; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\Gui\CommonControl\MyListCtrl.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??0MYLIST_COLUMN_IMAGE@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MYLIST_COLUMN_INFO@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4MYLIST_COLUMN_INFO@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadSkin@CMyListCtrl@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShowItemToolTip@CMyListCtrl@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShowSubItemToolTip@CMyListCtrl@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SortFunction@CMyListCtrl@@UAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemIdxByKey@CMyListCtrl@@UAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMyListCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBasicSkinWnd@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MYLIST_COLUMN_INFO@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABHABUMYLIST_COLUMN_INFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MYLIST_COLUMN_INFO@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAE@PAUMYLIST_COLUMN_INFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$back_inserter@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@AAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@HV?$allocator@H@std@@@0@AAV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAHIH@std@@YAXPAHIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_ECMyListCtrl@@WFE@AEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CMyListCtrl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CMyListCtrl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1FE@?0A@A@CBasicSkinWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CCmdTarget@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CListCtrl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCListCtrl@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CMyListCtrl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCBasicSkinWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCMyListCtrl@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CMyListCtrl@@6BCBasicSkinWnd@@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?EndModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BeginModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4CMyListCtrl@@6BCListCtrl@@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Invalidate@CWnd@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@UtagPOINT@@UtagSIZE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CenterPoint@CRect@@QBE?AVCPoint@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFocus@CWnd@@SGPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItem@CListCtrl@@QBEHPAUtagLVITEMA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCRect@@QBEPBUtagRECT@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBrush@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBrush@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CBrush@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCBrush@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CBrush@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CBrush@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBrush@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GCBrush@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FillRect@CDC@@QAEXPBUtagRECT@@PAVCBrush@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHandle@CGdiObject@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetItemData@CListCtrl@@QAEHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SortItems@CListCtrl@@QAEHP6GHJJJ@ZK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SubItemHitTest@CListCtrl@@QAEHPAUtagLVHITTESTINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8CPoint@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?s_pt@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4V3@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?$S5@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4IA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?GetItemCount@CListCtrl@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetColumnWidth@CListCtrl@@QBEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUpdateRect@CWnd@@QAEHPAUtagRECT@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCRect@@QAEPAUtagRECT@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertColumn@CListCtrl@@QAEHHPBUtagLVCOLUMNA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParent@CWnd@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_messageEntries@CMyListCtrl@@0QBUAFX_MSGMAP_ENTRY@@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messageMap@CMyListCtrl@@1UAFX_MSGMAP@@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBasicSkinWnd@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CBasicSkinWnd@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CBasicSkinWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CBasicSkinWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBasicSkinWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCBasicSkinWnd@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFont@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CFont@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCFont@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCFont@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFont@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMyListCtrl@@6BCBasicSkinWnd@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMyListCtrl@@6BCListCtrl@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CBasicSkinWnd@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CListCtrl@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CListCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CListCtrl@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CListCtrl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CListCtrl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCListCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_messageEntries@CMyListCtrl@@0QBUAFX_MSGMAP_ENTRY@@B ; CMyListCtrl::_messageEntries
PUBLIC	?messageMap@CMyListCtrl@@1UAFX_MSGMAP@@B	; CMyListCtrl::messageMap
PUBLIC	?OnDestroy@CMyListCtrl@@IAEXXZ			; CMyListCtrl::OnDestroy
PUBLIC	?OnCreate@CMyListCtrl@@IAEHPAUtagCREATESTRUCTA@@@Z ; CMyListCtrl::OnCreate
PUBLIC	?OnEraseBkgnd@CMyListCtrl@@IAEHPAVCDC@@@Z	; CMyListCtrl::OnEraseBkgnd
PUBLIC	?MeasureItem@CMyListCtrl@@IAEXPAUtagMEASUREITEMSTRUCT@@@Z ; CMyListCtrl::MeasureItem
PUBLIC	?OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z	; CMyListCtrl::OnMouseMove
PUBLIC	?OnMouseLeave@CMyListCtrl@@IAEJIJ@Z		; CMyListCtrl::OnMouseLeave
PUBLIC	?OnPaint@CMyListCtrl@@IAEXXZ			; CMyListCtrl::OnPaint
PUBLIC	?OnColumnclickList@CMyListCtrl@@IAEXPAUtagNMHDR@@PAJ@Z ; CMyListCtrl::OnColumnclickList
PUBLIC	?OnCoolSBCustomdraw@CMyListCtrl@@IAEXPAUtagNMHDR@@PAJ@Z ; CMyListCtrl::OnCoolSBCustomdraw
EXTRN	?GetThisMessageMap@CListCtrl@@KGPBUAFX_MSGMAP@@XZ:NEAR ; CListCtrl::GetThisMessageMap
_BSS	SEGMENT
_mkey1	DD	01H DUP (?)
_mkey2	DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_clrOddItemBK DD 0333333H
_clrEvenItemBK DD 02c2c2dH
_DATA	ENDS
CONST	SEGMENT
$SG199526 DB	0cbH, 0ceH, 0ccH, 0e5H, 00H
CONST	ENDS
;	COMDAT ?_messageEntries@CMyListCtrl@@0QBUAFX_MSGMAP_ENTRY@@B
CONST	SEGMENT
?_messageEntries@CMyListCtrl@@0QBUAFX_MSGMAP_ENTRY@@B DD 01H ; CMyListCtrl::_messageEntries
	DD	00H
	DD	00H
	DD	00H
	DD	0dH
	DD	FLAT:?OnCreate@CMyListCtrl@@IAEHPAUtagCREATESTRUCTA@@@Z
	DD	0bc2cH
	DD	00H
	DD	00H
	DD	00H
	DD	029H
	DD	FLAT:?MeasureItem@CMyListCtrl@@IAEXPAUtagMEASUREITEMSTRUCT@@@Z
	DD	0200H
	DD	00H
	DD	00H
	DD	00H
	DD	032H
	DD	FLAT:?OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z
	DD	02a3H
	DD	00H
	DD	00H
	DD	00H
	DD	0eH
	DD	FLAT:?OnMouseLeave@CMyListCtrl@@IAEJIJ@Z
	DD	0bc4eH
	DD	0ff94H
	DD	00H
	DD	00H
	DD	039H
	DD	FLAT:?OnColumnclickList@CMyListCtrl@@IAEXPAUtagNMHDR@@PAJ@Z
	DD	0bc4eH
	DD	0f001H
	DD	00H
	DD	00H
	DD	039H
	DD	FLAT:?OnCoolSBCustomdraw@CMyListCtrl@@IAEXPAUtagNMHDR@@PAJ@Z
	DD	014H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:?OnEraseBkgnd@CMyListCtrl@@IAEHPAVCDC@@@Z
	DD	0fH
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	FLAT:?OnPaint@CMyListCtrl@@IAEXXZ
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	FLAT:?OnDestroy@CMyListCtrl@@IAEXXZ
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?messageMap@CMyListCtrl@@1UAFX_MSGMAP@@B
CONST	SEGMENT
?messageMap@CMyListCtrl@@1UAFX_MSGMAP@@B DD FLAT:?GetThisMessageMap@CListCtrl@@KGPBUAFX_MSGMAP@@XZ ; CMyListCtrl::messageMap
	DD	FLAT:?_messageEntries@CMyListCtrl@@0QBUAFX_MSGMAP_ENTRY@@B
CONST	ENDS
CONST	SEGMENT
$SG199874 DB	00H
	ORG $+2
$SG199875 DB	'tooltips_class32', 00H
	ORG $+3
$SG200264 DB	'ListHoverBK', 00H
CONST	ENDS
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CWnd@@8				; CWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCWnd@@@8				; CWnd `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CCmdTarget@@8			; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCCmdTarget@@@8				; CCmdTarget `RTTI Type Descriptor'
PUBLIC	??_R0?AVCBasicSkinWnd@@@8			; CBasicSkinWnd `RTTI Type Descriptor'
PUBLIC	??1CBasicSkinWnd@@UAE@XZ			; CBasicSkinWnd::~CBasicSkinWnd
PUBLIC	??0CBasicSkinWnd@@QAE@XZ			; CBasicSkinWnd::CBasicSkinWnd
PUBLIC	??0?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	??1?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::~map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	??0CMyListCtrl@@QAE@XZ				; CMyListCtrl::CMyListCtrl
PUBLIC	?GetMessageMap@CMyListCtrl@@MBEPBUAFX_MSGMAP@@XZ ; CMyListCtrl::GetMessageMap
PUBLIC	?DrawItem@CMyListCtrl@@MAEXPAUtagDRAWITEMSTRUCT@@@Z ; CMyListCtrl::DrawItem
PUBLIC	?LoadSkin@CMyListCtrl@@UAEXXZ			; CMyListCtrl::LoadSkin
PUBLIC	?CreateControl@CMyListCtrl@@UAEXHPAVCWnd@@@Z	; CMyListCtrl::CreateControl
PUBLIC	?DrawTextColumn@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z ; CMyListCtrl::DrawTextColumn
PUBLIC	?DrawImageColumn@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@H@Z ; CMyListCtrl::DrawImageColumn
PUBLIC	??_R0?AVCListCtrl@@@8				; CListCtrl `RTTI Type Descriptor'
PUBLIC	?NeedChangeCursor@CMyListCtrl@@UAEHAAVCPoint@@@Z ; CMyListCtrl::NeedChangeCursor
PUBLIC	??_R1A@?0A@A@CListCtrl@@8			; CListCtrl::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?SetItemTextColor@CMyListCtrl@@UAEXPAVCDC@@HH@Z	; CMyListCtrl::SetItemTextColor
PUBLIC	?SetItemBkColor@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z ; CMyListCtrl::SetItemBkColor
PUBLIC	?ShowItemToolTip@CMyListCtrl@@UAEXHH@Z		; CMyListCtrl::ShowItemToolTip
PUBLIC	?ShowSubItemToolTip@CMyListCtrl@@UAEXHH@Z	; CMyListCtrl::ShowSubItemToolTip
PUBLIC	?HideToolTip@CMyListCtrl@@UAEXXZ		; CMyListCtrl::HideToolTip
PUBLIC	?SortFunction@CMyListCtrl@@UAEHHH@Z		; CMyListCtrl::SortFunction
PUBLIC	?SetKeySubItem@CMyListCtrl@@UAEXH@Z		; CMyListCtrl::SetKeySubItem
PUBLIC	?GetItemIdxByKey@CMyListCtrl@@UAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z ; CMyListCtrl::GetItemIdxByKey
PUBLIC	?PreTranslateMessage@CMyListCtrl@@UAEHPAUtagMSG@@@Z ; CMyListCtrl::PreTranslateMessage
PUBLIC	??_7CMyListCtrl@@6BCListCtrl@@@			; CMyListCtrl::`vftable'
PUBLIC	??_7CMyListCtrl@@6BCBasicSkinWnd@@@		; CMyListCtrl::`vftable'
PUBLIC	??_GCMyListCtrl@@UAEPAXI@Z			; CMyListCtrl::`scalar deleting destructor'
PUBLIC	??0CFont@@QAE@XZ				; CFont::CFont
PUBLIC	??1CFont@@UAE@XZ				; CFont::~CFont
PUBLIC	??_R4CMyListCtrl@@6BCListCtrl@@@		; CMyListCtrl::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMyListCtrl@@@8				; CMyListCtrl `RTTI Type Descriptor'
PUBLIC	??_R3CMyListCtrl@@8				; CMyListCtrl::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMyListCtrl@@8				; CMyListCtrl::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CMyListCtrl@@8			; CMyListCtrl::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1FE@?0A@A@CBasicSkinWnd@@8			; CBasicSkinWnd::`RTTI Base Class Descriptor at (84,-1,0,0)'
PUBLIC	??_ECMyListCtrl@@WFE@AEPAXI@Z			; [thunk]:CMyListCtrl::`vector deleting destructor'
PUBLIC	??_R4CMyListCtrl@@6BCBasicSkinWnd@@@		; CMyListCtrl::`RTTI Complete Object Locator'
PUBLIC	?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z	; CWnd::DoDataExchange
PUBLIC	?BeginModalState@CWnd@@UAEXXZ			; CWnd::BeginModalState
PUBLIC	?EndModalState@CWnd@@UAEXXZ			; CWnd::EndModalState
PUBLIC	??0CListCtrl@@QAE@XZ				; CListCtrl::CListCtrl
EXTRN	?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z:NEAR ; CWnd::CreateControlContainer
EXTRN	?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z:NEAR ; CWnd::CreateControlSite
EXTRN	?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:NEAR ; CWnd::SetOccDialogInfo
EXTRN	__purecall:NEAR
EXTRN	?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z:NEAR ; CWnd::OnToolHitTest
EXTRN	?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z:NEAR ; CWnd::GetScrollBarCtrl
EXTRN	??1CListCtrl@@UAE@XZ:NEAR			; CListCtrl::~CListCtrl
EXTRN	?OnChildNotify@CListCtrl@@MAEHIIJPAJ@Z:NEAR	; CListCtrl::OnChildNotify
EXTRN	?WinHelpA@CWnd@@UAEXKI@Z:NEAR			; CWnd::WinHelpA
EXTRN	?HtmlHelpA@CWnd@@UAEXKI@Z:NEAR			; CWnd::HtmlHelpA
EXTRN	?WinHelpInternal@CWnd@@UAEXKI@Z:NEAR		; CWnd::WinHelpInternal
EXTRN	?ContinueModal@CWnd@@UAEHXZ:NEAR		; CWnd::ContinueModal
EXTRN	?EndModalLoop@CWnd@@UAEXH@Z:NEAR		; CWnd::EndModalLoop
EXTRN	?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ:NEAR ; CWnd::GetInterfaceMap
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?EnsureStdObj@CWnd@@UAEJXZ:NEAR			; CWnd::EnsureStdObj
EXTRN	?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z:NEAR ; CWnd::get_accParent
EXTRN	?get_accChildCount@CWnd@@UAEJPAJ@Z:NEAR		; CWnd::get_accChildCount
EXTRN	?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:NEAR ; CCmdTarget::OnCmdMsg
EXTRN	?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z:NEAR ; CWnd::get_accChild
EXTRN	?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z:NEAR	; CCmdTarget::IsInvokeAllowed
EXTRN	?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accName
EXTRN	?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accValue
EXTRN	?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accDescription
EXTRN	?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z:NEAR ; CCmdTarget::GetDispatchIID
EXTRN	?GetTypeInfoCount@CCmdTarget@@UAEIXZ:NEAR	; CCmdTarget::GetTypeInfoCount
EXTRN	?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ:NEAR ; CCmdTarget::GetTypeLibCache
EXTRN	?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:NEAR ; CWnd::get_accRole
EXTRN	?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z:NEAR ; CCmdTarget::GetTypeLib
EXTRN	?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:NEAR ; CWnd::get_accState
EXTRN	?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accHelp
EXTRN	?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z:NEAR ; CWnd::get_accHelpTopic
EXTRN	?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accKeyboardShortcut
EXTRN	?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z:NEAR	; CWnd::get_accFocus
EXTRN	?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z:NEAR ; CWnd::get_accSelection
EXTRN	?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accDefaultAction
EXTRN	?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ:NEAR ; CCmdTarget::GetCommandMap
EXTRN	?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z:NEAR	; CWnd::accSelect
EXTRN	?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z:NEAR ; CWnd::accLocation
EXTRN	?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ:NEAR ; CCmdTarget::GetDispatchMap
EXTRN	?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z:NEAR ; CWnd::accNavigate
EXTRN	?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z:NEAR	; CWnd::accHitTest
EXTRN	?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ:NEAR ; CCmdTarget::GetConnectionMap
EXTRN	?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z:NEAR ; CWnd::accDoDefaultAction
EXTRN	?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z:NEAR	; CWnd::put_accName
EXTRN	?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z:NEAR ; CWnd::put_accValue
EXTRN	?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z:NEAR ; CWnd::SetProxy
EXTRN	?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z:NEAR	; CWnd::CreateAccessibleProxy
EXTRN	?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ:NEAR ; CCmdTarget::GetEventSinkMap
EXTRN	?OnCreateAggregates@CCmdTarget@@UAEHXZ:NEAR	; CCmdTarget::OnCreateAggregates
EXTRN	?OnCommand@CWnd@@MAEHIJ@Z:NEAR			; CWnd::OnCommand
EXTRN	?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z:NEAR ; CCmdTarget::GetInterfaceHook
EXTRN	?OnNotify@CWnd@@MAEHIJPAJ@Z:NEAR		; CWnd::OnNotify
EXTRN	?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z:NEAR ; CCmdTarget::GetExtraConnectionPoints
EXTRN	?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z:NEAR ; CCmdTarget::GetConnectionHook
EXTRN	??_ECMyListCtrl@@UAEPAXI@Z:NEAR			; CMyListCtrl::`vector deleting destructor'
EXTRN	??0CCWToolTips@@QAE@XZ:NEAR			; CCWToolTips::CCWToolTips
EXTRN	??1CCWToolTips@@UAE@XZ:NEAR			; CCWToolTips::~CCWToolTips
EXTRN	?CreatePointFont@CFont@@QAEHHPBDPAVCDC@@@Z:NEAR	; CFont::CreatePointFont
EXTRN	?PreSubclassWindow@CWnd@@UAEXXZ:NEAR		; CWnd::PreSubclassWindow
EXTRN	?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z:NEAR ; CWnd::Create
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z:NEAR ; CWnd::CreateEx
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z:NEAR ; CWnd::CreateEx
EXTRN	?DestroyWindow@CWnd@@UAEHXZ:NEAR		; CWnd::DestroyWindow
EXTRN	?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z:NEAR ; CWnd::PreCreateWindow
EXTRN	?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z:NEAR	; CWnd::CalcWindowRect
EXTRN	?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ:NEAR ; CWnd::GetSuperWndProcAddr
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z:NEAR ; CWnd::OnAmbientProperty
EXTRN	?WindowProc@CWnd@@MAEJIIJ@Z:NEAR		; CWnd::WindowProc
EXTRN	?OnWndMsg@CWnd@@MAEHIIJPAJ@Z:NEAR		; CWnd::OnWndMsg
EXTRN	?DefWindowProcA@CWnd@@MAEJIIJ@Z:NEAR		; CWnd::DefWindowProcA
EXTRN	?PostNcDestroy@CWnd@@MAEXXZ:NEAR		; CWnd::PostNcDestroy
EXTRN	?CheckAutoCenter@CWnd@@UAEHXZ:NEAR		; CWnd::CheckAutoCenter
EXTRN	?GetRuntimeClass@CListCtrl@@UBEPAUCRuntimeClass@@XZ:NEAR ; CListCtrl::GetRuntimeClass
EXTRN	?Create@CListCtrl@@UAEHKABUtagRECT@@PAVCWnd@@I@Z:NEAR ; CListCtrl::Create
EXTRN	?CreateEx@CListCtrl@@UAEHKKABUtagRECT@@PAVCWnd@@I@Z:NEAR ; CListCtrl::CreateEx
EXTRN	?IsFrameWnd@CWnd@@UBEHXZ:NEAR			; CWnd::IsFrameWnd
EXTRN	?OnFinalRelease@CWnd@@UAEXXZ:NEAR		; CWnd::OnFinalRelease
xdata$x	SEGMENT
$T202193 DD	0ffffffffH
	DD	FLAT:$L202181
	DD	00H
	DD	FLAT:$L202182
	DD	01H
	DD	FLAT:$L202183
	DD	02H
	DD	FLAT:$L202184
	DD	03H
	DD	FLAT:$L202185
	DD	04H
	DD	FLAT:$L202186
$T202190 DD	019930520H
	DD	06H
	DD	FLAT:$T202193
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CMyListCtrl@@6BCListCtrl@@@
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\mylistctrl.cpp
CONST	SEGMENT
??_7CMyListCtrl@@6BCListCtrl@@@ DD FLAT:??_R4CMyListCtrl@@6BCListCtrl@@@ ; CMyListCtrl::`vftable'
	DD	FLAT:?GetRuntimeClass@CListCtrl@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECMyListCtrl@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CMyListCtrl@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CMyListCtrl@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CListCtrl@@MAEHIIJPAJ@Z
	DD	FLAT:?CheckAutoCenter@CWnd@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?Create@CListCtrl@@UAEHKABUtagRECT@@PAVCWnd@@I@Z
	DD	FLAT:?CreateEx@CListCtrl@@UAEHKKABUtagRECT@@PAVCWnd@@I@Z
	DD	FLAT:?DrawItem@CMyListCtrl@@MAEXPAUtagDRAWITEMSTRUCT@@@Z
	DD	FLAT:?CreateControl@CMyListCtrl@@UAEXHPAVCWnd@@@Z
	DD	FLAT:?DrawTextColumn@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z
	DD	FLAT:?DrawImageColumn@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@H@Z
	DD	FLAT:?NeedChangeCursor@CMyListCtrl@@UAEHAAVCPoint@@@Z
	DD	FLAT:__purecall
	DD	FLAT:?SetItemTextColor@CMyListCtrl@@UAEXPAVCDC@@HH@Z
	DD	FLAT:?SetItemBkColor@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z
	DD	FLAT:?ShowItemToolTip@CMyListCtrl@@UAEXHH@Z
	DD	FLAT:?ShowSubItemToolTip@CMyListCtrl@@UAEXHH@Z
	DD	FLAT:?HideToolTip@CMyListCtrl@@UAEXXZ
	DD	FLAT:?SortFunction@CMyListCtrl@@UAEHHH@Z
	DD	FLAT:?SetKeySubItem@CMyListCtrl@@UAEXH@Z
	DD	FLAT:?GetItemIdxByKey@CMyListCtrl@@UAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z
CONST	ENDS
;	COMDAT ??_7CMyListCtrl@@6BCBasicSkinWnd@@@
CONST	SEGMENT
??_7CMyListCtrl@@6BCBasicSkinWnd@@@ DD FLAT:??_R4CMyListCtrl@@6BCBasicSkinWnd@@@ ; CMyListCtrl::`vftable'
	DD	FLAT:??_ECMyListCtrl@@WFE@AEPAXI@Z
	DD	FLAT:?LoadSkin@CMyListCtrl@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4CMyListCtrl@@6BCListCtrl@@@
rdata$r	SEGMENT
??_R4CMyListCtrl@@6BCListCtrl@@@ DD 00H			; CMyListCtrl::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMyListCtrl@@@8
	DD	FLAT:??_R3CMyListCtrl@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMyListCtrl@@@8
_DATA	SEGMENT
??_R0?AVCMyListCtrl@@@8 DD FLAT:??_7type_info@@6B@	; CMyListCtrl `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMyListCtrl@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CMyListCtrl@@8
rdata$r	SEGMENT
??_R3CMyListCtrl@@8 DD 00H				; CMyListCtrl::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	06H
	DD	FLAT:??_R2CMyListCtrl@@8
rdata$r	ENDS
;	COMDAT ??_R2CMyListCtrl@@8
rdata$r	SEGMENT
??_R2CMyListCtrl@@8 DD FLAT:??_R1A@?0A@A@CMyListCtrl@@8	; CMyListCtrl::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CListCtrl@@8
	DD	FLAT:??_R1A@?0A@A@CWnd@@8
	DD	FLAT:??_R1A@?0A@A@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
	DD	FLAT:??_R1FE@?0A@A@CBasicSkinWnd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMyListCtrl@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CMyListCtrl@@8 DD FLAT:??_R0?AVCMyListCtrl@@@8 ; CMyListCtrl::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CListCtrl@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CListCtrl@@8 DD FLAT:??_R0?AVCListCtrl@@@8	; CListCtrl::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCListCtrl@@@8
_DATA	SEGMENT
??_R0?AVCListCtrl@@@8 DD FLAT:??_7type_info@@6B@	; CListCtrl `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCListCtrl@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CWnd@@8 DD FLAT:??_R0?AVCWnd@@@8		; CWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCWnd@@@8
_DATA	SEGMENT
??_R0?AVCWnd@@@8 DD FLAT:??_7type_info@@6B@		; CWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CCmdTarget@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CCmdTarget@@8 DD FLAT:??_R0?AVCCmdTarget@@@8 ; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
_DATA	SEGMENT
??_R0?AVCCmdTarget@@@8 DD FLAT:??_7type_info@@6B@	; CCmdTarget `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCmdTarget@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
_DATA	ENDS
;	COMDAT ??_R1FE@?0A@A@CBasicSkinWnd@@8
rdata$r	SEGMENT
??_R1FE@?0A@A@CBasicSkinWnd@@8 DD FLAT:??_R0?AVCBasicSkinWnd@@@8 ; CBasicSkinWnd::`RTTI Base Class Descriptor at (84,-1,0,0)'
	DD	00H
	DD	054H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCBasicSkinWnd@@@8
_DATA	SEGMENT
??_R0?AVCBasicSkinWnd@@@8 DD FLAT:??_7type_info@@6B@	; CBasicSkinWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBasicSkinWnd@@', 00H
	ORG $-28
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVCBasicSkinWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CMyListCtrl@@6BCBasicSkinWnd@@@
rdata$r	SEGMENT
??_R4CMyListCtrl@@6BCBasicSkinWnd@@@ DD 00H		; CMyListCtrl::`RTTI Complete Object Locator'
	DD	054H
	DD	00H
	DD	FLAT:??_R0?AVCMyListCtrl@@@8
	DD	FLAT:??_R3CMyListCtrl@@8
; Function compile flags: /Odt
rdata$r	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CMyListCtrl@@QAE@XZ PROC NEAR			; CMyListCtrl::CMyListCtrl
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CMyListCtrl@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0CListCtrl@@QAE@XZ	; CListCtrl::CListCtrl
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 54	 add	 ecx, 84			; 00000054H
  00031	e8 00 00 00 00	 call	 ??0CBasicSkinWnd@@QAE@XZ
  00036	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMyListCtrl@@6BCListCtrl@@@
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET FLAT:??_7CMyListCtrl@@6BCBasicSkinWnd@@@
  0004d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00050	c7 42 6c 00 00
	00 00		 mov	 DWORD PTR [edx+108], 0
  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0
  00061	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	83 c1 74	 add	 ecx, 116		; 00000074H
  00067	e8 00 00 00 00	 call	 ??0CFont@@QAE@XZ	; CFont::CFont
  0006c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00070	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	c7 41 7c 00 00
	00 00		 mov	 DWORD PTR [ecx+124], 0
  0007a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	c7 82 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+128], -1
  00087	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	c7 80 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+132], -1
  00094	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	c7 81 88 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+136], -1
  000a1	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a4	c7 82 8c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+140], -1
  000ae	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], 0
  000bb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  000c4	e8 00 00 00 00	 call	 ??0?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >
  000c9	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000cd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  000d6	e8 00 00 00 00	 call	 ??0CCWToolTips@@QAE@XZ	; CCWToolTips::CCWToolTips
  000db	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000df	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	c6 81 30 01 00
	00 00		 mov	 BYTE PTR [ecx+304], 0
  000e9	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000ec	c7 82 34 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+308], -1
  000f6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	81 c1 3c 01 00
	00		 add	 ecx, 316		; 0000013cH
  000ff	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00104	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00108	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0010b	c7 80 58 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+344], 1

; 30   : // 	m_bDrawItemTopLine	= false;
; 31   : 	m_clrOddItemBK		= RGB(51,51,51);		

  00115	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	c7 41 58 33 33
	33 00		 mov	 DWORD PTR [ecx+88], 3355443 ; 00333333H

; 32   : 	m_clrEvenItemBK		= RGB(45,44,44);		

  0011f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00122	c7 42 5c 2d 2c
	2c 00		 mov	 DWORD PTR [edx+92], 2894893 ; 002c2c2dH

; 33   : 	m_clrNormalItemText = RGB(255,0,0);

  00129	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0012c	c7 40 60 ff 00
	00 00		 mov	 DWORD PTR [eax+96], 255	; 000000ffH

; 34   : 	m_clrSelItemBK		= RGB(128,128,128);

  00133	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	c7 41 64 80 80
	80 00		 mov	 DWORD PTR [ecx+100], 8421504 ; 00808080H

; 35   : 	m_clrSelItemText	= RGB(255,0,0);

  0013d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00140	c7 42 68 ff 00
	00 00		 mov	 DWORD PTR [edx+104], 255 ; 000000ffH

; 36   : 	
; 37   : 	m_font.CreatePointFont(90,_T(""));

  00147	6a 00		 push	 0
  00149	68 00 00 00 00	 push	 OFFSET FLAT:$SG199526
  0014e	6a 5a		 push	 90			; 0000005aH
  00150	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	83 c1 74	 add	 ecx, 116		; 00000074H
  00156	e8 00 00 00 00	 call	 ?CreatePointFont@CFont@@QAEHHPBDPAVCDC@@@Z ; CFont::CreatePointFont

; 38   : 	m_bDrawHoverRow = true;

  0015b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0015e	c6 80 54 01 00
	00 01		 mov	 BYTE PTR [eax+340], 1

; 39   : 	m_bInit = false;

  00165	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	c6 81 38 01 00
	00 00		 mov	 BYTE PTR [ecx+312], 0

; 40   : }

  0016f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00176	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00179	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202181:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CListCtrl@@UAE@XZ	; CListCtrl::~CListCtrl
$L202182:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 54	 add	 ecx, 84			; 00000054H
  0000e	e9 00 00 00 00	 jmp	 ??1CBasicSkinWnd@@UAE@XZ ; CBasicSkinWnd::~CBasicSkinWnd
$L202183:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 74	 add	 ecx, 116		; 00000074H
  00019	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
$L202184:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  00027	e9 00 00 00 00	 jmp	 ??1?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ
$L202185:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00035	e9 00 00 00 00	 jmp	 ??1CCWToolTips@@UAE@XZ	; CCWToolTips::~CCWToolTips
$L202186:
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	81 c1 3c 01 00
	00		 add	 ecx, 316		; 0000013cH
  00043	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$??0CMyListCtrl@@QAE@XZ:
  00048	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202190
  0004d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CMyListCtrl@@QAE@XZ ENDP				; CMyListCtrl::CMyListCtrl
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\mylistctrl.h
;	COMDAT ?LoadSkin@CMyListCtrl@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LoadSkin@CMyListCtrl@@UAEXXZ PROC NEAR			; CMyListCtrl::LoadSkin, COMDAT
; _this$ = ecx

; 75   : 	virtual void	LoadSkin(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?LoadSkin@CMyListCtrl@@UAEXXZ ENDP			; CMyListCtrl::LoadSkin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ShowItemToolTip@CMyListCtrl@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iItem$ = 8						; size = 4
_iSubItem$ = 12						; size = 4
?ShowItemToolTip@CMyListCtrl@@UAEXHH@Z PROC NEAR	; CMyListCtrl::ShowItemToolTip, COMDAT
; _this$ = ecx

; 84   : 	virtual void	ShowItemToolTip( int iItem,int iSubItem ){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 08 00	 ret	 8
?ShowItemToolTip@CMyListCtrl@@UAEXHH@Z ENDP		; CMyListCtrl::ShowItemToolTip
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ShowSubItemToolTip@CMyListCtrl@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iItem$ = 8						; size = 4
_iSubItem$ = 12						; size = 4
?ShowSubItemToolTip@CMyListCtrl@@UAEXHH@Z PROC NEAR	; CMyListCtrl::ShowSubItemToolTip, COMDAT
; _this$ = ecx

; 85   : 	virtual void	ShowSubItemToolTip(int iItem,int iSubItem ){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 08 00	 ret	 8
?ShowSubItemToolTip@CMyListCtrl@@UAEXHH@Z ENDP		; CMyListCtrl::ShowSubItemToolTip
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SortFunction@CMyListCtrl@@UAEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iItem1$ = 8						; size = 4
_iItem2$ = 12						; size = 4
?SortFunction@CMyListCtrl@@UAEHHH@Z PROC NEAR		; CMyListCtrl::SortFunction, COMDAT
; _this$ = ecx

; 87   : 	virtual int		SortFunction(int iItem1,int iItem2){return 0;}; 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?SortFunction@CMyListCtrl@@UAEHHH@Z ENDP		; CMyListCtrl::SortFunction
_TEXT	ENDS
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetItemIdxByKey@CMyListCtrl@@UAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_strKey$ = 8						; size = 28
_vecIdx$ = 36						; size = 4
?GetItemIdxByKey@CMyListCtrl@@UAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z PROC NEAR ; CMyListCtrl::GetItemIdxByKey, COMDAT
; _this$ = ecx

; 89   : 	virtual void	GetItemIdxByKey(string strKey,vector<int> &vecIdx){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 4d 08	 lea	 ecx, DWORD PTR _strKey$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 20 00	 ret	 32			; 00000020H
?GetItemIdxByKey@CMyListCtrl@@UAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z ENDP ; CMyListCtrl::GetItemIdxByKey
_TEXT	ENDS
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
PUBLIC	??1CMyListCtrl@@UAE@XZ				; CMyListCtrl::~CMyListCtrl
; Function compile flags: /Odt
;	COMDAT ??_GCMyListCtrl@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCMyListCtrl@@UAEPAXI@Z PROC NEAR			; CMyListCtrl::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMyListCtrl@@UAE@XZ	; CMyListCtrl::~CMyListCtrl
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L199530
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L199530:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCMyListCtrl@@UAEPAXI@Z ENDP				; CMyListCtrl::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4CBasicSkinWnd@@6B@				; CBasicSkinWnd::`RTTI Complete Object Locator'
PUBLIC	??_R3CBasicSkinWnd@@8				; CBasicSkinWnd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBasicSkinWnd@@8				; CBasicSkinWnd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CBasicSkinWnd@@8			; CBasicSkinWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_7CBasicSkinWnd@@6B@				; CBasicSkinWnd::`vftable'
PUBLIC	??_GCBasicSkinWnd@@UAEPAXI@Z			; CBasicSkinWnd::`scalar deleting destructor'
EXTRN	??_ECBasicSkinWnd@@UAEPAXI@Z:NEAR		; CBasicSkinWnd::`vector deleting destructor'
;	COMDAT ??_7CBasicSkinWnd@@6B@
CONST	SEGMENT
??_7CBasicSkinWnd@@6B@ DD FLAT:??_R4CBasicSkinWnd@@6B@	; CBasicSkinWnd::`vftable'
	DD	FLAT:??_ECBasicSkinWnd@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4CBasicSkinWnd@@6B@
rdata$r	SEGMENT
??_R4CBasicSkinWnd@@6B@ DD 00H				; CBasicSkinWnd::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBasicSkinWnd@@@8
	DD	FLAT:??_R3CBasicSkinWnd@@8
rdata$r	ENDS
;	COMDAT ??_R3CBasicSkinWnd@@8
rdata$r	SEGMENT
??_R3CBasicSkinWnd@@8 DD 00H				; CBasicSkinWnd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CBasicSkinWnd@@8
rdata$r	ENDS
;	COMDAT ??_R2CBasicSkinWnd@@8
rdata$r	SEGMENT
??_R2CBasicSkinWnd@@8 DD FLAT:??_R1A@?0A@A@CBasicSkinWnd@@8 ; CBasicSkinWnd::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBasicSkinWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CBasicSkinWnd@@8 DD FLAT:??_R0?AVCBasicSkinWnd@@@8 ; CBasicSkinWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CBasicSkinWnd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CBasicSkinWnd@@QAE@XZ PROC NEAR			; CBasicSkinWnd::CBasicSkinWnd, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBasicSkinWnd@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0CBasicSkinWnd@@QAE@XZ ENDP				; CBasicSkinWnd::CBasicSkinWnd
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::~_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
; Function compile flags: /Odt
;	COMDAT ??1?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::~map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::~_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::~map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >
_TEXT	ENDS
EXTRN	?DeleteObject@CGdiObject@@QAEHXZ:NEAR		; CGdiObject::DeleteObject
xdata$x	SEGMENT
$T202227 DD	0ffffffffH
	DD	FLAT:$L202216
	DD	00H
	DD	FLAT:$L202219
	DD	01H
	DD	FLAT:$L202220
	DD	02H
	DD	FLAT:$L202221
	DD	03H
	DD	FLAT:$L202222
	DD	04H
	DD	FLAT:$L202223
$T202225 DD	019930520H
	DD	06H
	DD	FLAT:$T202227
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\mylistctrl.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv68 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CMyListCtrl@@UAE@XZ PROC NEAR			; CMyListCtrl::~CMyListCtrl
; _this$ = ecx

; 43   : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp
  00193	6a ff		 push	 -1
  00195	68 00 00 00 00	 push	 __ehhandler$??1CMyListCtrl@@UAE@XZ
  0019a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  001a0	50		 push	 eax
  001a1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  001a8	83 ec 08	 sub	 esp, 8
  001ab	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  001ae	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001b1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMyListCtrl@@6BCListCtrl@@@
  001b7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ba	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET FLAT:??_7CMyListCtrl@@6BCBasicSkinWnd@@@
  001c1	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5

; 44   : 	m_font.DeleteObject();

  001c8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001cb	83 c1 74	 add	 ecx, 116		; 00000074H
  001ce	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject

; 45   : }

  001d3	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  001d7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001da	81 c1 3c 01 00
	00		 add	 ecx, 316		; 0000013cH
  001e0	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  001e5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  001e9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ec	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  001f2	e8 00 00 00 00	 call	 ??1CCWToolTips@@UAE@XZ	; CCWToolTips::~CCWToolTips
  001f7	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001fb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001fe	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  00204	e8 00 00 00 00	 call	 ??1?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ
  00209	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0020d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00210	83 c1 74	 add	 ecx, 116		; 00000074H
  00213	e8 00 00 00 00	 call	 ??1CFont@@UAE@XZ	; CFont::~CFont
  00218	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0021c	83 7d f0 00	 cmp	 DWORD PTR _this$[ebp], 0
  00220	74 0b		 je	 SHORT $L202214
  00222	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00225	83 c2 54	 add	 edx, 84			; 00000054H
  00228	89 55 ec	 mov	 DWORD PTR tv68[ebp], edx
  0022b	eb 07		 jmp	 SHORT $L202215
$L202214:
  0022d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L202215:
  00234	8b 4d ec	 mov	 ecx, DWORD PTR tv68[ebp]
  00237	e8 00 00 00 00	 call	 ??1CBasicSkinWnd@@UAE@XZ ; CBasicSkinWnd::~CBasicSkinWnd
  0023c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00243	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00246	e8 00 00 00 00	 call	 ??1CListCtrl@@UAE@XZ	; CListCtrl::~CListCtrl
  0024b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0024e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00255	8b e5		 mov	 esp, ebp
  00257	5d		 pop	 ebp
  00258	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202216:
  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e9 00 00 00 00	 jmp	 ??1CListCtrl@@UAE@XZ	; CListCtrl::~CListCtrl
$L202219:
  0005a	83 7d f0 00	 cmp	 DWORD PTR _this$[ebp], 0
  0005e	0f 84 0e 00 00
	00		 je	 $L202217
  00064	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 c0 54	 add	 eax, 84			; 00000054H
  0006a	89 45 ec	 mov	 DWORD PTR tv68[ebp], eax
  0006d	e9 07 00 00 00	 jmp	 $L202218
$L202217:
  00072	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L202218:
  00079	8b 4d ec	 mov	 ecx, DWORD PTR tv68[ebp]
  0007c	e9 00 00 00 00	 jmp	 ??1CBasicSkinWnd@@UAE@XZ ; CBasicSkinWnd::~CBasicSkinWnd
$L202220:
  00081	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	83 c1 74	 add	 ecx, 116		; 00000074H
  00087	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
$L202221:
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  00095	e9 00 00 00 00	 jmp	 ??1?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ
$L202222:
  0009a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  000a3	e9 00 00 00 00	 jmp	 ??1CCWToolTips@@UAE@XZ	; CCWToolTips::~CCWToolTips
$L202223:
  000a8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	81 c1 3c 01 00
	00		 add	 ecx, 316		; 0000013cH
  000b1	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$??1CMyListCtrl@@UAE@XZ:
  000b6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202225
  000bb	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CMyListCtrl@@UAE@XZ ENDP				; CMyListCtrl::~CMyListCtrl
PUBLIC	?GetThisMessageMap@CMyListCtrl@@KGPBUAFX_MSGMAP@@XZ ; CMyListCtrl::GetThisMessageMap
; Function compile flags: /Odt
_TEXT	SEGMENT
?GetThisMessageMap@CMyListCtrl@@KGPBUAFX_MSGMAP@@XZ PROC NEAR ; CMyListCtrl::GetThisMessageMap

; 47   : BEGIN_MESSAGE_MAP(CMyListCtrl, CListCtrl)

  00260	55		 push	 ebp
  00261	8b ec		 mov	 ebp, esp
  00263	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?messageMap@CMyListCtrl@@1UAFX_MSGMAP@@B ; CMyListCtrl::messageMap
  00268	5d		 pop	 ebp
  00269	c3		 ret	 0
?GetThisMessageMap@CMyListCtrl@@KGPBUAFX_MSGMAP@@XZ ENDP ; CMyListCtrl::GetThisMessageMap
; Function compile flags: /Odt
_this$ = -4						; size = 4
?GetMessageMap@CMyListCtrl@@MBEPBUAFX_MSGMAP@@XZ PROC NEAR ; CMyListCtrl::GetMessageMap
; _this$ = ecx

; 47   : BEGIN_MESSAGE_MAP(CMyListCtrl, CListCtrl)

  00270	55		 push	 ebp
  00271	8b ec		 mov	 ebp, esp
  00273	51		 push	 ecx
  00274	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00277	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?messageMap@CMyListCtrl@@1UAFX_MSGMAP@@B ; CMyListCtrl::messageMap
  0027c	8b e5		 mov	 esp, ebp
  0027e	5d		 pop	 ebp
  0027f	c3		 ret	 0
?GetMessageMap@CMyListCtrl@@MBEPBUAFX_MSGMAP@@XZ ENDP	; CMyListCtrl::GetMessageMap
_TEXT	ENDS
EXTRN	?OnDestroy@CWnd@@IAEXXZ:NEAR			; CWnd::OnDestroy
EXTRN	_UninitializeCoolSB@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnDestroy@CMyListCtrl@@IAEXXZ PROC NEAR		; CMyListCtrl::OnDestroy
; _this$ = ecx

; 60   : {

  00280	55		 push	 ebp
  00281	8b ec		 mov	 ebp, esp
  00283	51		 push	 ecx
  00284	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 61   : 	m_tooltip.DestroyWindow();

  00287	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0028a	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00290	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00293	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  00299	ff 52 68	 call	 DWORD PTR [edx+104]

; 62   : 	if( m_bInit )

  0029c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0029f	0f b6 88 38 01
	00 00		 movzx	 ecx, BYTE PTR [eax+312]
  002a6	85 c9		 test	 ecx, ecx
  002a8	74 0c		 je	 SHORT $L199599

; 63   : 	{
; 64   : 		UninitializeCoolSB( m_hWnd );

  002aa	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002ad	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  002b0	50		 push	 eax
  002b1	e8 00 00 00 00	 call	 _UninitializeCoolSB@4
$L199599:

; 65   : 	}
; 66   : 	__super::OnDestroy();

  002b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b9	e8 00 00 00 00	 call	 ?OnDestroy@CWnd@@IAEXXZ	; CWnd::OnDestroy

; 67   : }

  002be	8b e5		 mov	 esp, ebp
  002c0	5d		 pop	 ebp
  002c1	c3		 ret	 0
?OnDestroy@CMyListCtrl@@IAEXXZ ENDP			; CMyListCtrl::OnDestroy
_TEXT	ENDS
PUBLIC	?size@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::size
PUBLIC	??A?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@I@Z ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::operator[]
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::clear
PUBLIC	??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[]
PUBLIC	?SetColumnInfo@CMyListCtrl@@QAEXABV?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@@Z ; CMyListCtrl::SetColumnInfo
PUBLIC	??4MYLIST_COLUMN_INFO@@QAEAAU0@ABU0@@Z		; MYLIST_COLUMN_INFO::operator=
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_idx$199605 = -4					; size = 4
_vecColumn$ = 8						; size = 4
?SetColumnInfo@CMyListCtrl@@QAEXABV?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@@Z PROC NEAR ; CMyListCtrl::SetColumnInfo
; _this$ = ecx

; 71   : {

  002d0	55		 push	 ebp
  002d1	8b ec		 mov	 ebp, esp
  002d3	83 ec 08	 sub	 esp, 8
  002d6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 72   : 	m_mapColumnInfo.clear();

  002d9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002dc	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  002e2	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::clear

; 73   : 	for( size_t idx = 0;idx <vecColumn.size();idx++ )

  002e7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _idx$199605[ebp], 0
  002ee	eb 09		 jmp	 SHORT $L199847
$L199848:
  002f0	8b 45 fc	 mov	 eax, DWORD PTR _idx$199605[ebp]
  002f3	83 c0 01	 add	 eax, 1
  002f6	89 45 fc	 mov	 DWORD PTR _idx$199605[ebp], eax
$L199847:
  002f9	8b 4d 08	 mov	 ecx, DWORD PTR _vecColumn$[ebp]
  002fc	e8 00 00 00 00	 call	 ?size@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::size
  00301	39 45 fc	 cmp	 DWORD PTR _idx$199605[ebp], eax
  00304	73 34		 jae	 SHORT $L199604

; 74   : 	{
; 75   : 		m_mapColumnInfo[vecColumn[idx].iColumnIndex] = vecColumn[idx];

  00306	8b 4d fc	 mov	 ecx, DWORD PTR _idx$199605[ebp]
  00309	51		 push	 ecx
  0030a	8b 4d 08	 mov	 ecx, DWORD PTR _vecColumn$[ebp]
  0030d	e8 00 00 00 00	 call	 ??A?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@I@Z ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::operator[]
  00312	50		 push	 eax
  00313	8b 55 fc	 mov	 edx, DWORD PTR _idx$199605[ebp]
  00316	52		 push	 edx
  00317	8b 4d 08	 mov	 ecx, DWORD PTR _vecColumn$[ebp]
  0031a	e8 00 00 00 00	 call	 ??A?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@I@Z ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::operator[]
  0031f	83 c0 20	 add	 eax, 32			; 00000020H
  00322	50		 push	 eax
  00323	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00326	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  0032c	e8 00 00 00 00	 call	 ??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[]
  00331	8b c8		 mov	 ecx, eax
  00333	e8 00 00 00 00	 call	 ??4MYLIST_COLUMN_INFO@@QAEAAU0@ABU0@@Z ; MYLIST_COLUMN_INFO::operator=

; 76   : 	}

  00338	eb b6		 jmp	 SHORT $L199848
$L199604:

; 77   : }

  0033a	8b e5		 mov	 esp, ebp
  0033c	5d		 pop	 ebp
  0033d	c2 04 00	 ret	 4
?SetColumnInfo@CMyListCtrl@@QAEXABV?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@@Z ENDP ; CMyListCtrl::SetColumnInfo
_TEXT	ENDS
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\mylistctrldata.h
;	COMDAT ??4MYLIST_COLUMN_INFO@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_columnInfo$ = 8					; size = 4
??4MYLIST_COLUMN_INFO@@QAEAAU0@ABU0@@Z PROC NEAR	; MYLIST_COLUMN_INFO::operator=, COMDAT
; _this$ = ecx

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 51   : 		strColumnName	= columnInfo.strColumnName;

  00007	8b 45 08	 mov	 eax, DWORD PTR _columnInfo$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 52   : 		enumColumnType	= columnInfo.enumColumnType;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 55 08	 mov	 edx, DWORD PTR _columnInfo$[ebp]
  0001a	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 53   : 		iColumnIndex	= columnInfo.iColumnIndex;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 55 08	 mov	 edx, DWORD PTR _columnInfo$[ebp]
  00026	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00029	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 54   : 		iColumnWidth	= columnInfo.iColumnWidth;

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 55 08	 mov	 edx, DWORD PTR _columnInfo$[ebp]
  00032	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00035	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 55   : 		bOperatorBtn	= columnInfo.bOperatorBtn;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 55 08	 mov	 edx, DWORD PTR _columnInfo$[ebp]
  0003e	8a 42 28	 mov	 al, BYTE PTR [edx+40]
  00041	88 41 28	 mov	 BYTE PTR [ecx+40], al

; 56   : 		ColumnImage		= columnInfo.ColumnImage;	

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _columnInfo$[ebp]
  00047	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0004a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	83 c2 2c	 add	 edx, 44			; 0000002cH
  00050	8b 01		 mov	 eax, DWORD PTR [ecx]
  00052	89 02		 mov	 DWORD PTR [edx], eax
  00054	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00057	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0005a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005d	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00060	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00063	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 57   : 		ColumnOperatorImage = columnInfo.ColumnOperatorImage;

  00066	8b 55 08	 mov	 edx, DWORD PTR _columnInfo$[ebp]
  00069	83 c2 3c	 add	 edx, 60			; 0000003cH
  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	83 c0 3c	 add	 eax, 60			; 0000003cH
  00072	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00074	89 08		 mov	 DWORD PTR [eax], ecx
  00076	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00079	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0007c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0007f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00082	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00085	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 58   : 		return *this;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 59   : 	}

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 04 00	 ret	 4
??4MYLIST_COLUMN_INFO@@QAEAAU0@ABU0@@Z ENDP		; MYLIST_COLUMN_INFO::operator=
_TEXT	ENDS
PUBLIC	?SetColor@CMyListCtrl@@QAEXKKKKK@Z		; CMyListCtrl::SetColor
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\mylistctrl.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_clrOddItemBK$ = 8					; size = 4
_clrEvenItemBK$ = 12					; size = 4
_clrNormalItemText$ = 16				; size = 4
_clrSelItemBK$ = 20					; size = 4
_clrSelItemText$ = 24					; size = 4
?SetColor@CMyListCtrl@@QAEXKKKKK@Z PROC NEAR		; CMyListCtrl::SetColor
; _this$ = ecx

; 80   : {

  00340	55		 push	 ebp
  00341	8b ec		 mov	 ebp, esp
  00343	51		 push	 ecx
  00344	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : 	m_clrOddItemBK		= clrOddItemBK;

  00347	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0034a	8b 4d 08	 mov	 ecx, DWORD PTR _clrOddItemBK$[ebp]
  0034d	89 48 58	 mov	 DWORD PTR [eax+88], ecx

; 82   : 	m_clrEvenItemBK		= clrEvenItemBK;

  00350	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00353	8b 45 0c	 mov	 eax, DWORD PTR _clrEvenItemBK$[ebp]
  00356	89 42 5c	 mov	 DWORD PTR [edx+92], eax

; 83   : 	m_clrNormalItemText = clrNormalItemText;

  00359	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0035c	8b 55 10	 mov	 edx, DWORD PTR _clrNormalItemText$[ebp]
  0035f	89 51 60	 mov	 DWORD PTR [ecx+96], edx

; 84   : 	m_clrSelItemBK		= clrSelItemBK;

  00362	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00365	8b 4d 14	 mov	 ecx, DWORD PTR _clrSelItemBK$[ebp]
  00368	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 85   : 	m_clrSelItemText	= clrSelItemText;

  0036b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0036e	8b 45 18	 mov	 eax, DWORD PTR _clrSelItemText$[ebp]
  00371	89 42 68	 mov	 DWORD PTR [edx+104], eax

; 86   : }

  00374	8b e5		 mov	 esp, ebp
  00376	5d		 pop	 ebp
  00377	c2 14 00	 ret	 20			; 00000014H
?SetColor@CMyListCtrl@@QAEXKKKKK@Z ENDP			; CMyListCtrl::SetColor
_TEXT	ENDS
PUBLIC	?SetScrollBitmap@CMyListCtrl@@QAEXPAVCDibBitmap@@0@Z ; CMyListCtrl::SetScrollBitmap
EXTRN	?GetWidth@CDibBitmap@@QAEHXZ:NEAR		; CDibBitmap::GetWidth
EXTRN	?GetHeight@CDibBitmap@@QAEHXZ:NEAR		; CDibBitmap::GetHeight
EXTRN	_CoolSB_SetMinThumbSize@12:NEAR
EXTRN	_CoolSB_SetSize@16:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_h$ = -8						; size = 4
_w$ = -4						; size = 4
_pBitmapVert$ = 8					; size = 4
_pBitmapHorz$ = 12					; size = 4
?SetScrollBitmap@CMyListCtrl@@QAEXPAVCDibBitmap@@0@Z PROC NEAR ; CMyListCtrl::SetScrollBitmap
; _this$ = ecx

; 89   : {

  00380	55		 push	 ebp
  00381	8b ec		 mov	 ebp, esp
  00383	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00386	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 90   : 	m_pBitmapScrollHorz = pBitmapHorz;

  00389	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0038c	8b 4d 0c	 mov	 ecx, DWORD PTR _pBitmapHorz$[ebp]
  0038f	89 48 70	 mov	 DWORD PTR [eax+112], ecx

; 91   : 	m_pBitmapScrollVert = pBitmapVert;

  00392	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00395	8b 45 08	 mov	 eax, DWORD PTR _pBitmapVert$[ebp]
  00398	89 42 6c	 mov	 DWORD PTR [edx+108], eax

; 92   : 
; 93   : 	int w,h;
; 94   : 	w = h = 15;

  0039b	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR _h$[ebp], 15	; 0000000fH
  003a2	8b 4d f8	 mov	 ecx, DWORD PTR _h$[ebp]
  003a5	89 4d fc	 mov	 DWORD PTR _w$[ebp], ecx

; 95   : 	if( m_pBitmapScrollHorz && m_pBitmapScrollVert )

  003a8	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  003ab	83 7a 70 00	 cmp	 DWORD PTR [edx+112], 0
  003af	74 35		 je	 SHORT $L199865
  003b1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  003b4	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  003b8	74 2c		 je	 SHORT $L199865

; 96   : 	{
; 97   : 		h = m_pBitmapScrollVert->GetHeight() / 3;

  003ba	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  003bd	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  003c0	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  003c5	99		 cdq
  003c6	b9 03 00 00 00	 mov	 ecx, 3
  003cb	f7 f9		 idiv	 ecx
  003cd	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax

; 98   : 		w = m_pBitmapScrollVert->GetWidth() / 6;

  003d0	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  003d3	8b 4a 6c	 mov	 ecx, DWORD PTR [edx+108]
  003d6	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  003db	99		 cdq
  003dc	b9 06 00 00 00	 mov	 ecx, 6
  003e1	f7 f9		 idiv	 ecx
  003e3	89 45 fc	 mov	 DWORD PTR _w$[ebp], eax
$L199865:

; 99   : 	}
; 100  : 	//InitializeCoolSB(m_hWnd);
; 101  : 	//CoolSB_SetStyle(m_hWnd, SB_BOTH, CSBS_HOTTRACKED);
; 102  : 	CoolSB_SetSize(m_hWnd, SB_BOTH, h, w);

  003e6	8b 55 fc	 mov	 edx, DWORD PTR _w$[ebp]
  003e9	52		 push	 edx
  003ea	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  003ed	50		 push	 eax
  003ee	6a 03		 push	 3
  003f0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  003f3	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  003f6	52		 push	 edx
  003f7	e8 00 00 00 00	 call	 _CoolSB_SetSize@16

; 103  : 	::CoolSB_SetMinThumbSize(m_hWnd, SB_BOTH, 8);

  003fc	6a 08		 push	 8
  003fe	6a 03		 push	 3
  00400	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00403	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00406	51		 push	 ecx
  00407	e8 00 00 00 00	 call	 _CoolSB_SetMinThumbSize@12

; 104  : 
; 105  : }

  0040c	8b e5		 mov	 esp, ebp
  0040e	5d		 pop	 ebp
  0040f	c2 08 00	 ret	 8
?SetScrollBitmap@CMyListCtrl@@QAEXPAVCDibBitmap@@0@Z ENDP ; CMyListCtrl::SetScrollBitmap
_TEXT	ENDS
PUBLIC	??0CRect@@QAE@HHHH@Z				; CRect::CRect
PUBLIC	?GetParent@CWnd@@QBEPAV1@XZ			; CWnd::GetParent
EXTRN	__imp__SendMessageA@16:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T202238 = -32						; size = 16
$T202237 = -16						; size = 16
_iID$ = 8						; size = 4
_pParent$ = 12						; size = 4
?CreateControl@CMyListCtrl@@UAEXHPAVCWnd@@@Z PROC NEAR	; CMyListCtrl::CreateControl
; _this$ = ecx

; 108  : {

  00420	55		 push	 ebp
  00421	8b ec		 mov	 ebp, esp
  00423	83 ec 24	 sub	 esp, 36			; 00000024H
  00426	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 	Create(WS_CHILD|WS_VISIBLE|WS_VSCROLL|LVS_SHOWSELALWAYS|LVS_REPORT|LVS_OWNERDRAWFIXED,CRect(0,0,0,0),pParent,iID);

  00429	8b 45 08	 mov	 eax, DWORD PTR _iID$[ebp]
  0042c	50		 push	 eax
  0042d	8b 4d 0c	 mov	 ecx, DWORD PTR _pParent$[ebp]
  00430	51		 push	 ecx
  00431	6a 00		 push	 0
  00433	6a 00		 push	 0
  00435	6a 00		 push	 0
  00437	6a 00		 push	 0
  00439	8d 4d f0	 lea	 ecx, DWORD PTR $T202237[ebp]
  0043c	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  00441	50		 push	 eax
  00442	68 09 04 20 50	 push	 1344275465		; 50200409H
  00447	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  0044a	8b 02		 mov	 eax, DWORD PTR [edx]
  0044c	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0044f	ff 90 38 01 00
	00		 call	 DWORD PTR [eax+312]

; 110  : 	ListView_SetExtendedListViewStyleEx ( m_hWnd,LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT );

  00455	6a 20		 push	 32			; 00000020H
  00457	6a 20		 push	 32			; 00000020H
  00459	68 36 10 00 00	 push	 4150			; 00001036H
  0045e	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00461	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00464	52		 push	 edx
  00465	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 111  : 
; 112  : 	m_tooltip.m_pClientWnd = this->GetParent();//AfxGetMainWindow();

  0046b	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0046e	e8 00 00 00 00	 call	 ?GetParent@CWnd@@QBEPAV1@XZ ; CWnd::GetParent
  00473	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00476	89 81 00 01 00
	00		 mov	 DWORD PTR [ecx+256], eax

; 113  : 	m_tooltip.m_hParent	 = m_hWnd;

  0047c	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  0047f	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00482	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00485	89 8a 28 01 00
	00		 mov	 DWORD PTR [edx+296], ecx

; 114  : 	m_tooltip.CreateEx(WS_EX_TOOLWINDOW|WS_EX_TOPMOST,TOOLTIPS_CLASS,"",TTS_ALWAYSTIP,CRect(0,0,0,0),NULL,0);	

  0048b	6a 00		 push	 0
  0048d	6a 00		 push	 0
  0048f	6a 00		 push	 0
  00491	6a 00		 push	 0
  00493	6a 00		 push	 0
  00495	6a 00		 push	 0
  00497	6a 00		 push	 0
  00499	8d 4d e0	 lea	 ecx, DWORD PTR $T202238[ebp]
  0049c	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  004a1	50		 push	 eax
  004a2	6a 01		 push	 1
  004a4	68 00 00 00 00	 push	 OFFSET FLAT:$SG199874
  004a9	68 00 00 00 00	 push	 OFFSET FLAT:$SG199875
  004ae	68 88 00 00 00	 push	 136			; 00000088H
  004b3	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  004b6	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  004bc	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  004bf	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  004c5	ff 50 60	 call	 DWORD PTR [eax+96]

; 115  : 	m_tooltip.m_clrBK = RGB(255, 255, 225);

  004c8	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  004cb	c7 81 fc 00 00
	00 ff ff e1 00	 mov	 DWORD PTR [ecx+252], 14811135 ; 00e1ffffH

; 116  : }

  004d5	8b e5		 mov	 esp, ebp
  004d7	5d		 pop	 ebp
  004d8	c2 08 00	 ret	 8
?CreateControl@CMyListCtrl@@UAEXHPAVCWnd@@@Z ENDP	; CMyListCtrl::CreateControl
_TEXT	ENDS
PUBLIC	?InsertColumn@CListCtrl@@QAEHHPBUtagLVCOLUMNA@@@Z ; CListCtrl::InsertColumn
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator!=
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::end
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator->
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++
PUBLIC	?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z	; CWnd::OnCreate
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
EXTRN	?InsertColumn@CListCtrl@@QAEHHPBDHHH@Z:NEAR	; CListCtrl::InsertColumn
EXTRN	?AfxGetUIManager@@YAPAVIUIManager@@XZ:NEAR	; AfxGetUIManager
; Function compile flags: /Odt
_TEXT	SEGMENT
tv154 = -64						; size = 4
tv149 = -60						; size = 4
tv159 = -56						; size = 4
_this$ = -52						; size = 4
$T202241 = -48						; size = 4
$T202240 = -44						; size = 4
_lvColumn$200001 = -40					; size = 32
_columnInfo$199976 = -8					; size = 4
_it$199969 = -4						; size = 4
_lp$ = 8						; size = 4
?OnCreate@CMyListCtrl@@IAEHPAUtagCREATESTRUCTA@@@Z PROC NEAR ; CMyListCtrl::OnCreate
; _this$ = ecx

; 119  : {

  004e0	55		 push	 ebp
  004e1	8b ec		 mov	 ebp, esp
  004e3	83 ec 40	 sub	 esp, 64			; 00000040H
  004e6	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 120  : 	InitColumnInfo();

  004e9	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  004ec	8b 10		 mov	 edx, DWORD PTR [eax]
  004ee	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  004f1	ff 92 54 01 00
	00		 call	 DWORD PTR [edx+340]

; 121  : 	LoadSkin();

  004f7	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  004fa	83 c1 54	 add	 ecx, 84			; 00000054H
  004fd	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00500	8b 50 54	 mov	 edx, DWORD PTR [eax+84]
  00503	ff 52 04	 call	 DWORD PTR [edx+4]

; 122  : 
; 123  : 	if( __super::OnCreate(lp) == -1 )

  00506	8b 45 08	 mov	 eax, DWORD PTR _lp$[ebp]
  00509	50		 push	 eax
  0050a	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0050d	e8 00 00 00 00	 call	 ?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z ; CWnd::OnCreate
  00512	83 f8 ff	 cmp	 eax, -1
  00515	75 08		 jne	 SHORT $L199886

; 124  : 	{
; 125  : 		return -1;

  00517	83 c8 ff	 or	 eax, -1
  0051a	e9 01 01 00 00	 jmp	 $L199885
$L199886:

; 126  : 	}
; 127  : 
; 128  : 	for(map<int,MYLIST_COLUMN_INFO>::iterator it = m_mapColumnInfo.begin();

  0051f	8d 4d fc	 lea	 ecx, DWORD PTR _it$199969[ebp]
  00522	51		 push	 ecx
  00523	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00526	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  0052c	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::begin

; 129  : 		it != m_mapColumnInfo.end();

  00531	eb 0e		 jmp	 SHORT $L199973
$L199974:

; 130  : 		it++)

  00533	6a 00		 push	 0
  00535	8d 55 d4	 lea	 edx, DWORD PTR $T202240[ebp]
  00538	52		 push	 edx
  00539	8d 4d fc	 lea	 ecx, DWORD PTR _it$199969[ebp]
  0053c	e8 00 00 00 00	 call	 ??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++
$L199973:
  00541	8d 45 d0	 lea	 eax, DWORD PTR $T202241[ebp]
  00544	50		 push	 eax
  00545	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00548	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  0054e	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::end
  00553	50		 push	 eax
  00554	8d 4d fc	 lea	 ecx, DWORD PTR _it$199969[ebp]
  00557	e8 00 00 00 00	 call	 ??9const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator!=
  0055c	0f b6 c8	 movzx	 ecx, al
  0055f	85 c9		 test	 ecx, ecx
  00561	74 7b		 je	 SHORT $L199975

; 131  : 	{
; 132  : 		MYLIST_COLUMN_INFO& columnInfo = it->second;

  00563	8d 4d fc	 lea	 ecx, DWORD PTR _it$199969[ebp]
  00566	e8 00 00 00 00	 call	 ??Citerator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator->
  0056b	83 c0 04	 add	 eax, 4
  0056e	89 45 f8	 mov	 DWORD PTR _columnInfo$199976[ebp], eax

; 133  : 		if( columnInfo.enumColumnType == MYLIST_COLUMN_INFO::COLUMN_TYPE_IMAGE)

  00571	8b 55 f8	 mov	 edx, DWORD PTR _columnInfo$199976[ebp]
  00574	83 7a 1c 01	 cmp	 DWORD PTR [edx+28], 1
  00578	75 29		 jne	 SHORT $L199999

; 134  : 		{
; 135  : 			InsertColumn( columnInfo.iColumnIndex, columnInfo.strColumnName.c_str(), LVCFMT_IMAGE,columnInfo.iColumnWidth  );

  0057a	6a ff		 push	 -1
  0057c	8b 45 f8	 mov	 eax, DWORD PTR _columnInfo$199976[ebp]
  0057f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00582	51		 push	 ecx
  00583	68 00 08 00 00	 push	 2048			; 00000800H
  00588	8b 4d f8	 mov	 ecx, DWORD PTR _columnInfo$199976[ebp]
  0058b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00591	50		 push	 eax
  00592	8b 55 f8	 mov	 edx, DWORD PTR _columnInfo$199976[ebp]
  00595	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00598	50		 push	 eax
  00599	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0059c	e8 00 00 00 00	 call	 ?InsertColumn@CListCtrl@@QAEHHPBDHHH@Z ; CListCtrl::InsertColumn

; 136  : 		}
; 137  : 		else

  005a1	eb 36		 jmp	 SHORT $L200000
$L199999:

; 138  : 		{
; 139  : 			LVCOLUMN lvColumn;
; 140  : 			lvColumn.mask		= LVCF_IMAGE | LVCF_TEXT | LVCF_FMT | LVCF_WIDTH;

  005a3	c7 45 d8 17 00
	00 00		 mov	 DWORD PTR _lvColumn$200001[ebp], 23 ; 00000017H

; 141  : 			lvColumn.fmt		= LVCFMT_LEFT; //LVCFMT_IMAGE | LVCF_TEXT;

  005aa	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _lvColumn$200001[ebp+4], 0

; 142  : 			//lvColumn.iSubItem	= columnInfo.iColumnIndex;
; 143  : 			lvColumn.cx			= columnInfo.iColumnWidth;

  005b1	8b 4d f8	 mov	 ecx, DWORD PTR _columnInfo$199976[ebp]
  005b4	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  005b7	89 55 e0	 mov	 DWORD PTR _lvColumn$200001[ebp+8], edx

; 144  : 			lvColumn.pszText	= (char*) columnInfo.strColumnName.c_str();

  005ba	8b 4d f8	 mov	 ecx, DWORD PTR _columnInfo$199976[ebp]
  005bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  005c3	89 45 e4	 mov	 DWORD PTR _lvColumn$200001[ebp+12], eax

; 145  : 
; 146  : 			InsertColumn( columnInfo.iColumnIndex,&lvColumn);

  005c6	8d 45 d8	 lea	 eax, DWORD PTR _lvColumn$200001[ebp]
  005c9	50		 push	 eax
  005ca	8b 4d f8	 mov	 ecx, DWORD PTR _columnInfo$199976[ebp]
  005cd	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  005d0	52		 push	 edx
  005d1	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  005d4	e8 00 00 00 00	 call	 ?InsertColumn@CListCtrl@@QAEHHPBUtagLVCOLUMNA@@@Z ; CListCtrl::InsertColumn
$L200000:

; 147  : 		}
; 148  : 	}

  005d9	e9 55 ff ff ff	 jmp	 $L199974
$L199975:

; 149  : 	AfxGetUIManager()->UIGetSkinMgr()->AddSkinWnd( this );

  005de	83 7d cc 00	 cmp	 DWORD PTR _this$[ebp], 0
  005e2	74 0b		 je	 SHORT $L202242
  005e4	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  005e7	83 c0 54	 add	 eax, 84			; 00000054H
  005ea	89 45 c8	 mov	 DWORD PTR tv159[ebp], eax
  005ed	eb 07		 jmp	 SHORT $L202243
$L202242:
  005ef	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv159[ebp], 0
$L202243:
  005f6	e8 00 00 00 00	 call	 ?AfxGetUIManager@@YAPAVIUIManager@@XZ ; AfxGetUIManager
  005fb	89 45 c4	 mov	 DWORD PTR tv149[ebp], eax
  005fe	8b 4d c4	 mov	 ecx, DWORD PTR tv149[ebp]
  00601	8b 11		 mov	 edx, DWORD PTR [ecx]
  00603	8b 4d c4	 mov	 ecx, DWORD PTR tv149[ebp]
  00606	ff 52 28	 call	 DWORD PTR [edx+40]
  00609	89 45 c0	 mov	 DWORD PTR tv154[ebp], eax
  0060c	8b 45 c8	 mov	 eax, DWORD PTR tv159[ebp]
  0060f	50		 push	 eax
  00610	8b 4d c0	 mov	 ecx, DWORD PTR tv154[ebp]
  00613	8b 11		 mov	 edx, DWORD PTR [ecx]
  00615	8b 4d c0	 mov	 ecx, DWORD PTR tv154[ebp]
  00618	ff 52 14	 call	 DWORD PTR [edx+20]

; 150  : 	return 1;

  0061b	b8 01 00 00 00	 mov	 eax, 1
$L199885:

; 151  : }

  00620	8b e5		 mov	 esp, ebp
  00622	5d		 pop	 ebp
  00623	c2 04 00	 ret	 4
?OnCreate@CMyListCtrl@@IAEHPAUtagCREATESTRUCTA@@@Z ENDP	; CMyListCtrl::OnCreate
_TEXT	ENDS
PUBLIC	?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z		; CWnd::GetClientRect
PUBLIC	?GetColumnWidth@CListCtrl@@QBEHH@Z		; CListCtrl::GetColumnWidth
PUBLIC	?GetUpdateRect@CWnd@@QAEHPAUtagRECT@@H@Z	; CWnd::GetUpdateRect
PUBLIC	?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z	; CWnd::InvalidateRect
PUBLIC	??0CRect@@QAE@XZ				; CRect::CRect
PUBLIC	??BCRect@@QAEPAUtagRECT@@XZ			; CRect::operator tagRECT *
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::size
EXTRN	?OnPaint@CWnd@@IAEXXZ:NEAR			; CWnd::OnPaint
EXTRN	_InitializeCoolSB@4:NEAR
EXTRN	_CoolSB_SetStyle@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -52						; size = 4
_i$200014 = -48						; size = 4
_h$200008 = -44						; size = 4
_w$200007 = -40						; size = 4
_rectClient$ = -36					; size = 16
_width$ = -20						; size = 4
_rectClip$ = -16					; size = 16
?OnPaint@CMyListCtrl@@IAEXXZ PROC NEAR			; CMyListCtrl::OnPaint
; _this$ = ecx

; 154  : {

  00630	55		 push	 ebp
  00631	8b ec		 mov	 ebp, esp
  00633	83 ec 34	 sub	 esp, 52			; 00000034H
  00636	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 155  : 	if(!m_bInit )

  00639	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0063c	0f b6 88 38 01
	00 00		 movzx	 ecx, BYTE PTR [eax+312]
  00643	85 c9		 test	 ecx, ecx
  00645	0f 85 97 00 00
	00		 jne	 $L200006

; 156  : 	{
; 157  : 		int w,h;
; 158  : 		w = h = 15;

  0064b	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _h$200008[ebp], 15 ; 0000000fH
  00652	8b 55 d4	 mov	 edx, DWORD PTR _h$200008[ebp]
  00655	89 55 d8	 mov	 DWORD PTR _w$200007[ebp], edx

; 159  : 
; 160  : 		if( m_pBitmapScrollHorz && m_pBitmapScrollVert )

  00658	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0065b	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  0065f	74 35		 je	 SHORT $L200009
  00661	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00664	83 79 6c 00	 cmp	 DWORD PTR [ecx+108], 0
  00668	74 2c		 je	 SHORT $L200009

; 161  : 		{
; 162  : 			h = m_pBitmapScrollVert->GetHeight() / 3;

  0066a	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0066d	8b 4a 6c	 mov	 ecx, DWORD PTR [edx+108]
  00670	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  00675	99		 cdq
  00676	b9 03 00 00 00	 mov	 ecx, 3
  0067b	f7 f9		 idiv	 ecx
  0067d	89 45 d4	 mov	 DWORD PTR _h$200008[ebp], eax

; 163  : 			w = m_pBitmapScrollVert->GetWidth() / 6;

  00680	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00683	8b 4a 6c	 mov	 ecx, DWORD PTR [edx+108]
  00686	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  0068b	99		 cdq
  0068c	b9 06 00 00 00	 mov	 ecx, 6
  00691	f7 f9		 idiv	 ecx
  00693	89 45 d8	 mov	 DWORD PTR _w$200007[ebp], eax
$L200009:

; 164  : 		}
; 165  : 
; 166  : 		InitializeCoolSB(m_hWnd);

  00696	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00699	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0069c	50		 push	 eax
  0069d	e8 00 00 00 00	 call	 _InitializeCoolSB@4

; 167  : 		CoolSB_SetStyle(m_hWnd, SB_BOTH, CSBS_HOTTRACKED);

  006a2	6a 02		 push	 2
  006a4	6a 03		 push	 3
  006a6	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  006a9	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  006ac	52		 push	 edx
  006ad	e8 00 00 00 00	 call	 _CoolSB_SetStyle@12

; 168  : 		CoolSB_SetSize(m_hWnd, SB_BOTH, h, w);

  006b2	8b 45 d8	 mov	 eax, DWORD PTR _w$200007[ebp]
  006b5	50		 push	 eax
  006b6	8b 4d d4	 mov	 ecx, DWORD PTR _h$200008[ebp]
  006b9	51		 push	 ecx
  006ba	6a 03		 push	 3
  006bc	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  006bf	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  006c2	50		 push	 eax
  006c3	e8 00 00 00 00	 call	 _CoolSB_SetSize@16

; 169  : 		::CoolSB_SetMinThumbSize(m_hWnd, SB_BOTH, 8);

  006c8	6a 08		 push	 8
  006ca	6a 03		 push	 3
  006cc	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  006cf	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  006d2	52		 push	 edx
  006d3	e8 00 00 00 00	 call	 _CoolSB_SetMinThumbSize@12

; 170  : 		m_bInit = true;

  006d8	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  006db	c6 80 38 01 00
	00 01		 mov	 BYTE PTR [eax+312], 1
$L200006:

; 171  : 	}
; 172  : 
; 173  :     CRect rectClient;

  006e2	8d 4d dc	 lea	 ecx, DWORD PTR _rectClient$[ebp]
  006e5	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 174  : 	GetClientRect(rectClient);

  006ea	8d 4d dc	 lea	 ecx, DWORD PTR _rectClient$[ebp]
  006ed	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  006f2	50		 push	 eax
  006f3	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  006f6	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 175  : 	CRect rectClip;

  006fb	8d 4d f0	 lea	 ecx, DWORD PTR _rectClip$[ebp]
  006fe	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 176  : 	GetUpdateRect(rectClip,FALSE);

  00703	6a 00		 push	 0
  00705	8d 4d f0	 lea	 ecx, DWORD PTR _rectClip$[ebp]
  00708	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  0070d	50		 push	 eax
  0070e	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00711	e8 00 00 00 00	 call	 ?GetUpdateRect@CWnd@@QAEHPAUtagRECT@@H@Z ; CWnd::GetUpdateRect

; 177  : 	if( rectClip.right < rectClient.right )

  00716	8b 4d f8	 mov	 ecx, DWORD PTR _rectClip$[ebp+8]
  00719	3b 4d e4	 cmp	 ecx, DWORD PTR _rectClient$[ebp+8]
  0071c	7d 06		 jge	 SHORT $L200012

; 178  : 	{
; 179  : 		rectClip.right = rectClient.right;

  0071e	8b 55 e4	 mov	 edx, DWORD PTR _rectClient$[ebp+8]
  00721	89 55 f8	 mov	 DWORD PTR _rectClip$[ebp+8], edx
$L200012:

; 180  : 	}
; 181  : 
; 182  : 	int width = 0;

  00724	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _width$[ebp], 0

; 183  : 	for(int i = 0 ; i<m_mapColumnInfo.size(); i++)

  0072b	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$200014[ebp], 0
  00732	eb 09		 jmp	 SHORT $L200015
$L200016:
  00734	8b 45 d0	 mov	 eax, DWORD PTR _i$200014[ebp]
  00737	83 c0 01	 add	 eax, 1
  0073a	89 45 d0	 mov	 DWORD PTR _i$200014[ebp], eax
$L200015:
  0073d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00740	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  00746	e8 00 00 00 00	 call	 ?size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::size
  0074b	39 45 d0	 cmp	 DWORD PTR _i$200014[ebp], eax
  0074e	73 14		 jae	 SHORT $L200017

; 184  : 		width += GetColumnWidth(i);

  00750	8b 4d d0	 mov	 ecx, DWORD PTR _i$200014[ebp]
  00753	51		 push	 ecx
  00754	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00757	e8 00 00 00 00	 call	 ?GetColumnWidth@CListCtrl@@QBEHH@Z ; CListCtrl::GetColumnWidth
  0075c	03 45 ec	 add	 eax, DWORD PTR _width$[ebp]
  0075f	89 45 ec	 mov	 DWORD PTR _width$[ebp], eax
  00762	eb d0		 jmp	 SHORT $L200016
$L200017:

; 185  : 
; 186  : 	if(rectClip.left >= width)

  00764	8b 55 f0	 mov	 edx, DWORD PTR _rectClip$[ebp]
  00767	3b 55 ec	 cmp	 edx, DWORD PTR _width$[ebp]
  0076a	7c 09		 jl	 SHORT $L200018

; 187  : 		rectClip.left = width -1;

  0076c	8b 45 ec	 mov	 eax, DWORD PTR _width$[ebp]
  0076f	83 e8 01	 sub	 eax, 1
  00772	89 45 f0	 mov	 DWORD PTR _rectClip$[ebp], eax
$L200018:

; 188  : 
; 189  : 	InvalidateRect( rectClip );

  00775	6a 01		 push	 1
  00777	8d 4d f0	 lea	 ecx, DWORD PTR _rectClip$[ebp]
  0077a	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  0077f	50		 push	 eax
  00780	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00783	e8 00 00 00 00	 call	 ?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::InvalidateRect

; 190  : 
; 191  : 	__super::OnPaint();

  00788	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0078b	e8 00 00 00 00	 call	 ?OnPaint@CWnd@@IAEXXZ	; CWnd::OnPaint

; 192  : }

  00790	8b e5		 mov	 esp, ebp
  00792	5d		 pop	 ebp
  00793	c3		 ret	 0
?OnPaint@CMyListCtrl@@IAEXXZ ENDP			; CMyListCtrl::OnPaint
_TEXT	ENDS
PUBLIC	?GetWindowRect@CWnd@@QBEXPAUtagRECT@@@Z		; CWnd::GetWindowRect
PUBLIC	?GetItemCount@CListCtrl@@QBEHXZ			; CListCtrl::GetItemCount
EXTRN	?GetItemRect@CListCtrl@@QBEHHPAUtagRECT@@I@Z:NEAR ; CListCtrl::GetItemRect
EXTRN	?GetHeaderCtrl@CListCtrl@@QAEPAVCHeaderCtrl@@XZ:NEAR ; CListCtrl::GetHeaderCtrl
EXTRN	?FillSolidRect@CDC@@QAEXPBUtagRECT@@K@Z:NEAR	; CDC::FillSolidRect
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -64						; size = 4
_clr$200029 = -60					; size = 4
_rectItem$200028 = -56					; size = 16
_rcClient$ = -40					; size = 16
_bNeedDraw$ = -21					; size = 1
_rectHeader$ = -20					; size = 16
_iItemCount$ = -4					; size = 4
_pDC$ = 8						; size = 4
?OnEraseBkgnd@CMyListCtrl@@IAEHPAVCDC@@@Z PROC NEAR	; CMyListCtrl::OnEraseBkgnd
; _this$ = ecx

; 196  : {

  007a0	55		 push	 ebp
  007a1	8b ec		 mov	 ebp, esp
  007a3	83 ec 40	 sub	 esp, 64			; 00000040H
  007a6	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 	CRect rcClient;

  007a9	8d 4d d8	 lea	 ecx, DWORD PTR _rcClient$[ebp]
  007ac	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 198  : 	GetClientRect(rcClient);

  007b1	8d 4d d8	 lea	 ecx, DWORD PTR _rcClient$[ebp]
  007b4	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  007b9	50		 push	 eax
  007ba	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  007bd	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 199  : 	CRect rectHeader;

  007c2	8d 4d ec	 lea	 ecx, DWORD PTR _rectHeader$[ebp]
  007c5	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 200  : 	GetHeaderCtrl()->GetWindowRect(rectHeader);

  007ca	8d 4d ec	 lea	 ecx, DWORD PTR _rectHeader$[ebp]
  007cd	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  007d2	50		 push	 eax
  007d3	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  007d6	e8 00 00 00 00	 call	 ?GetHeaderCtrl@CListCtrl@@QAEPAVCHeaderCtrl@@XZ ; CListCtrl::GetHeaderCtrl
  007db	8b c8		 mov	 ecx, eax
  007dd	e8 00 00 00 00	 call	 ?GetWindowRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetWindowRect

; 201  : 	bool bNeedDraw = true;

  007e2	c6 45 eb 01	 mov	 BYTE PTR _bNeedDraw$[ebp], 1

; 202  : 
; 203  : 	int iItemCount = GetItemCount();

  007e6	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  007e9	e8 00 00 00 00	 call	 ?GetItemCount@CListCtrl@@QBEHXZ ; CListCtrl::GetItemCount
  007ee	89 45 fc	 mov	 DWORD PTR _iItemCount$[ebp], eax

; 204  : 
; 205  : 	if (iItemCount > 0)

  007f1	83 7d fc 00	 cmp	 DWORD PTR _iItemCount$[ebp], 0
  007f5	7e 66		 jle	 SHORT $L200027

; 206  : 	{
; 207  : 		CRect rectItem;

  007f7	8d 4d c8	 lea	 ecx, DWORD PTR _rectItem$200028[ebp]
  007fa	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 208  : 		GetItemRect(iItemCount-1,rectItem,LVIR_BOUNDS);

  007ff	6a 00		 push	 0
  00801	8d 4d c8	 lea	 ecx, DWORD PTR _rectItem$200028[ebp]
  00804	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  00809	50		 push	 eax
  0080a	8b 45 fc	 mov	 eax, DWORD PTR _iItemCount$[ebp]
  0080d	83 e8 01	 sub	 eax, 1
  00810	50		 push	 eax
  00811	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00814	e8 00 00 00 00	 call	 ?GetItemRect@CListCtrl@@QBEHHPAUtagRECT@@I@Z ; CListCtrl::GetItemRect

; 209  : 		rcClient.top = rectItem.bottom;

  00819	8b 4d d4	 mov	 ecx, DWORD PTR _rectItem$200028[ebp+12]
  0081c	89 4d dc	 mov	 DWORD PTR _rcClient$[ebp+4], ecx

; 210  : 
; 211  : 		COLORREF clr;
; 212  : 		if (iItemCount % 2)

  0081f	8b 55 fc	 mov	 edx, DWORD PTR _iItemCount$[ebp]
  00822	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  00828	79 05		 jns	 SHORT $L202246
  0082a	4a		 dec	 edx
  0082b	83 ca fe	 or	 edx, -2			; fffffffeH
  0082e	42		 inc	 edx
$L202246:
  0082f	85 d2		 test	 edx, edx
  00831	74 0a		 je	 SHORT $L200030

; 213  : 			clr = clrOddItemBK;

  00833	a1 00 00 00 00	 mov	 eax, DWORD PTR _clrOddItemBK
  00838	89 45 c4	 mov	 DWORD PTR _clr$200029[ebp], eax

; 214  : 		else

  0083b	eb 09		 jmp	 SHORT $L200031
$L200030:

; 215  : 			clr = clrEvenItemBK;

  0083d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _clrEvenItemBK
  00843	89 4d c4	 mov	 DWORD PTR _clr$200029[ebp], ecx
$L200031:

; 216  : 
; 217  : 		pDC->FillSolidRect (&rcClient, clr);//RGB(45,44,44));

  00846	8b 55 c4	 mov	 edx, DWORD PTR _clr$200029[ebp]
  00849	52		 push	 edx
  0084a	8d 45 d8	 lea	 eax, DWORD PTR _rcClient$[ebp]
  0084d	50		 push	 eax
  0084e	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00851	e8 00 00 00 00	 call	 ?FillSolidRect@CDC@@QAEXPBUtagRECT@@K@Z ; CDC::FillSolidRect

; 218  : 
; 219  : 		return TRUE;

  00856	b8 01 00 00 00	 mov	 eax, 1
  0085b	eb 05		 jmp	 SHORT $L200022
$L200027:

; 220  : 	}
; 221  : /*  
; 222  : 	if( iItemCount > 0 )
; 223  : 	{
; 224  : 		CRect rectItem;
; 225  : 		GetItemRect(iItemCount-1,rectItem,LVIR_BOUNDS);
; 226  : 		if( rectItem.bottom < rcClient.bottom )
; 227  : 		{
; 228  : 			rcClient.top = rectItem.bottom;			
; 229  : 		}
; 230  : 		else
; 231  : 		{
; 232  : 			bNeedDraw = false;
; 233  : 		}
; 234  : 	}	
; 235  : 	else
; 236  : 	{
; 237  : 		rcClient.top = rectHeader.Height();
; 238  : 	}
; 239  : 
; 240  : 	if( bNeedDraw )
; 241  : 	{
; 242  : 		int id =iItemCount+1;
; 243  : 		for(int btop=rcClient.top ;btop<rcClient.bottom;btop+=ITEM_HEIGHT)
; 244  : 		{
; 245  : 			if(id%2)
; 246  : 			{
; 247  : 				pDC->FillSolidRect(CRect(rcClient.left,btop, rcClient.right ,btop+ITEM_HEIGHT),m_clrEvenItemBK);
; 248  : 			}else
; 249  : 			{
; 250  : 				pDC->FillSolidRect(CRect(rcClient.left,btop, rcClient.right ,btop+ITEM_HEIGHT),m_clrOddItemBK);
; 251  : 			}
; 252  : 			id++;
; 253  : 		}
; 254  : 	}
; 255  : */
; 256  : // 	rcClient.top = 0;
; 257  : // 	rcClient.top += (rectHeader.bottom - rectHeader.top );
; 258  : // 	rcClient.bottom = rcClient.top/* + 2*/;
; 259  : // 	pDC->FillSolidRect(rcClient, m_clrOddItemBK );
; 260  : 
; 261  : 	return TRUE;

  0085d	b8 01 00 00 00	 mov	 eax, 1
$L200022:

; 262  : }

  00862	8b e5		 mov	 esp, ebp
  00864	5d		 pop	 ebp
  00865	c2 04 00	 ret	 4
?OnEraseBkgnd@CMyListCtrl@@IAEHPAVCDC@@@Z ENDP		; CMyListCtrl::OnEraseBkgnd
; Function compile flags: /Odt
_this$ = -4						; size = 4
_lpmis$ = 8						; size = 4
?MeasureItem@CMyListCtrl@@IAEXPAUtagMEASUREITEMSTRUCT@@@Z PROC NEAR ; CMyListCtrl::MeasureItem
; _this$ = ecx

; 265  : {

  00870	55		 push	 ebp
  00871	8b ec		 mov	 ebp, esp
  00873	51		 push	 ecx
  00874	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 266  : 	lpmis->itemHeight = ITEM_HEIGHT;

  00877	8b 45 08	 mov	 eax, DWORD PTR _lpmis$[ebp]
  0087a	c7 40 10 50 00
	00 00		 mov	 DWORD PTR [eax+16], 80	; 00000050H

; 267  : }

  00881	8b e5		 mov	 esp, ebp
  00883	5d		 pop	 ebp
  00884	c2 04 00	 ret	 4
?MeasureItem@CMyListCtrl@@IAEXPAUtagMEASUREITEMSTRUCT@@@Z ENDP ; CMyListCtrl::MeasureItem
_TEXT	ENDS
EXTRN	?HideTooTips@CCWToolTips@@QAEXXZ:NEAR		; CCWToolTips::HideTooTips
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HideToolTip@CMyListCtrl@@UAEXXZ PROC NEAR		; CMyListCtrl::HideToolTip
; _this$ = ecx

; 271  : {

  00890	55		 push	 ebp
  00891	8b ec		 mov	 ebp, esp
  00893	51		 push	 ecx
  00894	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 272  : 	m_tooltip.HideTooTips();

  00897	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0089a	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  008a0	e8 00 00 00 00	 call	 ?HideTooTips@CCWToolTips@@QAEXXZ ; CCWToolTips::HideTooTips

; 273  : }

  008a5	8b e5		 mov	 esp, ebp
  008a7	5d		 pop	 ebp
  008a8	c3		 ret	 0
?HideToolTip@CMyListCtrl@@UAEXXZ ENDP			; CMyListCtrl::HideToolTip
_TEXT	ENDS
PUBLIC	??0CPoint@@QAE@HH@Z				; CPoint::CPoint
PUBLIC	??8CPoint@@QBEHUtagPOINT@@@Z			; CPoint::operator==
PUBLIC	?SubItemHitTest@CListCtrl@@QAEHPAUtagLVHITTESTINFO@@@Z ; CListCtrl::SubItemHitTest
PUBLIC	?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z		; CWnd::OnMouseMove
EXTRN	?GetSubItemRect@CListCtrl@@QAEHHHHAAVCRect@@@Z:NEAR ; CListCtrl::GetSubItemRect
EXTRN	__imp__SetCursor@4:NEAR
EXTRN	__imp___TrackMouseEvent@4:NEAR
EXTRN	__imp__LoadCursorA@8:NEAR
;	COMDAT ?s_pt@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4V3@A
_BSS	SEGMENT
?s_pt@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4V3@A DQ 01H DUP (?) ; `CMyListCtrl::OnMouseMove'::`2'::s_pt
_BSS	ENDS
;	COMDAT ?$S5@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4IA
_BSS	SEGMENT
?$S5@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4IA DD 01H DUP (?) ; `CMyListCtrl::OnMouseMove'::`2'::$S5
; Function compile flags: /Odt
_BSS	ENDS
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T202250 = -112						; size = 8
_tme$200074 = -104					; size = 16
_r$200059 = -88						; size = 16
_r$200057 = -72						; size = 16
_r$200055 = -56						; size = 16
_rectSubItem$ = -40					; size = 16
_ret$ = -24						; size = 4
_lvhti$ = -20						; size = 20
_nFlags$ = 8						; size = 4
_point$ = 12						; size = 8
?OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z PROC NEAR	; CMyListCtrl::OnMouseMove
; _this$ = ecx

; 277  : {

  008b0	55		 push	 ebp
  008b1	8b ec		 mov	 ebp, esp
  008b3	83 ec 74	 sub	 esp, 116		; 00000074H
  008b6	89 4d 8c	 mov	 DWORD PTR _this$[ebp], ecx

; 278  : 	static CPoint s_pt(0,0);

  008b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S5@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4IA
  008be	83 e0 01	 and	 eax, 1
  008c1	75 1d		 jne	 SHORT $L200048
  008c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$S5@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4IA
  008c9	83 c9 01	 or	 ecx, 1
  008cc	89 0d 00 00 00
	00		 mov	 DWORD PTR ?$S5@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4IA, ecx
  008d2	6a 00		 push	 0
  008d4	6a 00		 push	 0
  008d6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?s_pt@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4V3@A
  008db	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint
$L200048:

; 279  : 
; 280  : //	TRACE("%d,%d",point.x,point.y);
; 281  : 
; 282  : 	if( s_pt == point )

  008e0	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  008e3	89 55 90	 mov	 DWORD PTR $T202250[ebp], edx
  008e6	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp+4]
  008e9	89 45 94	 mov	 DWORD PTR $T202250[ebp+4], eax
  008ec	8b 4d 94	 mov	 ecx, DWORD PTR $T202250[ebp+4]
  008ef	51		 push	 ecx
  008f0	8b 55 90	 mov	 edx, DWORD PTR $T202250[ebp]
  008f3	52		 push	 edx
  008f4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?s_pt@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4V3@A
  008f9	e8 00 00 00 00	 call	 ??8CPoint@@QBEHUtagPOINT@@@Z ; CPoint::operator==
  008fe	85 c0		 test	 eax, eax
  00900	74 05		 je	 SHORT $L200050

; 283  : 	{
; 284  : //		__super::OnMouseMove( nFlags,point );
; 285  : 		return;

  00902	e9 43 03 00 00	 jmp	 $L200043
$L200050:

; 286  : 	}
; 287  : 	s_pt = point;

  00907	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  0090a	a3 00 00 00 00	 mov	 DWORD PTR ?s_pt@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4V3@A, eax
  0090f	8b 4d 10	 mov	 ecx, DWORD PTR _point$[ebp+4]
  00912	89 0d 04 00 00
	00		 mov	 DWORD PTR ?s_pt@?1??OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z@4V3@A+4, ecx

; 288  : 
; 289  : 	HideToolTip();

  00918	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  0091b	8b 02		 mov	 eax, DWORD PTR [edx]
  0091d	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00920	ff 90 68 01 00
	00		 call	 DWORD PTR [eax+360]

; 290  : 
; 291  : 	LVHITTESTINFO lvhti;
; 292  : 	lvhti.pt = point;

  00926	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  00929	89 4d ec	 mov	 DWORD PTR _lvhti$[ebp], ecx
  0092c	8b 55 10	 mov	 edx, DWORD PTR _point$[ebp+4]
  0092f	89 55 f0	 mov	 DWORD PTR _lvhti$[ebp+4], edx

; 293  : 	int ret = SubItemHitTest(&lvhti);

  00932	8d 45 ec	 lea	 eax, DWORD PTR _lvhti$[ebp]
  00935	50		 push	 eax
  00936	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00939	e8 00 00 00 00	 call	 ?SubItemHitTest@CListCtrl@@QAEHPAUtagLVHITTESTINFO@@@Z ; CListCtrl::SubItemHitTest
  0093e	89 45 e8	 mov	 DWORD PTR _ret$[ebp], eax

; 294  : 	if( ret == -1 )

  00941	83 7d e8 ff	 cmp	 DWORD PTR _ret$[ebp], -1
  00945	0f 85 87 00 00
	00		 jne	 $L200053

; 295  : 	{
; 296  : 		if( m_iCurrentCursorItem != -1 )

  0094b	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  0094e	83 b9 80 00 00
	00 ff		 cmp	 DWORD PTR [ecx+128], -1
  00955	74 2e		 je	 SHORT $L200054

; 297  : 		{
; 298  : 			CRect r;

  00957	8d 4d c8	 lea	 ecx, DWORD PTR _r$200055[ebp]
  0095a	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 299  : 			GetItemRect(m_iCurrentCursorItem, &r,LVIR_BOUNDS);

  0095f	6a 00		 push	 0
  00961	8d 55 c8	 lea	 edx, DWORD PTR _r$200055[ebp]
  00964	52		 push	 edx
  00965	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00968	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0096e	51		 push	 ecx
  0096f	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00972	e8 00 00 00 00	 call	 ?GetItemRect@CListCtrl@@QBEHHPAUtagRECT@@I@Z ; CListCtrl::GetItemRect

; 300  : 			InvalidateRect(&r, true);

  00977	6a 01		 push	 1
  00979	8d 55 c8	 lea	 edx, DWORD PTR _r$200055[ebp]
  0097c	52		 push	 edx
  0097d	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00980	e8 00 00 00 00	 call	 ?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::InvalidateRect
$L200054:

; 301  : 		}
; 302  : 		m_iCurrentCursorItem = m_iCurrentCursorSubItem = -1;

  00985	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00988	c7 80 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+132], -1
  00992	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00995	c7 81 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+128], -1

; 303  : 		m_iOverImageItem	= -1;

  0099f	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  009a2	c7 82 88 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+136], -1

; 304  : 		m_iOverImageSubItem	= -1;

  009ac	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  009af	c7 80 8c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+140], -1

; 305  : 		__super::OnMouseMove( nFlags,point );

  009b9	8b 4d 10	 mov	 ecx, DWORD PTR _point$[ebp+4]
  009bc	51		 push	 ecx
  009bd	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  009c0	52		 push	 edx
  009c1	8b 45 08	 mov	 eax, DWORD PTR _nFlags$[ebp]
  009c4	50		 push	 eax
  009c5	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  009c8	e8 00 00 00 00	 call	 ?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z ; CWnd::OnMouseMove

; 306  : 		return;

  009cd	e9 78 02 00 00	 jmp	 $L200043
$L200053:

; 307  : 	}
; 308  : 
; 309  : 	if( m_iCurrentCursorItem != -1 )

  009d2	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  009d5	83 b9 80 00 00
	00 ff		 cmp	 DWORD PTR [ecx+128], -1
  009dc	74 2e		 je	 SHORT $L200056

; 310  : 	{
; 311  : 		CRect r;

  009de	8d 4d b8	 lea	 ecx, DWORD PTR _r$200057[ebp]
  009e1	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 312  : 		GetItemRect(m_iCurrentCursorItem, &r,LVIR_BOUNDS);

  009e6	6a 00		 push	 0
  009e8	8d 55 b8	 lea	 edx, DWORD PTR _r$200057[ebp]
  009eb	52		 push	 edx
  009ec	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  009ef	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  009f5	51		 push	 ecx
  009f6	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  009f9	e8 00 00 00 00	 call	 ?GetItemRect@CListCtrl@@QBEHHPAUtagRECT@@I@Z ; CListCtrl::GetItemRect

; 313  : 		InvalidateRect(&r, true);

  009fe	6a 01		 push	 1
  00a00	8d 55 b8	 lea	 edx, DWORD PTR _r$200057[ebp]
  00a03	52		 push	 edx
  00a04	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00a07	e8 00 00 00 00	 call	 ?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::InvalidateRect
$L200056:

; 314  : 	}
; 315  : 	m_iCurrentCursorItem	= lvhti.iItem;

  00a0c	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00a0f	8b 4d f8	 mov	 ecx, DWORD PTR _lvhti$[ebp+12]
  00a12	89 88 80 00 00
	00		 mov	 DWORD PTR [eax+128], ecx

; 316  : 	m_iCurrentCursorSubItem	= lvhti.iSubItem;

  00a18	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  00a1b	8b 45 fc	 mov	 eax, DWORD PTR _lvhti$[ebp+16]
  00a1e	89 82 84 00 00
	00		 mov	 DWORD PTR [edx+132], eax

; 317  : 	if( m_iCurrentCursorItem != -1 )

  00a24	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00a27	83 b9 80 00 00
	00 ff		 cmp	 DWORD PTR [ecx+128], -1
  00a2e	74 2e		 je	 SHORT $L200058

; 318  : 	{
; 319  : 		CRect r;

  00a30	8d 4d a8	 lea	 ecx, DWORD PTR _r$200059[ebp]
  00a33	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 320  : 		GetItemRect(m_iCurrentCursorItem, &r,LVIR_BOUNDS);

  00a38	6a 00		 push	 0
  00a3a	8d 55 a8	 lea	 edx, DWORD PTR _r$200059[ebp]
  00a3d	52		 push	 edx
  00a3e	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00a41	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00a47	51		 push	 ecx
  00a48	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00a4b	e8 00 00 00 00	 call	 ?GetItemRect@CListCtrl@@QBEHHPAUtagRECT@@I@Z ; CListCtrl::GetItemRect

; 321  : 		InvalidateRect(&r, true);

  00a50	6a 01		 push	 1
  00a52	8d 55 a8	 lea	 edx, DWORD PTR _r$200059[ebp]
  00a55	52		 push	 edx
  00a56	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00a59	e8 00 00 00 00	 call	 ?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::InvalidateRect
$L200058:

; 322  : 	}
; 323  : 
; 324  : 	CRect rectSubItem;

  00a5e	8d 4d d8	 lea	 ecx, DWORD PTR _rectSubItem$[ebp]
  00a61	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 325  : 	GetSubItemRect( m_iCurrentCursorItem,m_iCurrentCursorSubItem,LVIR_BOUNDS,rectSubItem);

  00a66	8d 45 d8	 lea	 eax, DWORD PTR _rectSubItem$[ebp]
  00a69	50		 push	 eax
  00a6a	6a 00		 push	 0
  00a6c	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00a6f	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00a75	52		 push	 edx
  00a76	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00a79	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00a7f	51		 push	 ecx
  00a80	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00a83	e8 00 00 00 00	 call	 ?GetSubItemRect@CListCtrl@@QAEHHHHAAVCRect@@@Z ; CListCtrl::GetSubItemRect

; 326  : 
; 327  : 	if( NeedChangeCursor( point ) )

  00a88	8d 55 0c	 lea	 edx, DWORD PTR _point$[ebp]
  00a8b	52		 push	 edx
  00a8c	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00a8f	8b 10		 mov	 edx, DWORD PTR [eax]
  00a91	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00a94	ff 92 50 01 00
	00		 call	 DWORD PTR [edx+336]
  00a9a	85 c0		 test	 eax, eax
  00a9c	0f 84 9a 00 00
	00		 je	 $L200061

; 328  : 	{
; 329  : 		::SetCursor(::LoadCursor(NULL, MAKEINTRESOURCE(32649)));			

  00aa2	68 89 7f 00 00	 push	 32649			; 00007f89H
  00aa7	6a 00		 push	 0
  00aa9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  00aaf	50		 push	 eax
  00ab0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4

; 330  : 		if( m_iOverImageItem == -1 && m_iOverImageSubItem == -1 )

  00ab6	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00ab9	83 b8 88 00 00
	00 ff		 cmp	 DWORD PTR [eax+136], -1
  00ac0	75 53		 jne	 SHORT $L200065
  00ac2	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00ac5	83 b9 8c 00 00
	00 ff		 cmp	 DWORD PTR [ecx+140], -1
  00acc	75 47		 jne	 SHORT $L200065

; 331  : 		{
; 332  : 			if( m_iCurrentCursorSubItem == 0 )

  00ace	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  00ad1	83 ba 84 00 00
	00 00		 cmp	 DWORD PTR [edx+132], 0
  00ad8	75 10		 jne	 SHORT $L200066

; 333  : 			{
; 334  : 				rectSubItem.right = rectSubItem.left + GetColumnWidth(0);

  00ada	6a 00		 push	 0
  00adc	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00adf	e8 00 00 00 00	 call	 ?GetColumnWidth@CListCtrl@@QBEHH@Z ; CListCtrl::GetColumnWidth
  00ae4	03 45 d8	 add	 eax, DWORD PTR _rectSubItem$[ebp]
  00ae7	89 45 e0	 mov	 DWORD PTR _rectSubItem$[ebp+8], eax
$L200066:

; 335  : 			}
; 336  : 
; 337  : 			InvalidateRect( rectSubItem );

  00aea	6a 01		 push	 1
  00aec	8d 4d d8	 lea	 ecx, DWORD PTR _rectSubItem$[ebp]
  00aef	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  00af4	50		 push	 eax
  00af5	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00af8	e8 00 00 00 00	 call	 ?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::InvalidateRect

; 338  : 			m_iOverImageItem	= lvhti.iItem;

  00afd	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00b00	8b 4d f8	 mov	 ecx, DWORD PTR _lvhti$[ebp+12]
  00b03	89 88 88 00 00
	00		 mov	 DWORD PTR [eax+136], ecx

; 339  : 			m_iOverImageSubItem	= lvhti.iSubItem;

  00b09	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  00b0c	8b 45 fc	 mov	 eax, DWORD PTR _lvhti$[ebp+16]
  00b0f	89 82 8c 00 00
	00		 mov	 DWORD PTR [edx+140], eax
$L200065:

; 340  : 		}
; 341  : 		ShowSubItemToolTip( m_iOverImageItem,m_iOverImageSubItem);

  00b15	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00b18	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  00b1e	52		 push	 edx
  00b1f	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00b22	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00b28	51		 push	 ecx
  00b29	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  00b2c	8b 02		 mov	 eax, DWORD PTR [edx]
  00b2e	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00b31	ff 90 64 01 00
	00		 call	 DWORD PTR [eax+356]

; 342  : 	}
; 343  : 	else

  00b37	e9 bd 00 00 00	 jmp	 $L200067
$L200061:

; 344  : 	{
; 345  : 		if( m_iOverImageItem != -1 && m_iOverImageSubItem != -1 )

  00b3c	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00b3f	83 b9 88 00 00
	00 ff		 cmp	 DWORD PTR [ecx+136], -1
  00b46	0f 84 8b 00 00
	00		 je	 $L200068
  00b4c	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  00b4f	83 ba 8c 00 00
	00 ff		 cmp	 DWORD PTR [edx+140], -1
  00b56	74 7f		 je	 SHORT $L200068

; 346  : 		{
; 347  : 			GetSubItemRect( m_iOverImageItem,m_iOverImageSubItem,LVIR_BOUNDS,rectSubItem);

  00b58	8d 45 d8	 lea	 eax, DWORD PTR _rectSubItem$[ebp]
  00b5b	50		 push	 eax
  00b5c	6a 00		 push	 0
  00b5e	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00b61	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  00b67	52		 push	 edx
  00b68	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00b6b	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00b71	51		 push	 ecx
  00b72	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00b75	e8 00 00 00 00	 call	 ?GetSubItemRect@CListCtrl@@QAEHHHHAAVCRect@@@Z ; CListCtrl::GetSubItemRect

; 348  : 			if( m_iCurrentCursorSubItem == 0 )

  00b7a	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  00b7d	83 ba 84 00 00
	00 00		 cmp	 DWORD PTR [edx+132], 0
  00b84	75 10		 jne	 SHORT $L200069

; 349  : 			{
; 350  : 				rectSubItem.right = rectSubItem.left + GetColumnWidth(0);

  00b86	6a 00		 push	 0
  00b88	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00b8b	e8 00 00 00 00	 call	 ?GetColumnWidth@CListCtrl@@QBEHH@Z ; CListCtrl::GetColumnWidth
  00b90	03 45 d8	 add	 eax, DWORD PTR _rectSubItem$[ebp]
  00b93	89 45 e0	 mov	 DWORD PTR _rectSubItem$[ebp+8], eax
$L200069:

; 351  : 			}
; 352  : 			InvalidateRect( rectSubItem );			

  00b96	6a 01		 push	 1
  00b98	8d 4d d8	 lea	 ecx, DWORD PTR _rectSubItem$[ebp]
  00b9b	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  00ba0	50		 push	 eax
  00ba1	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00ba4	e8 00 00 00 00	 call	 ?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::InvalidateRect

; 353  : 			m_iOverImageItem	= -1;

  00ba9	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00bac	c7 80 88 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+136], -1

; 354  : 			m_iOverImageSubItem	= -1;

  00bb6	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00bb9	c7 81 8c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+140], -1

; 355  : 			::SetCursor(::LoadCursor(NULL, IDC_ARROW));	

  00bc3	68 00 7f 00 00	 push	 32512			; 00007f00H
  00bc8	6a 00		 push	 0
  00bca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  00bd0	50		 push	 eax
  00bd1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
$L200068:

; 356  : 		}	
; 357  : 		ShowItemToolTip( m_iCurrentCursorItem,m_iCurrentCursorSubItem);

  00bd7	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  00bda	8b 82 84 00 00
	00		 mov	 eax, DWORD PTR [edx+132]
  00be0	50		 push	 eax
  00be1	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00be4	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  00bea	52		 push	 edx
  00beb	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00bee	8b 10		 mov	 edx, DWORD PTR [eax]
  00bf0	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00bf3	ff 92 60 01 00
	00		 call	 DWORD PTR [edx+352]
$L200067:

; 358  : 	}
; 359  : 	if(!m_bTrackMouseEvent) 

  00bf9	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00bfc	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00c03	75 31		 jne	 SHORT $L200073

; 360  : 	{
; 361  : 		TRACKMOUSEEVENT tme;
; 362  : 		tme.cbSize = sizeof(tme);

  00c05	c7 45 98 10 00
	00 00		 mov	 DWORD PTR _tme$200074[ebp], 16 ; 00000010H

; 363  : 		tme.hwndTrack = m_hWnd;

  00c0c	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00c0f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00c12	89 55 a0	 mov	 DWORD PTR _tme$200074[ebp+8], edx

; 364  : 		tme.dwFlags = TME_LEAVE; 

  00c15	c7 45 9c 02 00
	00 00		 mov	 DWORD PTR _tme$200074[ebp+4], 2

; 365  : 		tme.dwHoverTime = 1;

  00c1c	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _tme$200074[ebp+12], 1

; 366  : 		m_bTrackMouseEvent = _TrackMouseEvent(&tme); 

  00c23	8d 45 98	 lea	 eax, DWORD PTR _tme$200074[ebp]
  00c26	50		 push	 eax
  00c27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___TrackMouseEvent@4
  00c2d	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00c30	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax
$L200073:

; 367  : 	}
; 368  : 	__super::OnMouseMove( nFlags,point );

  00c36	8b 55 10	 mov	 edx, DWORD PTR _point$[ebp+4]
  00c39	52		 push	 edx
  00c3a	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  00c3d	50		 push	 eax
  00c3e	8b 4d 08	 mov	 ecx, DWORD PTR _nFlags$[ebp]
  00c41	51		 push	 ecx
  00c42	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00c45	e8 00 00 00 00	 call	 ?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z ; CWnd::OnMouseMove
$L200043:

; 369  : 
; 370  : }

  00c4a	8b e5		 mov	 esp, ebp
  00c4c	5d		 pop	 ebp
  00c4d	c2 0c 00	 ret	 12			; 0000000cH
?OnMouseMove@CMyListCtrl@@IAEXIVCPoint@@@Z ENDP		; CMyListCtrl::OnMouseMove
; Function compile flags: /Odt
_this$ = -20						; size = 4
_r$200081 = -16						; size = 16
_wparam$ = 8						; size = 4
_lparam$ = 12						; size = 4
?OnMouseLeave@CMyListCtrl@@IAEJIJ@Z PROC NEAR		; CMyListCtrl::OnMouseLeave
; _this$ = ecx

; 373  : {

  00c50	55		 push	 ebp
  00c51	8b ec		 mov	 ebp, esp
  00c53	83 ec 14	 sub	 esp, 20			; 00000014H
  00c56	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 374  : 	m_bTrackMouseEvent = FALSE;

  00c59	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00c5c	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], 0

; 375  : 	if( m_iCurrentCursorItem != -1 )

  00c66	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00c69	83 b9 80 00 00
	00 ff		 cmp	 DWORD PTR [ecx+128], -1
  00c70	74 2e		 je	 SHORT $L200080

; 376  : 	{
; 377  : 		CRect r;

  00c72	8d 4d f0	 lea	 ecx, DWORD PTR _r$200081[ebp]
  00c75	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 378  : 		GetItemRect(m_iCurrentCursorItem, &r,LVIR_BOUNDS);

  00c7a	6a 00		 push	 0
  00c7c	8d 55 f0	 lea	 edx, DWORD PTR _r$200081[ebp]
  00c7f	52		 push	 edx
  00c80	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00c83	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00c89	51		 push	 ecx
  00c8a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00c8d	e8 00 00 00 00	 call	 ?GetItemRect@CListCtrl@@QBEHHPAUtagRECT@@I@Z ; CListCtrl::GetItemRect

; 379  : 		InvalidateRect(&r, true);

  00c92	6a 01		 push	 1
  00c94	8d 55 f0	 lea	 edx, DWORD PTR _r$200081[ebp]
  00c97	52		 push	 edx
  00c98	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00c9b	e8 00 00 00 00	 call	 ?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::InvalidateRect
$L200080:

; 380  : 	}
; 381  : 	m_iCurrentCursorItem = -1;

  00ca0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00ca3	c7 80 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+128], -1

; 382  : 	m_iCurrentCursorSubItem = -1;

  00cad	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00cb0	c7 81 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+132], -1

; 383  : 	m_iOverImageItem = -1;

  00cba	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00cbd	c7 82 88 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+136], -1

; 384  : 	m_iOverImageSubItem = -1;

  00cc7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00cca	c7 80 8c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+140], -1

; 385  : 
; 386  : 	HideToolTip();

  00cd4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00cd7	8b 11		 mov	 edx, DWORD PTR [ecx]
  00cd9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00cdc	ff 92 68 01 00
	00		 call	 DWORD PTR [edx+360]

; 387  : 	return DefWindowProc(WM_MOUSELEAVE, wparam, lparam); 

  00ce2	8b 45 0c	 mov	 eax, DWORD PTR _lparam$[ebp]
  00ce5	50		 push	 eax
  00ce6	8b 4d 08	 mov	 ecx, DWORD PTR _wparam$[ebp]
  00ce9	51		 push	 ecx
  00cea	68 a3 02 00 00	 push	 675			; 000002a3H
  00cef	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00cf2	8b 02		 mov	 eax, DWORD PTR [edx]
  00cf4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00cf7	ff 90 18 01 00
	00		 call	 DWORD PTR [eax+280]

; 388  : }

  00cfd	8b e5		 mov	 esp, ebp
  00cff	5d		 pop	 ebp
  00d00	c2 08 00	 ret	 8
?OnMouseLeave@CMyListCtrl@@IAEJIJ@Z ENDP		; CMyListCtrl::OnMouseLeave
_TEXT	ENDS
PUBLIC	?SetItemData@CListCtrl@@QAEHHK@Z		; CListCtrl::SetItemData
PUBLIC	?SortItems@CListCtrl@@QAEHP6GHJJJ@ZK@Z		; CListCtrl::SortItems
PUBLIC	?MyCompareProc@CMyListCtrl@@SGHJJJ@Z		; CMyListCtrl::MyCompareProc
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$200090 = -8						; size = 4
_pNMListView$ = -4					; size = 4
_pNMHDR$ = 8						; size = 4
_pResult$ = 12						; size = 4
?OnColumnclickList@CMyListCtrl@@IAEXPAUtagNMHDR@@PAJ@Z PROC NEAR ; CMyListCtrl::OnColumnclickList
; _this$ = ecx

; 391  : {

  00d10	55		 push	 ebp
  00d11	8b ec		 mov	 ebp, esp
  00d13	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00d16	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 392  : 	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

  00d19	8b 45 08	 mov	 eax, DWORD PTR _pNMHDR$[ebp]
  00d1c	89 45 fc	 mov	 DWORD PTR _pNMListView$[ebp], eax

; 393  : 
; 394  : 	m_bAsc		= !m_bAsc;

  00d1f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d22	0f b6 91 30 01
	00 00		 movzx	 edx, BYTE PTR [ecx+304]
  00d29	f7 da		 neg	 edx
  00d2b	1b d2		 sbb	 edx, edx
  00d2d	42		 inc	 edx
  00d2e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00d31	88 90 30 01 00
	00		 mov	 BYTE PTR [eax+304], dl

; 395  : 	m_iSortItem = pNMListView->iSubItem;

  00d37	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d3a	8b 55 fc	 mov	 edx, DWORD PTR _pNMListView$[ebp]
  00d3d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00d40	89 81 34 01 00
	00		 mov	 DWORD PTR [ecx+308], eax

; 396  : 
; 397  : 	SortItems(MyCompareProc, (LPARAM)this);

  00d46	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d49	51		 push	 ecx
  00d4a	68 00 00 00 00	 push	 OFFSET FLAT:?MyCompareProc@CMyListCtrl@@SGHJJJ@Z ; CMyListCtrl::MyCompareProc
  00d4f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d52	e8 00 00 00 00	 call	 ?SortItems@CListCtrl@@QAEHP6GHJJJ@ZK@Z ; CListCtrl::SortItems

; 398  : 	for(int i = 0 ; i<GetItemCount(); i++)

  00d57	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$200090[ebp], 0
  00d5e	eb 09		 jmp	 SHORT $L200091
$L200092:
  00d60	8b 55 f8	 mov	 edx, DWORD PTR _i$200090[ebp]
  00d63	83 c2 01	 add	 edx, 1
  00d66	89 55 f8	 mov	 DWORD PTR _i$200090[ebp], edx
$L200091:
  00d69	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d6c	e8 00 00 00 00	 call	 ?GetItemCount@CListCtrl@@QBEHXZ ; CListCtrl::GetItemCount
  00d71	39 45 f8	 cmp	 DWORD PTR _i$200090[ebp], eax
  00d74	7d 12		 jge	 SHORT $L200093

; 399  : 	{
; 400  : 		SetItemData(i, i);

  00d76	8b 45 f8	 mov	 eax, DWORD PTR _i$200090[ebp]
  00d79	50		 push	 eax
  00d7a	8b 4d f8	 mov	 ecx, DWORD PTR _i$200090[ebp]
  00d7d	51		 push	 ecx
  00d7e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d81	e8 00 00 00 00	 call	 ?SetItemData@CListCtrl@@QAEHHK@Z ; CListCtrl::SetItemData

; 401  : 	}

  00d86	eb d8		 jmp	 SHORT $L200092
$L200093:

; 402  : 
; 403  : 	*pResult = 0;

  00d88	8b 55 0c	 mov	 edx, DWORD PTR _pResult$[ebp]
  00d8b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 404  : }

  00d91	8b e5		 mov	 esp, ebp
  00d93	5d		 pop	 ebp
  00d94	c2 08 00	 ret	 8
?OnColumnclickList@CMyListCtrl@@IAEXPAUtagNMHDR@@PAJ@Z ENDP ; CMyListCtrl::OnColumnclickList
; Function compile flags: /Odt
_pWnd$ = -4						; size = 4
_lParam1$ = 8						; size = 4
_lParam2$ = 12						; size = 4
_lParamSort$ = 16					; size = 4
?MyCompareProc@CMyListCtrl@@SGHJJJ@Z PROC NEAR		; CMyListCtrl::MyCompareProc

; 407  : {

  00da0	55		 push	 ebp
  00da1	8b ec		 mov	 ebp, esp
  00da3	51		 push	 ecx

; 408  : 	CMyListCtrl * pWnd = (CMyListCtrl *)lParamSort;

  00da4	8b 45 10	 mov	 eax, DWORD PTR _lParamSort$[ebp]
  00da7	89 45 fc	 mov	 DWORD PTR _pWnd$[ebp], eax

; 409  : 	if(pWnd == NULL)

  00daa	83 7d fc 00	 cmp	 DWORD PTR _pWnd$[ebp], 0
  00dae	75 04		 jne	 SHORT $L200101

; 410  : 		return 0;

  00db0	33 c0		 xor	 eax, eax
  00db2	eb 16		 jmp	 SHORT $L200098
$L200101:

; 411  : 	return pWnd->SortFunction( (int)lParam1,(int)lParam2);

  00db4	8b 4d 0c	 mov	 ecx, DWORD PTR _lParam2$[ebp]
  00db7	51		 push	 ecx
  00db8	8b 55 08	 mov	 edx, DWORD PTR _lParam1$[ebp]
  00dbb	52		 push	 edx
  00dbc	8b 45 fc	 mov	 eax, DWORD PTR _pWnd$[ebp]
  00dbf	8b 10		 mov	 edx, DWORD PTR [eax]
  00dc1	8b 4d fc	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00dc4	ff 92 6c 01 00
	00		 call	 DWORD PTR [edx+364]
$L200098:

; 412  : }

  00dca	8b e5		 mov	 esp, ebp
  00dcc	5d		 pop	 ebp
  00dcd	c2 0c 00	 ret	 12			; 0000000cH
?MyCompareProc@CMyListCtrl@@SGHJJJ@Z ENDP		; CMyListCtrl::MyCompareProc
; Function compile flags: /Odt
_this$ = -4						; size = 4
_lpDrawItemStruct$ = 8					; size = 4
?DrawItem@CMyListCtrl@@MAEXPAUtagDRAWITEMSTRUCT@@@Z PROC NEAR ; CMyListCtrl::DrawItem
; _this$ = ecx

; 415  : {

  00dd0	55		 push	 ebp
  00dd1	8b ec		 mov	 ebp, esp
  00dd3	51		 push	 ecx
  00dd4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 416  : /*
; 417  : 	CRect rcWnd;
; 418  : 	GetClientRect(&rcWnd);
; 419  : 	
; 420  : 	CRect rcItem(lpDrawItemStruct->rcItem);
; 421  : 	rcItem.right = rcWnd.right;
; 422  : 	CBufferDC* pDC = new CBufferDC( lpDrawItemStruct->hDC,rcItem);
; 423  : 
; 424  : 	int nItem = lpDrawItemStruct->itemID;
; 425  : 
; 426  : 	// Save dc state
; 427  : 	int nSavedDC = pDC->SaveDC();
; 428  : 
; 429  : 	LV_ITEM lvi;
; 430  : 	lvi.mask = LVIF_STATE;
; 431  : 	lvi.iItem = nItem;
; 432  : 	lvi.iSubItem = 0;
; 433  : 	lvi.stateMask = 0xFFFF;     // get all state flags
; 434  : 	GetItem(&lvi);
; 435  : 
; 436  : 	// Should the item be highlighted
; 437  : 	BOOL bHighlight =( (lvi.state & LVIS_DROPHILITED) || ( (lvi.state & LVIS_SELECTED)&& ((GetFocus() == this)|| (GetStyle() & LVS_SHOWSELALWAYS)	)	)		);
; 438  : 
; 439  : 	// Get rectangles for drawing
; 440  : 	CRect rcBounds;
; 441  : 	GetItemRect(nItem, rcBounds, LVIR_BOUNDS);
; 442  : 		
; 443  : 	CRect rcHighlight;
; 444  : 
; 445  : 	rcHighlight = rcBounds;
; 446  : 	rcHighlight.left = rcWnd.left;
; 447  : 	rcHighlight.right = rcWnd.right;
; 448  : 
; 449  : 	// Draw the background color
; 450  : 	SetItemTextColor( pDC,bHighlight,nItem );
; 451  : 	SetItemBkColor( pDC,bHighlight,nItem ,rcHighlight );
; 452  : 	
; 453  : 	int iColumnCount = GetHeaderCtrl()->GetItemCount();	
; 454  : 
; 455  : 	LV_COLUMN lvc;
; 456  : 	lvc.mask = LVCF_FMT | LVCF_WIDTH;
; 457  : 	
; 458  : 	CFont* pFont = pDC->SelectObject(&m_font);
; 459  : 	m_iOffset = pDC->GetTextExtent(_T(" "), 1 ).cx / 2;
; 460  : 
; 461  : 	for( int i = 0;i < iColumnCount;i++ )
; 462  : 	{
; 463  : 		GetColumn( i,&lvc );
; 464  : 		rcBounds.right = rcBounds.left + lvc.cx;
; 465  : 		if( m_mapColumnInfo[i].enumColumnType == MYLIST_COLUMN_INFO::COLUMN_TYPE_IMAGE )
; 466  : 		{
; 467  : 			DrawImageColumn( pDC,nItem,i,rcBounds,bHighlight);
; 468  : 		}
; 469  : 		else
; 470  : 		{
; 471  : 			DrawTextColumn( pDC,nItem,i,rcBounds );
; 472  : 		}
; 473  : 		rcBounds.left = rcBounds.right;
; 474  : 	}
; 475  : 
; 476  : 	pDC->SelectObject(pFont);
; 477  : 	// Restore dc
; 478  : 
; 479  : 	pDC->RestoreDC( nSavedDC );
; 480  : 
; 481  : 	delete pDC;
; 482  : */
; 483  : }

  00dd7	8b e5		 mov	 esp, ebp
  00dd9	5d		 pop	 ebp
  00dda	c2 04 00	 ret	 4
?DrawItem@CMyListCtrl@@MAEXPAUtagDRAWITEMSTRUCT@@@Z ENDP ; CMyListCtrl::DrawItem
; Function compile flags: /Odt
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
_bHighlight$ = 12					; size = 4
_iItem$ = 16						; size = 4
?SetItemTextColor@CMyListCtrl@@UAEXPAVCDC@@HH@Z PROC NEAR ; CMyListCtrl::SetItemTextColor
; _this$ = ecx

; 487  : {

  00de0	55		 push	 ebp
  00de1	8b ec		 mov	 ebp, esp
  00de3	51		 push	 ecx
  00de4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 488  : 	// Draw the background color
; 489  : 	if( bHighlight )

  00de7	83 7d 0c 00	 cmp	 DWORD PTR _bHighlight$[ebp], 0
  00deb	74 14		 je	 SHORT $L200114

; 490  : 	{
; 491  : 		pDC->SetTextColor( m_clrSelItemText);

  00ded	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00df0	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00df3	51		 push	 ecx
  00df4	8b 55 08	 mov	 edx, DWORD PTR _pDC$[ebp]
  00df7	8b 02		 mov	 eax, DWORD PTR [edx]
  00df9	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00dfc	ff 50 38	 call	 DWORD PTR [eax+56]

; 492  : 	}
; 493  : 	else

  00dff	eb 12		 jmp	 SHORT $L200113
$L200114:

; 494  : 	{
; 495  : 		pDC->SetTextColor( m_clrNormalItemText);	

  00e01	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e04	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00e07	52		 push	 edx
  00e08	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  00e0b	8b 10		 mov	 edx, DWORD PTR [eax]
  00e0d	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00e10	ff 52 38	 call	 DWORD PTR [edx+56]
$L200113:

; 496  : 	}
; 497  : }

  00e13	8b e5		 mov	 esp, ebp
  00e15	5d		 pop	 ebp
  00e16	c2 0c 00	 ret	 12			; 0000000cH
?SetItemTextColor@CMyListCtrl@@UAEXPAVCDC@@HH@Z ENDP	; CMyListCtrl::SetItemTextColor
_TEXT	ENDS
PUBLIC	??BCRect@@QBEPBUtagRECT@@XZ			; CRect::operator tagRECT const *
PUBLIC	?FillRect@CDC@@QAEXPBUtagRECT@@PAVCBrush@@@Z	; CDC::FillRect
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator!=
PUBLIC	??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z ; std::find<std::vector<int,std::allocator<int> >::iterator,int>
PUBLIC	??1CBrush@@UAE@XZ				; CBrush::~CBrush
EXTRN	?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z:NEAR	; CDibBitmap::Draw
EXTRN	?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z:NEAR	; CDibBitmap::SetCDibRect
EXTRN	??0CBrush@@QAE@K@Z:NEAR				; CBrush::CBrush
xdata$x	SEGMENT
$T202273 DD	0ffffffffH
	DD	FLAT:$L202265
	DD	0ffffffffH
	DD	FLAT:$L202266
	DD	0ffffffffH
	DD	FLAT:$L202267
	DD	0ffffffffH
	DD	FLAT:$L202268
$T202270 DD	019930520H
	DD	04H
	DD	FLAT:$T202273
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv197 = -108						; size = 4
tv192 = -104						; size = 4
tv216 = -100						; size = 4
tv220 = -96						; size = 4
tv214 = -92						; size = 4
tv219 = -88						; size = 4
tv212 = -84						; size = 4
tv218 = -80						; size = 4
tv210 = -76						; size = 4
tv217 = -72						; size = 4
_this$ = -68						; size = 4
$T202264 = -64						; size = 8
$T202263 = -56						; size = 8
$T202262 = -48						; size = 8
$T202261 = -40						; size = 4
$T202260 = -36						; size = 4
$T202259 = -32						; size = 4
$T202258 = -28						; size = 8
_pDib$200263 = -20					; size = 4
_ite$200243 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pDC$ = 8						; size = 4
_bHighlight$ = 12					; size = 4
_iItem$ = 16						; size = 4
_rect$ = 20						; size = 4
?SetItemBkColor@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z PROC NEAR ; CMyListCtrl::SetItemBkColor
; _this$ = ecx

; 500  : {

  00e20	55		 push	 ebp
  00e21	8b ec		 mov	 ebp, esp
  00e23	6a ff		 push	 -1
  00e25	68 00 00 00 00	 push	 __ehhandler$?SetItemBkColor@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z
  00e2a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00e30	50		 push	 eax
  00e31	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00e38	83 ec 60	 sub	 esp, 96			; 00000060H
  00e3b	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 501  : 	// Draw the background color
; 502  : 	if( bHighlight )

  00e3e	83 7d 0c 00	 cmp	 DWORD PTR _bHighlight$[ebp], 0
  00e42	74 5a		 je	 SHORT $L200123

; 503  : 	{
; 504  : 		pDC->SetBkColor( m_clrSelItemBK);

  00e44	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00e47	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00e4a	51		 push	 ecx
  00e4b	8b 55 08	 mov	 edx, DWORD PTR _pDC$[ebp]
  00e4e	8b 02		 mov	 eax, DWORD PTR [edx]
  00e50	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00e53	ff 50 34	 call	 DWORD PTR [eax+52]

; 505  : 		pDC->FillRect(rect, &CBrush( m_clrSelItemBK));

  00e56	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e59	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00e5c	52		 push	 edx
  00e5d	8d 4d e4	 lea	 ecx, DWORD PTR $T202258[ebp]
  00e60	e8 00 00 00 00	 call	 ??0CBrush@@QAE@K@Z	; CBrush::CBrush
  00e65	89 45 b8	 mov	 DWORD PTR tv217[ebp], eax
  00e68	8b 45 b8	 mov	 eax, DWORD PTR tv217[ebp]
  00e6b	89 45 b4	 mov	 DWORD PTR tv210[ebp], eax
  00e6e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00e75	8b 4d b4	 mov	 ecx, DWORD PTR tv210[ebp]
  00e78	51		 push	 ecx
  00e79	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  00e7c	e8 00 00 00 00	 call	 ??BCRect@@QBEPBUtagRECT@@XZ ; CRect::operator tagRECT const *
  00e81	50		 push	 eax
  00e82	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00e85	e8 00 00 00 00	 call	 ?FillRect@CDC@@QAEXPBUtagRECT@@PAVCBrush@@@Z ; CDC::FillRect
  00e8a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00e91	8d 4d e4	 lea	 ecx, DWORD PTR $T202258[ebp]
  00e94	e8 00 00 00 00	 call	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush

; 506  : 	}
; 507  : 	else

  00e99	e9 7c 01 00 00	 jmp	 $L200125
$L200123:

; 508  : 	{
; 509  : 		vector<int>::iterator ite=find(m_vecSearchedItems.begin(),m_vecSearchedItems.end(),iItem);

  00e9e	8d 55 10	 lea	 edx, DWORD PTR _iItem$[ebp]
  00ea1	52		 push	 edx
  00ea2	8d 45 e0	 lea	 eax, DWORD PTR $T202259[ebp]
  00ea5	50		 push	 eax
  00ea6	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ea9	81 c1 3c 01 00
	00		 add	 ecx, 316		; 0000013cH
  00eaf	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  00eb4	8b 08		 mov	 ecx, DWORD PTR [eax]
  00eb6	51		 push	 ecx
  00eb7	8d 55 dc	 lea	 edx, DWORD PTR $T202260[ebp]
  00eba	52		 push	 edx
  00ebb	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ebe	81 c1 3c 01 00
	00		 add	 ecx, 316		; 0000013cH
  00ec4	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
  00ec9	8b 00		 mov	 eax, DWORD PTR [eax]
  00ecb	50		 push	 eax
  00ecc	8d 4d f0	 lea	 ecx, DWORD PTR _ite$200243[ebp]
  00ecf	51		 push	 ecx
  00ed0	e8 00 00 00 00	 call	 ??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z ; std::find<std::vector<int,std::allocator<int> >::iterator,int>
  00ed5	83 c4 10	 add	 esp, 16			; 00000010H

; 510  : 		if (ite!=m_vecSearchedItems.end())

  00ed8	8d 55 d8	 lea	 edx, DWORD PTR $T202261[ebp]
  00edb	52		 push	 edx
  00edc	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00edf	81 c1 3c 01 00
	00		 add	 ecx, 316		; 0000013cH
  00ee5	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  00eea	50		 push	 eax
  00eeb	8d 4d f0	 lea	 ecx, DWORD PTR _ite$200243[ebp]
  00eee	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator!=
  00ef3	0f b6 c0	 movzx	 eax, al
  00ef6	85 c0		 test	 eax, eax
  00ef8	74 60		 je	 SHORT $L200255

; 511  : 		{
; 512  : 			pDC->SetBkColor( m_colorSearchHightLight);

  00efa	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00efd	8b 91 4c 01 00
	00		 mov	 edx, DWORD PTR [ecx+332]
  00f03	52		 push	 edx
  00f04	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  00f07	8b 10		 mov	 edx, DWORD PTR [eax]
  00f09	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00f0c	ff 52 34	 call	 DWORD PTR [edx+52]

; 513  : 			pDC->FillRect(rect, &CBrush( m_colorSearchHightLight));

  00f0f	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00f12	8b 88 4c 01 00
	00		 mov	 ecx, DWORD PTR [eax+332]
  00f18	51		 push	 ecx
  00f19	8d 4d d0	 lea	 ecx, DWORD PTR $T202262[ebp]
  00f1c	e8 00 00 00 00	 call	 ??0CBrush@@QAE@K@Z	; CBrush::CBrush
  00f21	89 45 b0	 mov	 DWORD PTR tv218[ebp], eax
  00f24	8b 55 b0	 mov	 edx, DWORD PTR tv218[ebp]
  00f27	89 55 ac	 mov	 DWORD PTR tv212[ebp], edx
  00f2a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00f31	8b 45 ac	 mov	 eax, DWORD PTR tv212[ebp]
  00f34	50		 push	 eax
  00f35	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  00f38	e8 00 00 00 00	 call	 ??BCRect@@QBEPBUtagRECT@@XZ ; CRect::operator tagRECT const *
  00f3d	50		 push	 eax
  00f3e	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00f41	e8 00 00 00 00	 call	 ?FillRect@CDC@@QAEXPBUtagRECT@@PAVCBrush@@@Z ; CDC::FillRect
  00f46	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00f4d	8d 4d d0	 lea	 ecx, DWORD PTR $T202262[ebp]
  00f50	e8 00 00 00 00	 call	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush

; 514  : 		}
; 515  : 		else

  00f55	e9 c0 00 00 00	 jmp	 $L200125
$L200255:

; 516  : 		{
; 517  : 			if( iItem % 2 )

  00f5a	8b 4d 10	 mov	 ecx, DWORD PTR _iItem$[ebp]
  00f5d	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  00f63	79 05		 jns	 SHORT $L202272
  00f65	49		 dec	 ecx
  00f66	83 c9 fe	 or	 ecx, -2			; fffffffeH
  00f69	41		 inc	 ecx
$L202272:
  00f6a	85 c9		 test	 ecx, ecx
  00f6c	74 57		 je	 SHORT $L200258

; 518  : 			{
; 519  : 				pDC->SetBkColor( m_clrOddItemBK);

  00f6e	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00f71	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00f74	50		 push	 eax
  00f75	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00f78	8b 11		 mov	 edx, DWORD PTR [ecx]
  00f7a	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00f7d	ff 52 34	 call	 DWORD PTR [edx+52]

; 520  : 				pDC->FillRect(rect, &CBrush( m_clrOddItemBK));

  00f80	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00f83	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00f86	51		 push	 ecx
  00f87	8d 4d c8	 lea	 ecx, DWORD PTR $T202263[ebp]
  00f8a	e8 00 00 00 00	 call	 ??0CBrush@@QAE@K@Z	; CBrush::CBrush
  00f8f	89 45 a8	 mov	 DWORD PTR tv219[ebp], eax
  00f92	8b 55 a8	 mov	 edx, DWORD PTR tv219[ebp]
  00f95	89 55 a4	 mov	 DWORD PTR tv214[ebp], edx
  00f98	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00f9f	8b 45 a4	 mov	 eax, DWORD PTR tv214[ebp]
  00fa2	50		 push	 eax
  00fa3	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  00fa6	e8 00 00 00 00	 call	 ??BCRect@@QBEPBUtagRECT@@XZ ; CRect::operator tagRECT const *
  00fab	50		 push	 eax
  00fac	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00faf	e8 00 00 00 00	 call	 ?FillRect@CDC@@QAEXPBUtagRECT@@PAVCBrush@@@Z ; CDC::FillRect
  00fb4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00fbb	8d 4d c8	 lea	 ecx, DWORD PTR $T202263[ebp]
  00fbe	e8 00 00 00 00	 call	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush

; 521  : 			}
; 522  : 			else

  00fc3	eb 55		 jmp	 SHORT $L200125
$L200258:

; 523  : 			{
; 524  : 				pDC->SetBkColor( m_clrEvenItemBK );

  00fc5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fc8	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00fcb	52		 push	 edx
  00fcc	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  00fcf	8b 10		 mov	 edx, DWORD PTR [eax]
  00fd1	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00fd4	ff 52 34	 call	 DWORD PTR [edx+52]

; 525  : 				pDC->FillRect(rect, &CBrush( m_clrEvenItemBK ));

  00fd7	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00fda	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00fdd	51		 push	 ecx
  00fde	8d 4d c0	 lea	 ecx, DWORD PTR $T202264[ebp]
  00fe1	e8 00 00 00 00	 call	 ??0CBrush@@QAE@K@Z	; CBrush::CBrush
  00fe6	89 45 a0	 mov	 DWORD PTR tv220[ebp], eax
  00fe9	8b 55 a0	 mov	 edx, DWORD PTR tv220[ebp]
  00fec	89 55 9c	 mov	 DWORD PTR tv216[ebp], edx
  00fef	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00ff6	8b 45 9c	 mov	 eax, DWORD PTR tv216[ebp]
  00ff9	50		 push	 eax
  00ffa	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  00ffd	e8 00 00 00 00	 call	 ??BCRect@@QBEPBUtagRECT@@XZ ; CRect::operator tagRECT const *
  01002	50		 push	 eax
  01003	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01006	e8 00 00 00 00	 call	 ?FillRect@CDC@@QAEXPBUtagRECT@@PAVCBrush@@@Z ; CDC::FillRect
  0100b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01012	8d 4d c0	 lea	 ecx, DWORD PTR $T202264[ebp]
  01015	e8 00 00 00 00	 call	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
$L200125:

; 526  : 			}
; 527  : 		}
; 528  : 	}
; 529  : /*
; 530  : 	if( m_bDrawItemTopLine )
; 531  : 	{
; 532  : 		//Item
; 533  : 		CRect rcTopLine = rect;
; 534  : 		rcTopLine.bottom = rcTopLine.top + 1;
; 535  : 		pDC->FillRect(rcTopLine, &CBrush(RGB(241,246,249)));
; 536  : 	}
; 537  : */
; 538  : 	if( !bHighlight && m_bDrawHoverRow && m_iCurrentCursorItem == iItem )

  0101a	83 7d 0c 00	 cmp	 DWORD PTR _bHighlight$[ebp], 0
  0101e	75 7d		 jne	 SHORT $L200122
  01020	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  01023	0f b6 91 54 01
	00 00		 movzx	 edx, BYTE PTR [ecx+340]
  0102a	85 d2		 test	 edx, edx
  0102c	74 6f		 je	 SHORT $L200122
  0102e	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  01031	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01037	3b 4d 10	 cmp	 ecx, DWORD PTR _iItem$[ebp]
  0103a	75 61		 jne	 SHORT $L200122

; 539  : 	{
; 540  : 		CDibBitmap *pDib = ::AfxGetUIManager()->UIGetSkinMgr()->GetDibBmp("ListHoverBK");

  0103c	e8 00 00 00 00	 call	 ?AfxGetUIManager@@YAPAVIUIManager@@XZ ; AfxGetUIManager
  01041	89 45 98	 mov	 DWORD PTR tv192[ebp], eax
  01044	8b 55 98	 mov	 edx, DWORD PTR tv192[ebp]
  01047	8b 02		 mov	 eax, DWORD PTR [edx]
  01049	8b 4d 98	 mov	 ecx, DWORD PTR tv192[ebp]
  0104c	ff 50 28	 call	 DWORD PTR [eax+40]
  0104f	89 45 94	 mov	 DWORD PTR tv197[ebp], eax
  01052	68 00 00 00 00	 push	 OFFSET FLAT:$SG200264
  01057	8b 4d 94	 mov	 ecx, DWORD PTR tv197[ebp]
  0105a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0105c	8b 4d 94	 mov	 ecx, DWORD PTR tv197[ebp]
  0105f	ff 52 04	 call	 DWORD PTR [edx+4]
  01062	89 45 ec	 mov	 DWORD PTR _pDib$200263[ebp], eax

; 541  : 		pDib->SetCDibRect(rect);

  01065	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01068	83 ec 10	 sub	 esp, 16			; 00000010H
  0106b	8b cc		 mov	 ecx, esp
  0106d	8b 10		 mov	 edx, DWORD PTR [eax]
  0106f	89 11		 mov	 DWORD PTR [ecx], edx
  01071	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01074	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  01077	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0107a	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0107d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  01080	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  01083	8b 4d ec	 mov	 ecx, DWORD PTR _pDib$200263[ebp]
  01086	e8 00 00 00 00	 call	 ?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ; CDibBitmap::SetCDibRect

; 542  : 		pDib->Draw(pDC, true);

  0108b	6a 01		 push	 1
  0108d	6a 00		 push	 0
  0108f	6a 01		 push	 1
  01091	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01094	51		 push	 ecx
  01095	8b 4d ec	 mov	 ecx, DWORD PTR _pDib$200263[ebp]
  01098	e8 00 00 00 00	 call	 ?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ; CDibBitmap::Draw
$L200122:

; 543  : 	}
; 544  : }

  0109d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  010a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  010a7	8b e5		 mov	 esp, ebp
  010a9	5d		 pop	 ebp
  010aa	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
text$x	SEGMENT
$L202265:
  000c0	8d 4d e4	 lea	 ecx, DWORD PTR $T202258[ebp]
  000c3	e9 00 00 00 00	 jmp	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
$L202266:
  000c8	8d 4d d0	 lea	 ecx, DWORD PTR $T202262[ebp]
  000cb	e9 00 00 00 00	 jmp	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
$L202267:
  000d0	8d 4d c8	 lea	 ecx, DWORD PTR $T202263[ebp]
  000d3	e9 00 00 00 00	 jmp	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
$L202268:
  000d8	8d 4d c0	 lea	 ecx, DWORD PTR $T202264[ebp]
  000db	e9 00 00 00 00	 jmp	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
__ehhandler$?SetItemBkColor@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z:
  000e0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202270
  000e5	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SetItemBkColor@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z ENDP ; CMyListCtrl::SetItemBkColor
PUBLIC	?GetFocus@CWnd@@SGPAV1@XZ			; CWnd::GetFocus
PUBLIC	?DrawImage@CMyListCtrl@@IAEXPAVCDibBitmap@@ABVCRect@@PAVCDC@@@Z ; CMyListCtrl::DrawImage
PUBLIC	?GetItem@CListCtrl@@QBEHPAUtagLVITEMA@@@Z	; CListCtrl::GetItem
EXTRN	?GetItemText@CListCtrl@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z:NEAR ; CListCtrl::GetItemText
EXTRN	__imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:NEAR
EXTRN	?SetBkMode@CDC@@QAEHH@Z:NEAR			; CDC::SetBkMode
EXTRN	__imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ:NEAR
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	?GetStyle@CWnd@@QBEKXZ:NEAR			; CWnd::GetStyle
xdata$x	SEGMENT
$T202283 DD	0ffffffffH
	DD	FLAT:$L202279
$T202281 DD	019930520H
	DD	01H
	DD	FLAT:$T202283
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv146 = -116						; size = 4
_this$ = -112						; size = 4
_lvi$200278 = -108					; size = 52
_bHighlight$200279 = -56				; size = 4
_rc$200281 = -52					; size = 16
_nJustify$ = -36					; size = 4
_rcLabel$ = -32						; size = 16
_sLabel$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pDC$ = 8						; size = 4
_iItem$ = 12						; size = 4
_iColumn$ = 16						; size = 4
_rectColumn$ = 20					; size = 4
?DrawTextColumn@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z PROC NEAR ; CMyListCtrl::DrawTextColumn
; _this$ = ecx

; 547  : {

  010b0	55		 push	 ebp
  010b1	8b ec		 mov	 ebp, esp
  010b3	6a ff		 push	 -1
  010b5	68 00 00 00 00	 push	 __ehhandler$?DrawTextColumn@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z
  010ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  010c0	50		 push	 eax
  010c1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  010c8	83 ec 68	 sub	 esp, 104		; 00000068H
  010cb	89 4d 90	 mov	 DWORD PTR _this$[ebp], ecx

; 548  : 	CString sLabel = GetItemText(iItem, iColumn);

  010ce	8b 45 10	 mov	 eax, DWORD PTR _iColumn$[ebp]
  010d1	50		 push	 eax
  010d2	8b 4d 0c	 mov	 ecx, DWORD PTR _iItem$[ebp]
  010d5	51		 push	 ecx
  010d6	8d 55 f0	 lea	 edx, DWORD PTR _sLabel$[ebp]
  010d9	52		 push	 edx
  010da	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  010dd	e8 00 00 00 00	 call	 ?GetItemText@CListCtrl@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z ; CListCtrl::GetItemText
  010e2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 549  : 	if (sLabel.GetLength() == 0)

  010e9	8d 4d f0	 lea	 ecx, DWORD PTR _sLabel$[ebp]
  010ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  010f2	85 c0		 test	 eax, eax
  010f4	75 15		 jne	 SHORT $L200274

; 550  : 	{
; 551  : 		return;

  010f6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  010fd	8d 4d f0	 lea	 ecx, DWORD PTR _sLabel$[ebp]
  01100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  01106	e9 b7 01 00 00	 jmp	 $L200271
$L200274:

; 552  : 	}
; 553  : 
; 554  : 	// Get the text justification
; 555  : 	UINT nJustify = DT_LEFT;

  0110b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _nJustify$[ebp], 0

; 556  : 	CRect rcLabel = rectColumn;

  01112	8b 45 14	 mov	 eax, DWORD PTR _rectColumn$[ebp]
  01115	8b 08		 mov	 ecx, DWORD PTR [eax]
  01117	89 4d e0	 mov	 DWORD PTR _rcLabel$[ebp], ecx
  0111a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0111d	89 55 e4	 mov	 DWORD PTR _rcLabel$[ebp+4], edx
  01120	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01123	89 4d e8	 mov	 DWORD PTR _rcLabel$[ebp+8], ecx
  01126	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01129	89 55 ec	 mov	 DWORD PTR _rcLabel$[ebp+12], edx

; 557  : 	rcLabel.left += m_iOffset;

  0112c	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0112f	8b 4d e0	 mov	 ecx, DWORD PTR _rcLabel$[ebp]
  01132	03 48 7c	 add	 ecx, DWORD PTR [eax+124]
  01135	89 4d e0	 mov	 DWORD PTR _rcLabel$[ebp], ecx

; 558  : 	rcLabel.right -= m_iOffset;

  01138	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0113b	8b 45 e8	 mov	 eax, DWORD PTR _rcLabel$[ebp+8]
  0113e	2b 42 7c	 sub	 eax, DWORD PTR [edx+124]
  01141	89 45 e8	 mov	 DWORD PTR _rcLabel$[ebp+8], eax

; 559  : 
; 560  : 	pDC->SetBkMode(TRANSPARENT);

  01144	6a 01		 push	 1
  01146	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01149	e8 00 00 00 00	 call	 ?SetBkMode@CDC@@QAEHH@Z	; CDC::SetBkMode

; 561  : 
; 562  : 	pDC->DrawText(sLabel, -1, rcLabel, nJustify | DT_SINGLELINE | DT_NOPREFIX | DT_VCENTER | DT_END_ELLIPSIS);

  0114e	8b 4d dc	 mov	 ecx, DWORD PTR _nJustify$[ebp]
  01151	83 c9 20	 or	 ecx, 32			; 00000020H
  01154	81 c9 00 08 00
	00		 or	 ecx, 2048		; 00000800H
  0115a	83 c9 04	 or	 ecx, 4
  0115d	81 c9 00 80 00
	00		 or	 ecx, 32768		; 00008000H
  01163	51		 push	 ecx
  01164	8d 4d e0	 lea	 ecx, DWORD PTR _rcLabel$[ebp]
  01167	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  0116c	50		 push	 eax
  0116d	6a ff		 push	 -1
  0116f	8d 4d f0	 lea	 ecx, DWORD PTR _sLabel$[ebp]
  01172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  01178	50		 push	 eax
  01179	8b 55 08	 mov	 edx, DWORD PTR _pDC$[ebp]
  0117c	8b 02		 mov	 eax, DWORD PTR [edx]
  0117e	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01181	ff 50 70	 call	 DWORD PTR [eax+112]

; 563  : 
; 564  : 	if( m_mapColumnInfo[iColumn].bOperatorBtn )

  01184	8d 4d 10	 lea	 ecx, DWORD PTR _iColumn$[ebp]
  01187	51		 push	 ecx
  01188	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0118b	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  01191	e8 00 00 00 00	 call	 ??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[]
  01196	0f b6 50 28	 movzx	 edx, BYTE PTR [eax+40]
  0119a	85 d2		 test	 edx, edx
  0119c	0f 84 10 01 00
	00		 je	 $L200277

; 565  : 	{
; 566  : 		LV_ITEM lvi;
; 567  : 		lvi.mask		= LVIF_STATE;

  011a2	c7 45 94 08 00
	00 00		 mov	 DWORD PTR _lvi$200278[ebp], 8

; 568  : 		lvi.iItem		= iItem;

  011a9	8b 45 0c	 mov	 eax, DWORD PTR _iItem$[ebp]
  011ac	89 45 98	 mov	 DWORD PTR _lvi$200278[ebp+4], eax

; 569  : 		lvi.iSubItem	= 0;

  011af	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _lvi$200278[ebp+8], 0

; 570  : 		lvi.stateMask	= 0xFFFF;   

  011b6	c7 45 a4 ff ff
	00 00		 mov	 DWORD PTR _lvi$200278[ebp+16], 65535 ; 0000ffffH

; 571  : 		GetItem(&lvi);

  011bd	8d 4d 94	 lea	 ecx, DWORD PTR _lvi$200278[ebp]
  011c0	51		 push	 ecx
  011c1	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  011c4	e8 00 00 00 00	 call	 ?GetItem@CListCtrl@@QBEHPAUtagLVITEMA@@@Z ; CListCtrl::GetItem

; 572  : 
; 573  : 		BOOL bHighlight =( (lvi.state & LVIS_DROPHILITED) || ( (lvi.state & LVIS_SELECTED)&& ((GetFocus() == this)|| (GetStyle() & LVS_SHOWSELALWAYS)	)	)		);

  011c9	8b 55 a0	 mov	 edx, DWORD PTR _lvi$200278[ebp+12]
  011cc	83 e2 08	 and	 edx, 8
  011cf	75 28		 jne	 SHORT $L202275
  011d1	8b 45 a0	 mov	 eax, DWORD PTR _lvi$200278[ebp+12]
  011d4	83 e0 02	 and	 eax, 2
  011d7	74 17		 je	 SHORT $L202276
  011d9	e8 00 00 00 00	 call	 ?GetFocus@CWnd@@SGPAV1@XZ ; CWnd::GetFocus
  011de	3b 45 90	 cmp	 eax, DWORD PTR _this$[ebp]
  011e1	74 16		 je	 SHORT $L202275
  011e3	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  011e6	e8 00 00 00 00	 call	 ?GetStyle@CWnd@@QBEKXZ	; CWnd::GetStyle
  011eb	83 e0 08	 and	 eax, 8
  011ee	75 09		 jne	 SHORT $L202275
$L202276:
  011f0	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv146[ebp], 0
  011f7	eb 07		 jmp	 SHORT $L202278
$L202275:
  011f9	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR tv146[ebp], 1
$L202278:
  01200	8b 4d 8c	 mov	 ecx, DWORD PTR tv146[ebp]
  01203	89 4d c8	 mov	 DWORD PTR _bHighlight$200279[ebp], ecx

; 574  : 
; 575  : 		if( !bHighlight )

  01206	83 7d c8 00	 cmp	 DWORD PTR _bHighlight$200279[ebp], 0
  0120a	75 15		 jne	 SHORT $L200280

; 576  : 		{
; 577  : 			return;

  0120c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01213	8d 4d f0	 lea	 ecx, DWORD PTR _sLabel$[ebp]
  01216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0121c	e9 a1 00 00 00	 jmp	 $L200271
$L200280:

; 578  : 		}
; 579  : 
; 580  : 		CRect rc = CRect(rectColumn.right-20, rectColumn.top, rectColumn.right, rectColumn.bottom);

  01221	8b 55 14	 mov	 edx, DWORD PTR _rectColumn$[ebp]
  01224	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01227	50		 push	 eax
  01228	8b 4d 14	 mov	 ecx, DWORD PTR _rectColumn$[ebp]
  0122b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0122e	52		 push	 edx
  0122f	8b 45 14	 mov	 eax, DWORD PTR _rectColumn$[ebp]
  01232	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01235	51		 push	 ecx
  01236	8b 55 14	 mov	 edx, DWORD PTR _rectColumn$[ebp]
  01239	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0123c	83 e8 14	 sub	 eax, 20			; 00000014H
  0123f	50		 push	 eax
  01240	8d 4d cc	 lea	 ecx, DWORD PTR _rc$200281[ebp]
  01243	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect

; 581  : 		if( m_iOverImageItem == iItem && m_iOverImageSubItem == iColumn )

  01248	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0124b	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  01251	3b 55 0c	 cmp	 edx, DWORD PTR _iItem$[ebp]
  01254	75 36		 jne	 SHORT $L200283
  01256	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01259	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  0125f	3b 4d 10	 cmp	 ecx, DWORD PTR _iColumn$[ebp]
  01262	75 28		 jne	 SHORT $L200283

; 582  : 		{
; 583  : 			DrawImage(  m_mapColumnInfo[iColumn].ColumnOperatorImage.pBitmapOver,rc,pDC );

  01264	8b 55 08	 mov	 edx, DWORD PTR _pDC$[ebp]
  01267	52		 push	 edx
  01268	8d 45 cc	 lea	 eax, DWORD PTR _rc$200281[ebp]
  0126b	50		 push	 eax
  0126c	8d 4d 10	 lea	 ecx, DWORD PTR _iColumn$[ebp]
  0126f	51		 push	 ecx
  01270	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01273	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  01279	e8 00 00 00 00	 call	 ??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[]
  0127e	8b 50 44	 mov	 edx, DWORD PTR [eax+68]
  01281	52		 push	 edx
  01282	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01285	e8 00 00 00 00	 call	 ?DrawImage@CMyListCtrl@@IAEXPAVCDibBitmap@@ABVCRect@@PAVCDC@@@Z ; CMyListCtrl::DrawImage

; 584  : 		}
; 585  : 		else

  0128a	eb 26		 jmp	 SHORT $L200277
$L200283:

; 586  : 		{
; 587  : 			DrawImage(  m_mapColumnInfo[iColumn].ColumnOperatorImage.pBitmapNormal,rc,pDC );

  0128c	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  0128f	50		 push	 eax
  01290	8d 4d cc	 lea	 ecx, DWORD PTR _rc$200281[ebp]
  01293	51		 push	 ecx
  01294	8d 55 10	 lea	 edx, DWORD PTR _iColumn$[ebp]
  01297	52		 push	 edx
  01298	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0129b	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  012a1	e8 00 00 00 00	 call	 ??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[]
  012a6	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  012a9	50		 push	 eax
  012aa	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  012ad	e8 00 00 00 00	 call	 ?DrawImage@CMyListCtrl@@IAEXPAVCDibBitmap@@ABVCRect@@PAVCDC@@@Z ; CMyListCtrl::DrawImage
$L200277:

; 588  : 		}
; 589  : 	}
; 590  : }

  012b2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  012b9	8d 4d f0	 lea	 ecx, DWORD PTR _sLabel$[ebp]
  012bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L200271:
  012c2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  012c5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  012cc	8b e5		 mov	 esp, ebp
  012ce	5d		 pop	 ebp
  012cf	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
text$x	SEGMENT
$L202279:
  000ea	8d 4d f0	 lea	 ecx, DWORD PTR _sLabel$[ebp]
  000ed	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?DrawTextColumn@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z:
  000f3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202281
  000f8	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DrawTextColumn@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@@Z ENDP ; CMyListCtrl::DrawTextColumn
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pt$ = 8						; size = 4
?NeedChangeCursor@CMyListCtrl@@UAEHAAVCPoint@@@Z PROC NEAR ; CMyListCtrl::NeedChangeCursor
; _this$ = ecx

; 593  : {

  012e0	55		 push	 ebp
  012e1	8b ec		 mov	 ebp, esp
  012e3	51		 push	 ecx
  012e4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 594  : 	return FALSE;

  012e7	33 c0		 xor	 eax, eax

; 595  : }

  012e9	8b e5		 mov	 esp, ebp
  012eb	5d		 pop	 ebp
  012ec	c2 04 00	 ret	 4
?NeedChangeCursor@CMyListCtrl@@UAEHAAVCPoint@@@Z ENDP	; CMyListCtrl::NeedChangeCursor
; Function compile flags: /Odt
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
_iItem$ = 12						; size = 4
_iColumn$ = 16						; size = 4
_rect$ = 20						; size = 4
_bSelected$ = 24					; size = 4
?DrawImageColumn@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@H@Z PROC NEAR ; CMyListCtrl::DrawImageColumn
; _this$ = ecx

; 598  : {

  012f0	55		 push	 ebp
  012f1	8b ec		 mov	 ebp, esp
  012f3	51		 push	 ecx
  012f4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 599  : 	if( m_iOverImageItem == iItem && m_iOverImageSubItem == iColumn )

  012f7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012fa	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  01300	3b 4d 0c	 cmp	 ecx, DWORD PTR _iItem$[ebp]
  01303	75 36		 jne	 SHORT $L200297
  01305	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01308	8b 82 8c 00 00
	00		 mov	 eax, DWORD PTR [edx+140]
  0130e	3b 45 10	 cmp	 eax, DWORD PTR _iColumn$[ebp]
  01311	75 28		 jne	 SHORT $L200297

; 600  : 	{
; 601  : 		DrawImage( m_mapColumnInfo[iColumn].ColumnImage.pBitmapOver,rect,pDC);

  01313	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01316	51		 push	 ecx
  01317	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  0131a	52		 push	 edx
  0131b	8d 45 10	 lea	 eax, DWORD PTR _iColumn$[ebp]
  0131e	50		 push	 eax
  0131f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01322	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  01328	e8 00 00 00 00	 call	 ??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[]
  0132d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01330	51		 push	 ecx
  01331	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01334	e8 00 00 00 00	 call	 ?DrawImage@CMyListCtrl@@IAEXPAVCDibBitmap@@ABVCRect@@PAVCDC@@@Z ; CMyListCtrl::DrawImage

; 602  : 		return;

  01339	eb 54		 jmp	 SHORT $L200296
$L200297:

; 603  : 	}
; 604  : 
; 605  : 	if( bSelected )

  0133b	83 7d 18 00	 cmp	 DWORD PTR _bSelected$[ebp], 0
  0133f	74 28		 je	 SHORT $L200298

; 606  : 	{
; 607  : 		DrawImage( m_mapColumnInfo[iColumn].ColumnImage.pBitmapSelected,rect,pDC);

  01341	8b 55 08	 mov	 edx, DWORD PTR _pDC$[ebp]
  01344	52		 push	 edx
  01345	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01348	50		 push	 eax
  01349	8d 4d 10	 lea	 ecx, DWORD PTR _iColumn$[ebp]
  0134c	51		 push	 ecx
  0134d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01350	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  01356	e8 00 00 00 00	 call	 ??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[]
  0135b	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  0135e	52		 push	 edx
  0135f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01362	e8 00 00 00 00	 call	 ?DrawImage@CMyListCtrl@@IAEXPAVCDibBitmap@@ABVCRect@@PAVCDC@@@Z ; CMyListCtrl::DrawImage

; 608  : 		return;

  01367	eb 26		 jmp	 SHORT $L200296
$L200298:

; 609  : 	}	
; 610  : 	DrawImage( m_mapColumnInfo[iColumn].ColumnImage.pBitmapNormal,rect,pDC);

  01369	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  0136c	50		 push	 eax
  0136d	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  01370	51		 push	 ecx
  01371	8d 55 10	 lea	 edx, DWORD PTR _iColumn$[ebp]
  01374	52		 push	 edx
  01375	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01378	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  0137e	e8 00 00 00 00	 call	 ??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[]
  01383	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  01386	50		 push	 eax
  01387	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0138a	e8 00 00 00 00	 call	 ?DrawImage@CMyListCtrl@@IAEXPAVCDibBitmap@@ABVCRect@@PAVCDC@@@Z ; CMyListCtrl::DrawImage
$L200296:

; 611  : }

  0138f	8b e5		 mov	 esp, ebp
  01391	5d		 pop	 ebp
  01392	c2 14 00	 ret	 20			; 00000014H
?DrawImageColumn@CMyListCtrl@@UAEXPAVCDC@@HHABVCRect@@H@Z ENDP ; CMyListCtrl::DrawImageColumn
_TEXT	ENDS
PUBLIC	??0CSize@@QAE@HH@Z				; CSize::CSize
PUBLIC	??0CPoint@@QAE@XZ				; CPoint::CPoint
PUBLIC	??0CRect@@QAE@UtagPOINT@@UtagSIZE@@@Z		; CRect::CRect
PUBLIC	?CenterPoint@CRect@@QBE?AVCPoint@@XZ		; CRect::CenterPoint
PUBLIC	?PointInSubitemImage@CMyListCtrl@@IAEHAAVCPoint@@@Z ; CMyListCtrl::PointInSubitemImage
PUBLIC	??0MYLIST_COLUMN_INFO@@QAE@XZ			; MYLIST_COLUMN_INFO::MYLIST_COLUMN_INFO
PUBLIC	??1MYLIST_COLUMN_INFO@@QAE@XZ			; MYLIST_COLUMN_INFO::~MYLIST_COLUMN_INFO
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__PtInRect@12:NEAR
xdata$x	SEGMENT
$T202304 DD	0ffffffffH
	DD	FLAT:$L202297
$T202299 DD	019930520H
	DD	01H
	DD	FLAT:$T202304
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -196						; size = 4
$T202296 = -192						; size = 4
$T202295 = -188						; size = 4
$T202294 = -184						; size = 8
$T202293 = -176						; size = 8
$T202292 = -168						; size = 8
$T202291 = -160						; size = 16
$T202290 = -144						; size = 8
$T202289 = -136						; size = 8
$T202288 = -128						; size = 4
_pointImage$ = -124					; size = 8
_rectSubItem$ = -116					; size = 16
_columnInfo$ = -100					; size = 76
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pt$ = 8						; size = 4
?PointInSubitemImage@CMyListCtrl@@IAEHAAVCPoint@@@Z PROC NEAR ; CMyListCtrl::PointInSubitemImage
; _this$ = ecx

; 614  : {

  013a0	55		 push	 ebp
  013a1	8b ec		 mov	 ebp, esp
  013a3	6a ff		 push	 -1
  013a5	68 00 00 00 00	 push	 __ehhandler$?PointInSubitemImage@CMyListCtrl@@IAEHAAVCPoint@@@Z
  013aa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  013b0	50		 push	 eax
  013b1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  013b8	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  013be	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  013c3	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  013c6	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 615  : 	MYLIST_COLUMN_INFO columnInfo;

  013cc	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  013cf	e8 00 00 00 00	 call	 ??0MYLIST_COLUMN_INFO@@QAE@XZ ; MYLIST_COLUMN_INFO::MYLIST_COLUMN_INFO
  013d4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 616  : 	CPoint pointImage;

  013db	8d 4d 84	 lea	 ecx, DWORD PTR _pointImage$[ebp]
  013de	e8 00 00 00 00	 call	 ??0CPoint@@QAE@XZ	; CPoint::CPoint

; 617  : 	CRect  rectSubItem;

  013e3	8d 4d 8c	 lea	 ecx, DWORD PTR _rectSubItem$[ebp]
  013e6	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 618  : 
; 619  : 	if( m_iCurrentCursorItem == -1 || m_iCurrentCursorSubItem == -1 )

  013eb	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  013f1	83 b8 80 00 00
	00 ff		 cmp	 DWORD PTR [eax+128], -1
  013f8	74 0f		 je	 SHORT $L200307
  013fa	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01400	83 b9 84 00 00
	00 ff		 cmp	 DWORD PTR [ecx+132], -1
  01407	75 1e		 jne	 SHORT $L200306
$L200307:

; 620  : 	{
; 621  : 		return FALSE;

  01409	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T202288[ebp], 0
  01410	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01417	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  0141a	e8 00 00 00 00	 call	 ??1MYLIST_COLUMN_INFO@@QAE@XZ
  0141f	8b 45 80	 mov	 eax, DWORD PTR $T202288[ebp]
  01422	e9 a8 01 00 00	 jmp	 $L200302
$L200306:

; 622  : 	}
; 623  : 
; 624  : 	GetSubItemRect( m_iCurrentCursorItem,m_iCurrentCursorSubItem,LVIR_BOUNDS,rectSubItem);

  01427	8d 55 8c	 lea	 edx, DWORD PTR _rectSubItem$[ebp]
  0142a	52		 push	 edx
  0142b	6a 00		 push	 0
  0142d	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01433	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  01439	51		 push	 ecx
  0143a	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01440	8b 82 80 00 00
	00		 mov	 eax, DWORD PTR [edx+128]
  01446	50		 push	 eax
  01447	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0144d	e8 00 00 00 00	 call	 ?GetSubItemRect@CListCtrl@@QAEHHHHAAVCRect@@@Z ; CListCtrl::GetSubItemRect

; 625  : 
; 626  : 	columnInfo			= m_mapColumnInfo[m_iCurrentCursorSubItem];

  01452	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01458	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0145e	51		 push	 ecx
  0145f	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01465	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  0146b	e8 00 00 00 00	 call	 ??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[]
  01470	50		 push	 eax
  01471	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  01474	e8 00 00 00 00	 call	 ??4MYLIST_COLUMN_INFO@@QAEAAU0@ABU0@@Z ; MYLIST_COLUMN_INFO::operator=

; 627  : 	rectSubItem.right	= rectSubItem.left + GetColumnWidth(m_iCurrentCursorSubItem);

  01479	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0147f	8b 82 84 00 00
	00		 mov	 eax, DWORD PTR [edx+132]
  01485	50		 push	 eax
  01486	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0148c	e8 00 00 00 00	 call	 ?GetColumnWidth@CListCtrl@@QBEHH@Z ; CListCtrl::GetColumnWidth
  01491	03 45 8c	 add	 eax, DWORD PTR _rectSubItem$[ebp]
  01494	89 45 94	 mov	 DWORD PTR _rectSubItem$[ebp+8], eax

; 628  : 	pointImage			= rectSubItem.CenterPoint();

  01497	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T202289[ebp]
  0149d	51		 push	 ecx
  0149e	8d 4d 8c	 lea	 ecx, DWORD PTR _rectSubItem$[ebp]
  014a1	e8 00 00 00 00	 call	 ?CenterPoint@CRect@@QBE?AVCPoint@@XZ ; CRect::CenterPoint
  014a6	8b 10		 mov	 edx, DWORD PTR [eax]
  014a8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  014ab	89 55 84	 mov	 DWORD PTR _pointImage$[ebp], edx
  014ae	89 45 88	 mov	 DWORD PTR _pointImage$[ebp+4], eax

; 629  : 	pointImage.x		= pointImage.x - columnInfo.ColumnImage.pBitmapNormal->GetWidth() /2;

  014b1	8b 4d c8	 mov	 ecx, DWORD PTR _columnInfo$[ebp+44]
  014b4	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  014b9	99		 cdq
  014ba	2b c2		 sub	 eax, edx
  014bc	d1 f8		 sar	 eax, 1
  014be	8b 4d 84	 mov	 ecx, DWORD PTR _pointImage$[ebp]
  014c1	2b c8		 sub	 ecx, eax
  014c3	89 4d 84	 mov	 DWORD PTR _pointImage$[ebp], ecx

; 630  : 	pointImage.y		= pointImage.y - columnInfo.ColumnImage.pBitmapNormal->GetHeight() /2;

  014c6	8b 4d c8	 mov	 ecx, DWORD PTR _columnInfo$[ebp+44]
  014c9	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  014ce	99		 cdq
  014cf	2b c2		 sub	 eax, edx
  014d1	d1 f8		 sar	 eax, 1
  014d3	8b 55 88	 mov	 edx, DWORD PTR _pointImage$[ebp+4]
  014d6	2b d0		 sub	 edx, eax
  014d8	89 55 88	 mov	 DWORD PTR _pointImage$[ebp+4], edx

; 631  : 
; 632  : 	if( PtInRect( CRect(pointImage,CSize(columnInfo.ColumnImage.pBitmapNormal->GetWidth(),columnInfo.ColumnImage.pBitmapNormal->GetHeight() ) ),pt))

  014db	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  014de	8b 08		 mov	 ecx, DWORD PTR [eax]
  014e0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  014e3	89 8d 70 ff ff
	ff		 mov	 DWORD PTR $T202290[ebp], ecx
  014e9	89 95 74 ff ff
	ff		 mov	 DWORD PTR $T202290[ebp+4], edx
  014ef	8b 4d c8	 mov	 ecx, DWORD PTR _columnInfo$[ebp+44]
  014f2	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  014f7	50		 push	 eax
  014f8	8b 4d c8	 mov	 ecx, DWORD PTR _columnInfo$[ebp+44]
  014fb	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  01500	50		 push	 eax
  01501	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T202293[ebp]
  01507	e8 00 00 00 00	 call	 ??0CSize@@QAE@HH@Z	; CSize::CSize
  0150c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0150e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01511	89 8d 58 ff ff
	ff		 mov	 DWORD PTR $T202292[ebp], ecx
  01517	89 95 5c ff ff
	ff		 mov	 DWORD PTR $T202292[ebp+4], edx
  0151d	8b 45 84	 mov	 eax, DWORD PTR _pointImage$[ebp]
  01520	89 85 48 ff ff
	ff		 mov	 DWORD PTR $T202294[ebp], eax
  01526	8b 4d 88	 mov	 ecx, DWORD PTR _pointImage$[ebp+4]
  01529	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T202294[ebp+4], ecx
  0152f	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR $T202290[ebp+4]
  01535	52		 push	 edx
  01536	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T202290[ebp]
  0153c	50		 push	 eax
  0153d	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR $T202292[ebp+4]
  01543	51		 push	 ecx
  01544	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR $T202292[ebp]
  0154a	52		 push	 edx
  0154b	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR $T202294[ebp+4]
  01551	50		 push	 eax
  01552	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR $T202294[ebp]
  01558	51		 push	 ecx
  01559	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T202291[ebp]
  0155f	e8 00 00 00 00	 call	 ??0CRect@@QAE@UtagPOINT@@UtagSIZE@@@Z ; CRect::CRect
  01564	8b c8		 mov	 ecx, eax
  01566	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  0156b	50		 push	 eax
  0156c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  01572	85 c0		 test	 eax, eax
  01574	74 3a		 je	 SHORT $L200315

; 633  : 	{
; 634  : 		pt.x = pointImage.x;

  01576	8b 55 08	 mov	 edx, DWORD PTR _pt$[ebp]
  01579	8b 45 84	 mov	 eax, DWORD PTR _pointImage$[ebp]
  0157c	89 02		 mov	 DWORD PTR [edx], eax

; 635  : 		pt.y = pointImage.y + columnInfo.ColumnImage.pBitmapNormal->GetHeight();

  0157e	8b 4d c8	 mov	 ecx, DWORD PTR _columnInfo$[ebp+44]
  01581	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  01586	03 45 88	 add	 eax, DWORD PTR _pointImage$[ebp+4]
  01589	8b 4d 08	 mov	 ecx, DWORD PTR _pt$[ebp]
  0158c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 636  : 		return TRUE;

  0158f	c7 85 44 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T202295[ebp], 1
  01599	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  015a0	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  015a3	e8 00 00 00 00	 call	 ??1MYLIST_COLUMN_INFO@@QAE@XZ
  015a8	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR $T202295[ebp]
  015ae	eb 1f		 jmp	 SHORT $L200302
$L200315:

; 637  : 	}
; 638  : 	return FALSE;

  015b0	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T202296[ebp], 0
  015ba	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  015c1	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  015c4	e8 00 00 00 00	 call	 ??1MYLIST_COLUMN_INFO@@QAE@XZ
  015c9	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR $T202296[ebp]
$L200302:

; 639  : }

  015cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  015d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  015d9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015e1	8b e5		 mov	 esp, ebp
  015e3	5d		 pop	 ebp
  015e4	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L202297:
  000fd	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  00100	e9 00 00 00 00	 jmp	 ??1MYLIST_COLUMN_INFO@@QAE@XZ
__ehhandler$?PointInSubitemImage@CMyListCtrl@@IAEHAAVCPoint@@@Z:
  00105	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202299
  0010a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?PointInSubitemImage@CMyListCtrl@@IAEHAAVCPoint@@@Z ENDP ; CMyListCtrl::PointInSubitemImage
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0MYLIST_COLUMN_IMAGE@@QAE@XZ			; MYLIST_COLUMN_IMAGE::MYLIST_COLUMN_IMAGE
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
;	COMDAT xdata$x
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\mylistctrldata.h
xdata$x	SEGMENT
$T202310 DD	0ffffffffH
	DD	FLAT:$L202306
$T202308 DD	019930520H
	DD	01H
	DD	FLAT:$T202310
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0MYLIST_COLUMN_INFO@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0MYLIST_COLUMN_INFO@@QAE@XZ PROC NEAR			; MYLIST_COLUMN_INFO::MYLIST_COLUMN_INFO, COMDAT
; _this$ = ecx

; 35   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0MYLIST_COLUMN_INFO@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	c7 41 20 ff ff
	ff ff		 mov	 DWORD PTR [ecx+32], -1
  00045	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00048	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0
  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c6 40 28 00	 mov	 BYTE PTR [eax+40], 0
  00056	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0005c	e8 00 00 00 00	 call	 ??0MYLIST_COLUMN_IMAGE@@QAE@XZ ; MYLIST_COLUMN_IMAGE::MYLIST_COLUMN_IMAGE
  00061	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00067	e8 00 00 00 00	 call	 ??0MYLIST_COLUMN_IMAGE@@QAE@XZ ; MYLIST_COLUMN_IMAGE::MYLIST_COLUMN_IMAGE
  0006c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00073	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00076	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00079	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202306:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0MYLIST_COLUMN_INFO@@QAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202308
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0MYLIST_COLUMN_INFO@@QAE@XZ ENDP			; MYLIST_COLUMN_INFO::MYLIST_COLUMN_INFO
; Function compile flags: /Odt
;	COMDAT ??0MYLIST_COLUMN_IMAGE@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MYLIST_COLUMN_IMAGE@@QAE@XZ PROC NEAR		; MYLIST_COLUMN_IMAGE::MYLIST_COLUMN_IMAGE, COMDAT
; _this$ = ecx

; 12   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??0MYLIST_COLUMN_IMAGE@@QAE@XZ ENDP			; MYLIST_COLUMN_IMAGE::MYLIST_COLUMN_IMAGE
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1MYLIST_COLUMN_INFO@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1MYLIST_COLUMN_INFO@@QAE@XZ PROC NEAR			; MYLIST_COLUMN_INFO::~MYLIST_COLUMN_INFO, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1MYLIST_COLUMN_INFO@@QAE@XZ ENDP			; MYLIST_COLUMN_INFO::~MYLIST_COLUMN_INFO
_TEXT	ENDS
PUBLIC	?PointInOperatorBtn@CMyListCtrl@@IAEHAAVCPoint@@@Z ; CMyListCtrl::PointInOperatorBtn
xdata$x	SEGMENT
$T202339 DD	0ffffffffH
	DD	FLAT:$L202334
$T202336 DD	019930520H
	DD	01H
	DD	FLAT:$T202339
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\mylistctrl.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv78 = -252						; size = 4
_this$ = -248						; size = 4
$T202333 = -244						; size = 4
$T202332 = -240						; size = 4
$T202331 = -236						; size = 8
$T202330 = -228						; size = 8
$T202329 = -220						; size = 8
$T202328 = -212						; size = 16
$T202327 = -196						; size = 8
$T202326 = -188						; size = 8
$T202325 = -180						; size = 4
_pointImage$ = -176					; size = 8
_rectSubItem$ = -168					; size = 16
_lvi$ = -152						; size = 52
_columnInfo$ = -100					; size = 76
__$ArrayPad$ = -20					; size = 4
_bHighlight$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pt$ = 8						; size = 4
?PointInOperatorBtn@CMyListCtrl@@IAEHAAVCPoint@@@Z PROC NEAR ; CMyListCtrl::PointInOperatorBtn
; _this$ = ecx

; 642  : {

  015f0	55		 push	 ebp
  015f1	8b ec		 mov	 ebp, esp
  015f3	6a ff		 push	 -1
  015f5	68 00 00 00 00	 push	 __ehhandler$?PointInOperatorBtn@CMyListCtrl@@IAEHAAVCPoint@@@Z
  015fa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01600	50		 push	 eax
  01601	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01608	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  0160e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  01613	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01616	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 	LV_ITEM lvi;
; 644  : 	lvi.mask		= LVIF_STATE;

  0161c	c7 85 68 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR _lvi$[ebp], 8

; 645  : 	lvi.iItem		= m_iCurrentCursorItem;

  01626	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0162c	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01632	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _lvi$[ebp+4], ecx

; 646  : 	lvi.iSubItem	= m_iCurrentCursorSubItem;

  01638	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0163e	8b 82 84 00 00
	00		 mov	 eax, DWORD PTR [edx+132]
  01644	89 85 70 ff ff
	ff		 mov	 DWORD PTR _lvi$[ebp+8], eax

; 647  : 	lvi.stateMask	= 0xFFFF;   

  0164a	c7 85 78 ff ff
	ff ff ff 00 00	 mov	 DWORD PTR _lvi$[ebp+16], 65535 ; 0000ffffH

; 648  : 	GetItem(&lvi);

  01654	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _lvi$[ebp]
  0165a	51		 push	 ecx
  0165b	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01661	e8 00 00 00 00	 call	 ?GetItem@CListCtrl@@QBEHPAUtagLVITEMA@@@Z ; CListCtrl::GetItem

; 649  : 
; 650  : 	BOOL bHighlight =( (lvi.state & LVIS_DROPHILITED) || ( (lvi.state & LVIS_SELECTED)&& ((GetFocus() == this)|| (GetStyle() & LVS_SHOWSELALWAYS)	)	)		);

  01666	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _lvi$[ebp+12]
  0166c	83 e2 08	 and	 edx, 8
  0166f	75 34		 jne	 SHORT $L202321
  01671	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _lvi$[ebp+12]
  01677	83 e0 02	 and	 eax, 2
  0167a	74 1d		 je	 SHORT $L202322
  0167c	e8 00 00 00 00	 call	 ?GetFocus@CWnd@@SGPAV1@XZ ; CWnd::GetFocus
  01681	3b 85 08 ff ff
	ff		 cmp	 eax, DWORD PTR _this$[ebp]
  01687	74 1c		 je	 SHORT $L202321
  01689	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0168f	e8 00 00 00 00	 call	 ?GetStyle@CWnd@@QBEKXZ	; CWnd::GetStyle
  01694	83 e0 08	 and	 eax, 8
  01697	75 0c		 jne	 SHORT $L202321
$L202322:
  01699	c7 85 04 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
  016a3	eb 0a		 jmp	 SHORT $L202324
$L202321:
  016a5	c7 85 04 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv78[ebp], 1
$L202324:
  016af	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  016b5	89 4d f0	 mov	 DWORD PTR _bHighlight$[ebp], ecx

; 651  : 
; 652  : 	if( !bHighlight )

  016b8	83 7d f0 00	 cmp	 DWORD PTR _bHighlight$[ebp], 0
  016bc	75 07		 jne	 SHORT $L200326

; 653  : 	{
; 654  : 		return FALSE;

  016be	33 c0		 xor	 eax, eax
  016c0	e9 57 02 00 00	 jmp	 $L200323
$L200326:

; 655  : 	}
; 656  : 
; 657  : 	if( m_iCurrentCursorItem == -1 || m_iCurrentCursorSubItem == -1 )

  016c5	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  016cb	83 ba 80 00 00
	00 ff		 cmp	 DWORD PTR [edx+128], -1
  016d2	74 0f		 je	 SHORT $L200328
  016d4	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  016da	83 b8 84 00 00
	00 ff		 cmp	 DWORD PTR [eax+132], -1
  016e1	75 07		 jne	 SHORT $L200327
$L200328:

; 658  : 	{
; 659  : 		return FALSE;

  016e3	33 c0		 xor	 eax, eax
  016e5	e9 32 02 00 00	 jmp	 $L200323
$L200327:

; 660  : 	}	
; 661  : 
; 662  : 	MYLIST_COLUMN_INFO columnInfo;

  016ea	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  016ed	e8 00 00 00 00	 call	 ??0MYLIST_COLUMN_INFO@@QAE@XZ ; MYLIST_COLUMN_INFO::MYLIST_COLUMN_INFO
  016f2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 663  : 	columnInfo			= m_mapColumnInfo[m_iCurrentCursorSubItem];

  016f9	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  016ff	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  01705	51		 push	 ecx
  01706	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0170c	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  01712	e8 00 00 00 00	 call	 ??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[]
  01717	50		 push	 eax
  01718	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  0171b	e8 00 00 00 00	 call	 ??4MYLIST_COLUMN_INFO@@QAEAAU0@ABU0@@Z ; MYLIST_COLUMN_INFO::operator=

; 664  : 	if( !columnInfo.bOperatorBtn )

  01720	0f b6 55 c4	 movzx	 edx, BYTE PTR _columnInfo$[ebp+40]
  01724	85 d2		 test	 edx, edx
  01726	75 24		 jne	 SHORT $L200330

; 665  : 	{
; 666  : 		return FALSE;

  01728	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T202325[ebp], 0
  01732	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01739	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  0173c	e8 00 00 00 00	 call	 ??1MYLIST_COLUMN_INFO@@QAE@XZ
  01741	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR $T202325[ebp]
  01747	e9 d0 01 00 00	 jmp	 $L200323
$L200330:

; 667  : 	}
; 668  : 
; 669  : 	CPoint pointImage;

  0174c	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _pointImage$[ebp]
  01752	e8 00 00 00 00	 call	 ??0CPoint@@QAE@XZ	; CPoint::CPoint

; 670  : 	CRect  rectSubItem;

  01757	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _rectSubItem$[ebp]
  0175d	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 671  : 
; 672  : 	GetSubItemRect( m_iCurrentCursorItem,m_iCurrentCursorSubItem,LVIR_BOUNDS,rectSubItem);

  01762	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _rectSubItem$[ebp]
  01768	50		 push	 eax
  01769	6a 00		 push	 0
  0176b	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01771	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  01777	52		 push	 edx
  01778	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0177e	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01784	51		 push	 ecx
  01785	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0178b	e8 00 00 00 00	 call	 ?GetSubItemRect@CListCtrl@@QAEHHHHAAVCRect@@@Z ; CListCtrl::GetSubItemRect

; 673  : 	
; 674  : 	rectSubItem.right	= rectSubItem.left + GetColumnWidth(m_iCurrentCursorSubItem);

  01790	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01796	8b 82 84 00 00
	00		 mov	 eax, DWORD PTR [edx+132]
  0179c	50		 push	 eax
  0179d	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  017a3	e8 00 00 00 00	 call	 ?GetColumnWidth@CListCtrl@@QBEHH@Z ; CListCtrl::GetColumnWidth
  017a8	03 85 58 ff ff
	ff		 add	 eax, DWORD PTR _rectSubItem$[ebp]
  017ae	89 85 60 ff ff
	ff		 mov	 DWORD PTR _rectSubItem$[ebp+8], eax

; 675  : 	rectSubItem.left	= rectSubItem.right - 20;

  017b4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _rectSubItem$[ebp+8]
  017ba	83 e9 14	 sub	 ecx, 20			; 00000014H
  017bd	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _rectSubItem$[ebp], ecx

; 676  : 	pointImage			= rectSubItem.CenterPoint();

  017c3	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR $T202326[ebp]
  017c9	52		 push	 edx
  017ca	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _rectSubItem$[ebp]
  017d0	e8 00 00 00 00	 call	 ?CenterPoint@CRect@@QBE?AVCPoint@@XZ ; CRect::CenterPoint
  017d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  017d7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  017da	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _pointImage$[ebp], ecx
  017e0	89 95 54 ff ff
	ff		 mov	 DWORD PTR _pointImage$[ebp+4], edx

; 677  : 	pointImage.x		= pointImage.x - columnInfo.ColumnOperatorImage.pBitmapNormal->GetWidth() /2;

  017e6	8b 4d d8	 mov	 ecx, DWORD PTR _columnInfo$[ebp+60]
  017e9	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  017ee	99		 cdq
  017ef	2b c2		 sub	 eax, edx
  017f1	d1 f8		 sar	 eax, 1
  017f3	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _pointImage$[ebp]
  017f9	2b c8		 sub	 ecx, eax
  017fb	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _pointImage$[ebp], ecx

; 678  : 	pointImage.y		= pointImage.y - columnInfo.ColumnOperatorImage.pBitmapNormal->GetHeight() /2;

  01801	8b 4d d8	 mov	 ecx, DWORD PTR _columnInfo$[ebp+60]
  01804	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  01809	99		 cdq
  0180a	2b c2		 sub	 eax, edx
  0180c	d1 f8		 sar	 eax, 1
  0180e	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _pointImage$[ebp+4]
  01814	2b d0		 sub	 edx, eax
  01816	89 95 54 ff ff
	ff		 mov	 DWORD PTR _pointImage$[ebp+4], edx

; 679  : 
; 680  : 	if( PtInRect( CRect(pointImage,CSize(columnInfo.ColumnOperatorImage.pBitmapNormal->GetWidth(),columnInfo.ColumnOperatorImage.pBitmapNormal->GetHeight() ) ),pt))

  0181c	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  0181f	8b 08		 mov	 ecx, DWORD PTR [eax]
  01821	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01824	89 8d 3c ff ff
	ff		 mov	 DWORD PTR $T202327[ebp], ecx
  0182a	89 95 40 ff ff
	ff		 mov	 DWORD PTR $T202327[ebp+4], edx
  01830	8b 4d d8	 mov	 ecx, DWORD PTR _columnInfo$[ebp+60]
  01833	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  01838	50		 push	 eax
  01839	8b 4d d8	 mov	 ecx, DWORD PTR _columnInfo$[ebp+60]
  0183c	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  01841	50		 push	 eax
  01842	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T202330[ebp]
  01848	e8 00 00 00 00	 call	 ??0CSize@@QAE@HH@Z	; CSize::CSize
  0184d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0184f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01852	89 8d 24 ff ff
	ff		 mov	 DWORD PTR $T202329[ebp], ecx
  01858	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T202329[ebp+4], edx
  0185e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _pointImage$[ebp]
  01864	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T202331[ebp], eax
  0186a	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _pointImage$[ebp+4]
  01870	89 8d 18 ff ff
	ff		 mov	 DWORD PTR $T202331[ebp+4], ecx
  01876	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR $T202327[ebp+4]
  0187c	52		 push	 edx
  0187d	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR $T202327[ebp]
  01883	50		 push	 eax
  01884	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR $T202329[ebp+4]
  0188a	51		 push	 ecx
  0188b	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR $T202329[ebp]
  01891	52		 push	 edx
  01892	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR $T202331[ebp+4]
  01898	50		 push	 eax
  01899	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T202331[ebp]
  0189f	51		 push	 ecx
  018a0	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T202328[ebp]
  018a6	e8 00 00 00 00	 call	 ??0CRect@@QAE@UtagPOINT@@UtagSIZE@@@Z ; CRect::CRect
  018ab	8b c8		 mov	 ecx, eax
  018ad	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  018b2	50		 push	 eax
  018b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  018b9	85 c0		 test	 eax, eax
  018bb	74 40		 je	 SHORT $L200340

; 681  : 	{
; 682  : 		pt.x = pointImage.x;

  018bd	8b 55 08	 mov	 edx, DWORD PTR _pt$[ebp]
  018c0	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _pointImage$[ebp]
  018c6	89 02		 mov	 DWORD PTR [edx], eax

; 683  : 		pt.y = pointImage.y + columnInfo.ColumnOperatorImage.pBitmapNormal->GetHeight();

  018c8	8b 4d d8	 mov	 ecx, DWORD PTR _columnInfo$[ebp+60]
  018cb	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  018d0	03 85 54 ff ff
	ff		 add	 eax, DWORD PTR _pointImage$[ebp+4]
  018d6	8b 4d 08	 mov	 ecx, DWORD PTR _pt$[ebp]
  018d9	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 684  : 		return TRUE;

  018dc	c7 85 10 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T202332[ebp], 1
  018e6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  018ed	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  018f0	e8 00 00 00 00	 call	 ??1MYLIST_COLUMN_INFO@@QAE@XZ
  018f5	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR $T202332[ebp]
  018fb	eb 1f		 jmp	 SHORT $L200323
$L200340:

; 685  : 	}
; 686  : 	return FALSE;

  018fd	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T202333[ebp], 0
  01907	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0190e	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  01911	e8 00 00 00 00	 call	 ??1MYLIST_COLUMN_INFO@@QAE@XZ
  01916	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR $T202333[ebp]
$L200323:

; 687  : }

  0191c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0191f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01926	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01929	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0192e	8b e5		 mov	 esp, ebp
  01930	5d		 pop	 ebp
  01931	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L202334:
  0010f	8d 4d 9c	 lea	 ecx, DWORD PTR _columnInfo$[ebp]
  00112	e9 00 00 00 00	 jmp	 ??1MYLIST_COLUMN_INFO@@QAE@XZ
__ehhandler$?PointInOperatorBtn@CMyListCtrl@@IAEHAAVCPoint@@@Z:
  00117	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202336
  0011c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?PointInOperatorBtn@CMyListCtrl@@IAEHAAVCPoint@@@Z ENDP	; CMyListCtrl::PointInOperatorBtn
PUBLIC	?Width@CRect@@QBEHXZ				; CRect::Width
PUBLIC	?Height@CRect@@QBEHXZ				; CRect::Height
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T202341 = -24						; size = 16
_pt$ = -8						; size = 8
_pDibBitmap$ = 8					; size = 4
_r$ = 12						; size = 4
_memDC$ = 16						; size = 4
?DrawImage@CMyListCtrl@@IAEXPAVCDibBitmap@@ABVCRect@@PAVCDC@@@Z PROC NEAR ; CMyListCtrl::DrawImage
; _this$ = ecx

; 690  : {		

  01940	55		 push	 ebp
  01941	8b ec		 mov	 ebp, esp
  01943	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01946	56		 push	 esi
  01947	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 691  : 	if( !pDibBitmap )

  0194a	83 7d 08 00	 cmp	 DWORD PTR _pDibBitmap$[ebp], 0
  0194e	75 05		 jne	 SHORT $L200349

; 692  : 	{
; 693  : 		return;

  01950	e9 bf 00 00 00	 jmp	 $L200348
$L200349:

; 694  : 	}
; 695  : 	CPoint pt = r.CenterPoint();

  01955	8d 45 f8	 lea	 eax, DWORD PTR _pt$[ebp]
  01958	50		 push	 eax
  01959	8b 4d 0c	 mov	 ecx, DWORD PTR _r$[ebp]
  0195c	e8 00 00 00 00	 call	 ?CenterPoint@CRect@@QBE?AVCPoint@@XZ ; CRect::CenterPoint

; 696  : 	pt.x = pt.x - pDibBitmap->GetWidth() /2;

  01961	8b 4d 08	 mov	 ecx, DWORD PTR _pDibBitmap$[ebp]
  01964	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  01969	99		 cdq
  0196a	2b c2		 sub	 eax, edx
  0196c	d1 f8		 sar	 eax, 1
  0196e	8b 4d f8	 mov	 ecx, DWORD PTR _pt$[ebp]
  01971	2b c8		 sub	 ecx, eax
  01973	89 4d f8	 mov	 DWORD PTR _pt$[ebp], ecx

; 697  : 	pt.y = pt.y - pDibBitmap->GetHeight() /2;

  01976	8b 4d 08	 mov	 ecx, DWORD PTR _pDibBitmap$[ebp]
  01979	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  0197e	99		 cdq
  0197f	2b c2		 sub	 eax, edx
  01981	d1 f8		 sar	 eax, 1
  01983	8b 55 fc	 mov	 edx, DWORD PTR _pt$[ebp+4]
  01986	2b d0		 sub	 edx, eax
  01988	89 55 fc	 mov	 DWORD PTR _pt$[ebp+4], edx

; 698  : 	//
; 699  : 	if( r.Width() >= pDibBitmap->GetWidth()
; 700  : 		&& r.Height() >= pDibBitmap->GetHeight() )

  0198b	8b 4d 0c	 mov	 ecx, DWORD PTR _r$[ebp]
  0198e	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  01993	8b f0		 mov	 esi, eax
  01995	8b 4d 08	 mov	 ecx, DWORD PTR _pDibBitmap$[ebp]
  01998	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  0199d	3b f0		 cmp	 esi, eax
  0199f	7c 73		 jl	 SHORT $L200348
  019a1	8b 4d 0c	 mov	 ecx, DWORD PTR _r$[ebp]
  019a4	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  019a9	8b f0		 mov	 esi, eax
  019ab	8b 4d 08	 mov	 ecx, DWORD PTR _pDibBitmap$[ebp]
  019ae	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  019b3	3b f0		 cmp	 esi, eax
  019b5	7c 5d		 jl	 SHORT $L200348

; 701  : 	{
; 702  : 		pDibBitmap->SetCDibRect(CRect(pt.x, pt.y, pt.x + pDibBitmap->GetWidth() , pt.y + pDibBitmap->GetHeight()));

  019b7	8b 4d 08	 mov	 ecx, DWORD PTR _pDibBitmap$[ebp]
  019ba	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  019bf	03 45 fc	 add	 eax, DWORD PTR _pt$[ebp+4]
  019c2	50		 push	 eax
  019c3	8b 4d 08	 mov	 ecx, DWORD PTR _pDibBitmap$[ebp]
  019c6	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  019cb	03 45 f8	 add	 eax, DWORD PTR _pt$[ebp]
  019ce	50		 push	 eax
  019cf	8b 45 fc	 mov	 eax, DWORD PTR _pt$[ebp+4]
  019d2	50		 push	 eax
  019d3	8b 4d f8	 mov	 ecx, DWORD PTR _pt$[ebp]
  019d6	51		 push	 ecx
  019d7	8d 4d e8	 lea	 ecx, DWORD PTR $T202341[ebp]
  019da	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  019df	83 ec 10	 sub	 esp, 16			; 00000010H
  019e2	8b d4		 mov	 edx, esp
  019e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  019e6	89 0a		 mov	 DWORD PTR [edx], ecx
  019e8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  019eb	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  019ee	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  019f1	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  019f4	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  019f7	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  019fa	8b 4d 08	 mov	 ecx, DWORD PTR _pDibBitmap$[ebp]
  019fd	e8 00 00 00 00	 call	 ?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ; CDibBitmap::SetCDibRect

; 703  : 		pDibBitmap->Draw(memDC, true);	

  01a02	6a 01		 push	 1
  01a04	6a 00		 push	 0
  01a06	6a 01		 push	 1
  01a08	8b 4d 10	 mov	 ecx, DWORD PTR _memDC$[ebp]
  01a0b	51		 push	 ecx
  01a0c	8b 4d 08	 mov	 ecx, DWORD PTR _pDibBitmap$[ebp]
  01a0f	e8 00 00 00 00	 call	 ?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ; CDibBitmap::Draw
$L200348:

; 704  : 	}
; 705  : }

  01a14	5e		 pop	 esi
  01a15	8b e5		 mov	 esp, ebp
  01a17	5d		 pop	 ebp
  01a18	c2 0c 00	 ret	 12			; 0000000cH
?DrawImage@CMyListCtrl@@IAEXPAVCDibBitmap@@ABVCRect@@PAVCDC@@@Z ENDP ; CMyListCtrl::DrawImage
_TEXT	ENDS
EXTRN	?HandleCustomDraw@@YAJIPAUNMCSBCUSTOMDRAW@@PAVCDibBitmap@@1@Z:NEAR ; HandleCustomDraw
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pNMCD$ = -4						; size = 4
_pNMHDR$ = 8						; size = 4
_pResult$ = 12						; size = 4
?OnCoolSBCustomdraw@CMyListCtrl@@IAEXPAUtagNMHDR@@PAJ@Z PROC NEAR ; CMyListCtrl::OnCoolSBCustomdraw
; _this$ = ecx

; 708  : {

  01a20	55		 push	 ebp
  01a21	8b ec		 mov	 ebp, esp
  01a23	83 ec 08	 sub	 esp, 8
  01a26	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 709  : 	NMCSBCUSTOMDRAW* pNMCD = reinterpret_cast<NMCSBCUSTOMDRAW*>(pNMHDR);	

  01a29	8b 45 08	 mov	 eax, DWORD PTR _pNMHDR$[ebp]
  01a2c	89 45 fc	 mov	 DWORD PTR _pNMCD$[ebp], eax

; 710  : 	if( m_pBitmapScrollHorz != NULL && m_pBitmapScrollVert != NULL )

  01a2f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01a32	83 79 70 00	 cmp	 DWORD PTR [ecx+112], 0
  01a36	74 2a		 je	 SHORT $L200358
  01a38	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01a3b	83 7a 6c 00	 cmp	 DWORD PTR [edx+108], 0
  01a3f	74 21		 je	 SHORT $L200358

; 711  : 	{
; 712  : 		*pResult = HandleCustomDraw(0, (NMCSBCUSTOMDRAW*)pNMHDR, m_pBitmapScrollVert,m_pBitmapScrollHorz );

  01a41	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01a44	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  01a47	51		 push	 ecx
  01a48	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01a4b	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  01a4e	50		 push	 eax
  01a4f	8b 4d 08	 mov	 ecx, DWORD PTR _pNMHDR$[ebp]
  01a52	51		 push	 ecx
  01a53	6a 00		 push	 0
  01a55	e8 00 00 00 00	 call	 ?HandleCustomDraw@@YAJIPAUNMCSBCUSTOMDRAW@@PAVCDibBitmap@@1@Z ; HandleCustomDraw
  01a5a	83 c4 10	 add	 esp, 16			; 00000010H
  01a5d	8b 55 0c	 mov	 edx, DWORD PTR _pResult$[ebp]
  01a60	89 02		 mov	 DWORD PTR [edx], eax
$L200358:

; 713  : 	}
; 714  : }

  01a62	8b e5		 mov	 esp, ebp
  01a64	5d		 pop	 ebp
  01a65	c2 08 00	 ret	 8
?OnCoolSBCustomdraw@CMyListCtrl@@IAEXPAUtagNMHDR@@PAJ@Z ENDP ; CMyListCtrl::OnCoolSBCustomdraw
_TEXT	ENDS
PUBLIC	?Invalidate@CWnd@@QAEXH@Z			; CWnd::Invalidate
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
PUBLIC	?SearchHighLight@CMyListCtrl@@QAEXAAV?$vector@HV?$allocator@H@std@@@std@@AAK@Z ; CMyListCtrl::SearchHighLight
PUBLIC	??$back_inserter@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::back_inserter<std::vector<int,std::allocator<int> > >
PUBLIC	??$copy@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@@Z ; std::copy<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T202347 = -16						; size = 4
$T202346 = -12						; size = 4
$T202345 = -8						; size = 4
$T202344 = -4						; size = 4
_vecItems$ = 8						; size = 4
_colorHighLight$ = 12					; size = 4
?SearchHighLight@CMyListCtrl@@QAEXAAV?$vector@HV?$allocator@H@std@@@std@@AAK@Z PROC NEAR ; CMyListCtrl::SearchHighLight
; _this$ = ecx

; 717  : {

  01a70	55		 push	 ebp
  01a71	8b ec		 mov	 ebp, esp
  01a73	83 ec 14	 sub	 esp, 20			; 00000014H
  01a76	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 718  : 	m_colorSearchHightLight=colorHighLight;

  01a79	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01a7c	8b 4d 0c	 mov	 ecx, DWORD PTR _colorHighLight$[ebp]
  01a7f	8b 11		 mov	 edx, DWORD PTR [ecx]
  01a81	89 90 4c 01 00
	00		 mov	 DWORD PTR [eax+332], edx

; 719  : 	m_vecSearchedItems.clear();

  01a87	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01a8a	81 c1 3c 01 00
	00		 add	 ecx, 316		; 0000013cH
  01a90	e8 00 00 00 00	 call	 ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear

; 720  : 	copy(vecItems.begin(),vecItems.end(),back_inserter(m_vecSearchedItems));

  01a95	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01a98	05 3c 01 00 00	 add	 eax, 316		; 0000013cH
  01a9d	50		 push	 eax
  01a9e	8d 4d fc	 lea	 ecx, DWORD PTR $T202344[ebp]
  01aa1	51		 push	 ecx
  01aa2	e8 00 00 00 00	 call	 ??$back_inserter@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::back_inserter<std::vector<int,std::allocator<int> > >
  01aa7	83 c4 08	 add	 esp, 8
  01aaa	8b 10		 mov	 edx, DWORD PTR [eax]
  01aac	52		 push	 edx
  01aad	8d 45 f8	 lea	 eax, DWORD PTR $T202345[ebp]
  01ab0	50		 push	 eax
  01ab1	8b 4d 08	 mov	 ecx, DWORD PTR _vecItems$[ebp]
  01ab4	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  01ab9	8b 08		 mov	 ecx, DWORD PTR [eax]
  01abb	51		 push	 ecx
  01abc	8d 55 f4	 lea	 edx, DWORD PTR $T202346[ebp]
  01abf	52		 push	 edx
  01ac0	8b 4d 08	 mov	 ecx, DWORD PTR _vecItems$[ebp]
  01ac3	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
  01ac8	8b 00		 mov	 eax, DWORD PTR [eax]
  01aca	50		 push	 eax
  01acb	8d 4d f0	 lea	 ecx, DWORD PTR $T202347[ebp]
  01ace	51		 push	 ecx
  01acf	e8 00 00 00 00	 call	 ??$copy@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@@Z ; std::copy<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >
  01ad4	83 c4 10	 add	 esp, 16			; 00000010H

; 721  : 	Invalidate(FALSE);

  01ad7	6a 00		 push	 0
  01ad9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01adc	e8 00 00 00 00	 call	 ?Invalidate@CWnd@@QAEXH@Z ; CWnd::Invalidate

; 722  : }

  01ae1	8b e5		 mov	 esp, ebp
  01ae3	5d		 pop	 ebp
  01ae4	c2 08 00	 ret	 8
?SearchHighLight@CMyListCtrl@@QAEXAAV?$vector@HV?$allocator@H@std@@@std@@AAK@Z ENDP ; CMyListCtrl::SearchHighLight
_TEXT	ENDS
EXTRN	?SetItemState@CListCtrl@@QAEHHII@Z:NEAR		; CListCtrl::SetItemState
EXTRN	?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z:NEAR ; CWnd::PreTranslateMessage
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$200412 = -4						; size = 4
_pMsg$ = 8						; size = 4
?PreTranslateMessage@CMyListCtrl@@UAEHPAUtagMSG@@@Z PROC NEAR ; CMyListCtrl::PreTranslateMessage
; _this$ = ecx

; 727  : {

  01af0	55		 push	 ebp
  01af1	8b ec		 mov	 ebp, esp
  01af3	83 ec 08	 sub	 esp, 8
  01af6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 728  : 	if( pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_CONTROL )

  01af9	8b 45 08	 mov	 eax, DWORD PTR _pMsg$[ebp]
  01afc	81 78 04 00 01
	00 00		 cmp	 DWORD PTR [eax+4], 256	; 00000100H
  01b03	75 13		 jne	 SHORT $L200408
  01b05	8b 4d 08	 mov	 ecx, DWORD PTR _pMsg$[ebp]
  01b08	83 79 08 11	 cmp	 DWORD PTR [ecx+8], 17	; 00000011H
  01b0c	75 0a		 jne	 SHORT $L200408

; 729  : 	{
; 730  : 		mkey1 = VK_CONTROL;

  01b0e	c7 05 00 00 00
	00 11 00 00 00	 mov	 DWORD PTR _mkey1, 17	; 00000011H
$L200408:

; 731  : 	}
; 732  : 	if( pMsg->message == WM_KEYDOWN && pMsg->wParam == 'A' )

  01b18	8b 55 08	 mov	 edx, DWORD PTR _pMsg$[ebp]
  01b1b	81 7a 04 00 01
	00 00		 cmp	 DWORD PTR [edx+4], 256	; 00000100H
  01b22	75 60		 jne	 SHORT $L200409
  01b24	8b 45 08	 mov	 eax, DWORD PTR _pMsg$[ebp]
  01b27	83 78 08 41	 cmp	 DWORD PTR [eax+8], 65	; 00000041H
  01b2b	75 57		 jne	 SHORT $L200409

; 733  : 	{
; 734  : 		if( mkey1 != 0 )

  01b2d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _mkey1, 0
  01b34	74 4e		 je	 SHORT $L200409

; 735  : 		{
; 736  : 			if( mkey2 == 0 )

  01b36	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _mkey2, 0
  01b3d	75 45		 jne	 SHORT $L200409

; 737  : 			{
; 738  : 				mkey2 = 'A';

  01b3f	c7 05 00 00 00
	00 41 00 00 00	 mov	 DWORD PTR _mkey2, 65	; 00000041H

; 739  : 				for (int i=0;i<GetItemCount();++i)

  01b49	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$200412[ebp], 0
  01b50	eb 09		 jmp	 SHORT $L200413
$L200414:
  01b52	8b 4d fc	 mov	 ecx, DWORD PTR _i$200412[ebp]
  01b55	83 c1 01	 add	 ecx, 1
  01b58	89 4d fc	 mov	 DWORD PTR _i$200412[ebp], ecx
$L200413:
  01b5b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01b5e	e8 00 00 00 00	 call	 ?GetItemCount@CListCtrl@@QBEHXZ ; CListCtrl::GetItemCount
  01b63	39 45 fc	 cmp	 DWORD PTR _i$200412[ebp], eax
  01b66	7d 12		 jge	 SHORT $L200415

; 740  : 				{
; 741  : 					SetItemState( i,LVIS_SELECTED,LVIS_SELECTED);		

  01b68	6a 02		 push	 2
  01b6a	6a 02		 push	 2
  01b6c	8b 55 fc	 mov	 edx, DWORD PTR _i$200412[ebp]
  01b6f	52		 push	 edx
  01b70	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01b73	e8 00 00 00 00	 call	 ?SetItemState@CListCtrl@@QAEHHII@Z ; CListCtrl::SetItemState

; 742  : 				}

  01b78	eb d8		 jmp	 SHORT $L200414
$L200415:

; 743  : 				return TRUE;

  01b7a	b8 01 00 00 00	 mov	 eax, 1
  01b7f	e9 82 00 00 00	 jmp	 $L200407
$L200409:

; 744  : 			}
; 745  : 		}
; 746  : 	}
; 747  : 	if( pMsg->message == WM_KEYUP )

  01b84	8b 45 08	 mov	 eax, DWORD PTR _pMsg$[ebp]
  01b87	81 78 04 01 01
	00 00		 cmp	 DWORD PTR [eax+4], 257	; 00000101H
  01b8e	75 1d		 jne	 SHORT $L200416

; 748  : 	{
; 749  : 		mkey2 = 0;

  01b90	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _mkey2, 0

; 750  : 		if(pMsg->wParam == VK_CONTROL)

  01b9a	8b 4d 08	 mov	 ecx, DWORD PTR _pMsg$[ebp]
  01b9d	83 79 08 11	 cmp	 DWORD PTR [ecx+8], 17	; 00000011H
  01ba1	75 0a		 jne	 SHORT $L200416

; 751  : 			mkey1 = 0;

  01ba3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _mkey1, 0
$L200416:

; 752  : 	}
; 753  : 	if( pMsg->hwnd == m_hWnd && mkey1 == 0
; 754  : 		&& pMsg->message == WM_KEYDOWN 
; 755  : 		&& (((pMsg->wParam > 0X40)&&(pMsg->wParam < 0X5B))||((pMsg->wParam > 0X60)&&(pMsg->wParam < 0X7B))) )

  01bad	8b 55 08	 mov	 edx, DWORD PTR _pMsg$[ebp]
  01bb0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01bb3	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01bb5	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  01bb8	75 40		 jne	 SHORT $L200418
  01bba	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _mkey1, 0
  01bc1	75 37		 jne	 SHORT $L200418
  01bc3	8b 55 08	 mov	 edx, DWORD PTR _pMsg$[ebp]
  01bc6	81 7a 04 00 01
	00 00		 cmp	 DWORD PTR [edx+4], 256	; 00000100H
  01bcd	75 2b		 jne	 SHORT $L200418
  01bcf	8b 45 08	 mov	 eax, DWORD PTR _pMsg$[ebp]
  01bd2	83 78 08 40	 cmp	 DWORD PTR [eax+8], 64	; 00000040H
  01bd6	76 09		 jbe	 SHORT $L200420
  01bd8	8b 4d 08	 mov	 ecx, DWORD PTR _pMsg$[ebp]
  01bdb	83 79 08 5b	 cmp	 DWORD PTR [ecx+8], 91	; 0000005bH
  01bdf	72 12		 jb	 SHORT $L200419
$L200420:
  01be1	8b 55 08	 mov	 edx, DWORD PTR _pMsg$[ebp]
  01be4	83 7a 08 60	 cmp	 DWORD PTR [edx+8], 96	; 00000060H
  01be8	76 10		 jbe	 SHORT $L200418
  01bea	8b 45 08	 mov	 eax, DWORD PTR _pMsg$[ebp]
  01bed	83 78 08 7b	 cmp	 DWORD PTR [eax+8], 123	; 0000007bH
  01bf1	73 07		 jae	 SHORT $L200418
$L200419:

; 756  : 	{
; 757  : 		//Ctrol_a_z_KeyDown( short(pMsg->wParam) );
; 758  : 		return TRUE;

  01bf3	b8 01 00 00 00	 mov	 eax, 1
  01bf8	eb 0c		 jmp	 SHORT $L200407
$L200418:

; 759  : 	}
; 760  : 
; 761  : 	return __super::PreTranslateMessage(pMsg);

  01bfa	8b 4d 08	 mov	 ecx, DWORD PTR _pMsg$[ebp]
  01bfd	51		 push	 ecx
  01bfe	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01c01	e8 00 00 00 00	 call	 ?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z ; CWnd::PreTranslateMessage
$L200407:

; 762  : }

  01c06	8b e5		 mov	 esp, ebp
  01c08	5d		 pop	 ebp
  01c09	c2 04 00	 ret	 4
?PreTranslateMessage@CMyListCtrl@@UAEHPAUtagMSG@@@Z ENDP ; CMyListCtrl::PreTranslateMessage
; Function compile flags: /Odt
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?SetKeySubItem@CMyListCtrl@@UAEXH@Z PROC NEAR		; CMyListCtrl::SetKeySubItem
; _this$ = ecx

; 765  : {

  01c10	55		 push	 ebp
  01c11	8b ec		 mov	 ebp, esp
  01c13	51		 push	 ecx
  01c14	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 766  : 	m_nKeySubItem = nIndex;

  01c17	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01c1a	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  01c1d	89 88 58 01 00
	00		 mov	 DWORD PTR [eax+344], ecx

; 767  : }

  01c23	8b e5		 mov	 esp, ebp
  01c25	5d		 pop	 ebp
  01c26	c2 04 00	 ret	 4
?SetKeySubItem@CMyListCtrl@@UAEXH@Z ENDP		; CMyListCtrl::SetKeySubItem
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ??0?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T202352 = -2						; size = 1
$T202351 = -1						; size = 1
??0?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >, COMDAT
; _this$ = ecx

; 102  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8d 4d ff	 lea	 ecx, DWORD PTR $T202351[ebp]
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >
  00011	50		 push	 eax
  00012	8d 45 fe	 lea	 eax, DWORD PTR $T202352[ebp]
  00015	50		 push	 eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >

; 103  : 		}

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??0?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator*
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::insert
PUBLIC	??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABHABUMYLIST_COLUMN_INFO@@@Z ; std::pair<int const ,MYLIST_COLUMN_INFO>::pair<int const ,MYLIST_COLUMN_INFO>
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::lower_bound
PUBLIC	??1?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@XZ ; std::pair<int const ,MYLIST_COLUMN_INFO>::~pair<int const ,MYLIST_COLUMN_INFO>
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202365 DD	0ffffffffH
	DD	FLAT:$L202360
	DD	00H
	DD	FLAT:$L202361
$T202363 DD	019930520H
	DD	02H
	DD	FLAT:$T202365
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z
_TEXT	SEGMENT
tv139 = -200						; size = 4
tv141 = -196						; size = 4
tv137 = -192						; size = 4
tv140 = -188						; size = 4
_this$ = -184						; size = 4
$T202359 = -180						; size = 4
$T202358 = -176						; size = 76
$T202357 = -100						; size = 80
$T202356 = -20						; size = 4
__Where$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z PROC NEAR ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[], COMDAT
; _this$ = ecx

; 142  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  0001e	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 143  : 		iterator _Where = this->lower_bound(_Keyval);

  00024	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00027	50		 push	 eax
  00028	8d 4d f0	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?lower_bound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::lower_bound

; 144  : 		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00037	8d 55 ec	 lea	 edx, DWORD PTR $T202356[ebp]
  0003a	52		 push	 edx
  0003b	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::end
  00046	50		 push	 eax
  00047	8d 4d f0	 lea	 ecx, DWORD PTR __Where$[ebp]
  0004a	e8 00 00 00 00	 call	 ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
  0004f	0f b6 c0	 movzx	 eax, al
  00052	85 c0		 test	 eax, eax
  00054	75 2c		 jne	 SHORT $L200486
  00056	8d 4d f0	 lea	 ecx, DWORD PTR __Where$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  00064	83 c4 04	 add	 esp, 4
  00067	50		 push	 eax
  00068	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00077	0f b6 d0	 movzx	 edx, al
  0007a	85 d2		 test	 edx, edx
  0007c	0f 84 8d 00 00
	00		 je	 $L200485
$L200486:

; 145  : 			_Where = this->insert(_Where,
; 146  : 				value_type(_Keyval, mapped_type()));

  00082	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T202358[ebp]
  00088	e8 00 00 00 00	 call	 ??0MYLIST_COLUMN_INFO@@QAE@XZ ; MYLIST_COLUMN_INFO::MYLIST_COLUMN_INFO
  0008d	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv140[ebp], eax
  00093	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv140[ebp]
  00099	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv137[ebp], eax
  0009f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000a6	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv137[ebp]
  000ac	51		 push	 ecx
  000ad	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  000b0	52		 push	 edx
  000b1	8d 4d 9c	 lea	 ecx, DWORD PTR $T202357[ebp]
  000b4	e8 00 00 00 00	 call	 ??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABHABUMYLIST_COLUMN_INFO@@@Z ; std::pair<int const ,MYLIST_COLUMN_INFO>::pair<int const ,MYLIST_COLUMN_INFO>
  000b9	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv141[ebp], eax
  000bf	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv141[ebp]
  000c5	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv139[ebp], eax
  000cb	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000cf	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv139[ebp]
  000d5	51		 push	 ecx
  000d6	8b 55 f0	 mov	 edx, DWORD PTR __Where$[ebp]
  000d9	52		 push	 edx
  000da	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR $T202359[ebp]
  000e0	50		 push	 eax
  000e1	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::insert
  000ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ee	89 4d f0	 mov	 DWORD PTR __Where$[ebp], ecx
  000f1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000f5	8d 4d 9c	 lea	 ecx, DWORD PTR $T202357[ebp]
  000f8	e8 00 00 00 00	 call	 ??1?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@XZ
  000fd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00104	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T202358[ebp]
  0010a	e8 00 00 00 00	 call	 ??1MYLIST_COLUMN_INFO@@QAE@XZ
$L200485:

; 147  : 		return ((*_Where).second);

  0010f	8d 4d f0	 lea	 ecx, DWORD PTR __Where$[ebp]
  00112	e8 00 00 00 00	 call	 ??Diterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator*
  00117	83 c0 04	 add	 eax, 4

; 148  : 		}

  0011a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202360:
  00000	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T202358[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1MYLIST_COLUMN_INFO@@QAE@XZ
$L202361:
  0000b	8d 4d 9c	 lea	 ecx, DWORD PTR $T202357[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@XZ
__ehhandler$??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z:
  00013	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202363
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??A?$map@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@@std@@QAEAAUMYLIST_COLUMN_INFO@@ABH@Z ENDP ; std::map<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> > >::operator[]
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tidy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::~_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >, COMDAT
; _this$ = ecx

; 391  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 392  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tidy

; 393  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::~_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lmost
; Function compile flags: /Odt
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::begin, COMDAT
; _this$ = ecx

; 407  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lmost
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00015	e8 00 00 00 00	 call	 ??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 409  : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::end, COMDAT
; _this$ = ecx

; 417  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 419  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::end
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::size, COMDAT
; _this$ = ecx

; 447  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 448  : 		return (_Mysize);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 449  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::size
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Erase
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
; Function compile flags: /Odt
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::clear, COMDAT
; _this$ = ecx

; 780  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 781  : 		_Erase(_Root());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00028	89 10		 mov	 DWORD PTR [eax], edx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lmost
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	89 10		 mov	 DWORD PTR [eax], edx
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00052	89 10		 mov	 DWORD PTR [eax], edx

; 784  : 		}

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::clear
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 745  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L202391
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L202392
$L202391:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L202392:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?size@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ ENDP ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::size
_TEXT	ENDS
PUBLIC	?begin@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::begin
PUBLIC	??Dconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@XZ ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator*
PUBLIC	??Hconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AV012@H@Z ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator+
; Function compile flags: /Odt
;	COMDAT ??A?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@I@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T202396 = -8						; size = 4
$T202395 = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@I@Z PROC NEAR ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::operator[], COMDAT
; _this$ = ecx

; 549  : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 550  : 		return (*(begin() + _Pos));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d f8	 lea	 ecx, DWORD PTR $T202396[ebp]
  00010	51		 push	 ecx
  00011	8d 55 fc	 lea	 edx, DWORD PTR $T202395[ebp]
  00014	52		 push	 edx
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?begin@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::begin
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ??Hconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AV012@H@Z ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator+
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@XZ ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator*

; 551  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??A?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@I@Z ENDP ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::operator[]
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Citerator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 321  : 			{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 			return (&**this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Diterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator*

; 323  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 332  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 333  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 334  : 			++*this;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++

; 335  : 			return (_Tmp);

  00019	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 336  : 			}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 245  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 246  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 247  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator==
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 159  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 161  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator!=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@XZ PROC NEAR ; std::pair<int const ,MYLIST_COLUMN_INFO>::~pair<int const ,MYLIST_COLUMN_INFO>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ??1MYLIST_COLUMN_INFO@@QAE@XZ
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@XZ ENDP	; std::pair<int const ,MYLIST_COLUMN_INFO>::~pair<int const ,MYLIST_COLUMN_INFO>
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Myval
PUBLIC	?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key, COMDAT

; 141  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?_Myval@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Myval
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  00015	83 c4 04	 add	 esp, 4

; 143  : 		}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_val<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Init
PUBLIC	??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >
; Function compile flags: /Odt
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >, COMDAT
; _this$ = ecx

; 361  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00018	51		 push	 ecx
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_Tree_val@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_val<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >

; 362  : 		_Init();

  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Init

; 363  : 		}

  00029	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::insert
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator--
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
; Function compile flags: /Odt
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T202421 = -36						; size = 8
$T202420 = -28						; size = 4
$T202419 = -24						; size = 4
$T202418 = -20						; size = 4
$T202417 = -16						; size = 4
$T202416 = -12						; size = 4
$T202415 = -8						; size = 4
__Next$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::insert, COMDAT
; _this$ = ecx

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 510  : 		iterator _Next;

  00009	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator

; 511  : 
; 512  : 		if (size() == 0)

  00011	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::size
  00019	85 c0		 test	 eax, eax
  0001b	75 21		 jne	 SHORT $L200642

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

  0001d	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00020	50		 push	 eax
  00021	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00027	52		 push	 edx
  00028	6a 01		 push	 1
  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  00036	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00039	e9 81 05 00 00	 jmp	 $L200640
$L200642:

; 514  : 		else if (this->_Multi)

  0003e	33 c9		 xor	 ecx, ecx
  00040	0f 84 b5 02 00
	00		 je	 $L200645

; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())

  00046	8d 55 f8	 lea	 edx, DWORD PTR $T202415[ebp]
  00049	52		 push	 edx
  0004a	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::begin
  00052	50		 push	 eax
  00053	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00056	e8 00 00 00 00	 call	 ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
  0005b	0f b6 c0	 movzx	 eax, al
  0005e	85 c0		 test	 eax, eax
  00060	74 56		 je	 SHORT $L200647

; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  00062	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  0006b	83 c4 04	 add	 esp, 4
  0006e	50		 push	 eax
  0006f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  0007d	83 c4 04	 add	 esp, 4
  00080	50		 push	 eax
  00081	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00089	0f b6 d0	 movzx	 edx, al
  0008c	85 d2		 test	 edx, edx
  0008e	75 23		 jne	 SHORT $L200648

; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00090	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00093	50		 push	 eax
  00094	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00097	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  0009c	50		 push	 eax
  0009d	6a 01		 push	 1
  0009f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a2	51		 push	 ecx
  000a3	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  000ab	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ae	e9 0c 05 00 00	 jmp	 $L200640
$L200648:

; 520  : 				}
; 521  : 			else if (_Where == end())

  000b3	e9 3e 02 00 00	 jmp	 $L200650
$L200647:
  000b8	8d 55 f4	 lea	 edx, DWORD PTR $T202416[ebp]
  000bb	52		 push	 edx
  000bc	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::end
  000c4	50		 push	 eax
  000c5	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000c8	e8 00 00 00 00	 call	 ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
  000cd	0f b6 c0	 movzx	 eax, al
  000d0	85 c0		 test	 eax, eax
  000d2	74 5a		 je	 SHORT $L200652

; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))

  000d4	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
  000dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000de	51		 push	 ecx
  000df	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  000e4	83 c4 04	 add	 esp, 4
  000e7	50		 push	 eax
  000e8	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  000f1	83 c4 04	 add	 esp, 4
  000f4	50		 push	 eax
  000f5	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  000fd	0f b6 c0	 movzx	 eax, al
  00100	85 c0		 test	 eax, eax
  00102	75 25		 jne	 SHORT $L200653

; 524  : 					return (_Insert(false, _Rmost(), _Val));

  00104	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00107	51		 push	 ecx
  00108	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
  00110	8b 10		 mov	 edx, DWORD PTR [eax]
  00112	52		 push	 edx
  00113	6a 00		 push	 0
  00115	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00118	50		 push	 eax
  00119	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  00121	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00124	e9 96 04 00 00	 jmp	 $L200640
$L200653:

; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))

  00129	e9 c8 01 00 00	 jmp	 $L200650
$L200652:

; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))

  0012e	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00131	51		 push	 ecx
  00132	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  00137	83 c4 04	 add	 esp, 4
  0013a	50		 push	 eax
  0013b	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0013e	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  00149	83 c4 04	 add	 esp, 4
  0014c	50		 push	 eax
  0014d	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00150	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00155	0f b6 d0	 movzx	 edx, al
  00158	85 d2		 test	 edx, edx
  0015a	0f 85 a4 00 00
	00		 jne	 $L200656
  00160	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00163	89 45 fc	 mov	 DWORD PTR __Next$[ebp], eax
  00166	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  00169	e8 00 00 00 00	 call	 ??Fiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator--
  0016e	8b c8		 mov	 ecx, eax
  00170	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  0017b	83 c4 04	 add	 esp, 4
  0017e	50		 push	 eax
  0017f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  00188	83 c4 04	 add	 esp, 4
  0018b	50		 push	 eax
  0018c	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00194	0f b6 d0	 movzx	 edx, al
  00197	85 d2		 test	 edx, edx
  00199	75 69		 jne	 SHORT $L200656

; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))

  0019b	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  0019e	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  001a9	83 c4 04	 add	 esp, 4
  001ac	8b 00		 mov	 eax, DWORD PTR [eax]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  001b4	83 c4 04	 add	 esp, 4
  001b7	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001ba	85 c9		 test	 ecx, ecx
  001bc	74 23		 je	 SHORT $L200657

; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));

  001be	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  001c1	52		 push	 edx
  001c2	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  001c5	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  001ca	50		 push	 eax
  001cb	6a 00		 push	 0
  001cd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001d0	50		 push	 eax
  001d1	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d4	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  001d9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001dc	e9 de 03 00 00	 jmp	 $L200640
$L200657:

; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));

  001e1	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  001e4	51		 push	 ecx
  001e5	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  001e8	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  001ed	50		 push	 eax
  001ee	6a 01		 push	 1
  001f0	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  001f3	52		 push	 edx
  001f4	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f7	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  001fc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ff	e9 bb 03 00 00	 jmp	 $L200640
$L200656:

; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))

  00204	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00207	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  0020c	50		 push	 eax
  0020d	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  00212	83 c4 04	 add	 esp, 4
  00215	50		 push	 eax
  00216	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  0021f	83 c4 04	 add	 esp, 4
  00222	50		 push	 eax
  00223	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00226	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0022b	0f b6 c8	 movzx	 ecx, al
  0022e	85 c9		 test	 ecx, ecx
  00230	0f 85 c0 00 00
	00		 jne	 $L200650
  00236	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]
  00239	89 55 fc	 mov	 DWORD PTR __Next$[ebp], edx
  0023c	8d 45 f0	 lea	 eax, DWORD PTR $T202417[ebp]
  0023f	50		 push	 eax
  00240	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00243	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::end
  00248	50		 push	 eax
  00249	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  0024c	e8 00 00 00 00	 call	 ??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++
  00251	8b c8		 mov	 ecx, eax
  00253	e8 00 00 00 00	 call	 ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
  00258	0f b6 c8	 movzx	 ecx, al
  0025b	85 c9		 test	 ecx, ecx
  0025d	75 2e		 jne	 SHORT $L200664
  0025f	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00262	52		 push	 edx
  00263	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  00268	83 c4 04	 add	 esp, 4
  0026b	50		 push	 eax
  0026c	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  0026f	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00274	50		 push	 eax
  00275	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  0027a	83 c4 04	 add	 esp, 4
  0027d	50		 push	 eax
  0027e	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00281	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00286	0f b6 c0	 movzx	 eax, al
  00289	85 c0		 test	 eax, eax
  0028b	75 69		 jne	 SHORT $L200650
$L200664:

; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))

  0028d	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00290	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00295	50		 push	 eax
  00296	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0029b	83 c4 04	 add	 esp, 4
  0029e	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a0	51		 push	 ecx
  002a1	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  002a6	83 c4 04	 add	 esp, 4
  002a9	0f be 10	 movsx	 edx, BYTE PTR [eax]
  002ac	85 d2		 test	 edx, edx
  002ae	74 23		 je	 SHORT $L200665

; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));

  002b0	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  002b3	50		 push	 eax
  002b4	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  002b7	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  002bc	50		 push	 eax
  002bd	6a 00		 push	 0
  002bf	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  002c2	51		 push	 ecx
  002c3	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c6	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  002cb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002ce	e9 ec 02 00 00	 jmp	 $L200640
$L200665:

; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));

  002d3	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  002d6	52		 push	 edx
  002d7	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  002da	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  002df	50		 push	 eax
  002e0	6a 01		 push	 1
  002e2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002e5	50		 push	 eax
  002e6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e9	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  002ee	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002f1	e9 c9 02 00 00	 jmp	 $L200640
$L200650:

; 544  : 				}
; 545  : 			}
; 546  : 		else

  002f6	e9 aa 02 00 00	 jmp	 $L200644
$L200645:

; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

  002fb	8d 4d ec	 lea	 ecx, DWORD PTR $T202418[ebp]
  002fe	51		 push	 ecx
  002ff	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00302	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::begin
  00307	50		 push	 eax
  00308	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0030b	e8 00 00 00 00	 call	 ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
  00310	0f b6 d0	 movzx	 edx, al
  00313	85 d2		 test	 edx, edx
  00315	74 56		 je	 SHORT $L200671

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

  00317	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0031a	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  0031f	50		 push	 eax
  00320	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  00325	83 c4 04	 add	 esp, 4
  00328	50		 push	 eax
  00329	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0032c	50		 push	 eax
  0032d	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  00332	83 c4 04	 add	 esp, 4
  00335	50		 push	 eax
  00336	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00339	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0033e	0f b6 c8	 movzx	 ecx, al
  00341	85 c9		 test	 ecx, ecx
  00343	74 23		 je	 SHORT $L200672

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00345	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00348	52		 push	 edx
  00349	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0034c	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00351	50		 push	 eax
  00352	6a 01		 push	 1
  00354	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00357	50		 push	 eax
  00358	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0035b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  00360	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00363	e9 57 02 00 00	 jmp	 $L200640
$L200672:

; 552  : 				}
; 553  : 			else if (_Where == end())

  00368	e9 38 02 00 00	 jmp	 $L200644
$L200671:
  0036d	8d 4d e8	 lea	 ecx, DWORD PTR $T202419[ebp]
  00370	51		 push	 ecx
  00371	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00374	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::end
  00379	50		 push	 eax
  0037a	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0037d	e8 00 00 00 00	 call	 ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
  00382	0f b6 d0	 movzx	 edx, al
  00385	85 d2		 test	 edx, edx
  00387	74 5a		 je	 SHORT $L200676

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

  00389	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0038c	50		 push	 eax
  0038d	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  00392	83 c4 04	 add	 esp, 4
  00395	50		 push	 eax
  00396	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00399	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
  0039e	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a0	51		 push	 ecx
  003a1	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  003a6	83 c4 04	 add	 esp, 4
  003a9	50		 push	 eax
  003aa	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ad	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  003b2	0f b6 d0	 movzx	 edx, al
  003b5	85 d2		 test	 edx, edx
  003b7	74 25		 je	 SHORT $L200677

; 556  : 					return (_Insert(false, _Rmost(), _Val));

  003b9	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  003bc	50		 push	 eax
  003bd	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  003c0	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
  003c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c7	51		 push	 ecx
  003c8	6a 00		 push	 0
  003ca	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  003cd	52		 push	 edx
  003ce	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  003d1	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  003d6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003d9	e9 e1 01 00 00	 jmp	 $L200640
$L200677:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))

  003de	e9 c2 01 00 00	 jmp	 $L200644
$L200676:

; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

  003e3	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  003e6	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  003eb	50		 push	 eax
  003ec	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  003f1	83 c4 04	 add	 esp, 4
  003f4	50		 push	 eax
  003f5	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  003f8	50		 push	 eax
  003f9	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  003fe	83 c4 04	 add	 esp, 4
  00401	50		 push	 eax
  00402	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00405	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0040a	0f b6 c8	 movzx	 ecx, al
  0040d	85 c9		 test	 ecx, ecx
  0040f	0f 84 a4 00 00
	00		 je	 $L200680
  00415	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]
  00418	89 55 fc	 mov	 DWORD PTR __Next$[ebp], edx
  0041b	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0041e	50		 push	 eax
  0041f	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  00424	83 c4 04	 add	 esp, 4
  00427	50		 push	 eax
  00428	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  0042b	e8 00 00 00 00	 call	 ??Fiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator--
  00430	8b c8		 mov	 ecx, eax
  00432	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00437	50		 push	 eax
  00438	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  0043d	83 c4 04	 add	 esp, 4
  00440	50		 push	 eax
  00441	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00444	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00449	0f b6 c8	 movzx	 ecx, al
  0044c	85 c9		 test	 ecx, ecx
  0044e	74 69		 je	 SHORT $L200680

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

  00450	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  00453	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00458	50		 push	 eax
  00459	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0045e	83 c4 04	 add	 esp, 4
  00461	8b 10		 mov	 edx, DWORD PTR [eax]
  00463	52		 push	 edx
  00464	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00469	83 c4 04	 add	 esp, 4
  0046c	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0046f	85 c0		 test	 eax, eax
  00471	74 23		 je	 SHORT $L200681

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

  00473	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00476	51		 push	 ecx
  00477	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  0047a	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  0047f	50		 push	 eax
  00480	6a 00		 push	 0
  00482	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00485	52		 push	 edx
  00486	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00489	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  0048e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00491	e9 29 01 00 00	 jmp	 $L200640
$L200681:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00496	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00499	50		 push	 eax
  0049a	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0049d	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  004a2	50		 push	 eax
  004a3	6a 01		 push	 1
  004a5	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  004a8	51		 push	 ecx
  004a9	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  004ac	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  004b1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  004b4	e9 06 01 00 00	 jmp	 $L200640
$L200680:

; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

  004b9	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  004bc	52		 push	 edx
  004bd	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  004c2	83 c4 04	 add	 esp, 4
  004c5	50		 push	 eax
  004c6	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  004c9	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  004ce	50		 push	 eax
  004cf	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  004d4	83 c4 04	 add	 esp, 4
  004d7	50		 push	 eax
  004d8	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  004db	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  004e0	0f b6 c0	 movzx	 eax, al
  004e3	85 c0		 test	 eax, eax
  004e5	0f 84 ba 00 00
	00		 je	 $L200644
  004eb	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  004ee	89 4d fc	 mov	 DWORD PTR __Next$[ebp], ecx
  004f1	8d 55 e4	 lea	 edx, DWORD PTR $T202420[ebp]
  004f4	52		 push	 edx
  004f5	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  004f8	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::end
  004fd	50		 push	 eax
  004fe	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  00501	e8 00 00 00 00	 call	 ??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++
  00506	8b c8		 mov	 ecx, eax
  00508	e8 00 00 00 00	 call	 ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
  0050d	0f b6 c0	 movzx	 eax, al
  00510	85 c0		 test	 eax, eax
  00512	75 2e		 jne	 SHORT $L200688
  00514	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  00517	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  0051c	50		 push	 eax
  0051d	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  00522	83 c4 04	 add	 esp, 4
  00525	50		 push	 eax
  00526	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00529	51		 push	 ecx
  0052a	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  0052f	83 c4 04	 add	 esp, 4
  00532	50		 push	 eax
  00533	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00536	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0053b	0f b6 d0	 movzx	 edx, al
  0053e	85 d2		 test	 edx, edx
  00540	74 63		 je	 SHORT $L200644
$L200688:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

  00542	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00545	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  0054a	50		 push	 eax
  0054b	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00550	83 c4 04	 add	 esp, 4
  00553	8b 00		 mov	 eax, DWORD PTR [eax]
  00555	50		 push	 eax
  00556	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  0055b	83 c4 04	 add	 esp, 4
  0055e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00561	85 c9		 test	 ecx, ecx
  00563	74 20		 je	 SHORT $L200689

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

  00565	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00568	52		 push	 edx
  00569	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0056c	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00571	50		 push	 eax
  00572	6a 00		 push	 0
  00574	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00577	50		 push	 eax
  00578	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0057b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  00580	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00583	eb 3a		 jmp	 SHORT $L200640
$L200689:

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

  00585	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00588	51		 push	 ecx
  00589	8d 4d fc	 lea	 ecx, DWORD PTR __Next$[ebp]
  0058c	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00591	50		 push	 eax
  00592	6a 01		 push	 1
  00594	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00597	52		 push	 edx
  00598	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0059b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  005a0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005a3	eb 1a		 jmp	 SHORT $L200640
$L200644:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

  005a5	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  005a8	50		 push	 eax
  005a9	8d 4d dc	 lea	 ecx, DWORD PTR $T202421[ebp]
  005ac	51		 push	 ecx
  005ad	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  005b0	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::insert
  005b5	8b 10		 mov	 edx, DWORD PTR [eax]
  005b7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005ba	89 10		 mov	 DWORD PTR [eax], edx
  005bc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L200640:

; 580  : 		}

  005bf	8b e5		 mov	 esp, ebp
  005c1	5d		 pop	 ebp
  005c2	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lbound
; Function compile flags: /Odt
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 809  : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lbound
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 811  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::destroy
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
; Function compile flags: /Odt
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$200720 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __Pnode$200720[ebp], eax
  0000f	eb 06		 jmp	 SHORT $L200721
$L200722:
  00011	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$200720[ebp]
  00014	89 4d 08	 mov	 DWORD PTR __Rootnode$[ebp], ecx
$L200721:
  00017	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$200720[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00020	83 c4 04	 add	 esp, 4
  00023	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00026	85 c0		 test	 eax, eax
  00028	75 4a		 jne	 SHORT $L200719

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$200720[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00033	83 c4 04	 add	 esp, 4
  00036	8b 10		 mov	 edx, DWORD PTR [eax]
  00038	52		 push	 edx
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  00041	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$200720[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  0004a	83 c4 04	 add	 esp, 4
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	89 4d fc	 mov	 DWORD PTR __Pnode$200720[ebp], ecx

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

  00052	8b 55 08	 mov	 edx, DWORD PTR __Rootnode$[ebp]
  00055	52		 push	 edx
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	83 c1 01	 add	 ecx, 1
  0005c	e8 00 00 00 00	 call	 ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::destroy

; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  00061	6a 01		 push	 1
  00063	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00066	50		 push	 eax
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 01	 add	 ecx, 1
  0006d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::deallocate

; 897  : 			}

  00072	eb 9d		 jmp	 SHORT $L200722
$L200719:

; 898  : 		}

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Erase
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1004 : 		{	// return leftmost node in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1005 : 		return (_Left(_Myhead));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00013	83 c4 04	 add	 esp, 4

; 1006 : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lmost
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1048 : 		{	// return rightmost node in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1049 : 		return (_Right(_Myhead));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00013	83 c4 04	 add	 esp, 4

; 1050 : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
; Function compile flags: /Odt
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1058 : 		{	// return root of mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1059 : 		return (_Parent(_Myhead));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00013	83 c4 04	 add	 esp, 4

; 1060 : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::destroy
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::erase
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T202436 = -12						; size = 4
$T202435 = -8						; size = 4
$T202434 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1142 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1143 : 		erase(begin(), end());

  00009	8d 45 fc	 lea	 eax, DWORD PTR $T202434[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::end
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	8d 55 f8	 lea	 edx, DWORD PTR $T202435[ebp]
  0001b	52		 push	 edx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::begin
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	50		 push	 eax
  00027	8d 4d f4	 lea	 ecx, DWORD PTR $T202436[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));

  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  0003f	83 c4 04	 add	 esp, 4
  00042	50		 push	 eax
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 02	 add	 ecx, 2
  00049	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::destroy

; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));

  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0005a	83 c4 04	 add	 esp, 4
  0005d	50		 push	 eax
  0005e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 02	 add	 ecx, 2
  00064	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::destroy

; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));

  00069	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00075	83 c4 04	 add	 esp, 4
  00078	50		 push	 eax
  00079	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	83 c1 02	 add	 ecx, 2
  0007f	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::destroy

; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00084	6a 01		 push	 1
  00086	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00089	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0008c	50		 push	 eax
  0008d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	83 c1 01	 add	 ecx, 1
  00093	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::deallocate

; 1148 : 		_Myhead = 0, _Mysize = 0;

  00098	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  000a2	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 1149 : 		}

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tidy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\functional
_TEXT	ENDS
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC NEAR			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 138  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		return (_Left < _Right);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	33 c0		 xor	 eax, eax
  00011	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00013	0f 9c c0	 setl	 al

; 140  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@H@std@@QAE@XZ PROC NEAR			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L200743

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 49		 jmp	 SHORT $L200742
$L200743:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L200745

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 776  : 		else

  00044	eb 30		 jmp	 SHORT $L200744
$L200745:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00067	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0006d	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L200744:

; 781  : 			}
; 782  : 		return (true);

  00076	b0 01		 mov	 al, 1
$L200742:

; 783  : 		}

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 35		 je	 SHORT $L200749

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	c1 f9 02	 sar	 ecx, 2
  00035	51		 push	 ecx
  00036	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00039	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003c	50		 push	 eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate
$L200749:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Odt
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC NEAR ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@ABV01@@Z ; std::allocator<int>::allocator<int>

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAE@PAUMYLIST_COLUMN_INFO@@@Z ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::const_iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::begin, COMDAT
; _this$ = ecx

; 467  : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 468  : 		return (const_iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAE@PAUMYLIST_COLUMN_INFO@@@Z ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::const_iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 469  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::begin
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::const_iterator

; 313  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 316  : 			{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator*

; 318  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 327  : 			++(*(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator++

; 328  : 			return (*this);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 329  : 			}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 240  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 242  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 283  : 			{	// return node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 284  : 			return (_Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 285  : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0MYLIST_COLUMN_INFO@@QAE@ABU0@@Z		; MYLIST_COLUMN_INFO::MYLIST_COLUMN_INFO
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABHABUMYLIST_COLUMN_INFO@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABHABUMYLIST_COLUMN_INFO@@@Z PROC NEAR ; std::pair<int const ,MYLIST_COLUMN_INFO>::pair<int const ,MYLIST_COLUMN_INFO>, COMDAT
; _this$ = ecx

; 34   : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 04	 add	 ecx, 4
  0001b	e8 00 00 00 00	 call	 ??0MYLIST_COLUMN_INFO@@QAE@ABU0@@Z

; 35   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABHABUMYLIST_COLUMN_INFO@@@Z ENDP ; std::pair<int const ,MYLIST_COLUMN_INFO>::pair<int const ,MYLIST_COLUMN_INFO>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 152  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 156  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator==
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@XZ PROC NEAR ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBEABUMYLIST_COLUMN_INFO@@XZ ENDP ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAEAAV012@H@Z ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator+=
; Function compile flags: /Odt
;	COMDAT ??Hconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator+, COMDAT
; _this$ = ecx

; 123  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 124  : 			const_iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 125  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAEAAV012@H@Z ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 126  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator+
_TEXT	ENDS
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
; Function compile flags: /Odt
;	COMDAT ??0MYLIST_COLUMN_INFO@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0MYLIST_COLUMN_INFO@@QAE@ABU0@@Z PROC NEAR		; MYLIST_COLUMN_INFO::MYLIST_COLUMN_INFO, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0001a	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00026	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00029	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00032	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00035	89 41 24	 mov	 DWORD PTR [ecx+36], eax
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003e	8a 42 28	 mov	 al, BYTE PTR [edx+40]
  00041	88 41 28	 mov	 BYTE PTR [ecx+40], al
  00044	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00047	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0004a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	83 c2 2c	 add	 edx, 44			; 0000002cH
  00050	8b 01		 mov	 eax, DWORD PTR [ecx]
  00052	89 02		 mov	 DWORD PTR [edx], eax
  00054	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00057	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0005a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005d	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00060	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00063	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00066	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00069	83 c2 3c	 add	 edx, 60			; 0000003cH
  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	83 c0 3c	 add	 eax, 60			; 0000003cH
  00072	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00074	89 08		 mov	 DWORD PTR [eax], ecx
  00076	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00079	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0007c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0007f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00082	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00085	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00088	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 04 00	 ret	 4
??0MYLIST_COLUMN_INFO@@QAE@ABU0@@Z ENDP			; MYLIST_COLUMN_INFO::MYLIST_COLUMN_INFO
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil, COMDAT

; 136  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 5d	 add	 eax, 93			; 0000005dH

; 138  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left, COMDAT

; 146  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 148  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent, COMDAT

; 151  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 153  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right, COMDAT

; 156  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 158  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Myval, COMDAT

; 161  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>
; Function compile flags: /Odt
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z
_TEXT	SEGMENT
tv85 = -56						; size = 4
_this$ = -52						; size = 4
$T202496 = -45						; size = 1
$T202495 = -44						; size = 4
$T202494 = -37						; size = 1
$T202493 = -36						; size = 4
$T202492 = -29						; size = 1
$T202491 = -28						; size = 4
$T202490 = -24						; size = 4
$T202489 = -17						; size = 1
__Where$200871 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::insert, COMDAT
; _this$ = ecx

; 477  : 		{	// try to insert node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 478  : 		_Nodeptr _Trynode = _Root();

  00009	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  00011	8b 00		 mov	 eax, DWORD PTR [eax]
  00013	89 45 f4	 mov	 DWORD PTR __Trynode$[ebp], eax

; 479  : 		_Nodeptr _Wherenode = _Myhead;

  00016	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001c	89 55 f8	 mov	 DWORD PTR __Wherenode$[ebp], edx

; 480  : 		bool _Addleft = true;	// add to left of head if tree empty

  0001f	c6 45 ff 01	 mov	 BYTE PTR __Addleft$[ebp], 1
$L200860:

; 481  : 		while (!_Isnil(_Trynode))

  00023	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  0002c	83 c4 04	 add	 esp, 4
  0002f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00032	85 c9		 test	 ecx, ecx
  00034	75 5f		 jne	 SHORT $L200861

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;

  00036	8b 55 f4	 mov	 edx, DWORD PTR __Trynode$[ebp]
  00039	89 55 f8	 mov	 DWORD PTR __Wherenode$[ebp], edx

; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  00045	83 c4 04	 add	 esp, 4
  00048	50		 push	 eax
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0005e	88 45 ff	 mov	 BYTE PTR __Addleft$[ebp], al

; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  00061	0f b6 55 ff	 movzx	 edx, BYTE PTR __Addleft$[ebp]
  00065	85 d2		 test	 edx, edx
  00067	74 13		 je	 SHORT $L202487
  00069	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00072	83 c4 04	 add	 esp, 4
  00075	8b 08		 mov	 ecx, DWORD PTR [eax]
  00077	89 4d c8	 mov	 DWORD PTR tv85[ebp], ecx
  0007a	eb 11		 jmp	 SHORT $L202488
$L202487:
  0007c	8b 55 f4	 mov	 edx, DWORD PTR __Trynode$[ebp]
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00085	83 c4 04	 add	 esp, 4
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	89 45 c8	 mov	 DWORD PTR tv85[ebp], eax
$L202488:
  0008d	8b 4d c8	 mov	 ecx, DWORD PTR tv85[ebp]
  00090	89 4d f4	 mov	 DWORD PTR __Trynode$[ebp], ecx

; 486  : 			}

  00093	eb 8e		 jmp	 SHORT $L200860
$L200861:

; 487  : 
; 488  : 		if (this->_Multi)

  00095	33 d2		 xor	 edx, edx
  00097	74 31		 je	 SHORT $L200862

; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00099	c6 45 ef 01	 mov	 BYTE PTR $T202489[ebp], 1
  0009d	8d 45 ef	 lea	 eax, DWORD PTR $T202489[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  000a4	51		 push	 ecx
  000a5	8b 55 f8	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000a8	52		 push	 edx
  000a9	8a 45 ff	 mov	 al, BYTE PTR __Addleft$[ebp]
  000ac	50		 push	 eax
  000ad	8d 4d e8	 lea	 ecx, DWORD PTR $T202490[ebp]
  000b0	51		 push	 ecx
  000b1	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  000b9	50		 push	 eax
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000bd	e8 00 00 00 00	 call	 ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>
  000c2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c5	e9 d9 00 00 00	 jmp	 $L200855
$L200862:

; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

  000ca	8b 55 f8	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cd	52		 push	 edx
  000ce	8d 4d f0	 lea	 ecx, DWORD PTR __Where$200871[ebp]
  000d1	e8 00 00 00 00	 call	 ??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator

; 493  : 			if (!_Addleft)

  000d6	0f b6 45 ff	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000da	85 c0		 test	 eax, eax
  000dc	75 02		 jne	 SHORT $L200873

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  000de	eb 50		 jmp	 SHORT $L200874
$L200873:
  000e0	8d 4d e4	 lea	 ecx, DWORD PTR $T202491[ebp]
  000e3	51		 push	 ecx
  000e4	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::begin
  000ec	50		 push	 eax
  000ed	8d 4d f0	 lea	 ecx, DWORD PTR __Where$200871[ebp]
  000f0	e8 00 00 00 00	 call	 ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
  000f5	0f b6 d0	 movzx	 edx, al
  000f8	85 d2		 test	 edx, edx
  000fa	74 2c		 je	 SHORT $L200876

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  000fc	c6 45 e3 01	 mov	 BYTE PTR $T202492[ebp], 1
  00100	8d 45 e3	 lea	 eax, DWORD PTR $T202492[ebp]
  00103	50		 push	 eax
  00104	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00107	51		 push	 ecx
  00108	8b 55 f8	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0010b	52		 push	 edx
  0010c	6a 01		 push	 1
  0010e	8d 45 dc	 lea	 eax, DWORD PTR $T202493[ebp]
  00111	50		 push	 eax
  00112	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  0011a	50		 push	 eax
  0011b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0011e	e8 00 00 00 00	 call	 ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>
  00123	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00126	eb 7b		 jmp	 SHORT $L200855
$L200876:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00128	8d 4d f0	 lea	 ecx, DWORD PTR __Where$200871[ebp]
  0012b	e8 00 00 00 00	 call	 ??Fiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator--
$L200874:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  00130	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00133	51		 push	 ecx
  00134	e8 00 00 00 00	 call	 ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
  00139	83 c4 04	 add	 esp, 4
  0013c	50		 push	 eax
  0013d	8d 4d f0	 lea	 ecx, DWORD PTR __Where$200871[ebp]
  00140	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  0014b	83 c4 04	 add	 esp, 4
  0014e	50		 push	 eax
  0014f	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00152	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00157	0f b6 d0	 movzx	 edx, al
  0015a	85 d2		 test	 edx, edx
  0015c	74 2e		 je	 SHORT $L200881

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  0015e	c6 45 db 01	 mov	 BYTE PTR $T202494[ebp], 1
  00162	8d 45 db	 lea	 eax, DWORD PTR $T202494[ebp]
  00165	50		 push	 eax
  00166	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00169	51		 push	 ecx
  0016a	8b 55 f8	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0016d	52		 push	 edx
  0016e	8a 45 ff	 mov	 al, BYTE PTR __Addleft$[ebp]
  00171	50		 push	 eax
  00172	8d 4d d4	 lea	 ecx, DWORD PTR $T202495[ebp]
  00175	51		 push	 ecx
  00176	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00179	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
  0017e	50		 push	 eax
  0017f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00182	e8 00 00 00 00	 call	 ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>
  00187	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0018a	eb 17		 jmp	 SHORT $L200855
$L200881:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  0018c	c6 45 d3 00	 mov	 BYTE PTR $T202496[ebp], 0
  00190	8d 55 d3	 lea	 edx, DWORD PTR $T202496[ebp]
  00193	52		 push	 edx
  00194	8d 45 f0	 lea	 eax, DWORD PTR __Where$200871[ebp]
  00197	50		 push	 eax
  00198	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0019b	e8 00 00 00 00	 call	 ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>
  001a0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L200855:

; 504  : 			}
; 505  : 		}

  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::erase
; Function compile flags: /Odt
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T202502 = -16						; size = 4
$T202501 = -12						; size = 4
$T202500 = -8						; size = 4
$T202499 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::erase, COMDAT
; _this$ = ecx

; 750  : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 751  : 		if (_First == begin() && _Last == end())

  00009	8d 45 fc	 lea	 eax, DWORD PTR $T202499[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::begin
  00015	50		 push	 eax
  00016	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00019	e8 00 00 00 00	 call	 ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
  0001e	0f b6 c8	 movzx	 ecx, al
  00021	85 c9		 test	 ecx, ecx
  00023	74 35		 je	 SHORT $L200897
  00025	8d 55 f8	 lea	 edx, DWORD PTR $T202500[ebp]
  00028	52		 push	 edx
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::end
  00031	50		 push	 eax
  00032	8d 4d 10	 lea	 ecx, DWORD PTR __Last$[ebp]
  00035	e8 00 00 00 00	 call	 ??8const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator==
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	85 c0		 test	 eax, eax
  0003f	74 19		 je	 SHORT $L200897

; 752  : 			{	// erase all
; 753  : 			clear();

  00041	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::clear

; 754  : 			return (begin());

  00049	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::begin
  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	eb 3d		 jmp	 SHORT $L200890
$L200897:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  0005a	8d 55 10	 lea	 edx, DWORD PTR __Last$[ebp]
  0005d	52		 push	 edx
  0005e	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00061	e8 00 00 00 00	 call	 ??9const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator!=
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	74 1f		 je	 SHORT $L200898

; 759  : 				erase(_First++);

  0006d	6a 00		 push	 0
  0006f	8d 4d f4	 lea	 ecx, DWORD PTR $T202501[ebp]
  00072	51		 push	 ecx
  00073	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00076	e8 00 00 00 00	 call	 ??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++
  0007b	8b 10		 mov	 edx, DWORD PTR [eax]
  0007d	52		 push	 edx
  0007e	8d 45 f0	 lea	 eax, DWORD PTR $T202502[ebp]
  00081	50		 push	 eax
  00082	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::erase
  0008a	eb ce		 jmp	 SHORT $L200897
$L200898:

; 760  : 			return (_First);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0008f	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00092	89 11		 mov	 DWORD PTR [ecx], edx
  00094	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L200890:

; 761  : 			}
; 762  : 		}

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Buynode
; Function compile flags: /Odt
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Init, COMDAT
; _this$ = ecx

; 901  : 		{	// create head/nil node and make tree empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 902  : 		_Myhead = _Buynode();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Buynode
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 903  : 		_Isnil(_Myhead) = true;

  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00021	83 c4 04	 add	 esp, 4
  00024	c6 00 01	 mov	 BYTE PTR [eax], 1

; 904  : 		_Root() = _Myhead;

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00035	89 10		 mov	 DWORD PTR [eax], edx

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lmost
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00045	89 10		 mov	 DWORD PTR [eax], edx
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00055	89 10		 mov	 DWORD PTR [eax], edx

; 906  : 		_Mysize = 0;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 907  : 		}

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Init
_TEXT	ENDS
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::max_size
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rrotate
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Buynode
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202514 DD	0ffffffffH
	DD	FLAT:$L202510
$T202512 DD	019930520H
	DD	01H
	DD	FLAT:$T202514
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
	ORG $-30
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T202508 = -88						; size = 28
$T202507 = -60						; size = 40
__Pnode$200921 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 50	 sub	 esp, 80			; 00000050H
  0001b	56		 push	 esi
  0001c	89 4d a4	 mov	 DWORD PTR _this$[ebp], ecx

; 912  : 		if (max_size() - 1 <= _Mysize)

  0001f	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::max_size
  00027	83 e8 01	 sub	 eax, 1
  0002a	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00030	77 2f		 ja	 SHORT $L200906

; 913  : 			_THROW(length_error, "map/set<T> too long");

  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  00037	8d 4d a8	 lea	 ecx, DWORD PTR $T202508[ebp]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	8d 55 a8	 lea	 edx, DWORD PTR $T202508[ebp]
  0004a	52		 push	 edx
  0004b	8d 4d c4	 lea	 ecx, DWORD PTR $T202507[ebp]
  0004e	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  00053	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00058	8d 45 c4	 lea	 eax, DWORD PTR $T202507[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200906:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  00061	6a 00		 push	 0
  00063	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006d	50		 push	 eax
  0006e	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  00075	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00078	50		 push	 eax
  00079	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Buynode
  00081	89 45 f0	 mov	 DWORD PTR __Newnode$[ebp], eax

; 916  : 
; 917  : 		++_Mysize;

  00084	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0008a	83 c2 01	 add	 edx, 1
  0008d	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  00090	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 918  : 		if (_Wherenode == _Myhead)

  00093	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	8b 55 10	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00099	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0009c	75 29		 jne	 SHORT $L200915

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  0009e	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  000a6	8b 4d f0	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000a9	89 08		 mov	 DWORD PTR [eax], ecx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  000ab	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lmost
  000b3	8b 55 f0	 mov	 edx, DWORD PTR __Newnode$[ebp]
  000b6	89 10		 mov	 DWORD PTR [eax], edx
  000b8	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000c3	89 08		 mov	 DWORD PTR [eax], ecx

; 922  : 			}
; 923  : 		else if (_Addleft)

  000c5	eb 64		 jmp	 SHORT $L200916
$L200915:
  000c7	0f b6 55 0c	 movzx	 edx, BYTE PTR __Addleft$[ebp]
  000cb	85 d2		 test	 edx, edx
  000cd	74 2f		 je	 SHORT $L200917

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  000cf	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 4d f0	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000de	89 08		 mov	 DWORD PTR [eax], ecx

; 926  : 			if (_Wherenode == _Lmost())

  000e0	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lmost
  000e8	8b 55 10	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000eb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ed	75 0d		 jne	 SHORT $L200918

; 927  : 				_Lmost() = _Newnode;

  000ef	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lmost
  000f7	8b 4d f0	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000fa	89 08		 mov	 DWORD PTR [eax], ecx
$L200918:

; 928  : 			}
; 929  : 		else

  000fc	eb 2d		 jmp	 SHORT $L200916
$L200917:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  000fe	8b 55 10	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00101	52		 push	 edx
  00102	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00107	83 c4 04	 add	 esp, 4
  0010a	8b 4d f0	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0010d	89 08		 mov	 DWORD PTR [eax], ecx

; 932  : 			if (_Wherenode == _Rmost())

  0010f	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
  00117	8b 55 10	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0011a	3b 10		 cmp	 edx, DWORD PTR [eax]
  0011c	75 0d		 jne	 SHORT $L200916

; 933  : 				_Rmost() = _Newnode;

  0011e	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
  00126	8b 4d f0	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx
$L200916:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  0012b	8b 55 f0	 mov	 edx, DWORD PTR __Newnode$[ebp]
  0012e	89 55 ec	 mov	 DWORD PTR __Pnode$200921[ebp], edx
$L200923:
  00131	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$200921[ebp]
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0013a	83 c4 04	 add	 esp, 4
  0013d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013f	51		 push	 ecx
  00140	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00145	83 c4 04	 add	 esp, 4
  00148	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0014b	85 d2		 test	 edx, edx
  0014d	0f 85 ce 02 00
	00		 jne	 $L200924

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  00153	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$200921[ebp]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0015c	83 c4 04	 add	 esp, 4
  0015f	8b f0		 mov	 esi, eax
  00161	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  00164	51		 push	 ecx
  00165	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0016a	83 c4 04	 add	 esp, 4
  0016d	8b 10		 mov	 edx, DWORD PTR [eax]
  0016f	52		 push	 edx
  00170	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00175	83 c4 04	 add	 esp, 4
  00178	8b 00		 mov	 eax, DWORD PTR [eax]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00180	83 c4 04	 add	 esp, 4
  00183	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00185	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00187	0f 85 4a 01 00
	00		 jne	 $L200925

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  0018d	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$200921[ebp]
  00190	52		 push	 edx
  00191	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00196	83 c4 04	 add	 esp, 4
  00199	8b 00		 mov	 eax, DWORD PTR [eax]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  001a1	83 c4 04	 add	 esp, 4
  001a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a6	51		 push	 ecx
  001a7	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  001ac	83 c4 04	 add	 esp, 4
  001af	8b 10		 mov	 edx, DWORD PTR [eax]
  001b1	89 55 10	 mov	 DWORD PTR __Wherenode$[ebp], edx

; 940  : 				if (_Color(_Wherenode) == _Red)

  001b4	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  001bd	83 c4 04	 add	 esp, 4
  001c0	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001c3	85 c9		 test	 ecx, ecx
  001c5	75 6f		 jne	 SHORT $L200926

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  001c7	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$200921[ebp]
  001ca	52		 push	 edx
  001cb	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  001d0	83 c4 04	 add	 esp, 4
  001d3	8b 00		 mov	 eax, DWORD PTR [eax]
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  001db	83 c4 04	 add	 esp, 4
  001de	c6 00 01	 mov	 BYTE PTR [eax], 1

; 943  : 					_Color(_Wherenode) = _Black;

  001e1	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  001e4	51		 push	 ecx
  001e5	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  001ea	83 c4 04	 add	 esp, 4
  001ed	c6 00 01	 mov	 BYTE PTR [eax], 1

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  001f0	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$200921[ebp]
  001f3	52		 push	 edx
  001f4	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  001f9	83 c4 04	 add	 esp, 4
  001fc	8b 00		 mov	 eax, DWORD PTR [eax]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00204	83 c4 04	 add	 esp, 4
  00207	8b 08		 mov	 ecx, DWORD PTR [eax]
  00209	51		 push	 ecx
  0020a	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  0020f	83 c4 04	 add	 esp, 4
  00212	c6 00 00	 mov	 BYTE PTR [eax], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  00215	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$200921[ebp]
  00218	52		 push	 edx
  00219	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0021e	83 c4 04	 add	 esp, 4
  00221	8b 00		 mov	 eax, DWORD PTR [eax]
  00223	50		 push	 eax
  00224	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00229	83 c4 04	 add	 esp, 4
  0022c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022e	89 4d ec	 mov	 DWORD PTR __Pnode$200921[ebp], ecx

; 946  : 					}
; 947  : 				else

  00231	e9 9c 00 00 00	 jmp	 $L200927
$L200926:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  00236	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$200921[ebp]
  00239	52		 push	 edx
  0023a	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0023f	83 c4 04	 add	 esp, 4
  00242	8b 00		 mov	 eax, DWORD PTR [eax]
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0024a	83 c4 04	 add	 esp, 4
  0024d	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  00250	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00252	75 1d		 jne	 SHORT $L200928

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);

  00254	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$200921[ebp]
  00257	52		 push	 edx
  00258	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0025d	83 c4 04	 add	 esp, 4
  00260	8b 00		 mov	 eax, DWORD PTR [eax]
  00262	89 45 ec	 mov	 DWORD PTR __Pnode$200921[ebp], eax

; 952  : 						_Lrotate(_Pnode);

  00265	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  00268	51		 push	 ecx
  00269	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  0026c	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lrotate
$L200928:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  00271	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$200921[ebp]
  00274	52		 push	 edx
  00275	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0027a	83 c4 04	 add	 esp, 4
  0027d	8b 00		 mov	 eax, DWORD PTR [eax]
  0027f	50		 push	 eax
  00280	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00285	83 c4 04	 add	 esp, 4
  00288	c6 00 01	 mov	 BYTE PTR [eax], 1

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  0028b	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  0028e	51		 push	 ecx
  0028f	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00294	83 c4 04	 add	 esp, 4
  00297	8b 10		 mov	 edx, DWORD PTR [eax]
  00299	52		 push	 edx
  0029a	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0029f	83 c4 04	 add	 esp, 4
  002a2	8b 00		 mov	 eax, DWORD PTR [eax]
  002a4	50		 push	 eax
  002a5	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  002aa	83 c4 04	 add	 esp, 4
  002ad	c6 00 00	 mov	 BYTE PTR [eax], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  002b0	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  002b3	51		 push	 ecx
  002b4	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  002b9	83 c4 04	 add	 esp, 4
  002bc	8b 10		 mov	 edx, DWORD PTR [eax]
  002be	52		 push	 edx
  002bf	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  002c4	83 c4 04	 add	 esp, 4
  002c7	8b 00		 mov	 eax, DWORD PTR [eax]
  002c9	50		 push	 eax
  002ca	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  002cd	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rrotate
$L200927:

; 957  : 					}
; 958  : 				}
; 959  : 			else

  002d2	e9 45 01 00 00	 jmp	 $L200929
$L200925:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

  002d7	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  002da	51		 push	 ecx
  002db	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  002e0	83 c4 04	 add	 esp, 4
  002e3	8b 10		 mov	 edx, DWORD PTR [eax]
  002e5	52		 push	 edx
  002e6	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  002eb	83 c4 04	 add	 esp, 4
  002ee	8b 00		 mov	 eax, DWORD PTR [eax]
  002f0	50		 push	 eax
  002f1	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  002f6	83 c4 04	 add	 esp, 4
  002f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  002fb	89 4d 10	 mov	 DWORD PTR __Wherenode$[ebp], ecx

; 962  : 				if (_Color(_Wherenode) == _Red)

  002fe	8b 55 10	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00301	52		 push	 edx
  00302	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00307	83 c4 04	 add	 esp, 4
  0030a	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0030d	85 c0		 test	 eax, eax
  0030f	75 6f		 jne	 SHORT $L200930

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;

  00311	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  00314	51		 push	 ecx
  00315	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0031a	83 c4 04	 add	 esp, 4
  0031d	8b 10		 mov	 edx, DWORD PTR [eax]
  0031f	52		 push	 edx
  00320	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00325	83 c4 04	 add	 esp, 4
  00328	c6 00 01	 mov	 BYTE PTR [eax], 1

; 965  : 					_Color(_Wherenode) = _Black;

  0032b	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0032e	50		 push	 eax
  0032f	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00334	83 c4 04	 add	 esp, 4
  00337	c6 00 01	 mov	 BYTE PTR [eax], 1

; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  0033a	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  0033d	51		 push	 ecx
  0033e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00343	83 c4 04	 add	 esp, 4
  00346	8b 10		 mov	 edx, DWORD PTR [eax]
  00348	52		 push	 edx
  00349	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0034e	83 c4 04	 add	 esp, 4
  00351	8b 00		 mov	 eax, DWORD PTR [eax]
  00353	50		 push	 eax
  00354	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00359	83 c4 04	 add	 esp, 4
  0035c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 967  : 					_Pnode = _Parent(_Parent(_Pnode));

  0035f	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  00362	51		 push	 ecx
  00363	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00368	83 c4 04	 add	 esp, 4
  0036b	8b 10		 mov	 edx, DWORD PTR [eax]
  0036d	52		 push	 edx
  0036e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00373	83 c4 04	 add	 esp, 4
  00376	8b 00		 mov	 eax, DWORD PTR [eax]
  00378	89 45 ec	 mov	 DWORD PTR __Pnode$200921[ebp], eax

; 968  : 					}
; 969  : 				else

  0037b	e9 9c 00 00 00	 jmp	 $L200929
$L200930:

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00380	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  00383	51		 push	 ecx
  00384	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00389	83 c4 04	 add	 esp, 4
  0038c	8b 10		 mov	 edx, DWORD PTR [eax]
  0038e	52		 push	 edx
  0038f	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00394	83 c4 04	 add	 esp, 4
  00397	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  0039a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0039c	75 1d		 jne	 SHORT $L200932

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);

  0039e	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$200921[ebp]
  003a1	52		 push	 edx
  003a2	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  003a7	83 c4 04	 add	 esp, 4
  003aa	8b 00		 mov	 eax, DWORD PTR [eax]
  003ac	89 45 ec	 mov	 DWORD PTR __Pnode$200921[ebp], eax

; 974  : 						_Rrotate(_Pnode);

  003af	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  003b2	51		 push	 ecx
  003b3	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  003b6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rrotate
$L200932:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  003bb	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$200921[ebp]
  003be	52		 push	 edx
  003bf	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  003c4	83 c4 04	 add	 esp, 4
  003c7	8b 00		 mov	 eax, DWORD PTR [eax]
  003c9	50		 push	 eax
  003ca	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  003cf	83 c4 04	 add	 esp, 4
  003d2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  003d5	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  003d8	51		 push	 ecx
  003d9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  003de	83 c4 04	 add	 esp, 4
  003e1	8b 10		 mov	 edx, DWORD PTR [eax]
  003e3	52		 push	 edx
  003e4	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  003e9	83 c4 04	 add	 esp, 4
  003ec	8b 00		 mov	 eax, DWORD PTR [eax]
  003ee	50		 push	 eax
  003ef	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  003f4	83 c4 04	 add	 esp, 4
  003f7	c6 00 00	 mov	 BYTE PTR [eax], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  003fa	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$200921[ebp]
  003fd	51		 push	 ecx
  003fe	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00403	83 c4 04	 add	 esp, 4
  00406	8b 10		 mov	 edx, DWORD PTR [eax]
  00408	52		 push	 edx
  00409	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0040e	83 c4 04	 add	 esp, 4
  00411	8b 00		 mov	 eax, DWORD PTR [eax]
  00413	50		 push	 eax
  00414	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00417	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lrotate
$L200929:

; 979  : 					}
; 980  : 				}

  0041c	e9 10 fd ff ff	 jmp	 $L200923
$L200924:

; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  00421	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00424	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  00429	8b 08		 mov	 ecx, DWORD PTR [eax]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00431	83 c4 04	 add	 esp, 4
  00434	c6 00 01	 mov	 BYTE PTR [eax], 1

; 983  : 		return (_TREE_ITERATOR(_Newnode));

  00437	8b 55 f0	 mov	 edx, DWORD PTR __Newnode$[ebp]
  0043a	52		 push	 edx
  0043b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0043e	e8 00 00 00 00	 call	 ??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator
  00443	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L202506:

; 984  : 		}

  00446	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00449	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00450	5e		 pop	 esi
  00451	8b e5		 mov	 esp, ebp
  00453	5d		 pop	 ebp
  00454	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202510:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR $T202508[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202512
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Insert
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
; Function compile flags: /Odt
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 987  : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 988  : 		_Nodeptr _Pnode = _Root();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  00011	8b 00		 mov	 eax, DWORD PTR [eax]
  00013	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

  00016	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001c	89 55 fc	 mov	 DWORD PTR __Wherenode$[ebp], edx
$L200939:

; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0001f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00028	83 c4 04	 add	 esp, 4
  0002b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0002e	85 c9		 test	 ecx, ecx
  00030	75 4c		 jne	 SHORT $L200940

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00032	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00035	52		 push	 edx
  00036	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?_Key@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Key
  0003f	83 c4 04	 add	 esp, 4
  00042	50		 push	 eax
  00043	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0004b	0f b6 c8	 movzx	 ecx, al
  0004e	85 c9		 test	 ecx, ecx
  00050	74 13		 je	 SHORT $L200941

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00052	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0005b	83 c4 04	 add	 esp, 4
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 994  : 			else

  00063	eb 17		 jmp	 SHORT $L200942
$L200941:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00065	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00068	89 4d fc	 mov	 DWORD PTR __Wherenode$[ebp], ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0006b	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00074	83 c4 04	 add	 esp, 4
  00077	8b 00		 mov	 eax, DWORD PTR [eax]
  00079	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax
$L200942:

; 998  : 				}

  0007c	eb a1		 jmp	 SHORT $L200939
$L200940:

; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 1001 : 		}

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_ptr<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
; Function compile flags: /Odt
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_val<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >, COMDAT
; _this$ = ecx

; 95   : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00018	51		 push	 ecx
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_Tree_ptr@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_ptr<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
  00021	8d 55 0c	 lea	 edx, DWORD PTR __Al$[ebp]
  00024	52		 push	 edx
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 c1 03	 add	 ecx, 3
  0002b	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >

; 96   : 		}

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_val<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z PROC NEAR ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn, COMDAT

; 63   : 		{	// extract key from element value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 64   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 65   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Kfn@?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@@Z ENDP ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Kfn
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::destroy
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC NEAR	; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC NEAR	; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@H@std@@YAPAHIPAH@Z ; std::_Allocate<int>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@H@std@@QBEIXZ ; std::allocator<int>::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202550 DD	0ffffffffH
	DD	FLAT:$L202546
$T202548 DD	019930520H
	DD	01H
	DD	FLAT:$T202550
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T202545 = -80						; size = 28
$T202544 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T202545[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T202545[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T202544[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T202544[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L202543:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202546:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T202545[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202548
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 304  : 		iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::const_iterator

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator--
; Function compile flags: /Odt
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 339  : 			{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 340  : 			--(*(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator--

; 341  : 			return (*this);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 342  : 			}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??Fiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator--
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 204  : 			{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 205  : 			return (_Myval(_Ptr));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?_Myval@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Myval
  00012	83 c4 04	 add	 esp, 4

; 206  : 			}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Inc
; Function compile flags: /Odt
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 215  : 			_Inc();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 217  : 			}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator++
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAE@PAUMYLIST_COLUMN_INFO@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAE@PAUMYLIST_COLUMN_INFO@@@Z PROC NEAR ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAE@PAUMYLIST_COLUMN_INFO@@@Z ENDP ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator+=, COMDAT
; _this$ = ecx

; 117  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 			_Myptr += _Off;

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 01		 add	 eax, DWORD PTR [ecx]
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	89 02		 mov	 DWORD PTR [edx], eax

; 119  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 120  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??Yconst_iterator@?$vector@UMYLIST_COLUMN_INFO@@V?$allocator@UMYLIST_COLUMN_INFO@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<MYLIST_COLUMN_INFO,std::allocator<MYLIST_COLUMN_INFO> >::const_iterator::operator+=
_TEXT	ENDS
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color, COMDAT

; 131  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 5c	 add	 eax, 92			; 0000005cH

; 133  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::max_size
; Function compile flags: /Odt
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::max_size, COMDAT
; _this$ = ecx

; 452  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 453  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 03	 add	 ecx, 3
  0000d	e8 00 00 00 00	 call	 ?max_size@?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::max_size

; 454  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::max_size
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Min
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202588 DD	0ffffffffH
	DD	FLAT:$L202584
$T202586 DD	019930520H
	DD	01H
	DD	FLAT:$T202588
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T202579 = -96						; size = 28
$T202578 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::erase, COMDAT
; _this$ = ecx

; 590  : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 60	 sub	 esp, 96			; 00000060H
  0001b	56		 push	 esi
  0001c	89 4d 9c	 mov	 DWORD PTR _this$[ebp], ecx

; 591  : 		if (_Isnil(_Where._Mynode()))

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  0002d	83 c4 04	 add	 esp, 4
  00030	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00033	85 c0		 test	 eax, eax
  00035	74 2f		 je	 SHORT $L201019

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0003c	8d 4d a0	 lea	 ecx, DWORD PTR $T202579[ebp]
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	8d 4d a0	 lea	 ecx, DWORD PTR $T202579[ebp]
  0004f	51		 push	 ecx
  00050	8d 4d bc	 lea	 ecx, DWORD PTR $T202578[ebp]
  00053	e8 00 00 00 00	 call	 ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
  00058	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  0005d	8d 55 bc	 lea	 edx, DWORD PTR $T202578[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201019:

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  00066	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00069	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  0006e	89 45 f0	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 594  : 		++_Where;	// save successor iterator for return

  00071	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00074	e8 00 00 00 00	 call	 ??Eiterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator::operator++

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;

  00079	8b 45 f0	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0007c	89 45 e8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  0007f	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00088	83 c4 04	 add	 esp, 4
  0008b	8b 10		 mov	 edx, DWORD PTR [eax]
  0008d	52		 push	 edx
  0008e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00093	83 c4 04	 add	 esp, 4
  00096	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00099	85 c0		 test	 eax, eax
  0009b	74 13		 je	 SHORT $L201027

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0009d	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  000a6	83 c4 04	 add	 esp, 4
  000a9	8b 10		 mov	 edx, DWORD PTR [eax]
  000ab	89 55 ec	 mov	 DWORD PTR __Fixnode$[ebp], edx

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  000ae	eb 4d		 jmp	 SHORT $L201028
$L201027:
  000b0	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  000b9	83 c4 04	 add	 esp, 4
  000bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  000c4	83 c4 04	 add	 esp, 4
  000c7	0f be 10	 movsx	 edx, BYTE PTR [eax]
  000ca	85 d2		 test	 edx, edx
  000cc	74 13		 je	 SHORT $L201029

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  000ce	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  000d7	83 c4 04	 add	 esp, 4
  000da	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dc	89 4d ec	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 604  : 		else

  000df	eb 1c		 jmp	 SHORT $L201028
$L201029:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  000e1	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000e4	e8 00 00 00 00	 call	 ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Mynode
  000e9	89 45 e8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  000ec	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  000f5	83 c4 04	 add	 esp, 4
  000f8	8b 00		 mov	 eax, DWORD PTR [eax]
  000fa	89 45 ec	 mov	 DWORD PTR __Fixnode$[ebp], eax
$L201028:

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  000fd	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00100	3b 4d f0	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  00103	0f 85 1b 01 00
	00		 jne	 $L201031

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);

  00109	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  0010c	52		 push	 edx
  0010d	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00112	83 c4 04	 add	 esp, 4
  00115	8b 00		 mov	 eax, DWORD PTR [eax]
  00117	89 45 e4	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 613  : 			if (!_Isnil(_Fixnode))

  0011a	8b 4d ec	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00123	83 c4 04	 add	 esp, 4
  00126	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00129	85 d2		 test	 edx, edx
  0012b	75 11		 jne	 SHORT $L201032

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  0012d	8b 45 ec	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00136	83 c4 04	 add	 esp, 4
  00139	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  0013c	89 08		 mov	 DWORD PTR [eax], ecx
$L201032:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  0013e	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  00146	8b 10		 mov	 edx, DWORD PTR [eax]
  00148	3b 55 f0	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  0014b	75 0f		 jne	 SHORT $L201033

; 617  : 				_Root() = _Fixnode;	// link down from root

  0014d	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00150	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  00155	8b 4d ec	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00158	89 08		 mov	 DWORD PTR [eax], ecx

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  0015a	eb 37		 jmp	 SHORT $L201034
$L201033:
  0015c	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0015f	52		 push	 edx
  00160	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00165	83 c4 04	 add	 esp, 4
  00168	8b 00		 mov	 eax, DWORD PTR [eax]
  0016a	3b 45 f0	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  0016d	75 13		 jne	 SHORT $L201035

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0016f	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00178	83 c4 04	 add	 esp, 4
  0017b	8b 55 ec	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  0017e	89 10		 mov	 DWORD PTR [eax], edx

; 620  : 			else

  00180	eb 11		 jmp	 SHORT $L201034
$L201035:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  00182	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0018b	83 c4 04	 add	 esp, 4
  0018e	8b 4d ec	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00191	89 08		 mov	 DWORD PTR [eax], ecx
$L201034:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  00193	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00196	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lmost
  0019b	8b 10		 mov	 edx, DWORD PTR [eax]
  0019d	3b 55 f0	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  001a0	75 37		 jne	 SHORT $L201037

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  001a2	8b 45 ec	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  001ab	83 c4 04	 add	 esp, 4
  001ae	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001b1	85 c9		 test	 ecx, ecx
  001b3	74 08		 je	 SHORT $L202580
  001b5	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  001b8	89 55 98	 mov	 DWORD PTR tv165[ebp], edx
  001bb	eb 0f		 jmp	 SHORT $L202581
$L202580:
  001bd	8b 45 ec	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ?_Min@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Min
  001c6	83 c4 04	 add	 esp, 4
  001c9	89 45 98	 mov	 DWORD PTR tv165[ebp], eax
$L202581:
  001cc	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  001cf	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lmost
  001d4	8b 4d 98	 mov	 ecx, DWORD PTR tv165[ebp]
  001d7	89 08		 mov	 DWORD PTR [eax], ecx
$L201037:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  001d9	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  001dc	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
  001e1	8b 10		 mov	 edx, DWORD PTR [eax]
  001e3	3b 55 f0	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  001e6	75 37		 jne	 SHORT $L201038

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  001e8	8b 45 ec	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  001f1	83 c4 04	 add	 esp, 4
  001f4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001f7	85 c9		 test	 ecx, ecx
  001f9	74 08		 je	 SHORT $L202582
  001fb	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  001fe	89 55 94	 mov	 DWORD PTR tv177[ebp], edx
  00201	eb 0f		 jmp	 SHORT $L202583
$L202582:
  00203	8b 45 ec	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00206	50		 push	 eax
  00207	e8 00 00 00 00	 call	 ?_Max@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Max
  0020c	83 c4 04	 add	 esp, 4
  0020f	89 45 94	 mov	 DWORD PTR tv177[ebp], eax
$L202583:
  00212	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00215	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rmost
  0021a	8b 4d 94	 mov	 ecx, DWORD PTR tv177[ebp]
  0021d	89 08		 mov	 DWORD PTR [eax], ecx
$L201038:

; 632  : 			}
; 633  : 		else

  0021f	e9 8e 01 00 00	 jmp	 $L201039
$L201031:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  00224	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00227	52		 push	 edx
  00228	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  0022d	83 c4 04	 add	 esp, 4
  00230	8b 00		 mov	 eax, DWORD PTR [eax]
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00238	83 c4 04	 add	 esp, 4
  0023b	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0023e	89 08		 mov	 DWORD PTR [eax], ecx

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  00240	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00243	52		 push	 edx
  00244	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00249	83 c4 04	 add	 esp, 4
  0024c	8b f0		 mov	 esi, eax
  0024e	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00251	50		 push	 eax
  00252	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00257	83 c4 04	 add	 esp, 4
  0025a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0025c	89 08		 mov	 DWORD PTR [eax], ecx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  0025e	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00261	52		 push	 edx
  00262	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00267	83 c4 04	 add	 esp, 4
  0026a	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0026d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0026f	75 0b		 jne	 SHORT $L201040

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00271	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00274	89 55 e4	 mov	 DWORD PTR __Fixnodeparent$[ebp], edx

; 640  : 			else

  00277	e9 80 00 00 00	 jmp	 $L201041
$L201040:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

  0027c	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0027f	50		 push	 eax
  00280	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00285	83 c4 04	 add	 esp, 4
  00288	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028a	89 4d e4	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 643  : 				if (!_Isnil(_Fixnode))

  0028d	8b 55 ec	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  00290	52		 push	 edx
  00291	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00296	83 c4 04	 add	 esp, 4
  00299	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0029c	85 c0		 test	 eax, eax
  0029e	75 11		 jne	 SHORT $L201042

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  002a0	8b 4d ec	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  002a3	51		 push	 ecx
  002a4	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  002a9	83 c4 04	 add	 esp, 4
  002ac	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  002af	89 10		 mov	 DWORD PTR [eax], edx
$L201042:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  002b1	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  002b4	50		 push	 eax
  002b5	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  002ba	83 c4 04	 add	 esp, 4
  002bd	8b 4d ec	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  002c0	89 08		 mov	 DWORD PTR [eax], ecx

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  002c2	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  002c5	52		 push	 edx
  002c6	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  002cb	83 c4 04	 add	 esp, 4
  002ce	8b f0		 mov	 esi, eax
  002d0	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002d3	50		 push	 eax
  002d4	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  002d9	83 c4 04	 add	 esp, 4
  002dc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002de	89 08		 mov	 DWORD PTR [eax], ecx

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  002e0	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  002e3	52		 push	 edx
  002e4	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  002e9	83 c4 04	 add	 esp, 4
  002ec	8b 00		 mov	 eax, DWORD PTR [eax]
  002ee	50		 push	 eax
  002ef	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  002f4	83 c4 04	 add	 esp, 4
  002f7	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002fa	89 08		 mov	 DWORD PTR [eax], ecx
$L201041:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  002fc	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  002ff	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  00304	8b 10		 mov	 edx, DWORD PTR [eax]
  00306	3b 55 f0	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  00309	75 0f		 jne	 SHORT $L201043

; 651  : 				_Root() = _Pnode;	// link down from root

  0030b	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0030e	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  00313	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00316	89 08		 mov	 DWORD PTR [eax], ecx

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  00318	eb 58		 jmp	 SHORT $L201044
$L201043:
  0031a	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  0031d	52		 push	 edx
  0031e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00323	83 c4 04	 add	 esp, 4
  00326	8b 00		 mov	 eax, DWORD PTR [eax]
  00328	50		 push	 eax
  00329	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  0032e	83 c4 04	 add	 esp, 4
  00331	8b 08		 mov	 ecx, DWORD PTR [eax]
  00333	3b 4d f0	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  00336	75 1e		 jne	 SHORT $L201045

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  00338	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  0033b	52		 push	 edx
  0033c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00341	83 c4 04	 add	 esp, 4
  00344	8b 00		 mov	 eax, DWORD PTR [eax]
  00346	50		 push	 eax
  00347	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  0034c	83 c4 04	 add	 esp, 4
  0034f	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00352	89 08		 mov	 DWORD PTR [eax], ecx

; 654  : 			else

  00354	eb 1c		 jmp	 SHORT $L201044
$L201045:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  00356	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00359	52		 push	 edx
  0035a	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0035f	83 c4 04	 add	 esp, 4
  00362	8b 00		 mov	 eax, DWORD PTR [eax]
  00364	50		 push	 eax
  00365	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0036a	83 c4 04	 add	 esp, 4
  0036d	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00370	89 08		 mov	 DWORD PTR [eax], ecx
$L201044:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  00372	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00375	52		 push	 edx
  00376	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0037b	83 c4 04	 add	 esp, 4
  0037e	8b f0		 mov	 esi, eax
  00380	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00383	50		 push	 eax
  00384	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00389	83 c4 04	 add	 esp, 4
  0038c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0038e	89 08		 mov	 DWORD PTR [eax], ecx

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  00390	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00393	52		 push	 edx
  00394	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00399	83 c4 04	 add	 esp, 4
  0039c	50		 push	 eax
  0039d	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003a0	50		 push	 eax
  003a1	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  003a6	83 c4 04	 add	 esp, 4
  003a9	50		 push	 eax
  003aa	e8 00 00 00 00	 call	 ??$swap@D@std@@YAXAAD0@Z ; std::swap<char>
  003af	83 c4 08	 add	 esp, 8
$L201039:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  003b2	8b 4d f0	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  003b5	51		 push	 ecx
  003b6	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  003bb	83 c4 04	 add	 esp, 4
  003be	0f be 10	 movsx	 edx, BYTE PTR [eax]
  003c1	83 fa 01	 cmp	 edx, 1
  003c4	0f 85 8f 03 00
	00		 jne	 $L201047

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  003ca	eb 11		 jmp	 SHORT $L201048
$L201049:
  003cc	8b 45 ec	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  003cf	50		 push	 eax
  003d0	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  003d5	83 c4 04	 add	 esp, 4
  003d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  003da	89 4d e4	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx
$L201048:
  003dd	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  003e0	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  003e5	8b 55 ec	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  003e8	3b 10		 cmp	 edx, DWORD PTR [eax]
  003ea	0f 84 5a 03 00
	00		 je	 $L201050
  003f0	8b 45 ec	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  003f3	50		 push	 eax
  003f4	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  003f9	83 c4 04	 add	 esp, 4
  003fc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003ff	83 f9 01	 cmp	 ecx, 1
  00402	0f 85 42 03 00
	00		 jne	 $L201050

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00408	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0040b	52		 push	 edx
  0040c	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00411	83 c4 04	 add	 esp, 4
  00414	8b 4d ec	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00417	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00419	0f 85 97 01 00
	00		 jne	 $L201051

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  0041f	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00422	52		 push	 edx
  00423	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00428	83 c4 04	 add	 esp, 4
  0042b	8b 00		 mov	 eax, DWORD PTR [eax]
  0042d	89 45 e8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 668  : 					if (_Color(_Pnode) == _Red)

  00430	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00433	51		 push	 ecx
  00434	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00439	83 c4 04	 add	 esp, 4
  0043c	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0043f	85 d2		 test	 edx, edx
  00441	75 3b		 jne	 SHORT $L201052

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;

  00443	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00446	50		 push	 eax
  00447	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  0044c	83 c4 04	 add	 esp, 4
  0044f	c6 00 01	 mov	 BYTE PTR [eax], 1

; 671  : 						_Color(_Fixnodeparent) = _Red;

  00452	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00455	51		 push	 ecx
  00456	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  0045b	83 c4 04	 add	 esp, 4
  0045e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 672  : 						_Lrotate(_Fixnodeparent);

  00461	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00464	52		 push	 edx
  00465	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00468	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  0046d	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00470	50		 push	 eax
  00471	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00476	83 c4 04	 add	 esp, 4
  00479	8b 08		 mov	 ecx, DWORD PTR [eax]
  0047b	89 4d e8	 mov	 DWORD PTR __Pnode$[ebp], ecx
$L201052:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  0047e	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00481	52		 push	 edx
  00482	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00487	83 c4 04	 add	 esp, 4
  0048a	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0048d	85 c0		 test	 eax, eax
  0048f	74 0b		 je	 SHORT $L201053

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00491	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00494	89 4d ec	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  00497	e9 15 01 00 00	 jmp	 $L201054
$L201053:

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  0049c	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0049f	52		 push	 edx
  004a0	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  004a5	83 c4 04	 add	 esp, 4
  004a8	8b 00		 mov	 eax, DWORD PTR [eax]
  004aa	50		 push	 eax
  004ab	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  004b0	83 c4 04	 add	 esp, 4
  004b3	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  004b6	83 f9 01	 cmp	 ecx, 1
  004b9	75 39		 jne	 SHORT $L201055
  004bb	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  004be	52		 push	 edx
  004bf	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  004c4	83 c4 04	 add	 esp, 4
  004c7	8b 00		 mov	 eax, DWORD PTR [eax]
  004c9	50		 push	 eax
  004ca	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  004cf	83 c4 04	 add	 esp, 4
  004d2	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  004d5	83 f9 01	 cmp	 ecx, 1
  004d8	75 1a		 jne	 SHORT $L201055

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;

  004da	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  004dd	52		 push	 edx
  004de	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  004e3	83 c4 04	 add	 esp, 4
  004e6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 682  : 						_Fixnode = _Fixnodeparent;

  004e9	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  004ec	89 45 ec	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 683  : 						}
; 684  : 					else

  004ef	e9 bd 00 00 00	 jmp	 $L201054
$L201055:

; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  004f4	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  004f7	51		 push	 ecx
  004f8	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  004fd	83 c4 04	 add	 esp, 4
  00500	8b 10		 mov	 edx, DWORD PTR [eax]
  00502	52		 push	 edx
  00503	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00508	83 c4 04	 add	 esp, 4
  0050b	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0050e	83 f8 01	 cmp	 eax, 1
  00511	75 46		 jne	 SHORT $L201057

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  00513	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00516	51		 push	 ecx
  00517	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  0051c	83 c4 04	 add	 esp, 4
  0051f	8b 10		 mov	 edx, DWORD PTR [eax]
  00521	52		 push	 edx
  00522	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00527	83 c4 04	 add	 esp, 4
  0052a	c6 00 01	 mov	 BYTE PTR [eax], 1

; 689  : 							_Color(_Pnode) = _Red;

  0052d	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00530	50		 push	 eax
  00531	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00536	83 c4 04	 add	 esp, 4
  00539	c6 00 00	 mov	 BYTE PTR [eax], 0

; 690  : 							_Rrotate(_Pnode);

  0053c	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0053f	51		 push	 ecx
  00540	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00543	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  00548	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0054b	52		 push	 edx
  0054c	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00551	83 c4 04	 add	 esp, 4
  00554	8b 00		 mov	 eax, DWORD PTR [eax]
  00556	89 45 e8	 mov	 DWORD PTR __Pnode$[ebp], eax
$L201057:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00559	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  0055c	51		 push	 ecx
  0055d	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00562	83 c4 04	 add	 esp, 4
  00565	8b f0		 mov	 esi, eax
  00567	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0056a	52		 push	 edx
  0056b	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00570	83 c4 04	 add	 esp, 4
  00573	8a 0e		 mov	 cl, BYTE PTR [esi]
  00575	88 08		 mov	 BYTE PTR [eax], cl

; 695  : 						_Color(_Fixnodeparent) = _Black;

  00577	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0057a	52		 push	 edx
  0057b	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00580	83 c4 04	 add	 esp, 4
  00583	c6 00 01	 mov	 BYTE PTR [eax], 1

; 696  : 						_Color(_Right(_Pnode)) = _Black;

  00586	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00589	50		 push	 eax
  0058a	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0058f	83 c4 04	 add	 esp, 4
  00592	8b 08		 mov	 ecx, DWORD PTR [eax]
  00594	51		 push	 ecx
  00595	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  0059a	83 c4 04	 add	 esp, 4
  0059d	c6 00 01	 mov	 BYTE PTR [eax], 1

; 697  : 						_Lrotate(_Fixnodeparent);

  005a0	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  005a3	52		 push	 edx
  005a4	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  005a7	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  005ac	e9 99 01 00 00	 jmp	 $L201050
$L201054:

; 699  : 						}
; 700  : 					}
; 701  : 				else

  005b1	e9 8f 01 00 00	 jmp	 $L201058
$L201051:

; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);

  005b6	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005b9	50		 push	 eax
  005ba	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  005bf	83 c4 04	 add	 esp, 4
  005c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  005c4	89 4d e8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 704  : 					if (_Color(_Pnode) == _Red)

  005c7	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  005ca	52		 push	 edx
  005cb	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  005d0	83 c4 04	 add	 esp, 4
  005d3	0f be 00	 movsx	 eax, BYTE PTR [eax]
  005d6	85 c0		 test	 eax, eax
  005d8	75 3b		 jne	 SHORT $L201059

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;

  005da	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  005dd	51		 push	 ecx
  005de	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  005e3	83 c4 04	 add	 esp, 4
  005e6	c6 00 01	 mov	 BYTE PTR [eax], 1

; 707  : 						_Color(_Fixnodeparent) = _Red;

  005e9	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  005ec	52		 push	 edx
  005ed	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  005f2	83 c4 04	 add	 esp, 4
  005f5	c6 00 00	 mov	 BYTE PTR [eax], 0

; 708  : 						_Rrotate(_Fixnodeparent);

  005f8	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005fb	50		 push	 eax
  005fc	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  005ff	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  00604	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00607	51		 push	 ecx
  00608	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  0060d	83 c4 04	 add	 esp, 4
  00610	8b 10		 mov	 edx, DWORD PTR [eax]
  00612	89 55 e8	 mov	 DWORD PTR __Pnode$[ebp], edx
$L201059:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  00615	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00618	50		 push	 eax
  00619	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  0061e	83 c4 04	 add	 esp, 4
  00621	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00624	85 c9		 test	 ecx, ecx
  00626	74 0b		 je	 SHORT $L201060

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00628	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0062b	89 55 ec	 mov	 DWORD PTR __Fixnode$[ebp], edx

; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  0062e	e9 12 01 00 00	 jmp	 $L201058
$L201060:

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  00633	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00636	50		 push	 eax
  00637	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0063c	83 c4 04	 add	 esp, 4
  0063f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00641	51		 push	 ecx
  00642	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00647	83 c4 04	 add	 esp, 4
  0064a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0064d	83 fa 01	 cmp	 edx, 1
  00650	75 39		 jne	 SHORT $L201062
  00652	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00655	50		 push	 eax
  00656	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  0065b	83 c4 04	 add	 esp, 4
  0065e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00660	51		 push	 ecx
  00661	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00666	83 c4 04	 add	 esp, 4
  00669	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0066c	83 fa 01	 cmp	 edx, 1
  0066f	75 1a		 jne	 SHORT $L201062

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  00671	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00674	50		 push	 eax
  00675	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  0067a	83 c4 04	 add	 esp, 4
  0067d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 717  : 						_Fixnode = _Fixnodeparent;

  00680	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00683	89 4d ec	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 718  : 						}
; 719  : 					else

  00686	e9 ba 00 00 00	 jmp	 $L201058
$L201062:

; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  0068b	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0068e	52		 push	 edx
  0068f	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00694	83 c4 04	 add	 esp, 4
  00697	8b 00		 mov	 eax, DWORD PTR [eax]
  00699	50		 push	 eax
  0069a	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  0069f	83 c4 04	 add	 esp, 4
  006a2	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  006a5	83 f9 01	 cmp	 ecx, 1
  006a8	75 46		 jne	 SHORT $L201064

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  006aa	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  006ad	52		 push	 edx
  006ae	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  006b3	83 c4 04	 add	 esp, 4
  006b6	8b 00		 mov	 eax, DWORD PTR [eax]
  006b8	50		 push	 eax
  006b9	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  006be	83 c4 04	 add	 esp, 4
  006c1	c6 00 01	 mov	 BYTE PTR [eax], 1

; 724  : 							_Color(_Pnode) = _Red;

  006c4	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  006c7	51		 push	 ecx
  006c8	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  006cd	83 c4 04	 add	 esp, 4
  006d0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 725  : 							_Lrotate(_Pnode);

  006d3	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  006d6	52		 push	 edx
  006d7	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  006da	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  006df	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006e2	50		 push	 eax
  006e3	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  006e8	83 c4 04	 add	 esp, 4
  006eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  006ed	89 4d e8	 mov	 DWORD PTR __Pnode$[ebp], ecx
$L201064:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  006f0	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  006f3	52		 push	 edx
  006f4	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  006f9	83 c4 04	 add	 esp, 4
  006fc	8b f0		 mov	 esi, eax
  006fe	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00701	50		 push	 eax
  00702	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00707	83 c4 04	 add	 esp, 4
  0070a	8a 0e		 mov	 cl, BYTE PTR [esi]
  0070c	88 08		 mov	 BYTE PTR [eax], cl

; 730  : 						_Color(_Fixnodeparent) = _Black;

  0070e	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00711	52		 push	 edx
  00712	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00717	83 c4 04	 add	 esp, 4
  0071a	c6 00 01	 mov	 BYTE PTR [eax], 1

; 731  : 						_Color(_Left(_Pnode)) = _Black;

  0071d	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00720	50		 push	 eax
  00721	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00726	83 c4 04	 add	 esp, 4
  00729	8b 08		 mov	 ecx, DWORD PTR [eax]
  0072b	51		 push	 ecx
  0072c	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00731	83 c4 04	 add	 esp, 4
  00734	c6 00 01	 mov	 BYTE PTR [eax], 1

; 732  : 						_Rrotate(_Fixnodeparent);

  00737	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0073a	52		 push	 edx
  0073b	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0073e	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rrotate

; 733  : 						break;	// tree now recolored/rebalanced

  00743	eb 05		 jmp	 SHORT $L201050
$L201058:

; 734  : 						}
; 735  : 					}

  00745	e9 82 fc ff ff	 jmp	 $L201049
$L201050:

; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0074a	8b 45 ec	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0074d	50		 push	 eax
  0074e	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00753	83 c4 04	 add	 esp, 4
  00756	c6 00 01	 mov	 BYTE PTR [eax], 1
$L201047:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

  00759	8b 4d f0	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  0075c	51		 push	 ecx
  0075d	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00760	83 c1 01	 add	 ecx, 1
  00763	e8 00 00 00 00	 call	 ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::destroy

; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00768	6a 01		 push	 1
  0076a	8b 55 f0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  0076d	52		 push	 edx
  0076e	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00771	83 c1 01	 add	 ecx, 1
  00774	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::deallocate

; 742  : 
; 743  : 		if (0 < _Mysize)

  00779	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  0077c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00780	76 0f		 jbe	 SHORT $L201065

; 744  : 			--_Mysize;

  00782	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00785	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00788	83 ea 01	 sub	 edx, 1
  0078b	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  0078e	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L201065:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  00791	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00794	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]
  00797	89 11		 mov	 DWORD PTR [ecx], edx
  00799	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L202577:

; 747  : 		}

  0079c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0079f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  007a6	5e		 pop	 esi
  007a7	8b e5		 mov	 esp, ebp
  007a9	5d		 pop	 ebp
  007aa	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202584:
  00000	8d 4d a0	 lea	 ecx, DWORD PTR $T202579[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202586
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::erase
; Function compile flags: /Odt
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1014 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  0000a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00013	83 c4 04	 add	 esp, 4
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  0001b	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00024	83 c4 04	 add	 esp, 4
  00027	8b f0		 mov	 esi, eax
  00029	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00032	83 c4 04	 add	 esp, 4
  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	89 08		 mov	 DWORD PTR [eax], ecx

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  00039	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00042	83 c4 04	 add	 esp, 4
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  0004d	83 c4 04	 add	 esp, 4
  00050	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00053	85 c9		 test	 ecx, ecx
  00055	75 1c		 jne	 SHORT $L201069

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00057	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00060	83 c4 04	 add	 esp, 4
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0006b	83 c4 04	 add	 esp, 4
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00071	89 08		 mov	 DWORD PTR [eax], ecx
$L201069:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00073	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0007c	83 c4 04	 add	 esp, 4
  0007f	8b f0		 mov	 esi, eax
  00081	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0008a	83 c4 04	 add	 esp, 4
  0008d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008f	89 08		 mov	 DWORD PTR [eax], ecx

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00091	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  00099	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0009c	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009e	75 0f		 jne	 SHORT $L201070

; 1023 : 			_Root() = _Pnode;

  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ab	89 08		 mov	 DWORD PTR [eax], ecx

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  000ad	eb 58		 jmp	 SHORT $L201071
$L201070:
  000af	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  000b8	83 c4 04	 add	 esp, 4
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  000c3	83 c4 04	 add	 esp, 4
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000c9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000cb	75 1e		 jne	 SHORT $L201072

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  000cd	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  000d6	83 c4 04	 add	 esp, 4
  000d9	8b 00		 mov	 eax, DWORD PTR [eax]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  000e1	83 c4 04	 add	 esp, 4
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000e7	89 08		 mov	 DWORD PTR [eax], ecx

; 1026 : 		else

  000e9	eb 1c		 jmp	 SHORT $L201071
$L201072:

; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  000eb	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  000f4	83 c4 04	 add	 esp, 4
  000f7	8b 00		 mov	 eax, DWORD PTR [eax]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  000ff	83 c4 04	 add	 esp, 4
  00102	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00105	89 08		 mov	 DWORD PTR [eax], ecx
$L201071:

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  00107	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00110	83 c4 04	 add	 esp, 4
  00113	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00116	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  00118	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0011b	52		 push	 edx
  0011c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00121	83 c4 04	 add	 esp, 4
  00124	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00127	89 08		 mov	 DWORD PTR [eax], ecx

; 1031 : 		}

  00129	5e		 pop	 esi
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Lrotate
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1063 : 		{	// return root of nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1064 : 		return (_Parent(_Myhead));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00013	83 c4 04	 add	 esp, 4

; 1065 : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1068 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  0000a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00013	83 c4 04	 add	 esp, 4
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  0001b	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00024	83 c4 04	 add	 esp, 4
  00027	8b f0		 mov	 esi, eax
  00029	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00032	83 c4 04	 add	 esp, 4
  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	89 08		 mov	 DWORD PTR [eax], ecx

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  00039	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00042	83 c4 04	 add	 esp, 4
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  0004d	83 c4 04	 add	 esp, 4
  00050	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00053	85 c9		 test	 ecx, ecx
  00055	75 1c		 jne	 SHORT $L201079

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00057	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00060	83 c4 04	 add	 esp, 4
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0006b	83 c4 04	 add	 esp, 4
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00071	89 08		 mov	 DWORD PTR [eax], ecx
$L201079:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00073	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0007c	83 c4 04	 add	 esp, 4
  0007f	8b f0		 mov	 esi, eax
  00081	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0008a	83 c4 04	 add	 esp, 4
  0008d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008f	89 08		 mov	 DWORD PTR [eax], ecx

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00091	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  00099	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0009c	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009e	75 0f		 jne	 SHORT $L201080

; 1077 : 			_Root() = _Pnode;

  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Root
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ab	89 08		 mov	 DWORD PTR [eax], ecx

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  000ad	eb 58		 jmp	 SHORT $L201081
$L201080:
  000af	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  000b8	83 c4 04	 add	 esp, 4
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  000c3	83 c4 04	 add	 esp, 4
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000c9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000cb	75 1e		 jne	 SHORT $L201082

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  000cd	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  000d6	83 c4 04	 add	 esp, 4
  000d9	8b 00		 mov	 eax, DWORD PTR [eax]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  000e1	83 c4 04	 add	 esp, 4
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000e7	89 08		 mov	 DWORD PTR [eax], ecx

; 1080 : 		else

  000e9	eb 1c		 jmp	 SHORT $L201081
$L201082:

; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  000eb	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  000f4	83 c4 04	 add	 esp, 4
  000f7	8b 00		 mov	 eax, DWORD PTR [eax]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  000ff	83 c4 04	 add	 esp, 4
  00102	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00105	89 08		 mov	 DWORD PTR [eax], ecx
$L201081:

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00107	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00110	83 c4 04	 add	 esp, 4
  00113	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00116	89 08		 mov	 DWORD PTR [eax], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  00118	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0011b	52		 push	 edx
  0011c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00121	83 c4 04	 add	 esp, 4
  00124	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00127	89 08		 mov	 DWORD PTR [eax], ecx

; 1085 : 		}

  00129	5e		 pop	 esi
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::allocate
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202607 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T202609 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L202603
$T202608 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T202609
$T202605 DD	019930520H
	DD	02H
	DD	FLAT:$T202607
	DD	01H
	DD	FLAT:$T202608
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
tv145 = -52						; size = 4
tv144 = -48						; size = 4
tv143 = -44						; size = 4
_this$ = -40						; size = 4
$T202601 = -36						; size = 4
$T202600 = -32						; size = 4
$T202599 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1105 : 		{	// allocate a head/nil node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 24	 sub	 esp, 36			; 00000024H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00025	6a 01		 push	 1
  00027	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 c1 01	 add	 ecx, 1
  0002d	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::allocate
  00032	89 45 e8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1107 : 		int _Linkcnt = 0;

  00035	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Linkcnt$[ebp], 0

; 1108 : 
; 1109 : 		_TRY_BEGIN

  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  00043	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T202599[ebp], 0
  0004a	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00053	83 c4 04	 add	 esp, 4
  00056	89 45 d4	 mov	 DWORD PTR tv143[ebp], eax
  00059	8d 4d e4	 lea	 ecx, DWORD PTR $T202599[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 d4	 mov	 edx, DWORD PTR tv143[ebp]
  00060	52		 push	 edx
  00061	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	83 c1 02	 add	 ecx, 2
  00067	e8 00 00 00 00	 call	 ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::construct

; 1111 : 		++_Linkcnt;

  0006c	8b 45 ec	 mov	 eax, DWORD PTR __Linkcnt$[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 ec	 mov	 DWORD PTR __Linkcnt$[ebp], eax

; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00075	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T202600[ebp], 0
  0007c	8b 4d e8	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00085	83 c4 04	 add	 esp, 4
  00088	89 45 d0	 mov	 DWORD PTR tv144[ebp], eax
  0008b	8d 55 e0	 lea	 edx, DWORD PTR $T202600[ebp]
  0008e	52		 push	 edx
  0008f	8b 45 d0	 mov	 eax, DWORD PTR tv144[ebp]
  00092	50		 push	 eax
  00093	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	83 c1 02	 add	 ecx, 2
  00099	e8 00 00 00 00	 call	 ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::construct

; 1113 : 		++_Linkcnt;

  0009e	8b 4d ec	 mov	 ecx, DWORD PTR __Linkcnt$[ebp]
  000a1	83 c1 01	 add	 ecx, 1
  000a4	89 4d ec	 mov	 DWORD PTR __Linkcnt$[ebp], ecx

; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  000a7	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T202601[ebp], 0
  000ae	8b 55 e8	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  000b7	83 c4 04	 add	 esp, 4
  000ba	89 45 cc	 mov	 DWORD PTR tv145[ebp], eax
  000bd	8d 45 dc	 lea	 eax, DWORD PTR $T202601[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d cc	 mov	 ecx, DWORD PTR tv145[ebp]
  000c4	51		 push	 ecx
  000c5	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	83 c1 02	 add	 ecx, 2
  000cb	e8 00 00 00 00	 call	 ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::construct
  000d0	eb 56		 jmp	 SHORT $L202602
$L202603:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)

  000d2	83 7d ec 01	 cmp	 DWORD PTR __Linkcnt$[ebp], 1
  000d6	7e 18		 jle	 SHORT $L201092

; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

  000d8	8b 55 e8	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  000e1	83 c4 04	 add	 esp, 4
  000e4	50		 push	 eax
  000e5	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	83 c1 02	 add	 ecx, 2
  000eb	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::destroy
$L201092:

; 1118 : 		if (0 < _Linkcnt)

  000f0	83 7d ec 00	 cmp	 DWORD PTR __Linkcnt$[ebp], 0
  000f4	7e 18		 jle	 SHORT $L201093

; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));

  000f6	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  000ff	83 c4 04	 add	 esp, 4
  00102	50		 push	 eax
  00103	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	83 c1 02	 add	 ecx, 2
  00109	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::destroy
$L201093:

; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);

  0010e	6a 01		 push	 1
  00110	8b 4d e8	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00113	51		 push	 ecx
  00114	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	83 c1 01	 add	 ecx, 1
  0011a	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::deallocate

; 1121 : 		_RERAISE;

  0011f	6a 00		 push	 0
  00121	6a 00		 push	 0
  00123	e8 00 00 00 00	 call	 __CxxThrowException@8
$L202602:

; 1122 : 		_CATCH_END

  00128	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1123 : 		_Color(_Wherenode) = _Black;

  0012f	8b 55 e8	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00132	52		 push	 edx
  00133	e8 00 00 00 00	 call	 ?_Color@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Color
  00138	83 c4 04	 add	 esp, 4
  0013b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  0013e	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00147	83 c4 04	 add	 esp, 4
  0014a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1125 : 		return (_Wherenode);

  0014d	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
$L202598:

; 1126 : 		}

  00150	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00153	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202605
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Buynode
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node::_Node
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202624 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L202620
	DD	0ffffffffH
	DD	00H
$T202626 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L202619
$T202625 DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T202626
$T202622 DD	019930520H
	DD	03H
	DD	FLAT:$T202624
	DD	01H
	DD	FLAT:$T202625
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z
_TEXT	SEGMENT
tv82 = -44						; size = 4
tv94 = -40						; size = 4
tv91 = -36						; size = 4
_this$ = -32						; size = 4
$T202615 = -28						; size = 4
$T202614 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1130 : 		{	// allocate a node with pointers, value, and color

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00025	6a 01		 push	 1
  00027	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 c1 01	 add	 ecx, 1
  0002d	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::allocate
  00032	89 45 ec	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1132 : 		_TRY_BEGIN

  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0003c	8b 45 ec	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0003f	50		 push	 eax
  00040	6a 60		 push	 96			; 00000060H
  00042	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00047	83 c4 08	 add	 esp, 8
  0004a	89 45 dc	 mov	 DWORD PTR tv91[ebp], eax
  0004d	8b 4d dc	 mov	 ecx, DWORD PTR tv91[ebp]
  00050	89 4d e4	 mov	 DWORD PTR $T202615[ebp], ecx
  00053	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00057	83 7d e4 00	 cmp	 DWORD PTR $T202615[ebp], 0
  0005b	74 27		 je	 SHORT $L202616
  0005d	8a 55 18	 mov	 dl, BYTE PTR __Carg$[ebp]
  00060	52		 push	 edx
  00061	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00064	50		 push	 eax
  00065	8b 4d 10	 mov	 ecx, DWORD PTR __Rarg$[ebp]
  00068	51		 push	 ecx
  00069	8b 55 0c	 mov	 edx, DWORD PTR __Parg$[ebp]
  0006c	52		 push	 edx
  0006d	8b 45 08	 mov	 eax, DWORD PTR __Larg$[ebp]
  00070	50		 push	 eax
  00071	8b 4d e4	 mov	 ecx, DWORD PTR $T202615[ebp]
  00074	e8 00 00 00 00	 call	 ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node::_Node
  00079	89 45 d8	 mov	 DWORD PTR tv94[ebp], eax
  0007c	8b 4d d8	 mov	 ecx, DWORD PTR tv94[ebp]
  0007f	89 4d d4	 mov	 DWORD PTR tv82[ebp], ecx
  00082	eb 07		 jmp	 SHORT $L202617
$L202616:
  00084	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$L202617:
  0008b	8b 55 d4	 mov	 edx, DWORD PTR tv82[ebp]
  0008e	89 55 e8	 mov	 DWORD PTR $T202614[ebp], edx
  00091	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00095	eb 1a		 jmp	 SHORT $L202618
$L202619:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);

  00097	6a 01		 push	 1
  00099	8b 45 ec	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	83 c1 01	 add	 ecx, 1
  000a3	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::deallocate

; 1136 : 		_RERAISE;

  000a8	6a 00		 push	 0
  000aa	6a 00		 push	 0
  000ac	e8 00 00 00 00	 call	 __CxxThrowException@8
$L202618:

; 1137 : 		_CATCH_END

  000b1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1138 : 		return (_Wherenode);

  000b8	8b 45 ec	 mov	 eax, DWORD PTR __Wherenode$[ebp]
$L202613:

; 1139 : 		}

  000bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202620:
  00000	8b 45 ec	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00003	50		 push	 eax
  00004	8b 4d e4	 mov	 ecx, DWORD PTR $T202615[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202622
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Buynode
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
PUBLIC	??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *><std::pair<int const ,MYLIST_COLUMN_INFO> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_ptr<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >, COMDAT
; _this$ = ecx

; 76   : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00018	51		 push	 ecx
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
  00021	8d 55 0c	 lea	 edx, DWORD PTR __Al$[ebp]
  00024	52		 push	 edx
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 c1 02	 add	 ecx, 2
  0002b	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *><std::pair<int const ,MYLIST_COLUMN_INFO> >

; 77   : 		}

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
??0?$_Tree_ptr@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_ptr<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@H@std@@QBEIXZ PROC NEAR		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc ff ff
	ff 3f		 mov	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L202638
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L202639
$L202638:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L202639:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 193  : 			{	// construct with null node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 194  : 			}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Dec
; Function compile flags: /Odt
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 227  : 			{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 228  : 			_Dec();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 230  : 			}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::operator--
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$201124 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 267  : 			{	// move to node with next larger value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 268  : 			if (_Isnil(_Ptr))

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00014	83 c4 04	 add	 esp, 4
  00017	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001a	85 d2		 test	 edx, edx
  0001c	74 05		 je	 SHORT $L201120

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  0001e	e9 8d 00 00 00	 jmp	 $L201119
$L201120:
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00039	83 c4 04	 add	 esp, 4
  0003c	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0003f	85 c0		 test	 eax, eax
  00041	75 20		 jne	 SHORT $L201126

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 11		 mov	 edx, DWORD PTR [ecx]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?_Min@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Min
  00059	83 c4 04	 add	 esp, 4
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	89 01		 mov	 DWORD PTR [ecx], eax

; 272  : 			else

  00061	eb 4d		 jmp	 SHORT $L201119
$L201126:

; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  00063	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 02		 mov	 eax, DWORD PTR [edx]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d fc	 mov	 DWORD PTR __Pnode$201124[ebp], ecx
  00076	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$201124[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  0007f	83 c4 04	 add	 esp, 4
  00082	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00085	85 c0		 test	 eax, eax
  00087	75 1f		 jne	 SHORT $L201127
  00089	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$201124[ebp]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00092	83 c4 04	 add	 esp, 4
  00095	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00098	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0009a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0009c	75 0a		 jne	 SHORT $L201127

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  0009e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$201124[ebp]
  000a4	89 02		 mov	 DWORD PTR [edx], eax
  000a6	eb bb		 jmp	 SHORT $L201126
$L201127:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$201124[ebp]
  000ae	89 11		 mov	 DWORD PTR [ecx], edx
$L201119:

; 279  : 				}
; 280  : 			}

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Inc
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 34   : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0000f	89 0a		 mov	 DWORD PTR [edx], ecx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00017	8a 11		 mov	 dl, BYTE PTR [ecx]
  00019	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 35   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::iterator,bool>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Max, COMDAT

; 1034 : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L201132:

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0000c	83 c4 04	 add	 esp, 4
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	75 13		 jne	 SHORT $L201133

; 1036 : 			_Pnode = _Right(_Pnode);

  00021	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00032	eb cf		 jmp	 SHORT $L201132
$L201133:

; 1037 : 		return (_Pnode);

  00034	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 1038 : 		}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Max
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Min, COMDAT

; 1041 : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L201136:

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  0000c	83 c4 04	 add	 esp, 4
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	75 13		 jne	 SHORT $L201137

; 1043 : 			_Pnode = _Left(_Pnode);

  00021	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00032	eb cf		 jmp	 SHORT $L201136
$L201137:

; 1044 : 		return (_Pnode);

  00034	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 1045 : 		}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Min
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node><std::pair<int const ,MYLIST_COLUMN_INFO> >
PUBLIC	??0?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>
; Function compile flags: /Odt
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >, COMDAT
; _this$ = ecx

; 54   : 		{	// construct traits from _Parg and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  0000a	8a 08		 mov	 cl, BYTE PTR [eax]
  0000c	51		 push	 ecx
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>
  00015	8d 55 0c	 lea	 edx, DWORD PTR __Al$[ebp]
  00018	52		 push	 edx
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	83 c1 01	 add	 ecx, 1
  0001f	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node><std::pair<int const ,MYLIST_COLUMN_INFO> >

; 55   : 		}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc 33 33
	33 03		 mov	 DWORD PTR __Count$[ebp], 53687091 ; 03333333H

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L202656
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L202657
$L202656:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L202657:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>
; Function compile flags: /Odt
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::construct
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$201170 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 250  : 			{	// move to node with next smaller value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 251  : 			if (_Isnil(_Ptr))

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00014	83 c4 04	 add	 esp, 4
  00017	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001a	85 d2		 test	 edx, edx
  0001c	74 1a		 je	 SHORT $L201166

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?_Right@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Right
  00029	83 c4 04	 add	 esp, 4
  0002c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	89 02		 mov	 DWORD PTR [edx], eax

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  00033	e9 a0 00 00 00	 jmp	 $L201165
$L201166:
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00043	83 c4 04	 add	 esp, 4
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  0004e	83 c4 04	 add	 esp, 4
  00051	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00054	85 c9		 test	 ecx, ecx
  00056	75 20		 jne	 SHORT $L201172

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00058	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 02		 mov	 eax, DWORD PTR [edx]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  00063	83 c4 04	 add	 esp, 4
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ?_Max@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Max
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00074	89 02		 mov	 DWORD PTR [edx], eax

; 255  : 			else

  00076	eb 60		 jmp	 SHORT $L201165
$L201172:

; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00078	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Parent
  00083	83 c4 04	 add	 esp, 4
  00086	8b 10		 mov	 edx, DWORD PTR [eax]
  00088	89 55 fc	 mov	 DWORD PTR __Pnode$201170[ebp], edx
  0008b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$201170[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  00094	83 c4 04	 add	 esp, 4
  00097	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009a	85 c9		 test	 ecx, ecx
  0009c	75 1f		 jne	 SHORT $L201173
  0009e	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$201170[ebp]
  000a1	52		 push	 edx
  000a2	e8 00 00 00 00	 call	 ?_Left@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Left
  000a7	83 c4 04	 add	 esp, 4
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  000af	3b 10		 cmp	 edx, DWORD PTR [eax]
  000b1	75 0a		 jne	 SHORT $L201173

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$201170[ebp]
  000b9	89 08		 mov	 DWORD PTR [eax], ecx
  000bb	eb bb		 jmp	 SHORT $L201172
$L201173:

; 261  : 				if (!_Isnil(_Pnode))

  000bd	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$201170[ebp]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Isnil
  000c6	83 c4 04	 add	 esp, 4
  000c9	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000cc	85 c0		 test	 eax, eax
  000ce	75 08		 jne	 SHORT $L201165

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  000d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$201170[ebp]
  000d6	89 11		 mov	 DWORD PTR [ecx], edx
$L201165:

; 263  : 				}
; 264  : 			}

  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABU01@@Z ; std::pair<int const ,MYLIST_COLUMN_INFO>::pair<int const ,MYLIST_COLUMN_INFO>
; Function compile flags: /Odt
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 40   : 			{	// construct a node with value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Larg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Parg$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR __Rarg$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00024	50		 push	 eax
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0002b	e8 00 00 00 00	 call	 ??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABU01@@Z
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8a 55 18	 mov	 dl, BYTE PTR __Carg$[ebp]
  00036	88 51 5c	 mov	 BYTE PTR [ecx+92], dl
  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c6 40 5d 00	 mov	 BYTE PTR [eax+93], 0

; 41   : 			}

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 14 00	 ret	 20			; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHUMYLIST_COLUMN_INFO@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node::_Node
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABU01@@Z PROC NEAR ; std::pair<int const ,MYLIST_COLUMN_INFO>::pair<int const ,MYLIST_COLUMN_INFO>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00014	83 c0 04	 add	 eax, 4
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 04	 add	 ecx, 4
  0001e	e8 00 00 00 00	 call	 ??0MYLIST_COLUMN_INFO@@QAE@ABU0@@Z
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??0?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@ABU01@@Z ENDP ; std::pair<int const ,MYLIST_COLUMN_INFO>::pair<int const ,MYLIST_COLUMN_INFO>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC NEAR ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with specified comparator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 39   : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0>
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
PUBLIC	??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::iterator::operator++
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\algorithm
;	COMDAT ??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z PROC NEAR ; std::find<std::vector<int,std::allocator<int> >::iterator,int>, COMDAT

; 29   : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 	for (; _First != _Last; ++_First)

  00003	eb 08		 jmp	 SHORT $L201197
$L201198:
  00005	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00008	e8 00 00 00 00	 call	 ??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::iterator::operator++
$L201197:
  0000d	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00010	50		 push	 eax
  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator!=
  00019	0f b6 c8	 movzx	 ecx, al
  0001c	85 c9		 test	 ecx, ecx
  0001e	74 15		 je	 SHORT $L201199

; 31   : 		if (*_First == _Val)

  00020	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00023	e8 00 00 00 00	 call	 ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
  00028	8b 55 14	 mov	 edx, DWORD PTR __Val$[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	3b 02		 cmp	 eax, DWORD PTR [edx]
  0002f	75 02		 jne	 SHORT $L201200

; 32   : 			break;

  00031	eb 02		 jmp	 SHORT $L201199
$L201200:

; 33   : 	return (_First);

  00033	eb d0		 jmp	 SHORT $L201198
$L201199:
  00035	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00038	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	89 11		 mov	 DWORD PTR [ecx], edx
  0003d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 34   : 	}

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z ENDP ; std::find<std::vector<int,std::allocator<int> >::iterator,int>
_TEXT	ENDS
PUBLIC	??0?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@AAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::back_insert_iterator<std::vector<int,std::allocator<int> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
;	COMDAT ??$back_inserter@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Cont$ = 12						; size = 4
??$back_inserter@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z PROC NEAR ; std::back_inserter<std::vector<int,std::allocator<int> > >, COMDAT

; 55   : 	{	// return a back_insert_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   : 	return (std::back_insert_iterator<_Container>(_Cont));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Cont$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@AAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::back_insert_iterator<std::vector<int,std::allocator<int> > >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 57   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$back_inserter@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::back_inserter<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@HV?$allocator@H@std@@@0@AAV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Ptr_cat<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$_Copy_opt@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T202678 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$copy@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@@Z PROC NEAR ; std::copy<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1039 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00004	8d 45 14	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@HV?$allocator@H@std@@@0@AAV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Ptr_cat<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T202678[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T202678[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Copy_opt@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >
  00030	83 c4 14	 add	 esp, 20			; 00000014H
  00033	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1041 : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$copy@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@@Z ENDP ; std::copy<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
PUBLIC	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEPAXI@Z ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00003	6a 00		 push	 0
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEPAXI@Z

; 50   : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Odt
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC NEAR		; std::_Allocate<int>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
PUBLIC	?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
; Function compile flags: /Odt
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T202687 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC NEAR ; std::_Destroy_range<int,std::allocator<int> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T202687[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T202687[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<int,std::allocator<int> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *><std::pair<int const ,MYLIST_COLUMN_INFO> >, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *><std::pair<int const ,MYLIST_COLUMN_INFO> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node><std::pair<int const ,MYLIST_COLUMN_INFO> >, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node><std::pair<int const ,MYLIST_COLUMN_INFO> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 60	 imul	 eax, 96			; 00000060H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
$T202696 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	50		 push	 eax
  0000a	6a 04		 push	 4
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00011	83 c4 08	 add	 esp, 8
  00014	89 45 fc	 mov	 DWORD PTR $T202696[ebp], eax
  00017	83 7d fc 00	 cmp	 DWORD PTR $T202696[ebp], 0
  0001b	74 12		 je	 SHORT $L202697
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T202696[ebp]
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	89 01		 mov	 DWORD PTR [ecx], eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR $T202696[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0002d	eb 07		 jmp	 SHORT $L201277
$L202697:
  0002f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L201277:

; 43   : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??1_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node::~_Node
; Function compile flags: /Odt
;	COMDAT ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEPAXI@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L201284
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L201284:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAEPAXI@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node::~_Node, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	e8 00 00 00 00	 call	 ??1?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@QAE@XZ
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1_Node@?$_Tree_nod@V?$_Tmap_traits@HUMYLIST_COLUMN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUMYLIST_COLUMN_INFO@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<int,MYLIST_COLUMN_INFO,std::less<int>,std::allocator<std::pair<int const ,MYLIST_COLUMN_INFO> >,0> >::_Node::~_Node
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::vector<int,std::allocator<int> >::const_iterator::operator*
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::vector<int,std::allocator<int> >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::vector<int,std::allocator<int> >::iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 			++this->_Myptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	83 c1 04	 add	 ecx, 4
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 232  : 			}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<int,std::allocator<int> >::iterator::operator++
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
_TEXT	ENDS
;	COMDAT ??0?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@AAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Cont$ = 8						; size = 4
??0?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@AAV?$vector@HV?$allocator@H@std@@@1@@Z PROC NEAR ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::back_insert_iterator<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 23   : 		{	// construct with container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Cont$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 24   : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@AAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::back_insert_iterator<std::vector<int,std::allocator<int> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator*
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@HV?$allocator@H@std@@@0@AAV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@HV?$allocator@H@std@@@0@AAV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC NEAR ; std::_Ptr_cat<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@HV?$allocator@H@std@@@0@AAV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Ptr_cat<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
PUBLIC	??4?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@ABH@Z ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator=
PUBLIC	??D?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator*
PUBLIC	??E?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator++
; Function compile flags: /Odt
;	COMDAT ??$_Copy_opt@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Copy_opt@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1020 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1021 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	eb 10		 jmp	 SHORT $L201301
$L201302:
  00005	8d 4d 14	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00008	e8 00 00 00 00	 call	 ??E?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator++
  0000d	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::iterator::operator++
$L201301:
  00015	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00018	50		 push	 eax
  00019	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0001c	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator!=
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 1a		 je	 SHORT $L201303

; 1022 : 		*_Dest = *_First;

  00028	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0002b	e8 00 00 00 00	 call	 ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
  00030	50		 push	 eax
  00031	8d 4d 14	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00034	e8 00 00 00 00	 call	 ??D?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator*
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 ??4?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@ABH@Z ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator=
  00040	eb c3		 jmp	 SHORT $L201302
$L201303:

; 1023 : 	return (_Dest);

  00042	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00045	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
  00048	89 02		 mov	 DWORD PTR [edx], eax
  0004a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1024 : 	}

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??$_Copy_opt@Viterator@?$vector@HV?$allocator@H@std@@@std@@V?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@0@Viterator@?$vector@HV?$allocator@H@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::vector<int,std::allocator<int> >::iterator,std::back_insert_iterator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initCX$ = 8						; size = 4
_initCY$ = 12						; size = 4
??0CSize@@QAE@HH@Z PROC NEAR				; CSize::CSize, COMDAT
; _this$ = ecx

; 24   : 	{ cx = initCX; cy = initCY; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _initCX$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _initCY$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0CSize@@QAE@HH@Z ENDP					; CSize::CSize
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<int,std::allocator<int> >, COMDAT

; 233  : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
;	COMDAT ??4?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??4?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@ABH@Z PROC NEAR ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator=, COMDAT
; _this$ = ecx

; 28   : 		{	// push value into container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 		container->push_back(_Val);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00010	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 30   : 		return (*this);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 31   : 		}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??4?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@ABH@Z ENDP ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??D?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ PROC NEAR ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator*, COMDAT
; _this$ = ecx

; 34   : 		{	// pretend to return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 36   : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??D?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??E?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ PROC NEAR ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator++, COMDAT
; _this$ = ecx

; 39   : 		{	// pretend to preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 41   : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??E?$back_insert_iterator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::back_insert_iterator<std::vector<int,std::allocator<int> > >::operator++
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T202729 = -8						; size = 4
$T202728 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0000a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00012	8b f0		 mov	 esi, eax
  00014	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  0001c	3b f0		 cmp	 esi, eax
  0001e	73 1d		 jae	 SHORT $L201313

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	50		 push	 eax
  00024	6a 01		 push	 1
  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	52		 push	 edx
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  0003b	eb 1f		 jmp	 SHORT $L201312
$L201313:

; 583  : 			insert(end(), _Val);

  0003d	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00040	52		 push	 edx
  00041	8d 45 fc	 lea	 eax, DWORD PTR $T202728[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	51		 push	 ecx
  00050	8d 55 f8	 lea	 edx, DWORD PTR $T202729[ebp]
  00053	52		 push	 edx
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$L201312:

; 584  : 		}

  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L202732
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 12		 jmp	 SHORT $L202733
$L202732:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	c1 f8 02	 sar	 eax, 2
  0002a	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L202733:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L202736
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 12		 jmp	 SHORT $L202737
$L202736:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	c1 f8 02	 sar	 eax, 2
  0002a	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L202737:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+
PUBLIC	??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<int,std::allocator<int> >::iterator::operator-
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odt
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
_this$ = -16						; size = 4
$T202743 = -12						; size = 4
$T202740 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00011	85 c0		 test	 eax, eax
  00013	75 09		 jne	 SHORT $L202741
  00015	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0001c	eb 18		 jmp	 SHORT $L202742
$L202741:
  0001e	8d 45 f8	 lea	 eax, DWORD PTR $T202740[ebp]
  00021	50		 push	 eax
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
  0002a	50		 push	 eax
  0002b	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002e	e8 00 00 00 00	 call	 ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<int,std::allocator<int> >::iterator::operator-
  00033	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$L202742:
  00036	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00039	89 4d fc	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0003c	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0003f	52		 push	 edx
  00040	6a 01		 push	 1
  00042	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00045	50		 push	 eax
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 623  : 		return (begin() + _Off);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	52		 push	 edx
  00056	8d 45 f4	 lea	 eax, DWORD PTR $T202743[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+
  00069	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Odt
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00022	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00025	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]

; 880  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
PUBLIC	??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z	; std::copy_backward<int *,int *>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202757 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T202759 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L202751
$T202760 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L202753
$T202758 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T202759
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T202760
$T202755 DD	019930520H
	DD	04H
	DD	FLAT:$T202757
	DD	02H
	DD	FLAT:$T202758
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
_TEXT	SEGMENT
tv240 = -52						; size = 4
tv239 = -48						; size = 4
tv85 = -44						; size = 4
_this$ = -40						; size = 4
__Oldend$201372 = -36					; size = 4
__Newvec$201351 = -32					; size = 4
__Ptr$201352 = -28					; size = 4
__Capacity$ = -24					; size = 4
__Tmp$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 24	 sub	 esp, 36			; 00000024H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00025	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d ec	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 811  : 		size_type _Capacity = capacity();

  0002d	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  00035	89 45 e8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  00038	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0003c	75 05		 jne	 SHORT $L201345

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0003e	e9 c6 02 00 00	 jmp	 $L202747
$L201345:
  00043	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  0004b	8b f0		 mov	 esi, eax
  0004d	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00055	2b c6		 sub	 eax, esi
  00057	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0005a	73 0d		 jae	 SHORT $L201347

; 816  : 			_Xlen();	// result too long

  0005c	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  00064	e9 a0 02 00 00	 jmp	 $L202747
$L201347:
  00069	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00071	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00074	39 45 e8	 cmp	 DWORD PTR __Capacity$[ebp], eax
  00077	0f 83 66 01 00
	00		 jae	 $L201349

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0007d	8b 75 e8	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00080	d1 ee		 shr	 esi, 1
  00082	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  0008a	2b c6		 sub	 eax, esi
  0008c	3b 45 e8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0008f	73 09		 jae	 SHORT $L202748
  00091	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  00098	eb 0b		 jmp	 SHORT $L202749
$L202748:
  0009a	8b 55 e8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0009d	d1 ea		 shr	 edx, 1
  0009f	03 55 e8	 add	 edx, DWORD PTR __Capacity$[ebp]
  000a2	89 55 d4	 mov	 DWORD PTR tv85[ebp], edx
$L202749:
  000a5	8b 45 d4	 mov	 eax, DWORD PTR tv85[ebp]
  000a8	89 45 e8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 821  : 			if (_Capacity < size() + _Count)

  000ab	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  000b3	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000b6	39 45 e8	 cmp	 DWORD PTR __Capacity$[ebp], eax
  000b9	73 0e		 jae	 SHORT $L201350

; 822  : 				_Capacity = size() + _Count;

  000bb	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  000c3	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000c6	89 45 e8	 mov	 DWORD PTR __Capacity$[ebp], eax
$L201350:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000c9	8b 4d e8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  000cc	51		 push	 ecx
  000cd	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate
  000d5	89 45 e0	 mov	 DWORD PTR __Newvec$201351[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  000d8	8b 55 e0	 mov	 edx, DWORD PTR __Newvec$201351[ebp]
  000db	89 55 e4	 mov	 DWORD PTR __Ptr$201352[ebp], edx

; 825  : 
; 826  : 			_TRY_BEGIN

  000de	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000e5	8b 45 e0	 mov	 eax, DWORD PTR __Newvec$201351[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  000ec	51		 push	 ecx
  000ed	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  000f0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f3	50		 push	 eax
  000f4	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
  000fc	89 45 d0	 mov	 DWORD PTR tv239[ebp], eax
  000ff	8b 4d d0	 mov	 ecx, DWORD PTR tv239[ebp]
  00102	89 4d e4	 mov	 DWORD PTR __Ptr$201352[ebp], ecx

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00105	8d 55 ec	 lea	 edx, DWORD PTR __Tmp$[ebp]
  00108	52		 push	 edx
  00109	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0010c	50		 push	 eax
  0010d	8b 4d e4	 mov	 ecx, DWORD PTR __Ptr$201352[ebp]
  00110	51		 push	 ecx
  00111	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00114	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
  00119	89 45 cc	 mov	 DWORD PTR tv240[ebp], eax
  0011c	8b 55 cc	 mov	 edx, DWORD PTR tv240[ebp]
  0011f	89 55 e4	 mov	 DWORD PTR __Ptr$201352[ebp], edx

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$201352[ebp]
  00125	50		 push	 eax
  00126	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0012c	52		 push	 edx
  0012d	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00130	50		 push	 eax
  00131	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00134	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
  00139	eb 29		 jmp	 SHORT $L202750
$L202751:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  0013b	8b 4d e4	 mov	 ecx, DWORD PTR __Ptr$201352[ebp]
  0013e	51		 push	 ecx
  0013f	8b 55 e0	 mov	 edx, DWORD PTR __Newvec$201351[ebp]
  00142	52		 push	 edx
  00143	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  0014b	8b 45 e8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  0014e	50		 push	 eax
  0014f	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$201351[ebp]
  00152	51		 push	 ecx
  00153	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate

; 834  : 			_RERAISE;

  0015b	6a 00		 push	 0
  0015d	6a 00		 push	 0
  0015f	e8 00 00 00 00	 call	 __CxxThrowException@8
$L202750:

; 835  : 			_CATCH_END

  00164	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 836  : 
; 837  : 			_Count += size();

  0016b	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00173	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00176	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  00179	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0017c	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00180	74 35		 je	 SHORT $L201359

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  00182	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00185	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00188	51		 push	 ecx
  00189	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0018c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0018f	50		 push	 eax
  00190	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00198	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0019b	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0019e	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  001a1	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  001a4	c1 f8 02	 sar	 eax, 2
  001a7	50		 push	 eax
  001a8	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001ae	52		 push	 edx
  001af	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate
$L201359:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001b7	8b 45 e8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  001ba	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$201351[ebp]
  001bd	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  001c0	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  001c3	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 844  : 			_Mylast = _Newvec + _Count;

  001c6	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  001c9	8b 55 e0	 mov	 edx, DWORD PTR __Newvec$201351[ebp]
  001cc	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  001cf	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d2	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

  001d5	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  001d8	8b 45 e0	 mov	 eax, DWORD PTR __Newvec$201351[ebp]
  001db	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001de	e9 26 01 00 00	 jmp	 $L202747
$L201349:
  001e3	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e6	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001e9	2b 55 08	 sub	 edx, DWORD PTR __Where$[ebp]
  001ec	c1 fa 02	 sar	 edx, 2
  001ef	3b 55 0c	 cmp	 edx, DWORD PTR __Count$[ebp]
  001f2	0f 83 ad 00 00
	00		 jae	 $L201362

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  001f8	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001fb	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  001fe	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00201	52		 push	 edx
  00202	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00205	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00208	51		 push	 ecx
  00209	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  0020c	52		 push	 edx
  0020d	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00210	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>

; 851  : 
; 852  : 			_TRY_BEGIN

  00215	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0021c	8d 45 ec	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0021f	50		 push	 eax
  00220	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00223	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00226	2b 55 08	 sub	 edx, DWORD PTR __Where$[ebp]
  00229	c1 fa 02	 sar	 edx, 2
  0022c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0022f	2b c2		 sub	 eax, edx
  00231	50		 push	 eax
  00232	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00235	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00238	52		 push	 edx
  00239	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023c	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
  00241	eb 28		 jmp	 SHORT $L202752
$L202753:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  00243	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00246	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00249	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0024c	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0024f	50		 push	 eax
  00250	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00253	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00256	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00259	50		 push	 eax
  0025a	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0025d	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 857  : 			_RERAISE;

  00262	6a 00		 push	 0
  00264	6a 00		 push	 0
  00266	e8 00 00 00 00	 call	 __CxxThrowException@8
$L202752:

; 858  : 			_CATCH_END

  0026b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 859  : 
; 860  : 			_Mylast += _Count;

  00272	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00275	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00278	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0027b	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  0027e	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00281	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00284	8d 45 ec	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00287	50		 push	 eax
  00288	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0028b	c1 e1 02	 shl	 ecx, 2
  0028e	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00291	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00294	2b c1		 sub	 eax, ecx
  00296	50		 push	 eax
  00297	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  0029a	51		 push	 ecx
  0029b	e8 00 00 00 00	 call	 ??$fill@PAHH@std@@YAXPAH0ABH@Z ; std::fill<int *,int>
  002a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002a3	eb 64		 jmp	 SHORT $L202747
$L201362:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  002a5	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  002a8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002ab	89 45 dc	 mov	 DWORD PTR __Oldend$201372[ebp], eax

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002b4	52		 push	 edx
  002b5	8b 45 dc	 mov	 eax, DWORD PTR __Oldend$201372[ebp]
  002b8	50		 push	 eax
  002b9	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002bc	c1 e1 02	 shl	 ecx, 2
  002bf	8b 55 dc	 mov	 edx, DWORD PTR __Oldend$201372[ebp]
  002c2	2b d1		 sub	 edx, ecx
  002c4	52		 push	 edx
  002c5	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c8	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
  002cd	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d0	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  002d3	8b 55 dc	 mov	 edx, DWORD PTR __Oldend$201372[ebp]
  002d6	52		 push	 edx
  002d7	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002da	c1 e0 02	 shl	 eax, 2
  002dd	8b 4d dc	 mov	 ecx, DWORD PTR __Oldend$201372[ebp]
  002e0	2b c8		 sub	 ecx, eax
  002e2	51		 push	 ecx
  002e3	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  002e6	52		 push	 edx
  002e7	e8 00 00 00 00	 call	 ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z ; std::copy_backward<int *,int *>
  002ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  002ef	8d 45 ec	 lea	 eax, DWORD PTR __Tmp$[ebp]
  002f2	50		 push	 eax
  002f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002f6	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  002f9	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  002fc	50		 push	 eax
  002fd	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00300	51		 push	 ecx
  00301	e8 00 00 00 00	 call	 ??$fill@PAHH@std@@YAXPAH0ABH@Z ; std::fill<int *,int>
  00306	83 c4 0c	 add	 esp, 12			; 0000000cH
$L202747:

; 873  : 			}
; 874  : 		}

  00309	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0030c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00313	5f		 pop	 edi
  00314	5e		 pop	 esi
  00315	5b		 pop	 ebx
  00316	8b e5		 mov	 esp, ebp
  00318	5d		 pop	 ebp
  00319	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202755
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CPoint@@QAE@XZ PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 61   : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CPoint@@QAE@XZ ENDP					; CPoint::CPoint
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initX$ = 8						; size = 4
_initY$ = 12						; size = 4
??0CPoint@@QAE@HH@Z PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 63   : 	{ x = initX; y = initY; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _initX$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _initY$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0CPoint@@QAE@HH@Z ENDP				; CPoint::CPoint
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8CPoint@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
_point$ = 8						; size = 8
??8CPoint@@QBEHUtagPOINT@@@Z PROC NEAR			; CPoint::operator==, COMDAT
; _this$ = ecx

; 82   : 	{ return (x == point.x && y == point.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	3b 4d 08	 cmp	 ecx, DWORD PTR _point$[ebp]
  00011	75 14		 jne	 SHORT $L202769
  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00019	3b 45 0c	 cmp	 eax, DWORD PTR _point$[ebp+4]
  0001c	75 09		 jne	 SHORT $L202769
  0001e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00025	eb 07		 jmp	 SHORT $L202770
$L202769:
  00027	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$L202770:
  0002e	8b 45 f8	 mov	 eax, DWORD PTR tv67[ebp]
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??8CPoint@@QBEHUtagPOINT@@@Z ENDP			; CPoint::operator==
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+=
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator-
; Function compile flags: /Odt
;	COMDAT ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T202775 = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR $T202775[ebp], ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR $T202775[ebp]
  00018	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator-

; 280  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator-
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  0000f	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax

; 257  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<int,unsigned int,int>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T202782 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T202782[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T202782[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<int,unsigned int,int>
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC NEAR		; std::fill<int *,int>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1135 : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L201498
$L201499:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 04	 add	 eax, 4
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L201498:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0c		 je	 SHORT $L201497

; 1136 : 		*_First = _Val;

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	89 0a		 mov	 DWORD PTR [edx], ecx
  00020	eb e3		 jmp	 SHORT $L201499
$L201497:

; 1137 : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *>
; Function compile flags: /Odt
;	COMDAT ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T202789 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z PROC NEAR	; std::copy_backward<int *,int *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00004	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T202789[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T202789[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::copy_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$fill_n@PAHIH@std@@YAXPAHIABH@Z		; std::fill_n<int *,unsigned int,int>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<int,unsigned int,int>, COMDAT

; 236  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 	fill_n(_First, _Count, _Val);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ??$fill_n@PAHIH@std@@YAXPAHIABH@Z ; std::fill_n<int *,unsigned int,int>
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 238  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>
; Function compile flags: /Odt
;	COMDAT ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T202794 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z PROC NEAR ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T202794[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T202794[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRect@@QAE@XZ PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 110  : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CRect@@QAE@XZ ENDP					; CRect::CRect
_TEXT	ENDS
EXTRN	__imp__memmove:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<int *,int *>, COMDAT

; 1058 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	89 45 fc	 mov	 DWORD PTR __Off$[ebp], eax

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  00010	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00013	c1 e1 02	 shl	 ecx, 2
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Off$[ebp]
  0001e	c1 e0 02	 shl	 eax, 2
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
??0CRect@@QAE@HHHH@Z PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 112  : 	{ left = l; top = t; right = r; bottom = b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _r$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _b$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
??0CRect@@QAE@HHHH@Z ENDP				; CRect::CRect
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill_n@PAHIH@std@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAHIH@std@@YAXPAHIABH@Z PROC NEAR		; std::fill_n<int *,unsigned int,int>, COMDAT

; 1159 : 	{	// copy _Val _Count times through [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00003	eb 12		 jmp	 SHORT $L201573
$L201574:
  00005	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00008	83 e8 01	 sub	 eax, 1
  0000b	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	83 c1 04	 add	 ecx, 4
  00014	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$L201573:
  00017	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0001b	76 0c		 jbe	 SHORT $L201572

; 1161 : 		*_First = _Val;

  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	89 0a		 mov	 DWORD PTR [edx], ecx
  00027	eb dc		 jmp	 SHORT $L201574
$L201572:

; 1162 : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$fill_n@PAHIH@std@@YAXPAHIABH@Z ENDP			; std::fill_n<int *,unsigned int,int>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<int,int>, COMDAT

; 105  : 	{	// copy [_First, _Last) to raw _Dest, (const) scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00010	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  00013	c1 e1 02	 shl	 ecx, 2
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 109  : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int,int>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@UtagPOINT@@UtagSIZE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_point$ = 8						; size = 8
_size$ = 16						; size = 8
??0CRect@@QAE@UtagPOINT@@UtagSIZE@@@Z PROC NEAR		; CRect::CRect, COMDAT
; _this$ = ecx

; 118  : 	{ right = (left = point.x) + size.cx; bottom = (top = point.y) + size.cy; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _point$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR _point$[ebp]
  00012	03 55 10	 add	 edx, DWORD PTR _size$[ebp]
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp+4]
  00021	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00024	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp+4]
  00027	03 45 14	 add	 eax, DWORD PTR _size$[ebp+4]
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 10 00	 ret	 16			; 00000010H
??0CRect@@QAE@UtagPOINT@@UtagSIZE@@@Z ENDP		; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_ECMyListCtrl@@WFE@AEPAXI@Z
_TEXT	SEGMENT
??_ECMyListCtrl@@WFE@AEPAXI@Z PROC NEAR			; [thunk]:CMyListCtrl::`vector deleting destructor', COMDAT
  00000	83 e9 54	 sub	 ecx, 84			; 00000054H
  00003	e9 00 00 00 00	 jmp	 ??_ECMyListCtrl@@UAEPAXI@Z
??_ECMyListCtrl@@WFE@AEPAXI@Z ENDP			; [thunk]:CMyListCtrl::`vector deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Width@CRect@@QBEHXZ PROC NEAR				; CRect::Width, COMDAT
; _this$ = ecx

; 123  : 	{ return right - left; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Width@CRect@@QBEHXZ ENDP				; CRect::Width
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Height@CRect@@QBEHXZ PROC NEAR				; CRect::Height, COMDAT
; _this$ = ecx

; 125  : 	{ return bottom - top; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?Height@CRect@@QBEHXZ ENDP				; CRect::Height
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?CenterPoint@CRect@@QBE?AVCPoint@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?CenterPoint@CRect@@QBE?AVCPoint@@XZ PROC NEAR		; CRect::CenterPoint, COMDAT
; _this$ = ecx

; 137  : 	{ return CPoint((left+right)/2, (top+bottom)/2); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  00013	99		 cdq
  00014	2b c2		 sub	 eax, edx
  00016	d1 f8		 sar	 eax, 1
  00018	50		 push	 eax
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 02		 mov	 eax, DWORD PTR [edx]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00024	99		 cdq
  00025	2b c2		 sub	 eax, edx
  00027	d1 f8		 sar	 eax, 1
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?CenterPoint@CRect@@QBE?AVCPoint@@XZ ENDP		; CRect::CenterPoint
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??BCRect@@QAEPAUtagRECT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCRect@@QAEPAUtagRECT@@XZ PROC NEAR			; CRect::operator tagRECT *, COMDAT
; _this$ = ecx

; 143  : 	{ return this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??BCRect@@QAEPAUtagRECT@@XZ ENDP			; CRect::operator tagRECT *
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??BCRect@@QBEPBUtagRECT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCRect@@QBEPBUtagRECT@@XZ PROC NEAR			; CRect::operator tagRECT const *, COMDAT
; _this$ = ecx

; 145  : 	{ return this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??BCRect@@QBEPBUtagRECT@@XZ ENDP			; CRect::operator tagRECT const *
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC NEAR	; CObject::Serialize, COMDAT
; _this$ = ecx

; 25   : 	{ /* CObject does not serialize anything by default */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC NEAR				; CObject::operator delete, COMDAT

; 31   : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AssertValid@CObject@@UBEXXZ PROC NEAR			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 41   : 	{ /* no asserts in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC NEAR	; CObject::Dump, COMDAT
; _this$ = ecx

; 43   : 	{ /* no dumping in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
PUBLIC	??_R0?AVCGdiObject@@@8				; CGdiObject `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CGdiObject@@8			; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4CBrush@@6B@				; CBrush::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBrush@@@8				; CBrush `RTTI Type Descriptor'
PUBLIC	??_R3CBrush@@8					; CBrush::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBrush@@8					; CBrush::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CBrush@@8				; CBrush::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??1CGdiObject@@UAE@XZ				; CGdiObject::~CGdiObject
PUBLIC	??_7CBrush@@6B@					; CBrush::`vftable'
PUBLIC	??_GCBrush@@UAEPAXI@Z				; CBrush::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CBrush@@UBEPAUCRuntimeClass@@XZ:NEAR ; CBrush::GetRuntimeClass
EXTRN	??_ECBrush@@UAEPAXI@Z:NEAR			; CBrush::`vector deleting destructor'
;	COMDAT ??_7CBrush@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
CONST	SEGMENT
??_7CBrush@@6B@ DD FLAT:??_R4CBrush@@6B@		; CBrush::`vftable'
	DD	FLAT:?GetRuntimeClass@CBrush@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECBrush@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CBrush@@6B@
rdata$r	SEGMENT
??_R4CBrush@@6B@ DD 00H					; CBrush::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBrush@@@8
	DD	FLAT:??_R3CBrush@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBrush@@@8
_DATA	SEGMENT
??_R0?AVCBrush@@@8 DD FLAT:??_7type_info@@6B@		; CBrush `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBrush@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CBrush@@8
rdata$r	SEGMENT
??_R3CBrush@@8 DD 00H					; CBrush::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CBrush@@8
rdata$r	ENDS
;	COMDAT ??_R2CBrush@@8
rdata$r	SEGMENT
??_R2CBrush@@8 DD FLAT:??_R1A@?0A@A@CBrush@@8		; CBrush::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBrush@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CBrush@@8 DD FLAT:??_R0?AVCBrush@@@8	; CBrush::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CGdiObject@@8 DD FLAT:??_R0?AVCGdiObject@@@8 ; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
_DATA	SEGMENT
??_R0?AVCGdiObject@@@8 DD FLAT:??_7type_info@@6B@	; CGdiObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGdiObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??1CBrush@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CBrush@@UAE@XZ PROC NEAR				; CBrush::~CBrush, COMDAT
; _this$ = ecx

; 130  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBrush@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CBrush@@UAE@XZ ENDP					; CBrush::~CBrush
_TEXT	ENDS
PUBLIC	??_R4CGdiObject@@6B@				; CGdiObject::`RTTI Complete Object Locator'
PUBLIC	??_R3CGdiObject@@8				; CGdiObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGdiObject@@8				; CGdiObject::`RTTI Base Class Array'
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
PUBLIC	??_7CGdiObject@@6B@				; CGdiObject::`vftable'
PUBLIC	??_GCGdiObject@@UAEPAXI@Z			; CGdiObject::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ:NEAR ; CGdiObject::GetRuntimeClass
EXTRN	??_ECGdiObject@@UAEPAXI@Z:NEAR			; CGdiObject::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202836 DD	0ffffffffH
	DD	FLAT:$L202832
$T202834 DD	019930520H
	DD	01H
	DD	FLAT:$T202836
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT
??_7CGdiObject@@6B@ DD FLAT:??_R4CGdiObject@@6B@	; CGdiObject::`vftable'
	DD	FLAT:?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECGdiObject@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT
??_R4CGdiObject@@6B@ DD 00H				; CGdiObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGdiObject@@@8
	DD	FLAT:??_R3CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT
??_R3CGdiObject@@8 DD 00H				; CGdiObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT
??_R2CGdiObject@@8 DD FLAT:??_R1A@?0A@A@CGdiObject@@8	; CGdiObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CObject@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CGdiObject@@UAE@XZ PROC NEAR				; CGdiObject::~CGdiObject, COMDAT
; _this$ = ecx

; 84   : 	{ DeleteObject(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGdiObject@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CGdiObject@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject
  00034	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CObject@@UAE@XZ	; CObject::~CObject
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202832:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CObject@@UAE@XZ	; CObject::~CObject
__ehhandler$??1CGdiObject@@UAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202834
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CGdiObject@@UAE@XZ ENDP				; CGdiObject::~CGdiObject
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CObject@@UAE@XZ PROC NEAR				; CObject::~CObject, COMDAT
; _this$ = ecx

; 23   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGdiObject@@UAEPAXI@Z PROC NEAR			; CGdiObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41495
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41495:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCGdiObject@@UAEPAXI@Z ENDP				; CGdiObject::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCBrush@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCBrush@@UAEPAXI@Z PROC NEAR				; CBrush::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41589
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41589:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCBrush@@UAEPAXI@Z ENDP				; CBrush::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4CFont@@6B@					; CFont::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCFont@@@8				; CFont `RTTI Type Descriptor'
PUBLIC	??_R3CFont@@8					; CFont::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CFont@@8					; CFont::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CFont@@8				; CFont::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0CGdiObject@@QAE@XZ				; CGdiObject::CGdiObject
PUBLIC	??_7CFont@@6B@					; CFont::`vftable'
PUBLIC	??_GCFont@@UAEPAXI@Z				; CFont::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CFont@@UBEPAUCRuntimeClass@@XZ:NEAR ; CFont::GetRuntimeClass
EXTRN	??_ECFont@@UAEPAXI@Z:NEAR			; CFont::`vector deleting destructor'
;	COMDAT ??_7CFont@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
CONST	SEGMENT
??_7CFont@@6B@ DD FLAT:??_R4CFont@@6B@			; CFont::`vftable'
	DD	FLAT:?GetRuntimeClass@CFont@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECFont@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CFont@@6B@
rdata$r	SEGMENT
??_R4CFont@@6B@ DD 00H					; CFont::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCFont@@@8
	DD	FLAT:??_R3CFont@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFont@@@8
_DATA	SEGMENT
??_R0?AVCFont@@@8 DD FLAT:??_7type_info@@6B@		; CFont `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFont@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CFont@@8
rdata$r	SEGMENT
??_R3CFont@@8 DD 00H					; CFont::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CFont@@8
rdata$r	ENDS
;	COMDAT ??_R2CFont@@8
rdata$r	SEGMENT
??_R2CFont@@8 DD FLAT:??_R1A@?0A@A@CFont@@8		; CFont::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CFont@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CFont@@8 DD FLAT:??_R0?AVCFont@@@8		; CFont::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CFont@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CFont@@QAE@XZ PROC NEAR				; CFont::CFont, COMDAT
; _this$ = ecx

; 153  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CGdiObject@@QAE@XZ	; CGdiObject::CGdiObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CFont@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CFont@@QAE@XZ ENDP					; CFont::CFont
_TEXT	ENDS
PUBLIC	??0CObject@@IAE@XZ				; CObject::CObject
; Function compile flags: /Odt
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CGdiObject@@QAE@XZ PROC NEAR				; CGdiObject::CGdiObject, COMDAT
; _this$ = ecx

; 82   : 	{ m_hObject = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CObject@@IAE@XZ	; CObject::CObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CGdiObject@@6B@
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0CGdiObject@@QAE@XZ ENDP				; CGdiObject::CGdiObject
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CObject@@IAE@XZ PROC NEAR				; CObject::CObject, COMDAT
; _this$ = ecx

; 21   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CObject@@IAE@XZ ENDP					; CObject::CObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCFont@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCFont@@UAEPAXI@Z PROC NEAR				; CFont::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CFont@@UAE@XZ	; CFont::~CFont
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41640
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41640:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCFont@@UAEPAXI@Z ENDP				; CFont::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
_TEXT	ENDS
;	COMDAT ??1CFont@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CFont@@UAE@XZ PROC NEAR				; CFont::~CFont, COMDAT
; _this$ = ecx

; 155  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CFont@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CFont@@UAE@XZ ENDP					; CFont::~CFont
_TEXT	ENDS
PUBLIC	?GetSafeHandle@CGdiObject@@QBEPAXXZ		; CGdiObject::GetSafeHandle
EXTRN	__imp__FillRect@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?FillRect@CDC@@QAEXPBUtagRECT@@PAVCBrush@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
_pBrush$ = 12						; size = 4
?FillRect@CDC@@QAEXPBUtagRECT@@PAVCBrush@@@Z PROC NEAR	; CDC::FillRect, COMDAT
; _this$ = ecx

; 472  : 	{ ASSERT(m_hDC != NULL); ::FillRect(m_hDC, lpRect, (HBRUSH)pBrush->GetSafeHandle()); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _pBrush$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetSafeHandle@CGdiObject@@QBEPAXXZ ; CGdiObject::GetSafeHandle
  0000f	50		 push	 eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	52		 push	 edx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?FillRect@CDC@@QAEXPBUtagRECT@@PAVCBrush@@@Z ENDP	; CDC::FillRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSafeHandle@CGdiObject@@QBEPAXXZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?GetSafeHandle@CGdiObject@@QBEPAXXZ PROC NEAR		; CGdiObject::GetSafeHandle, COMDAT
; _this$ = ecx

; 80   : 	{ return this == NULL ? NULL : m_hObject; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  0000d	75 09		 jne	 SHORT $L202862
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00016	eb 09		 jmp	 SHORT $L202863
$L202862:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	89 4d f8	 mov	 DWORD PTR tv66[ebp], ecx
$L202863:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GetSafeHandle@CGdiObject@@QBEPAXXZ ENDP		; CGdiObject::GetSafeHandle
_TEXT	ENDS
EXTRN	__imp__GetWindowRect@8:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin2.inl
;	COMDAT ?GetWindowRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
?GetWindowRect@CWnd@@QBEXPAUtagRECT@@@Z PROC NEAR	; CWnd::GetWindowRect, COMDAT
; _this$ = ecx

; 105  : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetWindowRect(m_hWnd, lpRect); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?GetWindowRect@CWnd@@QBEXPAUtagRECT@@@Z ENDP		; CWnd::GetWindowRect
_TEXT	ENDS
EXTRN	__imp__GetClientRect@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z PROC NEAR	; CWnd::GetClientRect, COMDAT
; _this$ = ecx

; 107  : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ENDP		; CWnd::GetClientRect
_TEXT	ENDS
EXTRN	__imp__GetUpdateRect@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetUpdateRect@CWnd@@QAEHPAUtagRECT@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
_bErase$ = 12						; size = 4
?GetUpdateRect@CWnd@@QAEHPAUtagRECT@@H@Z PROC NEAR	; CWnd::GetUpdateRect, COMDAT
; _this$ = ecx

; 131  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::GetUpdateRect(m_hWnd, lpRect, bErase); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _bErase$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetUpdateRect@12
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?GetUpdateRect@CWnd@@QAEHPAUtagRECT@@H@Z ENDP		; CWnd::GetUpdateRect
_TEXT	ENDS
EXTRN	__imp__InvalidateRect@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?Invalidate@CWnd@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bErase$ = 8						; size = 4
?Invalidate@CWnd@@QAEXH@Z PROC NEAR			; CWnd::Invalidate, COMDAT
; _this$ = ecx

; 135  : 	{ ASSERT(::IsWindow(m_hWnd)); ::InvalidateRect(m_hWnd, NULL, bErase); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _bErase$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00013	52		 push	 edx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?Invalidate@CWnd@@QAEXH@Z ENDP				; CWnd::Invalidate
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
_bErase$ = 12						; size = 4
?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z PROC NEAR	; CWnd::InvalidateRect, COMDAT
; _this$ = ecx

; 137  : 	{ ASSERT(::IsWindow(m_hWnd)); ::InvalidateRect(m_hWnd, lpRect, bErase); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _bErase$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?InvalidateRect@CWnd@@QAEXPBUtagRECT@@H@Z ENDP		; CWnd::InvalidateRect
_TEXT	ENDS
EXTRN	__imp__GetFocus@0:NEAR
EXTRN	?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z:NEAR	; CWnd::FromHandle
; Function compile flags: /Odt
;	COMDAT ?GetFocus@CWnd@@SGPAV1@XZ
_TEXT	SEGMENT
?GetFocus@CWnd@@SGPAV1@XZ PROC NEAR			; CWnd::GetFocus, COMDAT

; 201  : 	{ return CWnd::FromHandle(::GetFocus()); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z ; CWnd::FromHandle
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetFocus@CWnd@@SGPAV1@XZ ENDP				; CWnd::GetFocus
_TEXT	ENDS
EXTRN	__imp__GetParent@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetParent@CWnd@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetParent@CWnd@@QBEPAV1@XZ PROC NEAR			; CWnd::GetParent, COMDAT
; _this$ = ecx

; 282  : 	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetParent(m_hWnd)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z ; CWnd::FromHandle
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?GetParent@CWnd@@QBEPAV1@XZ ENDP			; CWnd::GetParent
_TEXT	ENDS
EXTRN	?Default@CWnd@@IAEJXZ:NEAR			; CWnd::Default
; Function compile flags: /Odt
;	COMDAT ?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z PROC NEAR	; CWnd::OnCreate, COMDAT
; _this$ = ecx

; 360  : 	{ return (int)Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z ENDP	; CWnd::OnCreate
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z PROC NEAR		; CWnd::OnMouseMove, COMDAT
; _this$ = ecx

; 476  : 	{ Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z ENDP		; CWnd::OnMouseMove
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z PROC NEAR ; CWnd::DoDataExchange, COMDAT
; _this$ = ecx

; 545  : 	{ } // default does nothing

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z ENDP	; CWnd::DoDataExchange
_TEXT	ENDS
EXTRN	__imp__EnableWindow@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?BeginModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BeginModalState@CWnd@@UAEXXZ PROC NEAR			; CWnd::BeginModalState, COMDAT
; _this$ = ecx

; 549  : 	{ ::EnableWindow(m_hWnd, FALSE); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	51		 push	 ecx
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?BeginModalState@CWnd@@UAEXXZ ENDP			; CWnd::BeginModalState
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?EndModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EndModalState@CWnd@@UAEXXZ PROC NEAR			; CWnd::EndModalState, COMDAT
; _this$ = ecx

; 551  : 	{ ::EnableWindow(m_hWnd, TRUE); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 01		 push	 1
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	51		 push	 ecx
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?EndModalState@CWnd@@UAEXXZ ENDP			; CWnd::EndModalState
_TEXT	ENDS
PUBLIC	??_7CListCtrl@@6B@				; CListCtrl::`vftable'
PUBLIC	??_GCListCtrl@@UAEPAXI@Z			; CListCtrl::`scalar deleting destructor'
PUBLIC	??_R4CListCtrl@@6B@				; CListCtrl::`RTTI Complete Object Locator'
PUBLIC	??_R3CListCtrl@@8				; CListCtrl::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CListCtrl@@8				; CListCtrl::`RTTI Base Class Array'
EXTRN	?DrawItem@CListCtrl@@UAEXPAUtagDRAWITEMSTRUCT@@@Z:NEAR ; CListCtrl::DrawItem
EXTRN	?GetMessageMap@CListCtrl@@MBEPBUAFX_MSGMAP@@XZ:NEAR ; CListCtrl::GetMessageMap
EXTRN	??_ECListCtrl@@UAEPAXI@Z:NEAR			; CListCtrl::`vector deleting destructor'
EXTRN	??0CWnd@@QAE@XZ:NEAR				; CWnd::CWnd
;	COMDAT ??_7CListCtrl@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxcmn.inl
CONST	SEGMENT
??_7CListCtrl@@6B@ DD FLAT:??_R4CListCtrl@@6B@		; CListCtrl::`vftable'
	DD	FLAT:?GetRuntimeClass@CListCtrl@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECListCtrl@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CListCtrl@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CListCtrl@@MAEHIIJPAJ@Z
	DD	FLAT:?CheckAutoCenter@CWnd@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?Create@CListCtrl@@UAEHKABUtagRECT@@PAVCWnd@@I@Z
	DD	FLAT:?CreateEx@CListCtrl@@UAEHKKABUtagRECT@@PAVCWnd@@I@Z
	DD	FLAT:?DrawItem@CListCtrl@@UAEXPAUtagDRAWITEMSTRUCT@@@Z
CONST	ENDS
;	COMDAT ??_R4CListCtrl@@6B@
rdata$r	SEGMENT
??_R4CListCtrl@@6B@ DD 00H				; CListCtrl::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCListCtrl@@@8
	DD	FLAT:??_R3CListCtrl@@8
rdata$r	ENDS
;	COMDAT ??_R3CListCtrl@@8
rdata$r	SEGMENT
??_R3CListCtrl@@8 DD 00H				; CListCtrl::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CListCtrl@@8
rdata$r	ENDS
;	COMDAT ??_R2CListCtrl@@8
rdata$r	SEGMENT
??_R2CListCtrl@@8 DD FLAT:??_R1A@?0A@A@CListCtrl@@8	; CListCtrl::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CWnd@@8
	DD	FLAT:??_R1A@?0A@A@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CListCtrl@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CListCtrl@@QAE@XZ PROC NEAR				; CListCtrl::CListCtrl, COMDAT
; _this$ = ecx

; 128  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CWnd@@QAE@XZ		; CWnd::CWnd
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CListCtrl@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CListCtrl@@QAE@XZ ENDP				; CListCtrl::CListCtrl
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCListCtrl@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCListCtrl@@UAEPAXI@Z PROC NEAR			; CListCtrl::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CListCtrl@@UAE@XZ	; CListCtrl::~CListCtrl
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L95454
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L95454:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCListCtrl@@UAEPAXI@Z ENDP				; CListCtrl::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetItemCount@CListCtrl@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetItemCount@CListCtrl@@QBEHXZ PROC NEAR		; CListCtrl::GetItemCount, COMDAT
; _this$ = ecx

; 142  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETITEMCOUNT, 0, 0L); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	68 04 10 00 00	 push	 4100			; 00001004H
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00016	51		 push	 ecx
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?GetItemCount@CListCtrl@@QBEHXZ ENDP			; CListCtrl::GetItemCount
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetItem@CListCtrl@@QBEHPAUtagLVITEMA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
?GetItem@CListCtrl@@QBEHPAUtagLVITEMA@@@Z PROC NEAR	; CListCtrl::GetItem, COMDAT
; _this$ = ecx

; 144  : 	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	68 05 10 00 00	 push	 4101			; 00001005H
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00018	52		 push	 edx
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?GetItem@CListCtrl@@QBEHPAUtagLVITEMA@@@Z ENDP		; CListCtrl::GetItem
_TEXT	ENDS
EXTRN	?SetItem@CListCtrl@@QAEHHHIPBDHIIJ@Z:NEAR	; CListCtrl::SetItem
; Function compile flags: /Odt
;	COMDAT ?SetItemData@CListCtrl@@QAEHHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nItem$ = 8						; size = 4
_dwData$ = 12						; size = 4
?SetItemData@CListCtrl@@QAEHHK@Z PROC NEAR		; CListCtrl::SetItemData, COMDAT
; _this$ = ecx

; 148  : 	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(nItem, 0, LVIF_PARAM, NULL, 0, 0, 0, (LPARAM)dwData); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _dwData$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	6a 04		 push	 4
  00015	6a 00		 push	 0
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _nItem$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?SetItem@CListCtrl@@QAEHHHIPBDHIIJ@Z ; CListCtrl::SetItem
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
?SetItemData@CListCtrl@@QAEHHK@Z ENDP			; CListCtrl::SetItemData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?InsertColumn@CListCtrl@@QAEHHPBUtagLVCOLUMNA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nCol$ = 8						; size = 4
_pColumn$ = 12						; size = 4
?InsertColumn@CListCtrl@@QAEHHPBUtagLVCOLUMNA@@@Z PROC NEAR ; CListCtrl::InsertColumn, COMDAT
; _this$ = ecx

; 196  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_INSERTCOLUMN, nCol, (LPARAM)pColumn); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _pColumn$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _nCol$[ebp]
  0000e	51		 push	 ecx
  0000f	68 1b 10 00 00	 push	 4123			; 0000101bH
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?InsertColumn@CListCtrl@@QAEHHPBUtagLVCOLUMNA@@@Z ENDP	; CListCtrl::InsertColumn
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetColumnWidth@CListCtrl@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nCol$ = 8						; size = 4
?GetColumnWidth@CListCtrl@@QBEHH@Z PROC NEAR		; CListCtrl::GetColumnWidth, COMDAT
; _this$ = ecx

; 200  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETCOLUMNWIDTH, nCol, 0); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _nCol$[ebp]
  0000c	50		 push	 eax
  0000d	68 1d 10 00 00	 push	 4125			; 0000101dH
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00018	52		 push	 edx
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?GetColumnWidth@CListCtrl@@QBEHH@Z ENDP			; CListCtrl::GetColumnWidth
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SortItems@CListCtrl@@QAEHP6GHJJJ@ZK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pfnCompare$ = 8					; size = 4
_dwData$ = 12						; size = 4
?SortItems@CListCtrl@@QAEHP6GHJJJ@ZK@Z PROC NEAR	; CListCtrl::SortItems, COMDAT
; _this$ = ecx

; 228  : 	{ ASSERT(::IsWindow(m_hWnd)); ASSERT((GetStyle() & LVS_OWNERDATA)==0); return (BOOL) ::SendMessage(m_hWnd, LVM_SORTITEMS, dwData, (LPARAM)pfnCompare); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pfnCompare$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _dwData$[ebp]
  0000e	51		 push	 ecx
  0000f	68 30 10 00 00	 push	 4144			; 00001030H
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?SortItems@CListCtrl@@QAEHP6GHJJJ@ZK@Z ENDP		; CListCtrl::SortItems
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxcmn2.inl
_TEXT	ENDS
;	COMDAT ?SubItemHitTest@CListCtrl@@QAEHPAUtagLVHITTESTINFO@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pInfo$ = 8						; size = 4
?SubItemHitTest@CListCtrl@@QAEHPAUtagLVHITTESTINFO@@@Z PROC NEAR ; CListCtrl::SubItemHitTest, COMDAT
; _this$ = ecx

; 123  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_SUBITEMHITTEST, 0, (LPARAM) pInfo); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pInfo$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	68 39 10 00 00	 push	 4153			; 00001039H
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00018	52		 push	 edx
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?SubItemHitTest@CListCtrl@@QAEHPAUtagLVHITTESTINFO@@@Z ENDP ; CListCtrl::SubItemHitTest
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z PROC NEAR ; std::_Ptr_cat, COMDAT

; 335  : 	{	// return pointer category from pointer to int arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 336  : 	_Scalar_ptr_iterator_tag _Cat;
; 337  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 338  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ENDP ; std::_Ptr_cat
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 28   : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202921 DD	0ffffffffH
	DD	FLAT:$L202916
$T202919 DD	019930520H
	DD	01H
	DD	FLAT:$T202921
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 20   : 		}

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202916:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202919
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102266
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102266:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202933 DD	0ffffffffH
	DD	FLAT:$L202928
$T202931 DD	019930520H
	DD	01H
	DD	FLAT:$T202933
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202928:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202931
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102332
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102332:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:NEAR		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@A@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 118  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7out_of_range@std@@6B@

; 119  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC NEAR			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 122  : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7out_of_range@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC NEAR		; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1out_of_range@std@@UAE@XZ ; std::out_of_range::~out_of_range
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102354
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102354:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\basicskinwnd.h
_TEXT	ENDS
;	COMDAT ??1CBasicSkinWnd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CBasicSkinWnd@@UAE@XZ PROC NEAR			; CBasicSkinWnd::~CBasicSkinWnd, COMDAT
; _this$ = ecx

; 7    : 	virtual ~CBasicSkinWnd(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBasicSkinWnd@@6B@
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1CBasicSkinWnd@@UAE@XZ ENDP				; CBasicSkinWnd::~CBasicSkinWnd
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCBasicSkinWnd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCBasicSkinWnd@@UAEPAXI@Z PROC NEAR			; CBasicSkinWnd::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CBasicSkinWnd@@UAE@XZ ; CBasicSkinWnd::~CBasicSkinWnd
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L107858
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L107858:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCBasicSkinWnd@@UAEPAXI@Z ENDP			; CBasicSkinWnd::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC NEAR		; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7out_of_range@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202963 DD	0ffffffffH
	DD	FLAT:$L202958
$T202961 DD	019930520H
	DD	01H
	DD	FLAT:$T202963
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0003f	52		 push	 edx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202958:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202961
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC NEAR			; std::swap<char>, COMDAT

; 14   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 15   : 	_Ty _Tmp = _Left;

  00004	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00007	8a 08		 mov	 cl, BYTE PTR [eax]
  00009	88 4d ff	 mov	 BYTE PTR __Tmp$[ebp], cl

; 16   : 	_Left = _Right, _Right = _Tmp;

  0000c	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00012	8a 08		 mov	 cl, BYTE PTR [eax]
  00014	88 0a		 mov	 BYTE PTR [edx], cl
  00016	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00019	8a 45 ff	 mov	 al, BYTE PTR __Tmp$[ebp]
  0001c	88 02		 mov	 BYTE PTR [edx], al

; 17   : 	}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
END
