; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\Gui\tray\Trayicon.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ?HookWindow@CSubclassWnd@@QAEHPAVCWnd@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMenuXPItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMenuXPItem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMenuXPItem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMenuXPText@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMenuXPText@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMenuXPSeparator@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMenuXPSeparator@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMenuXPSideBar@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMenuXPSideBar@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMenuXPButton@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMenuXPButton@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1BCMenuMemDC@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GBCMenuMemDC@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CShowMenu@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAtlStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAtlStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringW@?$ChTraitsOS@_W@ATL@@KGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExW@?$ChTraitsOS@_W@ATL@@KGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiW@?$ChTraitsOS@_W@ATL@@KGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerW@?$ChTraitsOS@_W@ATL@@KGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperW@?$ChTraitsOS@_W@ATL@@KGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strchr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strrchr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strrev@?$ChTraitsOS@_W@ATL@@SAPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strstr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strspn@?$ChTraitsOS@_W@ATL@@SAHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strcspn@?$ChTraitsOS@_W@ATL@@SAHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strpbrk@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E5
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??_GCTrayIcon@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTrayHook@CTrayIcon@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CTrayHook@CTrayIcon@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCTrayHook@CTrayIcon@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCShowMenu@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CArray@HAAH@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CArray@HAAH@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlAlignUp@H@ATL@@YGHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CArray@HAAH@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSize@?$CArray@HAAH@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$SerializeElements@H@@YGXAAVCArchive@@PAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CMenuXPSeparator@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@HAAH@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CMenuXPText@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CMenuXPItem@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3BCMenuMemDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CTrayHook@CTrayIcon@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CTrayIcon@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CMenuXPButton@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CMenuXPSideBar@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CMenuXPSeparator@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@HAAH@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CMenuXPText@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CMenuXPItem@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2BCMenuMemDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CTrayHook@CTrayIcon@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CTrayIcon@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CMenuXPButton@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CMenuXPSideBar@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMenuXPSeparator@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$CArray@HAAH@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMenuXPText@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUIAtlStringMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCDC@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@BCMenuMemDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSubclassWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTrayHook@CTrayIcon@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CCmdTarget@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CTrayIcon@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMenuXPButton@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMenuXPItem@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMenuXPSideBar@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCMenuXPSeparator@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$CArray@HAAH@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCMenuXPText@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCAtlStringMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVBCMenuMemDC@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCSubclassWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCTrayHook@CTrayIcon@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCTrayIcon@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCMenuXPButton@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCMenuXPItem@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCMenuXPSideBar@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CMenuXPSeparator@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$CArray@HAAH@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CMenuXPText@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CAtlStringMgr@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CMenuXPItem@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?Escape@CDC@@UAEHHHPBDPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrayStringA@CDC@@UAEHPAVCBrush@@P6GHPAUHDC__@@JH@ZJHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHandle@CGdiObject@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawTextExA@CDC@@UAEHPADHPAUtagRECT@@IPAUtagDRAWTEXTPARAMS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawTextA@CDC@@UAEHPBDHPAUtagRECT@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TabbedTextOutA@CDC@@UAE?AVCSize@@HHPBDHHPAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtTextOutA@CDC@@UAEHHHIPBUtagRECT@@PBDIPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TextOutA@CDC@@UAEHHHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RectVisible@CDC@@UBEHPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PtVisible@CDC@@UBEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4BCMenuMemDC@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CTrayHook@CTrayIcon@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4CTrayIcon@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CMenuXPButton@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CMenuXPSideBar@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CArchive@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CArray@HAAH@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CTrayHook@CTrayIcon@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CTrayIcon@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?classCTrayIcon@CTrayIcon@@2UCRuntimeClass@@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNilStringData@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CAtlStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCompatibleBitmap@CBitmap@@QAEHPAVCDC@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPrinting@CDC@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyRect@CRect@@QAEXPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBitmap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBitmap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CBitmap@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCBitmap@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GCBitmap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBitmap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7BCMenuMemDC@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMenuXPButton@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMenuXPSideBar@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMenuXPSeparator@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMenuXPText@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMenuXPItem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AfxGetApp@@YGPAVCWinApp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadIconA@CWinApp@@QBEPAUHICON__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_strthunks@ATL@@3U_AtlStringThunks@1@A		; ATL::_strthunks
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
PUBLIC	?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWThunk
PUBLIC	?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z	; ATL::CompareStringWThunk
PUBLIC	?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWThunk
PUBLIC	?lstrcmpiWThunk@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWThunk
PUBLIC	?CharLowerWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWThunk
PUBLIC	?CharUpperWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWThunk
PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
PUBLIC	?classCTrayIcon@CTrayIcon@@2UCRuntimeClass@@B	; CTrayIcon::classCTrayIcon
EXTRN	?GetThisClass@CCmdTarget@@SGPAUCRuntimeClass@@XZ:NEAR ; CCmdTarget::GetThisClass
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
CONST	ENDS
CONST	SEGMENT
$SG200458 DB	'TaskbarCreated', 00H
	ORG $+1
$SG200460 DB	'CTrayIcon', 00H
CONST	ENDS
;	COMDAT ?classCTrayIcon@CTrayIcon@@2UCRuntimeClass@@B
CONST	SEGMENT
?classCTrayIcon@CTrayIcon@@2UCRuntimeClass@@B DD FLAT:$SG200460 ; CTrayIcon::classCTrayIcon
	DD	030cH
	DD	0ffffH
	DD	00H
	DD	FLAT:?GetThisClass@CCmdTarget@@SGPAUCRuntimeClass@@XZ
	DD	00H
	DD	00H
CONST	ENDS
CONST	SEGMENT
	ORG $+2
$SG200513 DB	'%s', 00H
$SG200533 DB	00H
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT
?_strthunks@ATL@@3U_AtlStringThunks@1@A DD FLAT:?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ; ATL::_strthunks
	DD	FLAT:?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
	DD	FLAT:?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
	DD	FLAT:?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_DATA	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -160						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

  00011	c7 85 60 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _ver$[ebp], 148 ; 00000094H

; 139  : 	::GetVersionEx( &ver );

  0001b	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _ver$[ebp]
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00028	83 bd 70 ff ff
	ff 02		 cmp	 DWORD PTR _ver$[ebp+16], 2
  0002f	75 15		 jne	 SHORT $L24173
  00031	83 bd 64 ff ff
	ff 05		 cmp	 DWORD PTR _ver$[ebp+4], 5
  00038	72 0c		 jb	 SHORT $L24173

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  0003a	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

  00044	eb 0a		 jmp	 SHORT $L24174
$L24173:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00046	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L24174:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  00050	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pfnGetThreadACP$[ebp]
  00056	51		 push	 ecx
  00057	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0005c	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pNew$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pp$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 93   : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$24161 = -24					; size = 4
_lcidThread$ = -20					; size = 4
_szACP$ = -16						; size = 7
__$ArrayPad$ = -8					; size = 4
_nACP$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0
  0001b	89 45 ec	 mov	 DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  0001e	6a 07		 push	 7
  00020	8d 45 f0	 lea	 eax, DWORD PTR _szACP$[ebp]
  00023	50		 push	 eax
  00024	68 04 10 00 00	 push	 4100			; 00001004H
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _lcidThread$[ebp]
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00033	85 c0		 test	 eax, eax
  00035	74 34		 je	 SHORT $L24160

; 111  : 	{
; 112  : 		char* pch = szACP;

  00037	8d 55 f0	 lea	 edx, DWORD PTR _szACP$[ebp]
  0003a	89 55 e8	 mov	 DWORD PTR _pch$24161[ebp], edx
$L24163:

; 113  : 		while (*pch != '\0')

  0003d	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00040	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00043	85 c9		 test	 ecx, ecx
  00045	74 24		 je	 SHORT $L24160

; 114  : 		{
; 115  : 			nACP *= 10;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  0004a	6b d2 0a	 imul	 edx, 10			; 0000000aH
  0004d	89 55 fc	 mov	 DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

  00050	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  00059	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  0005d	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
  00060	8b 4d e8	 mov	 ecx, DWORD PTR _pch$24161[ebp]
  00063	83 c1 01	 add	 ecx, 1
  00066	89 4d e8	 mov	 DWORD PTR _pch$24161[ebp], ecx

; 117  : 		}

  00069	eb d2		 jmp	 SHORT $L24163
$L24160:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  0006b	83 7d fc 00	 cmp	 DWORD PTR _nACP$[ebp], 0
  0006f	75 09		 jne	 SHORT $L24165

; 121  : 		nACP = ::GetACP();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  00077	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
$L24165:

; 122  : 
; 123  : 	return nACP;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _nACP$[ebp]

; 124  : }

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  : 	return( CP_THREAD_ACP );

  00003	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
PUBLIC	?GetThisClass@CTrayIcon@@SGPAUCRuntimeClass@@XZ	; CTrayIcon::GetThisClass
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\tray\trayicon.cpp
_TEXT	SEGMENT
?GetThisClass@CTrayIcon@@SGPAUCRuntimeClass@@XZ PROC NEAR ; CTrayIcon::GetThisClass

; 26   : IMPLEMENT_DYNAMIC(CTrayIcon, CCmdTarget)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?classCTrayIcon@CTrayIcon@@2UCRuntimeClass@@B ; CTrayIcon::classCTrayIcon
  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetThisClass@CTrayIcon@@SGPAUCRuntimeClass@@XZ ENDP	; CTrayIcon::GetThisClass
_TEXT	ENDS
PUBLIC	?GetRuntimeClass@CTrayIcon@@UBEPAUCRuntimeClass@@XZ ; CTrayIcon::GetRuntimeClass
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRuntimeClass@CTrayIcon@@UBEPAUCRuntimeClass@@XZ PROC NEAR ; CTrayIcon::GetRuntimeClass
; _this$ = ecx

; 26   : IMPLEMENT_DYNAMIC(CTrayIcon, CCmdTarget)

  00010	55		 push	 ebp
  00011	8b ec		 mov	 ebp, esp
  00013	51		 push	 ecx
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?classCTrayIcon@CTrayIcon@@2UCRuntimeClass@@B ; CTrayIcon::classCTrayIcon
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?GetRuntimeClass@CTrayIcon@@UBEPAUCRuntimeClass@@XZ ENDP ; CTrayIcon::GetRuntimeClass
_TEXT	ENDS
PUBLIC	??_R4CTrayIcon@@6B@				; CTrayIcon::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTrayIcon@@@8				; CTrayIcon `RTTI Type Descriptor'
PUBLIC	??_R3CTrayIcon@@8				; CTrayIcon::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTrayIcon@@8				; CTrayIcon::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CTrayIcon@@8			; CTrayIcon::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CCmdTarget@@8			; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCCmdTarget@@@8				; CCmdTarget `RTTI Type Descriptor'
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	??0CTrayIcon@@QAE@I@Z				; CTrayIcon::CTrayIcon
PUBLIC	?OnTrayNotify@CTrayIcon@@UAEJIJ@Z		; CTrayIcon::OnTrayNotify
PUBLIC	?OnTaskBarCreate@CTrayIcon@@UAEJIJ@Z		; CTrayIcon::OnTaskBarCreate
PUBLIC	??0CTrayHook@CTrayIcon@@QAE@XZ			; CTrayIcon::CTrayHook::CTrayHook
PUBLIC	??1CTrayHook@CTrayIcon@@UAE@XZ			; CTrayIcon::CTrayHook::~CTrayHook
PUBLIC	??_7CTrayIcon@@6B@				; CTrayIcon::`vftable'
PUBLIC	??_GCTrayIcon@@UAEPAXI@Z			; CTrayIcon::`scalar deleting destructor'
EXTRN	?AfxLoadString@@YGHIPADI@Z:NEAR			; AfxLoadString
EXTRN	??0CCmdTarget@@QAE@XZ:NEAR			; CCmdTarget::CCmdTarget
EXTRN	?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:NEAR ; CCmdTarget::OnCmdMsg
EXTRN	?OnFinalRelease@CCmdTarget@@UAEXXZ:NEAR		; CCmdTarget::OnFinalRelease
EXTRN	?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z:NEAR	; CCmdTarget::IsInvokeAllowed
EXTRN	?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z:NEAR ; CCmdTarget::GetDispatchIID
EXTRN	?GetTypeInfoCount@CCmdTarget@@UAEIXZ:NEAR	; CCmdTarget::GetTypeInfoCount
EXTRN	?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ:NEAR ; CCmdTarget::GetTypeLibCache
EXTRN	?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z:NEAR ; CCmdTarget::GetTypeLib
EXTRN	??1CCmdTarget@@UAE@XZ:NEAR			; CCmdTarget::~CCmdTarget
EXTRN	?GetMessageMap@CCmdTarget@@MBEPBUAFX_MSGMAP@@XZ:NEAR ; CCmdTarget::GetMessageMap
EXTRN	?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ:NEAR ; CCmdTarget::GetCommandMap
EXTRN	?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ:NEAR ; CCmdTarget::GetDispatchMap
EXTRN	?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ:NEAR ; CCmdTarget::GetConnectionMap
EXTRN	?GetInterfaceMap@CCmdTarget@@MBEPBUAFX_INTERFACEMAP@@XZ:NEAR ; CCmdTarget::GetInterfaceMap
EXTRN	?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ:NEAR ; CCmdTarget::GetEventSinkMap
EXTRN	?OnCreateAggregates@CCmdTarget@@UAEHXZ:NEAR	; CCmdTarget::OnCreateAggregates
EXTRN	?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z:NEAR ; CCmdTarget::GetInterfaceHook
EXTRN	?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z:NEAR ; CCmdTarget::GetExtraConnectionPoints
EXTRN	?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z:NEAR ; CCmdTarget::GetConnectionHook
EXTRN	_memset:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??0CTrayIconPosition@@QAE@XZ:NEAR		; CTrayIconPosition::CTrayIconPosition
EXTRN	??1CTrayIconPosition@@UAE@XZ:NEAR		; CTrayIconPosition::~CTrayIconPosition
EXTRN	??_ECTrayIcon@@UAEPAXI@Z:NEAR			; CTrayIcon::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
xdata$x	SEGMENT
$T201501 DD	0ffffffffH
	DD	FLAT:$L201491
	DD	00H
	DD	FLAT:$L201492
	DD	01H
	DD	FLAT:$L201493
	DD	02H
	DD	FLAT:$L201494
$T201498 DD	019930520H
	DD	04H
	DD	FLAT:$T201501
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CTrayIcon@@6B@
CONST	SEGMENT
??_7CTrayIcon@@6B@ DD FLAT:??_R4CTrayIcon@@6B@		; CTrayIcon::`vftable'
	DD	FLAT:?GetRuntimeClass@CTrayIcon@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECTrayIcon@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CCmdTarget@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CCmdTarget@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CCmdTarget@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?OnTrayNotify@CTrayIcon@@UAEJIJ@Z
	DD	FLAT:?OnTaskBarCreate@CTrayIcon@@UAEJIJ@Z
CONST	ENDS
;	COMDAT ??_R4CTrayIcon@@6B@
rdata$r	SEGMENT
??_R4CTrayIcon@@6B@ DD 00H				; CTrayIcon::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTrayIcon@@@8
	DD	FLAT:??_R3CTrayIcon@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTrayIcon@@@8
_DATA	SEGMENT
??_R0?AVCTrayIcon@@@8 DD FLAT:??_7type_info@@6B@	; CTrayIcon `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTrayIcon@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CTrayIcon@@8
rdata$r	SEGMENT
??_R3CTrayIcon@@8 DD 00H				; CTrayIcon::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CTrayIcon@@8
rdata$r	ENDS
;	COMDAT ??_R2CTrayIcon@@8
rdata$r	SEGMENT
??_R2CTrayIcon@@8 DD FLAT:??_R1A@?0A@A@CTrayIcon@@8	; CTrayIcon::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTrayIcon@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CTrayIcon@@8 DD FLAT:??_R0?AVCTrayIcon@@@8	; CTrayIcon::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCmdTarget@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CCmdTarget@@8 DD FLAT:??_R0?AVCCmdTarget@@@8 ; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
_DATA	SEGMENT
??_R0?AVCCmdTarget@@@8 DD FLAT:??_7type_info@@6B@	; CCmdTarget `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCmdTarget@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_uID$ = 8						; size = 4
??0CTrayIcon@@QAE@I@Z PROC NEAR				; CTrayIcon::CTrayIcon
; _this$ = ecx

; 29   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	6a ff		 push	 -1
  00025	68 00 00 00 00	 push	 __ehhandler$??0CTrayIcon@@QAE@I@Z
  0002a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00030	50		 push	 eax
  00031	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00038	51		 push	 ecx
  00039	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ??0CCmdTarget@@QAE@XZ	; CCmdTarget::CCmdTarget
  00044	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTrayIcon@@6B@
  00054	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	83 c1 24	 add	 ecx, 36			; 00000024H
  0005a	e8 00 00 00 00	 call	 ??0CTrayIconPosition@@QAE@XZ ; CTrayIconPosition::CTrayIconPosition
  0005f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	81 c1 e0 02 00
	00		 add	 ecx, 736		; 000002e0H
  0006c	e8 00 00 00 00	 call	 ??0CTrayHook@CTrayIcon@@QAE@XZ
  00071	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00075	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	81 c1 f4 02 00
	00		 add	 ecx, 756		; 000002f4H
  0007e	e8 00 00 00 00	 call	 ??0CTrayHook@CTrayIcon@@QAE@XZ
  00083	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 30   : 	// Initialize NOTIFYICONDATA
; 31   : 	memset(&m_nid, 0 , sizeof(m_nid));

  00087	68 e8 01 00 00	 push	 488			; 000001e8H
  0008c	6a 00		 push	 0
  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	81 c1 f8 00 00
	00		 add	 ecx, 248		; 000000f8H
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 _memset
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32   : 	m_nid.cbSize = sizeof(m_nid);

  000a0	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	c7 82 f8 00 00
	00 e8 01 00 00	 mov	 DWORD PTR [edx+248], 488 ; 000001e8H

; 33   : 	m_nid.uID = uID;	// never changes after construction

  000ad	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _uID$[ebp]
  000b3	89 88 00 01 00
	00		 mov	 DWORD PTR [eax+256], ecx

; 34   : 
; 35   : 	m_notifyHook.m_pTrayIcon = this; // notification window hook

  000b9	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000bc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	89 82 f0 02 00
	00		 mov	 DWORD PTR [edx+752], eax

; 36   : 	m_parentHook.m_pTrayIcon = this;	// parent window hook

  000c5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000cb	89 91 04 03 00
	00		 mov	 DWORD PTR [ecx+772], edx

; 37   : 	m_bDbClicked = false;

  000d1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	c6 80 08 03 00
	00 00		 mov	 BYTE PTR [eax+776], 0

; 38   : 	m_bRClick = false;

  000db	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	c6 81 09 03 00
	00 00		 mov	 BYTE PTR [ecx+777], 0

; 39   : 	m_pMenu = NULL;

  000e5	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000e8	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 40   : 	// Use resource string as tip if there is one
; 41   : 	AfxLoadString(uID, m_nid.szTip, sizeof(m_nid.szTip));	

  000ef	68 80 00 00 00	 push	 128			; 00000080H
  000f4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	05 10 01 00 00	 add	 eax, 272		; 00000110H
  000fc	50		 push	 eax
  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _uID$[ebp]
  00100	51		 push	 ecx
  00101	e8 00 00 00 00	 call	 ?AfxLoadString@@YGHIPADI@Z ; AfxLoadString

; 42   : }

  00106	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0010d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00110	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00113	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L201491:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CCmdTarget@@UAE@XZ	; CCmdTarget::~CCmdTarget
$L201492:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 24	 add	 ecx, 36			; 00000024H
  0000e	e9 00 00 00 00	 jmp	 ??1CTrayIconPosition@@UAE@XZ ; CTrayIconPosition::~CTrayIconPosition
$L201493:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	81 c1 e0 02 00
	00		 add	 ecx, 736		; 000002e0H
  0001c	e9 00 00 00 00	 jmp	 ??1CTrayHook@CTrayIcon@@UAE@XZ
$L201494:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 f4 02 00
	00		 add	 ecx, 756		; 000002f4H
  0002a	e9 00 00 00 00	 jmp	 ??1CTrayHook@CTrayIcon@@UAE@XZ
__ehhandler$??0CTrayIcon@@QAE@I@Z:
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201498
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CTrayIcon@@QAE@I@Z ENDP				; CTrayIcon::CTrayIcon
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
PUBLIC	??1CTrayIcon@@UAE@XZ				; CTrayIcon::~CTrayIcon
; Function compile flags: /Odt
;	COMDAT ??_GCTrayIcon@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTrayIcon@@UAEPAXI@Z PROC NEAR			; CTrayIcon::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTrayIcon@@UAE@XZ	; CTrayIcon::~CTrayIcon
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L200476
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L200476:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCTrayIcon@@UAEPAXI@Z ENDP				; CTrayIcon::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4CTrayHook@CTrayIcon@@6B@			; CTrayIcon::CTrayHook::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTrayHook@CTrayIcon@@@8			; CTrayIcon::CTrayHook `RTTI Type Descriptor'
PUBLIC	??_R3CTrayHook@CTrayIcon@@8			; CTrayIcon::CTrayHook::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTrayHook@CTrayIcon@@8			; CTrayIcon::CTrayHook::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CTrayHook@CTrayIcon@@8		; CTrayIcon::CTrayHook::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@CSubclassWnd@@8			; CSubclassWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCSubclassWnd@@@8			; CSubclassWnd `RTTI Type Descriptor'
PUBLIC	?WindowProc@CTrayHook@CTrayIcon@@EAEJIIJ@Z	; CTrayIcon::CTrayHook::WindowProc
PUBLIC	??_7CTrayHook@CTrayIcon@@6B@			; CTrayIcon::CTrayHook::`vftable'
PUBLIC	??_GCTrayHook@CTrayIcon@@UAEPAXI@Z		; CTrayIcon::CTrayHook::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CSubclassWnd@@UBEPAUCRuntimeClass@@XZ:NEAR ; CSubclassWnd::GetRuntimeClass
EXTRN	??0CSubclassWnd@@QAE@XZ:NEAR			; CSubclassWnd::CSubclassWnd
EXTRN	??_ECTrayHook@CTrayIcon@@UAEPAXI@Z:NEAR		; CTrayIcon::CTrayHook::`vector deleting destructor'
;	COMDAT ??_7CTrayHook@CTrayIcon@@6B@
CONST	SEGMENT
??_7CTrayHook@CTrayIcon@@6B@ DD FLAT:??_R4CTrayHook@CTrayIcon@@6B@ ; CTrayIcon::CTrayHook::`vftable'
	DD	FLAT:?GetRuntimeClass@CSubclassWnd@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECTrayHook@CTrayIcon@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?WindowProc@CTrayHook@CTrayIcon@@EAEJIIJ@Z
CONST	ENDS
;	COMDAT ??_R4CTrayHook@CTrayIcon@@6B@
rdata$r	SEGMENT
??_R4CTrayHook@CTrayIcon@@6B@ DD 00H			; CTrayIcon::CTrayHook::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTrayHook@CTrayIcon@@@8
	DD	FLAT:??_R3CTrayHook@CTrayIcon@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTrayHook@CTrayIcon@@@8
_DATA	SEGMENT
??_R0?AVCTrayHook@CTrayIcon@@@8 DD FLAT:??_7type_info@@6B@ ; CTrayIcon::CTrayHook `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTrayHook@CTrayIcon@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CTrayHook@CTrayIcon@@8
rdata$r	SEGMENT
??_R3CTrayHook@CTrayIcon@@8 DD 00H			; CTrayIcon::CTrayHook::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CTrayHook@CTrayIcon@@8
rdata$r	ENDS
;	COMDAT ??_R2CTrayHook@CTrayIcon@@8
rdata$r	SEGMENT
??_R2CTrayHook@CTrayIcon@@8 DD FLAT:??_R1A@?0A@A@CTrayHook@CTrayIcon@@8 ; CTrayIcon::CTrayHook::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CSubclassWnd@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTrayHook@CTrayIcon@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CTrayHook@CTrayIcon@@8 DD FLAT:??_R0?AVCTrayHook@CTrayIcon@@@8 ; CTrayIcon::CTrayHook::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSubclassWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CSubclassWnd@@8 DD FLAT:??_R0?AVCSubclassWnd@@@8 ; CSubclassWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCSubclassWnd@@@8
_DATA	SEGMENT
??_R0?AVCSubclassWnd@@@8 DD FLAT:??_7type_info@@6B@	; CSubclassWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSubclassWnd@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0CTrayHook@CTrayIcon@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CTrayHook@CTrayIcon@@QAE@XZ PROC NEAR		; CTrayIcon::CTrayHook::CTrayHook, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CSubclassWnd@@QAE@XZ	; CSubclassWnd::CSubclassWnd
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTrayHook@CTrayIcon@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CTrayHook@CTrayIcon@@QAE@XZ ENDP			; CTrayIcon::CTrayHook::CTrayHook
_TEXT	ENDS
EXTRN	??1CSubclassWnd@@UAE@XZ:NEAR			; CSubclassWnd::~CSubclassWnd
; Function compile flags: /Odt
;	COMDAT ??1CTrayHook@CTrayIcon@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CTrayHook@CTrayIcon@@UAE@XZ PROC NEAR		; CTrayIcon::CTrayHook::~CTrayHook, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CSubclassWnd@@UAE@XZ	; CSubclassWnd::~CSubclassWnd
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CTrayHook@CTrayIcon@@UAE@XZ ENDP			; CTrayIcon::CTrayHook::~CTrayHook
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCTrayHook@CTrayIcon@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTrayHook@CTrayIcon@@UAEPAXI@Z PROC NEAR		; CTrayIcon::CTrayHook::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTrayHook@CTrayIcon@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L200484
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L200484:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCTrayHook@CTrayIcon@@UAEPAXI@Z ENDP			; CTrayIcon::CTrayHook::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?SetIcon@CTrayIcon@@QAEHI@Z			; CTrayIcon::SetIcon
xdata$x	SEGMENT
$T201521 DD	0ffffffffH
	DD	FLAT:$L201514
	DD	00H
	DD	FLAT:$L201515
	DD	01H
	DD	FLAT:$L201516
	DD	02H
	DD	FLAT:$L201517
$T201519 DD	019930520H
	DD	04H
	DD	FLAT:$T201521
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CTrayIcon@@UAE@XZ PROC NEAR				; CTrayIcon::~CTrayIcon
; _this$ = ecx

; 45   : {

  00120	55		 push	 ebp
  00121	8b ec		 mov	 ebp, esp
  00123	6a ff		 push	 -1
  00125	68 00 00 00 00	 push	 __ehhandler$??1CTrayIcon@@UAE@XZ
  0012a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00130	50		 push	 eax
  00131	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00138	51		 push	 ecx
  00139	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0013c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0013f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTrayIcon@@6B@
  00145	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 46   : 	SetIcon(0); // remove icon from system tray

  0014c	6a 00		 push	 0
  0014e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?SetIcon@CTrayIcon@@QAEHI@Z ; CTrayIcon::SetIcon

; 47   : }

  00156	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0015a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015d	81 c1 f4 02 00
	00		 add	 ecx, 756		; 000002f4H
  00163	e8 00 00 00 00	 call	 ??1CTrayHook@CTrayIcon@@UAE@XZ
  00168	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0016c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	81 c1 e0 02 00
	00		 add	 ecx, 736		; 000002e0H
  00175	e8 00 00 00 00	 call	 ??1CTrayHook@CTrayIcon@@UAE@XZ
  0017a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0017e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	83 c1 24	 add	 ecx, 36			; 00000024H
  00184	e8 00 00 00 00	 call	 ??1CTrayIconPosition@@UAE@XZ ; CTrayIconPosition::~CTrayIconPosition
  00189	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00190	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	e8 00 00 00 00	 call	 ??1CCmdTarget@@UAE@XZ	; CCmdTarget::~CCmdTarget
  00198	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0019b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L201514:
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e9 00 00 00 00	 jmp	 ??1CCmdTarget@@UAE@XZ	; CCmdTarget::~CCmdTarget
$L201515:
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	83 c1 24	 add	 ecx, 36			; 00000024H
  00047	e9 00 00 00 00	 jmp	 ??1CTrayIconPosition@@UAE@XZ ; CTrayIconPosition::~CTrayIconPosition
$L201516:
  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	81 c1 e0 02 00
	00		 add	 ecx, 736		; 000002e0H
  00055	e9 00 00 00 00	 jmp	 ??1CTrayHook@CTrayIcon@@UAE@XZ
$L201517:
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	81 c1 f4 02 00
	00		 add	 ecx, 756		; 000002f4H
  00063	e9 00 00 00 00	 jmp	 ??1CTrayHook@CTrayIcon@@UAE@XZ
__ehhandler$??1CTrayIcon@@UAE@XZ:
  00068	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201519
  0006d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CTrayIcon@@UAE@XZ ENDP				; CTrayIcon::~CTrayIcon
PUBLIC	?HookWindow@CSubclassWnd@@QAEHPAVCWnd@@@Z	; CSubclassWnd::HookWindow
PUBLIC	?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ		; CWnd::GetSafeHwnd
PUBLIC	?SetNotificationWnd@CTrayIcon@@QAEXPAVCWnd@@I@Z	; CTrayIcon::SetNotificationWnd
EXTRN	?InitializePositionTracking@CTrayIconPosition@@QAEXPAUHWND__@@H@Z:NEAR ; CTrayIconPosition::InitializePositionTracking
EXTRN	?GetTopLevelParent@CWnd@@QBEPAV1@XZ:NEAR	; CWnd::GetTopLevelParent
; Function compile flags: /Odt
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
_pParentWnd$ = -4					; size = 4
_pNotifyWnd$ = 8					; size = 4
_uCbMsg$ = 12						; size = 4
?SetNotificationWnd@CTrayIcon@@QAEXPAVCWnd@@I@Z PROC NEAR ; CTrayIcon::SetNotificationWnd
; _this$ = ecx

; 53   : {

  001b0	55		 push	 ebp
  001b1	8b ec		 mov	 ebp, esp
  001b3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001b6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 54   : 	// If the following assert fails, you're probably
; 55   : 	// calling me before you created your window. Oops.
; 56   : 	ASSERT(pNotifyWnd==NULL || ::IsWindow(pNotifyWnd->GetSafeHwnd()));
; 57   : 	m_nid.hWnd = pNotifyWnd->GetSafeHwnd();

  001b9	8b 4d 08	 mov	 ecx, DWORD PTR _pNotifyWnd$[ebp]
  001bc	e8 00 00 00 00	 call	 ?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ ; CWnd::GetSafeHwnd
  001c1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c4	89 81 fc 00 00
	00		 mov	 DWORD PTR [ecx+252], eax

; 58   : 
; 59   : 	ASSERT(uCbMsg==0 || uCbMsg>=WM_USER);
; 60   : 	m_nid.uCallbackMessage = uCbMsg;

  001ca	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001cd	8b 45 0c	 mov	 eax, DWORD PTR _uCbMsg$[ebp]
  001d0	89 82 08 01 00
	00		 mov	 DWORD PTR [edx+264], eax

; 61   : 
; 62   : 	CWnd* pParentWnd = pNotifyWnd ? pNotifyWnd->GetTopLevelParent() : NULL;

  001d6	83 7d 08 00	 cmp	 DWORD PTR _pNotifyWnd$[ebp], 0
  001da	74 0d		 je	 SHORT $L201523
  001dc	8b 4d 08	 mov	 ecx, DWORD PTR _pNotifyWnd$[ebp]
  001df	e8 00 00 00 00	 call	 ?GetTopLevelParent@CWnd@@QBEPAV1@XZ ; CWnd::GetTopLevelParent
  001e4	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  001e7	eb 07		 jmp	 SHORT $L201524
$L201523:
  001e9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$L201524:
  001f0	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  001f3	89 4d fc	 mov	 DWORD PTR _pParentWnd$[ebp], ecx

; 63   : 
; 64   : 	// Install window hooks. Must be different because
; 65   : 	// taskbar creation message only goes to top-level parent.
; 66   : 	m_notifyHook.HookWindow(pNotifyWnd);

  001f6	8b 55 08	 mov	 edx, DWORD PTR _pNotifyWnd$[ebp]
  001f9	52		 push	 edx
  001fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fd	81 c1 e0 02 00
	00		 add	 ecx, 736		; 000002e0H
  00203	e8 00 00 00 00	 call	 ?HookWindow@CSubclassWnd@@QAEHPAVCWnd@@@Z ; CSubclassWnd::HookWindow

; 67   : 	if (pParentWnd!=pNotifyWnd)

  00208	8b 45 fc	 mov	 eax, DWORD PTR _pParentWnd$[ebp]
  0020b	3b 45 08	 cmp	 eax, DWORD PTR _pNotifyWnd$[ebp]
  0020e	74 12		 je	 SHORT $L200496

; 68   : 		m_parentHook.HookWindow(pParentWnd);

  00210	8b 4d fc	 mov	 ecx, DWORD PTR _pParentWnd$[ebp]
  00213	51		 push	 ecx
  00214	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00217	81 c1 f4 02 00
	00		 add	 ecx, 756		; 000002f4H
  0021d	e8 00 00 00 00	 call	 ?HookWindow@CSubclassWnd@@QAEHPAVCWnd@@@Z ; CSubclassWnd::HookWindow
$L200496:

; 69   : 	m_tipPosition.InitializePositionTracking(m_nid.hWnd,m_nid.uID);

  00222	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00225	8b 82 00 01 00
	00		 mov	 eax, DWORD PTR [edx+256]
  0022b	50		 push	 eax
  0022c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0022f	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  00235	52		 push	 edx
  00236	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00239	83 c1 24	 add	 ecx, 36			; 00000024H
  0023c	e8 00 00 00 00	 call	 ?InitializePositionTracking@CTrayIconPosition@@QAEXPAUHWND__@@H@Z ; CTrayIconPosition::InitializePositionTracking

; 70   : }

  00241	8b e5		 mov	 esp, ebp
  00243	5d		 pop	 ebp
  00244	c2 08 00	 ret	 8
?SetNotificationWnd@CTrayIcon@@QAEXPAVCWnd@@I@Z ENDP	; CTrayIcon::SetNotificationWnd
_TEXT	ENDS
EXTRN	?HookWindow@CSubclassWnd@@QAEHPAUHWND__@@@Z:NEAR ; CSubclassWnd::HookWindow
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\tray\subclass.h
;	COMDAT ?HookWindow@CSubclassWnd@@QAEHPAVCWnd@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pWnd$ = 8						; size = 4
?HookWindow@CSubclassWnd@@QAEHPAVCWnd@@@Z PROC NEAR	; CSubclassWnd::HookWindow, COMDAT
; _this$ = ecx

; 38   : 	BOOL	HookWindow(CWnd* pWnd)	{ return HookWindow(pWnd->GetSafeHwnd()); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ ; CWnd::GetSafeHwnd
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?HookWindow@CSubclassWnd@@QAEHPAUHWND__@@@Z ; CSubclassWnd::HookWindow
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?HookWindow@CSubclassWnd@@QAEHPAVCWnd@@@Z ENDP		; CSubclassWnd::HookWindow
_TEXT	ENDS
PUBLIC	?AfxGetApp@@YGPAVCWinApp@@XZ			; AfxGetApp
PUBLIC	?SetIcon@CTrayIcon@@QAEHPAUHICON__@@PBD@Z	; CTrayIcon::SetIcon
PUBLIC	?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z		; CWinApp::LoadIconA
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\tray\trayicon.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hicon$ = -4						; size = 4
_uID$ = 8						; size = 4
?SetIcon@CTrayIcon@@QAEHI@Z PROC NEAR			; CTrayIcon::SetIcon
; _this$ = ecx

; 78   : { 

  00250	55		 push	 ebp
  00251	8b ec		 mov	 ebp, esp
  00253	83 ec 08	 sub	 esp, 8
  00256	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 79   : 	HICON hicon=NULL;

  00259	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hicon$[ebp], 0

; 80   : 	if (uID) {

  00260	83 7d 08 00	 cmp	 DWORD PTR _uID$[ebp], 0
  00264	74 2a		 je	 SHORT $L200502

; 81   : 		AfxLoadString(uID, m_nid.szTip, sizeof(m_nid.szTip));

  00266	68 80 00 00 00	 push	 128			; 00000080H
  0026b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0026e	05 10 01 00 00	 add	 eax, 272		; 00000110H
  00273	50		 push	 eax
  00274	8b 4d 08	 mov	 ecx, DWORD PTR _uID$[ebp]
  00277	51		 push	 ecx
  00278	e8 00 00 00 00	 call	 ?AfxLoadString@@YGHIPADI@Z ; AfxLoadString

; 82   : 		hicon = AfxGetApp()->LoadIcon(uID);

  0027d	8b 55 08	 mov	 edx, DWORD PTR _uID$[ebp]
  00280	52		 push	 edx
  00281	e8 00 00 00 00	 call	 ?AfxGetApp@@YGPAVCWinApp@@XZ ; AfxGetApp
  00286	8b c8		 mov	 ecx, eax
  00288	e8 00 00 00 00	 call	 ?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z ; CWinApp::LoadIconA
  0028d	89 45 fc	 mov	 DWORD PTR _hicon$[ebp], eax
$L200502:

; 83   : 	}
; 84   : 	return SetIcon(hicon, NULL);

  00290	6a 00		 push	 0
  00292	8b 45 fc	 mov	 eax, DWORD PTR _hicon$[ebp]
  00295	50		 push	 eax
  00296	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00299	e8 00 00 00 00	 call	 ?SetIcon@CTrayIcon@@QAEHPAUHICON__@@PBD@Z ; CTrayIcon::SetIcon

; 85   : }

  0029e	8b e5		 mov	 esp, ebp
  002a0	5d		 pop	 ebp
  002a1	c2 04 00	 ret	 4
?SetIcon@CTrayIcon@@QAEHI@Z ENDP			; CTrayIcon::SetIcon
_TEXT	ENDS
EXTRN	__imp__Shell_NotifyIconA@8:NEAR
EXTRN	__imp___snprintf:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_bRet$ = -8						; size = 4
_msg$ = -4						; size = 4
_hicon$ = 8						; size = 4
_lpTip$ = 12						; size = 4
?SetIcon@CTrayIcon@@QAEHPAUHICON__@@PBD@Z PROC NEAR	; CTrayIcon::SetIcon
; _this$ = ecx

; 91   : {

  002b0	55		 push	 ebp
  002b1	8b ec		 mov	 ebp, esp
  002b3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  002b6	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 92   : 	UINT msg;
; 93   : 	m_nid.uFlags = 0;

  002b9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002bc	c7 80 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+260], 0

; 94   : 
; 95   : 	// Set the icon
; 96   : 	if (hicon) {

  002c6	83 7d 08 00	 cmp	 DWORD PTR _hicon$[ebp], 0
  002ca	74 35		 je	 SHORT $L200509

; 97   : 		// Add or replace icon in system tray
; 98   : 		msg = m_nid.hIcon ? NIM_MODIFY : NIM_ADD;

  002cc	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002cf	33 d2		 xor	 edx, edx
  002d1	83 b9 0c 01 00
	00 00		 cmp	 DWORD PTR [ecx+268], 0
  002d8	0f 95 c2	 setne	 dl
  002db	89 55 fc	 mov	 DWORD PTR _msg$[ebp], edx

; 99   : 		m_nid.hIcon = hicon;

  002de	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002e1	8b 4d 08	 mov	 ecx, DWORD PTR _hicon$[ebp]
  002e4	89 88 0c 01 00
	00		 mov	 DWORD PTR [eax+268], ecx

; 100  : 		m_nid.uFlags |= NIF_ICON;

  002ea	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  002ed	8b 82 04 01 00
	00		 mov	 eax, DWORD PTR [edx+260]
  002f3	83 c8 02	 or	 eax, 2
  002f6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002f9	89 81 04 01 00
	00		 mov	 DWORD PTR [ecx+260], eax

; 101  : 	} else { // remove icon from tray

  002ff	eb 1d		 jmp	 SHORT $L200510
$L200509:

; 102  : 		if (m_nid.hIcon==NULL)

  00301	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00304	83 ba 0c 01 00
	00 00		 cmp	 DWORD PTR [edx+268], 0
  0030b	75 0a		 jne	 SHORT $L200511

; 103  : 			return TRUE;		// already deleted

  0030d	b8 01 00 00 00	 mov	 eax, 1
  00312	e9 b8 00 00 00	 jmp	 $L200507
$L200511:

; 104  : 		msg = NIM_DELETE;

  00317	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _msg$[ebp], 2
$L200510:

; 105  : 	}
; 106  : 
; 107  : 	// Use the tip, if any
; 108  : 	if (lpTip)

  0031e	83 7d 0c 00	 cmp	 DWORD PTR _lpTip$[ebp], 0
  00322	74 28		 je	 SHORT $L200512

; 109  : 	{
; 110  : 		_snprintf(m_nid.szTip,countof(m_nid.szTip)-1,"%s",lpTip);

  00324	8b 45 0c	 mov	 eax, DWORD PTR _lpTip$[ebp]
  00327	50		 push	 eax
  00328	68 00 00 00 00	 push	 OFFSET FLAT:$SG200513
  0032d	6a 7f		 push	 127			; 0000007fH
  0032f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00332	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  00338	51		 push	 ecx
  00339	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  0033f	83 c4 10	 add	 esp, 16			; 00000010H

; 111  : 		m_nid.szTip[ countof(m_nid.szTip)-1 ] = '\0';

  00342	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00345	c6 82 8f 01 00
	00 00		 mov	 BYTE PTR [edx+399], 0
$L200512:

; 112  : //		_tcsncpy(m_nid.szTip, lpTip, countof(m_nid.szTip));
; 113  : 	}
; 114  : 	if (m_nid.szTip[0])

  0034c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0034f	0f be 88 10 01
	00 00		 movsx	 ecx, BYTE PTR [eax+272]
  00356	85 c9		 test	 ecx, ecx
  00358	74 15		 je	 SHORT $L200514

; 115  : 		m_nid.uFlags |= NIF_TIP;

  0035a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0035d	8b 82 04 01 00
	00		 mov	 eax, DWORD PTR [edx+260]
  00363	83 c8 04	 or	 eax, 4
  00366	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00369	89 81 04 01 00
	00		 mov	 DWORD PTR [ecx+260], eax
$L200514:

; 116  : 
; 117  : 	// Use callback if any
; 118  : 	if (m_nid.uCallbackMessage && m_nid.hWnd)

  0036f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00372	83 ba 08 01 00
	00 00		 cmp	 DWORD PTR [edx+264], 0
  00379	74 21		 je	 SHORT $L200515
  0037b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0037e	83 b8 fc 00 00
	00 00		 cmp	 DWORD PTR [eax+252], 0
  00385	74 15		 je	 SHORT $L200515

; 119  : 		m_nid.uFlags |= NIF_MESSAGE;

  00387	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0038a	8b 91 04 01 00
	00		 mov	 edx, DWORD PTR [ecx+260]
  00390	83 ca 01	 or	 edx, 1
  00393	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00396	89 90 04 01 00
	00		 mov	 DWORD PTR [eax+260], edx
$L200515:

; 120  : 
; 121  : 	// Do it
; 122  : 	BOOL bRet = Shell_NotifyIcon(msg, &m_nid);

  0039c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0039f	81 c1 f8 00 00
	00		 add	 ecx, 248		; 000000f8H
  003a5	51		 push	 ecx
  003a6	8b 55 fc	 mov	 edx, DWORD PTR _msg$[ebp]
  003a9	52		 push	 edx
  003aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Shell_NotifyIconA@8
  003b0	89 45 f8	 mov	 DWORD PTR _bRet$[ebp], eax

; 123  : 	if (msg==NIM_DELETE || !bRet)

  003b3	83 7d fc 02	 cmp	 DWORD PTR _msg$[ebp], 2
  003b7	74 06		 je	 SHORT $L200518
  003b9	83 7d f8 00	 cmp	 DWORD PTR _bRet$[ebp], 0
  003bd	75 0d		 jne	 SHORT $L200517
$L200518:

; 124  : 		m_nid.hIcon = NULL;	// failed

  003bf	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  003c2	c7 80 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+268], 0
$L200517:

; 125  : 	return bRet;

  003cc	8b 45 f8	 mov	 eax, DWORD PTR _bRet$[ebp]
$L200507:

; 126  : }

  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c2 08 00	 ret	 8
?SetIcon@CTrayIcon@@QAEHPAUHICON__@@PBD@Z ENDP		; CTrayIcon::SetIcon
_TEXT	ENDS
PUBLIC	??0CPoint@@QAE@XZ				; CPoint::CPoint
PUBLIC	?ShowTrayIconBalloon@CTrayIcon@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0I@Z ; CTrayIcon::ShowTrayIconBalloon
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	?unSHOW_CLOSE_BUTTON@CBalloonHelp@@2IB:DWORD	; CBalloonHelp::unSHOW_CLOSE_BUTTON
EXTRN	?unSHOW_TOPMOST@CBalloonHelp@@2IB:DWORD		; CBalloonHelp::unSHOW_TOPMOST
EXTRN	?unDISABLE_XP_SHADOW@CBalloonHelp@@2IB:DWORD	; CBalloonHelp::unDISABLE_XP_SHADOW
EXTRN	?LaunchBalloon@CBalloonHelp@@SAXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0ABVCPoint@@PBDIPAVCWnd@@V23@I@Z:NEAR ; CBalloonHelp::LaunchBalloon
EXTRN	__imp__GetDesktopWindow@0:NEAR
EXTRN	?GetTrayIconPosition@CTrayIconPosition@@QAEHAAVCPoint@@W4TrackType@1@W4Precision@1@@Z:NEAR ; CTrayIconPosition::GetTrayIconPosition
EXTRN	?RestoreTrayIcon@CTrayIconPosition@@QAEXPAUHICON__@@@Z:NEAR ; CTrayIconPosition::RestoreTrayIcon
EXTRN	?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z:NEAR	; CWnd::FromHandle
xdata$x	SEGMENT
$T201537 DD	0ffffffffH
	DD	FLAT:$L201531
	DD	00H
	DD	FLAT:$L201532
	DD	01H
	DD	FLAT:$L201533
$T201535 DD	019930520H
	DD	03H
	DD	FLAT:$T201537
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv147 = -44						; size = 4
tv150 = -40						; size = 4
_this$ = -36						; size = 4
$T201530 = -32						; size = 4
_ptIcon$ = -28						; size = 8
_eTrackType$ = -20					; size = 4
_bIconFound$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strTitle$ = 8						; size = 4
_str$ = 12						; size = 4
_unTimeOut$ = 16					; size = 4
?ShowTrayIconBalloon@CTrayIcon@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0I@Z PROC NEAR ; CTrayIcon::ShowTrayIconBalloon
; _this$ = ecx

; 129  : {

  003e0	55		 push	 ebp
  003e1	8b ec		 mov	 ebp, esp
  003e3	6a ff		 push	 -1
  003e5	68 00 00 00 00	 push	 __ehhandler$?ShowTrayIconBalloon@CTrayIcon@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0I@Z
  003ea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  003f0	50		 push	 eax
  003f1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  003f8	83 ec 20	 sub	 esp, 32			; 00000020H
  003fb	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
  003fe	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 130  : 	CTrayIconPosition::TrackType eTrackType = CTrayIconPosition::UseBothTechniquesDirectPrefered;

  00405	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _eTrackType$[ebp], 0

; 131  : 	//use m_tipPosition.Invalidate(); if you want to avoid few-seconds postion cashing (visual scan mode only)
; 132  : 	CPoint ptIcon;

  0040c	8d 4d e4	 lea	 ecx, DWORD PTR _ptIcon$[ebp]
  0040f	e8 00 00 00 00	 call	 ??0CPoint@@QAE@XZ	; CPoint::CPoint

; 133  : 	BOOL bIconFound = m_tipPosition.GetTrayIconPosition(ptIcon, eTrackType);

  00414	6a 00		 push	 0
  00416	8b 45 ec	 mov	 eax, DWORD PTR _eTrackType$[ebp]
  00419	50		 push	 eax
  0041a	8d 4d e4	 lea	 ecx, DWORD PTR _ptIcon$[ebp]
  0041d	51		 push	 ecx
  0041e	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00421	83 c1 24	 add	 ecx, 36			; 00000024H
  00424	e8 00 00 00 00	 call	 ?GetTrayIconPosition@CTrayIconPosition@@QAEHAAVCPoint@@W4TrackType@1@W4Precision@1@@Z ; CTrayIconPosition::GetTrayIconPosition
  00429	89 45 f0	 mov	 DWORD PTR _bIconFound$[ebp], eax

; 134  : 
; 135  : 	if(bIconFound == -1)	

  0042c	83 7d f0 ff	 cmp	 DWORD PTR _bIconFound$[ebp], -1
  00430	75 22		 jne	 SHORT $L200528

; 136  : 		return;

  00432	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00436	8d 4d 08	 lea	 ecx, DWORD PTR _strTitle$[ebp]
  00439	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0043f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00446	8d 4d 0c	 lea	 ecx, DWORD PTR _str$[ebp]
  00449	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0044f	e9 9d 00 00 00	 jmp	 $L200524
$L200528:

; 137  : 
; 138  : 	m_tipPosition.RestoreTrayIcon(AfxGetApp()->LoadIcon(m_nid.uID));

  00454	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00457	8b 82 00 01 00
	00		 mov	 eax, DWORD PTR [edx+256]
  0045d	50		 push	 eax
  0045e	e8 00 00 00 00	 call	 ?AfxGetApp@@YGPAVCWinApp@@XZ ; AfxGetApp
  00463	8b c8		 mov	 ecx, eax
  00465	e8 00 00 00 00	 call	 ?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z ; CWinApp::LoadIconA
  0046a	50		 push	 eax
  0046b	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0046e	83 c1 24	 add	 ecx, 36			; 00000024H
  00471	e8 00 00 00 00	 call	 ?RestoreTrayIcon@CTrayIconPosition@@QAEXPAUHICON__@@@Z ; CTrayIconPosition::RestoreTrayIcon

; 139  : 	CBalloonHelp::LaunchBalloon( strTitle, str, ptIcon, 
; 140  : 		IDI_INFORMATION, CBalloonHelp::unSHOW_CLOSE_BUTTON|CBalloonHelp::unDISABLE_XP_SHADOW|CBalloonHelp::unSHOW_TOPMOST,
; 141  : 		CWnd::FromHandle(::GetDesktopWindow()), "", unTimeOut );

  00476	8b 4d 10	 mov	 ecx, DWORD PTR _unTimeOut$[ebp]
  00479	51		 push	 ecx
  0047a	51		 push	 ecx
  0047b	8b cc		 mov	 ecx, esp
  0047d	89 65 e0	 mov	 DWORD PTR $T201530[ebp], esp
  00480	68 00 00 00 00	 push	 OFFSET FLAT:$SG200533
  00485	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0048b	89 45 d8	 mov	 DWORD PTR tv150[ebp], eax
  0048e	8b 55 d8	 mov	 edx, DWORD PTR tv150[ebp]
  00491	89 55 d4	 mov	 DWORD PTR tv147[ebp], edx
  00494	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00498	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDesktopWindow@0
  0049e	50		 push	 eax
  0049f	e8 00 00 00 00	 call	 ?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z ; CWnd::FromHandle
  004a4	50		 push	 eax
  004a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?unSHOW_CLOSE_BUTTON@CBalloonHelp@@2IB ; CBalloonHelp::unSHOW_CLOSE_BUTTON
  004aa	0b 05 00 00 00
	00		 or	 eax, DWORD PTR ?unDISABLE_XP_SHADOW@CBalloonHelp@@2IB ; CBalloonHelp::unDISABLE_XP_SHADOW
  004b0	0b 05 00 00 00
	00		 or	 eax, DWORD PTR ?unSHOW_TOPMOST@CBalloonHelp@@2IB ; CBalloonHelp::unSHOW_TOPMOST
  004b6	50		 push	 eax
  004b7	68 04 7f 00 00	 push	 32516			; 00007f04H
  004bc	8d 4d e4	 lea	 ecx, DWORD PTR _ptIcon$[ebp]
  004bf	51		 push	 ecx
  004c0	8d 55 0c	 lea	 edx, DWORD PTR _str$[ebp]
  004c3	52		 push	 edx
  004c4	8d 45 08	 lea	 eax, DWORD PTR _strTitle$[ebp]
  004c7	50		 push	 eax
  004c8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  004cc	e8 00 00 00 00	 call	 ?LaunchBalloon@CBalloonHelp@@SAXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0ABVCPoint@@PBDIPAVCWnd@@V23@I@Z ; CBalloonHelp::LaunchBalloon
  004d1	83 c4 20	 add	 esp, 32			; 00000020H

; 142  : }

  004d4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  004d8	8d 4d 08	 lea	 ecx, DWORD PTR _strTitle$[ebp]
  004db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  004e1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004e8	8d 4d 0c	 lea	 ecx, DWORD PTR _str$[ebp]
  004eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L200524:
  004f1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  004fb	8b e5		 mov	 esp, ebp
  004fd	5d		 pop	 ebp
  004fe	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L201531:
  00072	8d 4d 0c	 lea	 ecx, DWORD PTR _str$[ebp]
  00075	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L201532:
  0007b	8d 4d 08	 lea	 ecx, DWORD PTR _strTitle$[ebp]
  0007e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L201533:
  00084	8b 4d e0	 mov	 ecx, DWORD PTR $T201530[ebp]
  00087	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?ShowTrayIconBalloon@CTrayIcon@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0I@Z:
  0008d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201535
  00092	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ShowTrayIconBalloon@CTrayIcon@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0I@Z ENDP ; CTrayIcon::ShowTrayIconBalloon
EXTRN	?WindowProc@CSubclassWnd@@MAEJIIJ@Z:NEAR	; CSubclassWnd::WindowProc
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_msg$ = 8						; size = 4
_wp$ = 12						; size = 4
_lp$ = 16						; size = 4
?WindowProc@CTrayHook@CTrayIcon@@EAEJIIJ@Z PROC NEAR	; CTrayIcon::CTrayHook::WindowProc
; _this$ = ecx

; 148  : {

  00510	55		 push	 ebp
  00511	8b ec		 mov	 ebp, esp
  00513	51		 push	 ecx
  00514	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 149  : 	if (msg==m_pTrayIcon->m_nid.uCallbackMessage &&
; 150  : 		 m_hWnd==m_pTrayIcon->m_nid.hWnd) {

  00517	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0051a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0051d	8b 55 08	 mov	 edx, DWORD PTR _msg$[ebp]
  00520	3b 91 08 01 00
	00		 cmp	 edx, DWORD PTR [ecx+264]
  00526	75 31		 jne	 SHORT $L200540
  00528	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0052b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0052e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00531	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00534	3b 81 fc 00 00
	00		 cmp	 eax, DWORD PTR [ecx+252]
  0053a	75 1d		 jne	 SHORT $L200540

; 151  : 
; 152  : 		m_pTrayIcon->OnTrayNotify(wp, lp);

  0053c	8b 4d 10	 mov	 ecx, DWORD PTR _lp$[ebp]
  0053f	51		 push	 ecx
  00540	8b 55 0c	 mov	 edx, DWORD PTR _wp$[ebp]
  00543	52		 push	 edx
  00544	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00547	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0054a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0054d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00550	8b 11		 mov	 edx, DWORD PTR [ecx]
  00552	8b c8		 mov	 ecx, eax
  00554	ff 52 58	 call	 DWORD PTR [edx+88]

; 153  : 
; 154  : 	} else if (msg==WM_TASKBARCREATED) {

  00557	eb 26		 jmp	 SHORT $L200541
$L200540:
  00559	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  0055c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WM_TASKBARCREATED
  00562	75 1b		 jne	 SHORT $L200541

; 155  : 		m_pTrayIcon->OnTaskBarCreate(wp, lp);

  00564	8b 4d 10	 mov	 ecx, DWORD PTR _lp$[ebp]
  00567	51		 push	 ecx
  00568	8b 55 0c	 mov	 edx, DWORD PTR _wp$[ebp]
  0056b	52		 push	 edx
  0056c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0056f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00572	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00575	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00578	8b 11		 mov	 edx, DWORD PTR [ecx]
  0057a	8b c8		 mov	 ecx, eax
  0057c	ff 52 5c	 call	 DWORD PTR [edx+92]
$L200541:

; 156  : 	}
; 157  : 	return CSubclassWnd::WindowProc(msg, wp, lp);

  0057f	8b 45 10	 mov	 eax, DWORD PTR _lp$[ebp]
  00582	50		 push	 eax
  00583	8b 4d 0c	 mov	 ecx, DWORD PTR _wp$[ebp]
  00586	51		 push	 ecx
  00587	8b 55 08	 mov	 edx, DWORD PTR _msg$[ebp]
  0058a	52		 push	 edx
  0058b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0058e	e8 00 00 00 00	 call	 ?WindowProc@CSubclassWnd@@MAEJIIJ@Z ; CSubclassWnd::WindowProc

; 158  : }

  00593	8b e5		 mov	 esp, ebp
  00595	5d		 pop	 ebp
  00596	c2 0c 00	 ret	 12			; 0000000cH
?WindowProc@CTrayHook@CTrayIcon@@EAEJIIJ@Z ENDP		; CTrayIcon::CTrayHook::WindowProc
_TEXT	ENDS
EXTRN	__imp__GetDoubleClickTime@0:NEAR
EXTRN	__imp__SetTimer@16:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wID$ = 8						; size = 4
_lEvent$ = 12						; size = 4
?OnTrayNotify@CTrayIcon@@UAEJIJ@Z PROC NEAR		; CTrayIcon::OnTrayNotify
; _this$ = ecx

; 165  : {

  005a0	55		 push	 ebp
  005a1	8b ec		 mov	 ebp, esp
  005a3	51		 push	 ecx
  005a4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 
; 167  : 	if (wID!=m_nid.uID ||
; 168  : 		(lEvent!=WM_RBUTTONUP && lEvent != WM_LBUTTONUP && lEvent!=WM_LBUTTONDBLCLK && lEvent != WM_LBUTTONDOWN))

  005a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005aa	8b 4d 08	 mov	 ecx, DWORD PTR _wID$[ebp]
  005ad	3b 88 00 01 00
	00		 cmp	 ecx, DWORD PTR [eax+256]
  005b3	75 24		 jne	 SHORT $L200549
  005b5	81 7d 0c 05 02
	00 00		 cmp	 DWORD PTR _lEvent$[ebp], 517 ; 00000205H
  005bc	74 22		 je	 SHORT $L200548
  005be	81 7d 0c 02 02
	00 00		 cmp	 DWORD PTR _lEvent$[ebp], 514 ; 00000202H
  005c5	74 19		 je	 SHORT $L200548
  005c7	81 7d 0c 03 02
	00 00		 cmp	 DWORD PTR _lEvent$[ebp], 515 ; 00000203H
  005ce	74 10		 je	 SHORT $L200548
  005d0	81 7d 0c 01 02
	00 00		 cmp	 DWORD PTR _lEvent$[ebp], 513 ; 00000201H
  005d7	74 07		 je	 SHORT $L200548
$L200549:

; 169  : 		return 0;

  005d9	33 c0		 xor	 eax, eax
  005db	e9 94 00 00 00	 jmp	 $L200547
$L200548:

; 170  : 
; 171  : 	if(lEvent == WM_LBUTTONDBLCLK)

  005e0	81 7d 0c 03 02
	00 00		 cmp	 DWORD PTR _lEvent$[ebp], 515 ; 00000203H
  005e7	75 0c		 jne	 SHORT $L200550

; 172  : 	{
; 173  : 		m_bDbClicked = true;

  005e9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005ec	c6 82 08 03 00
	00 01		 mov	 BYTE PTR [edx+776], 1

; 174  : 	}
; 175  : 	else

  005f3	eb 0a		 jmp	 SHORT $L200551
$L200550:

; 176  : 	{
; 177  : 		m_bDbClicked = false;

  005f5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005f8	c6 80 08 03 00
	00 00		 mov	 BYTE PTR [eax+776], 0
$L200551:

; 178  : 	}
; 179  : 
; 180  : 	if ( (lEvent == WM_RBUTTONUP) ) {

  005ff	81 7d 0c 05 02
	00 00		 cmp	 DWORD PTR _lEvent$[ebp], 517 ; 00000205H
  00606	75 30		 jne	 SHORT $L200552

; 181  : 		m_bRClick = true;

  00608	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0060b	c6 81 09 03 00
	00 01		 mov	 BYTE PTR [ecx+777], 1

; 182  : 		::SetTimer(m_nid.hWnd , TIMER_FOR_TRAY ,GetDoubleClickTime() / 3  ,NULL); 

  00612	6a 00		 push	 0
  00614	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDoubleClickTime@0
  0061a	33 d2		 xor	 edx, edx
  0061c	b9 03 00 00 00	 mov	 ecx, 3
  00621	f7 f1		 div	 ecx
  00623	50		 push	 eax
  00624	6a 0b		 push	 11			; 0000000bH
  00626	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00629	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  0062f	50		 push	 eax
  00630	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 183  : 	
; 184  : 	}
; 185  : 	else if(lEvent == WM_LBUTTONUP)

  00636	eb 37		 jmp	 SHORT $L200553
$L200552:
  00638	81 7d 0c 02 02
	00 00		 cmp	 DWORD PTR _lEvent$[ebp], 514 ; 00000202H
  0063f	75 2e		 jne	 SHORT $L200553

; 186  : 	{
; 187  : 		m_bRClick = false;

  00641	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00644	c6 81 09 03 00
	00 00		 mov	 BYTE PTR [ecx+777], 0

; 188  : 		::SetTimer(m_nid.hWnd , TIMER_FOR_TRAY ,GetDoubleClickTime() / 3 ,NULL); 

  0064b	6a 00		 push	 0
  0064d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDoubleClickTime@0
  00653	33 d2		 xor	 edx, edx
  00655	b9 03 00 00 00	 mov	 ecx, 3
  0065a	f7 f1		 div	 ecx
  0065c	50		 push	 eax
  0065d	6a 0b		 push	 11			; 0000000bH
  0065f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00662	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  00668	50		 push	 eax
  00669	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
$L200553:

; 189  : 	
; 190  : 	}
; 191  : 
; 192  : 	return 1; // handled

  0066f	b8 01 00 00 00	 mov	 eax, 1
$L200547:

; 193  : }

  00674	8b e5		 mov	 esp, ebp
  00676	5d		 pop	 ebp
  00677	c2 08 00	 ret	 8
?OnTrayNotify@CTrayIcon@@UAEJIJ@Z ENDP			; CTrayIcon::OnTrayNotify
; Function compile flags: /Odt
_this$ = -8						; size = 4
_hIcon$ = -4						; size = 4
_wp$ = 8						; size = 4
_lp$ = 12						; size = 4
?OnTaskBarCreate@CTrayIcon@@UAEJIJ@Z PROC NEAR		; CTrayIcon::OnTaskBarCreate
; _this$ = ecx

; 199  : {

  00680	55		 push	 ebp
  00681	8b ec		 mov	 ebp, esp
  00683	83 ec 08	 sub	 esp, 8
  00686	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 200  : 	// Reinstall taskbar icon
; 201  : 	HICON hIcon = m_nid.hIcon;

  00689	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0068c	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  00692	89 4d fc	 mov	 DWORD PTR _hIcon$[ebp], ecx

; 202  : 	m_nid.hIcon = NULL;

  00695	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00698	c7 82 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+268], 0

; 203  : 	if (hIcon)

  006a2	83 7d fc 00	 cmp	 DWORD PTR _hIcon$[ebp], 0
  006a6	74 0e		 je	 SHORT $L200561

; 204  : 		SetIcon(hIcon, NULL); // will reuse current tip

  006a8	6a 00		 push	 0
  006aa	8b 45 fc	 mov	 eax, DWORD PTR _hIcon$[ebp]
  006ad	50		 push	 eax
  006ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006b1	e8 00 00 00 00	 call	 ?SetIcon@CTrayIcon@@QAEHPAUHICON__@@PBD@Z ; CTrayIcon::SetIcon
$L200561:

; 205  : 	return 0;

  006b6	33 c0		 xor	 eax, eax

; 206  : }

  006b8	8b e5		 mov	 esp, ebp
  006ba	5d		 pop	 ebp
  006bb	c2 08 00	 ret	 8
?OnTaskBarCreate@CTrayIcon@@UAEJIJ@Z ENDP		; CTrayIcon::OnTaskBarCreate
_TEXT	ENDS
PUBLIC	??_GCShowMenu@@QAEPAXI@Z			; CShowMenu::`scalar deleting destructor'
PUBLIC	?CreatePopup@CTrayIcon@@QAEHPAUHWND__@@@Z	; CTrayIcon::CreatePopup
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	??0CShowMenu@@QAE@PAVCWnd@@KK@Z:NEAR		; CShowMenu::CShowMenu
EXTRN	?DisableItem@CShowMenu@@QAEXK@Z:NEAR		; CShowMenu::DisableItem
EXTRN	?ShowMenu@CShowMenu@@QAEXABVCPoint@@@Z:NEAR	; CShowMenu::ShowMenu
EXTRN	__imp__SetForegroundWindow@4:NEAR
EXTRN	__imp__GetCursorPos@4:NEAR
EXTRN	?AfxGetUIManager@@YAPAVIUIManager@@XZ:NEAR	; AfxGetUIManager
xdata$x	SEGMENT
$T201554 DD	0ffffffffH
	DD	FLAT:$L201550
$T201552 DD	019930520H
	DD	01H
	DD	FLAT:$T201554
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv137 = -52						; size = 4
tv79 = -48						; size = 4
tv77 = -44						; size = 4
_this$ = -40						; size = 4
$T201547 = -36						; size = 4
$T201546 = -32						; size = 4
$T201543 = -28						; size = 4
$T201542 = -24						; size = 4
_point$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_hwnd$ = 8						; size = 4
?CreatePopup@CTrayIcon@@QAEHPAUHWND__@@@Z PROC NEAR	; CTrayIcon::CreatePopup
; _this$ = ecx

; 209  : {

  006c0	55		 push	 ebp
  006c1	8b ec		 mov	 ebp, esp
  006c3	6a ff		 push	 -1
  006c5	68 00 00 00 00	 push	 __ehhandler$?CreatePopup@CTrayIcon@@QAEHPAUHWND__@@@Z
  006ca	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  006d0	50		 push	 eax
  006d1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  006d8	83 ec 28	 sub	 esp, 40			; 00000028H
  006db	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 210  : 	m_pMenu = new CShowMenu(CWnd::FromHandle(hwnd),IDR_MENU_TRAYICON);

  006de	6a 6c		 push	 108			; 0000006cH
  006e0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  006e5	83 c4 04	 add	 esp, 4
  006e8	89 45 e4	 mov	 DWORD PTR $T201543[ebp], eax
  006eb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  006f2	83 7d e4 00	 cmp	 DWORD PTR $T201543[ebp], 0
  006f6	74 1e		 je	 SHORT $L201544
  006f8	6a 00		 push	 0
  006fa	68 b5 00 00 00	 push	 181			; 000000b5H
  006ff	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00702	50		 push	 eax
  00703	e8 00 00 00 00	 call	 ?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z ; CWnd::FromHandle
  00708	50		 push	 eax
  00709	8b 4d e4	 mov	 ecx, DWORD PTR $T201543[ebp]
  0070c	e8 00 00 00 00	 call	 ??0CShowMenu@@QAE@PAVCWnd@@KK@Z ; CShowMenu::CShowMenu
  00711	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  00714	eb 07		 jmp	 SHORT $L201545
$L201544:
  00716	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$L201545:
  0071d	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  00720	89 4d e8	 mov	 DWORD PTR $T201542[ebp], ecx
  00723	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0072a	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0072d	8b 45 e8	 mov	 eax, DWORD PTR $T201542[ebp]
  00730	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 211  : 
; 212  : 	if( !AfxGetUIManager()->UICanExit() )

  00733	e8 00 00 00 00	 call	 ?AfxGetUIManager@@YAPAVIUIManager@@XZ ; AfxGetUIManager
  00738	89 45 d0	 mov	 DWORD PTR tv79[ebp], eax
  0073b	8b 4d d0	 mov	 ecx, DWORD PTR tv79[ebp]
  0073e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00740	8b 4d d0	 mov	 ecx, DWORD PTR tv79[ebp]
  00743	ff 52 0c	 call	 DWORD PTR [edx+12]
  00746	0f b6 c0	 movzx	 eax, al
  00749	85 c0		 test	 eax, eax
  0074b	75 1d		 jne	 SHORT $L200570

; 213  : 	{
; 214  : 		m_pMenu->DisableItem(ID_MEMU_SETTING);

  0074d	6a 68		 push	 104			; 00000068H
  0074f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00752	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00755	e8 00 00 00 00	 call	 ?DisableItem@CShowMenu@@QAEXK@Z ; CShowMenu::DisableItem

; 215  : 		m_pMenu->DisableItem(ID_APP_EXIT);

  0075a	68 41 e1 00 00	 push	 57665			; 0000e141H
  0075f	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00762	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00765	e8 00 00 00 00	 call	 ?DisableItem@CShowMenu@@QAEXK@Z ; CShowMenu::DisableItem
$L200570:

; 216  : 	}
; 217  : 	//////////////////////////////////
; 218  : 	CPoint point;

  0076a	8d 4d ec	 lea	 ecx, DWORD PTR _point$[ebp]
  0076d	e8 00 00 00 00	 call	 ??0CPoint@@QAE@XZ	; CPoint::CPoint

; 219  : 	GetCursorPos(&point);

  00772	8d 45 ec	 lea	 eax, DWORD PTR _point$[ebp]
  00775	50		 push	 eax
  00776	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4

; 220  : 	::SetForegroundWindow(hwnd);	

  0077c	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0077f	51		 push	 ecx
  00780	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetForegroundWindow@4

; 221  : 	m_pMenu->ShowMenu(point);

  00786	8d 55 ec	 lea	 edx, DWORD PTR _point$[ebp]
  00789	52		 push	 edx
  0078a	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  0078d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00790	e8 00 00 00 00	 call	 ?ShowMenu@CShowMenu@@QAEXABVCPoint@@@Z ; CShowMenu::ShowMenu

; 222  : 	delete m_pMenu;

  00795	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00798	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0079b	89 55 dc	 mov	 DWORD PTR $T201547[ebp], edx
  0079e	8b 45 dc	 mov	 eax, DWORD PTR $T201547[ebp]
  007a1	89 45 e0	 mov	 DWORD PTR $T201546[ebp], eax
  007a4	83 7d e0 00	 cmp	 DWORD PTR $T201546[ebp], 0
  007a8	74 0f		 je	 SHORT $L201548
  007aa	6a 01		 push	 1
  007ac	8b 4d e0	 mov	 ecx, DWORD PTR $T201546[ebp]
  007af	e8 00 00 00 00	 call	 ??_GCShowMenu@@QAEPAXI@Z
  007b4	89 45 cc	 mov	 DWORD PTR tv137[ebp], eax
  007b7	eb 07		 jmp	 SHORT $L201549
$L201548:
  007b9	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], 0
$L201549:

; 223  : 	m_pMenu = NULL;

  007c0	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  007c3	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 224  : 	return 0;

  007ca	33 c0		 xor	 eax, eax

; 225  : }

  007cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  007cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  007d6	8b e5		 mov	 esp, ebp
  007d8	5d		 pop	 ebp
  007d9	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L201550:
  00097	8b 45 e4	 mov	 eax, DWORD PTR $T201543[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a0	59		 pop	 ecx
  000a1	c3		 ret	 0
__ehhandler$?CreatePopup@CTrayIcon@@QAEHPAUHWND__@@@Z:
  000a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201552
  000a7	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreatePopup@CTrayIcon@@QAEHPAUHWND__@@@Z ENDP		; CTrayIcon::CreatePopup
PUBLIC	??1CShowMenu@@QAE@XZ				; CShowMenu::~CShowMenu
; Function compile flags: /Odt
;	COMDAT ??_GCShowMenu@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCShowMenu@@QAEPAXI@Z PROC NEAR			; CShowMenu::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CShowMenu@@QAE@XZ	; CShowMenu::~CShowMenu
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L200577
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L200577:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCShowMenu@@QAEPAXI@Z ENDP				; CShowMenu::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??1BCMenu@@UAE@XZ:NEAR				; BCMenu::~BCMenu
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\util\showmenu.h
;	COMDAT ??1CShowMenu@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CShowMenu@@QAE@XZ PROC NEAR				; CShowMenu::~CShowMenu, COMDAT
; _this$ = ecx

; 11   : 	~CShowMenu(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1BCMenu@@UAE@XZ	; BCMenu::~BCMenu
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CShowMenu@@QAE@XZ ENDP				; CShowMenu::~CShowMenu
_TEXT	ENDS
PUBLIC	?MeasureItem@CTrayIcon@@QAEXPAUtagMEASUREITEMSTRUCT@@@Z ; CTrayIcon::MeasureItem
EXTRN	?MeasureItem@CShowMenu@@QAE_NPAUtagMEASUREITEMSTRUCT@@@Z:NEAR ; CShowMenu::MeasureItem
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\tray\trayicon.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpMeasureItemStruct$ = 8				; size = 4
?MeasureItem@CTrayIcon@@QAEXPAUtagMEASUREITEMSTRUCT@@@Z PROC NEAR ; CTrayIcon::MeasureItem
; _this$ = ecx

; 227  : {

  007e0	55		 push	 ebp
  007e1	8b ec		 mov	 ebp, esp
  007e3	51		 push	 ecx
  007e4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 228  : 	if( m_pMenu )

  007e7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007ea	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  007ee	74 0f		 je	 SHORT $L200581

; 229  : 	{
; 230  : 		m_pMenu->MeasureItem(lpMeasureItemStruct);

  007f0	8b 4d 08	 mov	 ecx, DWORD PTR _lpMeasureItemStruct$[ebp]
  007f3	51		 push	 ecx
  007f4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  007f7	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  007fa	e8 00 00 00 00	 call	 ?MeasureItem@CShowMenu@@QAE_NPAUtagMEASUREITEMSTRUCT@@@Z ; CShowMenu::MeasureItem
$L200581:

; 231  : 	}
; 232  : }

  007ff	8b e5		 mov	 esp, ebp
  00801	5d		 pop	 ebp
  00802	c2 04 00	 ret	 4
?MeasureItem@CTrayIcon@@QAEXPAUtagMEASUREITEMSTRUCT@@@Z ENDP ; CTrayIcon::MeasureItem
_TEXT	ENDS
PUBLIC	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z	; ATL::_AtlInstallStringThunk
PUBLIC	?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableW@12:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWThunk, COMDAT

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 184  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
; 185  : 		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetEnvironmentVariableW@12
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
  0000e	68 14 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 186  : 
; 187  : 	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);

  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 0c	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  00022	52		 push	 edx
  00023	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  00026	50		 push	 eax
  00027	ff 15 14 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20

; 188  : }

  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWThunk
_TEXT	ENDS
PUBLIC	?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
PUBLIC	??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
EXTRN	__imp__GetVersion@0:NEAR
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT
?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA DB 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT
??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 DD 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
; Function compile flags: /Odt
_BSS	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT
_pfn$ = -4						; size = 4
_ppThunk$ = 8						; size = 4
_pfnWin9x$ = 12						; size = 4
_pfnNT$ = 16						; size = 4
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z PROC NEAR	; ATL::_AtlInstallStringThunk, COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 116  : #pragma warning (push)
; 117  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 118  : 
; 119  : 	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
  00009	83 e0 01	 and	 eax, 1
  0000c	75 25		 jne	 SHORT $L25641
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
  00014	83 c9 01	 or	 ecx, 1
  00017	89 0d 00 00 00
	00		 mov	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, ecx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00023	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00028	f7 d8		 neg	 eax
  0002a	1b c0		 sbb	 eax, eax
  0002c	f7 d8		 neg	 eax
  0002e	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L25641:

; 120  : 	
; 121  : #pragma warning (pop)
; 122  : 
; 123  : 	void* pfn;
; 124  : 	if (s_bWin9x)

  00033	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  0003a	85 d2		 test	 edx, edx
  0003c	74 08		 je	 SHORT $L25643

; 125  : 		pfn = pfnWin9x;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _pfnWin9x$[ebp]
  00041	89 45 fc	 mov	 DWORD PTR _pfn$[ebp], eax

; 126  : 	else

  00044	eb 06		 jmp	 SHORT $L25644
$L25643:

; 127  : 	{
; 128  : #ifdef _CSTRING_ALWAYS_THUNK
; 129  : 		pfn = pfnWin9x;
; 130  : 		(void)pfnNT;
; 131  : #else
; 132  : 		pfn = pfnNT;

  00046	8b 4d 10	 mov	 ecx, DWORD PTR _pfnNT$[ebp]
  00049	89 4d fc	 mov	 DWORD PTR _pfn$[ebp], ecx
$L25644:

; 133  : #endif
; 134  : 	}
; 135  : 	InterlockedExchangePointer(ppThunk, pfn);

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _pfn$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 08	 mov	 eax, DWORD PTR _ppThunk$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 136  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ENDP	; ATL::_AtlInstallStringThunk
_TEXT	ENDS
PUBLIC	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
PUBLIC	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
PUBLIC	??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z		; ATL::CW2AEX<128>::CW2AEX<128>
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
PUBLIC	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CW2AEX<128>::operator char *
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
EXTRN	__imp__MultiByteToWideChar@24:NEAR
EXTRN	__imp__GetEnvironmentVariableA@12:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201576 DD	0ffffffffH
	DD	FLAT:$L201570
	DD	00H
	DD	FLAT:$L201571
$T201573 DD	019930520H
	DD	02H
	DD	FLAT:$T201576
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
$T201569 = -312						; size = 4
$T201568 = -308						; size = 4
$T201567 = -304						; size = 4
_pszBufferA$ = -300					; size = 132
_nSizeW$ = -160						; size = 4
_pszNameA$ = -156					; size = 132
__$ArrayPad$ = -20					; size = 4
_nSizeA$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWFake, COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 160  : 	ULONG nSizeA;
; 161  : 	ULONG nSizeW;
; 162  : 	CTempBuffer<char> pszBufferA;

  00026	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 163  : 	CW2A pszNameA(pszName);

  00038	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  0003b	50		 push	 eax
  0003c	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ; ATL::CW2AEX<128>::CW2AEX<128>
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 164  : 
; 165  : 	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00055	e8 00 00 00 00	 call	 ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ; ATL::CW2AEX<128>::operator char *
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12
  00061	89 45 f0	 mov	 DWORD PTR _nSizeA$[ebp], eax

; 166  : 	if (nSizeA == 0)

  00064	83 7d f0 00	 cmp	 DWORD PTR _nSizeA$[ebp], 0
  00068	75 36		 jne	 SHORT $L25746

; 167  : 		return 0;

  0006a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T201567[ebp], 0
  00074	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00078	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  0007e	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  00083	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00090	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  00095	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T201567[ebp]
  0009b	e9 ee 00 00 00	 jmp	 $L25687
$L25746:

; 168  : 
; 169  : 	pszBufferA.Allocate(nSizeA*2);

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _nSizeA$[ebp]
  000a3	d1 e1		 shl	 ecx, 1
  000a5	51		 push	 ecx
  000a6	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000ac	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 170  : 	::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA);

  000b1	8b 55 f0	 mov	 edx, DWORD PTR _nSizeA$[ebp]
  000b4	52		 push	 edx
  000b5	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000bb	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000c0	50		 push	 eax
  000c1	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  000c7	e8 00 00 00 00	 call	 ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ; ATL::CW2AEX<128>::operator char *
  000cc	50		 push	 eax
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12

; 171  : 
; 172  : 	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);

  000d3	6a 00		 push	 0
  000d5	6a 00		 push	 0
  000d7	6a ff		 push	 -1
  000d9	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000df	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  000ec	50		 push	 eax
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  000f3	89 85 60 ff ff
	ff		 mov	 DWORD PTR _nSizeW$[ebp], eax

; 173  : 	if (nSize == 0)

  000f9	83 7d 10 00	 cmp	 DWORD PTR _nSize$[ebp], 0
  000fd	75 35		 jne	 SHORT $L25748

; 174  : 		return nSizeW;

  000ff	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nSizeW$[ebp]
  00105	89 85 cc fe ff
	ff		 mov	 DWORD PTR $T201568[ebp], eax
  0010b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0010f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00115	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00121	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00127	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  0012c	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T201568[ebp]
  00132	eb 5a		 jmp	 SHORT $L25687
$L25748:

; 175  : 	ATLASSERT(nSize >= nSizeW);
; 176  : 	::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW);

  00134	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _nSizeW$[ebp]
  0013a	51		 push	 ecx
  0013b	8b 55 0c	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  0013e	52		 push	 edx
  0013f	6a ff		 push	 -1
  00141	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00147	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  0014c	50		 push	 eax
  0014d	6a 00		 push	 0
  0014f	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00154	50		 push	 eax
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 177  : 
; 178  : 	return nSizeW;

  0015b	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nSizeW$[ebp]
  00161	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T201569[ebp], eax
  00167	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0016b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00171	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  00176	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0017d	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00183	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  00188	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T201569[ebp]
$L25687:

; 179  : }

  0018e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00191	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00198	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201570:
  00000	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
$L201571:
  0000b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201573
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 158  : 	return( g_pfnGetThreadACP() );

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 159  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringW@24:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWThunk, COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 217  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CompareStringW@24
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ; ATL::CompareStringWFake
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A ; ATL::_strthunks
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : 
; 219  : 	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);

  0001b	8b 4d 1c	 mov	 ecx, DWORD PTR _nLength2$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 18	 mov	 edx, DWORD PTR _pszString2$[ebp]
  00022	52		 push	 edx
  00023	8b 45 14	 mov	 eax, DWORD PTR _nLength1$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR _pszString1$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR _lcid$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A

; 220  : }

  00039	5d		 pop	 ebp
  0003a	c2 18 00	 ret	 24			; 00000018H
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWThunk
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
PUBLIC	?AtlW2AHelper@@YGPADPADPB_WHI@Z			; AtlW2AHelper
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
EXTRN	__imp__lstrlenW@4:NEAR
EXTRN	__imp__CompareStringA@24:NEAR
EXTRN	__alloca_probe:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201599 DD	0ffffffffH
	DD	FLAT:$L201594
$T201596 DD	019930520H
	DD	01H
	DD	FLAT:$T201599
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
tv147 = -68						; size = 4
tv142 = -64						; size = 4
tv149 = -60						; size = 4
tv89 = -56						; size = 4
tv84 = -52						; size = 4
tv91 = -48						; size = 4
$T201593 = -44						; size = 4
_pszAString1$ = -40					; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__convert_ex$ = -32					; size = 4
__acp_ex$ = -28						; size = 4
_pszAString2$ = -24					; size = 4
__lpw_ex$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWFake, COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 38	 sub	 esp, 56			; 00000038H

; 193  : 	USES_CONVERSION_EX;

  0001b	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00020	89 45 e4	 mov	 DWORD PTR __acp_ex$[ebp], eax
  00023	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 194  : 	
; 195  : 	LPCSTR pszAString1 = NULL;

  00032	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pszAString1$[ebp], 0

; 196  : 	if(pszString1 != NULL)

  00039	83 7d 10 00	 cmp	 DWORD PTR _pszString1$[ebp], 0
  0003d	0f 84 98 00 00
	00		 je	 $L25772

; 197  : 	{
; 198  : 		pszAString1 = W2A_EX(pszString1,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00043	8b 45 10	 mov	 eax, DWORD PTR _pszString1$[ebp]
  00046	89 45 f0	 mov	 DWORD PTR __lpw_ex$[ebp], eax
  00049	83 7d f0 00	 cmp	 DWORD PTR __lpw_ex$[ebp], 0
  0004d	75 09		 jne	 SHORT $L201587
  0004f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
  00056	eb 6d		 jmp	 SHORT $L201588
$L201587:
  00058	8b 4d f0	 mov	 ecx, DWORD PTR __lpw_ex$[ebp]
  0005b	51		 push	 ecx
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00062	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00066	89 55 e0	 mov	 DWORD PTR __convert_ex$[ebp], edx
  00069	81 7d e0 00 04
	00 00		 cmp	 DWORD PTR __convert_ex$[ebp], 1024 ; 00000400H
  00070	7f 2c		 jg	 SHORT $L201585
  00072	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0007b	83 c4 04	 add	 esp, 4
  0007e	0f b6 c8	 movzx	 ecx, al
  00081	85 c9		 test	 ecx, ecx
  00083	74 19		 je	 SHORT $L201585
  00085	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00088	83 c0 03	 add	 eax, 3
  0008b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008e	e8 00 00 00 00	 call	 __alloca_probe
  00093	89 65 cc	 mov	 DWORD PTR tv84[ebp], esp
  00096	8b 55 cc	 mov	 edx, DWORD PTR tv84[ebp]
  00099	89 55 c8	 mov	 DWORD PTR tv89[ebp], edx
  0009c	eb 0f		 jmp	 SHORT $L201586
$L201585:
  0009e	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  000a1	50		 push	 eax
  000a2	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000a5	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  000aa	89 45 c8	 mov	 DWORD PTR tv89[ebp], eax
$L201586:
  000ad	8b 4d e4	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 e0	 mov	 edx, DWORD PTR __convert_ex$[ebp]
  000b4	52		 push	 edx
  000b5	8b 45 f0	 mov	 eax, DWORD PTR __lpw_ex$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d c8	 mov	 ecx, DWORD PTR tv89[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  000c2	89 45 d0	 mov	 DWORD PTR tv91[ebp], eax
$L201588:
  000c5	8b 55 d0	 mov	 edx, DWORD PTR tv91[ebp]
  000c8	89 55 d8	 mov	 DWORD PTR _pszAString1$[ebp], edx

; 199  : 		if(pszAString1 == NULL)

  000cb	83 7d d8 00	 cmp	 DWORD PTR _pszAString1$[ebp], 0
  000cf	75 0a		 jne	 SHORT $L25772

; 200  : 			AtlThrow(E_OUTOFMEMORY);

  000d1	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  000d6	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L25772:

; 201  : 	}
; 202  : 
; 203  : 	LPCSTR pszAString2 = NULL;

  000db	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pszAString2$[ebp], 0

; 204  : 	if(pszString2 != NULL)

  000e2	83 7d 18 00	 cmp	 DWORD PTR _pszString2$[ebp], 0
  000e6	0f 84 98 00 00
	00		 je	 $L25778

; 205  : 	{
; 206  : 		pszAString2 = W2A_EX(pszString2,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  000ec	8b 45 18	 mov	 eax, DWORD PTR _pszString2$[ebp]
  000ef	89 45 f0	 mov	 DWORD PTR __lpw_ex$[ebp], eax
  000f2	83 7d f0 00	 cmp	 DWORD PTR __lpw_ex$[ebp], 0
  000f6	75 09		 jne	 SHORT $L201591
  000f8	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv149[ebp], 0
  000ff	eb 6d		 jmp	 SHORT $L201592
$L201591:
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __lpw_ex$[ebp]
  00104	51		 push	 ecx
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0010b	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  0010f	89 55 e0	 mov	 DWORD PTR __convert_ex$[ebp], edx
  00112	81 7d e0 00 04
	00 00		 cmp	 DWORD PTR __convert_ex$[ebp], 1024 ; 00000400H
  00119	7f 2c		 jg	 SHORT $L201589
  0011b	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  00124	83 c4 04	 add	 esp, 4
  00127	0f b6 c8	 movzx	 ecx, al
  0012a	85 c9		 test	 ecx, ecx
  0012c	74 19		 je	 SHORT $L201589
  0012e	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00131	83 c0 03	 add	 eax, 3
  00134	83 e0 fc	 and	 eax, -4			; fffffffcH
  00137	e8 00 00 00 00	 call	 __alloca_probe
  0013c	89 65 c0	 mov	 DWORD PTR tv142[ebp], esp
  0013f	8b 55 c0	 mov	 edx, DWORD PTR tv142[ebp]
  00142	89 55 bc	 mov	 DWORD PTR tv147[ebp], edx
  00145	eb 0f		 jmp	 SHORT $L201590
$L201589:
  00147	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  0014a	50		 push	 eax
  0014b	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  0014e	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  00153	89 45 bc	 mov	 DWORD PTR tv147[ebp], eax
$L201590:
  00156	8b 4d e4	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  00159	51		 push	 ecx
  0015a	8b 55 e0	 mov	 edx, DWORD PTR __convert_ex$[ebp]
  0015d	52		 push	 edx
  0015e	8b 45 f0	 mov	 eax, DWORD PTR __lpw_ex$[ebp]
  00161	50		 push	 eax
  00162	8b 4d bc	 mov	 ecx, DWORD PTR tv147[ebp]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0016b	89 45 c4	 mov	 DWORD PTR tv149[ebp], eax
$L201592:
  0016e	8b 55 c4	 mov	 edx, DWORD PTR tv149[ebp]
  00171	89 55 e8	 mov	 DWORD PTR _pszAString2$[ebp], edx

; 207  : 		if(pszAString2 == NULL)

  00174	83 7d e8 00	 cmp	 DWORD PTR _pszAString2$[ebp], 0
  00178	75 0a		 jne	 SHORT $L25778

; 208  : 			AtlThrow(E_OUTOFMEMORY);

  0017a	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0017f	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L25778:

; 209  : 	}
; 210  : 
; 211  : 	return ::CompareStringA(lcid, dwFlags, pszAString1, nLength1, pszAString2, nLength2);

  00184	8b 45 1c	 mov	 eax, DWORD PTR _nLength2$[ebp]
  00187	50		 push	 eax
  00188	8b 4d e8	 mov	 ecx, DWORD PTR _pszAString2$[ebp]
  0018b	51		 push	 ecx
  0018c	8b 55 14	 mov	 edx, DWORD PTR _nLength1$[ebp]
  0018f	52		 push	 edx
  00190	8b 45 d8	 mov	 eax, DWORD PTR _pszAString1$[ebp]
  00193	50		 push	 eax
  00194	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00197	51		 push	 ecx
  00198	8b 55 08	 mov	 edx, DWORD PTR _lcid$[ebp]
  0019b	52		 push	 edx
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CompareStringA@24
  001a2	89 45 d4	 mov	 DWORD PTR $T201593[ebp], eax
  001a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001ac	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  001af	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  001b4	8b 45 d4	 mov	 eax, DWORD PTR $T201593[ebp]
$L201584:

; 212  : }

  001b7	8d 65 bc	 lea	 esp, DWORD PTR [ebp-68]
  001ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201594:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201596
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWFake
EXTRN	__imp___resetstkoflw:NEAR
EXTRN	__except_handler3:NEAR
;	COMDAT CONST
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
CONST	SEGMENT
$T201610 DD	0ffffffffH
	DD	FLAT:$L201605
	DD	FLAT:$L201606
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
tv65 = -40						; size = 4
$T201609 = -36						; size = 4
_p$24118 = -32						; size = 4
_bStackAvailable$ = -25					; size = 1
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 OFFSET FLAT:$T201610
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:__except_handler3
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00015	50		 push	 eax
  00016	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001d	83 c4 e8	 add	 esp, -24		; ffffffe8H
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 332  :     bool bStackAvailable = true;

  00026	c6 45 e7 01	 mov	 BYTE PTR _bStackAvailable$[ebp], 1

; 333  : 
; 334  :     __try

  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 335  :     {
; 336  :         PVOID p = _alloca(Size + _ATL_STACK_MARGIN);

  00031	8b 45 08	 mov	 eax, DWORD PTR _Size$[ebp]
  00034	05 03 20 00 00	 add	 eax, 8195		; 00002003H
  00039	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003c	e8 00 00 00 00	 call	 __alloca_probe
  00041	89 65 d8	 mov	 DWORD PTR tv65[ebp], esp
  00044	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00047	8b 45 d8	 mov	 eax, DWORD PTR tv65[ebp]
  0004a	89 45 e0	 mov	 DWORD PTR _p$24118[ebp], eax
  0004d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00054	eb 2c		 jmp	 SHORT $L201608
$L201605:
$L201614:

; 337  :         (p);
; 338  :     }
; 339  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 340  :                    EXCEPTION_EXECUTE_HANDLER :
; 341  :                    EXCEPTION_CONTINUE_SEARCH)

  00056	8b 4d ec	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+4]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8b 02		 mov	 eax, DWORD PTR [edx]
  0005d	89 45 dc	 mov	 DWORD PTR $T201609[ebp], eax
  00060	8b 45 dc	 mov	 eax, DWORD PTR $T201609[ebp]
  00063	2d fd 00 00 c0	 sub	 eax, -1073741571	; c00000fdH
  00068	f7 d8		 neg	 eax
  0006a	1b c0		 sbb	 eax, eax
  0006c	40		 inc	 eax
$L201607:
$L201613:
  0006d	c3		 ret	 0
$L201606:
  0006e	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 342  :     {
; 343  :         bStackAvailable = false;

  00071	c6 45 e7 00	 mov	 BYTE PTR _bStackAvailable$[ebp], 0

; 344  :         _resetstkoflw();

  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___resetstkoflw
  0007b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$L201608:

; 345  :     }
; 346  :     return bStackAvailable;

  00082	8a 45 e7	 mov	 al, BYTE PTR _bStackAvailable$[ebp]
$L201604:

; 347  : }

  00085	8d 65 cc	 lea	 esp, DWORD PTR [ebp-52]
  00088	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
EXTRN	__imp__WideCharToMultiByte@32:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPB_WHI@Z PROC NEAR		; AtlW2AHelper, COMDAT

; 573  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 574  : 	ATLASSERT(lpw != NULL);
; 575  : 	ATLASSERT(lpa != NULL);
; 576  : 	if (lpa == NULL || lpw == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpa$[ebp], 0
  00008	74 06		 je	 SHORT $L24319
  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpw$[ebp], 0
  0000e	75 04		 jne	 SHORT $L24318
$L24319:

; 577  : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 34		 jmp	 SHORT $L24315
$L24318:

; 578  : 	// verify that no illegal character present
; 579  : 	// since lpa was allocated based on the size of lpw
; 580  : 	// don't worry about the number of chars
; 581  : 	lpa[0] = '\0';

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpa$[ebp]
  00017	c6 00 00	 mov	 BYTE PTR [eax], 0

; 582  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR _nChars$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _lpa$[ebp]
  00025	52		 push	 edx
  00026	6a ff		 push	 -1
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lpw$[ebp]
  0002b	50		 push	 eax
  0002c	6a 00		 push	 0
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _acp$[ebp]
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00038	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 583  : 	if(ret == 0)

  0003b	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0003f	75 04		 jne	 SHORT $L24321

; 584  : 	{
; 585  : 		ATLASSERT(FALSE);
; 586  : 		return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	eb 03		 jmp	 SHORT $L24315
$L24321:

; 587  : 	}
; 588  : 	return lpa;

  00045	8b 45 08	 mov	 eax, DWORD PTR _lpa$[ebp]
$L24315:

; 589  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 10 00	 ret	 16			; 00000010H
?AtlW2AHelper@@YGPADPADPB_WHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00003	81 7d 08 0e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
  0000a	75 05		 jne	 SHORT $L24681

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000c	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L24681:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00011	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L201620:

; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );
; 74   : #endif
; 75   : };

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExW@20:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWThunk, COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 241  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetStringTypeExW@20
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ; ATL::GetStringTypeExWFake
  0000e	68 04 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  : 
; 243  : 	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);

  0001b	8b 4d 18	 mov	 ecx, DWORD PTR _pwCharType$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 14	 mov	 edx, DWORD PTR _nLength$[ebp]
  00022	52		 push	 edx
  00023	8b 45 10	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _dwInfoType$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _lcid$[ebp]
  0002e	52		 push	 edx
  0002f	ff 15 04 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4

; 244  : }

  00035	5d		 pop	 ebp
  00036	c2 14 00	 ret	 20			; 00000014H
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z ENDP	; ATL::GetStringTypeExWThunk
_TEXT	ENDS
EXTRN	__imp__GetStringTypeExA@20:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201632 DD	0ffffffffH
	DD	FLAT:$L201627
$T201629 DD	019930520H
	DD	01H
	DD	FLAT:$T201632
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
$T201626 = -164						; size = 4
_nLengthA$ = -160					; size = 4
_pszA$ = -156						; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWFake, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 225  : 	int nLengthA;
; 226  : 	CTempBuffer<char> pszA;

  00026	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 227  : 
; 228  : 	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	8b 45 14	 mov	 eax, DWORD PTR _nLength$[ebp]
  00043	50		 push	 eax
  00044	8b 4d 10	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  00047	51		 push	 ecx
  00048	6a 00		 push	 0
  0004a	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00056	89 85 60 ff ff
	ff		 mov	 DWORD PTR _nLengthA$[ebp], eax

; 229  : 	pszA.Allocate(nLengthA);

  0005c	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _nLengthA$[ebp]
  00062	52		 push	 edx
  00063	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  00069	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 230  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nLengthA$[ebp]
  00078	50		 push	 eax
  00079	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  0007f	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  00084	50		 push	 eax
  00085	8b 4d 14	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 10	 mov	 edx, DWORD PTR _pszSrc$[ebp]
  0008c	52		 push	 edx
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 231  : 
; 232  : 	if (nLength == -1)

  0009b	83 7d 14 ff	 cmp	 DWORD PTR _nLength$[ebp], -1
  0009f	75 0a		 jne	 SHORT $L25804

; 233  : 		nLengthA = -1;

  000a1	c7 85 60 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _nLengthA$[ebp], -1
$L25804:

; 234  : 
; 235  : 	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);

  000ab	8b 45 18	 mov	 eax, DWORD PTR _pwCharType$[ebp]
  000ae	50		 push	 eax
  000af	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _nLengthA$[ebp]
  000b5	51		 push	 ecx
  000b6	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  000bc	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000c1	50		 push	 eax
  000c2	8b 55 0c	 mov	 edx, DWORD PTR _dwInfoType$[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 08	 mov	 eax, DWORD PTR _lcid$[ebp]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStringTypeExA@20
  000d0	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T201626[ebp], eax
  000d6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000dd	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  000e3	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  000e8	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T201626[ebp]

; 236  : }

  000ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201627:
  00000	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201629
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ENDP		; ATL::GetStringTypeExWFake
PUBLIC	?lstrcmpiWFake@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiW@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWThunk, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 255  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__lstrcmpiW@8
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?lstrcmpiWFake@ATL@@YGHPB_W0@Z ; ATL::lstrcmpiWFake
  0000e	68 08 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 256  : 
; 257  : 	return _strthunks.pfnlstrcmpiW(psz1, psz2);

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _psz2$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _psz1$[ebp]
  00022	52		 push	 edx
  00023	ff 15 08 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8

; 258  : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWThunk
_TEXT	ENDS
EXTRN	__imp__lstrcmpiA@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv94 = -28						; size = 4
tv76 = -24						; size = 4
tv79 = -20						; size = 4
__acp$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWFake@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWFake, COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 248  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f4	 mov	 DWORD PTR __acp$[ebp], eax

; 249  : 
; 250  : 	return ::lstrcmpiA(W2A(psz1), W2A(psz2));

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _psz2$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L201639
  0001a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L201640
$L201639:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e8	 mov	 DWORD PTR tv76[ebp], esp
  00045	8b 45 f4	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e8	 mov	 eax, DWORD PTR tv76[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
$L201640:
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _psz1$[ebp]
  00060	89 4d f8	 mov	 DWORD PTR __lpw$[ebp], ecx
  00063	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00067	75 09		 jne	 SHORT $L201641
  00069	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00070	eb 3a		 jmp	 SHORT $L201642
$L201641:
  00072	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00075	52		 push	 edx
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0007c	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00080	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00083	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008c	e8 00 00 00 00	 call	 __alloca_probe
  00091	89 65 e0	 mov	 DWORD PTR tv91[ebp], esp
  00094	8b 4d f4	 mov	 ecx, DWORD PTR __acp$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 fc	 mov	 edx, DWORD PTR __convert$[ebp]
  0009b	52		 push	 edx
  0009c	8b 45 f8	 mov	 eax, DWORD PTR __lpw$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d e0	 mov	 ecx, DWORD PTR tv91[ebp]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  000a9	89 45 e4	 mov	 DWORD PTR tv94[ebp], eax
$L201642:
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000af	52		 push	 edx
  000b0	8b 45 e4	 mov	 eax, DWORD PTR tv94[ebp]
  000b3	50		 push	 eax
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8

; 251  : }

  000ba	8d 65 e0	 lea	 esp, DWORD PTR [ebp-32]
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
?lstrcmpiWFake@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWFake
_TEXT	ENDS
PUBLIC	?CharLowerWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWFake
EXTRN	__imp__CharLowerW@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWThunk, COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 274  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharLowerW@4
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CharLowerWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharLowerWFake
  0000e	68 0c 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  : 
; 276  : 	return _strthunks.pfnCharLowerW(psz);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 15 0c 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12

; 277  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWThunk
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z		; AtlA2WHelper
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	__imp__CharLowerA@4:NEAR
EXTRN	__imp__wcscpy:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
__lpa$ = -20						; size = 4
__acp$ = -16						; size = 4
_pszA$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWFake, COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 262  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f0	 mov	 DWORD PTR __acp$[ebp], eax

; 263  : 	LPSTR pszA;
; 264  : 
; 265  : 	pszA = W2A(psz);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L201647
  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L201648
$L201647:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e4	 mov	 DWORD PTR tv75[ebp], esp
  00045	8b 45 f0	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$L201648:
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00060	89 4d f4	 mov	 DWORD PTR _pszA$[ebp], ecx

; 266  : 	::CharLowerA(pszA);

  00063	8b 55 f4	 mov	 edx, DWORD PTR _pszA$[ebp]
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharLowerA@4

; 267  : 	wcscpy(psz, A2W(pszA));

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _pszA$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR __lpa$[ebp], eax
  00073	83 7d ec 00	 cmp	 DWORD PTR __lpa$[ebp], 0
  00077	75 09		 jne	 SHORT $L201649
  00079	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00080	eb 3b		 jmp	 SHORT $L201650
$L201649:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00092	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00095	d1 e0		 shl	 eax, 1
  00097	83 c0 03	 add	 eax, 3
  0009a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0009d	e8 00 00 00 00	 call	 __alloca_probe
  000a2	89 65 dc	 mov	 DWORD PTR tv90[ebp], esp
  000a5	8b 55 f0	 mov	 edx, DWORD PTR __acp$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  000ba	89 45 e0	 mov	 DWORD PTR tv94[ebp], eax
$L201650:
  000bd	8b 45 e0	 mov	 eax, DWORD PTR tv94[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  000c4	51		 push	 ecx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000cb	83 c4 08	 add	 esp, 8

; 268  : 
; 269  : 	return psz;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]

; 270  : }

  000d1	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z PROC NEAR		; AtlA2WHelper, COMDAT

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 555  : 	ATLASSERT(lpa != NULL);
; 556  : 	ATLASSERT(lpw != NULL);
; 557  : 	if (lpw == NULL || lpa == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpw$[ebp], 0
  00008	74 06		 je	 SHORT $L24306
  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpa$[ebp], 0
  0000e	75 04		 jne	 SHORT $L24305
$L24306:

; 558  : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 32		 jmp	 SHORT $L24302
$L24305:

; 559  : 	// verify that no illegal character present
; 560  : 	// since lpw was allocated based on the size of lpa
; 561  : 	// don't worry about the number of chars
; 562  : 	lpw[0] = '\0';

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
  00017	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 563  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _nChars$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 08	 mov	 edx, DWORD PTR _lpw$[ebp]
  00023	52		 push	 edx
  00024	6a ff		 push	 -1
  00026	8b 45 0c	 mov	 eax, DWORD PTR _lpa$[ebp]
  00029	50		 push	 eax
  0002a	6a 00		 push	 0
  0002c	8b 4d 14	 mov	 ecx, DWORD PTR _acp$[ebp]
  0002f	51		 push	 ecx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00036	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 564  : 	if(ret == 0)

  00039	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0003d	75 04		 jne	 SHORT $L24308

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);
; 567  : 		return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	eb 03		 jmp	 SHORT $L24302
$L24308:

; 568  : 	}		
; 569  : 	return lpw;

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
$L24302:

; 570  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?CharUpperWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWFake
EXTRN	__imp__CharUpperW@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWThunk, COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharUpperW@4
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CharUpperWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharUpperWFake
  0000e	68 10 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 294  : 
; 295  : 	return _strthunks.pfnCharUpperW(psz);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 15 10 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16

; 296  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWThunk
_TEXT	ENDS
EXTRN	__imp__CharUpperA@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
__lpa$ = -20						; size = 4
__acp$ = -16						; size = 4
_pszA$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWFake, COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 281  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f0	 mov	 DWORD PTR __acp$[ebp], eax

; 282  : 	LPSTR pszA;
; 283  : 
; 284  : 	pszA = W2A(psz);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L201657
  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L201658
$L201657:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e4	 mov	 DWORD PTR tv75[ebp], esp
  00045	8b 45 f0	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$L201658:
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00060	89 4d f4	 mov	 DWORD PTR _pszA$[ebp], ecx

; 285  : 	::CharUpperA(pszA);

  00063	8b 55 f4	 mov	 edx, DWORD PTR _pszA$[ebp]
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharUpperA@4

; 286  : 	wcscpy(psz, A2W(pszA));

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _pszA$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR __lpa$[ebp], eax
  00073	83 7d ec 00	 cmp	 DWORD PTR __lpa$[ebp], 0
  00077	75 09		 jne	 SHORT $L201659
  00079	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00080	eb 3b		 jmp	 SHORT $L201660
$L201659:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00092	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00095	d1 e0		 shl	 eax, 1
  00097	83 c0 03	 add	 eax, 3
  0009a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0009d	e8 00 00 00 00	 call	 __alloca_probe
  000a2	89 65 dc	 mov	 DWORD PTR tv90[ebp], esp
  000a5	8b 55 f0	 mov	 edx, DWORD PTR __acp$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  000ba	89 45 e0	 mov	 DWORD PTR tv94[ebp], eax
$L201660:
  000bd	8b 45 e0	 mov	 eax, DWORD PTR tv94[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  000c4	51		 push	 ecx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000cb	83 c4 08	 add	 esp, 8

; 287  : 
; 288  : 	return psz;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]

; 289  : }

  000d1	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CPoint@@QAE@XZ PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 61   : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CPoint@@QAE@XZ ENDP					; CPoint::CPoint
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC NEAR	; CObject::Serialize, COMDAT
; _this$ = ecx

; 25   : 	{ /* CObject does not serialize anything by default */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC NEAR				; CObject::operator delete, COMDAT

; 31   : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AssertValid@CObject@@UBEXXZ PROC NEAR			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 41   : 	{ /* no asserts in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC NEAR	; CObject::Dump, COMDAT
; _this$ = ecx

; 43   : 	{ /* no dumping in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
EXTRN	?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ:NEAR ; AfxGetModuleState
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
;	COMDAT ?AfxGetApp@@YGPAVCWinApp@@XZ
_TEXT	SEGMENT
?AfxGetApp@@YGPAVCWinApp@@XZ PROC NEAR			; AfxGetApp, COMDAT

; 21   : 	{ return afxCurrentWinApp; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 ?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetModuleState
  00008	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?AfxGetApp@@YGPAVCWinApp@@XZ ENDP			; AfxGetApp
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin2.inl
_TEXT	ENDS
;	COMDAT ?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ PROC NEAR		; CWnd::GetSafeHwnd, COMDAT
; _this$ = ecx

; 27   : 	{ return this == NULL ? NULL : m_hWnd; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  0000d	75 09		 jne	 SHORT $L201675
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00016	eb 09		 jmp	 SHORT $L201676
$L201675:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001e	89 4d f8	 mov	 DWORD PTR tv66[ebp], ecx
$L201676:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ ENDP		; CWnd::GetSafeHwnd
_TEXT	ENDS
EXTRN	?AfxFindResourceHandle@@YGPAUHINSTANCE__@@PBD0@Z:NEAR ; AfxFindResourceHandle
EXTRN	__imp__LoadIconA@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIDResource$ = 8					; size = 4
?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z PROC NEAR	; CWinApp::LoadIconA, COMDAT
; _this$ = ecx

; 1014 : 	{ return ::LoadIcon(AfxFindResourceHandle(MAKEINTRESOURCE(nIDResource),

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1015 : 		RT_GROUP_ICON), MAKEINTRESOURCE(nIDResource)); }

  00007	0f b7 45 08	 movzx	 eax, WORD PTR _nIDResource$[ebp]
  0000b	50		 push	 eax
  0000c	6a 0e		 push	 14			; 0000000eH
  0000e	0f b7 4d 08	 movzx	 ecx, WORD PTR _nIDResource$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?AfxFindResourceHandle@@YGPAUHINSTANCE__@@PBD0@Z ; AfxFindResourceHandle
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z ENDP		; CWinApp::LoadIconA
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 373  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
; Function compile flags: /Odt
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = -4						; size = 4
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 375  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));

  00009	8b 45 08	 mov	 eax, DWORD PTR _nRequestedSize$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 377  : 		if (p == NULL)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0001f	75 04		 jne	 SHORT $L191833

; 378  : 			return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	eb 1a		 jmp	 SHORT $L191820
$L191833:

; 379  : 		
; 380  : 		// Add buffer to the list
; 381  : 		p->m_pNext = m_pHead;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00028	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	89 01		 mov	 DWORD PTR [ecx], eax

; 382  : 		m_pHead = p;

  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00035	89 11		 mov	 DWORD PTR [ecx], edx

; 383  : 		
; 384  : 		return p->GetData();

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
$L191820:

; 385  : 	}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
EXTRN	__imp__malloc:NEAR
; Function compile flags: /Odt
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC NEAR		; ATL::CCRTAllocator::Allocate, COMDAT

; 30   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 		return malloc(nBytes);

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0000d	83 c4 04	 add	 esp, 4

; 32   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
; Function compile flags: /Odt
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$191839 = -4						; size = 4
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 387  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$L191837:

; 388  : 		// Walk the list and free the buffers
; 389  : 		while (m_pHead != NULL)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 22		 je	 SHORT $L191835

; 390  : 		{
; 391  : 			CAtlSafeAllocBufferNode* p = m_pHead;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 fc	 mov	 DWORD PTR _p$191839[ebp], edx

; 392  : 			m_pHead = m_pHead->m_pNext;

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	89 02		 mov	 DWORD PTR [edx], eax

; 393  : 			Allocator::Free(p);

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _p$191839[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  0002e	83 c4 04	 add	 esp, 4

; 394  : 		}

  00031	eb d6		 jmp	 SHORT $L191837
$L191835:

; 395  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
EXTRN	__imp__free:NEAR
; Function compile flags: /Odt
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC NEAR		; ATL::CCRTAllocator::Free, COMDAT

; 35   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   : 		free(p);

  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000d	83 c4 04	 add	 esp, 4

; 37   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 217  : 	}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	39 01		 cmp	 DWORD PTR [ecx], eax
  00012	74 08		 je	 SHORT $L191843

; 227  : 		{
; 228  : 			FreeHeap();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L191843:

; 229  : 		}
; 230  : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 233  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 235  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z		; ATL::CW2AEX<128>::Init
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z PROC NEAR		; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 419  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	89 01		 mov	 DWORD PTR [ecx], eax

; 420  : 		Init( psz, _AtlGetConversionACP() );

  00012	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00017	50		 push	 eax
  00018	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  0001b	52		 push	 edx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init

; 421  : 	}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC NEAR			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 428  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 429  : 		if( m_psz != m_szBuffer )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	39 01		 cmp	 DWORD PTR [ecx], eax
  00012	74 0f		 je	 SHORT $L191854

; 430  : 		{
; 431  : 			free( m_psz );

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 02		 mov	 eax, DWORD PTR [edx]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00020	83 c4 04	 add	 esp, 4
$L191854:

; 432  : 		}
; 433  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC NEAR		; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 436  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 437  : 		return( m_psz );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 438  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );
; 278  : 		if( nBytes > t_nFixedBytes )

  00007	81 7d 08 80 00
	00 00		 cmp	 DWORD PTR _nBytes$[ebp], 128 ; 00000080H
  0000e	76 0e		 jbe	 SHORT $L193612

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

  00010	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

  0001c	eb 0b		 jmp	 SHORT $L193613
$L193612:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 04	 add	 ecx, 4
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	89 0a		 mov	 DWORD PTR [edx], ecx
$L193613:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]

; 288  : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  00012	83 c4 04	 add	 esp, 4

; 314  : 	}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nLengthW$ = -8						; size = 4
_nLengthA$ = -4						; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z PROC NEAR		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 442  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 443  : 		if (psz == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  0000d	75 0b		 jne	 SHORT $L193619

; 444  : 		{
; 445  : 			m_psz = NULL;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 446  : 			return;

  00018	eb 70		 jmp	 SHORT $L201708
$L193619:

; 447  : 		}
; 448  : 		int nLengthW = lstrlenW( psz )+1;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001d	51		 push	 ecx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00024	83 c0 01	 add	 eax, 1
  00027	89 45 f8	 mov	 DWORD PTR _nLengthW$[ebp], eax

; 449  : 		int nLengthA = nLengthW*2;

  0002a	8b 55 f8	 mov	 edx, DWORD PTR _nLengthW$[ebp]
  0002d	d1 e2		 shl	 edx, 1
  0002f	89 55 fc	 mov	 DWORD PTR _nLengthA$[ebp], edx

; 450  : 
; 451  : 		if( nLengthA > t_nBufferLength )

  00032	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _nLengthA$[ebp], 128 ; 00000080H
  00039	7e 24		 jle	 SHORT $L193622

; 452  : 		{
; 453  : 			m_psz = static_cast< LPSTR >( malloc( nLengthA*sizeof( char ) ) );

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _nLengthA$[ebp]
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00045	83 c4 04	 add	 esp, 4
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 454  : 			if (m_psz == NULL)

  0004d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00050	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00053	75 0a		 jne	 SHORT $L193622

; 455  : 			{
; 456  : 				AtlThrow( E_OUTOFMEMORY );

  00055	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0005a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L193622:

; 457  : 			}
; 458  : 		}
; 459  : 
; 460  : 		if (::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ) == 0)

  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	8b 45 fc	 mov	 eax, DWORD PTR _nLengthA$[ebp]
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	52		 push	 edx
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _nLengthW$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  00074	51		 push	 ecx
  00075	6a 00		 push	 0
  00077	8b 55 0c	 mov	 edx, DWORD PTR _nCodePage$[ebp]
  0007a	52		 push	 edx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00081	85 c0		 test	 eax, eax
  00083	75 05		 jne	 SHORT $L201708

; 461  : 		{
; 462  : 			AtlThrowLastWin32();

  00085	e8 00 00 00 00	 call	 ?AtlThrowLastWin32@ATL@@YGXXZ ; ATL::AtlThrowLastWin32
$L201708:

; 463  : 		}
; 464  : 	}

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ENDP		; ATL::CW2AEX<128>::Init
_TEXT	ENDS
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_dwError$ = -4						; size = 4
?AtlThrowLastWin32@ATL@@YGXXZ PROC NEAR			; ATL::AtlThrowLastWin32, COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 81   : 	DWORD dwError = ::GetLastError();

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0000c	89 45 fc	 mov	 DWORD PTR _dwError$[ebp], eax

; 82   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

  0000f	83 7d fc 00	 cmp	 DWORD PTR _dwError$[ebp], 0
  00013	7f 08		 jg	 SHORT $L201711
  00015	8b 45 fc	 mov	 eax, DWORD PTR _dwError$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001b	eb 18		 jmp	 SHORT $L201712
$L201711:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _dwError$[ebp]
  00020	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00026	81 c9 00 00 07
	00		 or	 ecx, 458752		; 00070000H
  0002c	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  00032	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
$L201712:
  00035	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L201710:

; 83   : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 365  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 366  : 			return (this + 1);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8

; 367  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00009	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

  00018	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0001c	75 0a		 jne	 SHORT $L194985

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

  0001e	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00023	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L194985:

; 297  : 		}
; 298  : 		m_p = p;

  00028	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0002e	89 11		 mov	 DWORD PTR [ecx], edx
$L201716:

; 299  : 	}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
EXTRN	__imp__RegisterWindowMessageA@4:NEAR
CRT$XCU	SEGMENT
_$S6	DD	FLAT:_$E5
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\tray\trayicon.cpp
CRT$XCU	ENDS
;	COMDAT _$E5
text$yc	SEGMENT
_$E5	PROC NEAR					; COMDAT

; 24   : const UINT WM_TASKBARCREATED = ::RegisterWindowMessage(_T("TaskbarCreated"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET FLAT:$SG200458
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000e	a3 00 00 00 00	 mov	 DWORD PTR _WM_TASKBARCREATED, eax
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_$E5	ENDP
text$yc	ENDS
_BSS	SEGMENT
_WM_TASKBARCREATED DD 01H DUP (?)
_BSS	ENDS
END
