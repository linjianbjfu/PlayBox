; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\util\Markup.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04JAADICNI@?5?$DN?1?$FL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??1CMarkup@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetPos@CMarkup@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ElemPos@CMarkup@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmptyElement@ElemPos@CMarkup@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@ElemPos@CMarkup@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustStart@ElemPos@CMarkup@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustEnd@ElemPos@CMarkup@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TokenPos@CMarkup@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@TokenPos@CMarkup@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Match@TokenPos@CMarkup@@QAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?x_SetPos@CMarkup@@IAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMarkup@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@D@ATL@@SAPBDPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CArray@UElemPos@CMarkup@@AAU12@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Append@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CArray@UElemPos@CMarkup@@AAU12@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CArray@UElemPos@CMarkup@@AAU12@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CArray@UElemPos@CMarkup@@AAU12@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ElementAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$CopyElements@UElemPos@CMarkup@@@@YGXPAUElemPos@CMarkup@@PBU01@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$SerializeElements@UElemPos@CMarkup@@@@YGXAAVCArchive@@PAUElemPos@CMarkup@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CMarkup@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@UElemPos@CMarkup@@AAU12@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CMarkup@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@UElemPos@CMarkup@@AAU12@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMarkup@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$CArray@UElemPos@CMarkup@@AAU12@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCMarkup@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$CArray@UElemPos@CMarkup@@AAU12@@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CMarkup@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$CArray@UElemPos@CMarkup@@AAU12@@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CArchive@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CArray@UElemPos@CMarkup@@AAU12@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?szSymbol@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PADA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?szaCode@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PAPADA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?anCodeLen@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PAHA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __tccpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?szaReplace@?1??x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z@4PAPADA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __tcsncmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __tcsstr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __tclen
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __tcschr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __tcsnccmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMarkup@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
CONST	SEGMENT
$SG197765 DB	'Element tag not found', 00H
	ORG $+2
$SG197769 DB	'Tag starts with quote', 00H
	ORG $+2
$SG197775 DB	'Invalid node', 00H
	ORG $+3
$SG197781 DB	'End of tag not found', 00H
	ORG $+3
$SG197786 DB	'Abrupt end within tag', 00H
	ORG $+2
$SG197800 DB	'End tag of %s element not found', 00H
$SG197808 DB	'Expecting end tag of element %s', 00H
$SG197812 DB	'End tag does not correspond to %s', 00H
	ORG $+2
$SG197818 DB	'End tag not completed for element %s', 00H
	ORG $+3
$SG197838 DB	' ', 09H, 0aH, 0dH, 00H
	ORG $+3
$SG197853 DB	' ', 09H, 0aH, 0dH, '<>=\/?!', 00H
$SG197862 DB	00H
	ORG $+3
$SG197891 DB	'?>', 00H
	ORG $+1
$SG197896 DB	']]>', 00H
$SG197899 DB	'-->', 00H
$SG197933 DB	00H
$SG197965 DB	00H
$SG197968 DB	00H
	ORG $+1
$SG197985 DB	' ', 00H
	ORG $+2
$SG197986 DB	'="', 00H
	ORG $+1
$SG197991 DB	'"', 00H
	ORG $+2
$SG198004 DB	'<![CDATA[', 00H
	ORG $+2
$SG198006 DB	']]>', 00H
$SG198010 DB	00H
	ORG $+3
$SG198023 DB	'&quot;', 00H
	ORG $+1
$SG198022 DB	'&apos;', 00H
	ORG $+1
$SG198021 DB	'&gt;', 00H
	ORG $+3
$SG198020 DB	'&amp;', 00H
	ORG $+2
$SG198019 DB	'&lt;', 00H
	ORG $+3
$SG198025 DB	'<&>''"', 00H
	ORG $+2
$SG198026 DB	'<&>', 00H
$SG198056 DB	'quot;', 00H
	ORG $+2
$SG198055 DB	'apos;', 00H
	ORG $+2
$SG198054 DB	'gt;', 00H
$SG198053 DB	'amp;', 00H
	ORG $+3
$SG198052 DB	'lt;', 00H
$SG198061 DB	'<&>''"', 00H
	ORG $+2
$SG198199 DB	'<', 00H
	ORG $+2
$SG198200 DB	'/>', 0dH, 0aH, 00H
	ORG $+3
$SG198204 DB	'<', 00H
	ORG $+2
$SG198205 DB	'>', 00H
	ORG $+2
$SG198206 DB	'</', 00H
	ORG $+1
$SG198207 DB	'>', 0dH, 0aH, 00H
$SG198214 DB	'>', 0dH, 0aH, 00H
$SG198215 DB	'</', 00H
	ORG $+1
$SG198219 DB	0dH, 0aH, 00H
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
PUBLIC	??4CMarkup@@QAEXABV0@@Z				; CMarkup::operator=
PUBLIC	?RemoveAll@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXXZ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::RemoveAll
PUBLIC	?Append@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEHABV1@@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::Append
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:NEAR
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_markup$ = 8						; size = 4
??4CMarkup@@QAEXABV0@@Z PROC NEAR			; CMarkup::operator=
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 	m_iPosParent = markup.m_iPosParent;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _markup$[ebp]
  0000d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00010	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 28   : 	m_iPos = markup.m_iPos;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _markup$[ebp]
  00019	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0001c	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 29   : 	m_iPosChild = markup.m_iPosChild;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _markup$[ebp]
  00025	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00028	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 30   : 	m_iPosFree = markup.m_iPosFree;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _markup$[ebp]
  00031	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00034	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 31   : 	m_nNodeType = markup.m_nNodeType;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _markup$[ebp]
  0003d	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00040	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 32   : 	m_aPos.RemoveAll();

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00049	e8 00 00 00 00	 call	 ?RemoveAll@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXXZ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::RemoveAll

; 33   : 	m_aPos.Append( markup.m_aPos );

  0004e	8b 45 08	 mov	 eax, DWORD PTR _markup$[ebp]
  00051	83 c0 0c	 add	 eax, 12			; 0000000cH
  00054	50		 push	 eax
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0005b	e8 00 00 00 00	 call	 ?Append@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEHABV1@@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::Append

; 34   : 	m_csDoc = markup.m_csDoc;

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _markup$[ebp]
  00063	83 c1 04	 add	 ecx, 4
  00066	51		 push	 ecx
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 35   : 	MARKUP_SETDEBUGSTATE;
; 36   : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
??4CMarkup@@QAEXABV0@@Z ENDP				; CMarkup::operator=
_TEXT	ENDS
PUBLIC	?SetDoc@CMarkup@@QAE_NPBD@Z			; CMarkup::SetDoc
PUBLIC	?ResetPos@CMarkup@@QAEXXZ			; CMarkup::ResetPos
PUBLIC	?Clear@ElemPos@CMarkup@@QAEXXZ			; CMarkup::ElemPos::Clear
PUBLIC	?GetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEHXZ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::GetSize
PUBLIC	?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::SetSize
PUBLIC	??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
PUBLIC	?x_ParseElem@CMarkup@@IAEHH@Z			; CMarkup::x_ParseElem
EXTRN	__imp_?Empty@?$CSimpleStringT@D$00@ATL@@QAEXXZ:NEAR
EXTRN	__imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ:NEAR
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -16						; size = 4
_iPos$197702 = -12					; size = 4
_nStartSize$ = -8					; size = 4
_bWellFormed$ = -1					; size = 1
_szDoc$ = 8						; size = 4
?SetDoc@CMarkup@@QAE_NPBD@Z PROC NEAR			; CMarkup::SetDoc
; _this$ = ecx

; 39   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	83 ec 10	 sub	 esp, 16			; 00000010H
  00086	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 	// Reset indexes
; 41   : 	m_iPosFree = 1;

  00089	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1

; 42   : 	ResetPos();

  00093	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?ResetPos@CMarkup@@QAEXXZ ; CMarkup::ResetPos

; 43   : 
; 44   : 	// Set document text
; 45   : 	if ( szDoc )

  0009b	83 7d 08 00	 cmp	 DWORD PTR _szDoc$[ebp], 0
  0009f	74 12		 je	 SHORT $L197696

; 46   : 		m_csDoc = szDoc;

  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _szDoc$[ebp]
  000a4	51		 push	 ecx
  000a5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	83 c1 04	 add	 ecx, 4
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 47   : 	else

  000b1	eb 0c		 jmp	 SHORT $L197697
$L197696:

; 48   : 		m_csDoc.Empty();

  000b3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	83 c1 04	 add	 ecx, 4
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Empty@?$CSimpleStringT@D$00@ATL@@QAEXXZ
$L197697:

; 49   : 
; 50   : 	// Starting size of position array: 1 element per 64 bytes of document
; 51   : 	// Tight fit when parsing small doc, only 0 to 2 reallocs when parsing large doc
; 52   : 	// Start at 8 when creating new document
; 53   : 	int nStartSize = m_csDoc.GetLength() / 64 + 8;

  000bf	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	83 c1 04	 add	 ecx, 4
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  000cb	99		 cdq
  000cc	83 e2 3f	 and	 edx, 63			; 0000003fH
  000cf	03 c2		 add	 eax, edx
  000d1	c1 f8 06	 sar	 eax, 6
  000d4	83 c0 08	 add	 eax, 8
  000d7	89 45 f8	 mov	 DWORD PTR _nStartSize$[ebp], eax

; 54   : 	if ( m_aPos.GetSize() < nStartSize )

  000da	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000e0	e8 00 00 00 00	 call	 ?GetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEHXZ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::GetSize
  000e5	3b 45 f8	 cmp	 eax, DWORD PTR _nStartSize$[ebp]
  000e8	7d 11		 jge	 SHORT $L197699

; 55   : 		m_aPos.SetSize( nStartSize );

  000ea	6a ff		 push	 -1
  000ec	8b 55 f8	 mov	 edx, DWORD PTR _nStartSize$[ebp]
  000ef	52		 push	 edx
  000f0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000f6	e8 00 00 00 00	 call	 ?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::SetSize
$L197699:

; 56   : 
; 57   : 	// Parse document
; 58   : 	bool bWellFormed = false;

  000fb	c6 45 ff 00	 mov	 BYTE PTR _bWellFormed$[ebp], 0

; 59   : 	if ( m_csDoc.GetLength() )

  000ff	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	83 c1 04	 add	 ecx, 4
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  0010b	85 c0		 test	 eax, eax
  0010d	74 3e		 je	 SHORT $L197701

; 60   : 	{
; 61   : 		m_aPos[0].Clear();

  0010f	6a 00		 push	 0
  00111	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00114	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00117	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0011c	8b c8		 mov	 ecx, eax
  0011e	e8 00 00 00 00	 call	 ?Clear@ElemPos@CMarkup@@QAEXXZ ; CMarkup::ElemPos::Clear

; 62   : 		int iPos = x_ParseElem( 0 );

  00123	6a 00		 push	 0
  00125	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00128	e8 00 00 00 00	 call	 ?x_ParseElem@CMarkup@@IAEHH@Z ; CMarkup::x_ParseElem
  0012d	89 45 f4	 mov	 DWORD PTR _iPos$197702[ebp], eax

; 63   : 		if ( iPos > 0 )

  00130	83 7d f4 00	 cmp	 DWORD PTR _iPos$197702[ebp], 0
  00134	7e 17		 jle	 SHORT $L197701

; 64   : 		{
; 65   : 			m_aPos[0].iElemChild = iPos;

  00136	6a 00		 push	 0
  00138	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0013e	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00143	8b 4d f4	 mov	 ecx, DWORD PTR _iPos$197702[ebp]
  00146	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 66   : 			bWellFormed = true;

  00149	c6 45 ff 01	 mov	 BYTE PTR _bWellFormed$[ebp], 1
$L197701:

; 67   : 		}
; 68   : 	}
; 69   : 
; 70   : 	// Clear indexes if parse failed or empty document
; 71   : 	if ( ! bWellFormed )

  0014d	0f b6 55 ff	 movzx	 edx, BYTE PTR _bWellFormed$[ebp]
  00151	85 d2		 test	 edx, edx
  00153	75 1e		 jne	 SHORT $L197704

; 72   : 	{
; 73   : 		m_aPos[0].Clear();

  00155	6a 00		 push	 0
  00157	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0015d	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00162	8b c8		 mov	 ecx, eax
  00164	e8 00 00 00 00	 call	 ?Clear@ElemPos@CMarkup@@QAEXXZ ; CMarkup::ElemPos::Clear

; 74   : 		m_iPosFree = 1;

  00169	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0016c	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1
$L197704:

; 75   : 	}
; 76   : 
; 77   : 	ResetPos();

  00173	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	e8 00 00 00 00	 call	 ?ResetPos@CMarkup@@QAEXXZ ; CMarkup::ResetPos

; 78   : 	return bWellFormed;

  0017b	8a 45 ff	 mov	 al, BYTE PTR _bWellFormed$[ebp]

; 79   : };

  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c2 04 00	 ret	 4
?SetDoc@CMarkup@@QAE_NPBD@Z ENDP			; CMarkup::SetDoc
_TEXT	ENDS
PUBLIC	?x_SetPos@CMarkup@@IAEXHHH@Z			; CMarkup::x_SetPos
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.h
;	COMDAT ?ResetPos@CMarkup@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetPos@CMarkup@@QAEXXZ PROC NEAR			; CMarkup::ResetPos, COMDAT
; _this$ = ecx

; 53   : 	void ResetPos() { x_SetPos(0,0,0); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?x_SetPos@CMarkup@@IAEXHHH@Z ; CMarkup::x_SetPos
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?ResetPos@CMarkup@@QAEXXZ ENDP				; CMarkup::ResetPos
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Clear@ElemPos@CMarkup@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@ElemPos@CMarkup@@QAEXXZ PROC NEAR		; CMarkup::ElemPos::Clear, COMDAT
; _this$ = ecx

; 90   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 91   : 			nStartL=0; nStartR=0; nEndL=0; nEndR=0; nReserved=0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 92   : 			iElemParent=0; iElemChild=0; iElemNext=0;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 93   : 		};

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?Clear@ElemPos@CMarkup@@QAEXXZ ENDP			; CMarkup::ElemPos::Clear
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?x_SetPos@CMarkup@@IAEXHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iPosParent$ = 8					; size = 4
_iPos$ = 12						; size = 4
_iPosChild$ = 16					; size = 4
?x_SetPos@CMarkup@@IAEXHHH@Z PROC NEAR			; CMarkup::x_SetPos, COMDAT
; _this$ = ecx

; 132  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 133  : 		m_iPosParent = iPosParent;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  0000d	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 134  : 		m_iPos = iPos;

  00010	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00013	8b 45 0c	 mov	 eax, DWORD PTR _iPos$[ebp]
  00016	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 135  : 		m_iPosChild = iPosChild;

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 55 10	 mov	 edx, DWORD PTR _iPosChild$[ebp]
  0001f	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 136  : 		m_nNodeType = iPos?MNT_ELEMENT:0;

  00022	33 c0		 xor	 eax, eax
  00024	83 7d 0c 00	 cmp	 DWORD PTR _iPos$[ebp], 0
  00028	0f 95 c0	 setne	 al
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 137  : 		MARKUP_SETDEBUGSTATE;
; 138  : 	};

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?x_SetPos@CMarkup@@IAEXHHH@Z ENDP			; CMarkup::x_SetPos
_TEXT	ENDS
PUBLIC	?IsWellFormed@CMarkup@@QAE_NXZ			; CMarkup::IsWellFormed
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWellFormed@CMarkup@@QAE_NXZ PROC NEAR		; CMarkup::IsWellFormed
; _this$ = ecx

; 82   : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp
  00193	51		 push	 ecx
  00194	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 83   : 	if ( m_aPos.GetSize() && m_aPos[0].iElemChild )

  00197	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0019a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0019d	e8 00 00 00 00	 call	 ?GetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEHXZ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::GetSize
  001a2	85 c0		 test	 eax, eax
  001a4	74 17		 je	 SHORT $L197708
  001a6	6a 00		 push	 0
  001a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001ae	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  001b3	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  001b7	74 04		 je	 SHORT $L197708

; 84   : 		return true;

  001b9	b0 01		 mov	 al, 1
  001bb	eb 02		 jmp	 SHORT $L197707
$L197708:

; 85   : 	return false;

  001bd	32 c0		 xor	 al, al
$L197707:

; 86   : }

  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
?IsWellFormed@CMarkup@@QAE_NXZ ENDP			; CMarkup::IsWellFormed
_TEXT	ENDS
PUBLIC	?FindElem@CMarkup@@QAE_NPBD@Z			; CMarkup::FindElem
PUBLIC	?x_FindElem@CMarkup@@IAEHHHPBD@Z		; CMarkup::x_FindElem
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iPos$197714 = -4					; size = 4
_szName$ = 8						; size = 4
?FindElem@CMarkup@@QAE_NPBD@Z PROC NEAR			; CMarkup::FindElem
; _this$ = ecx

; 89   : {

  001d0	55		 push	 ebp
  001d1	8b ec		 mov	 ebp, esp
  001d3	83 ec 08	 sub	 esp, 8
  001d6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 90   : 	// Change current position only if found
; 91   : 	//
; 92   : 	if ( m_aPos.GetSize() )

  001d9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001dc	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001df	e8 00 00 00 00	 call	 ?GetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEHXZ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::GetSize
  001e4	85 c0		 test	 eax, eax
  001e6	74 48		 je	 SHORT $L197713

; 93   : 	{
; 94   : 		int iPos = x_FindElem( m_iPosParent, m_iPos, szName );

  001e8	8b 45 08	 mov	 eax, DWORD PTR _szName$[ebp]
  001eb	50		 push	 eax
  001ec	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ef	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  001f2	52		 push	 edx
  001f3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001f6	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001f9	51		 push	 ecx
  001fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fd	e8 00 00 00 00	 call	 ?x_FindElem@CMarkup@@IAEHHHPBD@Z ; CMarkup::x_FindElem
  00202	89 45 fc	 mov	 DWORD PTR _iPos$197714[ebp], eax

; 95   : 		if ( iPos )

  00205	83 7d fc 00	 cmp	 DWORD PTR _iPos$197714[ebp], 0
  00209	74 25		 je	 SHORT $L197713

; 96   : 		{
; 97   : 			// Assign new position
; 98   : 			x_SetPos( m_aPos[iPos].iElemParent, iPos, 0 );

  0020b	6a 00		 push	 0
  0020d	8b 55 fc	 mov	 edx, DWORD PTR _iPos$197714[ebp]
  00210	52		 push	 edx
  00211	8b 45 fc	 mov	 eax, DWORD PTR _iPos$197714[ebp]
  00214	50		 push	 eax
  00215	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00218	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0021b	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00220	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00223	51		 push	 ecx
  00224	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00227	e8 00 00 00 00	 call	 ?x_SetPos@CMarkup@@IAEXHHH@Z ; CMarkup::x_SetPos

; 99   : 			return true;

  0022c	b0 01		 mov	 al, 1
  0022e	eb 02		 jmp	 SHORT $L197712
$L197713:

; 100  : 		}
; 101  : 	}
; 102  : 	return false;

  00230	32 c0		 xor	 al, al
$L197712:

; 103  : }

  00232	8b e5		 mov	 esp, ebp
  00234	5d		 pop	 ebp
  00235	c2 04 00	 ret	 4
?FindElem@CMarkup@@QAE_NPBD@Z ENDP			; CMarkup::FindElem
_TEXT	ENDS
PUBLIC	?FindChildElem@CMarkup@@QAE_NPBD@Z		; CMarkup::FindChildElem
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iPos$197723 = -8					; size = 4
_iPosChild$ = -4					; size = 4
_szName$ = 8						; size = 4
?FindChildElem@CMarkup@@QAE_NPBD@Z PROC NEAR		; CMarkup::FindChildElem
; _this$ = ecx

; 106  : {

  00240	55		 push	 ebp
  00241	8b ec		 mov	 ebp, esp
  00243	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00246	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 107  : 	// Change current child position only if found
; 108  : 	//
; 109  : 	// Shorthand: call this with no current main position
; 110  : 	// means find child under root element
; 111  : 	if ( ! m_iPos )

  00249	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0024c	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00250	75 0a		 jne	 SHORT $L197720

; 112  : 		FindElem();

  00252	6a 00		 push	 0
  00254	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00257	e8 00 00 00 00	 call	 ?FindElem@CMarkup@@QAE_NPBD@Z ; CMarkup::FindElem
$L197720:

; 113  : 
; 114  : 	int iPosChild = x_FindElem( m_iPos, m_iPosChild, szName );

  0025c	8b 4d 08	 mov	 ecx, DWORD PTR _szName$[ebp]
  0025f	51		 push	 ecx
  00260	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00263	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00266	50		 push	 eax
  00267	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0026a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0026d	52		 push	 edx
  0026e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00271	e8 00 00 00 00	 call	 ?x_FindElem@CMarkup@@IAEHHHPBD@Z ; CMarkup::x_FindElem
  00276	89 45 fc	 mov	 DWORD PTR _iPosChild$[ebp], eax

; 115  : 	if ( iPosChild )

  00279	83 7d fc 00	 cmp	 DWORD PTR _iPosChild$[ebp], 0
  0027d	74 3c		 je	 SHORT $L197722

; 116  : 	{
; 117  : 		// Assign new position
; 118  : 		int iPos = m_aPos[iPosChild].iElemParent;

  0027f	8b 45 fc	 mov	 eax, DWORD PTR _iPosChild$[ebp]
  00282	50		 push	 eax
  00283	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00286	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00289	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0028e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00291	89 4d f8	 mov	 DWORD PTR _iPos$197723[ebp], ecx

; 119  : 		x_SetPos( m_aPos[iPos].iElemParent, iPos, iPosChild );

  00294	8b 55 fc	 mov	 edx, DWORD PTR _iPosChild$[ebp]
  00297	52		 push	 edx
  00298	8b 45 f8	 mov	 eax, DWORD PTR _iPos$197723[ebp]
  0029b	50		 push	 eax
  0029c	8b 4d f8	 mov	 ecx, DWORD PTR _iPos$197723[ebp]
  0029f	51		 push	 ecx
  002a0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002a3	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002a6	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  002ab	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  002ae	52		 push	 edx
  002af	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002b2	e8 00 00 00 00	 call	 ?x_SetPos@CMarkup@@IAEXHHH@Z ; CMarkup::x_SetPos

; 120  : 		return true;

  002b7	b0 01		 mov	 al, 1
  002b9	eb 02		 jmp	 SHORT $L197719
$L197722:

; 121  : 	}
; 122  : 
; 123  : 	return false;

  002bb	32 c0		 xor	 al, al
$L197719:

; 124  : }

  002bd	8b e5		 mov	 esp, ebp
  002bf	5d		 pop	 ebp
  002c0	c2 04 00	 ret	 4
?FindChildElem@CMarkup@@QAE_NPBD@Z ENDP			; CMarkup::FindChildElem
_TEXT	ENDS
PUBLIC	?GetTagName@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; CMarkup::GetTagName
PUBLIC	?x_GetTagName@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CMarkup::x_GetTagName
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T199088 DD	0ffffffffH
	DD	FLAT:$L199077
	DD	00H
	DD	FLAT:$L199078
$T199085 DD	019930520H
	DD	02H
	DD	FLAT:$T199088
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv84 = -36						; size = 4
tv65 = -32						; size = 4
_this$ = -28						; size = 4
$T199080 = -24						; size = 4
$T199076 = -20						; size = 4
_csTagName$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetTagName@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC NEAR ; CMarkup::GetTagName
; _this$ = ecx

; 128  : {

  002d0	55		 push	 ebp
  002d1	8b ec		 mov	 ebp, esp
  002d3	6a ff		 push	 -1
  002d5	68 00 00 00 00	 push	 __ehhandler$?GetTagName@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
  002da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  002e0	50		 push	 eax
  002e1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  002e8	83 ec 18	 sub	 esp, 24			; 00000018H
  002eb	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  002ee	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T199080[ebp], 0

; 129  : 	// Return the tag name at the current main position
; 130  : 	CString csTagName;

  002f5	8d 4d f0	 lea	 ecx, DWORD PTR _csTagName$[ebp]
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  002fe	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 131  : 
; 132  : 
; 133  : 	if ( m_iPos )

  00305	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00308	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0030c	74 3a		 je	 SHORT $L197729

; 134  : 		csTagName = x_GetTagName( m_iPos );

  0030e	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00311	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00314	52		 push	 edx
  00315	8d 45 ec	 lea	 eax, DWORD PTR $T199076[ebp]
  00318	50		 push	 eax
  00319	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0031c	e8 00 00 00 00	 call	 ?x_GetTagName@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CMarkup::x_GetTagName
  00321	89 45 e0	 mov	 DWORD PTR tv65[ebp], eax
  00324	8b 4d e0	 mov	 ecx, DWORD PTR tv65[ebp]
  00327	89 4d dc	 mov	 DWORD PTR tv84[ebp], ecx
  0032a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0032e	8b 55 dc	 mov	 edx, DWORD PTR tv84[ebp]
  00331	52		 push	 edx
  00332	8d 4d f0	 lea	 ecx, DWORD PTR _csTagName$[ebp]
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0033b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0033f	8d 4d ec	 lea	 ecx, DWORD PTR $T199076[ebp]
  00342	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L197729:

; 135  : 	return csTagName;

  00348	8d 45 f0	 lea	 eax, DWORD PTR _csTagName$[ebp]
  0034b	50		 push	 eax
  0034c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0034f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00355	8b 4d e8	 mov	 ecx, DWORD PTR $T199080[ebp]
  00358	83 c9 01	 or	 ecx, 1
  0035b	89 4d e8	 mov	 DWORD PTR $T199080[ebp], ecx
  0035e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00365	8d 4d f0	 lea	 ecx, DWORD PTR _csTagName$[ebp]
  00368	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0036e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 136  : }

  00371	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00374	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0037b	8b e5		 mov	 esp, ebp
  0037d	5d		 pop	 ebp
  0037e	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L199077:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _csTagName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L199078:
  00009	8d 4d ec	 lea	 ecx, DWORD PTR $T199076[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?GetTagName@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199085
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetTagName@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; CMarkup::GetTagName
PUBLIC	?IntoElem@CMarkup@@QAE_NXZ			; CMarkup::IntoElem
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IntoElem@CMarkup@@QAE_NXZ PROC NEAR			; CMarkup::IntoElem
; _this$ = ecx

; 139  : {

  00390	55		 push	 ebp
  00391	8b ec		 mov	 ebp, esp
  00393	51		 push	 ecx
  00394	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 	// If there is no child position and IntoElem is called it will succeed in release 6.3
; 141  : 	// (A subsequent call to FindElem will find the first element)
; 142  : 	// The following short-hand behavior was never part of EDOM and was misleading
; 143  : 	// It would find a child element if there was no current child element position and go into it
; 144  : 	// It is removed in release 6.3, this change is NOT backwards compatible!
; 145  : 	// if ( ! m_iPosChild )
; 146  : 	//	FindChildElem();
; 147  : 
; 148  : 	if ( m_iPos && m_nNodeType == MNT_ELEMENT )

  00397	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0039a	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0039e	74 25		 je	 SHORT $L197734
  003a0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a3	83 79 30 01	 cmp	 DWORD PTR [ecx+48], 1
  003a7	75 1c		 jne	 SHORT $L197734

; 149  : 	{
; 150  : 		x_SetPos( m_iPos, m_iPosChild, 0 );

  003a9	6a 00		 push	 0
  003ab	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003ae	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  003b1	50		 push	 eax
  003b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003b5	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  003b8	52		 push	 edx
  003b9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003bc	e8 00 00 00 00	 call	 ?x_SetPos@CMarkup@@IAEXHHH@Z ; CMarkup::x_SetPos

; 151  : 		return true;

  003c1	b0 01		 mov	 al, 1
  003c3	eb 02		 jmp	 SHORT $L197733
$L197734:

; 152  : 	}
; 153  : 	return false;

  003c5	32 c0		 xor	 al, al
$L197733:

; 154  : }

  003c7	8b e5		 mov	 esp, ebp
  003c9	5d		 pop	 ebp
  003ca	c3		 ret	 0
?IntoElem@CMarkup@@QAE_NXZ ENDP				; CMarkup::IntoElem
_TEXT	ENDS
PUBLIC	?OutOfElem@CMarkup@@QAE_NXZ			; CMarkup::OutOfElem
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OutOfElem@CMarkup@@QAE_NXZ PROC NEAR			; CMarkup::OutOfElem
; _this$ = ecx

; 157  : {

  003d0	55		 push	 ebp
  003d1	8b ec		 mov	 ebp, esp
  003d3	51		 push	 ecx
  003d4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 158  : 	// Go to parent element
; 159  : 	if ( m_iPosParent )

  003d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003da	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  003de	74 30		 je	 SHORT $L197738

; 160  : 	{
; 161  : 		x_SetPos( m_aPos[m_iPosParent].iElemParent, m_iPosParent, m_iPos );

  003e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003e3	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  003e6	52		 push	 edx
  003e7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003ea	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  003ed	51		 push	 ecx
  003ee	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003f1	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  003f4	50		 push	 eax
  003f5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003f8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  003fb	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00400	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00403	51		 push	 ecx
  00404	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00407	e8 00 00 00 00	 call	 ?x_SetPos@CMarkup@@IAEXHHH@Z ; CMarkup::x_SetPos

; 162  : 		return true;

  0040c	b0 01		 mov	 al, 1
  0040e	eb 02		 jmp	 SHORT $L197737
$L197738:

; 163  : 	}
; 164  : 	return false;

  00410	32 c0		 xor	 al, al
$L197737:

; 165  : }

  00412	8b e5		 mov	 esp, ebp
  00414	5d		 pop	 ebp
  00415	c3		 ret	 0
?OutOfElem@CMarkup@@QAE_NXZ ENDP			; CMarkup::OutOfElem
_TEXT	ENDS
PUBLIC	?x_GetFreePos@CMarkup@@IAEHXZ			; CMarkup::x_GetFreePos
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?x_GetFreePos@CMarkup@@IAEHXZ PROC NEAR			; CMarkup::x_GetFreePos
; _this$ = ecx

; 172  : {

  00420	55		 push	 ebp
  00421	8b ec		 mov	 ebp, esp
  00423	51		 push	 ecx
  00424	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 173  : 	//
; 174  : 	// This returns the index of the next unused ElemPos in the array
; 175  : 	//
; 176  : 	if ( m_iPosFree == m_aPos.GetSize() )

  00427	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0042a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0042d	e8 00 00 00 00	 call	 ?GetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEHXZ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::GetSize
  00432	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00435	39 41 2c	 cmp	 DWORD PTR [ecx+44], eax
  00438	75 1f		 jne	 SHORT $L197742

; 177  : 		m_aPos.SetSize( m_iPosFree + m_iPosFree / 2 );

  0043a	6a ff		 push	 -1
  0043c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0043f	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00442	99		 cdq
  00443	2b c2		 sub	 eax, edx
  00445	d1 f8		 sar	 eax, 1
  00447	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0044a	03 41 2c	 add	 eax, DWORD PTR [ecx+44]
  0044d	50		 push	 eax
  0044e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00451	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00454	e8 00 00 00 00	 call	 ?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::SetSize
$L197742:

; 178  : 	++m_iPosFree;

  00459	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0045c	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0045f	83 c0 01	 add	 eax, 1
  00462	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00465	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 179  : 	return m_iPosFree - 1;

  00468	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0046b	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0046e	83 e8 01	 sub	 eax, 1

; 180  : }

  00471	8b e5		 mov	 esp, ebp
  00473	5d		 pop	 ebp
  00474	c3		 ret	 0
?x_GetFreePos@CMarkup@@IAEHXZ ENDP			; CMarkup::x_GetFreePos
_TEXT	ENDS
PUBLIC	?x_ReleasePos@CMarkup@@IAEHXZ			; CMarkup::x_ReleasePos
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?x_ReleasePos@CMarkup@@IAEHXZ PROC NEAR			; CMarkup::x_ReleasePos
; _this$ = ecx

; 183  : {

  00480	55		 push	 ebp
  00481	8b ec		 mov	 ebp, esp
  00483	51		 push	 ecx
  00484	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 	//
; 185  : 	// This decrements the index of the next unused ElemPos in the array
; 186  : 	// allowing the element index returned by GetFreePos() to be reused
; 187  : 	//
; 188  : 	--m_iPosFree;

  00487	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0048a	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0048d	83 e9 01	 sub	 ecx, 1
  00490	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00493	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 189  : 	return 0;

  00496	33 c0		 xor	 eax, eax

; 190  : }

  00498	8b e5		 mov	 esp, ebp
  0049a	5d		 pop	 ebp
  0049b	c3		 ret	 0
?x_ReleasePos@CMarkup@@IAEHXZ ENDP			; CMarkup::x_ReleasePos
_TEXT	ENDS
PUBLIC	?x_ParseError@CMarkup@@IAEHPBD0@Z		; CMarkup::x_ParseError
EXTRN	__imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szError$ = 8						; size = 4
_szName$ = 12						; size = 4
?x_ParseError@CMarkup@@IAEHPBD0@Z PROC NEAR		; CMarkup::x_ParseError
; _this$ = ecx

; 193  : {

  004a0	55		 push	 ebp
  004a1	8b ec		 mov	 ebp, esp
  004a3	51		 push	 ecx
  004a4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 194  : 	if ( szName )

  004a7	83 7d 0c 00	 cmp	 DWORD PTR _szName$[ebp], 0
  004ab	74 1a		 je	 SHORT $L197751

; 195  : 		m_csError.Format( szError, szName );

  004ad	8b 45 0c	 mov	 eax, DWORD PTR _szName$[ebp]
  004b0	50		 push	 eax
  004b1	8b 4d 08	 mov	 ecx, DWORD PTR _szError$[ebp]
  004b4	51		 push	 ecx
  004b5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004b8	83 c2 08	 add	 edx, 8
  004bb	52		 push	 edx
  004bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  004c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 196  : 	else

  004c5	eb 10		 jmp	 SHORT $L197752
$L197751:

; 197  : 		m_csError = szError;

  004c7	8b 45 08	 mov	 eax, DWORD PTR _szError$[ebp]
  004ca	50		 push	 eax
  004cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004ce	83 c1 08	 add	 ecx, 8
  004d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
$L197752:

; 198  : 	x_ReleasePos();

  004d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004da	e8 00 00 00 00	 call	 ?x_ReleasePos@CMarkup@@IAEHXZ ; CMarkup::x_ReleasePos

; 199  : 	return -1;

  004df	83 c8 ff	 or	 eax, -1

; 200  : }

  004e2	8b e5		 mov	 esp, ebp
  004e4	5d		 pop	 ebp
  004e5	c2 08 00	 ret	 8
?x_ParseError@CMarkup@@IAEHPBD0@Z ENDP			; CMarkup::x_ParseError
_TEXT	ENDS
PUBLIC	??0TokenPos@CMarkup@@QAE@PBD@Z			; CMarkup::TokenPos::TokenPos
PUBLIC	?Match@TokenPos@CMarkup@@QAE_NPBD@Z		; CMarkup::TokenPos::Match
PUBLIC	?x_FindChar@CMarkup@@KA_NPBDAAHD@Z		; CMarkup::x_FindChar
PUBLIC	?x_FindToken@CMarkup@@KA_NAAUTokenPos@1@@Z	; CMarkup::x_FindToken
PUBLIC	?x_GetToken@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABUTokenPos@1@@Z ; CMarkup::x_GetToken
PUBLIC	?x_ParseNode@CMarkup@@IAEHAAUTokenPos@1@@Z	; CMarkup::x_ParseNode
EXTRN	__imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z:NEAR
EXTRN	__imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:NEAR
EXTRN	__imp_?IsEmpty@?$CSimpleStringT@D$00@ATL@@QBE_NXZ:NEAR
xdata$x	SEGMENT
$T199114 DD	0ffffffffH
	DD	FLAT:$L199109
	DD	00H
	DD	FLAT:$L199110
$T199112 DD	019930520H
	DD	02H
	DD	FLAT:$T199114
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv390 = -120						; size = 4
tv133 = -116						; size = 4
_this$ = -112						; size = 4
$T199108 = -108						; size = 4
$T199107 = -104						; size = 4
$T199106 = -100						; size = 4
$T199105 = -96						; size = 4
$T199104 = -92						; size = 4
$T199103 = -88						; size = 4
$T199102 = -84						; size = 4
$T199101 = -80						; size = 4
$T199100 = -76						; size = 4
$T199099 = -72						; size = 4
$T199098 = -68						; size = 4
$T199097 = -64						; size = 4
$T199096 = -60						; size = 4
_iInner$197789 = -56					; size = 4
_iInnerPrev$197790 = -52				; size = 4
_nTokenCount$197801 = -48				; size = 4
_cFirstChar$197770 = -41				; size = 1
_iPos$ = -40						; size = 4
_token$ = -36						; size = 20
_csName$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_iPosParent$ = 8					; size = 4
?x_ParseElem@CMarkup@@IAEHH@Z PROC NEAR			; CMarkup::x_ParseElem
; _this$ = ecx

; 203  : {

  004f0	55		 push	 ebp
  004f1	8b ec		 mov	 ebp, esp
  004f3	6a ff		 push	 -1
  004f5	68 00 00 00 00	 push	 __ehhandler$?x_ParseElem@CMarkup@@IAEHH@Z
  004fa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00500	50		 push	 eax
  00501	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00508	83 ec 6c	 sub	 esp, 108		; 0000006cH
  0050b	56		 push	 esi
  0050c	89 4d 90	 mov	 DWORD PTR _this$[ebp], ecx

; 204  : 	// This is either called by SetDoc, x_AddSubDoc, or itself recursively
; 205  : 	// m_aPos[iPosParent].nEndL is where to start parsing for the child element
; 206  : 	// This returns the new position if a tag is found, otherwise zero
; 207  : 	// In all cases we need to get a new ElemPos, but release it if unused
; 208  : 	//
; 209  : 	int iPos = x_GetFreePos();

  0050f	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00512	e8 00 00 00 00	 call	 ?x_GetFreePos@CMarkup@@IAEHXZ ; CMarkup::x_GetFreePos
  00517	89 45 d8	 mov	 DWORD PTR _iPos$[ebp], eax

; 210  : 	m_aPos[iPos].nStartL = m_aPos[iPosParent].nEndL;

  0051a	8b 45 08	 mov	 eax, DWORD PTR _iPosParent$[ebp]
  0051d	50		 push	 eax
  0051e	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00521	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00524	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00529	8b f0		 mov	 esi, eax
  0052b	8b 4d d8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  0052e	51		 push	 ecx
  0052f	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00532	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00535	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0053a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0053d	89 10		 mov	 DWORD PTR [eax], edx

; 211  : 	m_aPos[iPos].iElemParent = iPosParent;

  0053f	8b 45 d8	 mov	 eax, DWORD PTR _iPos$[ebp]
  00542	50		 push	 eax
  00543	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00546	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00549	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0054e	8b 4d 08	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  00551	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 212  : 	m_aPos[iPos].iElemChild = 0;

  00554	8b 55 d8	 mov	 edx, DWORD PTR _iPos$[ebp]
  00557	52		 push	 edx
  00558	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0055b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0055e	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00563	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 213  : 	m_aPos[iPos].iElemNext = 0;

  0056a	8b 45 d8	 mov	 eax, DWORD PTR _iPos$[ebp]
  0056d	50		 push	 eax
  0056e	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00571	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00574	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00579	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 214  : 
; 215  : 	// Start Tag
; 216  : 	// A loop is used to ignore all remarks tags and special tags
; 217  : 	// i.e. <?xml version="1.0"?>, and <!-- comment here -->
; 218  : 	// So any tag beginning with ? or ! is ignored
; 219  : 	// Loop past ignored tags
; 220  : 	TokenPos token( m_csDoc );

  00580	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00583	83 c1 04	 add	 ecx, 4
  00586	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0058c	50		 push	 eax
  0058d	8d 4d dc	 lea	 ecx, DWORD PTR _token$[ebp]
  00590	e8 00 00 00 00	 call	 ??0TokenPos@CMarkup@@QAE@PBD@Z ; CMarkup::TokenPos::TokenPos

; 221  : 	token.nNext = m_aPos[iPosParent].nEndL;

  00595	8b 4d 08	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  00598	51		 push	 ecx
  00599	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0059c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0059f	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  005a4	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  005a7	89 55 e4	 mov	 DWORD PTR _token$[ebp+8], edx

; 222  : 	CString csName;

  005aa	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  005ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  005b3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
$L197761:

; 223  : 	while ( csName.IsEmpty() )

  005ba	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  005bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@?$CSimpleStringT@D$00@ATL@@QBE_NXZ
  005c3	0f b6 c0	 movzx	 eax, al
  005c6	85 c0		 test	 eax, eax
  005c8	0f 84 39 02 00
	00		 je	 $L197762

; 224  : 	{
; 225  : 		// Look for left angle bracket of start tag
; 226  : 		m_aPos[iPos].nStartL = token.nNext;

  005ce	8b 4d d8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  005d1	51		 push	 ecx
  005d2	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  005d5	83 c1 0c	 add	 ecx, 12			; 0000000cH
  005d8	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  005dd	8b 55 e4	 mov	 edx, DWORD PTR _token$[ebp+8]
  005e0	89 10		 mov	 DWORD PTR [eax], edx

; 227  : 		if ( ! x_FindChar( token.szDoc, m_aPos[iPos].nStartL, _T('<') ) )

  005e2	6a 3c		 push	 60			; 0000003cH
  005e4	8b 45 d8	 mov	 eax, DWORD PTR _iPos$[ebp]
  005e7	50		 push	 eax
  005e8	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  005eb	83 c1 0c	 add	 ecx, 12			; 0000000cH
  005ee	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  005f3	50		 push	 eax
  005f4	8b 4d e8	 mov	 ecx, DWORD PTR _token$[ebp+12]
  005f7	51		 push	 ecx
  005f8	e8 00 00 00 00	 call	 ?x_FindChar@CMarkup@@KA_NPBDAAHD@Z ; CMarkup::x_FindChar
  005fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00600	0f b6 d0	 movzx	 edx, al
  00603	85 d2		 test	 edx, edx
  00605	75 2a		 jne	 SHORT $L197763

; 228  : 			return x_ParseError( _T("Element tag not found") );

  00607	6a 00		 push	 0
  00609	68 00 00 00 00	 push	 OFFSET FLAT:$SG197765
  0060e	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00611	e8 00 00 00 00	 call	 ?x_ParseError@CMarkup@@IAEHPBD0@Z ; CMarkup::x_ParseError
  00616	89 45 c4	 mov	 DWORD PTR $T199096[ebp], eax
  00619	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00620	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  00623	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00629	8b 45 c4	 mov	 eax, DWORD PTR $T199096[ebp]
  0062c	e9 05 05 00 00	 jmp	 $L197756
$L197763:

; 229  : 
; 230  : 		// Set parent's End tag to start looking from here (or later)
; 231  : 		m_aPos[iPosParent].nEndL = m_aPos[iPos].nStartL;

  00631	8b 45 d8	 mov	 eax, DWORD PTR _iPos$[ebp]
  00634	50		 push	 eax
  00635	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00638	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0063b	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00640	8b f0		 mov	 esi, eax
  00642	8b 4d 08	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  00645	51		 push	 ecx
  00646	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00649	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0064c	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00651	8b 16		 mov	 edx, DWORD PTR [esi]
  00653	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 232  : 
; 233  : 		// Determine whether this is an element, or bypass other type of node
; 234  : 		token.nNext = m_aPos[iPos].nStartL + 1;

  00656	8b 45 d8	 mov	 eax, DWORD PTR _iPos$[ebp]
  00659	50		 push	 eax
  0065a	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0065d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00660	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00665	8b 08		 mov	 ecx, DWORD PTR [eax]
  00667	83 c1 01	 add	 ecx, 1
  0066a	89 4d e4	 mov	 DWORD PTR _token$[ebp+8], ecx

; 235  : 		if ( x_FindToken( token ) )

  0066d	8d 55 dc	 lea	 edx, DWORD PTR _token$[ebp]
  00670	52		 push	 edx
  00671	e8 00 00 00 00	 call	 ?x_FindToken@CMarkup@@KA_NAAUTokenPos@1@@Z ; CMarkup::x_FindToken
  00676	83 c4 04	 add	 esp, 4
  00679	0f b6 c0	 movzx	 eax, al
  0067c	85 c0		 test	 eax, eax
  0067e	0f 84 54 01 00
	00		 je	 $L197766

; 236  : 		{
; 237  : 			if ( token.bIsString )

  00684	0f b6 4d ec	 movzx	 ecx, BYTE PTR _token$[ebp+16]
  00688	85 c9		 test	 ecx, ecx
  0068a	74 2a		 je	 SHORT $L197767

; 238  : 				return x_ParseError( _T("Tag starts with quote") );

  0068c	6a 00		 push	 0
  0068e	68 00 00 00 00	 push	 OFFSET FLAT:$SG197769
  00693	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00696	e8 00 00 00 00	 call	 ?x_ParseError@CMarkup@@IAEHPBD0@Z ; CMarkup::x_ParseError
  0069b	89 45 c0	 mov	 DWORD PTR $T199097[ebp], eax
  0069e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  006a5	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  006a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  006ae	8b 45 c0	 mov	 eax, DWORD PTR $T199097[ebp]
  006b1	e9 80 04 00 00	 jmp	 $L197756
$L197767:

; 239  : 			_TCHAR cFirstChar = m_csDoc[token.nL];

  006b6	8b 55 dc	 mov	 edx, DWORD PTR _token$[ebp]
  006b9	52		 push	 edx
  006ba	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  006bd	83 c1 04	 add	 ecx, 4
  006c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
  006c6	88 45 d7	 mov	 BYTE PTR _cFirstChar$197770[ebp], al

; 240  : 			if ( cFirstChar == _T('?') || cFirstChar == _T('!') )

  006c9	0f be 45 d7	 movsx	 eax, BYTE PTR _cFirstChar$197770[ebp]
  006cd	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  006d0	74 09		 je	 SHORT $L197772
  006d2	0f be 4d d7	 movsx	 ecx, BYTE PTR _cFirstChar$197770[ebp]
  006d6	83 f9 21	 cmp	 ecx, 33			; 00000021H
  006d9	75 53		 jne	 SHORT $L197771
$L197772:

; 241  : 			{
; 242  : 				token.nNext = m_aPos[iPos].nStartL;

  006db	8b 55 d8	 mov	 edx, DWORD PTR _iPos$[ebp]
  006de	52		 push	 edx
  006df	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  006e2	83 c1 0c	 add	 ecx, 12			; 0000000cH
  006e5	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  006ea	8b 00		 mov	 eax, DWORD PTR [eax]
  006ec	89 45 e4	 mov	 DWORD PTR _token$[ebp+8], eax

; 243  : 				if ( ! x_ParseNode(token) )

  006ef	8d 4d dc	 lea	 ecx, DWORD PTR _token$[ebp]
  006f2	51		 push	 ecx
  006f3	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  006f6	e8 00 00 00 00	 call	 ?x_ParseNode@CMarkup@@IAEHAAUTokenPos@1@@Z ; CMarkup::x_ParseNode
  006fb	85 c0		 test	 eax, eax
  006fd	75 2a		 jne	 SHORT $L197773

; 244  : 					return x_ParseError( _T("Invalid node") );

  006ff	6a 00		 push	 0
  00701	68 00 00 00 00	 push	 OFFSET FLAT:$SG197775
  00706	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00709	e8 00 00 00 00	 call	 ?x_ParseError@CMarkup@@IAEHPBD0@Z ; CMarkup::x_ParseError
  0070e	89 45 bc	 mov	 DWORD PTR $T199098[ebp], eax
  00711	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00718	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  0071b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00721	8b 45 bc	 mov	 eax, DWORD PTR $T199098[ebp]
  00724	e9 0d 04 00 00	 jmp	 $L197756
$L197773:

; 245  : 			}
; 246  : 			else if ( cFirstChar != _T('/') )

  00729	e9 a8 00 00 00	 jmp	 $L197776
$L197771:
  0072e	0f be 55 d7	 movsx	 edx, BYTE PTR _cFirstChar$197770[ebp]
  00732	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  00735	74 7c		 je	 SHORT $L197777

; 247  : 			{
; 248  : 				csName = x_GetToken( token );

  00737	8d 45 dc	 lea	 eax, DWORD PTR _token$[ebp]
  0073a	50		 push	 eax
  0073b	8d 4d b8	 lea	 ecx, DWORD PTR $T199099[ebp]
  0073e	51		 push	 ecx
  0073f	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00742	e8 00 00 00 00	 call	 ?x_GetToken@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABUTokenPos@1@@Z ; CMarkup::x_GetToken
  00747	89 45 8c	 mov	 DWORD PTR tv133[ebp], eax
  0074a	8b 55 8c	 mov	 edx, DWORD PTR tv133[ebp]
  0074d	89 55 88	 mov	 DWORD PTR tv390[ebp], edx
  00750	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00754	8b 45 88	 mov	 eax, DWORD PTR tv390[ebp]
  00757	50		 push	 eax
  00758	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  0075b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00761	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00765	8d 4d b8	 lea	 ecx, DWORD PTR $T199099[ebp]
  00768	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 249  : 				// Look for end of tag
; 250  : 				if ( ! x_FindChar(token.szDoc, token.nNext, _T('>')) )

  0076e	6a 3e		 push	 62			; 0000003eH
  00770	8d 4d e4	 lea	 ecx, DWORD PTR _token$[ebp+8]
  00773	51		 push	 ecx
  00774	8b 55 e8	 mov	 edx, DWORD PTR _token$[ebp+12]
  00777	52		 push	 edx
  00778	e8 00 00 00 00	 call	 ?x_FindChar@CMarkup@@KA_NPBDAAHD@Z ; CMarkup::x_FindChar
  0077d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00780	0f b6 c0	 movzx	 eax, al
  00783	85 c0		 test	 eax, eax
  00785	75 2a		 jne	 SHORT $L197779

; 251  : 					return x_ParseError( _T("End of tag not found") );

  00787	6a 00		 push	 0
  00789	68 00 00 00 00	 push	 OFFSET FLAT:$SG197781
  0078e	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00791	e8 00 00 00 00	 call	 ?x_ParseError@CMarkup@@IAEHPBD0@Z ; CMarkup::x_ParseError
  00796	89 45 b4	 mov	 DWORD PTR $T199100[ebp], eax
  00799	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  007a0	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  007a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  007a9	8b 45 b4	 mov	 eax, DWORD PTR $T199100[ebp]
  007ac	e9 85 03 00 00	 jmp	 $L197756
$L197779:

; 252  : 			}
; 253  : 			else

  007b1	eb 23		 jmp	 SHORT $L197776
$L197777:

; 254  : 				return x_ReleasePos(); // probably end tag of parent

  007b3	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  007b6	e8 00 00 00 00	 call	 ?x_ReleasePos@CMarkup@@IAEHXZ ; CMarkup::x_ReleasePos
  007bb	89 45 b0	 mov	 DWORD PTR $T199101[ebp], eax
  007be	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  007c5	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  007c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  007ce	8b 45 b0	 mov	 eax, DWORD PTR $T199101[ebp]
  007d1	e9 60 03 00 00	 jmp	 $L197756
$L197776:

; 255  : 		}
; 256  : 		else

  007d6	eb 2a		 jmp	 SHORT $L197784
$L197766:

; 257  : 			return x_ParseError( _T("Abrupt end within tag") );

  007d8	6a 00		 push	 0
  007da	68 00 00 00 00	 push	 OFFSET FLAT:$SG197786
  007df	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  007e2	e8 00 00 00 00	 call	 ?x_ParseError@CMarkup@@IAEHPBD0@Z ; CMarkup::x_ParseError
  007e7	89 45 ac	 mov	 DWORD PTR $T199102[ebp], eax
  007ea	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  007f1	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  007f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  007fa	8b 45 ac	 mov	 eax, DWORD PTR $T199102[ebp]
  007fd	e9 34 03 00 00	 jmp	 $L197756
$L197784:

; 258  : 	}

  00802	e9 b3 fd ff ff	 jmp	 $L197761
$L197762:

; 259  : 	m_aPos[iPos].nStartR = token.nNext;

  00807	8b 4d d8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  0080a	51		 push	 ecx
  0080b	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0080e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00811	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00816	8b 55 e4	 mov	 edx, DWORD PTR _token$[ebp+8]
  00819	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 260  : 
; 261  : 	// Is ending mark within start tag, i.e. empty element?
; 262  : 	if ( m_csDoc[m_aPos[iPos].nStartR-1] == _T('/') )

  0081c	8b 45 d8	 mov	 eax, DWORD PTR _iPos$[ebp]
  0081f	50		 push	 eax
  00820	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00823	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00826	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0082b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0082e	83 e9 01	 sub	 ecx, 1
  00831	51		 push	 ecx
  00832	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00835	83 c1 04	 add	 ecx, 4
  00838	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
  0083e	0f be d0	 movsx	 edx, al
  00841	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  00844	75 52		 jne	 SHORT $L197787

; 263  : 	{
; 264  : 		// Empty element
; 265  : 		// Close tag left is set to ending mark, and right to open tag right
; 266  : 		m_aPos[iPos].nEndL = m_aPos[iPos].nStartR-1;

  00846	8b 45 d8	 mov	 eax, DWORD PTR _iPos$[ebp]
  00849	50		 push	 eax
  0084a	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0084d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00850	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00855	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00858	83 ee 01	 sub	 esi, 1
  0085b	8b 4d d8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  0085e	51		 push	 ecx
  0085f	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00862	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00865	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0086a	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 267  : 		m_aPos[iPos].nEndR = m_aPos[iPos].nStartR;

  0086d	8b 55 d8	 mov	 edx, DWORD PTR _iPos$[ebp]
  00870	52		 push	 edx
  00871	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00874	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00877	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0087c	8b f0		 mov	 esi, eax
  0087e	8b 45 d8	 mov	 eax, DWORD PTR _iPos$[ebp]
  00881	50		 push	 eax
  00882	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00885	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00888	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0088d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00890	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 268  : 	}
; 269  : 	else // look for end tag

  00893	e9 85 02 00 00	 jmp	 $L197788
$L197787:

; 270  : 	{
; 271  : 		// Element probably has contents
; 272  : 		// Determine where to start looking for left angle bracket of end tag
; 273  : 		// This is done by recursively parsing the contents of this element
; 274  : 		int iInner, iInnerPrev = 0;

  00898	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _iInnerPrev$197790[ebp], 0

; 275  : 		m_aPos[iPos].nEndL = m_aPos[iPos].nStartR + 1;

  0089f	8b 55 d8	 mov	 edx, DWORD PTR _iPos$[ebp]
  008a2	52		 push	 edx
  008a3	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  008a6	83 c1 0c	 add	 ecx, 12			; 0000000cH
  008a9	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  008ae	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  008b1	83 c6 01	 add	 esi, 1
  008b4	8b 45 d8	 mov	 eax, DWORD PTR _iPos$[ebp]
  008b7	50		 push	 eax
  008b8	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  008bb	83 c1 0c	 add	 ecx, 12			; 0000000cH
  008be	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  008c3	89 70 08	 mov	 DWORD PTR [eax+8], esi
$L197792:

; 276  : 		while ( (iInner = x_ParseElem( iPos )) > 0 )

  008c6	8b 4d d8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  008c9	51		 push	 ecx
  008ca	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  008cd	e8 00 00 00 00	 call	 ?x_ParseElem@CMarkup@@IAEHH@Z ; CMarkup::x_ParseElem
  008d2	89 45 c8	 mov	 DWORD PTR _iInner$197789[ebp], eax
  008d5	83 7d c8 00	 cmp	 DWORD PTR _iInner$197789[ebp], 0
  008d9	7e 61		 jle	 SHORT $L197793

; 277  : 		{
; 278  : 			// Set links to iInner
; 279  : 			if ( iInnerPrev )

  008db	83 7d cc 00	 cmp	 DWORD PTR _iInnerPrev$197790[ebp], 0
  008df	74 17		 je	 SHORT $L197794

; 280  : 				m_aPos[iInnerPrev].iElemNext = iInner;

  008e1	8b 55 cc	 mov	 edx, DWORD PTR _iInnerPrev$197790[ebp]
  008e4	52		 push	 edx
  008e5	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  008e8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  008eb	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  008f0	8b 4d c8	 mov	 ecx, DWORD PTR _iInner$197789[ebp]
  008f3	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 281  : 			else

  008f6	eb 15		 jmp	 SHORT $L197795
$L197794:

; 282  : 				m_aPos[iPos].iElemChild = iInner;

  008f8	8b 55 d8	 mov	 edx, DWORD PTR _iPos$[ebp]
  008fb	52		 push	 edx
  008fc	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  008ff	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00902	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00907	8b 4d c8	 mov	 ecx, DWORD PTR _iInner$197789[ebp]
  0090a	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L197795:

; 283  : 			iInnerPrev = iInner;

  0090d	8b 55 c8	 mov	 edx, DWORD PTR _iInner$197789[ebp]
  00910	89 55 cc	 mov	 DWORD PTR _iInnerPrev$197790[ebp], edx

; 284  : 
; 285  : 			// Set offset to reflect child
; 286  : 			m_aPos[iPos].nEndL = m_aPos[iInner].nEndR + 1;

  00913	8b 45 c8	 mov	 eax, DWORD PTR _iInner$197789[ebp]
  00916	50		 push	 eax
  00917	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0091a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0091d	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00922	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00925	83 c6 01	 add	 esi, 1
  00928	8b 4d d8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  0092b	51		 push	 ecx
  0092c	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0092f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00932	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00937	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 287  : 		}

  0093a	eb 8a		 jmp	 SHORT $L197792
$L197793:

; 288  : 		if ( iInner == -1 )

  0093c	83 7d c8 ff	 cmp	 DWORD PTR _iInner$197789[ebp], -1
  00940	75 1f		 jne	 SHORT $L197796

; 289  : 			return -1;

  00942	c7 45 a8 ff ff
	ff ff		 mov	 DWORD PTR $T199103[ebp], -1
  00949	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00950	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  00953	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00959	8b 45 a8	 mov	 eax, DWORD PTR $T199103[ebp]
  0095c	e9 d5 01 00 00	 jmp	 $L197756
$L197796:

; 290  : 
; 291  : 		// Look for left angle bracket of end tag
; 292  : 		if ( ! x_FindChar( token.szDoc, m_aPos[iPos].nEndL, _T('<') ) )

  00961	6a 3c		 push	 60			; 0000003cH
  00963	8b 55 d8	 mov	 edx, DWORD PTR _iPos$[ebp]
  00966	52		 push	 edx
  00967	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0096a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0096d	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00972	83 c0 08	 add	 eax, 8
  00975	50		 push	 eax
  00976	8b 45 e8	 mov	 eax, DWORD PTR _token$[ebp+12]
  00979	50		 push	 eax
  0097a	e8 00 00 00 00	 call	 ?x_FindChar@CMarkup@@KA_NPBDAAHD@Z ; CMarkup::x_FindChar
  0097f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00982	0f b6 c8	 movzx	 ecx, al
  00985	85 c9		 test	 ecx, ecx
  00987	75 32		 jne	 SHORT $L197798

; 293  : 			return x_ParseError( _T("End tag of %s element not found"), csName );

  00989	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  0098c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00992	50		 push	 eax
  00993	68 00 00 00 00	 push	 OFFSET FLAT:$SG197800
  00998	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0099b	e8 00 00 00 00	 call	 ?x_ParseError@CMarkup@@IAEHPBD0@Z ; CMarkup::x_ParseError
  009a0	89 45 a4	 mov	 DWORD PTR $T199104[ebp], eax
  009a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  009aa	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  009ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  009b3	8b 45 a4	 mov	 eax, DWORD PTR $T199104[ebp]
  009b6	e9 7b 01 00 00	 jmp	 $L197756
$L197798:

; 294  : 
; 295  : 		// Look through tokens of end tag
; 296  : 		token.nNext = m_aPos[iPos].nEndL + 1;

  009bb	8b 55 d8	 mov	 edx, DWORD PTR _iPos$[ebp]
  009be	52		 push	 edx
  009bf	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  009c2	83 c1 0c	 add	 ecx, 12			; 0000000cH
  009c5	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  009ca	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  009cd	83 c0 01	 add	 eax, 1
  009d0	89 45 e4	 mov	 DWORD PTR _token$[ebp+8], eax

; 297  : 		int nTokenCount = 0;

  009d3	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _nTokenCount$197801[ebp], 0
$L197803:

; 298  : 		while ( x_FindToken( token ) )

  009da	8d 4d dc	 lea	 ecx, DWORD PTR _token$[ebp]
  009dd	51		 push	 ecx
  009de	e8 00 00 00 00	 call	 ?x_FindToken@CMarkup@@KA_NAAUTokenPos@1@@Z ; CMarkup::x_FindToken
  009e3	83 c4 04	 add	 esp, 4
  009e6	0f b6 d0	 movzx	 edx, al
  009e9	85 d2		 test	 edx, edx
  009eb	0f 84 d5 00 00
	00		 je	 $L197804

; 299  : 		{
; 300  : 			++nTokenCount;

  009f1	8b 45 d0	 mov	 eax, DWORD PTR _nTokenCount$197801[ebp]
  009f4	83 c0 01	 add	 eax, 1
  009f7	89 45 d0	 mov	 DWORD PTR _nTokenCount$197801[ebp], eax

; 301  : 			if ( ! token.bIsString )

  009fa	0f b6 4d ec	 movzx	 ecx, BYTE PTR _token$[ebp+16]
  009fe	85 c9		 test	 ecx, ecx
  00a00	0f 85 bb 00 00
	00		 jne	 $L197805

; 302  : 			{
; 303  : 				// Is first token not an end slash mark?
; 304  : 				if ( nTokenCount == 1 && m_csDoc[token.nL] != _T('/') )

  00a06	83 7d d0 01	 cmp	 DWORD PTR _nTokenCount$197801[ebp], 1
  00a0a	75 4a		 jne	 SHORT $L197806
  00a0c	8b 55 dc	 mov	 edx, DWORD PTR _token$[ebp]
  00a0f	52		 push	 edx
  00a10	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00a13	83 c1 04	 add	 ecx, 4
  00a16	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
  00a1c	0f be c0	 movsx	 eax, al
  00a1f	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00a22	74 32		 je	 SHORT $L197806

; 305  : 					return x_ParseError( _T("Expecting end tag of element %s"), csName );

  00a24	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  00a27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00a2d	50		 push	 eax
  00a2e	68 00 00 00 00	 push	 OFFSET FLAT:$SG197808
  00a33	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00a36	e8 00 00 00 00	 call	 ?x_ParseError@CMarkup@@IAEHPBD0@Z ; CMarkup::x_ParseError
  00a3b	89 45 a0	 mov	 DWORD PTR $T199105[ebp], eax
  00a3e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00a45	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  00a48	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00a4e	8b 45 a0	 mov	 eax, DWORD PTR $T199105[ebp]
  00a51	e9 e0 00 00 00	 jmp	 $L197756
$L197806:

; 306  : 
; 307  : 				else if ( nTokenCount == 2 && ! token.Match(csName) )

  00a56	83 7d d0 02	 cmp	 DWORD PTR _nTokenCount$197801[ebp], 2
  00a5a	75 4b		 jne	 SHORT $L197810
  00a5c	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  00a5f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00a65	50		 push	 eax
  00a66	8d 4d dc	 lea	 ecx, DWORD PTR _token$[ebp]
  00a69	e8 00 00 00 00	 call	 ?Match@TokenPos@CMarkup@@QAE_NPBD@Z ; CMarkup::TokenPos::Match
  00a6e	0f b6 c8	 movzx	 ecx, al
  00a71	85 c9		 test	 ecx, ecx
  00a73	75 32		 jne	 SHORT $L197810

; 308  : 					return x_ParseError( _T("End tag does not correspond to %s"), csName );

  00a75	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  00a78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00a7e	50		 push	 eax
  00a7f	68 00 00 00 00	 push	 OFFSET FLAT:$SG197812
  00a84	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00a87	e8 00 00 00 00	 call	 ?x_ParseError@CMarkup@@IAEHPBD0@Z ; CMarkup::x_ParseError
  00a8c	89 45 9c	 mov	 DWORD PTR $T199106[ebp], eax
  00a8f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00a96	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  00a99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00a9f	8b 45 9c	 mov	 eax, DWORD PTR $T199106[ebp]
  00aa2	e9 8f 00 00 00	 jmp	 $L197756
$L197810:

; 309  : 
; 310  : 				// Else is it a right angle bracket?
; 311  : 				else if ( m_csDoc[token.nL] == _T('>') )

  00aa7	8b 55 dc	 mov	 edx, DWORD PTR _token$[ebp]
  00aaa	52		 push	 edx
  00aab	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00aae	83 c1 04	 add	 ecx, 4
  00ab1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
  00ab7	0f be c0	 movsx	 eax, al
  00aba	83 f8 3e	 cmp	 eax, 62			; 0000003eH
  00abd	75 02		 jne	 SHORT $L197805

; 312  : 					break;

  00abf	eb 05		 jmp	 SHORT $L197804
$L197805:

; 313  : 			}
; 314  : 		}

  00ac1	e9 14 ff ff ff	 jmp	 $L197803
$L197804:

; 315  : 
; 316  : 		// Was a right angle bracket not found?
; 317  : 		if ( ! token.szDoc[token.nL] || nTokenCount < 2 )

  00ac6	8b 4d e8	 mov	 ecx, DWORD PTR _token$[ebp+12]
  00ac9	03 4d dc	 add	 ecx, DWORD PTR _token$[ebp]
  00acc	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00acf	85 d2		 test	 edx, edx
  00ad1	74 06		 je	 SHORT $L197816
  00ad3	83 7d d0 02	 cmp	 DWORD PTR _nTokenCount$197801[ebp], 2
  00ad7	7d 2f		 jge	 SHORT $L197815
$L197816:

; 318  : 			return x_ParseError( _T("End tag not completed for element %s"), csName );

  00ad9	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  00adc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00ae2	50		 push	 eax
  00ae3	68 00 00 00 00	 push	 OFFSET FLAT:$SG197818
  00ae8	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00aeb	e8 00 00 00 00	 call	 ?x_ParseError@CMarkup@@IAEHPBD0@Z ; CMarkup::x_ParseError
  00af0	89 45 98	 mov	 DWORD PTR $T199107[ebp], eax
  00af3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00afa	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  00afd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00b03	8b 45 98	 mov	 eax, DWORD PTR $T199107[ebp]
  00b06	eb 2e		 jmp	 SHORT $L197756
$L197815:

; 319  : 		m_aPos[iPos].nEndR = token.nL;

  00b08	8b 45 d8	 mov	 eax, DWORD PTR _iPos$[ebp]
  00b0b	50		 push	 eax
  00b0c	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00b0f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00b12	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00b17	8b 4d dc	 mov	 ecx, DWORD PTR _token$[ebp]
  00b1a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$L197788:

; 320  : 	}
; 321  : 
; 322  : 	// Successfully parsed element (and contained elements)
; 323  : 	return iPos;

  00b1d	8b 55 d8	 mov	 edx, DWORD PTR _iPos$[ebp]
  00b20	89 55 94	 mov	 DWORD PTR $T199108[ebp], edx
  00b23	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b2a	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  00b2d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00b33	8b 45 94	 mov	 eax, DWORD PTR $T199108[ebp]
$L197756:

; 324  : }

  00b36	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00b39	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00b40	5e		 pop	 esi
  00b41	8b e5		 mov	 esp, ebp
  00b43	5d		 pop	 ebp
  00b44	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L199109:
  0001c	8d 4d f0	 lea	 ecx, DWORD PTR _csName$[ebp]
  0001f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L199110:
  00025	8d 4d b8	 lea	 ecx, DWORD PTR $T199099[ebp]
  00028	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?x_ParseElem@CMarkup@@IAEHH@Z:
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199112
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?x_ParseElem@CMarkup@@IAEHH@Z ENDP			; CMarkup::x_ParseElem
PUBLIC	?Clear@TokenPos@CMarkup@@QAEXXZ			; CMarkup::TokenPos::Clear
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.h
;	COMDAT ??0TokenPos@CMarkup@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sz$ = 8						; size = 4
??0TokenPos@CMarkup@@QAE@PBD@Z PROC NEAR		; CMarkup::TokenPos::TokenPos, COMDAT
; _this$ = ecx

; 115  : 		TokenPos( LPCTSTR sz ) { Clear(); szDoc = sz; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Clear@TokenPos@CMarkup@@QAEXXZ ; CMarkup::TokenPos::Clear
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _sz$[ebp]
  00015	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??0TokenPos@CMarkup@@QAE@PBD@Z ENDP			; CMarkup::TokenPos::TokenPos
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Clear@TokenPos@CMarkup@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@TokenPos@CMarkup@@QAEXXZ PROC NEAR		; CMarkup::TokenPos::Clear, COMDAT
; _this$ = ecx

; 117  : 		void Clear() { nL=0; nR=-1; nNext=0; bIsString=false; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 ff ff
	ff ff		 mov	 DWORD PTR [ecx+4], -1
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c6 40 10 00	 mov	 BYTE PTR [eax+16], 0
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?Clear@TokenPos@CMarkup@@QAEXXZ ENDP			; CMarkup::TokenPos::Clear
_TEXT	ENDS
PUBLIC	??_C@_04JAADICNI@?5?$DN?1?$FL?$AA@		; `string'
PUBLIC	__tcschr
PUBLIC	__tcsnccmp
;	COMDAT ??_C@_04JAADICNI@?5?$DN?1?$FL?$AA@
CONST	SEGMENT
??_C@_04JAADICNI@?5?$DN?1?$FL?$AA@ DB ' =/[', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Match@TokenPos@CMarkup@@QAE_NPBD@Z
_TEXT	SEGMENT
tv83 = -12						; size = 4
_this$ = -8						; size = 4
_nLen$ = -4						; size = 4
_szName$ = 8						; size = 4
?Match@TokenPos@CMarkup@@QAE_NPBD@Z PROC NEAR		; CMarkup::TokenPos::Match, COMDAT
; _this$ = ecx

; 119  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 120  : 			int nLen = nR - nL + 1;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00012	2b 11		 sub	 edx, DWORD PTR [ecx]
  00014	83 c2 01	 add	 edx, 1
  00017	89 55 fc	 mov	 DWORD PTR _nLen$[ebp], edx

; 121  : 			return ( (_tcsnccmp( &szDoc[nL], szName, nLen ) == 0)
; 122  : 				&& ( szName[nLen] == _T('\0') || _tcschr(_T(" =/["),szName[nLen]) ) );

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _nLen$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _szName$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	03 01		 add	 eax, DWORD PTR [ecx]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 __tcsnccmp
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	85 c0		 test	 eax, eax
  00038	75 31		 jne	 SHORT $L199121
  0003a	8b 55 08	 mov	 edx, DWORD PTR _szName$[ebp]
  0003d	03 55 fc	 add	 edx, DWORD PTR _nLen$[ebp]
  00040	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00043	85 c0		 test	 eax, eax
  00045	74 1b		 je	 SHORT $L199120
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _szName$[ebp]
  0004a	03 4d fc	 add	 ecx, DWORD PTR _nLen$[ebp]
  0004d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00050	52		 push	 edx
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JAADICNI@?5?$DN?1?$FL?$AA@
  00056	e8 00 00 00 00	 call	 __tcschr
  0005b	83 c4 08	 add	 esp, 8
  0005e	85 c0		 test	 eax, eax
  00060	74 09		 je	 SHORT $L199121
$L199120:
  00062	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
  00069	eb 07		 jmp	 SHORT $L199122
$L199121:
  0006b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$L199122:
  00072	8a 45 f4	 mov	 al, BYTE PTR tv83[ebp]

; 123  : 		};

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
?Match@TokenPos@CMarkup@@QAE_NPBD@Z ENDP		; CMarkup::TokenPos::Match
_TEXT	ENDS
EXTRN	__imp___mbschr:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\tchar.h
;	COMDAT __tcschr
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__c$ = 12						; size = 4
__tcschr PROC NEAR					; COMDAT

; 840  : __inline _PC _tcschr(_CPC _s1,_UI _c) {return (_PC)_mbschr((_CPUC)_s1,_c);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __c$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbschr
  00011	83 c4 08	 add	 esp, 8
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
__tcschr ENDP
_TEXT	ENDS
EXTRN	__imp___mbsncmp:NEAR
; Function compile flags: /Odt
;	COMDAT __tcsnccmp
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__n$ = 16						; size = 4
__tcsnccmp PROC NEAR					; COMDAT

; 856  : __inline int _tcsnccmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __n$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __s2$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __s1$[ebp]
  0000e	52		 push	 edx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsncmp
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
__tcsnccmp ENDP
_TEXT	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -160						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

  00011	c7 85 60 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _ver$[ebp], 148 ; 00000094H

; 139  : 	::GetVersionEx( &ver );

  0001b	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _ver$[ebp]
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00028	83 bd 70 ff ff
	ff 02		 cmp	 DWORD PTR _ver$[ebp+16], 2
  0002f	75 15		 jne	 SHORT $L24173
  00031	83 bd 64 ff ff
	ff 05		 cmp	 DWORD PTR _ver$[ebp+4], 5
  00038	72 0c		 jb	 SHORT $L24173

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  0003a	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

  00044	eb 0a		 jmp	 SHORT $L24174
$L24173:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00046	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L24174:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  00050	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pfnGetThreadACP$[ebp]
  00056	51		 push	 ecx
  00057	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0005c	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pNew$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pp$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 93   : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$24161 = -24					; size = 4
_lcidThread$ = -20					; size = 4
_szACP$ = -16						; size = 7
__$ArrayPad$ = -8					; size = 4
_nACP$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0
  0001b	89 45 ec	 mov	 DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  0001e	6a 07		 push	 7
  00020	8d 45 f0	 lea	 eax, DWORD PTR _szACP$[ebp]
  00023	50		 push	 eax
  00024	68 04 10 00 00	 push	 4100			; 00001004H
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _lcidThread$[ebp]
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00033	85 c0		 test	 eax, eax
  00035	74 34		 je	 SHORT $L24160

; 111  : 	{
; 112  : 		char* pch = szACP;

  00037	8d 55 f0	 lea	 edx, DWORD PTR _szACP$[ebp]
  0003a	89 55 e8	 mov	 DWORD PTR _pch$24161[ebp], edx
$L24163:

; 113  : 		while (*pch != '\0')

  0003d	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00040	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00043	85 c9		 test	 ecx, ecx
  00045	74 24		 je	 SHORT $L24160

; 114  : 		{
; 115  : 			nACP *= 10;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  0004a	6b d2 0a	 imul	 edx, 10			; 0000000aH
  0004d	89 55 fc	 mov	 DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

  00050	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  00059	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  0005d	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
  00060	8b 4d e8	 mov	 ecx, DWORD PTR _pch$24161[ebp]
  00063	83 c1 01	 add	 ecx, 1
  00066	89 4d e8	 mov	 DWORD PTR _pch$24161[ebp], ecx

; 117  : 		}

  00069	eb d2		 jmp	 SHORT $L24163
$L24160:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  0006b	83 7d fc 00	 cmp	 DWORD PTR _nACP$[ebp], 0
  0006f	75 09		 jne	 SHORT $L24165

; 121  : 		nACP = ::GetACP();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  00077	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
$L24165:

; 122  : 
; 123  : 	return nACP;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _nACP$[ebp]

; 124  : }

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  : 	return( CP_THREAD_ACP );

  00003	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
PUBLIC	__tclen
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.cpp
_TEXT	SEGMENT
_pChar$ = -4						; size = 4
_szDoc$ = 8						; size = 4
_nChar$ = 12						; size = 4
_c$ = 16						; size = 1
?x_FindChar@CMarkup@@KA_NPBDAAHD@Z PROC NEAR		; CMarkup::x_FindChar

; 327  : {

  00b50	55		 push	 ebp
  00b51	8b ec		 mov	 ebp, esp
  00b53	51		 push	 ecx

; 328  : 	// static function
; 329  : 	LPCTSTR pChar = &szDoc[nChar];

  00b54	8b 45 0c	 mov	 eax, DWORD PTR _nChar$[ebp]
  00b57	8b 4d 08	 mov	 ecx, DWORD PTR _szDoc$[ebp]
  00b5a	03 08		 add	 ecx, DWORD PTR [eax]
  00b5c	89 4d fc	 mov	 DWORD PTR _pChar$[ebp], ecx
$L197827:

; 330  : 	while ( *pChar && *pChar != c )

  00b5f	8b 55 fc	 mov	 edx, DWORD PTR _pChar$[ebp]
  00b62	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00b65	85 c0		 test	 eax, eax
  00b67	74 22		 je	 SHORT $L197828
  00b69	8b 4d fc	 mov	 ecx, DWORD PTR _pChar$[ebp]
  00b6c	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00b6f	0f be 45 10	 movsx	 eax, BYTE PTR _c$[ebp]
  00b73	3b d0		 cmp	 edx, eax
  00b75	74 14		 je	 SHORT $L197828

; 331  : 		pChar += _tclen( pChar );

  00b77	8b 4d fc	 mov	 ecx, DWORD PTR _pChar$[ebp]
  00b7a	51		 push	 ecx
  00b7b	e8 00 00 00 00	 call	 __tclen
  00b80	83 c4 04	 add	 esp, 4
  00b83	03 45 fc	 add	 eax, DWORD PTR _pChar$[ebp]
  00b86	89 45 fc	 mov	 DWORD PTR _pChar$[ebp], eax
  00b89	eb d4		 jmp	 SHORT $L197827
$L197828:

; 332  : 	nChar = (int)( pChar - szDoc);

  00b8b	8b 55 fc	 mov	 edx, DWORD PTR _pChar$[ebp]
  00b8e	2b 55 08	 sub	 edx, DWORD PTR _szDoc$[ebp]
  00b91	8b 45 0c	 mov	 eax, DWORD PTR _nChar$[ebp]
  00b94	89 10		 mov	 DWORD PTR [eax], edx

; 333  : 	if ( ! *pChar )

  00b96	8b 4d fc	 mov	 ecx, DWORD PTR _pChar$[ebp]
  00b99	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00b9c	85 d2		 test	 edx, edx
  00b9e	75 04		 jne	 SHORT $L197830

; 334  : 		return false;

  00ba0	32 c0		 xor	 al, al
  00ba2	eb 02		 jmp	 SHORT $L197824
$L197830:

; 335  : 	/*
; 336  : 	while ( szDoc[nChar] && szDoc[nChar] != c )
; 337  : 		nChar += _tclen( &szDoc[nChar] );
; 338  : 	if ( ! szDoc[nChar] )
; 339  : 		return false;
; 340  : 	*/
; 341  : 	return true;

  00ba4	b0 01		 mov	 al, 1
$L197824:

; 342  : }

  00ba6	8b e5		 mov	 esp, ebp
  00ba8	5d		 pop	 ebp
  00ba9	c3		 ret	 0
?x_FindChar@CMarkup@@KA_NPBDAAHD@Z ENDP			; CMarkup::x_FindChar
_TEXT	ENDS
EXTRN	__imp___mbclen:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\tchar.h
;	COMDAT __tclen
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__tclen	PROC NEAR					; COMDAT

; 888  : __inline size_t _tclen(_CPC _s1) {return _mbclen((_CPUC)_s1);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __s1$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbclen
  0000d	83 c4 04	 add	 esp, 4
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
__tclen	ENDP
_TEXT	ENDS
PUBLIC	?x_FindAny@CMarkup@@KA_NPBDAAH@Z		; CMarkup::x_FindAny
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.cpp
_TEXT	SEGMENT
_szDoc$ = 8						; size = 4
_nChar$ = 12						; size = 4
?x_FindAny@CMarkup@@KA_NPBDAAH@Z PROC NEAR		; CMarkup::x_FindAny

; 345  : {

  00bb0	55		 push	 ebp
  00bb1	8b ec		 mov	 ebp, esp
$L197836:

; 346  : 	// Starting at nChar, find a non-whitespace char
; 347  : 	// return false if no non-whitespace before end of document, nChar points to end
; 348  : 	// otherwise return true and nChar points to non-whitespace char
; 349  : 	while ( szDoc[nChar] && _tcschr(_T(" \t\n\r"),szDoc[nChar]) )

  00bb3	8b 45 0c	 mov	 eax, DWORD PTR _nChar$[ebp]
  00bb6	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bb8	8b 55 08	 mov	 edx, DWORD PTR _szDoc$[ebp]
  00bbb	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00bbf	85 c0		 test	 eax, eax
  00bc1	74 2d		 je	 SHORT $L197837
  00bc3	8b 4d 0c	 mov	 ecx, DWORD PTR _nChar$[ebp]
  00bc6	8b 11		 mov	 edx, DWORD PTR [ecx]
  00bc8	8b 45 08	 mov	 eax, DWORD PTR _szDoc$[ebp]
  00bcb	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00bcf	51		 push	 ecx
  00bd0	68 00 00 00 00	 push	 OFFSET FLAT:$SG197838
  00bd5	e8 00 00 00 00	 call	 __tcschr
  00bda	83 c4 08	 add	 esp, 8
  00bdd	85 c0		 test	 eax, eax
  00bdf	74 0f		 je	 SHORT $L197837

; 350  : 		++nChar;

  00be1	8b 55 0c	 mov	 edx, DWORD PTR _nChar$[ebp]
  00be4	8b 02		 mov	 eax, DWORD PTR [edx]
  00be6	83 c0 01	 add	 eax, 1
  00be9	8b 4d 0c	 mov	 ecx, DWORD PTR _nChar$[ebp]
  00bec	89 01		 mov	 DWORD PTR [ecx], eax
  00bee	eb c3		 jmp	 SHORT $L197836
$L197837:

; 351  : 	return szDoc[nChar] != '\0';

  00bf0	8b 55 0c	 mov	 edx, DWORD PTR _nChar$[ebp]
  00bf3	8b 02		 mov	 eax, DWORD PTR [edx]
  00bf5	8b 4d 08	 mov	 ecx, DWORD PTR _szDoc$[ebp]
  00bf8	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  00bfc	f7 d8		 neg	 eax
  00bfe	1b c0		 sbb	 eax, eax
  00c00	f7 d8		 neg	 eax

; 352  : }

  00c02	5d		 pop	 ebp
  00c03	c3		 ret	 0
?x_FindAny@CMarkup@@KA_NPBDAAH@Z ENDP			; CMarkup::x_FindAny
; Function compile flags: /Odt
_szDoc$ = -12						; size = 4
_nChar$ = -8						; size = 4
_cFirstChar$ = -1					; size = 1
_token$ = 8						; size = 4
?x_FindToken@CMarkup@@KA_NAAUTokenPos@1@@Z PROC NEAR	; CMarkup::x_FindToken

; 355  : {

  00c10	55		 push	 ebp
  00c11	8b ec		 mov	 ebp, esp
  00c13	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 356  : 	// Starting at token.nNext, bypass whitespace and find the next token
; 357  : 	// returns true on success, members of token point to token
; 358  : 	// returns false on end of document, members point to end of document
; 359  : 	LPCTSTR szDoc = token.szDoc;

  00c16	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00c19	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00c1c	89 4d f4	 mov	 DWORD PTR _szDoc$[ebp], ecx

; 360  : 	int nChar = token.nNext;

  00c1f	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00c22	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00c25	89 45 f8	 mov	 DWORD PTR _nChar$[ebp], eax

; 361  : 	token.bIsString = false;

  00c28	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00c2b	c6 41 10 00	 mov	 BYTE PTR [ecx+16], 0

; 362  : 
; 363  : 	// By-pass leading whitespace
; 364  : 	if ( ! x_FindAny(szDoc,nChar) )

  00c2f	8d 55 f8	 lea	 edx, DWORD PTR _nChar$[ebp]
  00c32	52		 push	 edx
  00c33	8b 45 f4	 mov	 eax, DWORD PTR _szDoc$[ebp]
  00c36	50		 push	 eax
  00c37	e8 00 00 00 00	 call	 ?x_FindAny@CMarkup@@KA_NPBDAAH@Z ; CMarkup::x_FindAny
  00c3c	83 c4 08	 add	 esp, 8
  00c3f	0f b6 c8	 movzx	 ecx, al
  00c42	85 c9		 test	 ecx, ecx
  00c44	75 21		 jne	 SHORT $L197844

; 365  : 	{
; 366  : 		// No token was found before end of document
; 367  : 		token.nL = nChar;

  00c46	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00c49	8b 45 f8	 mov	 eax, DWORD PTR _nChar$[ebp]
  00c4c	89 02		 mov	 DWORD PTR [edx], eax

; 368  : 		token.nR = nChar;

  00c4e	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00c51	8b 55 f8	 mov	 edx, DWORD PTR _nChar$[ebp]
  00c54	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 369  : 		token.nNext = nChar;

  00c57	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00c5a	8b 4d f8	 mov	 ecx, DWORD PTR _nChar$[ebp]
  00c5d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 370  : 		return false;

  00c60	32 c0		 xor	 al, al
  00c62	e9 e1 00 00 00	 jmp	 $L197841
$L197844:

; 371  : 	}
; 372  : 
; 373  : 	// Is it an opening quote?
; 374  : 	_TCHAR cFirstChar = szDoc[nChar];

  00c67	8b 55 f4	 mov	 edx, DWORD PTR _szDoc$[ebp]
  00c6a	03 55 f8	 add	 edx, DWORD PTR _nChar$[ebp]
  00c6d	8a 02		 mov	 al, BYTE PTR [edx]
  00c6f	88 45 ff	 mov	 BYTE PTR _cFirstChar$[ebp], al

; 375  : 	if ( cFirstChar == _T('\"') || cFirstChar == _T('\'') )

  00c72	0f be 4d ff	 movsx	 ecx, BYTE PTR _cFirstChar$[ebp]
  00c76	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00c79	74 09		 je	 SHORT $L197847
  00c7b	0f be 55 ff	 movsx	 edx, BYTE PTR _cFirstChar$[ebp]
  00c7f	83 fa 27	 cmp	 edx, 39			; 00000027H
  00c82	75 53		 jne	 SHORT $L197846
$L197847:

; 376  : 	{
; 377  : 		token.bIsString = true;

  00c84	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00c87	c6 40 10 01	 mov	 BYTE PTR [eax+16], 1

; 378  : 
; 379  : 		// Move past opening quote
; 380  : 		++nChar;

  00c8b	8b 4d f8	 mov	 ecx, DWORD PTR _nChar$[ebp]
  00c8e	83 c1 01	 add	 ecx, 1
  00c91	89 4d f8	 mov	 DWORD PTR _nChar$[ebp], ecx

; 381  : 		token.nL = nChar;

  00c94	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00c97	8b 45 f8	 mov	 eax, DWORD PTR _nChar$[ebp]
  00c9a	89 02		 mov	 DWORD PTR [edx], eax

; 382  : 
; 383  : 		// Look for closing quote
; 384  : 		x_FindChar( token.szDoc, nChar, cFirstChar );

  00c9c	8a 4d ff	 mov	 cl, BYTE PTR _cFirstChar$[ebp]
  00c9f	51		 push	 ecx
  00ca0	8d 55 f8	 lea	 edx, DWORD PTR _nChar$[ebp]
  00ca3	52		 push	 edx
  00ca4	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00ca7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00caa	51		 push	 ecx
  00cab	e8 00 00 00 00	 call	 ?x_FindChar@CMarkup@@KA_NPBDAAHD@Z ; CMarkup::x_FindChar
  00cb0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 385  : 
; 386  : 		// Set right to before closing quote
; 387  : 		token.nR = nChar - 1;

  00cb3	8b 55 f8	 mov	 edx, DWORD PTR _nChar$[ebp]
  00cb6	83 ea 01	 sub	 edx, 1
  00cb9	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00cbc	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 388  : 
; 389  : 		// Set nChar past closing quote unless at end of document
; 390  : 		if ( szDoc[nChar] )

  00cbf	8b 4d f4	 mov	 ecx, DWORD PTR _szDoc$[ebp]
  00cc2	03 4d f8	 add	 ecx, DWORD PTR _nChar$[ebp]
  00cc5	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00cc8	85 d2		 test	 edx, edx
  00cca	74 09		 je	 SHORT $L197848

; 391  : 			++nChar;

  00ccc	8b 45 f8	 mov	 eax, DWORD PTR _nChar$[ebp]
  00ccf	83 c0 01	 add	 eax, 1
  00cd2	89 45 f8	 mov	 DWORD PTR _nChar$[ebp], eax
$L197848:

; 392  : 	}
; 393  : 	else

  00cd5	eb 66		 jmp	 SHORT $L197849
$L197846:

; 394  : 	{
; 395  : 		// Go until special char or whitespace
; 396  : 		token.nL = nChar;

  00cd7	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00cda	8b 55 f8	 mov	 edx, DWORD PTR _nChar$[ebp]
  00cdd	89 11		 mov	 DWORD PTR [ecx], edx
$L197851:

; 397  : 		while ( szDoc[nChar] && ! _tcschr(_T(" \t\n\r<>=\\/?!"),szDoc[nChar]) )

  00cdf	8b 45 f4	 mov	 eax, DWORD PTR _szDoc$[ebp]
  00ce2	03 45 f8	 add	 eax, DWORD PTR _nChar$[ebp]
  00ce5	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00ce8	85 c9		 test	 ecx, ecx
  00cea	74 32		 je	 SHORT $L197852
  00cec	8b 55 f4	 mov	 edx, DWORD PTR _szDoc$[ebp]
  00cef	03 55 f8	 add	 edx, DWORD PTR _nChar$[ebp]
  00cf2	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00cf5	50		 push	 eax
  00cf6	68 00 00 00 00	 push	 OFFSET FLAT:$SG197853
  00cfb	e8 00 00 00 00	 call	 __tcschr
  00d00	83 c4 08	 add	 esp, 8
  00d03	85 c0		 test	 eax, eax
  00d05	75 17		 jne	 SHORT $L197852

; 398  : 			nChar += (int)_tclen(&szDoc[nChar]);

  00d07	8b 4d f4	 mov	 ecx, DWORD PTR _szDoc$[ebp]
  00d0a	03 4d f8	 add	 ecx, DWORD PTR _nChar$[ebp]
  00d0d	51		 push	 ecx
  00d0e	e8 00 00 00 00	 call	 __tclen
  00d13	83 c4 04	 add	 esp, 4
  00d16	03 45 f8	 add	 eax, DWORD PTR _nChar$[ebp]
  00d19	89 45 f8	 mov	 DWORD PTR _nChar$[ebp], eax
  00d1c	eb c1		 jmp	 SHORT $L197851
$L197852:

; 399  : 
; 400  : 		// Adjust end position if it is one special char
; 401  : 		if ( nChar == token.nL )

  00d1e	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00d21	8b 45 f8	 mov	 eax, DWORD PTR _nChar$[ebp]
  00d24	3b 02		 cmp	 eax, DWORD PTR [edx]
  00d26	75 09		 jne	 SHORT $L197855

; 402  : 			++nChar; // it is a special char

  00d28	8b 4d f8	 mov	 ecx, DWORD PTR _nChar$[ebp]
  00d2b	83 c1 01	 add	 ecx, 1
  00d2e	89 4d f8	 mov	 DWORD PTR _nChar$[ebp], ecx
$L197855:

; 403  : 		token.nR = nChar - 1;

  00d31	8b 55 f8	 mov	 edx, DWORD PTR _nChar$[ebp]
  00d34	83 ea 01	 sub	 edx, 1
  00d37	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00d3a	89 50 04	 mov	 DWORD PTR [eax+4], edx
$L197849:

; 404  : 	}
; 405  : 
; 406  : 	// nNext points to one past last char of token
; 407  : 	token.nNext = nChar;

  00d3d	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00d40	8b 55 f8	 mov	 edx, DWORD PTR _nChar$[ebp]
  00d43	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 408  : 	return true;

  00d46	b0 01		 mov	 al, 1
$L197841:

; 409  : }

  00d48	8b e5		 mov	 esp, ebp
  00d4a	5d		 pop	 ebp
  00d4b	c3		 ret	 0
?x_FindToken@CMarkup@@KA_NAAUTokenPos@1@@Z ENDP		; CMarkup::x_FindToken
_TEXT	ENDS
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:NEAR
EXTRN	__imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T199149 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_token$ = 12						; size = 4
?x_GetToken@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABUTokenPos@1@@Z PROC NEAR ; CMarkup::x_GetToken
; _this$ = ecx

; 412  : {

  00d50	55		 push	 ebp
  00d51	8b ec		 mov	 ebp, esp
  00d53	83 ec 08	 sub	 esp, 8
  00d56	56		 push	 esi
  00d57	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00d5a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T199149[ebp], 0

; 413  : 	// The token contains indexes into the document identifying a small substring
; 414  : 	// Build the substring from those indexes and return it
; 415  : 	if ( token.nL > token.nR )

  00d61	8b 45 0c	 mov	 eax, DWORD PTR _token$[ebp]
  00d64	8b 4d 0c	 mov	 ecx, DWORD PTR _token$[ebp]
  00d67	8b 10		 mov	 edx, DWORD PTR [eax]
  00d69	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00d6c	7e 1c		 jle	 SHORT $L197861

; 416  : 		return _T("");

  00d6e	68 00 00 00 00	 push	 OFFSET FLAT:$SG197862
  00d73	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00d76	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00d7c	8b 45 fc	 mov	 eax, DWORD PTR $T199149[ebp]
  00d7f	83 c8 01	 or	 eax, 1
  00d82	89 45 fc	 mov	 DWORD PTR $T199149[ebp], eax
  00d85	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00d88	eb 47		 jmp	 SHORT $L197860
$L197861:

; 417  : 	return m_csDoc.Mid( token.nL,
; 418  : 		token.nR - token.nL + ((token.nR<m_csDoc.GetLength())? 1:0) );

  00d8a	8b 4d 0c	 mov	 ecx, DWORD PTR _token$[ebp]
  00d8d	8b 55 0c	 mov	 edx, DWORD PTR _token$[ebp]
  00d90	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00d93	2b 32		 sub	 esi, DWORD PTR [edx]
  00d95	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d98	83 c1 04	 add	 ecx, 4
  00d9b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  00da1	8b 4d 0c	 mov	 ecx, DWORD PTR _token$[ebp]
  00da4	33 d2		 xor	 edx, edx
  00da6	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  00da9	0f 9c c2	 setl	 dl
  00dac	03 f2		 add	 esi, edx
  00dae	56		 push	 esi
  00daf	8b 45 0c	 mov	 eax, DWORD PTR _token$[ebp]
  00db2	8b 08		 mov	 ecx, DWORD PTR [eax]
  00db4	51		 push	 ecx
  00db5	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00db8	52		 push	 edx
  00db9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00dbc	83 c1 04	 add	 ecx, 4
  00dbf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z
  00dc5	8b 45 fc	 mov	 eax, DWORD PTR $T199149[ebp]
  00dc8	83 c8 01	 or	 eax, 1
  00dcb	89 45 fc	 mov	 DWORD PTR $T199149[ebp], eax
  00dce	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L197860:

; 419  : }

  00dd1	5e		 pop	 esi
  00dd2	8b e5		 mov	 esp, ebp
  00dd4	5d		 pop	 ebp
  00dd5	c2 08 00	 ret	 8
?x_GetToken@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABUTokenPos@1@@Z ENDP ; CMarkup::x_GetToken
; Function compile flags: /Odt
_this$ = -24						; size = 4
_token$ = -20						; size = 20
_iPosParent$ = 8					; size = 4
_iPos$ = 12						; size = 4
_szPath$ = 16						; size = 4
?x_FindElem@CMarkup@@IAEHHHPBD@Z PROC NEAR		; CMarkup::x_FindElem
; _this$ = ecx

; 422  : {

  00de0	55		 push	 ebp
  00de1	8b ec		 mov	 ebp, esp
  00de3	83 ec 18	 sub	 esp, 24			; 00000018H
  00de6	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 423  : 	// If szPath is NULL or empty, go to next sibling element
; 424  : 	// Otherwise go to next sibling element with matching path
; 425  : 	//
; 426  : 	if ( iPos )

  00de9	83 7d 0c 00	 cmp	 DWORD PTR _iPos$[ebp], 0
  00ded	74 17		 je	 SHORT $L197870

; 427  : 		iPos = m_aPos[iPos].iElemNext;

  00def	8b 45 0c	 mov	 eax, DWORD PTR _iPos$[ebp]
  00df2	50		 push	 eax
  00df3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00df6	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00df9	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00dfe	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00e01	89 4d 0c	 mov	 DWORD PTR _iPos$[ebp], ecx

; 428  : 	else

  00e04	eb 15		 jmp	 SHORT $L197871
$L197870:

; 429  : 		iPos = m_aPos[iPosParent].iElemChild;

  00e06	8b 55 08	 mov	 edx, DWORD PTR _iPosParent$[ebp]
  00e09	52		 push	 edx
  00e0a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e0d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00e10	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00e15	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00e18	89 45 0c	 mov	 DWORD PTR _iPos$[ebp], eax
$L197871:

; 430  : 
; 431  : 	// Finished here if szPath not specified
; 432  : 	if ( szPath == NULL || !szPath[0] )

  00e1b	83 7d 10 00	 cmp	 DWORD PTR _szPath$[ebp], 0
  00e1f	74 0a		 je	 SHORT $L197873
  00e21	8b 4d 10	 mov	 ecx, DWORD PTR _szPath$[ebp]
  00e24	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00e27	85 d2		 test	 edx, edx
  00e29	75 05		 jne	 SHORT $L197872
$L197873:

; 433  : 		return iPos;

  00e2b	8b 45 0c	 mov	 eax, DWORD PTR _iPos$[ebp]
  00e2e	eb 6f		 jmp	 SHORT $L197869
$L197872:

; 434  : 
; 435  : 	// Search
; 436  : 	TokenPos token( m_csDoc );

  00e30	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e33	83 c1 04	 add	 ecx, 4
  00e36	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00e3c	50		 push	 eax
  00e3d	8d 4d ec	 lea	 ecx, DWORD PTR _token$[ebp]
  00e40	e8 00 00 00 00	 call	 ??0TokenPos@CMarkup@@QAE@PBD@Z ; CMarkup::TokenPos::TokenPos
$L197876:

; 437  : 	while ( iPos )

  00e45	83 7d 0c 00	 cmp	 DWORD PTR _iPos$[ebp], 0
  00e49	74 52		 je	 SHORT $L197877

; 438  : 	{
; 439  : 		// Compare tag name
; 440  : 		token.nNext = m_aPos[iPos].nStartL + 1;

  00e4b	8b 45 0c	 mov	 eax, DWORD PTR _iPos$[ebp]
  00e4e	50		 push	 eax
  00e4f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e52	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00e55	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00e5a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e5c	83 c1 01	 add	 ecx, 1
  00e5f	89 4d f4	 mov	 DWORD PTR _token$[ebp+8], ecx

; 441  : 		x_FindToken( token ); // Locate tag name

  00e62	8d 55 ec	 lea	 edx, DWORD PTR _token$[ebp]
  00e65	52		 push	 edx
  00e66	e8 00 00 00 00	 call	 ?x_FindToken@CMarkup@@KA_NAAUTokenPos@1@@Z ; CMarkup::x_FindToken
  00e6b	83 c4 04	 add	 esp, 4

; 442  : 		if ( token.Match(szPath) )

  00e6e	8b 45 10	 mov	 eax, DWORD PTR _szPath$[ebp]
  00e71	50		 push	 eax
  00e72	8d 4d ec	 lea	 ecx, DWORD PTR _token$[ebp]
  00e75	e8 00 00 00 00	 call	 ?Match@TokenPos@CMarkup@@QAE_NPBD@Z ; CMarkup::TokenPos::Match
  00e7a	0f b6 c8	 movzx	 ecx, al
  00e7d	85 c9		 test	 ecx, ecx
  00e7f	74 05		 je	 SHORT $L197878

; 443  : 			return iPos;

  00e81	8b 45 0c	 mov	 eax, DWORD PTR _iPos$[ebp]
  00e84	eb 19		 jmp	 SHORT $L197869
$L197878:

; 444  : 		iPos = m_aPos[iPos].iElemNext;

  00e86	8b 55 0c	 mov	 edx, DWORD PTR _iPos$[ebp]
  00e89	52		 push	 edx
  00e8a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e8d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00e90	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  00e95	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00e98	89 45 0c	 mov	 DWORD PTR _iPos$[ebp], eax

; 445  : 	}

  00e9b	eb a8		 jmp	 SHORT $L197876
$L197877:

; 446  : 	return 0;

  00e9d	33 c0		 xor	 eax, eax
$L197869:

; 447  : }

  00e9f	8b e5		 mov	 esp, ebp
  00ea1	5d		 pop	 ebp
  00ea2	c2 0c 00	 ret	 12			; 0000000cH
?x_FindElem@CMarkup@@IAEHHHPBD@Z ENDP			; CMarkup::x_FindElem
_TEXT	ENDS
PUBLIC	__tcsstr
EXTRN	_strlen:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -36						; size = 4
_pEnd$197917 = -32					; size = 4
_cChar$197906 = -25					; size = 1
_nBrackets$197901 = -24					; size = 4
_cSecondChar$197894 = -17				; size = 1
_szEndOfNode$197889 = -16				; size = 4
_cFirstChar$197888 = -9					; size = 1
_szDoc$ = -8						; size = 4
_nTypeFound$ = -4					; size = 4
_token$ = 8						; size = 4
?x_ParseNode@CMarkup@@IAEHAAUTokenPos@1@@Z PROC NEAR	; CMarkup::x_ParseNode
; _this$ = ecx

; 450  : {

  00eb0	55		 push	 ebp
  00eb1	8b ec		 mov	 ebp, esp
  00eb3	83 ec 24	 sub	 esp, 36			; 00000024H
  00eb6	56		 push	 esi
  00eb7	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 451  : 	// Call this with token.nNext set to the start of the node
; 452  : 	// This returns the node type and token.nNext set to the char after the node
; 453  : 	// If the node is not found or an element, token.nR is not determined
; 454  : 	int nTypeFound = 0;

  00eba	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nTypeFound$[ebp], 0

; 455  : 	LPCTSTR szDoc = token.szDoc;

  00ec1	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00ec4	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00ec7	89 4d f8	 mov	 DWORD PTR _szDoc$[ebp], ecx

; 456  : 	token.nL = token.nNext;

  00eca	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00ecd	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00ed0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00ed3	89 0a		 mov	 DWORD PTR [edx], ecx

; 457  : 	if ( szDoc[token.nL] == '<' )

  00ed5	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00ed8	8b 02		 mov	 eax, DWORD PTR [edx]
  00eda	8b 4d f8	 mov	 ecx, DWORD PTR _szDoc$[ebp]
  00edd	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00ee1	83 fa 3c	 cmp	 edx, 60			; 0000003cH
  00ee4	0f 85 99 01 00
	00		 jne	 $L197885

; 458  : 	{
; 459  : 		// Started with <, could be:
; 460  : 		// <!--...--> comment
; 461  : 		// <!DOCTYPE ...> dtd
; 462  : 		// <?target ...?> processing instruction
; 463  : 		// <![CDATA[...]]> cdata section
; 464  : 		// <NAME ...> element
; 465  : 		//
; 466  : 		if ( ! szDoc[token.nL+1] || ! szDoc[token.nL+2] )

  00eea	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00eed	8b 08		 mov	 ecx, DWORD PTR [eax]
  00eef	8b 55 f8	 mov	 edx, DWORD PTR _szDoc$[ebp]
  00ef2	0f be 44 0a 01	 movsx	 eax, BYTE PTR [edx+ecx+1]
  00ef7	85 c0		 test	 eax, eax
  00ef9	74 11		 je	 SHORT $L197887
  00efb	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00efe	8b 11		 mov	 edx, DWORD PTR [ecx]
  00f00	8b 45 f8	 mov	 eax, DWORD PTR _szDoc$[ebp]
  00f03	0f be 4c 10 02	 movsx	 ecx, BYTE PTR [eax+edx+2]
  00f08	85 c9		 test	 ecx, ecx
  00f0a	75 07		 jne	 SHORT $L197886
$L197887:

; 467  : 			return 0;

  00f0c	33 c0		 xor	 eax, eax
  00f0e	e9 dd 01 00 00	 jmp	 $L197882
$L197886:

; 468  : 		_TCHAR cFirstChar = szDoc[token.nL+1];

  00f13	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00f16	8b 02		 mov	 eax, DWORD PTR [edx]
  00f18	8b 4d f8	 mov	 ecx, DWORD PTR _szDoc$[ebp]
  00f1b	8a 54 01 01	 mov	 dl, BYTE PTR [ecx+eax+1]
  00f1f	88 55 f7	 mov	 BYTE PTR _cFirstChar$197888[ebp], dl

; 469  : 		LPCTSTR szEndOfNode = NULL;

  00f22	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _szEndOfNode$197889[ebp], 0

; 470  : 		if ( cFirstChar == _T('?') )

  00f29	0f be 45 f7	 movsx	 eax, BYTE PTR _cFirstChar$197888[ebp]
  00f2d	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00f30	75 13		 jne	 SHORT $L197890

; 471  : 		{
; 472  : 			nTypeFound = MNT_PROCESSING_INSTRUCTION;

  00f32	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR _nTypeFound$[ebp], 16 ; 00000010H

; 473  : 			szEndOfNode = _T("?>");

  00f39	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _szEndOfNode$197889[ebp], OFFSET FLAT:$SG197891

; 474  : 		}
; 475  : 		else if ( cFirstChar == _T('!') )

  00f40	e9 f6 00 00 00	 jmp	 $L197892
$L197890:
  00f45	0f be 4d f7	 movsx	 ecx, BYTE PTR _cFirstChar$197888[ebp]
  00f49	83 f9 21	 cmp	 ecx, 33			; 00000021H
  00f4c	0f 85 d2 00 00
	00		 jne	 $L197893

; 476  : 		{
; 477  : 			_TCHAR cSecondChar = szDoc[token.nL+2];

  00f52	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00f55	8b 02		 mov	 eax, DWORD PTR [edx]
  00f57	8b 4d f8	 mov	 ecx, DWORD PTR _szDoc$[ebp]
  00f5a	8a 54 01 02	 mov	 dl, BYTE PTR [ecx+eax+2]
  00f5e	88 55 ef	 mov	 BYTE PTR _cSecondChar$197894[ebp], dl

; 478  : 			if ( cSecondChar == _T('[') )

  00f61	0f be 45 ef	 movsx	 eax, BYTE PTR _cSecondChar$197894[ebp]
  00f65	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  00f68	75 13		 jne	 SHORT $L197895

; 479  : 			{
; 480  : 				nTypeFound = MNT_CDATA_SECTION;

  00f6a	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR _nTypeFound$[ebp], 8

; 481  : 				szEndOfNode = _T("]]>");

  00f71	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _szEndOfNode$197889[ebp], OFFSET FLAT:$SG197896

; 482  : 			}
; 483  : 			else if ( cSecondChar == _T('-') )

  00f78	e9 a5 00 00 00	 jmp	 $L197897
$L197895:
  00f7d	0f be 4d ef	 movsx	 ecx, BYTE PTR _cSecondChar$197894[ebp]
  00f81	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00f84	75 13		 jne	 SHORT $L197898

; 484  : 			{
; 485  : 				nTypeFound = MNT_COMMENT;

  00f86	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _nTypeFound$[ebp], 32 ; 00000020H

; 486  : 				szEndOfNode = _T("-->");

  00f8d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _szEndOfNode$197889[ebp], OFFSET FLAT:$SG197899

; 487  : 			}
; 488  : 			else

  00f94	e9 89 00 00 00	 jmp	 $L197897
$L197898:

; 489  : 			{
; 490  : 				// Document type requires tokenizing because of strings and brackets
; 491  : 				nTypeFound = 0;

  00f99	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nTypeFound$[ebp], 0

; 492  : 				int nBrackets = 0;

  00fa0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _nBrackets$197901[ebp], 0
$L197903:

; 493  : 				while ( x_FindToken(token) )

  00fa7	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00faa	52		 push	 edx
  00fab	e8 00 00 00 00	 call	 ?x_FindToken@CMarkup@@KA_NAAUTokenPos@1@@Z ; CMarkup::x_FindToken
  00fb0	83 c4 04	 add	 esp, 4
  00fb3	0f b6 c0	 movzx	 eax, al
  00fb6	85 c0		 test	 eax, eax
  00fb8	74 5b		 je	 SHORT $L197904

; 494  : 				{
; 495  : 					if ( ! token.bIsString )

  00fba	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00fbd	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00fc1	85 d2		 test	 edx, edx
  00fc3	75 4e		 jne	 SHORT $L197905

; 496  : 					{
; 497  : 						_TCHAR cChar = szDoc[token.nL];

  00fc5	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00fc8	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fca	8b 55 f8	 mov	 edx, DWORD PTR _szDoc$[ebp]
  00fcd	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  00fd0	88 45 e7	 mov	 BYTE PTR _cChar$197906[ebp], al

; 498  : 						if ( cChar == _T('[') )

  00fd3	0f be 4d e7	 movsx	 ecx, BYTE PTR _cChar$197906[ebp]
  00fd7	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00fda	75 0b		 jne	 SHORT $L197907

; 499  : 							++nBrackets;

  00fdc	8b 55 e8	 mov	 edx, DWORD PTR _nBrackets$197901[ebp]
  00fdf	83 c2 01	 add	 edx, 1
  00fe2	89 55 e8	 mov	 DWORD PTR _nBrackets$197901[ebp], edx

; 500  : 						else if ( cChar == _T(']') )

  00fe5	eb 2c		 jmp	 SHORT $L197905
$L197907:
  00fe7	0f be 45 e7	 movsx	 eax, BYTE PTR _cChar$197906[ebp]
  00feb	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  00fee	75 0b		 jne	 SHORT $L197909

; 501  : 							--nBrackets;

  00ff0	8b 4d e8	 mov	 ecx, DWORD PTR _nBrackets$197901[ebp]
  00ff3	83 e9 01	 sub	 ecx, 1
  00ff6	89 4d e8	 mov	 DWORD PTR _nBrackets$197901[ebp], ecx

; 502  : 						else if ( nBrackets == 0 && cChar == _T('>') )

  00ff9	eb 18		 jmp	 SHORT $L197905
$L197909:
  00ffb	83 7d e8 00	 cmp	 DWORD PTR _nBrackets$197901[ebp], 0
  00fff	75 12		 jne	 SHORT $L197905
  01001	0f be 55 e7	 movsx	 edx, BYTE PTR _cChar$197906[ebp]
  01005	83 fa 3e	 cmp	 edx, 62			; 0000003eH
  01008	75 09		 jne	 SHORT $L197905

; 503  : 						{
; 504  : 							nTypeFound = MNT_DOCUMENT_TYPE;

  0100a	c7 45 fc 40 00
	00 00		 mov	 DWORD PTR _nTypeFound$[ebp], 64 ; 00000040H

; 505  : 							break;

  01011	eb 02		 jmp	 SHORT $L197904
$L197905:

; 506  : 						}
; 507  : 					}
; 508  : 				}

  01013	eb 92		 jmp	 SHORT $L197903
$L197904:

; 509  : 				if ( ! nTypeFound )

  01015	83 7d fc 00	 cmp	 DWORD PTR _nTypeFound$[ebp], 0
  01019	75 07		 jne	 SHORT $L197897

; 510  : 					return 0;

  0101b	33 c0		 xor	 eax, eax
  0101d	e9 ce 00 00 00	 jmp	 $L197882
$L197897:

; 511  : 			}
; 512  : 		}
; 513  : 		else if ( cFirstChar == _T('/') )

  01022	eb 17		 jmp	 SHORT $L197892
$L197893:
  01024	0f be 45 f7	 movsx	 eax, BYTE PTR _cFirstChar$197888[ebp]
  01028	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0102b	75 07		 jne	 SHORT $L197914

; 514  : 		{
; 515  : 			// End tag means no node found within parent element
; 516  : 			return 0;

  0102d	33 c0		 xor	 eax, eax
  0102f	e9 bc 00 00 00	 jmp	 $L197882
$L197914:

; 517  : 		}
; 518  : 		else
; 519  : 		{
; 520  : 			nTypeFound = MNT_ELEMENT;

  01034	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _nTypeFound$[ebp], 1
$L197892:

; 521  : 		}
; 522  : 
; 523  : 		// Search for end of node if not found yet
; 524  : 		if ( szEndOfNode )

  0103b	83 7d f0 00	 cmp	 DWORD PTR _szEndOfNode$197889[ebp], 0
  0103f	74 40		 je	 SHORT $L197916

; 525  : 		{
; 526  : 			LPCTSTR pEnd = _tcsstr( &szDoc[token.nNext], szEndOfNode );

  01041	8b 4d f0	 mov	 ecx, DWORD PTR _szEndOfNode$197889[ebp]
  01044	51		 push	 ecx
  01045	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  01048	8b 45 f8	 mov	 eax, DWORD PTR _szDoc$[ebp]
  0104b	03 42 08	 add	 eax, DWORD PTR [edx+8]
  0104e	50		 push	 eax
  0104f	e8 00 00 00 00	 call	 __tcsstr
  01054	83 c4 08	 add	 esp, 8
  01057	89 45 e0	 mov	 DWORD PTR _pEnd$197917[ebp], eax

; 527  : 			if ( ! pEnd )

  0105a	83 7d e0 00	 cmp	 DWORD PTR _pEnd$197917[ebp], 0
  0105e	75 07		 jne	 SHORT $L197918

; 528  : 				return 0; // not well-formed

  01060	33 c0		 xor	 eax, eax
  01062	e9 89 00 00 00	 jmp	 $L197882
$L197918:

; 529  : 			token.nNext = (int)(pEnd - szDoc) + (int)_tcslen(szEndOfNode);

  01067	8b 75 e0	 mov	 esi, DWORD PTR _pEnd$197917[ebp]
  0106a	2b 75 f8	 sub	 esi, DWORD PTR _szDoc$[ebp]
  0106d	8b 4d f0	 mov	 ecx, DWORD PTR _szEndOfNode$197889[ebp]
  01070	51		 push	 ecx
  01071	e8 00 00 00 00	 call	 _strlen
  01076	83 c4 04	 add	 esp, 4
  01079	03 f0		 add	 esi, eax
  0107b	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  0107e	89 72 08	 mov	 DWORD PTR [edx+8], esi
$L197916:

; 530  : 		}
; 531  : 	}
; 532  : 	else if ( szDoc[token.nL] )

  01081	eb 6a		 jmp	 SHORT $L197921
$L197885:
  01083	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  01086	8b 08		 mov	 ecx, DWORD PTR [eax]
  01088	8b 55 f8	 mov	 edx, DWORD PTR _szDoc$[ebp]
  0108b	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0108f	85 c0		 test	 eax, eax
  01091	74 5a		 je	 SHORT $L197921

; 533  : 	{
; 534  : 		// It is text or whitespace because it did not start with <
; 535  : 		nTypeFound = MNT_WHITESPACE;

  01093	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR _nTypeFound$[ebp], 4

; 536  : 		token.nNext = token.nL;

  0109a	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  0109d	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  010a0	8b 02		 mov	 eax, DWORD PTR [edx]
  010a2	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 537  : 		if ( x_FindAny(szDoc,token.nNext) )

  010a5	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  010a8	83 c1 08	 add	 ecx, 8
  010ab	51		 push	 ecx
  010ac	8b 55 f8	 mov	 edx, DWORD PTR _szDoc$[ebp]
  010af	52		 push	 edx
  010b0	e8 00 00 00 00	 call	 ?x_FindAny@CMarkup@@KA_NPBDAAH@Z ; CMarkup::x_FindAny
  010b5	83 c4 08	 add	 esp, 8
  010b8	0f b6 c0	 movzx	 eax, al
  010bb	85 c0		 test	 eax, eax
  010bd	74 2e		 je	 SHORT $L197921

; 538  : 		{
; 539  : 			if ( szDoc[token.nNext] != _T('<') )

  010bf	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  010c2	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  010c5	8b 45 f8	 mov	 eax, DWORD PTR _szDoc$[ebp]
  010c8	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  010cc	83 f9 3c	 cmp	 ecx, 60			; 0000003cH
  010cf	74 1c		 je	 SHORT $L197921

; 540  : 			{
; 541  : 				nTypeFound = MNT_TEXT;

  010d1	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _nTypeFound$[ebp], 2

; 542  : 				x_FindChar( szDoc, token.nNext, _T('<') );

  010d8	6a 3c		 push	 60			; 0000003cH
  010da	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  010dd	83 c2 08	 add	 edx, 8
  010e0	52		 push	 edx
  010e1	8b 45 f8	 mov	 eax, DWORD PTR _szDoc$[ebp]
  010e4	50		 push	 eax
  010e5	e8 00 00 00 00	 call	 ?x_FindChar@CMarkup@@KA_NPBDAAHD@Z ; CMarkup::x_FindChar
  010ea	83 c4 0c	 add	 esp, 12			; 0000000cH
$L197921:

; 543  : 			}
; 544  : 		}
; 545  : 	}
; 546  : 	return nTypeFound;

  010ed	8b 45 fc	 mov	 eax, DWORD PTR _nTypeFound$[ebp]
$L197882:

; 547  : }

  010f0	5e		 pop	 esi
  010f1	8b e5		 mov	 esp, ebp
  010f3	5d		 pop	 ebp
  010f4	c2 04 00	 ret	 4
?x_ParseNode@CMarkup@@IAEHAAUTokenPos@1@@Z ENDP		; CMarkup::x_ParseNode
_TEXT	ENDS
EXTRN	__imp___mbsstr:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\tchar.h
;	COMDAT __tcsstr
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcsstr PROC NEAR					; COMDAT

; 847  : __inline _PC _tcsstr(_CPC _s1,_CPC _s2) {return (_PC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __s2$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsstr
  00011	83 c4 08	 add	 esp, 8
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
__tcsstr ENDP
_TEXT	ENDS
PUBLIC	??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.cpp
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T199157 = -24						; size = 4
_token$ = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
_iPos$ = 12						; size = 4
?x_GetTagName@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC NEAR ; CMarkup::x_GetTagName
; _this$ = ecx

; 550  : {

  01100	55		 push	 ebp
  01101	8b ec		 mov	 ebp, esp
  01103	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01106	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  01109	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T199157[ebp], 0

; 551  : 	// Return the tag name at specified element
; 552  : 	TokenPos token( m_csDoc );

  01110	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  01113	83 c1 04	 add	 ecx, 4
  01116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0111c	50		 push	 eax
  0111d	8d 4d ec	 lea	 ecx, DWORD PTR _token$[ebp]
  01120	e8 00 00 00 00	 call	 ??0TokenPos@CMarkup@@QAE@PBD@Z ; CMarkup::TokenPos::TokenPos

; 553  : 	token.nNext = m_aPos[iPos].nStartL + 1;

  01125	8b 45 0c	 mov	 eax, DWORD PTR _iPos$[ebp]
  01128	50		 push	 eax
  01129	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0112c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0112f	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01134	8b 08		 mov	 ecx, DWORD PTR [eax]
  01136	83 c1 01	 add	 ecx, 1
  01139	89 4d f4	 mov	 DWORD PTR _token$[ebp+8], ecx

; 554  : 	if ( ! iPos || ! x_FindToken( token ) )

  0113c	83 7d 0c 00	 cmp	 DWORD PTR _iPos$[ebp], 0
  01140	74 13		 je	 SHORT $L197932
  01142	8d 55 ec	 lea	 edx, DWORD PTR _token$[ebp]
  01145	52		 push	 edx
  01146	e8 00 00 00 00	 call	 ?x_FindToken@CMarkup@@KA_NAAUTokenPos@1@@Z ; CMarkup::x_FindToken
  0114b	83 c4 04	 add	 esp, 4
  0114e	0f b6 c0	 movzx	 eax, al
  01151	85 c0		 test	 eax, eax
  01153	75 1c		 jne	 SHORT $L197931
$L197932:

; 555  : 		return _T("");

  01155	68 00 00 00 00	 push	 OFFSET FLAT:$SG197933
  0115a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0115d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  01163	8b 4d e8	 mov	 ecx, DWORD PTR $T199157[ebp]
  01166	83 c9 01	 or	 ecx, 1
  01169	89 4d e8	 mov	 DWORD PTR $T199157[ebp], ecx
  0116c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0116f	eb 1c		 jmp	 SHORT $L197929
$L197931:

; 556  : 
; 557  : 	// Return substring of document
; 558  : 	return x_GetToken( token );

  01171	8d 55 ec	 lea	 edx, DWORD PTR _token$[ebp]
  01174	52		 push	 edx
  01175	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  01178	50		 push	 eax
  01179	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0117c	e8 00 00 00 00	 call	 ?x_GetToken@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABUTokenPos@1@@Z ; CMarkup::x_GetToken
  01181	8b 4d e8	 mov	 ecx, DWORD PTR $T199157[ebp]
  01184	83 c9 01	 or	 ecx, 1
  01187	89 4d e8	 mov	 DWORD PTR $T199157[ebp], ecx
  0118a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L197929:

; 559  : }

  0118d	8b e5		 mov	 esp, ebp
  0118f	5d		 pop	 ebp
  01190	c2 08 00	 ret	 8
?x_GetTagName@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; CMarkup::x_GetTagName
_TEXT	ENDS
PUBLIC	?x_FindAttrib@CMarkup@@IBE_NAAUTokenPos@1@PBD@Z	; CMarkup::x_FindAttrib
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -16						; size = 4
_cChar$197946 = -9					; size = 1
_nCount$197941 = -8					; size = 4
_nAttrib$ = -4						; size = 4
_token$ = 8						; size = 4
_szAttrib$ = 12						; size = 4
?x_FindAttrib@CMarkup@@IBE_NAAUTokenPos@1@PBD@Z PROC NEAR ; CMarkup::x_FindAttrib
; _this$ = ecx

; 562  : {

  011a0	55		 push	 ebp
  011a1	8b ec		 mov	 ebp, esp
  011a3	83 ec 10	 sub	 esp, 16			; 00000010H
  011a6	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 563  : 	// If szAttrib is NULL find next attrib, otherwise find named attrib
; 564  : 	// Return true if found
; 565  : 	int nAttrib = 0;

  011a9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nAttrib$[ebp], 0

; 566  : 	for ( int nCount = 0; x_FindToken(token); ++nCount )

  011b0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nCount$197941[ebp], 0
  011b7	eb 09		 jmp	 SHORT $L197942
$L197943:
  011b9	8b 45 f8	 mov	 eax, DWORD PTR _nCount$197941[ebp]
  011bc	83 c0 01	 add	 eax, 1
  011bf	89 45 f8	 mov	 DWORD PTR _nCount$197941[ebp], eax
$L197942:
  011c2	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  011c5	51		 push	 ecx
  011c6	e8 00 00 00 00	 call	 ?x_FindToken@CMarkup@@KA_NAAUTokenPos@1@@Z ; CMarkup::x_FindToken
  011cb	83 c4 04	 add	 esp, 4
  011ce	0f b6 d0	 movzx	 edx, al
  011d1	85 d2		 test	 edx, edx
  011d3	0f 84 9d 00 00
	00		 je	 $L197944

; 567  : 	{
; 568  : 		if ( ! token.bIsString )

  011d9	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  011dc	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  011e0	85 c9		 test	 ecx, ecx
  011e2	75 78		 jne	 SHORT $L197945

; 569  : 		{
; 570  : 			// Is it the right angle bracket?
; 571  : 			_TCHAR cChar = m_csDoc[token.nL];

  011e4	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  011e7	8b 02		 mov	 eax, DWORD PTR [edx]
  011e9	50		 push	 eax
  011ea	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  011ed	83 c1 04	 add	 ecx, 4
  011f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
  011f6	88 45 f7	 mov	 BYTE PTR _cChar$197946[ebp], al

; 572  : 			if ( cChar == _T('>') || cChar == _T('/') || cChar == _T('?') )

  011f9	0f be 4d f7	 movsx	 ecx, BYTE PTR _cChar$197946[ebp]
  011fd	83 f9 3e	 cmp	 ecx, 62			; 0000003eH
  01200	74 12		 je	 SHORT $L197948
  01202	0f be 55 f7	 movsx	 edx, BYTE PTR _cChar$197946[ebp]
  01206	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  01209	74 09		 je	 SHORT $L197948
  0120b	0f be 45 f7	 movsx	 eax, BYTE PTR _cChar$197946[ebp]
  0120f	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  01212	75 02		 jne	 SHORT $L197947
$L197948:

; 573  : 				break; // attrib not found

  01214	eb 60		 jmp	 SHORT $L197944
$L197947:

; 574  : 
; 575  : 			// Equal sign
; 576  : 			if ( cChar == _T('=') )

  01216	0f be 4d f7	 movsx	 ecx, BYTE PTR _cChar$197946[ebp]
  0121a	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  0121d	75 02		 jne	 SHORT $L197949

; 577  : 				continue;

  0121f	eb 98		 jmp	 SHORT $L197943
$L197949:

; 578  : 
; 579  : 			// Potential attribute
; 580  : 			if ( ! nAttrib && nCount )

  01221	83 7d fc 00	 cmp	 DWORD PTR _nAttrib$[ebp], 0
  01225	75 33		 jne	 SHORT $L197950
  01227	83 7d f8 00	 cmp	 DWORD PTR _nCount$197941[ebp], 0
  0122b	74 2d		 je	 SHORT $L197950

; 581  : 			{
; 582  : 				// Attribute name search?
; 583  : 				if ( ! szAttrib || ! szAttrib[0] )

  0122d	83 7d 0c 00	 cmp	 DWORD PTR _szAttrib$[ebp], 0
  01231	74 0a		 je	 SHORT $L197952
  01233	8b 55 0c	 mov	 edx, DWORD PTR _szAttrib$[ebp]
  01236	0f be 02	 movsx	 eax, BYTE PTR [edx]
  01239	85 c0		 test	 eax, eax
  0123b	75 04		 jne	 SHORT $L197951
$L197952:

; 584  : 					return true; // return with token at attrib name

  0123d	b0 01		 mov	 al, 1
  0123f	eb 37		 jmp	 SHORT $L197939
$L197951:

; 585  : 
; 586  : 				// Compare szAttrib
; 587  : 				if ( token.Match(szAttrib) )

  01241	8b 4d 0c	 mov	 ecx, DWORD PTR _szAttrib$[ebp]
  01244	51		 push	 ecx
  01245	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  01248	e8 00 00 00 00	 call	 ?Match@TokenPos@CMarkup@@QAE_NPBD@Z ; CMarkup::TokenPos::Match
  0124d	0f b6 d0	 movzx	 edx, al
  01250	85 d2		 test	 edx, edx
  01252	74 06		 je	 SHORT $L197950

; 588  : 					nAttrib = nCount;

  01254	8b 45 f8	 mov	 eax, DWORD PTR _nCount$197941[ebp]
  01257	89 45 fc	 mov	 DWORD PTR _nAttrib$[ebp], eax
$L197950:

; 589  : 			}
; 590  : 		}
; 591  : 		else if ( nAttrib && nCount == nAttrib + 2 )

  0125a	eb 15		 jmp	 SHORT $L197954
$L197945:
  0125c	83 7d fc 00	 cmp	 DWORD PTR _nAttrib$[ebp], 0
  01260	74 0f		 je	 SHORT $L197954
  01262	8b 4d fc	 mov	 ecx, DWORD PTR _nAttrib$[ebp]
  01265	83 c1 02	 add	 ecx, 2
  01268	39 4d f8	 cmp	 DWORD PTR _nCount$197941[ebp], ecx
  0126b	75 04		 jne	 SHORT $L197954

; 592  : 		{
; 593  : 			return true;

  0126d	b0 01		 mov	 al, 1
  0126f	eb 07		 jmp	 SHORT $L197939
$L197954:

; 594  : 		}
; 595  : 	}

  01271	e9 43 ff ff ff	 jmp	 $L197943
$L197944:

; 596  : 
; 597  : 	// Not found
; 598  : 	return false;

  01276	32 c0		 xor	 al, al
$L197939:

; 599  : }

  01278	8b e5		 mov	 esp, ebp
  0127a	5d		 pop	 ebp
  0127b	c2 08 00	 ret	 8
?x_FindAttrib@CMarkup@@IBE_NAAUTokenPos@1@PBD@Z ENDP	; CMarkup::x_FindAttrib
_TEXT	ENDS
PUBLIC	?x_GetAttrib@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPBD@Z ; CMarkup::x_GetAttrib
PUBLIC	?x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z ; CMarkup::x_TextFromDoc
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T199162 = -24						; size = 4
_token$ = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
_iPos$ = 12						; size = 4
_szAttrib$ = 16						; size = 4
?x_GetAttrib@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPBD@Z PROC NEAR ; CMarkup::x_GetAttrib
; _this$ = ecx

; 602  : {

  01280	55		 push	 ebp
  01281	8b ec		 mov	 ebp, esp
  01283	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01286	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  01289	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T199162[ebp], 0

; 603  : 	// Return the value of the attrib
; 604  : 	TokenPos token( m_csDoc );

  01290	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  01293	83 c1 04	 add	 ecx, 4
  01296	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0129c	50		 push	 eax
  0129d	8d 4d ec	 lea	 ecx, DWORD PTR _token$[ebp]
  012a0	e8 00 00 00 00	 call	 ??0TokenPos@CMarkup@@QAE@PBD@Z ; CMarkup::TokenPos::TokenPos

; 605  : 	if ( iPos && m_nNodeType == MNT_ELEMENT )

  012a5	83 7d 0c 00	 cmp	 DWORD PTR _iPos$[ebp], 0
  012a9	74 22		 je	 SHORT $L197963
  012ab	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  012ae	83 78 30 01	 cmp	 DWORD PTR [eax+48], 1
  012b2	75 19		 jne	 SHORT $L197963

; 606  : 		token.nNext = m_aPos[iPos].nStartL + 1;

  012b4	8b 4d 0c	 mov	 ecx, DWORD PTR _iPos$[ebp]
  012b7	51		 push	 ecx
  012b8	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  012bb	83 c1 0c	 add	 ecx, 12			; 0000000cH
  012be	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  012c3	8b 10		 mov	 edx, DWORD PTR [eax]
  012c5	83 c2 01	 add	 edx, 1
  012c8	89 55 f4	 mov	 DWORD PTR _token$[ebp+8], edx

; 607  : 	else

  012cb	eb 1c		 jmp	 SHORT $L197964
$L197963:

; 608  : 		return _T("");

  012cd	68 00 00 00 00	 push	 OFFSET FLAT:$SG197965
  012d2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  012d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  012db	8b 45 e8	 mov	 eax, DWORD PTR $T199162[ebp]
  012de	83 c8 01	 or	 eax, 1
  012e1	89 45 e8	 mov	 DWORD PTR $T199162[ebp], eax
  012e4	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  012e7	eb 6f		 jmp	 SHORT $L197961
$L197964:

; 609  : 
; 610  : 	if ( szAttrib && x_FindAttrib( token, szAttrib ) )

  012e9	83 7d 10 00	 cmp	 DWORD PTR _szAttrib$[ebp], 0
  012ed	74 4f		 je	 SHORT $L197966
  012ef	8b 4d 10	 mov	 ecx, DWORD PTR _szAttrib$[ebp]
  012f2	51		 push	 ecx
  012f3	8d 55 ec	 lea	 edx, DWORD PTR _token$[ebp]
  012f6	52		 push	 edx
  012f7	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  012fa	e8 00 00 00 00	 call	 ?x_FindAttrib@CMarkup@@IBE_NAAUTokenPos@1@PBD@Z ; CMarkup::x_FindAttrib
  012ff	0f b6 c0	 movzx	 eax, al
  01302	85 c0		 test	 eax, eax
  01304	74 38		 je	 SHORT $L197966

; 611  : 		return x_TextFromDoc( token.nL, token.nR - ((token.nR<m_csDoc.GetLength())?0:1) );

  01306	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  01309	83 c1 04	 add	 ecx, 4
  0130c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  01312	33 c9		 xor	 ecx, ecx
  01314	39 45 f0	 cmp	 DWORD PTR _token$[ebp+4], eax
  01317	0f 9d c1	 setge	 cl
  0131a	8b 55 f0	 mov	 edx, DWORD PTR _token$[ebp+4]
  0131d	2b d1		 sub	 edx, ecx
  0131f	52		 push	 edx
  01320	8b 45 ec	 mov	 eax, DWORD PTR _token$[ebp]
  01323	50		 push	 eax
  01324	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01327	51		 push	 ecx
  01328	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0132b	e8 00 00 00 00	 call	 ?x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z ; CMarkup::x_TextFromDoc
  01330	8b 55 e8	 mov	 edx, DWORD PTR $T199162[ebp]
  01333	83 ca 01	 or	 edx, 1
  01336	89 55 e8	 mov	 DWORD PTR $T199162[ebp], edx
  01339	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0133c	eb 1a		 jmp	 SHORT $L197961
$L197966:

; 612  : 	return _T("");

  0133e	68 00 00 00 00	 push	 OFFSET FLAT:$SG197968
  01343	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01346	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0134c	8b 45 e8	 mov	 eax, DWORD PTR $T199162[ebp]
  0134f	83 c8 01	 or	 eax, 1
  01352	89 45 e8	 mov	 DWORD PTR $T199162[ebp], eax
  01355	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L197961:

; 613  : }

  01358	8b e5		 mov	 esp, ebp
  0135a	5d		 pop	 ebp
  0135b	c2 0c 00	 ret	 12			; 0000000cH
?x_GetAttrib@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPBD@Z ENDP ; CMarkup::x_GetAttrib
_TEXT	ENDS
PUBLIC	?IsEmptyElement@ElemPos@CMarkup@@QBE_NXZ	; CMarkup::ElemPos::IsEmptyElement
PUBLIC	?AdjustEnd@ElemPos@CMarkup@@QAEXH@Z		; CMarkup::ElemPos::AdjustEnd
PUBLIC	?x_SetAttrib@CMarkup@@IAE_NHPBD0@Z		; CMarkup::x_SetAttrib
PUBLIC	?x_DocChange@CMarkup@@IAEXHHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CMarkup::x_DocChange
PUBLIC	?x_Adjust@CMarkup@@IAEXHH_N@Z			; CMarkup::x_Adjust
PUBLIC	?x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z ; CMarkup::x_TextToDoc
EXTRN	__imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@D$00@1@@Z:NEAR
EXTRN	__imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:NEAR
xdata$x	SEGMENT
$T199175 DD	0ffffffffH
	DD	FLAT:$L199168
	DD	00H
	DD	FLAT:$L199169
	DD	00H
	DD	FLAT:$L199170
	DD	02H
	DD	FLAT:$L199171
$T199173 DD	019930520H
	DD	04H
	DD	FLAT:$T199175
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv178 = -88						; size = 4
tv195 = -84						; size = 4
tv145 = -80						; size = 4
tv192 = -76						; size = 4
tv93 = -72						; size = 4
_this$ = -68						; size = 4
$T199167 = -61						; size = 1
$T199166 = -60						; size = 4
$T199165 = -56						; size = 4
_csFormat$197984 = -52					; size = 4
_csInsert$ = -48					; size = 4
_nAdjust$ = -44						; size = 4
_nInsertAt$ = -40					; size = 4
_nReplace$ = -36					; size = 4
_token$ = -32						; size = 20
__$EHRec$ = -12						; size = 12
_iPos$ = 8						; size = 4
_szAttrib$ = 12						; size = 4
_szValue$ = 16						; size = 4
?x_SetAttrib@CMarkup@@IAE_NHPBD0@Z PROC NEAR		; CMarkup::x_SetAttrib
; _this$ = ecx

; 616  : {

  01360	55		 push	 ebp
  01361	8b ec		 mov	 ebp, esp
  01363	6a ff		 push	 -1
  01365	68 00 00 00 00	 push	 __ehhandler$?x_SetAttrib@CMarkup@@IAE_NHPBD0@Z
  0136a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01370	50		 push	 eax
  01371	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01378	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0137b	56		 push	 esi
  0137c	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 617  : 	// Set attribute in iPos element
; 618  : 	TokenPos token( m_csDoc );

  0137f	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  01382	83 c1 04	 add	 ecx, 4
  01385	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0138b	50		 push	 eax
  0138c	8d 4d e0	 lea	 ecx, DWORD PTR _token$[ebp]
  0138f	e8 00 00 00 00	 call	 ??0TokenPos@CMarkup@@QAE@PBD@Z ; CMarkup::TokenPos::TokenPos

; 619  : 	int nInsertAt;
; 620  : 	if ( iPos && m_nNodeType == MNT_ELEMENT )

  01394	83 7d 08 00	 cmp	 DWORD PTR _iPos$[ebp], 0
  01398	74 5a		 je	 SHORT $L197977
  0139a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0139d	83 78 30 01	 cmp	 DWORD PTR [eax+48], 1
  013a1	75 51		 jne	 SHORT $L197977

; 621  : 	{
; 622  : 		token.nNext = m_aPos[iPos].nStartL + 1;

  013a3	8b 4d 08	 mov	 ecx, DWORD PTR _iPos$[ebp]
  013a6	51		 push	 ecx
  013a7	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  013aa	83 c1 0c	 add	 ecx, 12			; 0000000cH
  013ad	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  013b2	8b 10		 mov	 edx, DWORD PTR [eax]
  013b4	83 c2 01	 add	 edx, 1
  013b7	89 55 e8	 mov	 DWORD PTR _token$[ebp+8], edx

; 623  : 		nInsertAt = m_aPos[iPos].nStartR - (m_aPos[iPos].IsEmptyElement()?1:0);

  013ba	8b 45 08	 mov	 eax, DWORD PTR _iPos$[ebp]
  013bd	50		 push	 eax
  013be	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  013c1	83 c1 0c	 add	 ecx, 12			; 0000000cH
  013c4	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  013c9	8b f0		 mov	 esi, eax
  013cb	8b 4d 08	 mov	 ecx, DWORD PTR _iPos$[ebp]
  013ce	51		 push	 ecx
  013cf	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  013d2	83 c1 0c	 add	 ecx, 12			; 0000000cH
  013d5	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  013da	8b c8		 mov	 ecx, eax
  013dc	e8 00 00 00 00	 call	 ?IsEmptyElement@ElemPos@CMarkup@@QBE_NXZ ; CMarkup::ElemPos::IsEmptyElement
  013e1	0f b6 d0	 movzx	 edx, al
  013e4	f7 da		 neg	 edx
  013e6	1b d2		 sbb	 edx, edx
  013e8	f7 da		 neg	 edx
  013ea	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  013ed	2b c2		 sub	 eax, edx
  013ef	89 45 d8	 mov	 DWORD PTR _nInsertAt$[ebp], eax

; 624  : 	}
; 625  : 	else

  013f2	eb 07		 jmp	 SHORT $L197978
$L197977:

; 626  : 		return false;

  013f4	32 c0		 xor	 al, al
  013f6	e9 9d 01 00 00	 jmp	 $L197974
$L197978:

; 627  : 
; 628  : 	// Create insertion text depending on whether attribute already exists
; 629  : 	int nReplace = 0;

  013fb	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _nReplace$[ebp], 0

; 630  : 	CString csInsert;

  01402	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  01405	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0140b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 631  : 	if ( x_FindAttrib( token, szAttrib ) )

  01412	8b 4d 0c	 mov	 ecx, DWORD PTR _szAttrib$[ebp]
  01415	51		 push	 ecx
  01416	8d 55 e0	 lea	 edx, DWORD PTR _token$[ebp]
  01419	52		 push	 edx
  0141a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0141d	e8 00 00 00 00	 call	 ?x_FindAttrib@CMarkup@@IBE_NAAUTokenPos@1@PBD@Z ; CMarkup::x_FindAttrib
  01422	0f b6 c0	 movzx	 eax, al
  01425	85 c0		 test	 eax, eax
  01427	74 50		 je	 SHORT $L197981

; 632  : 	{
; 633  : 		// Replace value only
; 634  : 		// Decision: for empty value leaving attrib="" instead of removing attrib
; 635  : 		csInsert = x_TextToDoc( szValue, true );

  01429	6a 01		 push	 1
  0142b	8b 4d 10	 mov	 ecx, DWORD PTR _szValue$[ebp]
  0142e	51		 push	 ecx
  0142f	8d 55 c8	 lea	 edx, DWORD PTR $T199165[ebp]
  01432	52		 push	 edx
  01433	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  01436	e8 00 00 00 00	 call	 ?x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z ; CMarkup::x_TextToDoc
  0143b	89 45 b8	 mov	 DWORD PTR tv93[ebp], eax
  0143e	8b 45 b8	 mov	 eax, DWORD PTR tv93[ebp]
  01441	89 45 b4	 mov	 DWORD PTR tv192[ebp], eax
  01444	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01448	8b 4d b4	 mov	 ecx, DWORD PTR tv192[ebp]
  0144b	51		 push	 ecx
  0144c	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  0144f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  01455	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01459	8d 4d c8	 lea	 ecx, DWORD PTR $T199165[ebp]
  0145c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 636  : 		nInsertAt = token.nL;

  01462	8b 55 e0	 mov	 edx, DWORD PTR _token$[ebp]
  01465	89 55 d8	 mov	 DWORD PTR _nInsertAt$[ebp], edx

; 637  : 		nReplace = token.nR-token.nL+1;

  01468	8b 45 e4	 mov	 eax, DWORD PTR _token$[ebp+4]
  0146b	2b 45 e0	 sub	 eax, DWORD PTR _token$[ebp]
  0146e	83 c0 01	 add	 eax, 1
  01471	89 45 dc	 mov	 DWORD PTR _nReplace$[ebp], eax

; 638  : 	}
; 639  : 	else

  01474	e9 97 00 00 00	 jmp	 $L197983
$L197981:

; 640  : 	{
; 641  : 		// Insert string name value pair
; 642  : 		CString csFormat;

  01479	8d 4d cc	 lea	 ecx, DWORD PTR _csFormat$197984[ebp]
  0147c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  01482	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 643  : 		csFormat = _T(" ");

  01486	68 00 00 00 00	 push	 OFFSET FLAT:$SG197985
  0148b	8d 4d cc	 lea	 ecx, DWORD PTR _csFormat$197984[ebp]
  0148e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 644  : 		csFormat += szAttrib;

  01494	8b 4d 0c	 mov	 ecx, DWORD PTR _szAttrib$[ebp]
  01497	51		 push	 ecx
  01498	8d 4d cc	 lea	 ecx, DWORD PTR _csFormat$197984[ebp]
  0149b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 645  : 		csFormat += _T("=\"");

  014a1	68 00 00 00 00	 push	 OFFSET FLAT:$SG197986
  014a6	8d 4d cc	 lea	 ecx, DWORD PTR _csFormat$197984[ebp]
  014a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 646  : 		csFormat += x_TextToDoc( szValue, true );

  014af	6a 01		 push	 1
  014b1	8b 55 10	 mov	 edx, DWORD PTR _szValue$[ebp]
  014b4	52		 push	 edx
  014b5	8d 45 c4	 lea	 eax, DWORD PTR $T199166[ebp]
  014b8	50		 push	 eax
  014b9	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  014bc	e8 00 00 00 00	 call	 ?x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z ; CMarkup::x_TextToDoc
  014c1	89 45 b0	 mov	 DWORD PTR tv145[ebp], eax
  014c4	8b 4d b0	 mov	 ecx, DWORD PTR tv145[ebp]
  014c7	89 4d ac	 mov	 DWORD PTR tv195[ebp], ecx
  014ca	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  014ce	8b 55 ac	 mov	 edx, DWORD PTR tv195[ebp]
  014d1	52		 push	 edx
  014d2	8d 4d cc	 lea	 ecx, DWORD PTR _csFormat$197984[ebp]
  014d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@D$00@1@@Z
  014db	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  014df	8d 4d c4	 lea	 ecx, DWORD PTR $T199166[ebp]
  014e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 647  : 		csFormat += _T("\"");

  014e8	68 00 00 00 00	 push	 OFFSET FLAT:$SG197991
  014ed	8d 4d cc	 lea	 ecx, DWORD PTR _csFormat$197984[ebp]
  014f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 648  : 		csInsert = csFormat;

  014f6	8d 45 cc	 lea	 eax, DWORD PTR _csFormat$197984[ebp]
  014f9	50		 push	 eax
  014fa	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  014fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 649  : 	}

  01503	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01507	8d 4d cc	 lea	 ecx, DWORD PTR _csFormat$197984[ebp]
  0150a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L197983:

; 650  : 
; 651  : 	x_DocChange( nInsertAt, nReplace, csInsert );

  01510	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  01513	51		 push	 ecx
  01514	8b 55 dc	 mov	 edx, DWORD PTR _nReplace$[ebp]
  01517	52		 push	 edx
  01518	8b 45 d8	 mov	 eax, DWORD PTR _nInsertAt$[ebp]
  0151b	50		 push	 eax
  0151c	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0151f	e8 00 00 00 00	 call	 ?x_DocChange@CMarkup@@IAEXHHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CMarkup::x_DocChange

; 652  : 	int nAdjust = csInsert.GetLength() - nReplace;

  01524	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  01527	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  0152d	2b 45 dc	 sub	 eax, DWORD PTR _nReplace$[ebp]
  01530	89 45 d4	 mov	 DWORD PTR _nAdjust$[ebp], eax

; 653  : 	m_aPos[iPos].nStartR += nAdjust;

  01533	8b 4d 08	 mov	 ecx, DWORD PTR _iPos$[ebp]
  01536	51		 push	 ecx
  01537	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0153a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0153d	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01542	83 c0 04	 add	 eax, 4
  01545	89 45 a8	 mov	 DWORD PTR tv178[ebp], eax
  01548	8b 55 a8	 mov	 edx, DWORD PTR tv178[ebp]
  0154b	8b 02		 mov	 eax, DWORD PTR [edx]
  0154d	03 45 d4	 add	 eax, DWORD PTR _nAdjust$[ebp]
  01550	8b 4d a8	 mov	 ecx, DWORD PTR tv178[ebp]
  01553	89 01		 mov	 DWORD PTR [ecx], eax

; 654  : 	m_aPos[iPos].AdjustEnd( nAdjust );

  01555	8b 55 d4	 mov	 edx, DWORD PTR _nAdjust$[ebp]
  01558	52		 push	 edx
  01559	8b 45 08	 mov	 eax, DWORD PTR _iPos$[ebp]
  0155c	50		 push	 eax
  0155d	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  01560	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01563	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01568	8b c8		 mov	 ecx, eax
  0156a	e8 00 00 00 00	 call	 ?AdjustEnd@ElemPos@CMarkup@@QAEXH@Z ; CMarkup::ElemPos::AdjustEnd

; 655  : 	x_Adjust( iPos, nAdjust );

  0156f	6a 00		 push	 0
  01571	8b 4d d4	 mov	 ecx, DWORD PTR _nAdjust$[ebp]
  01574	51		 push	 ecx
  01575	8b 55 08	 mov	 edx, DWORD PTR _iPos$[ebp]
  01578	52		 push	 edx
  01579	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0157c	e8 00 00 00 00	 call	 ?x_Adjust@CMarkup@@IAEXHH_N@Z ; CMarkup::x_Adjust

; 656  : 	MARKUP_SETDEBUGSTATE;
; 657  : 	return true;

  01581	c6 45 c3 01	 mov	 BYTE PTR $T199167[ebp], 1
  01585	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0158c	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  0158f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  01595	8a 45 c3	 mov	 al, BYTE PTR $T199167[ebp]
$L197974:

; 658  : }

  01598	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0159b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  015a2	5e		 pop	 esi
  015a3	8b e5		 mov	 esp, ebp
  015a5	5d		 pop	 ebp
  015a6	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L199168:
  00038	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  0003b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L199169:
  00041	8d 4d c8	 lea	 ecx, DWORD PTR $T199165[ebp]
  00044	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L199170:
  0004a	8d 4d cc	 lea	 ecx, DWORD PTR _csFormat$197984[ebp]
  0004d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L199171:
  00053	8d 4d c4	 lea	 ecx, DWORD PTR $T199166[ebp]
  00056	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?x_SetAttrib@CMarkup@@IAE_NHPBD0@Z:
  0005c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199173
  00061	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?x_SetAttrib@CMarkup@@IAE_NHPBD0@Z ENDP			; CMarkup::x_SetAttrib
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.h
;	COMDAT ?IsEmptyElement@ElemPos@CMarkup@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEmptyElement@ElemPos@CMarkup@@QBE_NXZ PROC NEAR	; CMarkup::ElemPos::IsEmptyElement, COMDAT
; _this$ = ecx

; 88   : 		bool IsEmptyElement() const { return (nStartR == nEndL + 1); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	83 c1 01	 add	 ecx, 1
  00010	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00013	33 c0		 xor	 eax, eax
  00015	39 4a 04	 cmp	 DWORD PTR [edx+4], ecx
  00018	0f 94 c0	 sete	 al
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?IsEmptyElement@ElemPos@CMarkup@@QBE_NXZ ENDP		; CMarkup::ElemPos::IsEmptyElement
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AdjustEnd@ElemPos@CMarkup@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?AdjustEnd@ElemPos@CMarkup@@QAEXH@Z PROC NEAR		; CMarkup::ElemPos::AdjustEnd, COMDAT
; _this$ = ecx

; 95   : 		void AdjustEnd( int n ) { nEndL+=n; nEndR+=n; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	03 4d 08	 add	 ecx, DWORD PTR _n$[ebp]
  00010	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00013	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0001c	03 4d 08	 add	 ecx, DWORD PTR _n$[ebp]
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?AdjustEnd@ElemPos@CMarkup@@QAEXH@Z ENDP		; CMarkup::ElemPos::AdjustEnd
_TEXT	ENDS
PUBLIC	__tcsncmp
PUBLIC	?x_GetData@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CMarkup::x_GetData
EXTRN	__imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z:NEAR
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.cpp
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T199182 = -16						; size = 4
_nEndCDATA$198005 = -12					; size = 4
_szDoc$198000 = -8					; size = 4
_nChar$198002 = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_iPos$ = 12						; size = 4
?x_GetData@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC NEAR ; CMarkup::x_GetData
; _this$ = ecx

; 661  : {

  015b0	55		 push	 ebp
  015b1	8b ec		 mov	 ebp, esp
  015b3	83 ec 14	 sub	 esp, 20			; 00000014H
  015b6	56		 push	 esi
  015b7	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  015ba	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T199182[ebp], 0

; 662  : 
; 663  : 	// Return a string representing data between start and end tag
; 664  : 	// Return empty string if there are any children elements
; 665  : 	if ( ! m_aPos[iPos].iElemChild && ! m_aPos[iPos].IsEmptyElement() )

  015c1	8b 45 0c	 mov	 eax, DWORD PTR _iPos$[ebp]
  015c4	50		 push	 eax
  015c5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  015c8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  015cb	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  015d0	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  015d4	0f 85 5a 01 00
	00		 jne	 $L197999
  015da	8b 4d 0c	 mov	 ecx, DWORD PTR _iPos$[ebp]
  015dd	51		 push	 ecx
  015de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  015e1	83 c1 0c	 add	 ecx, 12			; 0000000cH
  015e4	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  015e9	8b c8		 mov	 ecx, eax
  015eb	e8 00 00 00 00	 call	 ?IsEmptyElement@ElemPos@CMarkup@@QBE_NXZ ; CMarkup::ElemPos::IsEmptyElement
  015f0	0f b6 d0	 movzx	 edx, al
  015f3	85 d2		 test	 edx, edx
  015f5	0f 85 39 01 00
	00		 jne	 $L197999

; 666  : 	{
; 667  : 		// See if it is a CDATA section
; 668  : 		LPCTSTR szDoc = (LPCTSTR)m_csDoc;

  015fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  015fe	83 c1 04	 add	 ecx, 4
  01601	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  01607	89 45 f8	 mov	 DWORD PTR _szDoc$198000[ebp], eax

; 669  : 		int nChar = m_aPos[iPos].nStartR + 1;

  0160a	8b 45 0c	 mov	 eax, DWORD PTR _iPos$[ebp]
  0160d	50		 push	 eax
  0160e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01611	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01614	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01619	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0161c	83 c1 01	 add	 ecx, 1
  0161f	89 4d fc	 mov	 DWORD PTR _nChar$198002[ebp], ecx

; 670  : 		if ( x_FindAny( szDoc, nChar ) && szDoc[nChar] == _T('<')
; 671  : 				&& nChar + 11 < m_aPos[iPos].nEndL
; 672  : 				&& _tcsncmp( &szDoc[nChar], _T("<![CDATA["), 9 ) == 0 )

  01622	8d 55 fc	 lea	 edx, DWORD PTR _nChar$198002[ebp]
  01625	52		 push	 edx
  01626	8b 45 f8	 mov	 eax, DWORD PTR _szDoc$198000[ebp]
  01629	50		 push	 eax
  0162a	e8 00 00 00 00	 call	 ?x_FindAny@CMarkup@@KA_NPBDAAH@Z ; CMarkup::x_FindAny
  0162f	83 c4 08	 add	 esp, 8
  01632	0f b6 c8	 movzx	 ecx, al
  01635	85 c9		 test	 ecx, ecx
  01637	0f 84 b1 00 00
	00		 je	 $L198003
  0163d	8b 55 f8	 mov	 edx, DWORD PTR _szDoc$198000[ebp]
  01640	03 55 fc	 add	 edx, DWORD PTR _nChar$198002[ebp]
  01643	0f be 02	 movsx	 eax, BYTE PTR [edx]
  01646	83 f8 3c	 cmp	 eax, 60			; 0000003cH
  01649	0f 85 9f 00 00
	00		 jne	 $L198003
  0164f	8b 75 fc	 mov	 esi, DWORD PTR _nChar$198002[ebp]
  01652	83 c6 0b	 add	 esi, 11			; 0000000bH
  01655	8b 4d 0c	 mov	 ecx, DWORD PTR _iPos$[ebp]
  01658	51		 push	 ecx
  01659	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0165c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0165f	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01664	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  01667	0f 8d 81 00 00
	00		 jge	 $L198003
  0166d	6a 09		 push	 9
  0166f	68 00 00 00 00	 push	 OFFSET FLAT:$SG198004
  01674	8b 55 f8	 mov	 edx, DWORD PTR _szDoc$198000[ebp]
  01677	03 55 fc	 add	 edx, DWORD PTR _nChar$198002[ebp]
  0167a	52		 push	 edx
  0167b	e8 00 00 00 00	 call	 __tcsncmp
  01680	83 c4 0c	 add	 esp, 12			; 0000000cH
  01683	85 c0		 test	 eax, eax
  01685	75 67		 jne	 SHORT $L198003

; 673  : 		{
; 674  : 			nChar += 9;

  01687	8b 45 fc	 mov	 eax, DWORD PTR _nChar$198002[ebp]
  0168a	83 c0 09	 add	 eax, 9
  0168d	89 45 fc	 mov	 DWORD PTR _nChar$198002[ebp], eax

; 675  : 			int nEndCDATA = m_csDoc.Find( _T("]]>"), nChar );

  01690	8b 4d fc	 mov	 ecx, DWORD PTR _nChar$198002[ebp]
  01693	51		 push	 ecx
  01694	68 00 00 00 00	 push	 OFFSET FLAT:$SG198006
  01699	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0169c	83 c1 04	 add	 ecx, 4
  0169f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z
  016a5	89 45 f4	 mov	 DWORD PTR _nEndCDATA$198005[ebp], eax

; 676  : 			if ( nEndCDATA != -1 && nEndCDATA < m_aPos[iPos].nEndL )

  016a8	83 7d f4 ff	 cmp	 DWORD PTR _nEndCDATA$198005[ebp], -1
  016ac	74 40		 je	 SHORT $L198003
  016ae	8b 55 0c	 mov	 edx, DWORD PTR _iPos$[ebp]
  016b1	52		 push	 edx
  016b2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  016b5	83 c1 0c	 add	 ecx, 12			; 0000000cH
  016b8	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  016bd	8b 4d f4	 mov	 ecx, DWORD PTR _nEndCDATA$198005[ebp]
  016c0	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  016c3	7d 29		 jge	 SHORT $L198003

; 677  : 			{
; 678  : 				return m_csDoc.Mid( nChar, nEndCDATA - nChar );

  016c5	8b 55 f4	 mov	 edx, DWORD PTR _nEndCDATA$198005[ebp]
  016c8	2b 55 fc	 sub	 edx, DWORD PTR _nChar$198002[ebp]
  016cb	52		 push	 edx
  016cc	8b 45 fc	 mov	 eax, DWORD PTR _nChar$198002[ebp]
  016cf	50		 push	 eax
  016d0	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  016d3	51		 push	 ecx
  016d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  016d7	83 c1 04	 add	 ecx, 4
  016da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z
  016e0	8b 55 f0	 mov	 edx, DWORD PTR $T199182[ebp]
  016e3	83 ca 01	 or	 edx, 1
  016e6	89 55 f0	 mov	 DWORD PTR $T199182[ebp], edx
  016e9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  016ec	eb 60		 jmp	 SHORT $L197998
$L198003:

; 679  : 			}
; 680  : 		}
; 681  : 		return x_TextFromDoc( m_aPos[iPos].nStartR+1, m_aPos[iPos].nEndL-1 );

  016ee	8b 45 0c	 mov	 eax, DWORD PTR _iPos$[ebp]
  016f1	50		 push	 eax
  016f2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  016f5	83 c1 0c	 add	 ecx, 12			; 0000000cH
  016f8	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  016fd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01700	83 e9 01	 sub	 ecx, 1
  01703	51		 push	 ecx
  01704	8b 55 0c	 mov	 edx, DWORD PTR _iPos$[ebp]
  01707	52		 push	 edx
  01708	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0170b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0170e	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01713	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01716	83 c0 01	 add	 eax, 1
  01719	50		 push	 eax
  0171a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0171d	51		 push	 ecx
  0171e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01721	e8 00 00 00 00	 call	 ?x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z ; CMarkup::x_TextFromDoc
  01726	8b 55 f0	 mov	 edx, DWORD PTR $T199182[ebp]
  01729	83 ca 01	 or	 edx, 1
  0172c	89 55 f0	 mov	 DWORD PTR $T199182[ebp], edx
  0172f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  01732	eb 1a		 jmp	 SHORT $L197998
$L197999:

; 682  : 	}
; 683  : 	return _T("");

  01734	68 00 00 00 00	 push	 OFFSET FLAT:$SG198010
  01739	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0173c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  01742	8b 45 f0	 mov	 eax, DWORD PTR $T199182[ebp]
  01745	83 c8 01	 or	 eax, 1
  01748	89 45 f0	 mov	 DWORD PTR $T199182[ebp], eax
  0174b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L197998:

; 684  : }

  0174e	5e		 pop	 esi
  0174f	8b e5		 mov	 esp, ebp
  01751	5d		 pop	 ebp
  01752	c2 08 00	 ret	 8
?x_GetData@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; CMarkup::x_GetData
_TEXT	ENDS
EXTRN	__imp___mbsnbcmp:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\tchar.h
;	COMDAT __tcsncmp
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__n$ = 16						; size = 4
__tcsncmp PROC NEAR					; COMDAT

; 857  : __inline int _tcsncmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __n$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __s2$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __s1$[ebp]
  0000e	52		 push	 edx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsnbcmp
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
__tcsncmp ENDP
_TEXT	ENDS
PUBLIC	__tccpy
EXTRN	__imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z:NEAR
EXTRN	__imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z:NEAR
EXTRN	_strcpy:NEAR
xdata$x	SEGMENT
$T199196 DD	0ffffffffH
	DD	FLAT:$L199189
$T199194 DD	019930520H
	DD	01H
	DD	FLAT:$T199196
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ?szaReplace@?1??x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z@4PAPADA
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.cpp
_DATA	SEGMENT
?szaReplace@?1??x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z@4PAPADA DD FLAT:$SG198019 ; `CMarkup::x_TextToDoc'::`2'::szaReplace
	DD	FLAT:$SG198020
	DD	FLAT:$SG198021
	DD	FLAT:$SG198022
	DD	FLAT:$SG198023
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
tv66 = -56						; size = 4
_this$ = -52						; size = 4
$T199191 = -48						; size = 4
_pFound$ = -44						; size = 4
_csText$ = -40						; size = 4
_pSource$ = -36						; size = 4
_cSource$ = -29						; size = 1
_nLen$ = -28						; size = 4
_pFind$ = -24						; size = 4
_nDestSize$ = -20					; size = 4
_pDest$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szText$ = 12						; size = 4
_bAttrib$ = 16						; size = 1
?x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z PROC NEAR ; CMarkup::x_TextToDoc
; _this$ = ecx

; 687  : {

  01760	55		 push	 ebp
  01761	8b ec		 mov	 ebp, esp
  01763	6a ff		 push	 -1
  01765	68 00 00 00 00	 push	 __ehhandler$?x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z
  0176a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01770	50		 push	 eax
  01771	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01778	83 ec 2c	 sub	 esp, 44			; 0000002cH
  0177b	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx
  0177e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T199191[ebp], 0

; 688  : 	// Convert text as seen outside XML document to XML friendly
; 689  : 	// replacing special characters with ampersand escape codes
; 690  : 	// E.g. convert "6>7" to "6&gt;7"
; 691  : 	//
; 692  : 	// &lt;   less than
; 693  : 	// &amp;  ampersand
; 694  : 	// &gt;   greater than
; 695  : 	//
; 696  : 	// and for attributes:
; 697  : 	//
; 698  : 	// &apos; apostrophe or single quote
; 699  : 	// &quot; double quote
; 700  : 	//
; 701  : 	static _TCHAR* szaReplace[] = { _T("&lt;"),_T("&amp;"),_T("&gt;"),_T("&apos;"),_T("&quot;") };
; 702  : 	const _TCHAR* pFind = bAttrib?_T("<&>\'\""):_T("<&>");

  01785	0f b6 45 10	 movzx	 eax, BYTE PTR _bAttrib$[ebp]
  01789	85 c0		 test	 eax, eax
  0178b	74 09		 je	 SHORT $L199187
  0178d	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], OFFSET FLAT:$SG198025
  01794	eb 07		 jmp	 SHORT $L199188
$L199187:
  01796	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], OFFSET FLAT:$SG198026
$L199188:
  0179d	8b 4d c8	 mov	 ecx, DWORD PTR tv66[ebp]
  017a0	89 4d e8	 mov	 DWORD PTR _pFind$[ebp], ecx

; 703  : 	CString csText;

  017a3	8d 4d d8	 lea	 ecx, DWORD PTR _csText$[ebp]
  017a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  017ac	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 704  : 	const _TCHAR* pSource = szText;

  017b3	8b 55 0c	 mov	 edx, DWORD PTR _szText$[ebp]
  017b6	89 55 dc	 mov	 DWORD PTR _pSource$[ebp], edx

; 705  : 	int nDestSize = (int)_tcslen(pSource);

  017b9	8b 45 dc	 mov	 eax, DWORD PTR _pSource$[ebp]
  017bc	50		 push	 eax
  017bd	e8 00 00 00 00	 call	 _strlen
  017c2	83 c4 04	 add	 esp, 4
  017c5	89 45 ec	 mov	 DWORD PTR _nDestSize$[ebp], eax

; 706  : 	nDestSize += nDestSize / 10 + 7;

  017c8	8b 45 ec	 mov	 eax, DWORD PTR _nDestSize$[ebp]
  017cb	99		 cdq
  017cc	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  017d1	f7 f9		 idiv	 ecx
  017d3	8b 55 ec	 mov	 edx, DWORD PTR _nDestSize$[ebp]
  017d6	8d 44 02 07	 lea	 eax, DWORD PTR [edx+eax+7]
  017da	89 45 ec	 mov	 DWORD PTR _nDestSize$[ebp], eax

; 707  : 	_TCHAR* pDest = csText.GetBuffer(nDestSize);

  017dd	8b 4d ec	 mov	 ecx, DWORD PTR _nDestSize$[ebp]
  017e0	51		 push	 ecx
  017e1	8d 4d d8	 lea	 ecx, DWORD PTR _csText$[ebp]
  017e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  017ea	89 45 f0	 mov	 DWORD PTR _pDest$[ebp], eax

; 708  : 	int nLen = 0;

  017ed	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _nLen$[ebp], 0

; 709  : 	_TCHAR cSource = *pSource;

  017f4	8b 55 dc	 mov	 edx, DWORD PTR _pSource$[ebp]
  017f7	8a 02		 mov	 al, BYTE PTR [edx]
  017f9	88 45 e3	 mov	 BYTE PTR _cSource$[ebp], al
$L198036:

; 710  : 	_TCHAR* pFound;
; 711  : 	while ( cSource )

  017fc	0f be 4d e3	 movsx	 ecx, BYTE PTR _cSource$[ebp]
  01800	85 c9		 test	 ecx, ecx
  01802	0f 84 c5 00 00
	00		 je	 $L198037

; 712  : 	{
; 713  : 		if ( nLen > nDestSize - 6 )

  01808	8b 55 ec	 mov	 edx, DWORD PTR _nDestSize$[ebp]
  0180b	83 ea 06	 sub	 edx, 6
  0180e	39 55 e4	 cmp	 DWORD PTR _nLen$[ebp], edx
  01811	7e 25		 jle	 SHORT $L198038

; 714  : 		{
; 715  : 			csText.ReleaseBuffer(nLen);

  01813	8b 45 e4	 mov	 eax, DWORD PTR _nLen$[ebp]
  01816	50		 push	 eax
  01817	8d 4d d8	 lea	 ecx, DWORD PTR _csText$[ebp]
  0181a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z

; 716  : 			nDestSize *= 2;

  01820	8b 4d ec	 mov	 ecx, DWORD PTR _nDestSize$[ebp]
  01823	d1 e1		 shl	 ecx, 1
  01825	89 4d ec	 mov	 DWORD PTR _nDestSize$[ebp], ecx

; 717  : 			pDest = csText.GetBuffer(nDestSize);

  01828	8b 55 ec	 mov	 edx, DWORD PTR _nDestSize$[ebp]
  0182b	52		 push	 edx
  0182c	8d 4d d8	 lea	 ecx, DWORD PTR _csText$[ebp]
  0182f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  01835	89 45 f0	 mov	 DWORD PTR _pDest$[ebp], eax
$L198038:

; 718  : 		}
; 719  : 		if ( (pFound= (_TCHAR*)_tcschr(pFind,cSource)) != NULL )

  01838	0f be 45 e3	 movsx	 eax, BYTE PTR _cSource$[ebp]
  0183c	50		 push	 eax
  0183d	8b 4d e8	 mov	 ecx, DWORD PTR _pFind$[ebp]
  01840	51		 push	 ecx
  01841	e8 00 00 00 00	 call	 __tcschr
  01846	83 c4 08	 add	 esp, 8
  01849	89 45 d4	 mov	 DWORD PTR _pFound$[ebp], eax
  0184c	83 7d d4 00	 cmp	 DWORD PTR _pFound$[ebp], 0
  01850	74 37		 je	 SHORT $L198040

; 720  : 		{
; 721  : 			pFound = szaReplace[pFound-pFind];

  01852	8b 55 d4	 mov	 edx, DWORD PTR _pFound$[ebp]
  01855	2b 55 e8	 sub	 edx, DWORD PTR _pFind$[ebp]
  01858	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?szaReplace@?1??x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z@4PAPADA[edx*4]
  0185f	89 45 d4	 mov	 DWORD PTR _pFound$[ebp], eax

; 722  : 			_tcscpy(&pDest[nLen],pFound);

  01862	8b 4d d4	 mov	 ecx, DWORD PTR _pFound$[ebp]
  01865	51		 push	 ecx
  01866	8b 55 f0	 mov	 edx, DWORD PTR _pDest$[ebp]
  01869	03 55 e4	 add	 edx, DWORD PTR _nLen$[ebp]
  0186c	52		 push	 edx
  0186d	e8 00 00 00 00	 call	 _strcpy
  01872	83 c4 08	 add	 esp, 8

; 723  : 			nLen += (int)_tcslen(pFound);

  01875	8b 45 d4	 mov	 eax, DWORD PTR _pFound$[ebp]
  01878	50		 push	 eax
  01879	e8 00 00 00 00	 call	 _strlen
  0187e	83 c4 04	 add	 esp, 4
  01881	03 45 e4	 add	 eax, DWORD PTR _nLen$[ebp]
  01884	89 45 e4	 mov	 DWORD PTR _nLen$[ebp], eax

; 724  : 		}
; 725  : 		else

  01887	eb 25		 jmp	 SHORT $L198042
$L198040:

; 726  : 		{
; 727  : 			_tccpy( &pDest[nLen], pSource );

  01889	8b 4d dc	 mov	 ecx, DWORD PTR _pSource$[ebp]
  0188c	51		 push	 ecx
  0188d	8b 55 f0	 mov	 edx, DWORD PTR _pDest$[ebp]
  01890	03 55 e4	 add	 edx, DWORD PTR _nLen$[ebp]
  01893	52		 push	 edx
  01894	e8 00 00 00 00	 call	 __tccpy
  01899	83 c4 08	 add	 esp, 8

; 728  : 			nLen += (int)_tclen( pSource );

  0189c	8b 45 dc	 mov	 eax, DWORD PTR _pSource$[ebp]
  0189f	50		 push	 eax
  018a0	e8 00 00 00 00	 call	 __tclen
  018a5	83 c4 04	 add	 esp, 4
  018a8	03 45 e4	 add	 eax, DWORD PTR _nLen$[ebp]
  018ab	89 45 e4	 mov	 DWORD PTR _nLen$[ebp], eax
$L198042:

; 729  : 		}
; 730  : 		pSource += _tclen( pSource );

  018ae	8b 4d dc	 mov	 ecx, DWORD PTR _pSource$[ebp]
  018b1	51		 push	 ecx
  018b2	e8 00 00 00 00	 call	 __tclen
  018b7	83 c4 04	 add	 esp, 4
  018ba	03 45 dc	 add	 eax, DWORD PTR _pSource$[ebp]
  018bd	89 45 dc	 mov	 DWORD PTR _pSource$[ebp], eax

; 731  : 		cSource = *pSource;

  018c0	8b 55 dc	 mov	 edx, DWORD PTR _pSource$[ebp]
  018c3	8a 02		 mov	 al, BYTE PTR [edx]
  018c5	88 45 e3	 mov	 BYTE PTR _cSource$[ebp], al

; 732  : 	}

  018c8	e9 2f ff ff ff	 jmp	 $L198036
$L198037:

; 733  : 	csText.ReleaseBuffer(nLen);

  018cd	8b 4d e4	 mov	 ecx, DWORD PTR _nLen$[ebp]
  018d0	51		 push	 ecx
  018d1	8d 4d d8	 lea	 ecx, DWORD PTR _csText$[ebp]
  018d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z

; 734  : 	return csText;

  018da	8d 55 d8	 lea	 edx, DWORD PTR _csText$[ebp]
  018dd	52		 push	 edx
  018de	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  018e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  018e7	8b 45 d0	 mov	 eax, DWORD PTR $T199191[ebp]
  018ea	83 c8 01	 or	 eax, 1
  018ed	89 45 d0	 mov	 DWORD PTR $T199191[ebp], eax
  018f0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  018f7	8d 4d d8	 lea	 ecx, DWORD PTR _csText$[ebp]
  018fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  01900	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 735  : }

  01903	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01906	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0190d	8b e5		 mov	 esp, ebp
  0190f	5d		 pop	 ebp
  01910	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L199189:
  00066	8d 4d d8	 lea	 ecx, DWORD PTR _csText$[ebp]
  00069	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z:
  0006f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199194
  00074	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z ENDP ; CMarkup::x_TextToDoc
EXTRN	__imp___mbccpy:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\tchar.h
;	COMDAT __tccpy
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tccpy	PROC NEAR					; COMDAT

; 889  : __inline void _tccpy(_PC _s1,_CPC _s2) {_mbccpy((_PUC)_s1,(_CPUC)_s2); return;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __s2$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbccpy
  00011	83 c4 08	 add	 esp, 8
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
__tccpy	ENDP
_TEXT	ENDS
xdata$x	SEGMENT
$T199207 DD	0ffffffffH
	DD	FLAT:$L199200
$T199205 DD	019930520H
	DD	01H
	DD	FLAT:$T199207
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ?anCodeLen@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PAHA
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.cpp
_DATA	SEGMENT
?anCodeLen@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PAHA DD 03H ; `CMarkup::x_TextFromDoc'::`2'::anCodeLen
	DD	04H
	DD	03H
	DD	05H
	DD	05H
_DATA	ENDS
;	COMDAT ?szaCode@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PAPADA
_DATA	SEGMENT
?szaCode@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PAPADA DD FLAT:$SG198052 ; `CMarkup::x_TextFromDoc'::`2'::szaCode
	DD	FLAT:$SG198053
	DD	FLAT:$SG198054
	DD	FLAT:$SG198055
	DD	FLAT:$SG198056
_DATA	ENDS
;	COMDAT ?szSymbol@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PADA
_DATA	SEGMENT
?szSymbol@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PADA DD FLAT:$SG198061 ; `CMarkup::x_TextFromDoc'::`2'::szSymbol
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T199202 = -52						; size = 4
_nMatch$198074 = -48					; size = 4
_bCodeConverted$198073 = -44				; size = 4
_nChar$ = -40						; size = 4
_csText$ = -36						; size = 4
_nCharLen$ = -32					; size = 4
_pSource$ = -28						; size = 4
_nLen$ = -24						; size = 4
_nDestSize$ = -20					; size = 4
_pDest$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_nLeft$ = 12						; size = 4
_nRight$ = 16						; size = 4
?x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z PROC NEAR ; CMarkup::x_TextFromDoc
; _this$ = ecx

; 738  : {

  01920	55		 push	 ebp
  01921	8b ec		 mov	 ebp, esp
  01923	6a ff		 push	 -1
  01925	68 00 00 00 00	 push	 __ehhandler$?x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z
  0192a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01930	50		 push	 eax
  01931	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01938	83 ec 2c	 sub	 esp, 44			; 0000002cH
  0193b	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx
  0193e	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T199202[ebp], 0

; 739  : 	// Convert XML friendly text to text as seen outside XML document
; 740  : 	// ampersand escape codes replaced with special characters e.g. convert "6&gt;7" to "6>7"
; 741  : 	// Conveniently the result is always the same or shorter in byte length
; 742  : 	//
; 743  : 	static _TCHAR* szaCode[] = { _T("lt;"),_T("amp;"),_T("gt;"),_T("apos;"),_T("quot;") };
; 744  : 	static int anCodeLen[] = { 3,4,3,5,5 };
; 745  : 	static _TCHAR* szSymbol = _T("<&>\'\"");
; 746  : 	CString csText;

  01945	8d 4d dc	 lea	 ecx, DWORD PTR _csText$[ebp]
  01948	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0194e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 747  : 	const _TCHAR* pSource = m_csDoc;

  01955	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01958	83 c1 04	 add	 ecx, 4
  0195b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  01961	89 45 e4	 mov	 DWORD PTR _pSource$[ebp], eax

; 748  : 	int nDestSize = nRight - nLeft + 1;

  01964	8b 45 10	 mov	 eax, DWORD PTR _nRight$[ebp]
  01967	2b 45 0c	 sub	 eax, DWORD PTR _nLeft$[ebp]
  0196a	83 c0 01	 add	 eax, 1
  0196d	89 45 ec	 mov	 DWORD PTR _nDestSize$[ebp], eax

; 749  : 	_TCHAR* pDest = csText.GetBuffer(nDestSize);

  01970	8b 4d ec	 mov	 ecx, DWORD PTR _nDestSize$[ebp]
  01973	51		 push	 ecx
  01974	8d 4d dc	 lea	 ecx, DWORD PTR _csText$[ebp]
  01977	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  0197d	89 45 f0	 mov	 DWORD PTR _pDest$[ebp], eax

; 750  : 	int nLen = 0;

  01980	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _nLen$[ebp], 0

; 751  : 	int nCharLen;
; 752  : 	int nChar = nLeft;

  01987	8b 55 0c	 mov	 edx, DWORD PTR _nLeft$[ebp]
  0198a	89 55 d8	 mov	 DWORD PTR _nChar$[ebp], edx
$L198070:

; 753  : 	while ( nChar <= nRight )

  0198d	8b 45 d8	 mov	 eax, DWORD PTR _nChar$[ebp]
  01990	3b 45 10	 cmp	 eax, DWORD PTR _nRight$[ebp]
  01993	0f 8f 10 01 00
	00		 jg	 $L198071

; 754  : 	{
; 755  : 		if ( pSource[nChar] == _T('&') )

  01999	8b 4d e4	 mov	 ecx, DWORD PTR _pSource$[ebp]
  0199c	03 4d d8	 add	 ecx, DWORD PTR _nChar$[ebp]
  0199f	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  019a2	83 fa 26	 cmp	 edx, 38			; 00000026H
  019a5	0f 85 bf 00 00
	00		 jne	 $L198072

; 756  : 		{
; 757  : 			// Look for matching &code;
; 758  : 			BOOL bCodeConverted = false;

  019ab	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _bCodeConverted$198073[ebp], 0

; 759  : 			for ( int nMatch = 0; nMatch < 5; ++nMatch )

  019b2	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _nMatch$198074[ebp], 0
  019b9	eb 09		 jmp	 SHORT $L198075
$L198076:
  019bb	8b 45 d0	 mov	 eax, DWORD PTR _nMatch$198074[ebp]
  019be	83 c0 01	 add	 eax, 1
  019c1	89 45 d0	 mov	 DWORD PTR _nMatch$198074[ebp], eax
$L198075:
  019c4	83 7d d0 05	 cmp	 DWORD PTR _nMatch$198074[ebp], 5
  019c8	7d 7d		 jge	 SHORT $L198077

; 760  : 			{
; 761  : 				if ( nChar <= nRight - anCodeLen[nMatch]
; 762  : 					&& _tcsncmp(szaCode[nMatch],&pSource[nChar+1],anCodeLen[nMatch]) == 0 )

  019ca	8b 4d d0	 mov	 ecx, DWORD PTR _nMatch$198074[ebp]
  019cd	8b 55 10	 mov	 edx, DWORD PTR _nRight$[ebp]
  019d0	2b 14 8d 00 00
	00 00		 sub	 edx, DWORD PTR ?anCodeLen@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PAHA[ecx*4]
  019d7	39 55 d8	 cmp	 DWORD PTR _nChar$[ebp], edx
  019da	7f 66		 jg	 SHORT $L198078
  019dc	8b 45 d0	 mov	 eax, DWORD PTR _nMatch$198074[ebp]
  019df	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?anCodeLen@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PAHA[eax*4]
  019e6	51		 push	 ecx
  019e7	8b 55 d8	 mov	 edx, DWORD PTR _nChar$[ebp]
  019ea	8b 45 e4	 mov	 eax, DWORD PTR _pSource$[ebp]
  019ed	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  019f1	51		 push	 ecx
  019f2	8b 55 d0	 mov	 edx, DWORD PTR _nMatch$198074[ebp]
  019f5	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?szaCode@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PAPADA[edx*4]
  019fc	50		 push	 eax
  019fd	e8 00 00 00 00	 call	 __tcsncmp
  01a02	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a05	85 c0		 test	 eax, eax
  01a07	75 39		 jne	 SHORT $L198078

; 763  : 				{
; 764  : 					// Insert symbol and increment index past ampersand semi-colon
; 765  : 					pDest[nLen++] = szSymbol[nMatch];

  01a09	8b 4d f0	 mov	 ecx, DWORD PTR _pDest$[ebp]
  01a0c	03 4d e8	 add	 ecx, DWORD PTR _nLen$[ebp]
  01a0f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?szSymbol@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PADA
  01a15	03 55 d0	 add	 edx, DWORD PTR _nMatch$198074[ebp]
  01a18	8a 02		 mov	 al, BYTE PTR [edx]
  01a1a	88 01		 mov	 BYTE PTR [ecx], al
  01a1c	8b 4d e8	 mov	 ecx, DWORD PTR _nLen$[ebp]
  01a1f	83 c1 01	 add	 ecx, 1
  01a22	89 4d e8	 mov	 DWORD PTR _nLen$[ebp], ecx

; 766  : 					nChar += anCodeLen[nMatch] + 1;

  01a25	8b 55 d0	 mov	 edx, DWORD PTR _nMatch$198074[ebp]
  01a28	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?anCodeLen@?1??x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z@4PAHA[edx*4]
  01a2f	8b 4d d8	 mov	 ecx, DWORD PTR _nChar$[ebp]
  01a32	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  01a36	89 55 d8	 mov	 DWORD PTR _nChar$[ebp], edx

; 767  : 					bCodeConverted = true;

  01a39	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bCodeConverted$198073[ebp], 1

; 768  : 					break;

  01a40	eb 05		 jmp	 SHORT $L198077
$L198078:

; 769  : 				}
; 770  : 			}

  01a42	e9 74 ff ff ff	 jmp	 $L198076
$L198077:

; 771  : 
; 772  : 			// If the code is not converted, leave it as is
; 773  : 			if ( ! bCodeConverted )

  01a47	83 7d d4 00	 cmp	 DWORD PTR _bCodeConverted$198073[ebp], 0
  01a4b	75 1b		 jne	 SHORT $L198079

; 774  : 			{
; 775  : 				pDest[nLen++] = _T('&');

  01a4d	8b 45 f0	 mov	 eax, DWORD PTR _pDest$[ebp]
  01a50	03 45 e8	 add	 eax, DWORD PTR _nLen$[ebp]
  01a53	c6 00 26	 mov	 BYTE PTR [eax], 38	; 00000026H
  01a56	8b 4d e8	 mov	 ecx, DWORD PTR _nLen$[ebp]
  01a59	83 c1 01	 add	 ecx, 1
  01a5c	89 4d e8	 mov	 DWORD PTR _nLen$[ebp], ecx

; 776  : 				++nChar;

  01a5f	8b 55 d8	 mov	 edx, DWORD PTR _nChar$[ebp]
  01a62	83 c2 01	 add	 edx, 1
  01a65	89 55 d8	 mov	 DWORD PTR _nChar$[ebp], edx
$L198079:

; 777  : 			}
; 778  : 		}
; 779  : 		else // not &

  01a68	eb 3a		 jmp	 SHORT $L198080
$L198072:

; 780  : 		{
; 781  : 			nCharLen = (int)_tclen(&pSource[nChar]);

  01a6a	8b 45 e4	 mov	 eax, DWORD PTR _pSource$[ebp]
  01a6d	03 45 d8	 add	 eax, DWORD PTR _nChar$[ebp]
  01a70	50		 push	 eax
  01a71	e8 00 00 00 00	 call	 __tclen
  01a76	83 c4 04	 add	 esp, 4
  01a79	89 45 e0	 mov	 DWORD PTR _nCharLen$[ebp], eax

; 782  : 			_tccpy( &pDest[nLen], &pSource[nChar] );

  01a7c	8b 4d e4	 mov	 ecx, DWORD PTR _pSource$[ebp]
  01a7f	03 4d d8	 add	 ecx, DWORD PTR _nChar$[ebp]
  01a82	51		 push	 ecx
  01a83	8b 55 f0	 mov	 edx, DWORD PTR _pDest$[ebp]
  01a86	03 55 e8	 add	 edx, DWORD PTR _nLen$[ebp]
  01a89	52		 push	 edx
  01a8a	e8 00 00 00 00	 call	 __tccpy
  01a8f	83 c4 08	 add	 esp, 8

; 783  : 			nLen += nCharLen;

  01a92	8b 45 e8	 mov	 eax, DWORD PTR _nLen$[ebp]
  01a95	03 45 e0	 add	 eax, DWORD PTR _nCharLen$[ebp]
  01a98	89 45 e8	 mov	 DWORD PTR _nLen$[ebp], eax

; 784  : 			nChar += nCharLen;

  01a9b	8b 4d d8	 mov	 ecx, DWORD PTR _nChar$[ebp]
  01a9e	03 4d e0	 add	 ecx, DWORD PTR _nCharLen$[ebp]
  01aa1	89 4d d8	 mov	 DWORD PTR _nChar$[ebp], ecx
$L198080:

; 785  : 		}
; 786  : 	}

  01aa4	e9 e4 fe ff ff	 jmp	 $L198070
$L198071:

; 787  : 	csText.ReleaseBuffer(nLen);

  01aa9	8b 55 e8	 mov	 edx, DWORD PTR _nLen$[ebp]
  01aac	52		 push	 edx
  01aad	8d 4d dc	 lea	 ecx, DWORD PTR _csText$[ebp]
  01ab0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z

; 788  : 	return csText;

  01ab6	8d 45 dc	 lea	 eax, DWORD PTR _csText$[ebp]
  01ab9	50		 push	 eax
  01aba	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01abd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  01ac3	8b 4d cc	 mov	 ecx, DWORD PTR $T199202[ebp]
  01ac6	83 c9 01	 or	 ecx, 1
  01ac9	89 4d cc	 mov	 DWORD PTR $T199202[ebp], ecx
  01acc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01ad3	8d 4d dc	 lea	 ecx, DWORD PTR _csText$[ebp]
  01ad6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  01adc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 789  : }

  01adf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01ae2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01ae9	8b e5		 mov	 esp, ebp
  01aeb	5d		 pop	 ebp
  01aec	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L199200:
  00079	8d 4d dc	 lea	 ecx, DWORD PTR _csText$[ebp]
  0007c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z:
  00082	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199205
  00087	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?x_TextFromDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z ENDP ; CMarkup::x_TextFromDoc
EXTRN	_memcpy:NEAR
EXTRN	__imp__memmove:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv84 = -48						; size = 4
tv85 = -44						; size = 4
tv79 = -40						; size = 4
tv74 = -36						; size = 4
tv75 = -32						; size = 4
tv71 = -28						; size = 4
_this$ = -24						; size = 4
_nDocLength$ = -20					; size = 4
_nInsLength$ = -16					; size = 4
_nBufferLen$ = -12					; size = 4
_pDoc$ = -8						; size = 4
_nNewLength$ = -4					; size = 4
_nLeft$ = 8						; size = 4
_nReplace$ = 12						; size = 4
_csInsert$ = 16						; size = 4
?x_DocChange@CMarkup@@IAEXHHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; CMarkup::x_DocChange
; _this$ = ecx

; 792  : {

  01af0	55		 push	 ebp
  01af1	8b ec		 mov	 ebp, esp
  01af3	83 ec 30	 sub	 esp, 48			; 00000030H
  01af6	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 793  : 	// Insert csInsert int m_csDoc at nLeft replacing nReplace chars
; 794  : 	// Do this with only one buffer reallocation if it grows
; 795  : 	//
; 796  : 	int nDocLength = m_csDoc.GetLength();

  01af9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  01afc	83 c1 04	 add	 ecx, 4
  01aff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  01b05	89 45 ec	 mov	 DWORD PTR _nDocLength$[ebp], eax

; 797  : 	int nInsLength = csInsert.GetLength();

  01b08	8b 4d 10	 mov	 ecx, DWORD PTR _csInsert$[ebp]
  01b0b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  01b11	89 45 f0	 mov	 DWORD PTR _nInsLength$[ebp], eax

; 798  : 
; 799  : 	// Make sure nLeft and nReplace are within bounds
; 800  : 	nLeft = max( 0, min( nLeft, nDocLength ) );

  01b14	8b 45 08	 mov	 eax, DWORD PTR _nLeft$[ebp]
  01b17	3b 45 ec	 cmp	 eax, DWORD PTR _nDocLength$[ebp]
  01b1a	7d 08		 jge	 SHORT $L199209
  01b1c	8b 4d 08	 mov	 ecx, DWORD PTR _nLeft$[ebp]
  01b1f	89 4d e4	 mov	 DWORD PTR tv71[ebp], ecx
  01b22	eb 06		 jmp	 SHORT $L199210
$L199209:
  01b24	8b 55 ec	 mov	 edx, DWORD PTR _nDocLength$[ebp]
  01b27	89 55 e4	 mov	 DWORD PTR tv71[ebp], edx
$L199210:
  01b2a	83 7d e4 00	 cmp	 DWORD PTR tv71[ebp], 0
  01b2e	7d 09		 jge	 SHORT $L199213
  01b30	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
  01b37	eb 1c		 jmp	 SHORT $L199214
$L199213:
  01b39	8b 45 08	 mov	 eax, DWORD PTR _nLeft$[ebp]
  01b3c	3b 45 ec	 cmp	 eax, DWORD PTR _nDocLength$[ebp]
  01b3f	7d 08		 jge	 SHORT $L199211
  01b41	8b 4d 08	 mov	 ecx, DWORD PTR _nLeft$[ebp]
  01b44	89 4d dc	 mov	 DWORD PTR tv74[ebp], ecx
  01b47	eb 06		 jmp	 SHORT $L199212
$L199211:
  01b49	8b 55 ec	 mov	 edx, DWORD PTR _nDocLength$[ebp]
  01b4c	89 55 dc	 mov	 DWORD PTR tv74[ebp], edx
$L199212:
  01b4f	8b 45 dc	 mov	 eax, DWORD PTR tv74[ebp]
  01b52	89 45 e0	 mov	 DWORD PTR tv75[ebp], eax
$L199214:
  01b55	8b 4d e0	 mov	 ecx, DWORD PTR tv75[ebp]
  01b58	89 4d 08	 mov	 DWORD PTR _nLeft$[ebp], ecx

; 801  : 	nReplace = max( 0, min( nReplace, nDocLength-nLeft ) );

  01b5b	8b 55 ec	 mov	 edx, DWORD PTR _nDocLength$[ebp]
  01b5e	2b 55 08	 sub	 edx, DWORD PTR _nLeft$[ebp]
  01b61	39 55 0c	 cmp	 DWORD PTR _nReplace$[ebp], edx
  01b64	7d 08		 jge	 SHORT $L199215
  01b66	8b 45 0c	 mov	 eax, DWORD PTR _nReplace$[ebp]
  01b69	89 45 d8	 mov	 DWORD PTR tv79[ebp], eax
  01b6c	eb 09		 jmp	 SHORT $L199216
$L199215:
  01b6e	8b 4d ec	 mov	 ecx, DWORD PTR _nDocLength$[ebp]
  01b71	2b 4d 08	 sub	 ecx, DWORD PTR _nLeft$[ebp]
  01b74	89 4d d8	 mov	 DWORD PTR tv79[ebp], ecx
$L199216:
  01b77	83 7d d8 00	 cmp	 DWORD PTR tv79[ebp], 0
  01b7b	7d 09		 jge	 SHORT $L199219
  01b7d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  01b84	eb 22		 jmp	 SHORT $L199220
$L199219:
  01b86	8b 55 ec	 mov	 edx, DWORD PTR _nDocLength$[ebp]
  01b89	2b 55 08	 sub	 edx, DWORD PTR _nLeft$[ebp]
  01b8c	39 55 0c	 cmp	 DWORD PTR _nReplace$[ebp], edx
  01b8f	7d 08		 jge	 SHORT $L199217
  01b91	8b 45 0c	 mov	 eax, DWORD PTR _nReplace$[ebp]
  01b94	89 45 d0	 mov	 DWORD PTR tv84[ebp], eax
  01b97	eb 09		 jmp	 SHORT $L199218
$L199217:
  01b99	8b 4d ec	 mov	 ecx, DWORD PTR _nDocLength$[ebp]
  01b9c	2b 4d 08	 sub	 ecx, DWORD PTR _nLeft$[ebp]
  01b9f	89 4d d0	 mov	 DWORD PTR tv84[ebp], ecx
$L199218:
  01ba2	8b 55 d0	 mov	 edx, DWORD PTR tv84[ebp]
  01ba5	89 55 d4	 mov	 DWORD PTR tv85[ebp], edx
$L199220:
  01ba8	8b 45 d4	 mov	 eax, DWORD PTR tv85[ebp]
  01bab	89 45 0c	 mov	 DWORD PTR _nReplace$[ebp], eax

; 802  : 
; 803  : 	// Get pointer to buffer with enough room
; 804  : 	int nNewLength = nInsLength + nDocLength - nReplace;

  01bae	8b 4d f0	 mov	 ecx, DWORD PTR _nInsLength$[ebp]
  01bb1	03 4d ec	 add	 ecx, DWORD PTR _nDocLength$[ebp]
  01bb4	2b 4d 0c	 sub	 ecx, DWORD PTR _nReplace$[ebp]
  01bb7	89 4d fc	 mov	 DWORD PTR _nNewLength$[ebp], ecx

; 805  : 	int nBufferLen = nNewLength;

  01bba	8b 55 fc	 mov	 edx, DWORD PTR _nNewLength$[ebp]
  01bbd	89 55 f4	 mov	 DWORD PTR _nBufferLen$[ebp], edx

; 806  : 	_TCHAR* pDoc = m_csDoc.GetBuffer( nBufferLen );

  01bc0	8b 45 f4	 mov	 eax, DWORD PTR _nBufferLen$[ebp]
  01bc3	50		 push	 eax
  01bc4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  01bc7	83 c1 04	 add	 ecx, 4
  01bca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  01bd0	89 45 f8	 mov	 DWORD PTR _pDoc$[ebp], eax

; 807  : 
; 808  : 	// Move part of old doc that goes after insert
; 809  : 	if ( nLeft+nReplace < nDocLength )

  01bd3	8b 4d 08	 mov	 ecx, DWORD PTR _nLeft$[ebp]
  01bd6	03 4d 0c	 add	 ecx, DWORD PTR _nReplace$[ebp]
  01bd9	3b 4d ec	 cmp	 ecx, DWORD PTR _nDocLength$[ebp]
  01bdc	7d 27		 jge	 SHORT $L198093

; 810  : 		memmove( &pDoc[nLeft+nInsLength], &pDoc[nLeft+nReplace], (nDocLength-nLeft-nReplace)*sizeof(_TCHAR) );

  01bde	8b 55 ec	 mov	 edx, DWORD PTR _nDocLength$[ebp]
  01be1	2b 55 08	 sub	 edx, DWORD PTR _nLeft$[ebp]
  01be4	2b 55 0c	 sub	 edx, DWORD PTR _nReplace$[ebp]
  01be7	52		 push	 edx
  01be8	8b 45 08	 mov	 eax, DWORD PTR _nLeft$[ebp]
  01beb	03 45 0c	 add	 eax, DWORD PTR _nReplace$[ebp]
  01bee	03 45 f8	 add	 eax, DWORD PTR _pDoc$[ebp]
  01bf1	50		 push	 eax
  01bf2	8b 4d 08	 mov	 ecx, DWORD PTR _nLeft$[ebp]
  01bf5	03 4d f0	 add	 ecx, DWORD PTR _nInsLength$[ebp]
  01bf8	03 4d f8	 add	 ecx, DWORD PTR _pDoc$[ebp]
  01bfb	51		 push	 ecx
  01bfc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  01c02	83 c4 0c	 add	 esp, 12			; 0000000cH
$L198093:

; 811  : 
; 812  : 	// Copy insert
; 813  : 	memcpy( &pDoc[nLeft], csInsert, nInsLength*sizeof(_TCHAR) );

  01c05	8b 55 f0	 mov	 edx, DWORD PTR _nInsLength$[ebp]
  01c08	52		 push	 edx
  01c09	8b 4d 10	 mov	 ecx, DWORD PTR _csInsert$[ebp]
  01c0c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  01c12	50		 push	 eax
  01c13	8b 45 f8	 mov	 eax, DWORD PTR _pDoc$[ebp]
  01c16	03 45 08	 add	 eax, DWORD PTR _nLeft$[ebp]
  01c19	50		 push	 eax
  01c1a	e8 00 00 00 00	 call	 _memcpy
  01c1f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 814  : 
; 815  : 	// Release
; 816  : 	m_csDoc.ReleaseBuffer( nNewLength );

  01c22	8b 4d fc	 mov	 ecx, DWORD PTR _nNewLength$[ebp]
  01c25	51		 push	 ecx
  01c26	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  01c29	83 c1 04	 add	 ecx, 4
  01c2c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z

; 817  : }

  01c32	8b e5		 mov	 esp, ebp
  01c34	5d		 pop	 ebp
  01c35	c2 0c 00	 ret	 12			; 0000000cH
?x_DocChange@CMarkup@@IAEXHHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CMarkup::x_DocChange
_TEXT	ENDS
PUBLIC	?AdjustStart@ElemPos@CMarkup@@QAEXH@Z		; CMarkup::ElemPos::AdjustStart
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -16						; size = 4
_bPosTop$198107 = -9					; size = 1
_iPosTop$ = -8						; size = 4
_bPosFirst$ = -1					; size = 1
_iPos$ = 8						; size = 4
_nShift$ = 12						; size = 4
_bAfterPos$ = 16					; size = 1
?x_Adjust@CMarkup@@IAEXHH_N@Z PROC NEAR			; CMarkup::x_Adjust
; _this$ = ecx

; 820  : {

  01c40	55		 push	 ebp
  01c41	8b ec		 mov	 ebp, esp
  01c43	83 ec 10	 sub	 esp, 16			; 00000010H
  01c46	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 821  : 	// Loop through affected elements and adjust indexes
; 822  : 	// Algorithm:
; 823  : 	// 1. update children unless bAfterPos
; 824  : 	//    (if no children or bAfterPos is true, end tag of iPos not affected)
; 825  : 	// 2. update next siblings and their children
; 826  : 	// 3. go up until there is a next sibling of a parent and update end tags
; 827  : 	// 4. step 2
; 828  : 	int iPosTop = m_aPos[iPos].iElemParent;

  01c49	8b 45 08	 mov	 eax, DWORD PTR _iPos$[ebp]
  01c4c	50		 push	 eax
  01c4d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01c50	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01c53	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01c58	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01c5b	89 4d f8	 mov	 DWORD PTR _iPosTop$[ebp], ecx

; 829  : 	bool bPosFirst = bAfterPos; // mark as first to skip its children

  01c5e	8a 55 10	 mov	 dl, BYTE PTR _bAfterPos$[ebp]
  01c61	88 55 ff	 mov	 BYTE PTR _bPosFirst$[ebp], dl
$L198105:

; 830  : 	while ( iPos )

  01c64	83 7d 08 00	 cmp	 DWORD PTR _iPos$[ebp], 0
  01c68	0f 84 23 01 00
	00		 je	 $L198101

; 831  : 	{
; 832  : 		// Were we at containing parent of affected position?
; 833  : 		bool bPosTop = false;

  01c6e	c6 45 f7 00	 mov	 BYTE PTR _bPosTop$198107[ebp], 0

; 834  : 		if ( iPos == iPosTop )

  01c72	8b 45 08	 mov	 eax, DWORD PTR _iPos$[ebp]
  01c75	3b 45 f8	 cmp	 eax, DWORD PTR _iPosTop$[ebp]
  01c78	75 19		 jne	 SHORT $L198108

; 835  : 		{
; 836  : 			// Move iPosTop up one towards root
; 837  : 			iPosTop = m_aPos[iPos].iElemParent;

  01c7a	8b 4d 08	 mov	 ecx, DWORD PTR _iPos$[ebp]
  01c7d	51		 push	 ecx
  01c7e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01c81	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01c84	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01c89	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  01c8c	89 55 f8	 mov	 DWORD PTR _iPosTop$[ebp], edx

; 838  : 			bPosTop = true;

  01c8f	c6 45 f7 01	 mov	 BYTE PTR _bPosTop$198107[ebp], 1
$L198108:

; 839  : 		}
; 840  : 
; 841  : 		// Traverse to the next update position
; 842  : 		if ( ! bPosTop && ! bPosFirst && m_aPos[iPos].iElemChild )

  01c93	0f b6 45 f7	 movzx	 eax, BYTE PTR _bPosTop$198107[ebp]
  01c97	85 c0		 test	 eax, eax
  01c99	75 34		 jne	 SHORT $L198109
  01c9b	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bPosFirst$[ebp]
  01c9f	85 c9		 test	 ecx, ecx
  01ca1	75 2c		 jne	 SHORT $L198109
  01ca3	8b 55 08	 mov	 edx, DWORD PTR _iPos$[ebp]
  01ca6	52		 push	 edx
  01ca7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01caa	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01cad	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01cb2	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  01cb6	74 17		 je	 SHORT $L198109

; 843  : 		{
; 844  : 			// Depth first
; 845  : 			iPos = m_aPos[iPos].iElemChild;

  01cb8	8b 45 08	 mov	 eax, DWORD PTR _iPos$[ebp]
  01cbb	50		 push	 eax
  01cbc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01cbf	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01cc2	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01cc7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01cca	89 4d 08	 mov	 DWORD PTR _iPos$[ebp], ecx

; 846  : 		}
; 847  : 		else if ( m_aPos[iPos].iElemNext )

  01ccd	eb 7d		 jmp	 SHORT $L198110
$L198109:
  01ccf	8b 55 08	 mov	 edx, DWORD PTR _iPos$[ebp]
  01cd2	52		 push	 edx
  01cd3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01cd6	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01cd9	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01cde	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  01ce2	74 17		 je	 SHORT $L198114

; 848  : 		{
; 849  : 			iPos = m_aPos[iPos].iElemNext;

  01ce4	8b 45 08	 mov	 eax, DWORD PTR _iPos$[ebp]
  01ce7	50		 push	 eax
  01ce8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01ceb	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01cee	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01cf3	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  01cf6	89 4d 08	 mov	 DWORD PTR _iPos$[ebp], ecx

; 850  : 		}
; 851  : 		else

  01cf9	eb 51		 jmp	 SHORT $L198110
$L198114:

; 852  : 		{
; 853  : 			// Look for next sibling of a parent of iPos
; 854  : 			// When going back up, parents have already been done except iPosTop
; 855  : 			while ( (iPos=m_aPos[iPos].iElemParent) != 0 && iPos != iPosTop )

  01cfb	8b 55 08	 mov	 edx, DWORD PTR _iPos$[ebp]
  01cfe	52		 push	 edx
  01cff	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01d02	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01d05	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01d0a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  01d0d	89 45 08	 mov	 DWORD PTR _iPos$[ebp], eax
  01d10	83 7d 08 00	 cmp	 DWORD PTR _iPos$[ebp], 0
  01d14	74 36		 je	 SHORT $L198110
  01d16	8b 4d 08	 mov	 ecx, DWORD PTR _iPos$[ebp]
  01d19	3b 4d f8	 cmp	 ecx, DWORD PTR _iPosTop$[ebp]
  01d1c	74 2e		 je	 SHORT $L198110

; 856  : 				if ( m_aPos[iPos].iElemNext )

  01d1e	8b 55 08	 mov	 edx, DWORD PTR _iPos$[ebp]
  01d21	52		 push	 edx
  01d22	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01d25	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01d28	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01d2d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  01d31	74 17		 je	 SHORT $L198116

; 857  : 				{
; 858  : 					iPos = m_aPos[iPos].iElemNext;

  01d33	8b 45 08	 mov	 eax, DWORD PTR _iPos$[ebp]
  01d36	50		 push	 eax
  01d37	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01d3a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01d3d	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01d42	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  01d45	89 4d 08	 mov	 DWORD PTR _iPos$[ebp], ecx

; 859  : 					break;

  01d48	eb 02		 jmp	 SHORT $L198110
$L198116:

; 860  : 				}
; 861  : 		}

  01d4a	eb af		 jmp	 SHORT $L198114
$L198110:

; 862  : 		bPosFirst = false;

  01d4c	c6 45 ff 00	 mov	 BYTE PTR _bPosFirst$[ebp], 0

; 863  : 
; 864  : 		// Shift indexes at iPos
; 865  : 		if ( iPos != iPosTop )

  01d50	8b 55 08	 mov	 edx, DWORD PTR _iPos$[ebp]
  01d53	3b 55 f8	 cmp	 edx, DWORD PTR _iPosTop$[ebp]
  01d56	74 1a		 je	 SHORT $L198117

; 866  : 			m_aPos[iPos].AdjustStart( nShift );

  01d58	8b 45 0c	 mov	 eax, DWORD PTR _nShift$[ebp]
  01d5b	50		 push	 eax
  01d5c	8b 4d 08	 mov	 ecx, DWORD PTR _iPos$[ebp]
  01d5f	51		 push	 ecx
  01d60	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01d63	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01d66	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01d6b	8b c8		 mov	 ecx, eax
  01d6d	e8 00 00 00 00	 call	 ?AdjustStart@ElemPos@CMarkup@@QAEXH@Z ; CMarkup::ElemPos::AdjustStart
$L198117:

; 867  : 		m_aPos[iPos].AdjustEnd( nShift );

  01d72	8b 55 0c	 mov	 edx, DWORD PTR _nShift$[ebp]
  01d75	52		 push	 edx
  01d76	8b 45 08	 mov	 eax, DWORD PTR _iPos$[ebp]
  01d79	50		 push	 eax
  01d7a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01d7d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01d80	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01d85	8b c8		 mov	 ecx, eax
  01d87	e8 00 00 00 00	 call	 ?AdjustEnd@ElemPos@CMarkup@@QAEXH@Z ; CMarkup::ElemPos::AdjustEnd

; 868  : 	}

  01d8c	e9 d3 fe ff ff	 jmp	 $L198105
$L198101:

; 869  : }

  01d91	8b e5		 mov	 esp, ebp
  01d93	5d		 pop	 ebp
  01d94	c2 0c 00	 ret	 12			; 0000000cH
?x_Adjust@CMarkup@@IAEXHH_N@Z ENDP			; CMarkup::x_Adjust
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.h
_TEXT	ENDS
;	COMDAT ?AdjustStart@ElemPos@CMarkup@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?AdjustStart@ElemPos@CMarkup@@QAEXH@Z PROC NEAR		; CMarkup::ElemPos::AdjustStart, COMDAT
; _this$ = ecx

; 94   : 		void AdjustStart( int n ) { nStartL+=n; nStartR+=n; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	03 4d 08	 add	 ecx, DWORD PTR _n$[ebp]
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	03 4d 08	 add	 ecx, DWORD PTR _n$[ebp]
  0001d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00020	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?AdjustStart@ElemPos@CMarkup@@QAEXH@Z ENDP		; CMarkup::ElemPos::AdjustStart
_TEXT	ENDS
PUBLIC	?x_LocateNew@CMarkup@@IAEXHAAH0HH@Z		; CMarkup::x_LocateNew
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.cpp
_TEXT	SEGMENT
_this$ = -40						; size = 4
_iPosLast$198163 = -36					; size = 4
_iPosNext$198164 = -32					; size = 4
_iPosPrev$198154 = -28					; size = 4
_szDoc$198146 = -24					; size = 4
_nChar$198148 = -20					; size = 4
_nStartL$ = -16						; size = 4
_bInsert$ = -9						; size = 1
_iPosBefore$ = -8					; size = 4
_bHonorWhitespace$ = -1					; size = 1
_iPosParent$ = 8					; size = 4
_iPosRel$ = 12						; size = 4
_nOffset$ = 16						; size = 4
_nLength$ = 20						; size = 4
_nFlags$ = 24						; size = 4
?x_LocateNew@CMarkup@@IAEXHAAH0HH@Z PROC NEAR		; CMarkup::x_LocateNew
; _this$ = ecx

; 872  : {

  01da0	55		 push	 ebp
  01da1	8b ec		 mov	 ebp, esp
  01da3	83 ec 28	 sub	 esp, 40			; 00000028H
  01da6	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 873  : 	// Determine where to insert new element or node
; 874  : 	//
; 875  : 	bool bInsert = (nFlags&1)?true:false;

  01da9	8b 45 18	 mov	 eax, DWORD PTR _nFlags$[ebp]
  01dac	83 e0 01	 and	 eax, 1
  01daf	0f 95 c1	 setne	 cl
  01db2	88 4d f7	 mov	 BYTE PTR _bInsert$[ebp], cl

; 876  : 	bool bHonorWhitespace = (nFlags&2)?true:false;

  01db5	8b 55 18	 mov	 edx, DWORD PTR _nFlags$[ebp]
  01db8	83 e2 02	 and	 edx, 2
  01dbb	0f 95 c0	 setne	 al
  01dbe	88 45 ff	 mov	 BYTE PTR _bHonorWhitespace$[ebp], al

; 877  : 
; 878  : 	int nStartL;
; 879  : 	if ( nLength )

  01dc1	83 7d 14 00	 cmp	 DWORD PTR _nLength$[ebp], 0
  01dc5	74 22		 je	 SHORT $L198129

; 880  : 	{
; 881  : 		// Located at a non-element node
; 882  : 		if ( bInsert )

  01dc7	0f b6 4d f7	 movzx	 ecx, BYTE PTR _bInsert$[ebp]
  01dcb	85 c9		 test	 ecx, ecx
  01dcd	74 0a		 je	 SHORT $L198130

; 883  : 			nStartL = nOffset;

  01dcf	8b 55 10	 mov	 edx, DWORD PTR _nOffset$[ebp]
  01dd2	8b 02		 mov	 eax, DWORD PTR [edx]
  01dd4	89 45 f0	 mov	 DWORD PTR _nStartL$[ebp], eax

; 884  : 		else

  01dd7	eb 0b		 jmp	 SHORT $L198131
$L198130:

; 885  : 			nStartL = nOffset + nLength;

  01dd9	8b 4d 10	 mov	 ecx, DWORD PTR _nOffset$[ebp]
  01ddc	8b 11		 mov	 edx, DWORD PTR [ecx]
  01dde	03 55 14	 add	 edx, DWORD PTR _nLength$[ebp]
  01de1	89 55 f0	 mov	 DWORD PTR _nStartL$[ebp], edx
$L198131:

; 886  : 	}
; 887  : 	else if ( iPosRel )

  01de4	e9 da 00 00 00	 jmp	 $L198132
$L198129:
  01de9	8b 45 0c	 mov	 eax, DWORD PTR _iPosRel$[ebp]
  01dec	83 38 00	 cmp	 DWORD PTR [eax], 0
  01def	74 3f		 je	 SHORT $L198133

; 888  : 	{
; 889  : 		// Located at an element
; 890  : 		if ( bInsert ) // precede iPosRel

  01df1	0f b6 4d f7	 movzx	 ecx, BYTE PTR _bInsert$[ebp]
  01df5	85 c9		 test	 ecx, ecx
  01df7	74 18		 je	 SHORT $L198134

; 891  : 			nStartL = m_aPos[iPosRel].nStartL;

  01df9	8b 55 0c	 mov	 edx, DWORD PTR _iPosRel$[ebp]
  01dfc	8b 02		 mov	 eax, DWORD PTR [edx]
  01dfe	50		 push	 eax
  01dff	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01e02	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01e05	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01e0a	8b 08		 mov	 ecx, DWORD PTR [eax]
  01e0c	89 4d f0	 mov	 DWORD PTR _nStartL$[ebp], ecx

; 892  : 		else // follow iPosRel

  01e0f	eb 1a		 jmp	 SHORT $L198135
$L198134:

; 893  : 			nStartL = m_aPos[iPosRel].nEndR + 1;

  01e11	8b 55 0c	 mov	 edx, DWORD PTR _iPosRel$[ebp]
  01e14	8b 02		 mov	 eax, DWORD PTR [edx]
  01e16	50		 push	 eax
  01e17	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01e1a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01e1d	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01e22	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01e25	83 c1 01	 add	 ecx, 1
  01e28	89 4d f0	 mov	 DWORD PTR _nStartL$[ebp], ecx
$L198135:

; 894  : 	}
; 895  : 	else if ( ! iPosParent )

  01e2b	e9 93 00 00 00	 jmp	 $L198132
$L198133:
  01e30	83 7d 08 00	 cmp	 DWORD PTR _iPosParent$[ebp], 0
  01e34	75 22		 jne	 SHORT $L198137

; 896  : 	{
; 897  : 		// Outside of all elements
; 898  : 		if ( bInsert )

  01e36	0f b6 55 f7	 movzx	 edx, BYTE PTR _bInsert$[ebp]
  01e3a	85 d2		 test	 edx, edx
  01e3c	74 09		 je	 SHORT $L198138

; 899  : 			nStartL = 0;

  01e3e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _nStartL$[ebp], 0

; 900  : 		else

  01e45	eb 0f		 jmp	 SHORT $L198139
$L198138:

; 901  : 			nStartL = m_csDoc.GetLength();

  01e47	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01e4a	83 c1 04	 add	 ecx, 4
  01e4d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  01e53	89 45 f0	 mov	 DWORD PTR _nStartL$[ebp], eax
$L198139:

; 902  : 	}
; 903  : 	else if ( m_aPos[iPosParent].IsEmptyElement() )

  01e56	eb 6b		 jmp	 SHORT $L198132
$L198137:
  01e58	8b 45 08	 mov	 eax, DWORD PTR _iPosParent$[ebp]
  01e5b	50		 push	 eax
  01e5c	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01e5f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01e62	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01e67	8b c8		 mov	 ecx, eax
  01e69	e8 00 00 00 00	 call	 ?IsEmptyElement@ElemPos@CMarkup@@QBE_NXZ ; CMarkup::ElemPos::IsEmptyElement
  01e6e	0f b6 c8	 movzx	 ecx, al
  01e71	85 c9		 test	 ecx, ecx
  01e73	74 17		 je	 SHORT $L198141

; 904  : 	{
; 905  : 		// Parent has no separate end tag, so split empty element
; 906  : 		nStartL = m_aPos[iPosParent].nStartR;

  01e75	8b 55 08	 mov	 edx, DWORD PTR _iPosParent$[ebp]
  01e78	52		 push	 edx
  01e79	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01e7c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01e7f	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01e84	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01e87	89 45 f0	 mov	 DWORD PTR _nStartL$[ebp], eax

; 907  : 	}
; 908  : 	else

  01e8a	eb 37		 jmp	 SHORT $L198132
$L198141:

; 909  : 	{
; 910  : 		if ( bInsert ) // after start tag

  01e8c	0f b6 4d f7	 movzx	 ecx, BYTE PTR _bInsert$[ebp]
  01e90	85 c9		 test	 ecx, ecx
  01e92	74 1a		 je	 SHORT $L198143

; 911  : 			nStartL = m_aPos[iPosParent].nStartR + 1;

  01e94	8b 55 08	 mov	 edx, DWORD PTR _iPosParent$[ebp]
  01e97	52		 push	 edx
  01e98	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01e9b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01e9e	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01ea3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01ea6	83 c0 01	 add	 eax, 1
  01ea9	89 45 f0	 mov	 DWORD PTR _nStartL$[ebp], eax

; 912  : 		else // before end tag

  01eac	eb 15		 jmp	 SHORT $L198132
$L198143:

; 913  : 			nStartL = m_aPos[iPosParent].nEndL;

  01eae	8b 4d 08	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  01eb1	51		 push	 ecx
  01eb2	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01eb5	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01eb8	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01ebd	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  01ec0	89 55 f0	 mov	 DWORD PTR _nStartL$[ebp], edx
$L198132:

; 914  : 	}
; 915  : 
; 916  : 	// Go up to start of next node, unless its splitting an empty element
; 917  : 	if ( ! bHonorWhitespace && ! m_aPos[iPosParent].IsEmptyElement() )

  01ec3	0f b6 45 ff	 movzx	 eax, BYTE PTR _bHonorWhitespace$[ebp]
  01ec7	85 c0		 test	 eax, eax
  01ec9	75 5d		 jne	 SHORT $L198145
  01ecb	8b 4d 08	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  01ece	51		 push	 ecx
  01ecf	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01ed2	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01ed5	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01eda	8b c8		 mov	 ecx, eax
  01edc	e8 00 00 00 00	 call	 ?IsEmptyElement@ElemPos@CMarkup@@QBE_NXZ ; CMarkup::ElemPos::IsEmptyElement
  01ee1	0f b6 d0	 movzx	 edx, al
  01ee4	85 d2		 test	 edx, edx
  01ee6	75 40		 jne	 SHORT $L198145

; 918  : 	{
; 919  : 		LPCTSTR szDoc = (LPCTSTR)m_csDoc;

  01ee8	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01eeb	83 c1 04	 add	 ecx, 4
  01eee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  01ef4	89 45 e8	 mov	 DWORD PTR _szDoc$198146[ebp], eax

; 920  : 		int nChar = nStartL;

  01ef7	8b 45 f0	 mov	 eax, DWORD PTR _nStartL$[ebp]
  01efa	89 45 ec	 mov	 DWORD PTR _nChar$198148[ebp], eax

; 921  : 		if ( ! x_FindAny(szDoc,nChar) || szDoc[nChar] == _T('<') )

  01efd	8d 4d ec	 lea	 ecx, DWORD PTR _nChar$198148[ebp]
  01f00	51		 push	 ecx
  01f01	8b 55 e8	 mov	 edx, DWORD PTR _szDoc$198146[ebp]
  01f04	52		 push	 edx
  01f05	e8 00 00 00 00	 call	 ?x_FindAny@CMarkup@@KA_NPBDAAH@Z ; CMarkup::x_FindAny
  01f0a	83 c4 08	 add	 esp, 8
  01f0d	0f b6 c0	 movzx	 eax, al
  01f10	85 c0		 test	 eax, eax
  01f12	74 0e		 je	 SHORT $L198150
  01f14	8b 4d e8	 mov	 ecx, DWORD PTR _szDoc$198146[ebp]
  01f17	03 4d ec	 add	 ecx, DWORD PTR _nChar$198148[ebp]
  01f1a	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  01f1d	83 fa 3c	 cmp	 edx, 60			; 0000003cH
  01f20	75 06		 jne	 SHORT $L198145
$L198150:

; 922  : 			nStartL = nChar;

  01f22	8b 45 ec	 mov	 eax, DWORD PTR _nChar$198148[ebp]
  01f25	89 45 f0	 mov	 DWORD PTR _nStartL$[ebp], eax
$L198145:

; 923  : 	}
; 924  : 
; 925  : 	// Determine iPosBefore
; 926  : 	int iPosBefore = 0;

  01f28	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iPosBefore$[ebp], 0

; 927  : 	if ( iPosRel )

  01f2f	8b 4d 0c	 mov	 ecx, DWORD PTR _iPosRel$[ebp]
  01f32	83 39 00	 cmp	 DWORD PTR [ecx], 0
  01f35	74 69		 je	 SHORT $L198152

; 928  : 	{
; 929  : 		if ( bInsert )

  01f37	0f b6 55 f7	 movzx	 edx, BYTE PTR _bInsert$[ebp]
  01f3b	85 d2		 test	 edx, edx
  01f3d	74 57		 je	 SHORT $L198153

; 930  : 		{
; 931  : 			// Is iPosRel past first sibling?
; 932  : 			int iPosPrev = m_aPos[iPosParent].iElemChild;

  01f3f	8b 45 08	 mov	 eax, DWORD PTR _iPosParent$[ebp]
  01f42	50		 push	 eax
  01f43	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f46	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01f49	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01f4e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01f51	89 4d e4	 mov	 DWORD PTR _iPosPrev$198154[ebp], ecx

; 933  : 			if ( iPosPrev != iPosRel )

  01f54	8b 55 0c	 mov	 edx, DWORD PTR _iPosRel$[ebp]
  01f57	8b 45 e4	 mov	 eax, DWORD PTR _iPosPrev$198154[ebp]
  01f5a	3b 02		 cmp	 eax, DWORD PTR [edx]
  01f5c	74 36		 je	 SHORT $L198155
$L198157:

; 934  : 			{
; 935  : 				// Find previous sibling of iPosRel
; 936  : 				while ( m_aPos[iPosPrev].iElemNext != iPosRel )

  01f5e	8b 4d e4	 mov	 ecx, DWORD PTR _iPosPrev$198154[ebp]
  01f61	51		 push	 ecx
  01f62	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f65	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01f68	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01f6d	8b 55 0c	 mov	 edx, DWORD PTR _iPosRel$[ebp]
  01f70	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  01f73	3b 02		 cmp	 eax, DWORD PTR [edx]
  01f75	74 17		 je	 SHORT $L198158

; 937  : 					iPosPrev = m_aPos[iPosPrev].iElemNext;

  01f77	8b 4d e4	 mov	 ecx, DWORD PTR _iPosPrev$198154[ebp]
  01f7a	51		 push	 ecx
  01f7b	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f7e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01f81	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01f86	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  01f89	89 55 e4	 mov	 DWORD PTR _iPosPrev$198154[ebp], edx
  01f8c	eb d0		 jmp	 SHORT $L198157
$L198158:

; 938  : 				iPosBefore = iPosPrev;

  01f8e	8b 45 e4	 mov	 eax, DWORD PTR _iPosPrev$198154[ebp]
  01f91	89 45 f8	 mov	 DWORD PTR _iPosBefore$[ebp], eax
$L198155:

; 939  : 			}
; 940  : 		}
; 941  : 		else

  01f94	eb 08		 jmp	 SHORT $L198159
$L198153:

; 942  : 		{
; 943  : 			iPosBefore = iPosRel;

  01f96	8b 4d 0c	 mov	 ecx, DWORD PTR _iPosRel$[ebp]
  01f99	8b 11		 mov	 edx, DWORD PTR [ecx]
  01f9b	89 55 f8	 mov	 DWORD PTR _iPosBefore$[ebp], edx
$L198159:

; 944  : 		}
; 945  : 	}
; 946  : 	else if ( m_aPos[iPosParent].iElemChild )

  01f9e	eb 61		 jmp	 SHORT $L198160
$L198152:
  01fa0	8b 45 08	 mov	 eax, DWORD PTR _iPosParent$[ebp]
  01fa3	50		 push	 eax
  01fa4	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01fa7	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01faa	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01faf	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  01fb3	74 4c		 je	 SHORT $L198160

; 947  : 	{
; 948  : 		if ( ! bInsert )

  01fb5	0f b6 4d f7	 movzx	 ecx, BYTE PTR _bInsert$[ebp]
  01fb9	85 c9		 test	 ecx, ecx
  01fbb	75 44		 jne	 SHORT $L198160

; 949  : 		{
; 950  : 			// Find last element under iPosParent
; 951  : 			int iPosLast = m_aPos[iPosParent].iElemChild;

  01fbd	8b 55 08	 mov	 edx, DWORD PTR _iPosParent$[ebp]
  01fc0	52		 push	 edx
  01fc1	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01fc4	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01fc7	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01fcc	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  01fcf	89 45 dc	 mov	 DWORD PTR _iPosLast$198163[ebp], eax

; 952  : 			int iPosNext = iPosLast;

  01fd2	8b 4d dc	 mov	 ecx, DWORD PTR _iPosLast$198163[ebp]
  01fd5	89 4d e0	 mov	 DWORD PTR _iPosNext$198164[ebp], ecx
$L198166:

; 953  : 			while ( iPosNext )

  01fd8	83 7d e0 00	 cmp	 DWORD PTR _iPosNext$198164[ebp], 0
  01fdc	74 1d		 je	 SHORT $L198167

; 954  : 			{
; 955  : 				iPosLast = iPosNext;

  01fde	8b 55 e0	 mov	 edx, DWORD PTR _iPosNext$198164[ebp]
  01fe1	89 55 dc	 mov	 DWORD PTR _iPosLast$198163[ebp], edx

; 956  : 				iPosNext = m_aPos[iPosNext].iElemNext;

  01fe4	8b 45 e0	 mov	 eax, DWORD PTR _iPosNext$198164[ebp]
  01fe7	50		 push	 eax
  01fe8	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01feb	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01fee	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  01ff3	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  01ff6	89 4d e0	 mov	 DWORD PTR _iPosNext$198164[ebp], ecx

; 957  : 			}

  01ff9	eb dd		 jmp	 SHORT $L198166
$L198167:

; 958  : 			iPosBefore = iPosLast;

  01ffb	8b 55 dc	 mov	 edx, DWORD PTR _iPosLast$198163[ebp]
  01ffe	89 55 f8	 mov	 DWORD PTR _iPosBefore$[ebp], edx
$L198160:

; 959  : 		}
; 960  : 	}
; 961  : 
; 962  : 	nOffset = nStartL;

  02001	8b 45 10	 mov	 eax, DWORD PTR _nOffset$[ebp]
  02004	8b 4d f0	 mov	 ecx, DWORD PTR _nStartL$[ebp]
  02007	89 08		 mov	 DWORD PTR [eax], ecx

; 963  : 	iPosRel = iPosBefore;

  02009	8b 55 0c	 mov	 edx, DWORD PTR _iPosRel$[ebp]
  0200c	8b 45 f8	 mov	 eax, DWORD PTR _iPosBefore$[ebp]
  0200f	89 02		 mov	 DWORD PTR [edx], eax

; 964  : }

  02011	8b e5		 mov	 esp, ebp
  02013	5d		 pop	 ebp
  02014	c2 14 00	 ret	 20			; 00000014H
?x_LocateNew@CMarkup@@IAEXHAAH0HH@Z ENDP		; CMarkup::x_LocateNew
_TEXT	ENDS
PUBLIC	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z ; ATL::operator+
PUBLIC	?x_AddElem@CMarkup@@IAE_NPBD0_N1@Z		; CMarkup::x_AddElem
xdata$x	SEGMENT
$T199238 DD	0ffffffffH
	DD	FLAT:$L199230
	DD	00H
	DD	FLAT:$L199231
	DD	00H
	DD	FLAT:$L199232
	DD	02H
	DD	FLAT:$L199233
	DD	00H
	DD	FLAT:$L199234
$T199236 DD	019930520H
	DD	05H
	DD	FLAT:$T199238
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv409 = -104						; size = 4
tv321 = -100						; size = 4
tv354 = -96						; size = 4
tv344 = -92						; size = 4
tv211 = -88						; size = 4
_this$ = -84						; size = 4
$T199229 = -77						; size = 1
$T199228 = -76						; size = 4
_csFormat$198213 = -72					; size = 4
_csParentTagName$198211 = -68				; size = 4
_csValue$198202 = -64					; size = 4
_iPosParent$ = -60					; size = 4
_nLenName$ = -56					; size = 4
_iPosBefore$ = -52					; size = 4
_csInsert$ = -48					; size = 4
_nLength$ = -44						; size = 4
_bEmptyParent$ = -37					; size = 1
_nOffset$ = -36						; size = 4
_nFlags$ = -32						; size = 4
_nReplace$ = -28					; size = 4
_iPos$ = -24						; size = 4
_nLeft$ = -20						; size = 4
_nLenValue$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_szName$ = 8						; size = 4
_szValue$ = 12						; size = 4
_bInsert$ = 16						; size = 1
_bAddChild$ = 20					; size = 1
?x_AddElem@CMarkup@@IAE_NPBD0_N1@Z PROC NEAR		; CMarkup::x_AddElem
; _this$ = ecx

; 967  : {

  02020	55		 push	 ebp
  02021	8b ec		 mov	 ebp, esp
  02023	6a ff		 push	 -1
  02025	68 00 00 00 00	 push	 __ehhandler$?x_AddElem@CMarkup@@IAE_NPBD0_N1@Z
  0202a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02030	50		 push	 eax
  02031	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02038	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0203b	56		 push	 esi
  0203c	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 968  : 	if ( bAddChild )

  0203f	0f b6 45 14	 movzx	 eax, BYTE PTR _bAddChild$[ebp]
  02043	85 c0		 test	 eax, eax
  02045	74 12		 je	 SHORT $L198175

; 969  : 	{
; 970  : 		// Adding a child element under main position
; 971  : 		if ( ! m_iPos )

  02047	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0204a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0204e	75 07		 jne	 SHORT $L198176

; 972  : 			return false;

  02050	32 c0		 xor	 al, al
  02052	e9 e1 05 00 00	 jmp	 $L198174
$L198176:

; 973  : 	}
; 974  : 	else if ( m_iPosParent == 0 )

  02057	eb 3d		 jmp	 SHORT $L198177
$L198175:
  02059	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  0205c	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  02060	75 34		 jne	 SHORT $L198177

; 975  : 	{
; 976  : 		// Adding root element
; 977  : 		if ( IsWellFormed() )

  02062	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02065	e8 00 00 00 00	 call	 ?IsWellFormed@CMarkup@@QAE_NXZ ; CMarkup::IsWellFormed
  0206a	0f b6 c0	 movzx	 eax, al
  0206d	85 c0		 test	 eax, eax
  0206f	74 07		 je	 SHORT $L198179

; 978  : 			return false;

  02071	32 c0		 xor	 al, al
  02073	e9 c0 05 00 00	 jmp	 $L198174
$L198179:

; 979  : 
; 980  : 
; 981  : 		// Locate after any version and DTD
; 982  : 		m_aPos[0].nEndL = m_csDoc.GetLength();

  02078	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0207b	83 c1 04	 add	 ecx, 4
  0207e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  02084	8b f0		 mov	 esi, eax
  02086	6a 00		 push	 0
  02088	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0208b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0208e	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02093	89 70 08	 mov	 DWORD PTR [eax+8], esi
$L198177:

; 983  : 	}
; 984  : 
; 985  : 	// Locate where to add element relative to current node
; 986  : 	int iPosParent, iPosBefore, nOffset = 0, nLength = 0;

  02096	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _nOffset$[ebp], 0
  0209d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _nLength$[ebp], 0

; 987  : 	if ( bAddChild )

  020a4	0f b6 4d 14	 movzx	 ecx, BYTE PTR _bAddChild$[ebp]
  020a8	85 c9		 test	 ecx, ecx
  020aa	74 14		 je	 SHORT $L198184

; 988  : 	{
; 989  : 		iPosParent = m_iPos;

  020ac	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  020af	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  020b2	89 45 c4	 mov	 DWORD PTR _iPosParent$[ebp], eax

; 990  : 		iPosBefore = m_iPosChild;

  020b5	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  020b8	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  020bb	89 55 cc	 mov	 DWORD PTR _iPosBefore$[ebp], edx

; 991  : 	}
; 992  : 	else

  020be	eb 12		 jmp	 SHORT $L198185
$L198184:

; 993  : 	{
; 994  : 		iPosParent = m_iPosParent;

  020c0	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  020c3	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  020c6	89 4d c4	 mov	 DWORD PTR _iPosParent$[ebp], ecx

; 995  : 		iPosBefore = m_iPos;

  020c9	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  020cc	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  020cf	89 45 cc	 mov	 DWORD PTR _iPosBefore$[ebp], eax
$L198185:

; 996  : 	}
; 997  : 	int nFlags = bInsert?1:0;

  020d2	0f b6 4d 10	 movzx	 ecx, BYTE PTR _bInsert$[ebp]
  020d6	f7 d9		 neg	 ecx
  020d8	1b c9		 sbb	 ecx, ecx
  020da	f7 d9		 neg	 ecx
  020dc	89 4d e0	 mov	 DWORD PTR _nFlags$[ebp], ecx

; 998  : 	x_LocateNew( iPosParent, iPosBefore, nOffset, nLength, nFlags );

  020df	8b 55 e0	 mov	 edx, DWORD PTR _nFlags$[ebp]
  020e2	52		 push	 edx
  020e3	8b 45 d4	 mov	 eax, DWORD PTR _nLength$[ebp]
  020e6	50		 push	 eax
  020e7	8d 4d dc	 lea	 ecx, DWORD PTR _nOffset$[ebp]
  020ea	51		 push	 ecx
  020eb	8d 55 cc	 lea	 edx, DWORD PTR _iPosBefore$[ebp]
  020ee	52		 push	 edx
  020ef	8b 45 c4	 mov	 eax, DWORD PTR _iPosParent$[ebp]
  020f2	50		 push	 eax
  020f3	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  020f6	e8 00 00 00 00	 call	 ?x_LocateNew@CMarkup@@IAEXHAAH0HH@Z ; CMarkup::x_LocateNew

; 999  : 	bool bEmptyParent = m_aPos[iPosParent].IsEmptyElement();

  020fb	8b 4d c4	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  020fe	51		 push	 ecx
  020ff	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02102	83 c1 0c	 add	 ecx, 12			; 0000000cH
  02105	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0210a	8b c8		 mov	 ecx, eax
  0210c	e8 00 00 00 00	 call	 ?IsEmptyElement@ElemPos@CMarkup@@QBE_NXZ ; CMarkup::ElemPos::IsEmptyElement
  02111	88 45 db	 mov	 BYTE PTR _bEmptyParent$[ebp], al

; 1000 : 	if ( bEmptyParent || m_aPos[iPosParent].nStartR + 1 == m_aPos[iPosParent].nEndL )

  02114	0f b6 55 db	 movzx	 edx, BYTE PTR _bEmptyParent$[ebp]
  02118	85 d2		 test	 edx, edx
  0211a	75 29		 jne	 SHORT $L198189
  0211c	8b 45 c4	 mov	 eax, DWORD PTR _iPosParent$[ebp]
  0211f	50		 push	 eax
  02120	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02123	83 c1 0c	 add	 ecx, 12			; 0000000cH
  02126	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0212b	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0212e	83 c6 01	 add	 esi, 1
  02131	8b 4d c4	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  02134	51		 push	 ecx
  02135	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02138	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0213b	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02140	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  02143	75 09		 jne	 SHORT $L198188
$L198189:

; 1001 : 		nOffset += 2;

  02145	8b 55 dc	 mov	 edx, DWORD PTR _nOffset$[ebp]
  02148	83 c2 02	 add	 edx, 2
  0214b	89 55 dc	 mov	 DWORD PTR _nOffset$[ebp], edx
$L198188:

; 1002 : 
; 1003 : 	// Create element and modify positions of affected elements
; 1004 : 	// If no szValue is specified, an empty element is created
; 1005 : 	// i.e. either <NAME>value</NAME> or <NAME/>
; 1006 : 	//
; 1007 : 	int iPos = x_GetFreePos();

  0214e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02151	e8 00 00 00 00	 call	 ?x_GetFreePos@CMarkup@@IAEHXZ ; CMarkup::x_GetFreePos
  02156	89 45 e8	 mov	 DWORD PTR _iPos$[ebp], eax

; 1008 : 	m_aPos[iPos].nStartL = nOffset;

  02159	8b 45 e8	 mov	 eax, DWORD PTR _iPos$[ebp]
  0215c	50		 push	 eax
  0215d	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02160	83 c1 0c	 add	 ecx, 12			; 0000000cH
  02163	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02168	8b 4d dc	 mov	 ecx, DWORD PTR _nOffset$[ebp]
  0216b	89 08		 mov	 DWORD PTR [eax], ecx

; 1009 : 
; 1010 : 	// Set links
; 1011 : 	m_aPos[iPos].iElemParent = iPosParent;

  0216d	8b 55 e8	 mov	 edx, DWORD PTR _iPos$[ebp]
  02170	52		 push	 edx
  02171	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02174	83 c1 0c	 add	 ecx, 12			; 0000000cH
  02177	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0217c	8b 4d c4	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  0217f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1012 : 	m_aPos[iPos].iElemChild = 0;

  02182	8b 55 e8	 mov	 edx, DWORD PTR _iPos$[ebp]
  02185	52		 push	 edx
  02186	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02189	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0218c	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02191	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 1013 : 	m_aPos[iPos].iElemNext = 0;

  02198	8b 45 e8	 mov	 eax, DWORD PTR _iPos$[ebp]
  0219b	50		 push	 eax
  0219c	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0219f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  021a2	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  021a7	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 1014 : 	if ( iPosBefore )

  021ae	83 7d cc 00	 cmp	 DWORD PTR _iPosBefore$[ebp], 0
  021b2	74 3d		 je	 SHORT $L198191

; 1015 : 	{
; 1016 : 		// Link in after iPosBefore
; 1017 : 		m_aPos[iPos].iElemNext = m_aPos[iPosBefore].iElemNext;

  021b4	8b 4d cc	 mov	 ecx, DWORD PTR _iPosBefore$[ebp]
  021b7	51		 push	 ecx
  021b8	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  021bb	83 c1 0c	 add	 ecx, 12			; 0000000cH
  021be	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  021c3	8b f0		 mov	 esi, eax
  021c5	8b 55 e8	 mov	 edx, DWORD PTR _iPos$[ebp]
  021c8	52		 push	 edx
  021c9	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  021cc	83 c1 0c	 add	 ecx, 12			; 0000000cH
  021cf	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  021d4	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  021d7	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 1018 : 		m_aPos[iPosBefore].iElemNext = iPos;

  021da	8b 55 cc	 mov	 edx, DWORD PTR _iPosBefore$[ebp]
  021dd	52		 push	 edx
  021de	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  021e1	83 c1 0c	 add	 ecx, 12			; 0000000cH
  021e4	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  021e9	8b 4d e8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  021ec	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 1019 : 	}
; 1020 : 	else

  021ef	eb 3b		 jmp	 SHORT $L198192
$L198191:

; 1021 : 	{
; 1022 : 		// First child
; 1023 : 		m_aPos[iPos].iElemNext = m_aPos[iPosParent].iElemChild;

  021f1	8b 55 c4	 mov	 edx, DWORD PTR _iPosParent$[ebp]
  021f4	52		 push	 edx
  021f5	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  021f8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  021fb	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02200	8b f0		 mov	 esi, eax
  02202	8b 45 e8	 mov	 eax, DWORD PTR _iPos$[ebp]
  02205	50		 push	 eax
  02206	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02209	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0220c	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02211	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  02214	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 1024 : 		m_aPos[iPosParent].iElemChild = iPos;

  02217	8b 55 c4	 mov	 edx, DWORD PTR _iPosParent$[ebp]
  0221a	52		 push	 edx
  0221b	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0221e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  02221	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02226	8b 4d e8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  02229	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L198192:

; 1025 : 	}
; 1026 : 
; 1027 : 	// Create string for insert
; 1028 : 	CString csInsert;

  0222c	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  0222f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  02235	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1029 : 	int nLenName = (int)_tcslen(szName);

  0223c	8b 55 08	 mov	 edx, DWORD PTR _szName$[ebp]
  0223f	52		 push	 edx
  02240	e8 00 00 00 00	 call	 _strlen
  02245	83 c4 04	 add	 esp, 4
  02248	89 45 c8	 mov	 DWORD PTR _nLenName$[ebp], eax

; 1030 : 	int nLenValue = szValue? (int)_tcslen(szValue) : 0;

  0224b	83 7d 0c 00	 cmp	 DWORD PTR _szValue$[ebp], 0
  0224f	74 11		 je	 SHORT $L199226
  02251	8b 45 0c	 mov	 eax, DWORD PTR _szValue$[ebp]
  02254	50		 push	 eax
  02255	e8 00 00 00 00	 call	 _strlen
  0225a	83 c4 04	 add	 esp, 4
  0225d	89 45 a8	 mov	 DWORD PTR tv211[ebp], eax
  02260	eb 07		 jmp	 SHORT $L199227
$L199226:
  02262	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv211[ebp], 0
$L199227:
  02269	8b 4d a8	 mov	 ecx, DWORD PTR tv211[ebp]
  0226c	89 4d f0	 mov	 DWORD PTR _nLenValue$[ebp], ecx

; 1031 : 	if ( ! nLenValue )

  0226f	83 7d f0 00	 cmp	 DWORD PTR _nLenValue$[ebp], 0
  02273	0f 85 a6 00 00
	00		 jne	 $L198198

; 1032 : 	{
; 1033 : 		// <NAME/> empty element
; 1034 : 		csInsert = _T("<");

  02279	68 00 00 00 00	 push	 OFFSET FLAT:$SG198199
  0227e	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  02281	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 1035 : 		csInsert += szName;

  02287	8b 55 08	 mov	 edx, DWORD PTR _szName$[ebp]
  0228a	52		 push	 edx
  0228b	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  0228e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 1036 : 		csInsert += _T("/>\r\n");

  02294	68 00 00 00 00	 push	 OFFSET FLAT:$SG198200
  02299	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  0229c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 1037 : 		m_aPos[iPos].nStartR = m_aPos[iPos].nStartL + nLenName + 2;

  022a2	8b 45 e8	 mov	 eax, DWORD PTR _iPos$[ebp]
  022a5	50		 push	 eax
  022a6	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  022a9	83 c1 0c	 add	 ecx, 12			; 0000000cH
  022ac	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  022b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  022b3	8b 55 c8	 mov	 edx, DWORD PTR _nLenName$[ebp]
  022b6	8d 74 11 02	 lea	 esi, DWORD PTR [ecx+edx+2]
  022ba	8b 45 e8	 mov	 eax, DWORD PTR _iPos$[ebp]
  022bd	50		 push	 eax
  022be	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  022c1	83 c1 0c	 add	 ecx, 12			; 0000000cH
  022c4	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  022c9	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1038 : 		m_aPos[iPos].nEndL = m_aPos[iPos].nStartR - 1;

  022cc	8b 4d e8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  022cf	51		 push	 ecx
  022d0	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  022d3	83 c1 0c	 add	 ecx, 12			; 0000000cH
  022d6	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  022db	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  022de	83 ee 01	 sub	 esi, 1
  022e1	8b 55 e8	 mov	 edx, DWORD PTR _iPos$[ebp]
  022e4	52		 push	 edx
  022e5	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  022e8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  022eb	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  022f0	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 1039 : 		m_aPos[iPos].nEndR = m_aPos[iPos].nEndL + 1;

  022f3	8b 45 e8	 mov	 eax, DWORD PTR _iPos$[ebp]
  022f6	50		 push	 eax
  022f7	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  022fa	83 c1 0c	 add	 ecx, 12			; 0000000cH
  022fd	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02302	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  02305	83 c6 01	 add	 esi, 1
  02308	8b 4d e8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  0230b	51		 push	 ecx
  0230c	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0230f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  02312	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02317	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 1040 : 	}
; 1041 : 	else

  0231a	e9 0e 01 00 00	 jmp	 $L198201
$L198198:

; 1042 : 	{
; 1043 : 		// <NAME>value</NAME>
; 1044 : 		CString csValue = x_TextToDoc( szValue );

  0231f	6a 00		 push	 0
  02321	8b 55 0c	 mov	 edx, DWORD PTR _szValue$[ebp]
  02324	52		 push	 edx
  02325	8d 45 c0	 lea	 eax, DWORD PTR _csValue$198202[ebp]
  02328	50		 push	 eax
  02329	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0232c	e8 00 00 00 00	 call	 ?x_TextToDoc@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD_N@Z ; CMarkup::x_TextToDoc
  02331	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1045 : 		nLenValue = csValue.GetLength();

  02335	8d 4d c0	 lea	 ecx, DWORD PTR _csValue$198202[ebp]
  02338	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  0233e	89 45 f0	 mov	 DWORD PTR _nLenValue$[ebp], eax

; 1046 : 		csInsert = _T("<");

  02341	68 00 00 00 00	 push	 OFFSET FLAT:$SG198204
  02346	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  02349	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 1047 : 		csInsert += szName;

  0234f	8b 4d 08	 mov	 ecx, DWORD PTR _szName$[ebp]
  02352	51		 push	 ecx
  02353	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  02356	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 1048 : 		csInsert += _T(">");

  0235c	68 00 00 00 00	 push	 OFFSET FLAT:$SG198205
  02361	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  02364	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 1049 : 		csInsert += csValue;

  0236a	8d 55 c0	 lea	 edx, DWORD PTR _csValue$198202[ebp]
  0236d	52		 push	 edx
  0236e	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  02371	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@D$00@1@@Z

; 1050 : 		csInsert += _T("</");

  02377	68 00 00 00 00	 push	 OFFSET FLAT:$SG198206
  0237c	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  0237f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 1051 : 		csInsert += szName;

  02385	8b 45 08	 mov	 eax, DWORD PTR _szName$[ebp]
  02388	50		 push	 eax
  02389	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  0238c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 1052 : 		csInsert += _T(">\r\n");

  02392	68 00 00 00 00	 push	 OFFSET FLAT:$SG198207
  02397	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  0239a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 1053 : 		m_aPos[iPos].nStartR = m_aPos[iPos].nStartL + nLenName + 1;

  023a0	8b 4d e8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  023a3	51		 push	 ecx
  023a4	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  023a7	83 c1 0c	 add	 ecx, 12			; 0000000cH
  023aa	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  023af	8b 10		 mov	 edx, DWORD PTR [eax]
  023b1	8b 45 c8	 mov	 eax, DWORD PTR _nLenName$[ebp]
  023b4	8d 74 02 01	 lea	 esi, DWORD PTR [edx+eax+1]
  023b8	8b 4d e8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  023bb	51		 push	 ecx
  023bc	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  023bf	83 c1 0c	 add	 ecx, 12			; 0000000cH
  023c2	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  023c7	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1054 : 		m_aPos[iPos].nEndL = m_aPos[iPos].nStartR + nLenValue + 1;

  023ca	8b 55 e8	 mov	 edx, DWORD PTR _iPos$[ebp]
  023cd	52		 push	 edx
  023ce	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  023d1	83 c1 0c	 add	 ecx, 12			; 0000000cH
  023d4	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  023d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  023dc	8b 4d f0	 mov	 ecx, DWORD PTR _nLenValue$[ebp]
  023df	8d 74 08 01	 lea	 esi, DWORD PTR [eax+ecx+1]
  023e3	8b 55 e8	 mov	 edx, DWORD PTR _iPos$[ebp]
  023e6	52		 push	 edx
  023e7	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  023ea	83 c1 0c	 add	 ecx, 12			; 0000000cH
  023ed	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  023f2	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 1055 : 		m_aPos[iPos].nEndR = m_aPos[iPos].nEndL + nLenName + 2;

  023f5	8b 45 e8	 mov	 eax, DWORD PTR _iPos$[ebp]
  023f8	50		 push	 eax
  023f9	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  023fc	83 c1 0c	 add	 ecx, 12			; 0000000cH
  023ff	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02404	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  02407	8b 55 c8	 mov	 edx, DWORD PTR _nLenName$[ebp]
  0240a	8d 74 11 02	 lea	 esi, DWORD PTR [ecx+edx+2]
  0240e	8b 45 e8	 mov	 eax, DWORD PTR _iPos$[ebp]
  02411	50		 push	 eax
  02412	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02415	83 c1 0c	 add	 ecx, 12			; 0000000cH
  02418	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  0241d	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 1056 : 	}

  02420	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02424	8d 4d c0	 lea	 ecx, DWORD PTR _csValue$198202[ebp]
  02427	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L198201:

; 1057 : 
; 1058 : 	// Insert
; 1059 : 	int nReplace = 0, nLeft = m_aPos[iPos].nStartL;

  0242d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _nReplace$[ebp], 0
  02434	8b 4d e8	 mov	 ecx, DWORD PTR _iPos$[ebp]
  02437	51		 push	 ecx
  02438	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0243b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0243e	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02443	8b 10		 mov	 edx, DWORD PTR [eax]
  02445	89 55 ec	 mov	 DWORD PTR _nLeft$[ebp], edx

; 1060 : 	if ( bEmptyParent )

  02448	0f b6 45 db	 movzx	 eax, BYTE PTR _bEmptyParent$[ebp]
  0244c	85 c0		 test	 eax, eax
  0244e	0f 84 ee 00 00
	00		 je	 $L198210

; 1061 : 	{
; 1062 : 		CString csParentTagName = x_GetTagName(iPosParent);

  02454	8b 4d c4	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  02457	51		 push	 ecx
  02458	8d 55 bc	 lea	 edx, DWORD PTR _csParentTagName$198211[ebp]
  0245b	52		 push	 edx
  0245c	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0245f	e8 00 00 00 00	 call	 ?x_GetTagName@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CMarkup::x_GetTagName
  02464	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 1063 : 		CString csFormat;

  02468	8d 4d b8	 lea	 ecx, DWORD PTR _csFormat$198213[ebp]
  0246b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  02471	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 1064 : 		csFormat = _T(">\r\n");

  02475	68 00 00 00 00	 push	 OFFSET FLAT:$SG198214
  0247a	8d 4d b8	 lea	 ecx, DWORD PTR _csFormat$198213[ebp]
  0247d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 1065 : 		csFormat += csInsert;

  02483	8d 45 d0	 lea	 eax, DWORD PTR _csInsert$[ebp]
  02486	50		 push	 eax
  02487	8d 4d b8	 lea	 ecx, DWORD PTR _csFormat$198213[ebp]
  0248a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@D$00@1@@Z

; 1066 : 		csFormat += _T("</");

  02490	68 00 00 00 00	 push	 OFFSET FLAT:$SG198215
  02495	8d 4d b8	 lea	 ecx, DWORD PTR _csFormat$198213[ebp]
  02498	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 1067 : 		csFormat += csParentTagName;

  0249e	8d 4d bc	 lea	 ecx, DWORD PTR _csParentTagName$198211[ebp]
  024a1	51		 push	 ecx
  024a2	8d 4d b8	 lea	 ecx, DWORD PTR _csFormat$198213[ebp]
  024a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@D$00@1@@Z

; 1068 : 		csInsert = csFormat;

  024ab	8d 55 b8	 lea	 edx, DWORD PTR _csFormat$198213[ebp]
  024ae	52		 push	 edx
  024af	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  024b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 1069 : 		nLeft = m_aPos[iPosParent].nStartR - 1;

  024b8	8b 45 c4	 mov	 eax, DWORD PTR _iPosParent$[ebp]
  024bb	50		 push	 eax
  024bc	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  024bf	83 c1 0c	 add	 ecx, 12			; 0000000cH
  024c2	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  024c7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  024ca	83 e9 01	 sub	 ecx, 1
  024cd	89 4d ec	 mov	 DWORD PTR _nLeft$[ebp], ecx

; 1070 : 		nReplace = 1;

  024d0	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _nReplace$[ebp], 1

; 1071 : 		// x_Adjust is going to update all affected indexes by one amount
; 1072 : 		// This will satisfy all except the empty parent
; 1073 : 		// Here we pre-adjust for the empty parent
; 1074 : 		// The empty tag slash is removed
; 1075 : 		m_aPos[iPosParent].nStartR -= 1;

  024d7	8b 55 c4	 mov	 edx, DWORD PTR _iPosParent$[ebp]
  024da	52		 push	 edx
  024db	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  024de	83 c1 0c	 add	 ecx, 12			; 0000000cH
  024e1	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  024e6	83 c0 04	 add	 eax, 4
  024e9	89 45 a4	 mov	 DWORD PTR tv344[ebp], eax
  024ec	8b 45 a4	 mov	 eax, DWORD PTR tv344[ebp]
  024ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  024f1	83 e9 01	 sub	 ecx, 1
  024f4	8b 55 a4	 mov	 edx, DWORD PTR tv344[ebp]
  024f7	89 0a		 mov	 DWORD PTR [edx], ecx

; 1076 : 		// For the newly created end tag, see the following example:
; 1077 : 		// <A/> (len 4) becomes <A><B/></A> (len 11)
; 1078 : 		// In x_Adjust everything will be adjusted 11 - 4 = 7
; 1079 : 		// But the nEndL of element A should only be adjusted 5
; 1080 : 		m_aPos[iPosParent].nEndL -= (csParentTagName.GetLength() + 1);

  024f9	8b 45 c4	 mov	 eax, DWORD PTR _iPosParent$[ebp]
  024fc	50		 push	 eax
  024fd	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02500	83 c1 0c	 add	 ecx, 12			; 0000000cH
  02503	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02508	83 c0 08	 add	 eax, 8
  0250b	89 45 a0	 mov	 DWORD PTR tv354[ebp], eax
  0250e	8d 4d bc	 lea	 ecx, DWORD PTR _csParentTagName$198211[ebp]
  02511	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  02517	83 c0 01	 add	 eax, 1
  0251a	8b 4d a0	 mov	 ecx, DWORD PTR tv354[ebp]
  0251d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0251f	2b d0		 sub	 edx, eax
  02521	8b 45 a0	 mov	 eax, DWORD PTR tv354[ebp]
  02524	89 10		 mov	 DWORD PTR [eax], edx

; 1081 : 	}

  02526	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0252a	8d 4d b8	 lea	 ecx, DWORD PTR _csFormat$198213[ebp]
  0252d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  02533	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02537	8d 4d bc	 lea	 ecx, DWORD PTR _csParentTagName$198211[ebp]
  0253a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1082 : 	else if ( m_aPos[iPosParent].nStartR + 1 == m_aPos[iPosParent].nEndL )

  02540	eb 7d		 jmp	 SHORT $L198216
$L198210:
  02542	8b 4d c4	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  02545	51		 push	 ecx
  02546	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02549	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0254c	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02551	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  02554	83 c6 01	 add	 esi, 1
  02557	8b 55 c4	 mov	 edx, DWORD PTR _iPosParent$[ebp]
  0255a	52		 push	 edx
  0255b	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0255e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  02561	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  02566	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  02569	75 54		 jne	 SHORT $L198216

; 1083 : 	{
; 1084 : 		csInsert = _T("\r\n") + csInsert;

  0256b	8d 45 d0	 lea	 eax, DWORD PTR _csInsert$[ebp]
  0256e	50		 push	 eax
  0256f	68 00 00 00 00	 push	 OFFSET FLAT:$SG198219
  02574	8d 4d b4	 lea	 ecx, DWORD PTR $T199228[ebp]
  02577	51		 push	 ecx
  02578	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z ; ATL::operator+
  0257d	83 c4 0c	 add	 esp, 12			; 0000000cH
  02580	89 45 9c	 mov	 DWORD PTR tv321[ebp], eax
  02583	8b 55 9c	 mov	 edx, DWORD PTR tv321[ebp]
  02586	89 55 98	 mov	 DWORD PTR tv409[ebp], edx
  02589	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0258d	8b 45 98	 mov	 eax, DWORD PTR tv409[ebp]
  02590	50		 push	 eax
  02591	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  02594	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0259a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0259e	8d 4d b4	 lea	 ecx, DWORD PTR $T199228[ebp]
  025a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1085 : 		nLeft = m_aPos[iPosParent].nStartR + 1;

  025a7	8b 4d c4	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  025aa	51		 push	 ecx
  025ab	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  025ae	83 c1 0c	 add	 ecx, 12			; 0000000cH
  025b1	e8 00 00 00 00	 call	 ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
  025b6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  025b9	83 c2 01	 add	 edx, 1
  025bc	89 55 ec	 mov	 DWORD PTR _nLeft$[ebp], edx
$L198216:

; 1086 : 	}
; 1087 : 	x_DocChange( nLeft, nReplace, csInsert );

  025bf	8d 45 d0	 lea	 eax, DWORD PTR _csInsert$[ebp]
  025c2	50		 push	 eax
  025c3	8b 4d e4	 mov	 ecx, DWORD PTR _nReplace$[ebp]
  025c6	51		 push	 ecx
  025c7	8b 55 ec	 mov	 edx, DWORD PTR _nLeft$[ebp]
  025ca	52		 push	 edx
  025cb	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  025ce	e8 00 00 00 00	 call	 ?x_DocChange@CMarkup@@IAEXHHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CMarkup::x_DocChange

; 1088 : 	x_Adjust( iPos, csInsert.GetLength() - nReplace );

  025d3	6a 00		 push	 0
  025d5	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  025d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  025de	2b 45 e4	 sub	 eax, DWORD PTR _nReplace$[ebp]
  025e1	50		 push	 eax
  025e2	8b 45 e8	 mov	 eax, DWORD PTR _iPos$[ebp]
  025e5	50		 push	 eax
  025e6	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  025e9	e8 00 00 00 00	 call	 ?x_Adjust@CMarkup@@IAEXHH_N@Z ; CMarkup::x_Adjust

; 1089 : 
; 1090 : 	if ( bAddChild )

  025ee	0f b6 4d 14	 movzx	 ecx, BYTE PTR _bAddChild$[ebp]
  025f2	85 c9		 test	 ecx, ecx
  025f4	74 19		 je	 SHORT $L198220

; 1091 : 		x_SetPos( m_iPosParent, iPosParent, iPos );

  025f6	8b 55 e8	 mov	 edx, DWORD PTR _iPos$[ebp]
  025f9	52		 push	 edx
  025fa	8b 45 c4	 mov	 eax, DWORD PTR _iPosParent$[ebp]
  025fd	50		 push	 eax
  025fe	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02601	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  02604	52		 push	 edx
  02605	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  02608	e8 00 00 00 00	 call	 ?x_SetPos@CMarkup@@IAEXHHH@Z ; CMarkup::x_SetPos

; 1092 : 	else

  0260d	eb 12		 jmp	 SHORT $L198221
$L198220:

; 1093 : 		x_SetPos( iPosParent, iPos, 0 );

  0260f	6a 00		 push	 0
  02611	8b 45 e8	 mov	 eax, DWORD PTR _iPos$[ebp]
  02614	50		 push	 eax
  02615	8b 4d c4	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  02618	51		 push	 ecx
  02619	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0261c	e8 00 00 00 00	 call	 ?x_SetPos@CMarkup@@IAEXHHH@Z ; CMarkup::x_SetPos
$L198221:

; 1094 : 	return true;

  02621	c6 45 b3 01	 mov	 BYTE PTR $T199229[ebp], 1
  02625	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0262c	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  0262f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  02635	8a 45 b3	 mov	 al, BYTE PTR $T199229[ebp]
$L198174:

; 1095 : }

  02638	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0263b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02642	5e		 pop	 esi
  02643	8b e5		 mov	 esp, ebp
  02645	5d		 pop	 ebp
  02646	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
text$x	SEGMENT
$L199230:
  0008c	8d 4d d0	 lea	 ecx, DWORD PTR _csInsert$[ebp]
  0008f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L199231:
  00095	8d 4d c0	 lea	 ecx, DWORD PTR _csValue$198202[ebp]
  00098	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L199232:
  0009e	8d 4d bc	 lea	 ecx, DWORD PTR _csParentTagName$198211[ebp]
  000a1	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L199233:
  000a7	8d 4d b8	 lea	 ecx, DWORD PTR _csFormat$198213[ebp]
  000aa	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L199234:
  000b0	8d 4d b4	 lea	 ecx, DWORD PTR $T199228[ebp]
  000b3	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?x_AddElem@CMarkup@@IAE_NPBD0_N1@Z:
  000b9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199236
  000be	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?x_AddElem@CMarkup@@IAE_NPBD0_N1@Z ENDP			; CMarkup::x_AddElem
EXTRN	__imp_?GetManager@?$CSimpleStringT@D$00@ATL@@QBEPAUIAtlStringMgr@2@XZ:NEAR
EXTRN	__imp_?StringLength@?$CSimpleStringT@D$00@ATL@@SAHPBD@Z:NEAR
EXTRN	__imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z:NEAR
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
xdata$x	SEGMENT
$T199247 DD	0ffffffffH
	DD	FLAT:$L199240
$T199245 DD	019930520H
	DD	01H
	DD	FLAT:$T199247
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z
_TEXT	SEGMENT
$T199242 = -20						; size = 4
_strResult$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_psz1$ = 12						; size = 4
_str2$ = 16						; size = 4
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z PROC NEAR ; ATL::operator+, COMDAT

; 2032 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T199242[ebp], 0

; 2033 : 		CStringT strResult( str2.GetManager() );

  00022	8b 4d 10	 mov	 ecx, DWORD PTR _str2$[ebp]
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CSimpleStringT@D$00@ATL@@QBEPAUIAtlStringMgr@2@XZ
  0002b	50		 push	 eax
  0002c	8d 4d f0	 lea	 ecx, DWORD PTR _strResult$[ebp]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2034 : 
; 2035 : 		Concatenate( strResult, psz1, StringLength( psz1 ), str2, str2.GetLength() );

  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _str2$[ebp]
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  00045	50		 push	 eax
  00046	8b 4d 10	 mov	 ecx, DWORD PTR _str2$[ebp]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0004f	50		 push	 eax
  00050	8b 45 0c	 mov	 eax, DWORD PTR _psz1$[ebp]
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StringLength@?$CSimpleStringT@D$00@ATL@@SAHPBD@Z
  0005a	83 c4 04	 add	 esp, 4
  0005d	50		 push	 eax
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _psz1$[ebp]
  00061	51		 push	 ecx
  00062	8d 55 f0	 lea	 edx, DWORD PTR _strResult$[ebp]
  00065	52		 push	 edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  0006c	83 c4 14	 add	 esp, 20			; 00000014H

; 2036 : 
; 2037 : 		return( strResult );

  0006f	8d 45 f0	 lea	 eax, DWORD PTR _strResult$[ebp]
  00072	50		 push	 eax
  00073	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0007c	8b 4d ec	 mov	 ecx, DWORD PTR $T199242[ebp]
  0007f	83 c9 01	 or	 ecx, 1
  00082	89 4d ec	 mov	 DWORD PTR $T199242[ebp], ecx
  00085	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008c	8d 4d f0	 lea	 ecx, DWORD PTR _strResult$[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00095	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2038 : 	}

  00098	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L199240:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _strResult$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199245
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z ENDP ; ATL::operator+
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
;	COMDAT ?GetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEHXZ PROC NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::GetSize, COMDAT
; _this$ = ecx

; 272  : 	{ return m_nSize; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEHXZ ENDP	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::GetSize
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0ElemPos@CMarkup@@QAE@XZ			; CMarkup::ElemPos::ElemPos
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:NEAR	; AfxThrowInvalidArgException
EXTRN	_memset:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T199282 DD	0ffffffffH
	DD	FLAT:$L199276
	DD	0ffffffffH
	DD	FLAT:$L199277
	DD	0ffffffffH
	DD	FLAT:$L199278
$T199280 DD	019930520H
	DD	03H
	DD	FLAT:$T199282
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z
_TEXT	SEGMENT
tv246 = -112						; size = 4
tv196 = -108						; size = 4
tv197 = -104						; size = 4
tv183 = -100						; size = 4
tv142 = -96						; size = 4
tv83 = -92						; size = 4
_this$ = -88						; size = 4
$T199275 = -84						; size = 4
$T199272 = -80						; size = 4
$T199271 = -76						; size = 4
$T199270 = -72						; size = 4
$T199263 = -68						; size = 4
$T199262 = -64						; size = 4
$T199259 = -60						; size = 4
$T199258 = -56						; size = 4
$T199257 = -52						; size = 4
$T199254 = -48						; size = 4
_i$198504 = -44						; size = 4
_pNewData$198492 = -40					; size = 4
_nNewMax$198486 = -36					; size = 4
_i$198480 = -32						; size = 4
_i$198468 = -28						; size = 4
_i$198452 = -24						; size = 4
_nAllocSize$198443 = -20				; size = 4
_i$198434 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_nNewSize$ = 8						; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z PROC NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::SetSize, COMDAT
; _this$ = ecx

; 369  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 64	 sub	 esp, 100		; 00000064H
  0001b	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx

; 370  : 	ASSERT_VALID(this);
; 371  : 	ASSERT(nNewSize >= 0);
; 372  : 
; 373  : 	if(nNewSize < 0 )

  0001e	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  00022	7d 05		 jge	 SHORT $L198430

; 374  : 		AfxThrowInvalidArgException();

  00024	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L198430:

; 375  : 
; 376  : 	if (nGrowBy >= 0)

  00029	83 7d 0c 00	 cmp	 DWORD PTR _nGrowBy$[ebp], 0
  0002d	7c 09		 jl	 SHORT $L198431

; 377  : 		m_nGrowBy = nGrowBy;  // set new size

  0002f	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _nGrowBy$[ebp]
  00035	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$L198431:

; 378  : 
; 379  : 	if (nNewSize == 0)

  00038	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  0003c	75 60		 jne	 SHORT $L198432

; 380  : 	{
; 381  : 		// shrink to nothing
; 382  : 		if (m_pData != NULL)

  0003e	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00041	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00045	74 3e		 je	 SHORT $L198433

; 383  : 		{
; 384  : 			for( int i = 0; i < m_nSize; i++ )

  00047	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$198434[ebp], 0
  0004e	eb 09		 jmp	 SHORT $L198435
$L198436:
  00050	8b 45 f0	 mov	 eax, DWORD PTR _i$198434[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 45 f0	 mov	 DWORD PTR _i$198434[ebp], eax
$L198435:
  00059	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	8b 55 f0	 mov	 edx, DWORD PTR _i$198434[ebp]
  0005f	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00062	7d 02		 jge	 SHORT $L198437

; 385  : 				(m_pData + i)->~TYPE();

  00064	eb ea		 jmp	 SHORT $L198436
$L198437:

; 386  : 			delete[] (BYTE*)m_pData;

  00066	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006c	89 4d d0	 mov	 DWORD PTR $T199254[ebp], ecx
  0006f	8b 55 d0	 mov	 edx, DWORD PTR $T199254[ebp]
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00078	83 c4 04	 add	 esp, 4

; 387  : 			m_pData = NULL;

  0007b	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L198433:

; 388  : 		}
; 389  : 		m_nSize = m_nMaxSize = 0;

  00085	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0008f	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00092	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 390  : 	}
; 391  : 	else if (m_pData == NULL)

  00099	e9 57 03 00 00	 jmp	 $L199253
$L198432:
  0009e	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000a5	0f 85 d0 00 00
	00		 jne	 $L198441

; 392  : 	{
; 393  : 		// create buffer big enough to hold number of requested elements or
; 394  : 		// m_nGrowBy elements, whichever is larger.
; 395  : #ifdef SIZE_T_MAX
; 396  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 397  : #endif
; 398  : 		size_t nAllocSize = max(nNewSize, m_nGrowBy);

  000ab	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  000b1	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000b4	7e 08		 jle	 SHORT $L199255
  000b6	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  000b9	89 45 a4	 mov	 DWORD PTR tv83[ebp], eax
  000bc	eb 09		 jmp	 SHORT $L199256
$L199255:
  000be	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000c4	89 55 a4	 mov	 DWORD PTR tv83[ebp], edx
$L199256:
  000c7	8b 45 a4	 mov	 eax, DWORD PTR tv83[ebp]
  000ca	89 45 ec	 mov	 DWORD PTR _nAllocSize$198443[ebp], eax

; 399  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  000cd	8b 4d ec	 mov	 ecx, DWORD PTR _nAllocSize$198443[ebp]
  000d0	c1 e1 05	 shl	 ecx, 5
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000d9	83 c4 04	 add	 esp, 4
  000dc	89 45 cc	 mov	 DWORD PTR $T199257[ebp], eax
  000df	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  000e2	8b 45 cc	 mov	 eax, DWORD PTR $T199257[ebp]
  000e5	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 400  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  000e8	8b 4d ec	 mov	 ecx, DWORD PTR _nAllocSize$198443[ebp]
  000eb	c1 e1 05	 shl	 ecx, 5
  000ee	51		 push	 ecx
  000ef	6a 00		 push	 0
  000f1	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _memset
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 401  : 		for( int i = 0; i < nNewSize; i++ )

  00100	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$198452[ebp], 0
  00107	eb 09		 jmp	 SHORT $L198453
$L198454:
  00109	8b 4d e8	 mov	 ecx, DWORD PTR _i$198452[ebp]
  0010c	83 c1 01	 add	 ecx, 1
  0010f	89 4d e8	 mov	 DWORD PTR _i$198452[ebp], ecx
$L198453:
  00112	8b 55 e8	 mov	 edx, DWORD PTR _i$198452[ebp]
  00115	3b 55 08	 cmp	 edx, DWORD PTR _nNewSize$[ebp]
  00118	7d 4a		 jge	 SHORT $L198455

; 402  : #pragma push_macro("new")
; 403  : #undef new
; 404  : 			::new( (void*)( m_pData + i ) ) TYPE;

  0011a	8b 45 e8	 mov	 eax, DWORD PTR _i$198452[ebp]
  0011d	c1 e0 05	 shl	 eax, 5
  00120	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00126	50		 push	 eax
  00127	6a 20		 push	 32			; 00000020H
  00129	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0012e	83 c4 08	 add	 esp, 8
  00131	89 45 c4	 mov	 DWORD PTR $T199259[ebp], eax
  00134	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0013b	83 7d c4 00	 cmp	 DWORD PTR $T199259[ebp], 0
  0013f	74 0d		 je	 SHORT $L199260
  00141	8b 4d c4	 mov	 ecx, DWORD PTR $T199259[ebp]
  00144	e8 00 00 00 00	 call	 ??0ElemPos@CMarkup@@QAE@XZ ; CMarkup::ElemPos::ElemPos
  00149	89 45 a0	 mov	 DWORD PTR tv142[ebp], eax
  0014c	eb 07		 jmp	 SHORT $L199261
$L199260:
  0014e	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
$L199261:
  00155	8b 55 a0	 mov	 edx, DWORD PTR tv142[ebp]
  00158	89 55 c8	 mov	 DWORD PTR $T199258[ebp], edx
  0015b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00162	eb a5		 jmp	 SHORT $L198454
$L198455:

; 405  : #pragma pop_macro("new")
; 406  : 		m_nSize = nNewSize;

  00164	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00167	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  0016a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 407  : 		m_nMaxSize = nAllocSize;

  0016d	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00170	8b 45 ec	 mov	 eax, DWORD PTR _nAllocSize$198443[ebp]
  00173	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 408  : 	}
; 409  : 	else if (nNewSize <= m_nMaxSize)

  00176	e9 7a 02 00 00	 jmp	 $L199253
$L198441:
  0017b	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00181	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00184	0f 8f ea 00 00
	00		 jg	 $L198463

; 410  : 	{
; 411  : 		// it fits
; 412  : 		if (nNewSize > m_nSize)

  0018a	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0018d	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  00190	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00193	0f 8e a0 00 00
	00		 jle	 $L198464

; 413  : 		{
; 414  : 			// initialize the new elements
; 415  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00199	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  0019c	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  0019f	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  001a2	c1 e0 05	 shl	 eax, 5
  001a5	50		 push	 eax
  001a6	6a 00		 push	 0
  001a8	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001ae	c1 e2 05	 shl	 edx, 5
  001b1	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001b4	03 50 04	 add	 edx, DWORD PTR [eax+4]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 _memset
  001bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 416  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )

  001c0	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$198468[ebp], 0
  001c7	eb 09		 jmp	 SHORT $L198469
$L198470:
  001c9	8b 4d e4	 mov	 ecx, DWORD PTR _i$198468[ebp]
  001cc	83 c1 01	 add	 ecx, 1
  001cf	89 4d e4	 mov	 DWORD PTR _i$198468[ebp], ecx
$L198469:
  001d2	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  001d5	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  001d8	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  001db	39 45 e4	 cmp	 DWORD PTR _i$198468[ebp], eax
  001de	7d 57		 jge	 SHORT $L198471

; 417  : #pragma push_macro("new")
; 418  : #undef new
; 419  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;

  001e0	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001e6	c1 e2 05	 shl	 edx, 5
  001e9	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001ec	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ef	03 ca		 add	 ecx, edx
  001f1	8b 55 e4	 mov	 edx, DWORD PTR _i$198468[ebp]
  001f4	c1 e2 05	 shl	 edx, 5
  001f7	03 ca		 add	 ecx, edx
  001f9	51		 push	 ecx
  001fa	6a 20		 push	 32			; 00000020H
  001fc	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00201	83 c4 08	 add	 esp, 8
  00204	89 45 bc	 mov	 DWORD PTR $T199263[ebp], eax
  00207	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0020e	83 7d bc 00	 cmp	 DWORD PTR $T199263[ebp], 0
  00212	74 0d		 je	 SHORT $L199264
  00214	8b 4d bc	 mov	 ecx, DWORD PTR $T199263[ebp]
  00217	e8 00 00 00 00	 call	 ??0ElemPos@CMarkup@@QAE@XZ ; CMarkup::ElemPos::ElemPos
  0021c	89 45 9c	 mov	 DWORD PTR tv183[ebp], eax
  0021f	eb 07		 jmp	 SHORT $L199265
$L199264:
  00221	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv183[ebp], 0
$L199265:
  00228	8b 45 9c	 mov	 eax, DWORD PTR tv183[ebp]
  0022b	89 45 c0	 mov	 DWORD PTR $T199262[ebp], eax
  0022e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00235	eb 92		 jmp	 SHORT $L198470
$L198471:

; 420  : #pragma pop_macro("new")
; 421  : 		}
; 422  : 		else if (m_nSize > nNewSize)

  00237	eb 2d		 jmp	 SHORT $L198478
$L198464:
  00239	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0023f	3b 55 08	 cmp	 edx, DWORD PTR _nNewSize$[ebp]
  00242	7e 22		 jle	 SHORT $L198478

; 423  : 		{
; 424  : 			// destroy the old elements
; 425  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )

  00244	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$198480[ebp], 0
  0024b	eb 09		 jmp	 SHORT $L198481
$L198482:
  0024d	8b 45 e0	 mov	 eax, DWORD PTR _i$198480[ebp]
  00250	83 c0 01	 add	 eax, 1
  00253	89 45 e0	 mov	 DWORD PTR _i$198480[ebp], eax
$L198481:
  00256	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00259	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0025c	2b 55 08	 sub	 edx, DWORD PTR _nNewSize$[ebp]
  0025f	39 55 e0	 cmp	 DWORD PTR _i$198480[ebp], edx
  00262	7d 02		 jge	 SHORT $L198478

; 426  : 				(m_pData + nNewSize + i)->~TYPE();

  00264	eb e7		 jmp	 SHORT $L198482
$L198478:

; 427  : 		}
; 428  : 		m_nSize = nNewSize;

  00266	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00269	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  0026c	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 429  : 	}
; 430  : 	else

  0026f	e9 81 01 00 00	 jmp	 $L199253
$L198463:

; 431  : 	{
; 432  : 		// otherwise, grow array
; 433  : 		nGrowBy = m_nGrowBy;

  00274	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00277	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0027a	89 45 0c	 mov	 DWORD PTR _nGrowBy$[ebp], eax

; 434  : 		if (nGrowBy == 0)

  0027d	83 7d 0c 00	 cmp	 DWORD PTR _nGrowBy$[ebp], 0
  00281	75 45		 jne	 SHORT $L198485

; 435  : 		{
; 436  : 			// heuristically determine growth when nGrowBy == 0
; 437  : 			//  (this avoids heap fragmentation in many situations)
; 438  : 			nGrowBy = m_nSize / 8;

  00283	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00286	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00289	99		 cdq
  0028a	83 e2 07	 and	 edx, 7
  0028d	03 c2		 add	 eax, edx
  0028f	c1 f8 03	 sar	 eax, 3
  00292	89 45 0c	 mov	 DWORD PTR _nGrowBy$[ebp], eax

; 439  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  00295	83 7d 0c 04	 cmp	 DWORD PTR _nGrowBy$[ebp], 4
  00299	7d 09		 jge	 SHORT $L199268
  0029b	c7 45 98 04 00
	00 00		 mov	 DWORD PTR tv197[ebp], 4
  002a2	eb 1e		 jmp	 SHORT $L199269
$L199268:
  002a4	81 7d 0c 00 04
	00 00		 cmp	 DWORD PTR _nGrowBy$[ebp], 1024 ; 00000400H
  002ab	7e 09		 jle	 SHORT $L199266
  002ad	c7 45 94 00 04
	00 00		 mov	 DWORD PTR tv196[ebp], 1024 ; 00000400H
  002b4	eb 06		 jmp	 SHORT $L199267
$L199266:
  002b6	8b 55 0c	 mov	 edx, DWORD PTR _nGrowBy$[ebp]
  002b9	89 55 94	 mov	 DWORD PTR tv196[ebp], edx
$L199267:
  002bc	8b 45 94	 mov	 eax, DWORD PTR tv196[ebp]
  002bf	89 45 98	 mov	 DWORD PTR tv197[ebp], eax
$L199269:
  002c2	8b 4d 98	 mov	 ecx, DWORD PTR tv197[ebp]
  002c5	89 4d 0c	 mov	 DWORD PTR _nGrowBy$[ebp], ecx
$L198485:

; 440  : 		}
; 441  : 		INT_PTR nNewMax;
; 442  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  002c8	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  002cb	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  002ce	03 45 0c	 add	 eax, DWORD PTR _nGrowBy$[ebp]
  002d1	39 45 08	 cmp	 DWORD PTR _nNewSize$[ebp], eax
  002d4	7d 0e		 jge	 SHORT $L198487

; 443  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity

  002d6	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  002dc	03 55 0c	 add	 edx, DWORD PTR _nGrowBy$[ebp]
  002df	89 55 dc	 mov	 DWORD PTR _nNewMax$198486[ebp], edx

; 444  : 		else

  002e2	eb 06		 jmp	 SHORT $L198488
$L198487:

; 445  : 			nNewMax = nNewSize;  // no slush

  002e4	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  002e7	89 45 dc	 mov	 DWORD PTR _nNewMax$198486[ebp], eax
$L198488:

; 446  : 
; 447  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 448  : 		
; 449  : 		if(nNewMax  < m_nMaxSize)

  002ea	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  002ed	8b 55 dc	 mov	 edx, DWORD PTR _nNewMax$198486[ebp]
  002f0	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  002f3	7d 05		 jge	 SHORT $L198490

; 450  : 			AfxThrowInvalidArgException();

  002f5	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L198490:

; 451  : 
; 452  : #ifdef SIZE_T_MAX
; 453  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 454  : #endif
; 455  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  002fa	8b 45 dc	 mov	 eax, DWORD PTR _nNewMax$198486[ebp]
  002fd	c1 e0 05	 shl	 eax, 5
  00300	50		 push	 eax
  00301	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00306	83 c4 04	 add	 esp, 4
  00309	89 45 b8	 mov	 DWORD PTR $T199270[ebp], eax
  0030c	8b 4d b8	 mov	 ecx, DWORD PTR $T199270[ebp]
  0030f	89 4d d8	 mov	 DWORD PTR _pNewData$198492[ebp], ecx

; 456  : 
; 457  : 		// copy new data from old
; 458  : 		memcpy(pNewData, m_pData, (size_t)m_nSize * sizeof(TYPE));

  00312	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00315	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00318	c1 e0 05	 shl	 eax, 5
  0031b	50		 push	 eax
  0031c	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0031f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00322	52		 push	 edx
  00323	8b 45 d8	 mov	 eax, DWORD PTR _pNewData$198492[ebp]
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 _memcpy
  0032c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 459  : 
; 460  : 		// construct remaining elements
; 461  : 		ASSERT(nNewSize > m_nSize);
; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  0032f	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00332	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00335	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  00338	c1 e2 05	 shl	 edx, 5
  0033b	52		 push	 edx
  0033c	6a 00		 push	 0
  0033e	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00341	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00344	c1 e1 05	 shl	 ecx, 5
  00347	03 4d d8	 add	 ecx, DWORD PTR _pNewData$198492[ebp]
  0034a	51		 push	 ecx
  0034b	e8 00 00 00 00	 call	 _memset
  00350	83 c4 0c	 add	 esp, 12			; 0000000cH

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )

  00353	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$198504[ebp], 0
  0035a	eb 09		 jmp	 SHORT $L198505
$L198506:
  0035c	8b 55 d4	 mov	 edx, DWORD PTR _i$198504[ebp]
  0035f	83 c2 01	 add	 edx, 1
  00362	89 55 d4	 mov	 DWORD PTR _i$198504[ebp], edx
$L198505:
  00365	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00368	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  0036b	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  0036e	39 4d d4	 cmp	 DWORD PTR _i$198504[ebp], ecx
  00371	7d 52		 jge	 SHORT $L198507

; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;

  00373	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00376	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00379	c1 e0 05	 shl	 eax, 5
  0037c	03 45 d8	 add	 eax, DWORD PTR _pNewData$198492[ebp]
  0037f	8b 4d d4	 mov	 ecx, DWORD PTR _i$198504[ebp]
  00382	c1 e1 05	 shl	 ecx, 5
  00385	03 c1		 add	 eax, ecx
  00387	50		 push	 eax
  00388	6a 20		 push	 32			; 00000020H
  0038a	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0038f	83 c4 08	 add	 esp, 8
  00392	89 45 b0	 mov	 DWORD PTR $T199272[ebp], eax
  00395	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0039c	83 7d b0 00	 cmp	 DWORD PTR $T199272[ebp], 0
  003a0	74 0d		 je	 SHORT $L199273
  003a2	8b 4d b0	 mov	 ecx, DWORD PTR $T199272[ebp]
  003a5	e8 00 00 00 00	 call	 ??0ElemPos@CMarkup@@QAE@XZ ; CMarkup::ElemPos::ElemPos
  003aa	89 45 90	 mov	 DWORD PTR tv246[ebp], eax
  003ad	eb 07		 jmp	 SHORT $L199274
$L199273:
  003af	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv246[ebp], 0
$L199274:
  003b6	8b 55 90	 mov	 edx, DWORD PTR tv246[ebp]
  003b9	89 55 b4	 mov	 DWORD PTR $T199271[ebp], edx
  003bc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003c3	eb 97		 jmp	 SHORT $L198506
$L198507:

; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  003c5	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  003c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003cb	89 4d ac	 mov	 DWORD PTR $T199275[ebp], ecx
  003ce	8b 55 ac	 mov	 edx, DWORD PTR $T199275[ebp]
  003d1	52		 push	 edx
  003d2	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  003d7	83 c4 04	 add	 esp, 4

; 471  : 		m_pData = pNewData;

  003da	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  003dd	8b 4d d8	 mov	 ecx, DWORD PTR _pNewData$198492[ebp]
  003e0	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 472  : 		m_nSize = nNewSize;

  003e3	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  003e6	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  003e9	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 473  : 		m_nMaxSize = nNewMax;

  003ec	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ef	8b 55 dc	 mov	 edx, DWORD PTR _nNewMax$198486[ebp]
  003f2	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L199253:

; 474  : 	}
; 475  : }

  003f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  003ff	8b e5		 mov	 esp, ebp
  00401	5d		 pop	 ebp
  00402	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L199276:
  00000	8b 45 e8	 mov	 eax, DWORD PTR _i$198452[ebp]
  00003	c1 e0 05	 shl	 eax, 5
  00006	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00009	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0000c	50		 push	 eax
  0000d	8b 55 c4	 mov	 edx, DWORD PTR $T199259[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00016	83 c4 08	 add	 esp, 8
  00019	c3		 ret	 0
$L199277:
  0001a	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00020	c1 e1 05	 shl	 ecx, 5
  00023	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00029	03 c1		 add	 eax, ecx
  0002b	8b 4d e4	 mov	 ecx, DWORD PTR _i$198468[ebp]
  0002e	c1 e1 05	 shl	 ecx, 5
  00031	03 c1		 add	 eax, ecx
  00033	50		 push	 eax
  00034	8b 55 bc	 mov	 edx, DWORD PTR $T199263[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0003d	83 c4 08	 add	 esp, 8
  00040	c3		 ret	 0
$L199278:
  00041	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00047	c1 e1 05	 shl	 ecx, 5
  0004a	03 4d d8	 add	 ecx, DWORD PTR _pNewData$198492[ebp]
  0004d	8b 55 d4	 mov	 edx, DWORD PTR _i$198504[ebp]
  00050	c1 e2 05	 shl	 edx, 5
  00053	03 ca		 add	 ecx, edx
  00055	51		 push	 ecx
  00056	8b 45 b0	 mov	 eax, DWORD PTR $T199272[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0005f	83 c4 08	 add	 esp, 8
  00062	c3		 ret	 0
__ehhandler$?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z:
  00063	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199280
  00068	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z ENDP ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::SetSize
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.h
_TEXT	ENDS
;	COMDAT ??0ElemPos@CMarkup@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ElemPos@CMarkup@@QAE@XZ PROC NEAR			; CMarkup::ElemPos::ElemPos, COMDAT
; _this$ = ecx

; 86   : 		ElemPos() { Clear(); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Clear@ElemPos@CMarkup@@QAEXXZ ; CMarkup::ElemPos::Clear
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0ElemPos@CMarkup@@QAE@XZ ENDP				; CMarkup::ElemPos::ElemPos
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RemoveAll@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXXZ PROC NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::RemoveAll, COMDAT
; _this$ = ecx

; 284  : 	{ SetSize(0, -1); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a ff		 push	 -1
  00009	6a 00		 push	 0
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::SetSize
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?RemoveAll@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXXZ ENDP ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::RemoveAll
_TEXT	ENDS
PUBLIC	??$CopyElements@UElemPos@CMarkup@@@@YGXPAUElemPos@CMarkup@@PBU01@H@Z ; CopyElements<CMarkup::ElemPos>
; Function compile flags: /Odt
;	COMDAT ?Append@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEHABV1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nOldSize$ = -4						; size = 4
_src$ = 8						; size = 4
?Append@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEHABV1@@Z PROC NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::Append, COMDAT
; _this$ = ecx

; 479  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 480  : 	ASSERT_VALID(this);
; 481  : 	ASSERT(this != &src);   // cannot append to itself
; 482  : 	
; 483  : 	if(this == &src)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	3b 45 08	 cmp	 eax, DWORD PTR _src$[ebp]
  0000f	75 05		 jne	 SHORT $L198529

; 484  : 		AfxThrowInvalidArgException();

  00011	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L198529:

; 485  : 
; 486  : 	INT_PTR nOldSize = m_nSize;

  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001c	89 55 fc	 mov	 DWORD PTR _nOldSize$[ebp], edx

; 487  : 	SetSize(m_nSize + src.m_nSize);

  0001f	6a ff		 push	 -1
  00021	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00027	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0002a	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  0002d	51		 push	 ecx
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::SetSize

; 488  : 	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);

  00036	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00039	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003c	51		 push	 ecx
  0003d	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00040	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _nOldSize$[ebp]
  00047	c1 e1 05	 shl	 ecx, 5
  0004a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??$CopyElements@UElemPos@CMarkup@@@@YGXPAUElemPos@CMarkup@@PBU01@H@Z ; CopyElements<CMarkup::ElemPos>

; 489  : 	return nOldSize;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _nOldSize$[ebp]
$L199294:

; 490  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?Append@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEHABV1@@Z ENDP ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::Append
_TEXT	ENDS
PUBLIC	?ElementAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::ElementAt
; Function compile flags: /Odt
;	COMDAT ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z PROC NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[], COMDAT
; _this$ = ecx

; 342  : 	{ return ElementAt(nIndex); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?ElementAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::ElementAt
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??A?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ENDP ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
_TEXT	ENDS
PUBLIC	?GetAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::GetAt
; Function compile flags: /Odt
;	COMDAT ??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z PROC NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[], COMDAT
; _this$ = ecx

; 339  : 	{ return GetAt(nIndex); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?GetAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::GetAt
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??A?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ENDP ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::operator[]
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z PROC NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::GetAt, COMDAT
; _this$ = ecx

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 296  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 297  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7c 19		 jl	 SHORT $L198600
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00013	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00016	7d 0e		 jge	 SHORT $L198600

; 298  : 		return m_pData[nIndex]; 

  00018	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  0001b	c1 e0 05	 shl	 eax, 5
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00024	eb 05		 jmp	 SHORT $L199300
$L198600:

; 299  : 	AfxThrowInvalidArgException();		

  00026	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L199300:

; 300  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?GetAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QBEABUElemPos@CMarkup@@H@Z ENDP ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::GetAt
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ElementAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?ElementAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z PROC NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::ElementAt, COMDAT
; _this$ = ecx

; 320  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 321  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 322  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7c 19		 jl	 SHORT $L198608
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00013	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00016	7d 0e		 jge	 SHORT $L198608

; 323  : 		return m_pData[nIndex]; 

  00018	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  0001b	c1 e0 05	 shl	 eax, 5
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00024	eb 05		 jmp	 SHORT $L199302
$L198608:

; 324  : 	AfxThrowInvalidArgException();		

  00026	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L199302:

; 325  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?ElementAt@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEAAUElemPos@CMarkup@@H@Z ENDP ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::ElementAt
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$CopyElements@UElemPos@CMarkup@@@@YGXPAUElemPos@CMarkup@@PBU01@H@Z
_TEXT	SEGMENT
_pDest$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nCount$ = 16						; size = 4
??$CopyElements@UElemPos@CMarkup@@@@YGXPAUElemPos@CMarkup@@PBU01@H@Z PROC NEAR ; CopyElements<CMarkup::ElemPos>, COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
$L198613:

; 57   : 	ASSERT(nCount == 0 ||
; 58   : 		AfxIsValidAddress(pDest, (size_t)nCount * sizeof(TYPE)));
; 59   : 	ASSERT(nCount == 0 ||
; 60   : 		AfxIsValidAddress(pSrc, (size_t)nCount * sizeof(TYPE)));
; 61   : 
; 62   : 	// default is element-copy using assignment
; 63   : 	while (nCount--)

  00005	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]
  00008	8b 4d 10	 mov	 ecx, DWORD PTR _nCount$[ebp]
  0000b	83 e9 01	 sub	 ecx, 1
  0000e	89 4d 10	 mov	 DWORD PTR _nCount$[ebp], ecx
  00011	85 c0		 test	 eax, eax
  00013	74 21		 je	 SHORT $L198609

; 64   : 		*pDest++ = *pSrc++;

  00015	8b 75 0c	 mov	 esi, DWORD PTR _pSrc$[ebp]
  00018	b9 08 00 00 00	 mov	 ecx, 8
  0001d	8b 7d 08	 mov	 edi, DWORD PTR _pDest$[ebp]
  00020	f3 a5		 rep movsd
  00022	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  00025	83 c2 20	 add	 edx, 32			; 00000020H
  00028	89 55 08	 mov	 DWORD PTR _pDest$[ebp], edx
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pSrc$[ebp]
  0002e	83 c0 20	 add	 eax, 32			; 00000020H
  00031	89 45 0c	 mov	 DWORD PTR _pSrc$[ebp], eax
  00034	eb cf		 jmp	 SHORT $L198613
$L198609:

; 65   : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5d		 pop	 ebp
  00039	c2 0c 00	 ret	 12			; 0000000cH
??$CopyElements@UElemPos@CMarkup@@@@YGXPAUElemPos@CMarkup@@PBU01@H@Z ENDP ; CopyElements<CMarkup::ElemPos>
_TEXT	ENDS
END
