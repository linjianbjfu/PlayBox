; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\Gui\Bitmap\DibBitmap.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??_GCDibBitmap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CDibBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CDibBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CDib@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDibBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCDib@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCDibBitmap@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4CDibBitmap@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDC@CWnd@@QAEPAVCDC@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Size@CRect@@QBE?AVCSize@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeflateRect@CRect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9CRect@@QBEHABUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CDibBitmap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG197508 DB	'DISPLAY', 00H
CONST	ENDS
PUBLIC	??0CRect@@QAE@XZ				; CRect::CRect
PUBLIC	??0CRect@@QAE@HHHH@Z				; CRect::CRect
PUBLIC	??_R4CDibBitmap@@6B@				; CDibBitmap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDibBitmap@@@8				; CDibBitmap `RTTI Type Descriptor'
PUBLIC	??_R3CDibBitmap@@8				; CDibBitmap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDibBitmap@@8				; CDibBitmap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CDibBitmap@@8			; CDibBitmap::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@CDib@@8				; CDib::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCDib@@@8				; CDib `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??0CDibBitmap@@QAE@XZ				; CDibBitmap::CDibBitmap
PUBLIC	??_7CDibBitmap@@6B@				; CDibBitmap::`vftable'
PUBLIC	??_GCDibBitmap@@UAEPAXI@Z			; CDibBitmap::`scalar deleting destructor'
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
EXTRN	?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ:NEAR ; CDib::GetRuntimeClass
EXTRN	??0CDib@@IAE@XZ:NEAR				; CDib::CDib
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	?Serialize@CDib@@MAEXAAVCArchive@@@Z:NEAR	; CDib::Serialize
EXTRN	??_ECDibBitmap@@UAEPAXI@Z:NEAR			; CDibBitmap::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_7CDibBitmap@@6B@
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\bitmap\dibbitmap.cpp
CONST	SEGMENT
??_7CDibBitmap@@6B@ DD FLAT:??_R4CDibBitmap@@6B@	; CDibBitmap::`vftable'
	DD	FLAT:?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECDibBitmap@@UAEPAXI@Z
	DD	FLAT:?Serialize@CDib@@MAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CDibBitmap@@6B@
rdata$r	SEGMENT
??_R4CDibBitmap@@6B@ DD 00H				; CDibBitmap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDibBitmap@@@8
	DD	FLAT:??_R3CDibBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDibBitmap@@@8
_DATA	SEGMENT
??_R0?AVCDibBitmap@@@8 DD FLAT:??_7type_info@@6B@	; CDibBitmap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDibBitmap@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CDibBitmap@@8
rdata$r	SEGMENT
??_R3CDibBitmap@@8 DD 00H				; CDibBitmap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CDibBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R2CDibBitmap@@8
rdata$r	SEGMENT
??_R2CDibBitmap@@8 DD FLAT:??_R1A@?0A@A@CDibBitmap@@8	; CDibBitmap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CDib@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDibBitmap@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CDibBitmap@@8 DD FLAT:??_R0?AVCDibBitmap@@@8 ; CDibBitmap::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDib@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CDib@@8 DD FLAT:??_R0?AVCDib@@@8		; CDib::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCDib@@@8
_DATA	SEGMENT
??_R0?AVCDib@@@8 DD FLAT:??_7type_info@@6B@		; CDib `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDib@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T198097 = -16						; size = 16
??0CDibBitmap@@QAE@XZ PROC NEAR				; CDibBitmap::CDibBitmap
; _this$ = ecx

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CDib@@IAE@XZ		; CDib::CDib
  00011	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDibBitmap@@6B@
  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 38	 add	 ecx, 56			; 00000038H
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00026	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0002c	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 60	 add	 ecx, 96			; 00000060H
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 6    : 	m_rect = CRect(0,0,0,0);

  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	6a 00		 push	 0
  00045	8d 4d f0	 lea	 ecx, DWORD PTR $T198097[ebp]
  00048	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00053	8b 10		 mov	 edx, DWORD PTR [eax]
  00055	89 11		 mov	 DWORD PTR [ecx], edx
  00057	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0005d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00060	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00063	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00066	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 7    : 	pos_Left = -1;

  00069	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	c7 41 50 ff ff
	ff ff		 mov	 DWORD PTR [ecx+80], -1

; 8    : 	pos_Top = -1;

  00073	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00076	c7 42 4c ff ff
	ff ff		 mov	 DWORD PTR [edx+76], -1

; 9    : 	pos_Right = -1;

  0007d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00080	c7 40 54 ff ff
	ff ff		 mov	 DWORD PTR [eax+84], -1

; 10   : 	pos_Bottom = -1;

  00087	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	c7 41 58 ff ff
	ff ff		 mov	 DWORD PTR [ecx+88], -1

; 11   : 	is_Loaded = 0;

  00091	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00094	c6 42 5c 00	 mov	 BYTE PTR [edx+92], 0

; 12   : 	is_ChangeColor = 1;

  00098	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	c6 40 5d 01	 mov	 BYTE PTR [eax+93], 1

; 13   : 	has_PopupError = false;

  0009f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	c6 41 5e 00	 mov	 BYTE PTR [ecx+94], 0

; 14   : 	m_count = 0;

  000a6	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000a9	c7 42 64 00 00
	00 00		 mov	 DWORD PTR [edx+100], 0

; 15   : }

  000b0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
??0CDibBitmap@@QAE@XZ ENDP				; CDibBitmap::CDibBitmap
_TEXT	ENDS
PUBLIC	??1CDibBitmap@@UAE@XZ				; CDibBitmap::~CDibBitmap
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
; Function compile flags: /Odt
;	COMDAT ??_GCDibBitmap@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCDibBitmap@@UAEPAXI@Z PROC NEAR			; CDibBitmap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDibBitmap@@UAE@XZ	; CDibBitmap::~CDibBitmap
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L197373
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L197373:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCDibBitmap@@UAEPAXI@Z ENDP				; CDibBitmap::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??1CDib@@MAE@XZ:NEAR				; CDib::~CDib
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CDibBitmap@@UAE@XZ PROC NEAR				; CDibBitmap::~CDibBitmap
; _this$ = ecx

; 18   : {

  000c0	55		 push	 ebp
  000c1	8b ec		 mov	 ebp, esp
  000c3	51		 push	 ecx
  000c4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  000c7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDibBitmap@@6B@

; 19   : }

  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	83 c1 60	 add	 ecx, 96			; 00000060H
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	83 c1 38	 add	 ecx, 56			; 00000038H
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	e8 00 00 00 00	 call	 ??1CDib@@MAE@XZ		; CDib::~CDib
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
??1CDibBitmap@@UAE@XZ ENDP				; CDibBitmap::~CDibBitmap
_TEXT	ENDS
PUBLIC	?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CDibBitmap::LoadFromFile
EXTRN	__imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:NEAR
EXTRN	?AttachMapFile@CDib@@IAEHPBDH@Z:NEAR		; CDib::AttachMapFile
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T198116 DD	0ffffffffH
	DD	FLAT:$L198109
$T198113 DD	019930520H
	DD	01H
	DD	FLAT:$T198116
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T198108 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; CDibBitmap::LoadFromFile
; _this$ = ecx

; 21   : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp
  00103	6a ff		 push	 -1
  00105	68 00 00 00 00	 push	 __ehhandler$?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0010a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00110	50		 push	 eax
  00111	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00118	83 ec 08	 sub	 esp, 8
  0011b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0011e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 22   : 	m_path = path;

  00125	8d 45 08	 lea	 eax, DWORD PTR _path$[ebp]
  00128	50		 push	 eax
  00129	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	83 c1 38	 add	 ecx, 56			; 00000038H
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 23   : 	return CDib::AttachMapFile(path,TRUE);

  00135	6a 01		 push	 1
  00137	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00140	50		 push	 eax
  00141	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	e8 00 00 00 00	 call	 ?AttachMapFile@CDib@@IAEHPBDH@Z ; CDib::AttachMapFile
  00149	89 45 f0	 mov	 DWORD PTR $T198108[ebp], eax
  0014c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00153	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0015c	8b 45 f0	 mov	 eax, DWORD PTR $T198108[ebp]

; 24   : }

  0015f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00162	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L198109:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T198113
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CDibBitmap::LoadFromFile
PUBLIC	?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUCutRect@CDib@@@Z ; CDibBitmap::LoadFromFile
EXTRN	?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z:NEAR ; CDib::AttachMapFile2
xdata$x	SEGMENT
$T198124 DD	0ffffffffH
	DD	FLAT:$L198120
$T198122 DD	019930520H
	DD	01H
	DD	FLAT:$T198124
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T198119 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
_pCutRect$ = 12						; size = 4
?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUCutRect@CDib@@@Z PROC NEAR ; CDibBitmap::LoadFromFile
; _this$ = ecx

; 26   : {

  00170	55		 push	 ebp
  00171	8b ec		 mov	 ebp, esp
  00173	6a ff		 push	 -1
  00175	68 00 00 00 00	 push	 __ehhandler$?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUCutRect@CDib@@@Z
  0017a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00180	50		 push	 eax
  00181	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00188	83 ec 08	 sub	 esp, 8
  0018b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0018e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 27   : 	m_path = path;

  00195	8d 45 08	 lea	 eax, DWORD PTR _path$[ebp]
  00198	50		 push	 eax
  00199	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0019c	83 c1 38	 add	 ecx, 56			; 00000038H
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 28   : 	return CDib::AttachMapFile2(path,pCutRect,TRUE);

  001a5	6a 01		 push	 1
  001a7	8b 4d 0c	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  001aa	51		 push	 ecx
  001ab	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  001b4	50		 push	 eax
  001b5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b8	e8 00 00 00 00	 call	 ?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z ; CDib::AttachMapFile2
  001bd	89 45 f0	 mov	 DWORD PTR $T198119[ebp], eax
  001c0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001c7	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  001ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001d0	8b 45 f0	 mov	 eax, DWORD PTR $T198119[ebp]

; 29   : }

  001d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
$L198120:
  00013	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUCutRect@CDib@@@Z:
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T198122
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUCutRect@CDib@@@Z ENDP ; CDibBitmap::LoadFromFile
PUBLIC	?LoadFromMem@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAXIPAUCutRect@CDib@@@Z ; CDibBitmap::LoadFromMem
EXTRN	?AttachMapFile2@CDib@@IAEHPAXIPAUCutRect@1@H@Z:NEAR ; CDib::AttachMapFile2
xdata$x	SEGMENT
$T198131 DD	0ffffffffH
	DD	FLAT:$L198127
$T198129 DD	019930520H
	DD	01H
	DD	FLAT:$T198131
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T198126 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
_pVoid$ = 12						; size = 4
_nSize$ = 16						; size = 4
_pCutRect$ = 20						; size = 4
?LoadFromMem@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAXIPAUCutRect@CDib@@@Z PROC NEAR ; CDibBitmap::LoadFromMem
; _this$ = ecx

; 31   : {

  001f0	55		 push	 ebp
  001f1	8b ec		 mov	 ebp, esp
  001f3	6a ff		 push	 -1
  001f5	68 00 00 00 00	 push	 __ehhandler$?LoadFromMem@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAXIPAUCutRect@CDib@@@Z
  001fa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00200	50		 push	 eax
  00201	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00208	83 ec 08	 sub	 esp, 8
  0020b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0020e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 32   : 	m_path = path;

  00215	8d 45 08	 lea	 eax, DWORD PTR _path$[ebp]
  00218	50		 push	 eax
  00219	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0021c	83 c1 38	 add	 ecx, 56			; 00000038H
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 33   : 	return CDib::AttachMapFile2(pVoid,nSize, pCutRect,TRUE);

  00225	6a 01		 push	 1
  00227	8b 4d 14	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  0022a	51		 push	 ecx
  0022b	8b 55 10	 mov	 edx, DWORD PTR _nSize$[ebp]
  0022e	52		 push	 edx
  0022f	8b 45 0c	 mov	 eax, DWORD PTR _pVoid$[ebp]
  00232	50		 push	 eax
  00233	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00236	e8 00 00 00 00	 call	 ?AttachMapFile2@CDib@@IAEHPAXIPAUCutRect@1@H@Z ; CDib::AttachMapFile2
  0023b	89 45 f0	 mov	 DWORD PTR $T198126[ebp], eax
  0023e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00245	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0024e	8b 45 f0	 mov	 eax, DWORD PTR $T198126[ebp]

; 34   : }

  00251	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00254	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0025b	8b e5		 mov	 esp, ebp
  0025d	5d		 pop	 ebp
  0025e	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
text$x	SEGMENT
$L198127:
  00026	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00029	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?LoadFromMem@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAXIPAUCutRect@CDib@@@Z:
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T198129
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadFromMem@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAXIPAUCutRect@CDib@@@Z ENDP ; CDibBitmap::LoadFromMem
PUBLIC	?LoadFromID@CDibBitmap@@QAEHI@Z			; CDibBitmap::LoadFromID
EXTRN	?AttachMemory@CDib@@QAEHPAXH0@Z:NEAR		; CDib::AttachMemory
EXTRN	__imp__FindResourceA@12:NEAR
EXTRN	__imp__LoadResource@8:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_lpv$ = -4						; size = 4
_ID$ = 8						; size = 4
?LoadFromID@CDibBitmap@@QAEHI@Z PROC NEAR		; CDibBitmap::LoadFromID
; _this$ = ecx

; 36   : {

  00270	55		 push	 ebp
  00271	8b ec		 mov	 ebp, esp
  00273	83 ec 08	 sub	 esp, 8
  00276	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 37   : 	LPVOID lpv = (LPVOID) ::LoadResource(NULL,
; 38   :         ::FindResource(NULL, MAKEINTRESOURCE(ID),
; 39   :                        RT_BITMAP));

  00279	6a 02		 push	 2
  0027b	0f b7 45 08	 movzx	 eax, WORD PTR _ID$[ebp]
  0027f	50		 push	 eax
  00280	6a 00		 push	 0
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  00288	50		 push	 eax
  00289	6a 00		 push	 0
  0028b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8
  00291	89 45 fc	 mov	 DWORD PTR _lpv$[ebp], eax

; 40   : 	return CDib::AttachMemory(lpv);

  00294	6a 00		 push	 0
  00296	6a 00		 push	 0
  00298	8b 4d fc	 mov	 ecx, DWORD PTR _lpv$[ebp]
  0029b	51		 push	 ecx
  0029c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0029f	e8 00 00 00 00	 call	 ?AttachMemory@CDib@@QAEHPAXH0@Z ; CDib::AttachMemory

; 41   : }

  002a4	8b e5		 mov	 esp, ebp
  002a6	5d		 pop	 ebp
  002a7	c2 04 00	 ret	 4
?LoadFromID@CDibBitmap@@QAEHI@Z ENDP			; CDibBitmap::LoadFromID
_TEXT	ENDS
PUBLIC	?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ		; CDC::GetSafeHdc
PUBLIC	?Width@CRect@@QBEHXZ				; CRect::Width
PUBLIC	?Height@CRect@@QBEHXZ				; CRect::Height
PUBLIC	??9CRect@@QBEHABUtagRECT@@@Z			; CRect::operator!=
PUBLIC	?GetShowRect@CDibBitmap@@AAEXAAVCRect@@V2@@Z	; CDibBitmap::GetShowRect
PUBLIC	?DrawStrechFromCenter@CDibBitmap@@QAEHPAVCDC@@@Z ; CDibBitmap::DrawStrechFromCenter
EXTRN	__imp__StretchDIBits@52:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T198134 = -32						; size = 16
_imgrc$197415 = -16					; size = 16
_pDC$ = 8						; size = 4
?DrawStrechFromCenter@CDibBitmap@@QAEHPAVCDC@@@Z PROC NEAR ; CDibBitmap::DrawStrechFromCenter
; _this$ = ecx

; 44   : {

  002b0	55		 push	 ebp
  002b1	8b ec		 mov	 ebp, esp
  002b3	83 ec 24	 sub	 esp, 36			; 00000024H
  002b6	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 45   : 	if(m_rect!= CRect(0,0,0,0))

  002b9	6a 00		 push	 0
  002bb	6a 00		 push	 0
  002bd	6a 00		 push	 0
  002bf	6a 00		 push	 0
  002c1	8d 4d e0	 lea	 ecx, DWORD PTR $T198134[ebp]
  002c4	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  002c9	50		 push	 eax
  002ca	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  002cd	83 c1 3c	 add	 ecx, 60			; 0000003cH
  002d0	e8 00 00 00 00	 call	 ??9CRect@@QBEHABUtagRECT@@@Z ; CRect::operator!=
  002d5	85 c0		 test	 eax, eax
  002d7	0f 84 b1 00 00
	00		 je	 $L197414

; 46   : 	{
; 47   : 		CRect imgrc(0,0,m_lpBMIH->biWidth,m_lpBMIH->biHeight);

  002dd	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  002e0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002e3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002e6	52		 push	 edx
  002e7	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  002ea	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002ed	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002f0	52		 push	 edx
  002f1	6a 00		 push	 0
  002f3	6a 00		 push	 0
  002f5	8d 4d f0	 lea	 ecx, DWORD PTR _imgrc$197415[ebp]
  002f8	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect

; 48   : 		GetShowRect(imgrc,m_rect);

  002fd	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00300	83 c0 3c	 add	 eax, 60			; 0000003cH
  00303	83 ec 10	 sub	 esp, 16			; 00000010H
  00306	8b cc		 mov	 ecx, esp
  00308	8b 10		 mov	 edx, DWORD PTR [eax]
  0030a	89 11		 mov	 DWORD PTR [ecx], edx
  0030c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0030f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00312	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00315	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00318	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0031b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0031e	8d 4d f0	 lea	 ecx, DWORD PTR _imgrc$197415[ebp]
  00321	51		 push	 ecx
  00322	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00325	e8 00 00 00 00	 call	 ?GetShowRect@CDibBitmap@@AAEXAAVCRect@@V2@@Z ; CDibBitmap::GetShowRect

; 49   : 		::StretchDIBits(pDC->GetSafeHdc(), m_rect.left,m_rect.top,m_rect.Width(),m_rect.Height(),
; 50   : 			imgrc.left, imgrc.top, imgrc.Width(), imgrc.Height(),	
; 51   : 			m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  0032a	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  0032f	6a 00		 push	 0
  00331	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00334	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00337	50		 push	 eax
  00338	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0033b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0033e	52		 push	 edx
  0033f	8d 4d f0	 lea	 ecx, DWORD PTR _imgrc$197415[ebp]
  00342	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00347	50		 push	 eax
  00348	8d 4d f0	 lea	 ecx, DWORD PTR _imgrc$197415[ebp]
  0034b	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00350	50		 push	 eax
  00351	8b 45 f4	 mov	 eax, DWORD PTR _imgrc$197415[ebp+4]
  00354	50		 push	 eax
  00355	8b 4d f0	 mov	 ecx, DWORD PTR _imgrc$197415[ebp]
  00358	51		 push	 ecx
  00359	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0035c	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0035f	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00364	50		 push	 eax
  00365	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00368	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0036b	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00370	50		 push	 eax
  00371	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00374	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00377	50		 push	 eax
  00378	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0037b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0037e	52		 push	 edx
  0037f	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00382	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  00387	50		 push	 eax
  00388	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52
$L197414:

; 52   : 	}
; 53   : 	return TRUE;

  0038e	b8 01 00 00 00	 mov	 eax, 1

; 54   : }

  00393	8b e5		 mov	 esp, ebp
  00395	5d		 pop	 ebp
  00396	c2 04 00	 ret	 4
?DrawStrechFromCenter@CDibBitmap@@QAEHPAVCDC@@@Z ENDP	; CDibBitmap::DrawStrechFromCenter
_TEXT	ENDS
PUBLIC	?DeflateRect@CRect@@QAEXHHHH@Z			; CRect::DeflateRect
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -44						; size = 4
_temprc$197427 = -40					; size = 16
_newwidth$197428 = -24					; size = 4
_newheight$197425 = -20					; size = 4
_temprc$197424 = -16					; size = 16
_Imgrc$ = 8						; size = 4
_Destrc$ = 12						; size = 16
?GetShowRect@CDibBitmap@@AAEXAAVCRect@@V2@@Z PROC NEAR	; CDibBitmap::GetShowRect
; _this$ = ecx

; 57   : {

  003a0	55		 push	 ebp
  003a1	8b ec		 mov	 ebp, esp
  003a3	83 ec 2c	 sub	 esp, 44			; 0000002cH
  003a6	56		 push	 esi
  003a7	57		 push	 edi
  003a8	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 	if(Destrc.Width()*Imgrc.Height() - Destrc.Height()*Imgrc.Width() > 0)

  003ab	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  003ae	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  003b3	8b f0		 mov	 esi, eax
  003b5	8b 4d 08	 mov	 ecx, DWORD PTR _Imgrc$[ebp]
  003b8	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  003bd	0f af f0	 imul	 esi, eax
  003c0	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  003c3	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  003c8	8b f8		 mov	 edi, eax
  003ca	8b 4d 08	 mov	 ecx, DWORD PTR _Imgrc$[ebp]
  003cd	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  003d2	0f af f8	 imul	 edi, eax
  003d5	2b f7		 sub	 esi, edi
  003d7	85 f6		 test	 esi, esi
  003d9	7e 71		 jle	 SHORT $L197423

; 59   : 	{
; 60   : 		CRect temprc = Imgrc;

  003db	8b 45 08	 mov	 eax, DWORD PTR _Imgrc$[ebp]
  003de	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e0	89 4d f0	 mov	 DWORD PTR _temprc$197424[ebp], ecx
  003e3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003e6	89 55 f4	 mov	 DWORD PTR _temprc$197424[ebp+4], edx
  003e9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003ec	89 4d f8	 mov	 DWORD PTR _temprc$197424[ebp+8], ecx
  003ef	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  003f2	89 55 fc	 mov	 DWORD PTR _temprc$197424[ebp+12], edx

; 61   : 		int newheight;
; 62   : 		newheight = Imgrc.Width() * Destrc.Height()/Destrc.Width();

  003f5	8b 4d 08	 mov	 ecx, DWORD PTR _Imgrc$[ebp]
  003f8	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  003fd	8b f0		 mov	 esi, eax
  003ff	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  00402	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00407	0f af f0	 imul	 esi, eax
  0040a	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  0040d	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00412	8b c8		 mov	 ecx, eax
  00414	8b c6		 mov	 eax, esi
  00416	99		 cdq
  00417	f7 f9		 idiv	 ecx
  00419	89 45 ec	 mov	 DWORD PTR _newheight$197425[ebp], eax

; 63   : 		Imgrc.DeflateRect(0,(temprc.Height() - newheight)/2,0,(temprc.Height() - newheight)/2);

  0041c	8d 4d f0	 lea	 ecx, DWORD PTR _temprc$197424[ebp]
  0041f	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00424	2b 45 ec	 sub	 eax, DWORD PTR _newheight$197425[ebp]
  00427	99		 cdq
  00428	2b c2		 sub	 eax, edx
  0042a	d1 f8		 sar	 eax, 1
  0042c	50		 push	 eax
  0042d	6a 00		 push	 0
  0042f	8d 4d f0	 lea	 ecx, DWORD PTR _temprc$197424[ebp]
  00432	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00437	2b 45 ec	 sub	 eax, DWORD PTR _newheight$197425[ebp]
  0043a	99		 cdq
  0043b	2b c2		 sub	 eax, edx
  0043d	d1 f8		 sar	 eax, 1
  0043f	50		 push	 eax
  00440	6a 00		 push	 0
  00442	8b 4d 08	 mov	 ecx, DWORD PTR _Imgrc$[ebp]
  00445	e8 00 00 00 00	 call	 ?DeflateRect@CRect@@QAEXHHHH@Z ; CRect::DeflateRect

; 64   : 	}
; 65   : 	else 

  0044a	eb 6f		 jmp	 SHORT $L197422
$L197423:

; 66   : 	{
; 67   : 		CRect temprc = Imgrc;

  0044c	8b 55 08	 mov	 edx, DWORD PTR _Imgrc$[ebp]
  0044f	8b 02		 mov	 eax, DWORD PTR [edx]
  00451	89 45 d8	 mov	 DWORD PTR _temprc$197427[ebp], eax
  00454	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00457	89 4d dc	 mov	 DWORD PTR _temprc$197427[ebp+4], ecx
  0045a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0045d	89 45 e0	 mov	 DWORD PTR _temprc$197427[ebp+8], eax
  00460	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00463	89 4d e4	 mov	 DWORD PTR _temprc$197427[ebp+12], ecx

; 68   : 		int newwidth;
; 69   : 		newwidth = temprc.Height() * Destrc.Width() / Destrc.Height();

  00466	8d 4d d8	 lea	 ecx, DWORD PTR _temprc$197427[ebp]
  00469	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0046e	8b f0		 mov	 esi, eax
  00470	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  00473	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00478	0f af f0	 imul	 esi, eax
  0047b	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  0047e	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00483	8b c8		 mov	 ecx, eax
  00485	8b c6		 mov	 eax, esi
  00487	99		 cdq
  00488	f7 f9		 idiv	 ecx
  0048a	89 45 e8	 mov	 DWORD PTR _newwidth$197428[ebp], eax

; 70   : 		Imgrc.DeflateRect((temprc.Width() - newwidth)/2,0,(temprc.Width() - newwidth)/2,0);

  0048d	6a 00		 push	 0
  0048f	8d 4d d8	 lea	 ecx, DWORD PTR _temprc$197427[ebp]
  00492	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00497	2b 45 e8	 sub	 eax, DWORD PTR _newwidth$197428[ebp]
  0049a	99		 cdq
  0049b	2b c2		 sub	 eax, edx
  0049d	d1 f8		 sar	 eax, 1
  0049f	50		 push	 eax
  004a0	6a 00		 push	 0
  004a2	8d 4d d8	 lea	 ecx, DWORD PTR _temprc$197427[ebp]
  004a5	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  004aa	2b 45 e8	 sub	 eax, DWORD PTR _newwidth$197428[ebp]
  004ad	99		 cdq
  004ae	2b c2		 sub	 eax, edx
  004b0	d1 f8		 sar	 eax, 1
  004b2	50		 push	 eax
  004b3	8b 4d 08	 mov	 ecx, DWORD PTR _Imgrc$[ebp]
  004b6	e8 00 00 00 00	 call	 ?DeflateRect@CRect@@QAEXHHHH@Z ; CRect::DeflateRect
$L197422:

; 71   : 	}
; 72   : }

  004bb	5f		 pop	 edi
  004bc	5e		 pop	 esi
  004bd	8b e5		 mov	 esp, ebp
  004bf	5d		 pop	 ebp
  004c0	c2 14 00	 ret	 20			; 00000014H
?GetShowRect@CDibBitmap@@AAEXAAVCRect@@V2@@Z ENDP	; CDibBitmap::GetShowRect
_TEXT	ENDS
PUBLIC	?Draw@CDibBitmap@@QAEHPAVCDC@@HHHHHHHH@Z	; CDibBitmap::Draw
PUBLIC	?ValidCheck@CDibBitmap@@QAEHXZ			; CDibBitmap::ValidCheck
EXTRN	?SetStretchBltMode@CDC@@QAEHH@Z:NEAR		; CDC::SetStretchBltMode
EXTRN	__imp__SelectPalette@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hOldPalette$ = -4					; size = 4
_pDC$ = 8						; size = 4
_srcX$ = 12						; size = 4
_srcY$ = 16						; size = 4
_srcW$ = 20						; size = 4
_srcH$ = 24						; size = 4
_dstX$ = 28						; size = 4
_dstY$ = 32						; size = 4
_dstW$ = 36						; size = 4
_dstH$ = 40						; size = 4
?Draw@CDibBitmap@@QAEHPAVCDC@@HHHHHHHH@Z PROC NEAR	; CDibBitmap::Draw
; _this$ = ecx

; 75   : {

  004d0	55		 push	 ebp
  004d1	8b ec		 mov	 ebp, esp
  004d3	83 ec 08	 sub	 esp, 8
  004d6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 76   : 	if(!ValidCheck())

  004d9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004dc	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  004e1	85 c0		 test	 eax, eax
  004e3	75 07		 jne	 SHORT $L197441

; 77   : 		return FALSE;

  004e5	33 c0		 xor	 eax, eax
  004e7	e9 b2 00 00 00	 jmp	 $L197440
$L197441:

; 78   : 	if(m_lpBMIH == NULL) return FALSE;

  004ec	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004ef	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  004f3	75 07		 jne	 SHORT $L197442
  004f5	33 c0		 xor	 eax, eax
  004f7	e9 a2 00 00 00	 jmp	 $L197440
$L197442:

; 79   : 	HPALETTE hOldPalette = NULL;

  004fc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hOldPalette$[ebp], 0

; 80   : 	if(m_hPalette != NULL) {

  00503	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00506	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  0050a	74 1b		 je	 SHORT $L197444

; 81   : 		hOldPalette = ::SelectPalette(pDC->GetSafeHdc(), m_hPalette, TRUE);

  0050c	6a 01		 push	 1
  0050e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00511	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00514	50		 push	 eax
  00515	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00518	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0051d	50		 push	 eax
  0051e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  00524	89 45 fc	 mov	 DWORD PTR _hOldPalette$[ebp], eax
$L197444:

; 82   : 	}
; 83   : 	pDC->SetStretchBltMode(COLORONCOLOR);

  00527	6a 03		 push	 3
  00529	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0052c	e8 00 00 00 00	 call	 ?SetStretchBltMode@CDC@@QAEHH@Z ; CDC::SetStretchBltMode

; 84   : 
; 85   : 	::StretchDIBits(pDC->GetSafeHdc(), srcX, srcY, srcW, srcH, dstX, m_lpBMIH->biHeight - dstY, dstW, dstH ,
; 86   : 		m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  00531	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00536	6a 00		 push	 0
  00538	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0053b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0053e	52		 push	 edx
  0053f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00542	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00545	51		 push	 ecx
  00546	8b 55 28	 mov	 edx, DWORD PTR _dstH$[ebp]
  00549	52		 push	 edx
  0054a	8b 45 24	 mov	 eax, DWORD PTR _dstW$[ebp]
  0054d	50		 push	 eax
  0054e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00551	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00554	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00557	2b 45 20	 sub	 eax, DWORD PTR _dstY$[ebp]
  0055a	50		 push	 eax
  0055b	8b 4d 1c	 mov	 ecx, DWORD PTR _dstX$[ebp]
  0055e	51		 push	 ecx
  0055f	8b 55 18	 mov	 edx, DWORD PTR _srcH$[ebp]
  00562	52		 push	 edx
  00563	8b 45 14	 mov	 eax, DWORD PTR _srcW$[ebp]
  00566	50		 push	 eax
  00567	8b 4d 10	 mov	 ecx, DWORD PTR _srcY$[ebp]
  0056a	51		 push	 ecx
  0056b	8b 55 0c	 mov	 edx, DWORD PTR _srcX$[ebp]
  0056e	52		 push	 edx
  0056f	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00572	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  00577	50		 push	 eax
  00578	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52

; 87   : 	if (hOldPalette != NULL)

  0057e	83 7d fc 00	 cmp	 DWORD PTR _hOldPalette$[ebp], 0
  00582	74 15		 je	 SHORT $L197447

; 88   : 	{
; 89   : 		::SelectPalette(pDC->GetSafeHdc(), hOldPalette, TRUE);

  00584	6a 01		 push	 1
  00586	8b 45 fc	 mov	 eax, DWORD PTR _hOldPalette$[ebp]
  00589	50		 push	 eax
  0058a	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0058d	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  00592	50		 push	 eax
  00593	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
$L197447:

; 90   : 	}
; 91   : 	return TRUE;

  00599	b8 01 00 00 00	 mov	 eax, 1
$L197440:

; 92   : }

  0059e	8b e5		 mov	 esp, ebp
  005a0	5d		 pop	 ebp
  005a1	c2 24 00	 ret	 36			; 00000024H
?Draw@CDibBitmap@@QAEHPAVCDC@@HHHHHHHH@Z ENDP		; CDibBitmap::Draw
; Function compile flags: /Odt
_this$ = -4						; size = 4
?ValidCheck@CDibBitmap@@QAEHXZ PROC NEAR		; CDibBitmap::ValidCheck
; _this$ = ecx

; 95   : {

  005b0	55		 push	 ebp
  005b1	8b ec		 mov	 ebp, esp
  005b3	51		 push	 ecx
  005b4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   : 	if(this == NULL)

  005b7	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  005bb	75 04		 jne	 SHORT $L197451

; 97   : 		return false;

  005bd	33 c0		 xor	 eax, eax
  005bf	eb 14		 jmp	 SHORT $L197450
$L197451:

; 98   : 	if(!this->is_Loaded)

  005c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005c4	0f b6 48 5c	 movzx	 ecx, BYTE PTR [eax+92]
  005c8	85 c9		 test	 ecx, ecx
  005ca	75 04		 jne	 SHORT $L197452

; 99   : 	{
; 100  : #ifdef _DEBUG
; 101  : 		if(!has_PopupError)
; 102  : 			;//AfxMessageBox("Í¼Æ¬ " + this->m_strName  + " ÎÞÐ§");
; 103  : 		has_PopupError = true;
; 104  : #endif
; 105  : 		return FALSE;

  005cc	33 c0		 xor	 eax, eax
  005ce	eb 05		 jmp	 SHORT $L197450
$L197452:

; 106  : 	}
; 107  : 	return TRUE;

  005d0	b8 01 00 00 00	 mov	 eax, 1
$L197450:

; 108  : }

  005d5	8b e5		 mov	 esp, ebp
  005d7	5d		 pop	 ebp
  005d8	c3		 ret	 0
?ValidCheck@CDibBitmap@@QAEHXZ ENDP			; CDibBitmap::ValidCheck
_TEXT	ENDS
PUBLIC	??0CPoint@@QAE@HH@Z				; CPoint::CPoint
PUBLIC	?Size@CRect@@QBE?AVCSize@@XZ			; CRect::Size
PUBLIC	?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z		; CDibBitmap::Draw
EXTRN	?Draw@CDib@@IAEHPAVCDC@@VCPoint@@VCSize@@HKW4DrawMode@1@@Z:NEAR ; CDib::Draw
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T198140 = -16						; size = 8
$T198139 = -8						; size = 8
_pDC$ = 8						; size = 4
_isBKTransparent$ = 12					; size = 4
_color$ = 16						; size = 4
_mode$ = 20						; size = 4
?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z PROC NEAR		; CDibBitmap::Draw
; _this$ = ecx

; 110  : {

  005e0	55		 push	 ebp
  005e1	8b ec		 mov	 ebp, esp
  005e3	83 ec 14	 sub	 esp, 20			; 00000014H
  005e6	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 111  : 	if(!ValidCheck())

  005e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  005ec	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  005f1	85 c0		 test	 eax, eax
  005f3	75 04		 jne	 SHORT $L197460

; 112  : 		return FALSE;

  005f5	33 c0		 xor	 eax, eax
  005f7	eb 4b		 jmp	 SHORT $L197459
$L197460:

; 113  : 	return CDib::Draw(pDC, CPoint(m_rect.left,m_rect.top), m_rect.Size(),isBKTransparent, color, (CDib::DrawMode)mode);

  005f9	8b 45 14	 mov	 eax, DWORD PTR _mode$[ebp]
  005fc	50		 push	 eax
  005fd	8b 4d 10	 mov	 ecx, DWORD PTR _color$[ebp]
  00600	51		 push	 ecx
  00601	8b 55 0c	 mov	 edx, DWORD PTR _isBKTransparent$[ebp]
  00604	52		 push	 edx
  00605	8d 45 f8	 lea	 eax, DWORD PTR $T198139[ebp]
  00608	50		 push	 eax
  00609	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0060c	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0060f	e8 00 00 00 00	 call	 ?Size@CRect@@QBE?AVCSize@@XZ ; CRect::Size
  00614	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00617	51		 push	 ecx
  00618	8b 10		 mov	 edx, DWORD PTR [eax]
  0061a	52		 push	 edx
  0061b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0061e	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00621	51		 push	 ecx
  00622	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00625	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00628	50		 push	 eax
  00629	8d 4d f0	 lea	 ecx, DWORD PTR $T198140[ebp]
  0062c	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint
  00631	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00634	51		 push	 ecx
  00635	8b 10		 mov	 edx, DWORD PTR [eax]
  00637	52		 push	 edx
  00638	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  0063b	50		 push	 eax
  0063c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0063f	e8 00 00 00 00	 call	 ?Draw@CDib@@IAEHPAVCDC@@VCPoint@@VCSize@@HKW4DrawMode@1@@Z ; CDib::Draw
$L197459:

; 114  : }

  00644	8b e5		 mov	 esp, ebp
  00646	5d		 pop	 ebp
  00647	c2 10 00	 ret	 16			; 00000010H
?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ENDP		; CDibBitmap::Draw
_TEXT	ENDS
PUBLIC	?DrawImageList@CDibBitmap@@QAEHPAVCDC@@HUtagPOINT@@H@Z ; CDibBitmap::DrawImageList
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nHight$ = -8						; size = 4
_nWidth$ = -4						; size = 4
_pDC$ = 8						; size = 4
_nIndex$ = 12						; size = 4
_pt$ = 16						; size = 8
_nCount$ = 24						; size = 4
?DrawImageList@CDibBitmap@@QAEHPAVCDC@@HUtagPOINT@@H@Z PROC NEAR ; CDibBitmap::DrawImageList
; _this$ = ecx

; 116  : {

  00650	55		 push	 ebp
  00651	8b ec		 mov	 ebp, esp
  00653	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00656	56		 push	 esi
  00657	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 117  : 	if( (m_count <= 0) || (nIndex>=m_count) || (nCount<1) )

  0065a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0065d	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  00661	7e 11		 jle	 SHORT $L197472
  00663	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00666	8b 55 0c	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00669	3b 51 64	 cmp	 edx, DWORD PTR [ecx+100]
  0066c	7d 06		 jge	 SHORT $L197472
  0066e	83 7d 18 01	 cmp	 DWORD PTR _nCount$[ebp], 1
  00672	7d 07		 jge	 SHORT $L197471
$L197472:

; 118  : 		return FALSE;

  00674	33 c0		 xor	 eax, eax
  00676	e9 f4 00 00 00	 jmp	 $L197470
$L197471:

; 119  : 	
; 120  : 
; 121  : 	if(!ValidCheck())

  0067b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0067e	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  00683	85 c0		 test	 eax, eax
  00685	75 07		 jne	 SHORT $L197473

; 122  : 		return FALSE;

  00687	33 c0		 xor	 eax, eax
  00689	e9 e1 00 00 00	 jmp	 $L197470
$L197473:

; 123  : 	if(m_lpBMIH == NULL) return FALSE;

  0068e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00691	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00695	75 07		 jne	 SHORT $L197474
  00697	33 c0		 xor	 eax, eax
  00699	e9 d1 00 00 00	 jmp	 $L197470
$L197474:

; 124  : 	if(m_hPalette != NULL) {

  0069e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  006a1	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  006a5	74 18		 je	 SHORT $L197475

; 125  : 		::SelectPalette(pDC->GetSafeHdc(), m_hPalette, TRUE);

  006a7	6a 01		 push	 1
  006a9	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  006ac	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  006af	50		 push	 eax
  006b0	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  006b3	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  006b8	50		 push	 eax
  006b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
$L197475:

; 126  : 	}
; 127  : 	pDC->SetStretchBltMode(COLORONCOLOR);

  006bf	6a 03		 push	 3
  006c1	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  006c4	e8 00 00 00 00	 call	 ?SetStretchBltMode@CDC@@QAEHH@Z ; CDC::SetStretchBltMode

; 128  : 
; 129  : 	int nWidth;
; 130  : 	if( nCount == 1 )

  006c9	83 7d 18 01	 cmp	 DWORD PTR _nCount$[ebp], 1
  006cd	75 15		 jne	 SHORT $L197477

; 131  : 	{
; 132  : 		nWidth =m_lpBMIH->biWidth/m_count;

  006cf	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  006d2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  006d5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  006d8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  006db	99		 cdq
  006dc	f7 79 64	 idiv	 DWORD PTR [ecx+100]
  006df	89 45 fc	 mov	 DWORD PTR _nWidth$[ebp], eax

; 133  : 	}
; 134  : 	else

  006e2	eb 12		 jmp	 SHORT $L197478
$L197477:

; 135  : 	{
; 136  : 		nWidth = m_rect.Width()  / nCount;

  006e4	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  006e7	83 c1 3c	 add	 ecx, 60			; 0000003cH
  006ea	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  006ef	99		 cdq
  006f0	f7 7d 18	 idiv	 DWORD PTR _nCount$[ebp]
  006f3	89 45 fc	 mov	 DWORD PTR _nWidth$[ebp], eax
$L197478:

; 137  : 	}
; 138  : 	int nHight = m_rect.Height();

  006f6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  006f9	83 c1 3c	 add	 ecx, 60			; 0000003cH
  006fc	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00701	89 45 f8	 mov	 DWORD PTR _nHight$[ebp], eax

; 139  : 	::StretchDIBits(pDC->GetSafeHdc(), pt.x, pt.y, nWidth,nHight, m_lpBMIH->biWidth/m_count*nIndex, 0, m_lpBMIH->biWidth/m_count, m_lpBMIH->biHeight ,
; 140  : 		m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  00704	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00709	6a 00		 push	 0
  0070b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0070e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00711	50		 push	 eax
  00712	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00715	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00718	52		 push	 edx
  00719	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0071c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0071f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00722	52		 push	 edx
  00723	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00726	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00729	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  0072c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0072f	99		 cdq
  00730	f7 7e 64	 idiv	 DWORD PTR [esi+100]
  00733	50		 push	 eax
  00734	6a 00		 push	 0
  00736	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00739	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0073c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0073f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00742	99		 cdq
  00743	f7 79 64	 idiv	 DWORD PTR [ecx+100]
  00746	0f af 45 0c	 imul	 eax, DWORD PTR _nIndex$[ebp]
  0074a	50		 push	 eax
  0074b	8b 55 f8	 mov	 edx, DWORD PTR _nHight$[ebp]
  0074e	52		 push	 edx
  0074f	8b 45 fc	 mov	 eax, DWORD PTR _nWidth$[ebp]
  00752	50		 push	 eax
  00753	8b 4d 14	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  00756	51		 push	 ecx
  00757	8b 55 10	 mov	 edx, DWORD PTR _pt$[ebp]
  0075a	52		 push	 edx
  0075b	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0075e	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  00763	50		 push	 eax
  00764	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52

; 141  : 	return TRUE;

  0076a	b8 01 00 00 00	 mov	 eax, 1
$L197470:

; 142  : }

  0076f	5e		 pop	 esi
  00770	8b e5		 mov	 esp, ebp
  00772	5d		 pop	 ebp
  00773	c2 14 00	 ret	 20			; 00000014H
?DrawImageList@CDibBitmap@@QAEHPAVCDC@@HUtagPOINT@@H@Z ENDP ; CDibBitmap::DrawImageList
_TEXT	ENDS
PUBLIC	?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z		; CDibBitmap::SetCDibRect
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rect$ = 8						; size = 16
?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z PROC NEAR	; CDibBitmap::SetCDibRect
; _this$ = ecx

; 144  : {

  00780	55		 push	 ebp
  00781	8b ec		 mov	 ebp, esp
  00783	51		 push	 ecx
  00784	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 145  : 	if(!ValidCheck())

  00787	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0078a	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  0078f	85 c0		 test	 eax, eax
  00791	75 02		 jne	 SHORT $L197486

; 146  : 		return;

  00793	eb 1d		 jmp	 SHORT $L197485
$L197486:

; 147  : 	m_rect = rect;

  00795	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00798	83 c0 3c	 add	 eax, 60			; 0000003cH
  0079b	8b 4d 08	 mov	 ecx, DWORD PTR _rect$[ebp]
  0079e	89 08		 mov	 DWORD PTR [eax], ecx
  007a0	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp+4]
  007a3	89 50 04	 mov	 DWORD PTR [eax+4], edx
  007a6	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp+8]
  007a9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  007ac	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp+12]
  007af	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L197485:

; 148  : }

  007b2	8b e5		 mov	 esp, ebp
  007b4	5d		 pop	 ebp
  007b5	c2 10 00	 ret	 16			; 00000010H
?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ENDP		; CDibBitmap::SetCDibRect
_TEXT	ENDS
PUBLIC	?SetCount@CDibBitmap@@QAEXH@Z			; CDibBitmap::SetCount
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nCount$ = 8						; size = 4
?SetCount@CDibBitmap@@QAEXH@Z PROC NEAR			; CDibBitmap::SetCount
; _this$ = ecx

; 150  : {

  007c0	55		 push	 ebp
  007c1	8b ec		 mov	 ebp, esp
  007c3	51		 push	 ecx
  007c4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 151  : 	m_count = nCount;

  007c7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007ca	8b 4d 08	 mov	 ecx, DWORD PTR _nCount$[ebp]
  007cd	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 152  : 
; 153  : }

  007d0	8b e5		 mov	 esp, ebp
  007d2	5d		 pop	 ebp
  007d3	c2 04 00	 ret	 4
?SetCount@CDibBitmap@@QAEXH@Z ENDP			; CDibBitmap::SetCount
_TEXT	ENDS
PUBLIC	?CreateBitmap@CDibBitmap@@QAEPAUHBITMAP__@@PAVCDC@@@Z ; CDibBitmap::CreateBitmap
PUBLIC	?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCDC@@@Z ; CDibBitmap::CreateRgnFromBitmap
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	__imp__CreateICA@16:NEAR
EXTRN	__imp__DeleteDC@4:NEAR
EXTRN	__imp__ExtCreateRegion@12:NEAR
EXTRN	__imp__GetDIBits@28:NEAR
EXTRN	__imp__GetObjectA@12:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv242 = -252						; size = 4
_this$ = -248						; size = 4
$T198158 = -244						; size = 4
$T198157 = -240						; size = 4
$T198156 = -236						; size = 4
$T198155 = -232						; size = 4
$T198154 = -228						; size = 4
$T198153 = -224						; size = 16
$T198152 = -208						; size = 4
$T198151 = -204						; size = 4
$T198150 = -200						; size = 16
$T198149 = -184						; size = 4
$T198148 = -180						; size = 4
$T198147 = -176						; size = 4
$T198146 = -172						; size = 4
$T198145 = -168						; size = 4
_i$197604 = -164					; size = 4
_pRgnDataNew$197594 = -160				; size = 4
_pRgnDataNew$197580 = -156				; size = 4
_k$197560 = -152					; size = 4
_old_bi$197514 = -148					; size = 4
_pClr$ = -144						; size = 4
_j$ = -140						; size = 4
_RGNDATAHEADER_SIZE$ = -136				; size = 4
_bi$ = -132						; size = 4
_bm$ = -128						; size = 24
_dwRectsCount$ = -104					; size = 4
_ismask$ = -97						; size = 1
_pRects$ = -96						; size = 4
_hRgn$ = -92						; size = 4
_clr_tbl$ = -88						; size = 4
_bmp$ = -84						; size = 24
_tmp$ = -57						; size = 1
_m_dwAlignedWidthBytes$ = -56				; size = 4
_pBits$ = -52						; size = 4
_ADD_RECTS_COUNT$ = -48					; size = 4
_Bpp$ = -41						; size = 1
_i$ = -40						; size = 4
_wasfirst$ = -33					; size = 1
_dc$ = -32						; size = 4
_hBmp$ = -28						; size = 4
_res$ = -24						; size = 4
_dwLineBackLen$ = -20					; size = 4
_pRgnData$ = -16					; size = 4
_bih$ = -12						; size = 4
_pColor$ = -8						; size = 4
_first$ = -4						; size = 4
_color$ = 8						; size = 4
_pDC$ = 12						; size = 4
?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCDC@@@Z PROC NEAR ; CDibBitmap::CreateRgnFromBitmap
; _this$ = ecx

; 155  : {

  007e0	55		 push	 ebp
  007e1	8b ec		 mov	 ebp, esp
  007e3	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  007e9	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 156  : 	if(!ValidCheck())

  007ef	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007f5	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  007fa	85 c0		 test	 eax, eax
  007fc	75 07		 jne	 SHORT $L197496

; 157  : 		return NULL;

  007fe	33 c0		 xor	 eax, eax
  00800	e9 73 06 00 00	 jmp	 $L197495
$L197496:

; 158  : 	HBITMAP hBmp = CreateBitmap(pDC);

  00805	8b 45 0c	 mov	 eax, DWORD PTR _pDC$[ebp]
  00808	50		 push	 eax
  00809	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0080f	e8 00 00 00 00	 call	 ?CreateBitmap@CDibBitmap@@QAEPAUHBITMAP__@@PAVCDC@@@Z ; CDibBitmap::CreateBitmap
  00814	89 45 e4	 mov	 DWORD PTR _hBmp$[ebp], eax

; 159  : 	// get image properties
; 160  : 	BITMAP bmp = { 0 };

  00817	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _bmp$[ebp], 0
  0081e	33 c9		 xor	 ecx, ecx
  00820	89 4d b0	 mov	 DWORD PTR _bmp$[ebp+4], ecx
  00823	89 4d b4	 mov	 DWORD PTR _bmp$[ebp+8], ecx
  00826	89 4d b8	 mov	 DWORD PTR _bmp$[ebp+12], ecx
  00829	89 4d bc	 mov	 DWORD PTR _bmp$[ebp+16], ecx
  0082c	89 4d c0	 mov	 DWORD PTR _bmp$[ebp+20], ecx

; 161  : 	GetObject( hBmp, sizeof(BITMAP), &bmp );

  0082f	8d 55 ac	 lea	 edx, DWORD PTR _bmp$[ebp]
  00832	52		 push	 edx
  00833	6a 18		 push	 24			; 00000018H
  00835	8b 45 e4	 mov	 eax, DWORD PTR _hBmp$[ebp]
  00838	50		 push	 eax
  00839	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetObjectA@12

; 162  : 	// allocate memory for extended image information
; 163  : 	LPBITMAPINFO bi = (LPBITMAPINFO) new BYTE[ sizeof(BITMAPINFO) + 8 ];

  0083f	6a 34		 push	 52			; 00000034H
  00841	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00846	83 c4 04	 add	 esp, 4
  00849	89 85 58 ff ff
	ff		 mov	 DWORD PTR $T198145[ebp], eax
  0084f	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR $T198145[ebp]
  00855	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _bi$[ebp], ecx

; 164  : 	memset( bi, 0, sizeof(BITMAPINFO) + 8 );

  0085b	6a 34		 push	 52			; 00000034H
  0085d	6a 00		 push	 0
  0085f	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _bi$[ebp]
  00865	52		 push	 edx
  00866	e8 00 00 00 00	 call	 _memset
  0086b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 165  : 	bi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

  0086e	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _bi$[ebp]
  00874	c7 00 28 00 00
	00		 mov	 DWORD PTR [eax], 40	; 00000028H

; 166  : 	// set window size
; 167  : 	//m_dwWidth	= bmp.bmWidth;		// bitmap width
; 168  : 	//m_dwHeight	= bmp.bmHeight;		// bitmap height
; 169  : 	// create temporary dc
; 170  : 	HDC dc = CreateIC( "DISPLAY",NULL,NULL,NULL );

  0087a	6a 00		 push	 0
  0087c	6a 00		 push	 0
  0087e	6a 00		 push	 0
  00880	68 00 00 00 00	 push	 OFFSET FLAT:$SG197508
  00885	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateICA@16
  0088b	89 45 e0	 mov	 DWORD PTR _dc$[ebp], eax

; 171  : 	// get extended information about image (length, compression, length of color table if exist, ...)
; 172  : 	DWORD res = GetDIBits( dc, hBmp, 0, bmp.bmHeight, 0, bi, DIB_RGB_COLORS );

  0088e	6a 00		 push	 0
  00890	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _bi$[ebp]
  00896	51		 push	 ecx
  00897	6a 00		 push	 0
  00899	8b 55 b4	 mov	 edx, DWORD PTR _bmp$[ebp+8]
  0089c	52		 push	 edx
  0089d	6a 00		 push	 0
  0089f	8b 45 e4	 mov	 eax, DWORD PTR _hBmp$[ebp]
  008a2	50		 push	 eax
  008a3	8b 4d e0	 mov	 ecx, DWORD PTR _dc$[ebp]
  008a6	51		 push	 ecx
  008a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDIBits@28
  008ad	89 45 e8	 mov	 DWORD PTR _res$[ebp], eax

; 173  : 	// allocate memory for image data (colors)
; 174  : 	LPBYTE pBits = new BYTE[ bi->bmiHeader.biSizeImage + 4 ];

  008b0	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _bi$[ebp]
  008b6	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  008b9	83 c0 04	 add	 eax, 4
  008bc	50		 push	 eax
  008bd	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  008c2	83 c4 04	 add	 esp, 4
  008c5	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T198146[ebp], eax
  008cb	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T198146[ebp]
  008d1	89 4d cc	 mov	 DWORD PTR _pBits$[ebp], ecx

; 175  : 	// allocate memory for color table
; 176  : 	if ( bi->bmiHeader.biBitCount == 8 )

  008d4	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _bi$[ebp]
  008da	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  008de	83 f8 08	 cmp	 eax, 8
  008e1	75 5e		 jne	 SHORT $L197513

; 177  : 	{
; 178  : 		// actually color table should be appended to this header(BITMAPINFO),
; 179  : 		// so we have to reallocate and copy it
; 180  : 		LPBITMAPINFO old_bi = bi;

  008e3	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _bi$[ebp]
  008e9	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _old_bi$197514[ebp], ecx

; 181  : 		// 255 - because there is one in BITMAPINFOHEADER
; 182  : 		bi = (LPBITMAPINFO)new char[ sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD) ];

  008ef	68 28 04 00 00	 push	 1064			; 00000428H
  008f4	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  008f9	83 c4 04	 add	 esp, 4
  008fc	89 85 50 ff ff
	ff		 mov	 DWORD PTR $T198147[ebp], eax
  00902	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR $T198147[ebp]
  00908	89 95 7c ff ff
	ff		 mov	 DWORD PTR _bi$[ebp], edx

; 183  : 		memcpy( bi, old_bi, sizeof(BITMAPINFO) );

  0090e	6a 2c		 push	 44			; 0000002cH
  00910	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _old_bi$197514[ebp]
  00916	50		 push	 eax
  00917	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _bi$[ebp]
  0091d	51		 push	 ecx
  0091e	e8 00 00 00 00	 call	 _memcpy
  00923	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 		// release old header
; 185  : 		delete old_bi;

  00926	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _old_bi$197514[ebp]
  0092c	89 95 4c ff ff
	ff		 mov	 DWORD PTR $T198148[ebp], edx
  00932	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR $T198148[ebp]
  00938	50		 push	 eax
  00939	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0093e	83 c4 04	 add	 esp, 4
$L197513:

; 186  : 	}
; 187  : 	// get bitmap info header
; 188  : 	BITMAPINFOHEADER& bih = bi->bmiHeader;

  00941	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _bi$[ebp]
  00947	89 4d f4	 mov	 DWORD PTR _bih$[ebp], ecx

; 189  : 	// get color table (for 256 color mode contains 256 entries of RGBQUAD(=DWORD))
; 190  : 	LPDWORD clr_tbl = (LPDWORD)&bi->bmiColors;

  0094a	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _bi$[ebp]
  00950	83 c2 28	 add	 edx, 40			; 00000028H
  00953	89 55 a8	 mov	 DWORD PTR _clr_tbl$[ebp], edx

; 191  : 	// fill bits buffer
; 192  : 	res = GetDIBits( dc, hBmp, 0, bih.biHeight, pBits, bi, DIB_RGB_COLORS );

  00956	6a 00		 push	 0
  00958	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _bi$[ebp]
  0095e	50		 push	 eax
  0095f	8b 4d cc	 mov	 ecx, DWORD PTR _pBits$[ebp]
  00962	51		 push	 ecx
  00963	8b 55 f4	 mov	 edx, DWORD PTR _bih$[ebp]
  00966	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00969	50		 push	 eax
  0096a	6a 00		 push	 0
  0096c	8b 4d e4	 mov	 ecx, DWORD PTR _hBmp$[ebp]
  0096f	51		 push	 ecx
  00970	8b 55 e0	 mov	 edx, DWORD PTR _dc$[ebp]
  00973	52		 push	 edx
  00974	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDIBits@28
  0097a	89 45 e8	 mov	 DWORD PTR _res$[ebp], eax

; 193  : 	DeleteDC( dc );

  0097d	8b 45 e0	 mov	 eax, DWORD PTR _dc$[ebp]
  00980	50		 push	 eax
  00981	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 194  : 
; 195  : 	BITMAP bm;
; 196  : 	GetObject( hBmp, sizeof(BITMAP), &bm );

  00987	8d 4d 80	 lea	 ecx, DWORD PTR _bm$[ebp]
  0098a	51		 push	 ecx
  0098b	6a 18		 push	 24			; 00000018H
  0098d	8b 55 e4	 mov	 edx, DWORD PTR _hBmp$[ebp]
  00990	52		 push	 edx
  00991	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetObjectA@12

; 197  : 	// shift bits and byte per pixel (for comparing colors)
; 198  : 	LPBYTE pClr = (LPBYTE)&color;

  00997	8d 45 08	 lea	 eax, DWORD PTR _color$[ebp]
  0099a	89 85 70 ff ff
	ff		 mov	 DWORD PTR _pClr$[ebp], eax

; 199  : 	// swap red and blue components
; 200  : 	BYTE tmp = pClr[0]; pClr[0] = pClr[2]; pClr[2] = tmp;

  009a0	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _pClr$[ebp]
  009a6	8a 11		 mov	 dl, BYTE PTR [ecx]
  009a8	88 55 c7	 mov	 BYTE PTR _tmp$[ebp], dl
  009ab	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _pClr$[ebp]
  009b1	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _pClr$[ebp]
  009b7	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  009ba	88 10		 mov	 BYTE PTR [eax], dl
  009bc	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _pClr$[ebp]
  009c2	8a 4d c7	 mov	 cl, BYTE PTR _tmp$[ebp]
  009c5	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 201  : 	// convert color if curent DC is 16-bit (5:6:5) or 15-bit (5:5:5)
; 202  : 	if ( bih.biBitCount == 16 )

  009c8	8b 55 f4	 mov	 edx, DWORD PTR _bih$[ebp]
  009cb	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  009cf	83 f8 10	 cmp	 eax, 16			; 00000010H
  009d2	75 3f		 jne	 SHORT $L197530

; 203  : 	{
; 204  : 		// for 16 bit
; 205  : 		color = ((DWORD)(pClr[0] & 0xf8) >> 3) |
; 206  : 				((DWORD)(pClr[1] & 0xfc) << 3) |
; 207  : 				((DWORD)(pClr[2] & 0xf8) << 8);

  009d4	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _pClr$[ebp]
  009da	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  009dd	81 e2 f8 00 00
	00		 and	 edx, 248		; 000000f8H
  009e3	c1 ea 03	 shr	 edx, 3
  009e6	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _pClr$[ebp]
  009ec	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  009f0	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  009f6	c1 e1 03	 shl	 ecx, 3
  009f9	0b d1		 or	 edx, ecx
  009fb	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _pClr$[ebp]
  00a01	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00a05	81 e1 f8 00 00
	00		 and	 ecx, 248		; 000000f8H
  00a0b	c1 e1 08	 shl	 ecx, 8
  00a0e	0b d1		 or	 edx, ecx
  00a10	89 55 08	 mov	 DWORD PTR _color$[ebp], edx
$L197530:

; 208  : 		// for 15 bit
; 209  : //		color = ((DWORD)(pClr[0] & 0xf8) >> 3) |
; 210  : //				((DWORD)(pClr[1] & 0xf8) << 2) |
; 211  : //				((DWORD)(pClr[2] & 0xf8) << 7);
; 212  : 	}
; 213  : 
; 214  : 	const DWORD RGNDATAHEADER_SIZE	= sizeof(RGNDATAHEADER);

  00a13	c7 85 78 ff ff
	ff 20 00 00 00	 mov	 DWORD PTR _RGNDATAHEADER_SIZE$[ebp], 32 ; 00000020H

; 215  : 	const DWORD ADD_RECTS_COUNT		= 40;			// number of rects to be appended

  00a1d	c7 45 d0 28 00
	00 00		 mov	 DWORD PTR _ADD_RECTS_COUNT$[ebp], 40 ; 00000028H

; 216  : 													// to region data buffer
; 217  : 
; 218  : 	// BitPerPixel
; 219  : 	BYTE	Bpp = bih.biBitCount >> 3;				// bytes per pixel

  00a24	8b 55 f4	 mov	 edx, DWORD PTR _bih$[ebp]
  00a27	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00a2b	c1 f8 03	 sar	 eax, 3
  00a2e	88 45 d7	 mov	 BYTE PTR _Bpp$[ebp], al

; 220  : 	// bytes per line in pBits is DWORD aligned and bmp.bmWidthBytes is WORD aligned
; 221  : 	// so, both of them not
; 222  : 	DWORD m_dwAlignedWidthBytes = (bmp.bmWidthBytes & ~0x3) + (!!(bmp.bmWidthBytes & 0x3) << 2);

  00a31	8b 4d b8	 mov	 ecx, DWORD PTR _bmp$[ebp+12]
  00a34	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00a37	8b 55 b8	 mov	 edx, DWORD PTR _bmp$[ebp+12]
  00a3a	83 e2 03	 and	 edx, 3
  00a3d	f7 da		 neg	 edx
  00a3f	1b d2		 sbb	 edx, edx
  00a41	f7 da		 neg	 edx
  00a43	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00a46	89 45 c8	 mov	 DWORD PTR _m_dwAlignedWidthBytes$[ebp], eax

; 223  : 	// DIB image is flipped that's why we scan it from the last line
; 224  : 	LPBYTE	pColor = pBits + (bih.biHeight - 1) * m_dwAlignedWidthBytes;

  00a49	8b 4d f4	 mov	 ecx, DWORD PTR _bih$[ebp]
  00a4c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00a4f	83 ea 01	 sub	 edx, 1
  00a52	0f af 55 c8	 imul	 edx, DWORD PTR _m_dwAlignedWidthBytes$[ebp]
  00a56	03 55 cc	 add	 edx, DWORD PTR _pBits$[ebp]
  00a59	89 55 f8	 mov	 DWORD PTR _pColor$[ebp], edx

; 225  : 	DWORD	dwLineBackLen = m_dwAlignedWidthBytes + bih.biWidth * Bpp;	// offset of previous scan line

  00a5c	0f b6 45 d7	 movzx	 eax, BYTE PTR _Bpp$[ebp]
  00a60	8b 4d f4	 mov	 ecx, DWORD PTR _bih$[ebp]
  00a63	0f af 41 04	 imul	 eax, DWORD PTR [ecx+4]
  00a67	03 45 c8	 add	 eax, DWORD PTR _m_dwAlignedWidthBytes$[ebp]
  00a6a	89 45 ec	 mov	 DWORD PTR _dwLineBackLen$[ebp], eax

; 226  : 													// (after processing of current)
; 227  : 	DWORD	dwRectsCount = bih.biHeight;			// number of rects in allocated buffer

  00a6d	8b 55 f4	 mov	 edx, DWORD PTR _bih$[ebp]
  00a70	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00a73	89 45 98	 mov	 DWORD PTR _dwRectsCount$[ebp], eax

; 228  : 	INT		i, j;									// current position in mask image
; 229  : 	INT		first = 0;								// left position of current scan line

  00a76	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _first$[ebp], 0

; 230  : 													// where mask was found
; 231  : 	bool	wasfirst = false;						// set when mask has been found in current scan line

  00a7d	c6 45 df 00	 mov	 BYTE PTR _wasfirst$[ebp], 0

; 232  : 	bool	ismask;									// set when current color is mask color
; 233  : 
; 234  : 	// allocate memory for region data
; 235  : 	// region data here is set of regions that are rectangles with height 1 pixel (scan line)
; 236  : 	// that's why first allocation is <bm.biHeight> RECTs - number of scan lines in image
; 237  : 	RGNDATAHEADER* pRgnData = 
; 238  : 		(RGNDATAHEADER*)new BYTE[ RGNDATAHEADER_SIZE + dwRectsCount * sizeof(RECT) ];

  00a81	8b 4d 98	 mov	 ecx, DWORD PTR _dwRectsCount$[ebp]
  00a84	c1 e1 04	 shl	 ecx, 4
  00a87	83 c1 20	 add	 ecx, 32			; 00000020H
  00a8a	51		 push	 ecx
  00a8b	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00a90	83 c4 04	 add	 esp, 4
  00a93	89 85 48 ff ff
	ff		 mov	 DWORD PTR $T198149[ebp], eax
  00a99	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR $T198149[ebp]
  00a9f	89 55 f0	 mov	 DWORD PTR _pRgnData$[ebp], edx

; 239  : 	// get pointer to RECT table
; 240  : 	LPRECT pRects = (LPRECT)((LPBYTE)pRgnData + RGNDATAHEADER_SIZE);

  00aa2	8b 45 f0	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00aa5	83 c0 20	 add	 eax, 32			; 00000020H
  00aa8	89 45 a0	 mov	 DWORD PTR _pRects$[ebp], eax

; 241  : 	// zero region data header memory (header  part only)
; 242  : 	memset( pRgnData, 0, RGNDATAHEADER_SIZE + dwRectsCount * sizeof(RECT) );

  00aab	8b 4d 98	 mov	 ecx, DWORD PTR _dwRectsCount$[ebp]
  00aae	c1 e1 04	 shl	 ecx, 4
  00ab1	83 c1 20	 add	 ecx, 32			; 00000020H
  00ab4	51		 push	 ecx
  00ab5	6a 00		 push	 0
  00ab7	8b 55 f0	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00aba	52		 push	 edx
  00abb	e8 00 00 00 00	 call	 _memset
  00ac0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 243  : 	// fill it by default
; 244  : 	pRgnData->dwSize	= RGNDATAHEADER_SIZE;

  00ac3	8b 45 f0	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00ac6	c7 00 20 00 00
	00		 mov	 DWORD PTR [eax], 32	; 00000020H

; 245  : 	pRgnData->iType		= RDH_RECTANGLES;

  00acc	8b 4d f0	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00acf	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 246  : 
; 247  : 	for ( i = 0; i < bih.biHeight; i++ )

  00ad6	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00add	eb 09		 jmp	 SHORT $L197556
$L197557:
  00adf	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  00ae2	83 c2 01	 add	 edx, 1
  00ae5	89 55 d8	 mov	 DWORD PTR _i$[ebp], edx
$L197556:
  00ae8	8b 45 f4	 mov	 eax, DWORD PTR _bih$[ebp]
  00aeb	8b 4d d8	 mov	 ecx, DWORD PTR _i$[ebp]
  00aee	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00af1	0f 8d ec 02 00
	00		 jge	 $L197558

; 248  : 	{
; 249  : 		if(i == 35)

  00af7	83 7d d8 23	 cmp	 DWORD PTR _i$[ebp], 35	; 00000023H
  00afb	75 0a		 jne	 SHORT $L197559

; 250  : 			int k = 0;

  00afd	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$197560[ebp], 0
$L197559:

; 251  : 		for ( j = 0; j < bih.biWidth; j++ )

  00b07	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  00b11	eb 0f		 jmp	 SHORT $L197561
$L197562:
  00b13	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00b19	83 c2 01	 add	 edx, 1
  00b1c	89 95 74 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
$L197561:
  00b22	8b 45 f4	 mov	 eax, DWORD PTR _bih$[ebp]
  00b25	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00b2b	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00b2e	0f 8d a6 01 00
	00		 jge	 $L197563

; 252  : 		{
; 253  : 			// get color
; 254  : 			switch ( bih.biBitCount )

  00b34	8b 55 f4	 mov	 edx, DWORD PTR _bih$[ebp]
  00b37	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00b3b	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv242[ebp], eax
  00b41	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR tv242[ebp]
  00b47	83 e9 08	 sub	 ecx, 8
  00b4a	89 8d 04 ff ff
	ff		 mov	 DWORD PTR tv242[ebp], ecx
  00b50	83 bd 04 ff ff
	ff 18		 cmp	 DWORD PTR tv242[ebp], 24 ; 00000018H
  00b57	77 6b		 ja	 SHORT $L197565
  00b59	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR tv242[ebp]
  00b5f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $L198159[edx]
  00b66	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L198160[eax*4]
$L197568:

; 255  : 			{
; 256  : 			case 8:
; 257  : 				ismask = (clr_tbl[ *pColor ] != color);

  00b6d	8b 4d f8	 mov	 ecx, DWORD PTR _pColor$[ebp]
  00b70	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00b73	8b 45 a8	 mov	 eax, DWORD PTR _clr_tbl$[ebp]
  00b76	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00b79	33 d2		 xor	 edx, edx
  00b7b	3b 4d 08	 cmp	 ecx, DWORD PTR _color$[ebp]
  00b7e	0f 95 c2	 setne	 dl
  00b81	88 55 9f	 mov	 BYTE PTR _ismask$[ebp], dl

; 258  : 				break;

  00b84	eb 3e		 jmp	 SHORT $L197565
$L197569:

; 259  : 			case 16:
; 260  : 				ismask = (*(LPWORD)pColor != (WORD)color);

  00b86	8b 45 f8	 mov	 eax, DWORD PTR _pColor$[ebp]
  00b89	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00b8c	0f b7 55 08	 movzx	 edx, WORD PTR _color$[ebp]
  00b90	33 c0		 xor	 eax, eax
  00b92	3b ca		 cmp	 ecx, edx
  00b94	0f 95 c0	 setne	 al
  00b97	88 45 9f	 mov	 BYTE PTR _ismask$[ebp], al

; 261  : 				break;

  00b9a	eb 28		 jmp	 SHORT $L197565
$L197572:

; 262  : 			case 24:
; 263  : 				ismask = ((*(LPDWORD)pColor & 0x00ffffff) != color);

  00b9c	8b 4d f8	 mov	 ecx, DWORD PTR _pColor$[ebp]
  00b9f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ba1	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  00ba7	33 c0		 xor	 eax, eax
  00ba9	3b 55 08	 cmp	 edx, DWORD PTR _color$[ebp]
  00bac	0f 95 c0	 setne	 al
  00baf	88 45 9f	 mov	 BYTE PTR _ismask$[ebp], al

; 264  : 				break;

  00bb2	eb 10		 jmp	 SHORT $L197565
$L197574:

; 265  : 			case 32:
; 266  : 				ismask = (*(LPDWORD)pColor != color);

  00bb4	8b 4d f8	 mov	 ecx, DWORD PTR _pColor$[ebp]
  00bb7	8b 11		 mov	 edx, DWORD PTR [ecx]
  00bb9	33 c0		 xor	 eax, eax
  00bbb	3b 55 08	 cmp	 edx, DWORD PTR _color$[ebp]
  00bbe	0f 95 c0	 setne	 al
  00bc1	88 45 9f	 mov	 BYTE PTR _ismask$[ebp], al
$L197565:

; 267  : 			}
; 268  : 			// shift pointer to next color
; 269  : 			pColor += Bpp;

  00bc4	0f b6 4d d7	 movzx	 ecx, BYTE PTR _Bpp$[ebp]
  00bc8	03 4d f8	 add	 ecx, DWORD PTR _pColor$[ebp]
  00bcb	89 4d f8	 mov	 DWORD PTR _pColor$[ebp], ecx

; 270  : 			// place part of scan line as RECT region if transparent color found after mask color or
; 271  : 			// mask color found at the end of mask image
; 272  : 			if ( wasfirst )

  00bce	0f b6 55 df	 movzx	 edx, BYTE PTR _wasfirst$[ebp]
  00bd2	85 d2		 test	 edx, edx
  00bd4	0f 84 e6 00 00
	00		 je	 $L197576

; 273  : 			{
; 274  : 				if ( !ismask )

  00bda	0f b6 45 9f	 movzx	 eax, BYTE PTR _ismask$[ebp]
  00bde	85 c0		 test	 eax, eax
  00be0	0f 85 d8 00 00
	00		 jne	 $L197577

; 275  : 				{
; 276  : 					// save current RECT
; 277  : 					pRects[ pRgnData->nCount++ ] = CRect( first, i, j, i + 1 );

  00be6	8b 4d d8	 mov	 ecx, DWORD PTR _i$[ebp]
  00be9	83 c1 01	 add	 ecx, 1
  00bec	51		 push	 ecx
  00bed	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00bf3	52		 push	 edx
  00bf4	8b 45 d8	 mov	 eax, DWORD PTR _i$[ebp]
  00bf7	50		 push	 eax
  00bf8	8b 4d fc	 mov	 ecx, DWORD PTR _first$[ebp]
  00bfb	51		 push	 ecx
  00bfc	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T198150[ebp]
  00c02	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  00c07	8b 55 f0	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00c0a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00c0d	c1 e1 04	 shl	 ecx, 4
  00c10	03 4d a0	 add	 ecx, DWORD PTR _pRects$[ebp]
  00c13	8b 10		 mov	 edx, DWORD PTR [eax]
  00c15	89 11		 mov	 DWORD PTR [ecx], edx
  00c17	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00c1a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00c1d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00c20	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00c23	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c26	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00c29	8b 4d f0	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00c2c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00c2f	83 c2 01	 add	 edx, 1
  00c32	8b 45 f0	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00c35	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 278  : 					// if buffer full reallocate it with more room
; 279  : 					if ( pRgnData->nCount >= dwRectsCount )

  00c38	8b 4d f0	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00c3b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00c3e	3b 55 98	 cmp	 edx, DWORD PTR _dwRectsCount$[ebp]
  00c41	72 77		 jb	 SHORT $L197579

; 280  : 					{
; 281  : 						dwRectsCount += ADD_RECTS_COUNT;

  00c43	8b 45 98	 mov	 eax, DWORD PTR _dwRectsCount$[ebp]
  00c46	83 c0 28	 add	 eax, 40			; 00000028H
  00c49	89 45 98	 mov	 DWORD PTR _dwRectsCount$[ebp], eax

; 282  : 						// allocate new buffer
; 283  : 						LPBYTE pRgnDataNew = new BYTE[ RGNDATAHEADER_SIZE + dwRectsCount * sizeof(RECT) ];

  00c4c	8b 4d 98	 mov	 ecx, DWORD PTR _dwRectsCount$[ebp]
  00c4f	c1 e1 04	 shl	 ecx, 4
  00c52	83 c1 20	 add	 ecx, 32			; 00000020H
  00c55	51		 push	 ecx
  00c56	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00c5b	83 c4 04	 add	 esp, 4
  00c5e	89 85 34 ff ff
	ff		 mov	 DWORD PTR $T198151[ebp], eax
  00c64	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR $T198151[ebp]
  00c6a	89 95 64 ff ff
	ff		 mov	 DWORD PTR _pRgnDataNew$197580[ebp], edx

; 284  : 						// copy current region data to it
; 285  : 						memcpy( pRgnDataNew, pRgnData, RGNDATAHEADER_SIZE + pRgnData->nCount * sizeof(RECT) );

  00c70	8b 45 f0	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00c73	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c76	c1 e1 04	 shl	 ecx, 4
  00c79	83 c1 20	 add	 ecx, 32			; 00000020H
  00c7c	51		 push	 ecx
  00c7d	8b 55 f0	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00c80	52		 push	 edx
  00c81	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnDataNew$197580[ebp]
  00c87	50		 push	 eax
  00c88	e8 00 00 00 00	 call	 _memcpy
  00c8d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 286  : 						// delte old region data buffer
; 287  : 						delete []pRgnData;

  00c90	8b 4d f0	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00c93	89 8d 30 ff ff
	ff		 mov	 DWORD PTR $T198152[ebp], ecx
  00c99	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR $T198152[ebp]
  00c9f	52		 push	 edx
  00ca0	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00ca5	83 c4 04	 add	 esp, 4

; 288  : 						// set pointer to new regiondata buffer to current
; 289  : 						pRgnData = (RGNDATAHEADER*)pRgnDataNew;

  00ca8	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnDataNew$197580[ebp]
  00cae	89 45 f0	 mov	 DWORD PTR _pRgnData$[ebp], eax

; 290  : 						// correct pointer to RECT table
; 291  : 						pRects = (LPRECT)((LPBYTE)pRgnData + RGNDATAHEADER_SIZE);

  00cb1	8b 4d f0	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00cb4	83 c1 20	 add	 ecx, 32			; 00000020H
  00cb7	89 4d a0	 mov	 DWORD PTR _pRects$[ebp], ecx
$L197579:

; 292  : 					}
; 293  : 					wasfirst = false;

  00cba	c6 45 df 00	 mov	 BYTE PTR _wasfirst$[ebp], 0
$L197577:

; 294  : 				}
; 295  : 			}
; 296  : 			else if ( ismask )		// set wasfirst when mask is found

  00cbe	eb 15		 jmp	 SHORT $L197589
$L197576:
  00cc0	0f b6 55 9f	 movzx	 edx, BYTE PTR _ismask$[ebp]
  00cc4	85 d2		 test	 edx, edx
  00cc6	74 0d		 je	 SHORT $L197589

; 297  : 			{
; 298  : 				first = j;

  00cc8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00cce	89 45 fc	 mov	 DWORD PTR _first$[ebp], eax

; 299  : 				wasfirst = true;

  00cd1	c6 45 df 01	 mov	 BYTE PTR _wasfirst$[ebp], 1
$L197589:

; 300  : 			}
; 301  : 		}

  00cd5	e9 39 fe ff ff	 jmp	 $L197562
$L197563:

; 302  : 
; 303  : 		if ( wasfirst && ismask )

  00cda	0f b6 4d df	 movzx	 ecx, BYTE PTR _wasfirst$[ebp]
  00cde	85 c9		 test	 ecx, ecx
  00ce0	0f 84 e4 00 00
	00		 je	 $L197591
  00ce6	0f b6 55 9f	 movzx	 edx, BYTE PTR _ismask$[ebp]
  00cea	85 d2		 test	 edx, edx
  00cec	0f 84 d8 00 00
	00		 je	 $L197591

; 304  : 		{
; 305  : 			// save current RECT
; 306  : 			pRects[ pRgnData->nCount++ ] = CRect( first, i, j, i + 1 );

  00cf2	8b 45 d8	 mov	 eax, DWORD PTR _i$[ebp]
  00cf5	83 c0 01	 add	 eax, 1
  00cf8	50		 push	 eax
  00cf9	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00cff	51		 push	 ecx
  00d00	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  00d03	52		 push	 edx
  00d04	8b 45 fc	 mov	 eax, DWORD PTR _first$[ebp]
  00d07	50		 push	 eax
  00d08	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T198153[ebp]
  00d0e	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  00d13	8b 4d f0	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00d16	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00d19	c1 e2 04	 shl	 edx, 4
  00d1c	03 55 a0	 add	 edx, DWORD PTR _pRects$[ebp]
  00d1f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d21	89 0a		 mov	 DWORD PTR [edx], ecx
  00d23	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00d26	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00d29	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00d2c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00d2f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00d32	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00d35	8b 4d f0	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00d38	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00d3b	83 c2 01	 add	 edx, 1
  00d3e	8b 45 f0	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00d41	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 307  : 			// if buffer full reallocate it with more room
; 308  : 			if ( pRgnData->nCount >= dwRectsCount )

  00d44	8b 4d f0	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00d47	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00d4a	3b 55 98	 cmp	 edx, DWORD PTR _dwRectsCount$[ebp]
  00d4d	72 77		 jb	 SHORT $L197593

; 309  : 			{
; 310  : 				dwRectsCount += ADD_RECTS_COUNT;

  00d4f	8b 45 98	 mov	 eax, DWORD PTR _dwRectsCount$[ebp]
  00d52	83 c0 28	 add	 eax, 40			; 00000028H
  00d55	89 45 98	 mov	 DWORD PTR _dwRectsCount$[ebp], eax

; 311  : 				// allocate new buffer
; 312  : 				LPBYTE pRgnDataNew = new BYTE[ RGNDATAHEADER_SIZE + dwRectsCount * sizeof(RECT) ];

  00d58	8b 4d 98	 mov	 ecx, DWORD PTR _dwRectsCount$[ebp]
  00d5b	c1 e1 04	 shl	 ecx, 4
  00d5e	83 c1 20	 add	 ecx, 32			; 00000020H
  00d61	51		 push	 ecx
  00d62	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00d67	83 c4 04	 add	 esp, 4
  00d6a	89 85 1c ff ff
	ff		 mov	 DWORD PTR $T198154[ebp], eax
  00d70	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR $T198154[ebp]
  00d76	89 95 60 ff ff
	ff		 mov	 DWORD PTR _pRgnDataNew$197594[ebp], edx

; 313  : 				// copy current region data to it
; 314  : 				memcpy( pRgnDataNew, pRgnData, RGNDATAHEADER_SIZE + pRgnData->nCount * sizeof(RECT) );

  00d7c	8b 45 f0	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00d7f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00d82	c1 e1 04	 shl	 ecx, 4
  00d85	83 c1 20	 add	 ecx, 32			; 00000020H
  00d88	51		 push	 ecx
  00d89	8b 55 f0	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00d8c	52		 push	 edx
  00d8d	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnDataNew$197594[ebp]
  00d93	50		 push	 eax
  00d94	e8 00 00 00 00	 call	 _memcpy
  00d99	83 c4 0c	 add	 esp, 12			; 0000000cH

; 315  : 				// delte old region data buffer
; 316  : 				delete []pRgnData;

  00d9c	8b 4d f0	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00d9f	89 8d 18 ff ff
	ff		 mov	 DWORD PTR $T198155[ebp], ecx
  00da5	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR $T198155[ebp]
  00dab	52		 push	 edx
  00dac	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00db1	83 c4 04	 add	 esp, 4

; 317  : 				// set pointer to new regiondata buffer to current
; 318  : 				pRgnData = (RGNDATAHEADER*)pRgnDataNew;

  00db4	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnDataNew$197594[ebp]
  00dba	89 45 f0	 mov	 DWORD PTR _pRgnData$[ebp], eax

; 319  : 				// correct pointer to RECT table
; 320  : 				pRects = (LPRECT)((LPBYTE)pRgnData + RGNDATAHEADER_SIZE);

  00dbd	8b 4d f0	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00dc0	83 c1 20	 add	 ecx, 32			; 00000020H
  00dc3	89 4d a0	 mov	 DWORD PTR _pRects$[ebp], ecx
$L197593:

; 321  : 			}
; 322  : 			wasfirst = false;

  00dc6	c6 45 df 00	 mov	 BYTE PTR _wasfirst$[ebp], 0
$L197591:

; 323  : 		}
; 324  : 
; 325  : 
; 326  : 		if(pColor - dwLineBackLen >= pBits)

  00dca	8b 55 f8	 mov	 edx, DWORD PTR _pColor$[ebp]
  00dcd	2b 55 ec	 sub	 edx, DWORD PTR _dwLineBackLen$[ebp]
  00dd0	3b 55 cc	 cmp	 edx, DWORD PTR _pBits$[ebp]
  00dd3	72 09		 jb	 SHORT $L197603

; 327  : 			pColor -= dwLineBackLen;

  00dd5	8b 45 f8	 mov	 eax, DWORD PTR _pColor$[ebp]
  00dd8	2b 45 ec	 sub	 eax, DWORD PTR _dwLineBackLen$[ebp]
  00ddb	89 45 f8	 mov	 DWORD PTR _pColor$[ebp], eax
$L197603:

; 328  : 	}

  00dde	e9 fc fc ff ff	 jmp	 $L197557
$L197558:

; 329  : 
; 330  : 	for(int i = 0 ; i<(int)pRgnData->nCount; i++)

  00de3	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$197604[ebp], 0
  00ded	eb 0f		 jmp	 SHORT $L197606
$L197607:
  00def	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _i$197604[ebp]
  00df5	83 c1 01	 add	 ecx, 1
  00df8	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _i$197604[ebp], ecx
$L197606:
  00dfe	8b 55 f0	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00e01	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _i$197604[ebp]
  00e07	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00e0a	7d 02		 jge	 SHORT $L197608

; 331  : 	{
; 332  : 	//	TRACE("\n count:%2d, [%2d, %2d, %2d,%2d]", i, pRects[i].left,  pRects[i].right,  pRects[i].top,  pRects[i].bottom);
; 333  : 	}

  00e0c	eb e1		 jmp	 SHORT $L197607
$L197608:

; 334  : 	// release image data
; 335  : 	delete []pBits;

  00e0e	8b 4d cc	 mov	 ecx, DWORD PTR _pBits$[ebp]
  00e11	89 8d 14 ff ff
	ff		 mov	 DWORD PTR $T198156[ebp], ecx
  00e17	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR $T198156[ebp]
  00e1d	52		 push	 edx
  00e1e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00e23	83 c4 04	 add	 esp, 4

; 336  : 	delete []bi;

  00e26	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _bi$[ebp]
  00e2c	89 85 10 ff ff
	ff		 mov	 DWORD PTR $T198157[ebp], eax
  00e32	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR $T198157[ebp]
  00e38	51		 push	 ecx
  00e39	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00e3e	83 c4 04	 add	 esp, 4

; 337  : 
; 338  : 	// create region
; 339  : 	HRGN hRgn = ExtCreateRegion( NULL, RGNDATAHEADER_SIZE + pRgnData->nCount * sizeof(RECT), (LPRGNDATA)pRgnData );

  00e41	8b 55 f0	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00e44	52		 push	 edx
  00e45	8b 45 f0	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00e48	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00e4b	c1 e1 04	 shl	 ecx, 4
  00e4e	83 c1 20	 add	 ecx, 32			; 00000020H
  00e51	51		 push	 ecx
  00e52	6a 00		 push	 0
  00e54	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExtCreateRegion@12
  00e5a	89 45 a4	 mov	 DWORD PTR _hRgn$[ebp], eax

; 340  : 	// release region data
; 341  : 	delete []pRgnData;

  00e5d	8b 55 f0	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00e60	89 95 0c ff ff
	ff		 mov	 DWORD PTR $T198158[ebp], edx
  00e66	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR $T198158[ebp]
  00e6c	50		 push	 eax
  00e6d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00e72	83 c4 04	 add	 esp, 4

; 342  : 	return hRgn;

  00e75	8b 45 a4	 mov	 eax, DWORD PTR _hRgn$[ebp]
$L197495:

; 343  : }

  00e78	8b e5		 mov	 esp, ebp
  00e7a	5d		 pop	 ebp
  00e7b	c2 08 00	 ret	 8
$L198160:
  00e7e	00 00 00 00	 DD	 $L197568
  00e82	00 00 00 00	 DD	 $L197569
  00e86	00 00 00 00	 DD	 $L197572
  00e8a	00 00 00 00	 DD	 $L197574
  00e8e	00 00 00 00	 DD	 $L197565
$L198159:
  00e92	00		 DB	 0
  00e93	04		 DB	 4
  00e94	04		 DB	 4
  00e95	04		 DB	 4
  00e96	04		 DB	 4
  00e97	04		 DB	 4
  00e98	04		 DB	 4
  00e99	04		 DB	 4
  00e9a	01		 DB	 1
  00e9b	04		 DB	 4
  00e9c	04		 DB	 4
  00e9d	04		 DB	 4
  00e9e	04		 DB	 4
  00e9f	04		 DB	 4
  00ea0	04		 DB	 4
  00ea1	04		 DB	 4
  00ea2	02		 DB	 2
  00ea3	04		 DB	 4
  00ea4	04		 DB	 4
  00ea5	04		 DB	 4
  00ea6	04		 DB	 4
  00ea7	04		 DB	 4
  00ea8	04		 DB	 4
  00ea9	04		 DB	 4
  00eaa	03		 DB	 3
?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCDC@@@Z ENDP ; CDibBitmap::CreateRgnFromBitmap
_TEXT	ENDS
PUBLIC	?GetWidth@CDibBitmap@@QAEHXZ			; CDibBitmap::GetWidth
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWidth@CDibBitmap@@QAEHXZ PROC NEAR			; CDibBitmap::GetWidth
; _this$ = ecx

; 448  : {

  00eb0	55		 push	 ebp
  00eb1	8b ec		 mov	 ebp, esp
  00eb3	51		 push	 ecx
  00eb4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 449  : 	if(!ValidCheck())

  00eb7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00eba	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  00ebf	85 c0		 test	 eax, eax
  00ec1	75 04		 jne	 SHORT $L197618

; 450  : 		return 0;

  00ec3	33 c0		 xor	 eax, eax
  00ec5	eb 09		 jmp	 SHORT $L197617
$L197618:

; 451  : 	return this->m_lpBMIH->biWidth;

  00ec7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00eca	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ecd	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
$L197617:

; 452  : }

  00ed0	8b e5		 mov	 esp, ebp
  00ed2	5d		 pop	 ebp
  00ed3	c3		 ret	 0
?GetWidth@CDibBitmap@@QAEHXZ ENDP			; CDibBitmap::GetWidth
_TEXT	ENDS
PUBLIC	?GetHeight@CDibBitmap@@QAEHXZ			; CDibBitmap::GetHeight
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHeight@CDibBitmap@@QAEHXZ PROC NEAR			; CDibBitmap::GetHeight
; _this$ = ecx

; 454  : {

  00ee0	55		 push	 ebp
  00ee1	8b ec		 mov	 ebp, esp
  00ee3	51		 push	 ecx
  00ee4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 455  : 	if(!ValidCheck())

  00ee7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00eea	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  00eef	85 c0		 test	 eax, eax
  00ef1	75 04		 jne	 SHORT $L197622

; 456  : 		return 0;

  00ef3	33 c0		 xor	 eax, eax
  00ef5	eb 09		 jmp	 SHORT $L197621
$L197622:

; 457  : 	return this->m_lpBMIH->biHeight;

  00ef7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00efa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00efd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
$L197621:

; 458  : }

  00f00	8b e5		 mov	 esp, ebp
  00f02	5d		 pop	 ebp
  00f03	c3		 ret	 0
?GetHeight@CDibBitmap@@QAEHXZ ENDP			; CDibBitmap::GetHeight
_TEXT	ENDS
PUBLIC	?GetPath@CDibBitmap@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; CDibBitmap::GetPath
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T198165 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetPath@CDibBitmap@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC NEAR ; CDibBitmap::GetPath
; _this$ = ecx

; 460  : {

  00f10	55		 push	 ebp
  00f11	8b ec		 mov	 ebp, esp
  00f13	83 ec 08	 sub	 esp, 8
  00f16	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00f19	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T198165[ebp], 0

; 461  : 	return m_path;

  00f20	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00f23	83 c0 38	 add	 eax, 56			; 00000038H
  00f26	50		 push	 eax
  00f27	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00f2a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00f30	8b 4d fc	 mov	 ecx, DWORD PTR $T198165[ebp]
  00f33	83 c9 01	 or	 ecx, 1
  00f36	89 4d fc	 mov	 DWORD PTR $T198165[ebp], ecx
  00f39	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 462  : }

  00f3c	8b e5		 mov	 esp, ebp
  00f3e	5d		 pop	 ebp
  00f3f	c2 04 00	 ret	 4
?GetPath@CDibBitmap@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; CDibBitmap::GetPath
_TEXT	ENDS
PUBLIC	?GetDC@CWnd@@QAEPAVCDC@@XZ			; CWnd::GetDC
PUBLIC	?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCWnd@@@Z ; CDibBitmap::CreateRgnFromBitmap
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_color$ = 8						; size = 4
_pWnd$ = 12						; size = 4
?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCWnd@@@Z PROC NEAR ; CDibBitmap::CreateRgnFromBitmap
; _this$ = ecx

; 468  : {

  00f50	55		 push	 ebp
  00f51	8b ec		 mov	 ebp, esp
  00f53	51		 push	 ecx
  00f54	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 469  : 	return CreateRgnFromBitmap(color,pWnd->GetDC());

  00f57	8b 4d 0c	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00f5a	e8 00 00 00 00	 call	 ?GetDC@CWnd@@QAEPAVCDC@@XZ ; CWnd::GetDC
  00f5f	50		 push	 eax
  00f60	8b 45 08	 mov	 eax, DWORD PTR _color$[ebp]
  00f63	50		 push	 eax
  00f64	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f67	e8 00 00 00 00	 call	 ?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCDC@@@Z ; CDibBitmap::CreateRgnFromBitmap

; 470  : }

  00f6c	8b e5		 mov	 esp, ebp
  00f6e	5d		 pop	 ebp
  00f6f	c2 08 00	 ret	 8
?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCWnd@@@Z ENDP ; CDibBitmap::CreateRgnFromBitmap
_TEXT	ENDS
EXTRN	?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z:NEAR ; CDib::CreateBitmap
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?CreateBitmap@CDibBitmap@@QAEPAUHBITMAP__@@PAVCDC@@@Z PROC NEAR ; CDibBitmap::CreateBitmap
; _this$ = ecx

; 473  : {

  00f80	55		 push	 ebp
  00f81	8b ec		 mov	 ebp, esp
  00f83	51		 push	 ecx
  00f84	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 474  : 	if(!ValidCheck())

  00f87	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f8a	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  00f8f	85 c0		 test	 eax, eax
  00f91	75 04		 jne	 SHORT $L197636

; 475  : 		return NULL;

  00f93	33 c0		 xor	 eax, eax
  00f95	eb 0c		 jmp	 SHORT $L197635
$L197636:

; 476  : 	return __super::CreateBitmap(pDC);

  00f97	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  00f9a	50		 push	 eax
  00f9b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f9e	e8 00 00 00 00	 call	 ?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ; CDib::CreateBitmap
$L197635:

; 477  : }

  00fa3	8b e5		 mov	 esp, ebp
  00fa5	5d		 pop	 ebp
  00fa6	c2 04 00	 ret	 4
?CreateBitmap@CDibBitmap@@QAEPAUHBITMAP__@@PAVCDC@@@Z ENDP ; CDibBitmap::CreateBitmap
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initX$ = 8						; size = 4
_initY$ = 12						; size = 4
??0CPoint@@QAE@HH@Z PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 63   : 	{ x = initX; y = initY; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _initX$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _initY$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0CPoint@@QAE@HH@Z ENDP				; CPoint::CPoint
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRect@@QAE@XZ PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 110  : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CRect@@QAE@XZ ENDP					; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
??0CRect@@QAE@HHHH@Z PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 112  : 	{ left = l; top = t; right = r; bottom = b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _r$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _b$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
??0CRect@@QAE@HHHH@Z ENDP				; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Width@CRect@@QBEHXZ PROC NEAR				; CRect::Width, COMDAT
; _this$ = ecx

; 123  : 	{ return right - left; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Width@CRect@@QBEHXZ ENDP				; CRect::Width
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Height@CRect@@QBEHXZ PROC NEAR				; CRect::Height, COMDAT
; _this$ = ecx

; 125  : 	{ return bottom - top; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?Height@CRect@@QBEHXZ ENDP				; CRect::Height
_TEXT	ENDS
PUBLIC	??0CSize@@QAE@HH@Z				; CSize::CSize
; Function compile flags: /Odt
;	COMDAT ?Size@CRect@@QBE?AVCSize@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Size@CRect@@QBE?AVCSize@@XZ PROC NEAR			; CRect::Size, COMDAT
; _this$ = ecx

; 127  : 	{ return CSize(right - left, bottom - top); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00010	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00013	52		 push	 edx
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0001d	2b 11		 sub	 edx, DWORD PTR [ecx]
  0001f	52		 push	 edx
  00020	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00023	e8 00 00 00 00	 call	 ??0CSize@@QAE@HH@Z	; CSize::CSize
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?Size@CRect@@QBE?AVCSize@@XZ ENDP			; CRect::Size
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initCX$ = 8						; size = 4
_initCY$ = 12						; size = 4
??0CSize@@QAE@HH@Z PROC NEAR				; CSize::CSize, COMDAT
; _this$ = ecx

; 24   : 	{ cx = initCX; cy = initCY; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _initCX$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _initCY$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0CSize@@QAE@HH@Z ENDP					; CSize::CSize
_TEXT	ENDS
EXTRN	__imp__EqualRect@8:NEAR
; Function compile flags: /Odt
;	COMDAT ??9CRect@@QBEHABUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rect$ = 8						; size = 4
??9CRect@@QBEHABUtagRECT@@@Z PROC NEAR			; CRect::operator!=, COMDAT
; _this$ = ecx

; 193  : 	{ return !::EqualRect(this, &rect); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EqualRect@8
  00015	f7 d8		 neg	 eax
  00017	1b c0		 sbb	 eax, eax
  00019	40		 inc	 eax
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??9CRect@@QBEHABUtagRECT@@@Z ENDP			; CRect::operator!=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?DeflateRect@CRect@@QAEXHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
?DeflateRect@CRect@@QAEXHHHH@Z PROC NEAR		; CRect::DeflateRect, COMDAT
; _this$ = ecx

; 267  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 268  : 		left += l;		top += t;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	03 4d 08	 add	 ecx, DWORD PTR _l$[ebp]
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	03 4d 0c	 add	 ecx, DWORD PTR _t$[ebp]
  0001d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00020	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 269  : 		right -= r;		bottom -= b;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00029	2b 4d 10	 sub	 ecx, DWORD PTR _r$[ebp]
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00038	2b 4d 14	 sub	 ecx, DWORD PTR _b$[ebp]
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 270  : 	}

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 10 00	 ret	 16			; 00000010H
?DeflateRect@CRect@@QAEXHHHH@Z ENDP			; CRect::DeflateRect
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC NEAR				; CObject::operator delete, COMDAT

; 31   : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AssertValid@CObject@@UBEXXZ PROC NEAR			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 41   : 	{ /* no asserts in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC NEAR	; CObject::Dump, COMDAT
; _this$ = ecx

; 43   : 	{ /* no dumping in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ PROC NEAR		; CDC::GetSafeHdc, COMDAT
; _this$ = ecx

; 316  : 	{ return this == NULL ? NULL : m_hDC; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  0000d	75 09		 jne	 SHORT $L198194
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00016	eb 09		 jmp	 SHORT $L198195
$L198194:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	89 4d f8	 mov	 DWORD PTR tv66[ebp], ecx
$L198195:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ENDP			; CDC::GetSafeHdc
_TEXT	ENDS
EXTRN	?FromHandle@CDC@@SGPAV1@PAUHDC__@@@Z:NEAR	; CDC::FromHandle
EXTRN	__imp__GetDC@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin2.inl
;	COMDAT ?GetDC@CWnd@@QAEPAVCDC@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDC@CWnd@@QAEPAVCDC@@XZ PROC NEAR			; CWnd::GetDC, COMDAT
; _this$ = ecx

; 121  : 	{ ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::GetDC(m_hWnd)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?FromHandle@CDC@@SGPAV1@PAUHDC__@@@Z ; CDC::FromHandle
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?GetDC@CWnd@@QAEPAVCDC@@XZ ENDP				; CWnd::GetDC
_TEXT	ENDS
END
