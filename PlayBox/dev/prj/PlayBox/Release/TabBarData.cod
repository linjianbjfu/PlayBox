; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\module\TabMan\TabBarData.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??1IData@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppStart@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppExit@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIData@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@OneLocalGame@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTabBarData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCTabBarData@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ITabBarData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ITabBarData@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CTabBarData@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GITabBarData@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GTAB_ITEM@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3ITabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CTabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ITabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CTabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ITabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVIData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVITabBarData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCTabBarData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4ITabBarData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CTabBarData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVITabBarObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7ITabBarData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CTabBarData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_pTabBarData@CTabBarData@@2PAV1@A		; CTabBarData::m_pTabBarData
_BSS	SEGMENT
?m_pTabBarData@CTabBarData@@2PAV1@A DD 01H DUP (?)	; CTabBarData::m_pTabBarData
_BSS	ENDS
CONST	SEGMENT
_ID_MESSAGE_TABBAR DD 0bH
_ID_DATA_PANELCHANGE DD 05H
CONST	ENDS
PUBLIC	?GetInstance@CTabBarData@@SAPAVIData@@XZ	; CTabBarData::GetInstance
PUBLIC	??0CTabBarData@@QAE@XZ				; CTabBarData::CTabBarData
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
xdata$x	SEGMENT
$T200776 DD	0ffffffffH
	DD	FLAT:$L200769
$T200773 DD	019930520H
	DD	01H
	DD	FLAT:$T200776
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabbardata.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv72 = -24						; size = 4
$T200766 = -20						; size = 4
$T200765 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?GetInstance@CTabBarData@@SAPAVIData@@XZ PROC NEAR	; CTabBarData::GetInstance

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetInstance@CTabBarData@@SAPAVIData@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 10   : 	if(m_pTabBarData == NULL)

  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A, 0 ; CTabBarData::m_pTabBarData
  00022	75 44		 jne	 SHORT $L198713

; 11   : 		m_pTabBarData = new CTabBarData();

  00024	6a 18		 push	 24			; 00000018H
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 45 ec	 mov	 DWORD PTR $T200766[ebp], eax
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	83 7d ec 00	 cmp	 DWORD PTR $T200766[ebp], 0
  0003c	74 0d		 je	 SHORT $L200767
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR $T200766[ebp]
  00041	e8 00 00 00 00	 call	 ??0CTabBarData@@QAE@XZ
  00046	89 45 e8	 mov	 DWORD PTR tv72[ebp], eax
  00049	eb 07		 jmp	 SHORT $L200768
$L200767:
  0004b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L200768:
  00052	8b 45 e8	 mov	 eax, DWORD PTR tv72[ebp]
  00055	89 45 f0	 mov	 DWORD PTR $T200765[ebp], eax
  00058	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR $T200765[ebp]
  00062	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A, ecx ; CTabBarData::m_pTabBarData
$L198713:

; 12   : 	return m_pTabBarData;

  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A ; CTabBarData::m_pTabBarData

; 13   : }

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200769:
  00000	8b 45 ec	 mov	 eax, DWORD PTR $T200766[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?GetInstance@CTabBarData@@SAPAVIData@@XZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200773
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetInstance@CTabBarData@@SAPAVIData@@XZ ENDP		; CTabBarData::GetInstance
PUBLIC	?DataAppStart@CTabBarData@@UAEXXZ		; CTabBarData::DataAppStart
PUBLIC	?DataAppExit@CTabBarData@@UAEXXZ		; CTabBarData::DataAppExit
PUBLIC	?ITabBar_ChangeTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z ; CTabBarData::ITabBar_ChangeTab
PUBLIC	?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z ; CTabBarData::ITabBar_DeleteTab
PUBLIC	?ITabBar_GetCurPos@CTabBarData@@UAEHXZ		; CTabBarData::ITabBar_GetCurPos
PUBLIC	?ITabBar_GetCurItem@CTabBarData@@UAE_NAAUTAB_ITEM@@@Z ; CTabBarData::ITabBar_GetCurItem
PUBLIC	?ITabBar_GetTabBarData@CTabBarData@@UAEXAAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@Z ; CTabBarData::ITabBar_GetTabBarData
PUBLIC	??_7CTabBarData@@6B@				; CTabBarData::`vftable'
PUBLIC	??_GCTabBarData@@UAEPAXI@Z			; CTabBarData::`scalar deleting destructor'
PUBLIC	??_R4CTabBarData@@6B@				; CTabBarData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTabBarData@@@8				; CTabBarData `RTTI Type Descriptor'
PUBLIC	??_R3CTabBarData@@8				; CTabBarData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTabBarData@@8				; CTabBarData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CTabBarData@@8			; CTabBarData::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@ITabBarData@@8			; ITabBarData::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVITabBarData@@@8				; ITabBarData `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@IData@@8				; IData::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVIData@@@8				; IData `RTTI Type Descriptor'
PUBLIC	??0ITabBarData@@QAE@XZ				; ITabBarData::ITabBarData
PUBLIC	??1ITabBarData@@UAE@XZ				; ITabBarData::~ITabBarData
PUBLIC	??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >
EXTRN	??_ECTabBarData@@UAEPAXI@Z:NEAR			; CTabBarData::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200784 DD	0ffffffffH
	DD	FLAT:$L200779
$T200782 DD	019930520H
	DD	01H
	DD	FLAT:$T200784
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CTabBarData@@6B@
CONST	SEGMENT
??_7CTabBarData@@6B@ DD FLAT:??_R4CTabBarData@@6B@	; CTabBarData::`vftable'
	DD	FLAT:??_ECTabBarData@@UAEPAXI@Z
	DD	FLAT:?DataAppStart@CTabBarData@@UAEXXZ
	DD	FLAT:?DataAppExit@CTabBarData@@UAEXXZ
	DD	FLAT:?ITabBar_ChangeTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBar_GetCurPos@CTabBarData@@UAEHXZ
	DD	FLAT:?ITabBar_GetCurItem@CTabBarData@@UAE_NAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBar_GetTabBarData@CTabBarData@@UAEXAAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@Z
CONST	ENDS
;	COMDAT ??_R4CTabBarData@@6B@
rdata$r	SEGMENT
??_R4CTabBarData@@6B@ DD 00H				; CTabBarData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTabBarData@@@8
	DD	FLAT:??_R3CTabBarData@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTabBarData@@@8
_DATA	SEGMENT
??_R0?AVCTabBarData@@@8 DD FLAT:??_7type_info@@6B@	; CTabBarData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTabBarData@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CTabBarData@@8
rdata$r	SEGMENT
??_R3CTabBarData@@8 DD 00H				; CTabBarData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CTabBarData@@8
rdata$r	ENDS
;	COMDAT ??_R2CTabBarData@@8
rdata$r	SEGMENT
??_R2CTabBarData@@8 DD FLAT:??_R1A@?0A@A@CTabBarData@@8	; CTabBarData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@ITabBarData@@8
	DD	FLAT:??_R1A@?0A@A@IData@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTabBarData@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CTabBarData@@8 DD FLAT:??_R0?AVCTabBarData@@@8 ; CTabBarData::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ITabBarData@@8
rdata$r	SEGMENT
??_R1A@?0A@A@ITabBarData@@8 DD FLAT:??_R0?AVITabBarData@@@8 ; ITabBarData::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVITabBarData@@@8
_DATA	SEGMENT
??_R0?AVITabBarData@@@8 DD FLAT:??_7type_info@@6B@	; ITabBarData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVITabBarData@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@IData@@8
rdata$r	SEGMENT
??_R1A@?0A@A@IData@@8 DD FLAT:??_R0?AVIData@@@8		; IData::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVIData@@@8
_DATA	SEGMENT
??_R0?AVIData@@@8 DD FLAT:??_7type_info@@6B@		; IData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIData@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0CTabBarData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CTabBarData@@QAE@XZ PROC NEAR			; CTabBarData::CTabBarData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTabBarData@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0ITabBarData@@QAE@XZ
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTabBarData@@6B@
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 08	 add	 ecx, 8
  0003a	e8 00 00 00 00	 call	 ??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >
  0003f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00046	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200779:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ITabBarData@@UAE@XZ
__ehhandler$??0CTabBarData@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200782
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CTabBarData@@QAE@XZ ENDP				; CTabBarData::CTabBarData
PUBLIC	??1CTabBarData@@UAE@XZ				; CTabBarData::~CTabBarData
; Function compile flags: /Odt
;	COMDAT ??_GCTabBarData@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTabBarData@@UAEPAXI@Z PROC NEAR			; CTabBarData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTabBarData@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L198723
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L198723:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCTabBarData@@UAEPAXI@Z ENDP				; CTabBarData::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4ITabBarData@@6B@				; ITabBarData::`RTTI Complete Object Locator'
PUBLIC	??_R3ITabBarData@@8				; ITabBarData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITabBarData@@8				; ITabBarData::`RTTI Base Class Array'
PUBLIC	?DataAppStart@IData@@UAEXXZ			; IData::DataAppStart
PUBLIC	?DataAppExit@IData@@UAEXXZ			; IData::DataAppExit
PUBLIC	??0IData@@QAE@XZ				; IData::IData
PUBLIC	??_7ITabBarData@@6B@				; ITabBarData::`vftable'
PUBLIC	??_GITabBarData@@UAEPAXI@Z			; ITabBarData::`scalar deleting destructor'
EXTRN	__purecall:NEAR
EXTRN	??_EITabBarData@@UAEPAXI@Z:NEAR			; ITabBarData::`vector deleting destructor'
;	COMDAT ??_7ITabBarData@@6B@
CONST	SEGMENT
??_7ITabBarData@@6B@ DD FLAT:??_R4ITabBarData@@6B@	; ITabBarData::`vftable'
	DD	FLAT:??_EITabBarData@@UAEPAXI@Z
	DD	FLAT:?DataAppStart@IData@@UAEXXZ
	DD	FLAT:?DataAppExit@IData@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4ITabBarData@@6B@
rdata$r	SEGMENT
??_R4ITabBarData@@6B@ DD 00H				; ITabBarData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVITabBarData@@@8
	DD	FLAT:??_R3ITabBarData@@8
rdata$r	ENDS
;	COMDAT ??_R3ITabBarData@@8
rdata$r	SEGMENT
??_R3ITabBarData@@8 DD 00H				; ITabBarData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITabBarData@@8
rdata$r	ENDS
;	COMDAT ??_R2ITabBarData@@8
rdata$r	SEGMENT
??_R2ITabBarData@@8 DD FLAT:??_R1A@?0A@A@ITabBarData@@8	; ITabBarData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@IData@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0ITabBarData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ITabBarData@@QAE@XZ PROC NEAR			; ITabBarData::ITabBarData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IData@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ITabBarData@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0ITabBarData@@QAE@XZ ENDP				; ITabBarData::ITabBarData
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\datainterface\idata.h
_TEXT	ENDS
;	COMDAT ?DataAppStart@IData@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DataAppStart@IData@@UAEXXZ PROC NEAR			; IData::DataAppStart, COMDAT
; _this$ = ecx

; 15   : 	virtual void	DataAppStart(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?DataAppStart@IData@@UAEXXZ ENDP			; IData::DataAppStart
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?DataAppExit@IData@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DataAppExit@IData@@UAEXXZ PROC NEAR			; IData::DataAppExit, COMDAT
; _this$ = ecx

; 18   : 	virtual void	DataAppExit(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?DataAppExit@IData@@UAEXXZ ENDP				; IData::DataAppExit
_TEXT	ENDS
PUBLIC	??1IData@@MAE@XZ				; IData::~IData
; Function compile flags: /Odt
;	COMDAT ??1ITabBarData@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ITabBarData@@UAE@XZ PROC NEAR			; ITabBarData::~ITabBarData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1IData@@MAE@XZ	; IData::~IData
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1ITabBarData@@UAE@XZ ENDP				; ITabBarData::~ITabBarData
_TEXT	ENDS
PUBLIC	??_R4IData@@6B@					; IData::`RTTI Complete Object Locator'
PUBLIC	??_R3IData@@8					; IData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IData@@8					; IData::`RTTI Base Class Array'
PUBLIC	??_7IData@@6B@					; IData::`vftable'
PUBLIC	??_GIData@@MAEPAXI@Z				; IData::`scalar deleting destructor'
EXTRN	??_EIData@@MAEPAXI@Z:NEAR			; IData::`vector deleting destructor'
;	COMDAT ??_7IData@@6B@
CONST	SEGMENT
??_7IData@@6B@ DD FLAT:??_R4IData@@6B@			; IData::`vftable'
	DD	FLAT:??_EIData@@MAEPAXI@Z
	DD	FLAT:?DataAppStart@IData@@UAEXXZ
	DD	FLAT:?DataAppExit@IData@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4IData@@6B@
rdata$r	SEGMENT
??_R4IData@@6B@ DD 00H					; IData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIData@@@8
	DD	FLAT:??_R3IData@@8
rdata$r	ENDS
;	COMDAT ??_R3IData@@8
rdata$r	SEGMENT
??_R3IData@@8 DD 00H					; IData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IData@@8
rdata$r	ENDS
;	COMDAT ??_R2IData@@8
rdata$r	SEGMENT
??_R2IData@@8 DD FLAT:??_R1A@?0A@A@IData@@8		; IData::`RTTI Base Class Array'
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??1IData@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1IData@@MAE@XZ PROC NEAR				; IData::~IData, COMDAT
; _this$ = ecx

; 10   : 	virtual ~IData(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IData@@6B@
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1IData@@MAE@XZ ENDP					; IData::~IData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GIData@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIData@@MAEPAXI@Z PROC NEAR				; IData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1IData@@MAE@XZ	; IData::~IData
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L197394
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L197394:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GIData@@MAEPAXI@Z ENDP				; IData::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200809 DD	0ffffffffH
	DD	FLAT:$L200804
$T200807 DD	019930520H
	DD	01H
	DD	FLAT:$T200809
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1CTabBarData@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CTabBarData@@UAE@XZ PROC NEAR			; CTabBarData::~CTabBarData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CTabBarData@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 08	 add	 ecx, 8
  00029	e8 00 00 00 00	 call	 ??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >
  0002e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??1ITabBarData@@UAE@XZ
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200804:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ITabBarData@@UAE@XZ
__ehhandler$??1CTabBarData@@UAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200807
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CTabBarData@@UAE@XZ ENDP				; CTabBarData::~CTabBarData
; Function compile flags: /Odt
;	COMDAT ??_GITabBarData@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GITabBarData@@UAEPAXI@Z PROC NEAR			; ITabBarData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1ITabBarData@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L198733
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L198733:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GITabBarData@@UAEPAXI@Z ENDP				; ITabBarData::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IData@@QAE@XZ PROC NEAR				; IData::IData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IData@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0IData@@QAE@XZ ENDP					; IData::IData
_TEXT	ENDS
PUBLIC	?DelInstance@CTabBarData@@SAXXZ			; CTabBarData::DelInstance
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabbardata.cpp
_TEXT	SEGMENT
tv71 = -12						; size = 4
$T200819 = -8						; size = 4
$T200818 = -4						; size = 4
?DelInstance@CTabBarData@@SAXXZ PROC NEAR		; CTabBarData::DelInstance

; 16   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 17   : 	if(m_pTabBarData != NULL)

  00086	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A, 0 ; CTabBarData::m_pTabBarData
  0008d	74 2c		 je	 SHORT $L198738

; 18   : 		delete m_pTabBarData;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A ; CTabBarData::m_pTabBarData
  00094	89 45 f8	 mov	 DWORD PTR $T200819[ebp], eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR $T200819[ebp]
  0009a	89 4d fc	 mov	 DWORD PTR $T200818[ebp], ecx
  0009d	83 7d fc 00	 cmp	 DWORD PTR $T200818[ebp], 0
  000a1	74 11		 je	 SHORT $L200820
  000a3	6a 01		 push	 1
  000a5	8b 55 fc	 mov	 edx, DWORD PTR $T200818[ebp]
  000a8	8b 02		 mov	 eax, DWORD PTR [edx]
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR $T200818[ebp]
  000ad	ff 10		 call	 DWORD PTR [eax]
  000af	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  000b2	eb 07		 jmp	 SHORT $L198738
$L200820:
  000b4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L198738:

; 19   : 	m_pTabBarData = NULL;

  000bb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A, 0 ; CTabBarData::m_pTabBarData

; 20   : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
?DelInstance@CTabBarData@@SAXXZ ENDP			; CTabBarData::DelInstance
; Function compile flags: /Odt
_this$ = -4						; size = 4
?DataAppStart@CTabBarData@@UAEXXZ PROC NEAR		; CTabBarData::DataAppStart
; _this$ = ecx

; 23   : {

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	51		 push	 ecx
  000d4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 	//tab
; 25   : }

  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
?DataAppStart@CTabBarData@@UAEXXZ ENDP			; CTabBarData::DataAppStart
; Function compile flags: /Odt
_this$ = -4						; size = 4
?DataAppExit@CTabBarData@@UAEXXZ PROC NEAR		; CTabBarData::DataAppExit
; _this$ = ecx

; 28   : {

  000e0	55		 push	 ebp
  000e1	8b ec		 mov	 ebp, esp
  000e3	51		 push	 ecx
  000e4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	//tab
; 30   : }

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
?DataAppExit@CTabBarData@@UAEXXZ ENDP			; CTabBarData::DataAppExit
_TEXT	ENDS
PUBLIC	?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ; CTabBarData::NotifyCreateTab
PUBLIC	??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	??_R0?AVIMessageObserver@@@8			; IMessageObserver `RTTI Type Descriptor'
PUBLIC	??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
PUBLIC	?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
PUBLIC	??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
PUBLIC	??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
PUBLIC	??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
PUBLIC	??_R0?AVITabBarObserver@@@8			; ITabBarObserver `RTTI Type Descriptor'
EXTRN	___RTDynamicCast:NEAR
EXTRN	?AfxGetMessageManager@@YAPAVIMessageManager@@XZ:NEAR ; AfxGetMessageManager
xdata$x	SEGMENT
$T200831 DD	0ffffffffH
	DD	FLAT:$L200827
$T200829 DD	019930520H
	DD	01H
	DD	FLAT:$T200831
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0?AVITabBarObserver@@@8
_DATA	SEGMENT
??_R0?AVITabBarObserver@@@8 DD FLAT:??_7type_info@@6B@	; ITabBarObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVITabBarObserver@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT
??_R0?AVIMessageObserver@@@8 DD FLAT:??_7type_info@@6B@	; IMessageObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIMessageObserver@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVIMessageObserver@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
tv69 = -48						; size = 4
_this$ = -44						; size = 4
$T200826 = -40						; size = 4
$T200825 = -36						; size = 4
_pOb$199252 = -32					; size = 4
_itOb$199245 = -28					; size = 4
_listOb$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
_item$ = 8						; size = 4
?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::NotifyCreateTab
; _this$ = ecx

; 33   : {

  000f0	55		 push	 ebp
  000f1	8b ec		 mov	 ebp, esp
  000f3	6a ff		 push	 -1
  000f5	68 00 00 00 00	 push	 __ehhandler$?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z
  000fa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00100	50		 push	 eax
  00101	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00108	83 ec 24	 sub	 esp, 36			; 00000024H
  0010b	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 34   : 	list<IMessageObserver*> listOb;

  0010e	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00111	e8 00 00 00 00	 call	 ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
  00116	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 35   : 	AfxGetMessageManager()->QueryObservers( ID_MESSAGE_TABBAR,listOb);

  0011d	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  00122	89 45 d0	 mov	 DWORD PTR tv69[ebp], eax
  00125	8d 45 e8	 lea	 eax, DWORD PTR _listOb$[ebp]
  00128	50		 push	 eax
  00129	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  0012e	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  00131	8b 11		 mov	 edx, DWORD PTR [ecx]
  00133	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  00136	ff 52 0c	 call	 DWORD PTR [edx+12]

; 36   : 
; 37   : 	for( list<IMessageObserver*>::iterator itOb = listOb.begin();itOb != listOb.end();itOb++ )

  00139	8d 45 e4	 lea	 eax, DWORD PTR _itOb$199245[ebp]
  0013c	50		 push	 eax
  0013d	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00140	e8 00 00 00 00	 call	 ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
  00145	eb 0e		 jmp	 SHORT $L199249
$L199250:
  00147	6a 00		 push	 0
  00149	8d 4d dc	 lea	 ecx, DWORD PTR $T200825[ebp]
  0014c	51		 push	 ecx
  0014d	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199245[ebp]
  00150	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
$L199249:
  00155	8d 55 d8	 lea	 edx, DWORD PTR $T200826[ebp]
  00158	52		 push	 edx
  00159	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0015c	e8 00 00 00 00	 call	 ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
  00161	50		 push	 eax
  00162	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199245[ebp]
  00165	e8 00 00 00 00	 call	 ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
  0016a	0f b6 c0	 movzx	 eax, al
  0016d	85 c0		 test	 eax, eax
  0016f	74 35		 je	 SHORT $L199251

; 38   : 	{
; 39   : 		ITabBarObserver* pOb = dynamic_cast<ITabBarObserver*>(*itOb);

  00171	6a 00		 push	 0
  00173	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVITabBarObserver@@@8
  00178	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIMessageObserver@@@8
  0017d	6a 00		 push	 0
  0017f	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199245[ebp]
  00182	e8 00 00 00 00	 call	 ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
  00187	8b 08		 mov	 ecx, DWORD PTR [eax]
  00189	51		 push	 ecx
  0018a	e8 00 00 00 00	 call	 ___RTDynamicCast
  0018f	83 c4 14	 add	 esp, 20			; 00000014H
  00192	89 45 e0	 mov	 DWORD PTR _pOb$199252[ebp], eax

; 40   : 		pOb->ITabBarOb_CreateNewTab(item);

  00195	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00198	52		 push	 edx
  00199	8b 45 e0	 mov	 eax, DWORD PTR _pOb$199252[ebp]
  0019c	8b 10		 mov	 edx, DWORD PTR [eax]
  0019e	8b 4d e0	 mov	 ecx, DWORD PTR _pOb$199252[ebp]
  001a1	ff 52 04	 call	 DWORD PTR [edx+4]

; 41   : 	}

  001a4	eb a1		 jmp	 SHORT $L199250
$L199251:

; 42   : }

  001a6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001ad	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  001b0	e8 00 00 00 00	 call	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
  001b5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L200827:
  00015	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00018	e9 00 00 00 00	 jmp	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
__ehhandler$?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z:
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200829
  00022	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ENDP	; CTabBarData::NotifyCreateTab
PUBLIC	?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ; CTabBarData::NotifyOpenExistTab
xdata$x	SEGMENT
$T200839 DD	0ffffffffH
	DD	FLAT:$L200835
$T200837 DD	019930520H
	DD	01H
	DD	FLAT:$T200839
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv69 = -48						; size = 4
_this$ = -44						; size = 4
$T200834 = -40						; size = 4
$T200833 = -36						; size = 4
_pOb$199269 = -32					; size = 4
_itOb$199262 = -28					; size = 4
_listOb$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
_item$ = 8						; size = 4
?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::NotifyOpenExistTab
; _this$ = ecx

; 45   : {

  001d0	55		 push	 ebp
  001d1	8b ec		 mov	 ebp, esp
  001d3	6a ff		 push	 -1
  001d5	68 00 00 00 00	 push	 __ehhandler$?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z
  001da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  001e0	50		 push	 eax
  001e1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  001e8	83 ec 24	 sub	 esp, 36			; 00000024H
  001eb	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 46   : 	list<IMessageObserver*> listOb;

  001ee	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  001f1	e8 00 00 00 00	 call	 ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
  001f6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 47   : 	AfxGetMessageManager()->QueryObservers( ID_MESSAGE_TABBAR,listOb);

  001fd	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  00202	89 45 d0	 mov	 DWORD PTR tv69[ebp], eax
  00205	8d 45 e8	 lea	 eax, DWORD PTR _listOb$[ebp]
  00208	50		 push	 eax
  00209	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  0020e	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  00211	8b 11		 mov	 edx, DWORD PTR [ecx]
  00213	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  00216	ff 52 0c	 call	 DWORD PTR [edx+12]

; 48   : 
; 49   : 	for( list<IMessageObserver*>::iterator itOb = listOb.begin();itOb != listOb.end();itOb++ )

  00219	8d 45 e4	 lea	 eax, DWORD PTR _itOb$199262[ebp]
  0021c	50		 push	 eax
  0021d	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00220	e8 00 00 00 00	 call	 ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
  00225	eb 0e		 jmp	 SHORT $L199266
$L199267:
  00227	6a 00		 push	 0
  00229	8d 4d dc	 lea	 ecx, DWORD PTR $T200833[ebp]
  0022c	51		 push	 ecx
  0022d	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199262[ebp]
  00230	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
$L199266:
  00235	8d 55 d8	 lea	 edx, DWORD PTR $T200834[ebp]
  00238	52		 push	 edx
  00239	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0023c	e8 00 00 00 00	 call	 ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
  00241	50		 push	 eax
  00242	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199262[ebp]
  00245	e8 00 00 00 00	 call	 ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
  0024a	0f b6 c0	 movzx	 eax, al
  0024d	85 c0		 test	 eax, eax
  0024f	74 35		 je	 SHORT $L199268

; 50   : 	{
; 51   : 		ITabBarObserver* pOb = dynamic_cast<ITabBarObserver*>(*itOb);

  00251	6a 00		 push	 0
  00253	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVITabBarObserver@@@8
  00258	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIMessageObserver@@@8
  0025d	6a 00		 push	 0
  0025f	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199262[ebp]
  00262	e8 00 00 00 00	 call	 ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
  00267	8b 08		 mov	 ecx, DWORD PTR [eax]
  00269	51		 push	 ecx
  0026a	e8 00 00 00 00	 call	 ___RTDynamicCast
  0026f	83 c4 14	 add	 esp, 20			; 00000014H
  00272	89 45 e0	 mov	 DWORD PTR _pOb$199269[ebp], eax

; 52   : 		pOb->ITabBarOb_OpenExistTab(item);

  00275	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00278	52		 push	 edx
  00279	8b 45 e0	 mov	 eax, DWORD PTR _pOb$199269[ebp]
  0027c	8b 10		 mov	 edx, DWORD PTR [eax]
  0027e	8b 4d e0	 mov	 ecx, DWORD PTR _pOb$199269[ebp]
  00281	ff 52 08	 call	 DWORD PTR [edx+8]

; 53   : 	}

  00284	eb a1		 jmp	 SHORT $L199267
$L199268:

; 54   : }

  00286	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0028d	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00290	e8 00 00 00 00	 call	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
  00295	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00298	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0029f	8b e5		 mov	 esp, ebp
  002a1	5d		 pop	 ebp
  002a2	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L200835:
  00027	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
__ehhandler$?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z:
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200837
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ENDP ; CTabBarData::NotifyOpenExistTab
PUBLIC	?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z	; CTabBarData::NotifyDelTab
xdata$x	SEGMENT
$T200847 DD	0ffffffffH
	DD	FLAT:$L200843
$T200845 DD	019930520H
	DD	01H
	DD	FLAT:$T200847
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv69 = -48						; size = 4
_this$ = -44						; size = 4
$T200842 = -40						; size = 4
$T200841 = -36						; size = 4
_pOb$199285 = -32					; size = 4
_itOb$199278 = -28					; size = 4
_listOb$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
_item$ = 8						; size = 4
?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::NotifyDelTab
; _this$ = ecx

; 57   : {

  002b0	55		 push	 ebp
  002b1	8b ec		 mov	 ebp, esp
  002b3	6a ff		 push	 -1
  002b5	68 00 00 00 00	 push	 __ehhandler$?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z
  002ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  002c0	50		 push	 eax
  002c1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  002c8	83 ec 24	 sub	 esp, 36			; 00000024H
  002cb	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 	list<IMessageObserver*> listOb;

  002ce	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  002d1	e8 00 00 00 00	 call	 ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
  002d6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 59   : 	AfxGetMessageManager()->QueryObservers( ID_MESSAGE_TABBAR,listOb);

  002dd	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  002e2	89 45 d0	 mov	 DWORD PTR tv69[ebp], eax
  002e5	8d 45 e8	 lea	 eax, DWORD PTR _listOb$[ebp]
  002e8	50		 push	 eax
  002e9	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  002ee	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  002f1	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f3	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  002f6	ff 52 0c	 call	 DWORD PTR [edx+12]

; 60   : 
; 61   : 	for( list<IMessageObserver*>::iterator itOb = listOb.begin();itOb != listOb.end();itOb++ )

  002f9	8d 45 e4	 lea	 eax, DWORD PTR _itOb$199278[ebp]
  002fc	50		 push	 eax
  002fd	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00300	e8 00 00 00 00	 call	 ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
  00305	eb 0e		 jmp	 SHORT $L199282
$L199283:
  00307	6a 00		 push	 0
  00309	8d 4d dc	 lea	 ecx, DWORD PTR $T200841[ebp]
  0030c	51		 push	 ecx
  0030d	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199278[ebp]
  00310	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
$L199282:
  00315	8d 55 d8	 lea	 edx, DWORD PTR $T200842[ebp]
  00318	52		 push	 edx
  00319	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0031c	e8 00 00 00 00	 call	 ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
  00321	50		 push	 eax
  00322	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199278[ebp]
  00325	e8 00 00 00 00	 call	 ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
  0032a	0f b6 c0	 movzx	 eax, al
  0032d	85 c0		 test	 eax, eax
  0032f	74 35		 je	 SHORT $L199284

; 62   : 	{
; 63   : 		ITabBarObserver* pOb = dynamic_cast<ITabBarObserver*>(*itOb);

  00331	6a 00		 push	 0
  00333	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVITabBarObserver@@@8
  00338	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIMessageObserver@@@8
  0033d	6a 00		 push	 0
  0033f	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199278[ebp]
  00342	e8 00 00 00 00	 call	 ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
  00347	8b 08		 mov	 ecx, DWORD PTR [eax]
  00349	51		 push	 ecx
  0034a	e8 00 00 00 00	 call	 ___RTDynamicCast
  0034f	83 c4 14	 add	 esp, 20			; 00000014H
  00352	89 45 e0	 mov	 DWORD PTR _pOb$199285[ebp], eax

; 64   : 		pOb->ITabBarOb_DelTab(item);

  00355	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00358	52		 push	 edx
  00359	8b 45 e0	 mov	 eax, DWORD PTR _pOb$199285[ebp]
  0035c	8b 10		 mov	 edx, DWORD PTR [eax]
  0035e	8b 4d e0	 mov	 ecx, DWORD PTR _pOb$199285[ebp]
  00361	ff 52 0c	 call	 DWORD PTR [edx+12]

; 65   : 	}

  00364	eb a1		 jmp	 SHORT $L199283
$L199284:

; 66   : }

  00366	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0036d	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00370	e8 00 00 00 00	 call	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
  00375	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00378	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0037f	8b e5		 mov	 esp, ebp
  00381	5d		 pop	 ebp
  00382	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L200843:
  00039	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0003c	e9 00 00 00 00	 jmp	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
__ehhandler$?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z:
  00041	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200845
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ENDP	; CTabBarData::NotifyDelTab
PUBLIC	?NotifyOpenTabError@CTabBarData@@AAEXH@Z	; CTabBarData::NotifyOpenTabError
xdata$x	SEGMENT
$T200855 DD	0ffffffffH
	DD	FLAT:$L200851
$T200853 DD	019930520H
	DD	01H
	DD	FLAT:$T200855
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv69 = -48						; size = 4
_this$ = -44						; size = 4
$T200850 = -40						; size = 4
$T200849 = -36						; size = 4
_pOb$199301 = -32					; size = 4
_itOb$199294 = -28					; size = 4
_listOb$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
_iErrorCode$ = 8					; size = 4
?NotifyOpenTabError@CTabBarData@@AAEXH@Z PROC NEAR	; CTabBarData::NotifyOpenTabError
; _this$ = ecx

; 69   : {

  00390	55		 push	 ebp
  00391	8b ec		 mov	 ebp, esp
  00393	6a ff		 push	 -1
  00395	68 00 00 00 00	 push	 __ehhandler$?NotifyOpenTabError@CTabBarData@@AAEXH@Z
  0039a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  003a0	50		 push	 eax
  003a1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  003a8	83 ec 24	 sub	 esp, 36			; 00000024H
  003ab	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 70   : 	list<IMessageObserver*> listOb;

  003ae	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  003b1	e8 00 00 00 00	 call	 ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
  003b6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 71   : 	AfxGetMessageManager()->QueryObservers( ID_MESSAGE_TABBAR,listOb);

  003bd	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  003c2	89 45 d0	 mov	 DWORD PTR tv69[ebp], eax
  003c5	8d 45 e8	 lea	 eax, DWORD PTR _listOb$[ebp]
  003c8	50		 push	 eax
  003c9	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  003ce	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  003d1	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d3	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  003d6	ff 52 0c	 call	 DWORD PTR [edx+12]

; 72   : 
; 73   : 	for( list<IMessageObserver*>::iterator itOb = listOb.begin();itOb != listOb.end();itOb++ )

  003d9	8d 45 e4	 lea	 eax, DWORD PTR _itOb$199294[ebp]
  003dc	50		 push	 eax
  003dd	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  003e0	e8 00 00 00 00	 call	 ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
  003e5	eb 0e		 jmp	 SHORT $L199298
$L199299:
  003e7	6a 00		 push	 0
  003e9	8d 4d dc	 lea	 ecx, DWORD PTR $T200849[ebp]
  003ec	51		 push	 ecx
  003ed	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199294[ebp]
  003f0	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
$L199298:
  003f5	8d 55 d8	 lea	 edx, DWORD PTR $T200850[ebp]
  003f8	52		 push	 edx
  003f9	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  003fc	e8 00 00 00 00	 call	 ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
  00401	50		 push	 eax
  00402	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199294[ebp]
  00405	e8 00 00 00 00	 call	 ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
  0040a	0f b6 c0	 movzx	 eax, al
  0040d	85 c0		 test	 eax, eax
  0040f	74 35		 je	 SHORT $L199300

; 74   : 	{
; 75   : 		ITabBarObserver* pOb = dynamic_cast<ITabBarObserver*>(*itOb);

  00411	6a 00		 push	 0
  00413	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVITabBarObserver@@@8
  00418	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIMessageObserver@@@8
  0041d	6a 00		 push	 0
  0041f	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$199294[ebp]
  00422	e8 00 00 00 00	 call	 ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
  00427	8b 08		 mov	 ecx, DWORD PTR [eax]
  00429	51		 push	 ecx
  0042a	e8 00 00 00 00	 call	 ___RTDynamicCast
  0042f	83 c4 14	 add	 esp, 20			; 00000014H
  00432	89 45 e0	 mov	 DWORD PTR _pOb$199301[ebp], eax

; 76   : 		pOb->ITabBarOb_OpenTabError(iErrorCode);

  00435	8b 55 08	 mov	 edx, DWORD PTR _iErrorCode$[ebp]
  00438	52		 push	 edx
  00439	8b 45 e0	 mov	 eax, DWORD PTR _pOb$199301[ebp]
  0043c	8b 10		 mov	 edx, DWORD PTR [eax]
  0043e	8b 4d e0	 mov	 ecx, DWORD PTR _pOb$199301[ebp]
  00441	ff 52 10	 call	 DWORD PTR [edx+16]

; 77   : 	}

  00444	eb a1		 jmp	 SHORT $L199299
$L199300:

; 78   : }

  00446	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0044d	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00450	e8 00 00 00 00	 call	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
  00455	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00458	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0045f	8b e5		 mov	 esp, ebp
  00461	5d		 pop	 ebp
  00462	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L200851:
  0004b	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0004e	e9 00 00 00 00	 jmp	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
__ehhandler$?NotifyOpenTabError@CTabBarData@@AAEXH@Z:
  00053	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200853
  00058	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NotifyOpenTabError@CTabBarData@@AAEXH@Z ENDP		; CTabBarData::NotifyOpenTabError
PUBLIC	??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
PUBLIC	??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
PUBLIC	??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
PUBLIC	??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator-
PUBLIC	?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
PUBLIC	?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
PUBLIC	?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
PUBLIC	?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::push_back
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z:NEAR
EXTRN	?AfxGetDataManager2@@YAPAVIDataManager@@XZ:NEAR	; AfxGetDataManager2
; Function compile flags: /Odt
_TEXT	SEGMENT
tv86 = -40						; size = 4
tv80 = -36						; size = 4
tv72 = -32						; size = 4
tv66 = -28						; size = 4
_this$ = -24						; size = 4
$T200860 = -20						; size = 4
$T200859 = -16						; size = 4
$T200858 = -12						; size = 4
$T200857 = -8						; size = 4
_it$ = -4						; size = 4
_item$ = 8						; size = 4
?ITabBar_ChangeTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::ITabBar_ChangeTab
; _this$ = ecx

; 84   : {

  00470	55		 push	 ebp
  00471	8b ec		 mov	 ebp, esp
  00473	83 ec 28	 sub	 esp, 40			; 00000028H
  00476	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 85   : 	//
; 86   : 	if( GLOBAL_PANELCHANGEDATA->IPanelChange_IsFullScreen() )

  00479	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  0047e	89 45 e4	 mov	 DWORD PTR tv66[ebp], eax
  00481	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_PANELCHANGE
  00486	8b 45 e4	 mov	 eax, DWORD PTR tv66[ebp]
  00489	8b 10		 mov	 edx, DWORD PTR [eax]
  0048b	8b 4d e4	 mov	 ecx, DWORD PTR tv66[ebp]
  0048e	ff 52 0c	 call	 DWORD PTR [edx+12]
  00491	89 45 e0	 mov	 DWORD PTR tv72[ebp], eax
  00494	8b 45 e0	 mov	 eax, DWORD PTR tv72[ebp]
  00497	8b 10		 mov	 edx, DWORD PTR [eax]
  00499	8b 4d e0	 mov	 ecx, DWORD PTR tv72[ebp]
  0049c	ff 52 14	 call	 DWORD PTR [edx+20]
  0049f	0f b6 c0	 movzx	 eax, al
  004a2	85 c0		 test	 eax, eax
  004a4	74 26		 je	 SHORT $L199308

; 87   : 	{
; 88   : 		GLOBAL_PANELCHANGEDATA->IPanelChange_ExitFullScreen();

  004a6	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  004ab	89 45 dc	 mov	 DWORD PTR tv80[ebp], eax
  004ae	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_PANELCHANGE
  004b3	8b 4d dc	 mov	 ecx, DWORD PTR tv80[ebp]
  004b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  004b8	8b 4d dc	 mov	 ecx, DWORD PTR tv80[ebp]
  004bb	ff 52 0c	 call	 DWORD PTR [edx+12]
  004be	89 45 d8	 mov	 DWORD PTR tv86[ebp], eax
  004c1	8b 45 d8	 mov	 eax, DWORD PTR tv86[ebp]
  004c4	8b 10		 mov	 edx, DWORD PTR [eax]
  004c6	8b 4d d8	 mov	 ecx, DWORD PTR tv86[ebp]
  004c9	ff 52 10	 call	 DWORD PTR [edx+16]
$L199308:

; 89   : 	}
; 90   : 	//////////////////////
; 91   : 	vector<TAB_ITEM>::iterator it = m_vecItem.begin();

  004cc	8d 45 fc	 lea	 eax, DWORD PTR _it$[ebp]
  004cf	50		 push	 eax
  004d0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  004d3	83 c1 08	 add	 ecx, 8
  004d6	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin

; 92   : 	for( ; it != m_vecItem.end(); it++ )

  004db	eb 0e		 jmp	 SHORT $L199431
$L199432:
  004dd	6a 00		 push	 0
  004df	8d 4d f8	 lea	 ecx, DWORD PTR $T200857[ebp]
  004e2	51		 push	 ecx
  004e3	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  004e6	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
$L199431:
  004eb	8d 55 f4	 lea	 edx, DWORD PTR $T200858[ebp]
  004ee	52		 push	 edx
  004ef	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  004f2	83 c1 08	 add	 ecx, 8
  004f5	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  004fa	50		 push	 eax
  004fb	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  004fe	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
  00503	0f b6 c0	 movzx	 eax, al
  00506	85 c0		 test	 eax, eax
  00508	74 34		 je	 SHORT $L199433

; 93   : 	{
; 94   : 		if( it->eumType == item.eumType
; 95   : 			&& it->strName == item.strName )

  0050a	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  0050d	e8 00 00 00 00	 call	 ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
  00512	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00515	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00518	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  0051b	75 1f		 jne	 SHORT $L199434
  0051d	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00520	50		 push	 eax
  00521	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  00524	e8 00 00 00 00	 call	 ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
  00529	50		 push	 eax
  0052a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
  00530	83 c4 08	 add	 esp, 8
  00533	0f b6 c8	 movzx	 ecx, al
  00536	85 c9		 test	 ecx, ecx
  00538	74 02		 je	 SHORT $L199434

; 96   : 		{
; 97   : 			break;

  0053a	eb 02		 jmp	 SHORT $L199433
$L199434:

; 98   : 		}
; 99   : 	}

  0053c	eb 9f		 jmp	 SHORT $L199432
$L199433:

; 100  : 	if( it != m_vecItem.end() )

  0053e	8d 55 f0	 lea	 edx, DWORD PTR $T200859[ebp]
  00541	52		 push	 edx
  00542	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00545	83 c1 08	 add	 ecx, 8
  00548	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  0054d	50		 push	 eax
  0054e	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  00551	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
  00556	0f b6 c0	 movzx	 eax, al
  00559	85 c0		 test	 eax, eax
  0055b	74 2c		 je	 SHORT $L199436

; 101  : 	{
; 102  : 		m_iPos = int(it - m_vecItem.begin());

  0055d	8d 4d ec	 lea	 ecx, DWORD PTR $T200860[ebp]
  00560	51		 push	 ecx
  00561	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00564	83 c1 08	 add	 ecx, 8
  00567	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
  0056c	50		 push	 eax
  0056d	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  00570	e8 00 00 00 00	 call	 ??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator-
  00575	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00578	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 103  : 		NotifyOpenExistTab(item);

  0057b	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0057e	50		 push	 eax
  0057f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00582	e8 00 00 00 00	 call	 ?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ; CTabBarData::NotifyOpenExistTab

; 104  : 	}else

  00587	eb 4b		 jmp	 SHORT $L199306
$L199436:

; 105  : 	{
; 106  : 		if( m_vecItem.size() >= MAX_TAB_COUNT )

  00589	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0058c	83 c1 08	 add	 ecx, 8
  0058f	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  00594	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00597	72 0c		 jb	 SHORT $L199439

; 107  : 		{
; 108  : 			//tabclosetooltips
; 109  : 			NotifyOpenTabError( 1 );

  00599	6a 01		 push	 1
  0059b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0059e	e8 00 00 00 00	 call	 ?NotifyOpenTabError@CTabBarData@@AAEXH@Z ; CTabBarData::NotifyOpenTabError

; 110  : 		}else

  005a3	eb 2f		 jmp	 SHORT $L199306
$L199439:

; 111  : 		{
; 112  : 			m_vecItem.push_back(item);

  005a5	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  005a8	51		 push	 ecx
  005a9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  005ac	83 c1 08	 add	 ecx, 8
  005af	e8 00 00 00 00	 call	 ?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::push_back

; 113  : 			m_iPos = int(m_vecItem.size()-1);

  005b4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  005b7	83 c1 08	 add	 ecx, 8
  005ba	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  005bf	83 e8 01	 sub	 eax, 1
  005c2	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  005c5	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 114  : 			NotifyCreateTab(item);

  005c8	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  005cb	50		 push	 eax
  005cc	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  005cf	e8 00 00 00 00	 call	 ?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ; CTabBarData::NotifyCreateTab
$L199306:

; 115  : 		}
; 116  : 	}
; 117  : }

  005d4	8b e5		 mov	 esp, ebp
  005d6	5d		 pop	 ebp
  005d7	c2 04 00	 ret	 4
?ITabBar_ChangeTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z ENDP ; CTabBarData::ITabBar_ChangeTab
_TEXT	ENDS
PUBLIC	?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::erase
PUBLIC	??0TAB_ITEM@@QAE@XZ				; TAB_ITEM::TAB_ITEM
PUBLIC	??1TAB_ITEM@@QAE@XZ				; TAB_ITEM::~TAB_ITEM
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
xdata$x	SEGMENT
$T200874 DD	0ffffffffH
	DD	FLAT:$L200867
$T200869 DD	019930520H
	DD	01H
	DD	FLAT:$T200874
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T200866 = -96						; size = 4
$T200865 = -92						; size = 4
$T200864 = -88						; size = 4
$T200863 = -84						; size = 4
_itemexisted$ = -80					; size = 60
__$ArrayPad$ = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_item$ = 8						; size = 4
?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::ITabBar_DeleteTab
; _this$ = ecx

; 120  : {

  005e0	55		 push	 ebp
  005e1	8b ec		 mov	 ebp, esp
  005e3	6a ff		 push	 -1
  005e5	68 00 00 00 00	 push	 __ehhandler$?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z
  005ea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  005f0	50		 push	 eax
  005f1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  005f8	83 ec 58	 sub	 esp, 88			; 00000058H
  005fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00600	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00603	89 4d 9c	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 	TAB_ITEM itemexisted;

  00606	8d 4d b0	 lea	 ecx, DWORD PTR _itemexisted$[ebp]
  00609	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@XZ
  0060e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 122  : 	vector<TAB_ITEM>::iterator it = m_vecItem.begin();

  00615	8d 45 f0	 lea	 eax, DWORD PTR _it$[ebp]
  00618	50		 push	 eax
  00619	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0061c	83 c1 08	 add	 ecx, 8
  0061f	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin

; 123  : 	for( ; it != m_vecItem.end(); it++ )

  00624	eb 0e		 jmp	 SHORT $L199451
$L199452:
  00626	6a 00		 push	 0
  00628	8d 4d ac	 lea	 ecx, DWORD PTR $T200863[ebp]
  0062b	51		 push	 ecx
  0062c	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  0062f	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
$L199451:
  00634	8d 55 a8	 lea	 edx, DWORD PTR $T200864[ebp]
  00637	52		 push	 edx
  00638	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0063b	83 c1 08	 add	 ecx, 8
  0063e	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  00643	50		 push	 eax
  00644	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  00647	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
  0064c	0f b6 c0	 movzx	 eax, al
  0064f	85 c0		 test	 eax, eax
  00651	74 34		 je	 SHORT $L199453

; 124  : 	{
; 125  : 		if( it->eumType == item.eumType
; 126  : 			&& it->strName == item.strName )

  00653	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  00656	e8 00 00 00 00	 call	 ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
  0065b	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0065e	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00661	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00664	75 1f		 jne	 SHORT $L199454
  00666	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00669	50		 push	 eax
  0066a	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  0066d	e8 00 00 00 00	 call	 ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
  00672	50		 push	 eax
  00673	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
  00679	83 c4 08	 add	 esp, 8
  0067c	0f b6 c8	 movzx	 ecx, al
  0067f	85 c9		 test	 ecx, ecx
  00681	74 02		 je	 SHORT $L199454

; 127  : 		{
; 128  : 			break;

  00683	eb 02		 jmp	 SHORT $L199453
$L199454:

; 129  : 		}
; 130  : 	}

  00685	eb 9f		 jmp	 SHORT $L199452
$L199453:

; 131  : 	if( it != m_vecItem.end() )

  00687	8d 55 a4	 lea	 edx, DWORD PTR $T200865[ebp]
  0068a	52		 push	 edx
  0068b	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0068e	83 c1 08	 add	 ecx, 8
  00691	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  00696	50		 push	 eax
  00697	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  0069a	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
  0069f	0f b6 c0	 movzx	 eax, al
  006a2	85 c0		 test	 eax, eax
  006a4	74 41		 je	 SHORT $L199456

; 132  : 	{
; 133  : 		m_vecItem.erase( it );

  006a6	8b 4d f0	 mov	 ecx, DWORD PTR _it$[ebp]
  006a9	51		 push	 ecx
  006aa	8d 55 a0	 lea	 edx, DWORD PTR $T200866[ebp]
  006ad	52		 push	 edx
  006ae	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  006b1	83 c1 08	 add	 ecx, 8
  006b4	e8 00 00 00 00	 call	 ?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::erase

; 134  : 
; 135  : 		m_iPos--;

  006b9	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  006bc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  006bf	83 e9 01	 sub	 ecx, 1
  006c2	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  006c5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 136  : 		if( m_iPos < 0 )

  006c8	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  006cb	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  006cf	7d 0a		 jge	 SHORT $L199458

; 137  : 		{
; 138  : 			m_iPos = 0;

  006d1	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  006d4	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$L199458:

; 139  : 		}
; 140  : 		NotifyDelTab(item);

  006db	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  006de	52		 push	 edx
  006df	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  006e2	e8 00 00 00 00	 call	 ?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ; CTabBarData::NotifyDelTab
$L199456:

; 141  : 	}
; 142  : }

  006e7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  006ee	8d 4d b0	 lea	 ecx, DWORD PTR _itemexisted$[ebp]
  006f1	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
  006f6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006f9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00700	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00703	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00708	8b e5		 mov	 esp, ebp
  0070a	5d		 pop	 ebp
  0070b	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L200867:
  0005d	8d 4d b0	 lea	 ecx, DWORD PTR _itemexisted$[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1TAB_ITEM@@QAE@XZ
__ehhandler$?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z:
  00065	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200869
  0006a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z ENDP ; CTabBarData::ITabBar_DeleteTab
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200881 DD	0ffffffffH
	DD	FLAT:$L200876
$T200879 DD	019930520H
	DD	01H
	DD	FLAT:$T200881
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0TAB_ITEM@@QAE@XZ PROC NEAR				; TAB_ITEM::TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0TAB_ITEM@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 20	 add	 ecx, 32			; 00000020H
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00045	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200876:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0TAB_ITEM@@QAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200879
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0TAB_ITEM@@QAE@XZ ENDP				; TAB_ITEM::TAB_ITEM
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200891 DD	0ffffffffH
	DD	FLAT:$L200886
$T200889 DD	019930520H
	DD	01H
	DD	FLAT:$T200891
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TAB_ITEM@@QAE@XZ PROC NEAR				; TAB_ITEM::~TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1TAB_ITEM@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 20	 add	 ecx, 32			; 00000020H
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200886:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1TAB_ITEM@@QAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200889
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1TAB_ITEM@@QAE@XZ ENDP				; TAB_ITEM::~TAB_ITEM
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ITabBar_GetCurPos@CTabBarData@@UAEHXZ PROC NEAR	; CTabBarData::ITabBar_GetCurPos
; _this$ = ecx

; 145  : {

  00710	55		 push	 ebp
  00711	8b ec		 mov	 ebp, esp
  00713	51		 push	 ecx
  00714	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : 	return m_iPos;

  00717	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0071a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 147  : } 

  0071d	8b e5		 mov	 esp, ebp
  0071f	5d		 pop	 ebp
  00720	c3		 ret	 0
?ITabBar_GetCurPos@CTabBarData@@UAEHXZ ENDP		; CTabBarData::ITabBar_GetCurPos
_TEXT	ENDS
PUBLIC	??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
PUBLIC	??4TAB_ITEM@@QAEAAU0@ABU0@@Z			; TAB_ITEM::operator=
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_TabItem$ = 8						; size = 4
?ITabBar_GetCurItem@CTabBarData@@UAE_NAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::ITabBar_GetCurItem
; _this$ = ecx

; 150  : {

  00730	55		 push	 ebp
  00731	8b ec		 mov	 ebp, esp
  00733	51		 push	 ecx
  00734	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 151  : 	if( m_iPos >= 0 && m_iPos < m_vecItem.size() )

  00737	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0073a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0073e	7c 32		 jl	 SHORT $L199470
  00740	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00743	83 c1 08	 add	 ecx, 8
  00746	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  0074b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0074e	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  00751	73 1f		 jae	 SHORT $L199470

; 152  : 	{
; 153  : 		TabItem = m_vecItem[m_iPos];

  00753	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00756	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00759	50		 push	 eax
  0075a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0075d	83 c1 08	 add	 ecx, 8
  00760	e8 00 00 00 00	 call	 ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
  00765	50		 push	 eax
  00766	8b 4d 08	 mov	 ecx, DWORD PTR _TabItem$[ebp]
  00769	e8 00 00 00 00	 call	 ??4TAB_ITEM@@QAEAAU0@ABU0@@Z

; 154  : 		return true;

  0076e	b0 01		 mov	 al, 1
  00770	eb 02		 jmp	 SHORT $L199469
$L199470:

; 155  : 	}else
; 156  : 	{
; 157  : 		return false;

  00772	32 c0		 xor	 al, al
$L199469:

; 158  : 	}	
; 159  : }

  00774	8b e5		 mov	 esp, ebp
  00776	5d		 pop	 ebp
  00777	c2 04 00	 ret	 4
?ITabBar_GetCurItem@CTabBarData@@UAE_NAAUTAB_ITEM@@@Z ENDP ; CTabBarData::ITabBar_GetCurItem
_TEXT	ENDS
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
; Function compile flags: /Odt
;	COMDAT ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4TAB_ITEM@@QAEAAU0@ABU0@@Z PROC NEAR			; TAB_ITEM::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0001a	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00020	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00023	83 c1 20	 add	 ecx, 32			; 00000020H
  00026	51		 push	 ecx
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 c1 20	 add	 ecx, 32			; 00000020H
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??4TAB_ITEM@@QAEAAU0@ABU0@@Z ENDP			; TAB_ITEM::operator=
_TEXT	ENDS
PUBLIC	?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear
PUBLIC	??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z ; std::back_inserter<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
PUBLIC	??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z ; std::copy<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T200903 = -16						; size = 4
$T200902 = -12						; size = 4
$T200901 = -8						; size = 4
$T200900 = -4						; size = 4
_vec$ = 8						; size = 4
?ITabBar_GetTabBarData@CTabBarData@@UAEXAAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@Z PROC NEAR ; CTabBarData::ITabBar_GetTabBarData
; _this$ = ecx

; 162  : {

  00780	55		 push	 ebp
  00781	8b ec		 mov	 ebp, esp
  00783	83 ec 14	 sub	 esp, 20			; 00000014H
  00786	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 163  : 	vec.clear();

  00789	8b 4d 08	 mov	 ecx, DWORD PTR _vec$[ebp]
  0078c	e8 00 00 00 00	 call	 ?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear

; 164  : 	copy(m_vecItem.begin(), m_vecItem.end(), back_inserter(vec));

  00791	8b 45 08	 mov	 eax, DWORD PTR _vec$[ebp]
  00794	50		 push	 eax
  00795	8d 4d fc	 lea	 ecx, DWORD PTR $T200900[ebp]
  00798	51		 push	 ecx
  00799	e8 00 00 00 00	 call	 ??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z ; std::back_inserter<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
  0079e	83 c4 08	 add	 esp, 8
  007a1	8b 10		 mov	 edx, DWORD PTR [eax]
  007a3	52		 push	 edx
  007a4	8d 45 f8	 lea	 eax, DWORD PTR $T200901[ebp]
  007a7	50		 push	 eax
  007a8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  007ab	83 c1 08	 add	 ecx, 8
  007ae	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  007b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  007b5	51		 push	 ecx
  007b6	8d 55 f4	 lea	 edx, DWORD PTR $T200902[ebp]
  007b9	52		 push	 edx
  007ba	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  007bd	83 c1 08	 add	 ecx, 8
  007c0	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
  007c5	8b 00		 mov	 eax, DWORD PTR [eax]
  007c7	50		 push	 eax
  007c8	8d 4d f0	 lea	 ecx, DWORD PTR $T200903[ebp]
  007cb	51		 push	 ecx
  007cc	e8 00 00 00 00	 call	 ??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z ; std::copy<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
  007d1	83 c4 10	 add	 esp, 16			; 00000010H

; 165  : }

  007d4	8b e5		 mov	 esp, ebp
  007d6	5d		 pop	 ebp
  007d7	c2 04 00	 ret	 4
?ITabBar_GetTabBarData@CTabBarData@@UAEXAAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@Z ENDP ; CTabBarData::ITabBar_GetTabBarData
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy
PUBLIC	??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >
PUBLIC	??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ		; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ ; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L200914
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L200915
$L200914:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L200915:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*
PUBLIC	??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+
; Function compile flags: /Odt
;	COMDAT ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T200919 = -8						; size = 4
$T200918 = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[], COMDAT
; _this$ = ecx

; 554  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		return (*(begin() + _Pos));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d f8	 lea	 ecx, DWORD PTR $T200919[ebp]
  00010	51		 push	 ecx
  00011	8d 55 fc	 lea	 edx, DWORD PTR $T200918[ebp]
  00014	52		 push	 edx
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*

; 556  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill
PUBLIC	?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::capacity
PUBLIC	?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::insert
; Function compile flags: /Odt
;	COMDAT ?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T200923 = -8						; size = 4
$T200922 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0000a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  00012	8b f0		 mov	 esi, eax
  00014	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::capacity
  0001c	3b f0		 cmp	 esi, eax
  0001e	73 1d		 jae	 SHORT $L199595

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	50		 push	 eax
  00024	6a 01		 push	 1
  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	52		 push	 edx
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill
  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  0003b	eb 1f		 jmp	 SHORT $L199594
$L199595:

; 583  : 			insert(end(), _Val);

  0003d	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00040	52		 push	 edx
  00041	8d 45 fc	 lea	 eax, DWORD PTR $T200922[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	51		 push	 ecx
  00050	8d 55 f8	 lea	 edx, DWORD PTR $T200923[ebp]
  00053	52		 push	 edx
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::insert
$L199594:

; 584  : 		}

  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::push_back
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy
PUBLIC	??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ; std::copy<TAB_ITEM *,TAB_ITEM *>
; Function compile flags: /Odt
;	COMDAT ?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::erase, COMDAT
; _this$ = ecx

; 723  : 		{	// erase element at where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 724  : 		copy(_ITER_BASE(_Where) + 1, _Mylast, _ITER_BASE(_Where));

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00011	52		 push	 edx
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00015	83 c0 3c	 add	 eax, 60			; 0000003cH
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ; std::copy<TAB_ITEM *,TAB_ITEM *>
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  : 		_Destroy(_Mylast - 1, _Mylast);

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00027	52		 push	 edx
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002e	83 e9 3c	 sub	 ecx, 60			; 0000003cH
  00031	51		 push	 ecx
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy

; 726  : 		--_Mylast;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00040	83 e8 3c	 sub	 eax, 60			; 0000003cH
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 727  : 		return (_Where);

  00049	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0004c	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0004f	89 02		 mov	 DWORD PTR [edx], eax
  00051	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 728  : 		}

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::erase
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy

; 745  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
PUBLIC	??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00027	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 281  : 		}

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 364  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 365  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy

; 366  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
PUBLIC	??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin, COMDAT
; _this$ = ecx

; 376  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 377  : 		return (iterator(_Nextnode(_Myhead)));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00013	83 c4 04	 add	 esp, 4
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	52		 push	 edx
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 378  : 		}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end, COMDAT
; _this$ = ecx

; 386  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 387  : 		return (iterator(_Myhead));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 388  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 239  : 			{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 240  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*

; 241  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 255  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 257  : 			++*this;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++

; 258  : 			return (_Tmp);

  00019	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 259  : 			}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
; Function compile flags: /Odt
;	COMDAT ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 201  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 203  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->, COMDAT
; _this$ = ecx

; 224  : 			{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 225  : 			return (&**this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*

; 226  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 236  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 237  : 			++*this;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++

; 238  : 			return (_Tmp);

  00019	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 239  : 			}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator-
; Function compile flags: /Odt
;	COMDAT ??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T200949 = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR $T200949[ebp], ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR $T200949[ebp]
  00018	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator-

; 280  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator==
; Function compile flags: /Odt
;	COMDAT ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 159  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 161  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L200954
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L200955
$L200954:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L200955:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::capacity
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Insert_n
; Function compile flags: /Odt
;	COMDAT ?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
_this$ = -16						; size = 4
$T200961 = -12						; size = 4
$T200958 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  00011	85 c0		 test	 eax, eax
  00013	75 09		 jne	 SHORT $L200959
  00015	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0001c	eb 18		 jmp	 SHORT $L200960
$L200959:
  0001e	8d 45 f8	 lea	 eax, DWORD PTR $T200958[ebp]
  00021	50		 push	 eax
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
  0002a	50		 push	 eax
  0002b	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002e	e8 00 00 00 00	 call	 ??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator-
  00033	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$L200960:
  00036	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00039	89 4d fc	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0003c	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0003f	52		 push	 edx
  00040	6a 01		 push	 1
  00042	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00045	50		 push	 eax
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Insert_n

; 623  : 		return (begin() + _Off);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	52		 push	 edx
  00056	8d 45 f4	 lea	 eax, DWORD PTR $T200961[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+
  00069	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::insert
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen
PUBLIC	?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::allocate
PUBLIC	?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
; Function compile flags: /Odt
;	COMDAT ?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L199691

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 49		 jmp	 SHORT $L199690
$L199691:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L199693

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen

; 776  : 		else

  00044	eb 30		 jmp	 SHORT $L199692
$L199693:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00067	6b d2 3c	 imul	 edx, 60			; 0000003cH
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L199692:

; 781  : 			}
; 782  : 		return (true);

  00076	b0 01		 mov	 al, 1
$L199690:

; 783  : 		}

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::deallocate
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 3c		 je	 SHORT $L199706

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	8b c1		 mov	 eax, ecx
  00034	99		 cdq
  00035	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0003a	f7 f9		 idiv	 ecx
  0003c	50		 push	 eax
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::deallocate
$L199706:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Uninitialized_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
;	COMDAT ?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Uninitialized_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00025	03 45 08	 add	 eax, DWORD PTR __Ptr$[ebp]

; 880  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
; Function compile flags: /Odt
;	COMDAT ??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z PROC NEAR ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z ; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z ENDP ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ PROC NEAR	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ ENDP		; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode, COMDAT

; 107  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 109  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
PUBLIC	?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200984 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T200986 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L200980
$T200985 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T200986
$T200982 DD	019930520H
	DD	02H
	DD	FLAT:$T200984
	DD	01H
	DD	FLAT:$T200985
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
_TEXT	SEGMENT
tv93 = -36						; size = 4
tv92 = -32						; size = 4
_this$ = -28						; size = 4
__Pnode$ = -24						; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode, COMDAT
; _this$ = ecx

; 898  : 		{	// allocate a head node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 14	 sub	 esp, 20			; 00000014H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00025	6a 01		 push	 1
  00027	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
  0002f	89 45 e8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 900  : 		int _Linkcnt = 0;

  00032	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Linkcnt$[ebp], 0

; 901  : 
; 902  : 		_TRY_BEGIN

  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

  00040	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00049	83 c4 04	 add	 esp, 4
  0004c	89 45 e0	 mov	 DWORD PTR tv92[ebp], eax
  0004f	8d 4d e8	 lea	 ecx, DWORD PTR __Pnode$[ebp]
  00052	51		 push	 ecx
  00053	8b 55 e0	 mov	 edx, DWORD PTR tv92[ebp]
  00056	52		 push	 edx
  00057	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 01	 add	 ecx, 1
  0005d	e8 00 00 00 00	 call	 ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct

; 904  : 		++_Linkcnt;

  00062	8b 45 ec	 mov	 eax, DWORD PTR __Linkcnt$[ebp]
  00065	83 c0 01	 add	 eax, 1
  00068	89 45 ec	 mov	 DWORD PTR __Linkcnt$[ebp], eax

; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

  0006b	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  00074	83 c4 04	 add	 esp, 4
  00077	89 45 dc	 mov	 DWORD PTR tv93[ebp], eax
  0007a	8d 55 e8	 lea	 edx, DWORD PTR __Pnode$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 dc	 mov	 eax, DWORD PTR tv93[ebp]
  00081	50		 push	 eax
  00082	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	83 c1 01	 add	 ecx, 1
  00088	e8 00 00 00 00	 call	 ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
  0008d	eb 35		 jmp	 SHORT $L200979
$L200980:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)

  0008f	83 7d ec 00	 cmp	 DWORD PTR __Linkcnt$[ebp], 0
  00093	7e 18		 jle	 SHORT $L199742

; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));

  00095	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  0009e	83 c4 04	 add	 esp, 4
  000a1	50		 push	 eax
  000a2	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	83 c1 01	 add	 ecx, 1
  000a8	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
$L199742:

; 909  : 		this->_Alnod.deallocate(_Pnode, 1);

  000ad	6a 01		 push	 1
  000af	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000b2	52		 push	 edx
  000b3	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 910  : 		_RERAISE;

  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200979:

; 911  : 		_CATCH_END

  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 912  : 		return (_Pnode);

  000cb	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$L200977:

; 913  : 		}

  000ce	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000d1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200982
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
PUBLIC	?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy, COMDAT
; _this$ = ecx

; 929  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 930  : 		clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 01	 add	 ecx, 1
  00025	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy

; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  00036	83 c4 04	 add	 esp, 4
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 01	 add	 ecx, 1
  00040	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy

; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

  00045	6a 01		 push	 1
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004d	52		 push	 edx
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 934  : 		_Myhead = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 935  : 		}

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
PUBLIC	??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
;	COMDAT ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 82   : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
  0001d	8d 4d 08	 lea	 ecx, DWORD PTR __Al$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 02	 add	 ecx, 2
  00027	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>

; 83   : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ PROC NEAR ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ENDP	; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator

; 236  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 249  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 250  : 			++(*(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++

; 251  : 			return (*this);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 252  : 			}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
; Function compile flags: /Odt
;	COMDAT ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 160  : 			{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 			return (_Myval(_Ptr));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
  00012	83 c4 04	 add	 esp, 4

; 162  : 			}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 196  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 			return (_Ptr == _Right._Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 198  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 			++this->_Myptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 232  : 			}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=
; Function compile flags: /Odt
;	COMDAT ??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	99		 cdq
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	f7 f9		 idiv	 ecx

; 144  : 			}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator-
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 152  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 156  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ	; std::allocator<TAB_ITEM>::max_size
; Function compile flags: /Odt
;	COMDAT ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ ; std::allocator<TAB_ITEM>::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>
PUBLIC	??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z ; std::fill<TAB_ITEM *,TAB_ITEM>
PUBLIC	??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ; std::copy_backward<TAB_ITEM *,TAB_ITEM *>
PUBLIC	??0TAB_ITEM@@QAE@ABU0@@Z			; TAB_ITEM::TAB_ITEM
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201032 DD	0ffffffffH
	DD	FLAT:$L201027
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T201034 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L201024
$T201035 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L201026
$T201033 DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T201034
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T201035
$T201029 DD	019930520H
	DD	05H
	DD	FLAT:$T201032
	DD	02H
	DD	FLAT:$T201033
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z
_TEXT	SEGMENT
tv244 = -112						; size = 4
tv65 = -108						; size = 4
tv89 = -104						; size = 4
_this$ = -100						; size = 4
__Oldend$199851 = -96					; size = 4
__Newvec$199830 = -92					; size = 4
__Ptr$199831 = -88					; size = 4
__Capacity$ = -84					; size = 4
__Tmp$ = -80						; size = 60
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00024	53		 push	 ebx
  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002a	89 4d 9c	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0002d	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00030	50		 push	 eax
  00031	8d 4d b0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00034	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@ABU0@@Z
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 811  : 		size_type _Capacity = capacity();

  00040	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::capacity
  00048	89 45 ac	 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  0004b	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0004f	75 05		 jne	 SHORT $L199824

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00051	e9 cf 02 00 00	 jmp	 $L199825
$L199824:
  00056	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  0005e	8b f0		 mov	 esi, eax
  00060	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
  00068	2b c6		 sub	 eax, esi
  0006a	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0006d	73 0d		 jae	 SHORT $L199826

; 816  : 			_Xlen();	// result too long

  0006f	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  00077	e9 a9 02 00 00	 jmp	 $L199825
$L199826:
  0007c	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  00084	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00087	39 45 ac	 cmp	 DWORD PTR __Capacity$[ebp], eax
  0008a	0f 83 68 01 00
	00		 jae	 $L199828

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00090	8b 75 ac	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00093	d1 ee		 shr	 esi, 1
  00095	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
  0009d	2b c6		 sub	 eax, esi
  0009f	3b 45 ac	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  000a2	73 09		 jae	 SHORT $L201021
  000a4	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  000ab	eb 0b		 jmp	 SHORT $L201022
$L201021:
  000ad	8b 4d ac	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  000b0	d1 e9		 shr	 ecx, 1
  000b2	03 4d ac	 add	 ecx, DWORD PTR __Capacity$[ebp]
  000b5	89 4d 98	 mov	 DWORD PTR tv89[ebp], ecx
$L201022:
  000b8	8b 55 98	 mov	 edx, DWORD PTR tv89[ebp]
  000bb	89 55 ac	 mov	 DWORD PTR __Capacity$[ebp], edx

; 821  : 			if (_Capacity < size() + _Count)

  000be	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  000c6	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000c9	39 45 ac	 cmp	 DWORD PTR __Capacity$[ebp], eax
  000cc	73 0e		 jae	 SHORT $L199829

; 822  : 				_Capacity = size() + _Count;

  000ce	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  000d6	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000d9	89 45 ac	 mov	 DWORD PTR __Capacity$[ebp], eax
$L199829:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000dc	8b 45 ac	 mov	 eax, DWORD PTR __Capacity$[ebp]
  000df	50		 push	 eax
  000e0	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::allocate
  000e8	89 45 a4	 mov	 DWORD PTR __Newvec$199830[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  000eb	8b 4d a4	 mov	 ecx, DWORD PTR __Newvec$199830[ebp]
  000ee	89 4d a8	 mov	 DWORD PTR __Ptr$199831[ebp], ecx

; 825  : 
; 826  : 			_TRY_BEGIN

  000f1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000f5	8b 55 a4	 mov	 edx, DWORD PTR __Newvec$199830[ebp]
  000f8	52		 push	 edx
  000f9	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00103	52		 push	 edx
  00104	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>
  0010c	89 45 94	 mov	 DWORD PTR tv65[ebp], eax
  0010f	8b 45 94	 mov	 eax, DWORD PTR tv65[ebp]
  00112	89 45 a8	 mov	 DWORD PTR __Ptr$199831[ebp], eax

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00115	8d 4d b0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00118	51		 push	 ecx
  00119	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0011c	52		 push	 edx
  0011d	8b 45 a8	 mov	 eax, DWORD PTR __Ptr$199831[ebp]
  00120	50		 push	 eax
  00121	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill
  00129	89 45 90	 mov	 DWORD PTR tv244[ebp], eax
  0012c	8b 4d 90	 mov	 ecx, DWORD PTR tv244[ebp]
  0012f	89 4d a8	 mov	 DWORD PTR __Ptr$199831[ebp], ecx

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00132	8b 55 a8	 mov	 edx, DWORD PTR __Ptr$199831[ebp]
  00135	52		 push	 edx
  00136	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00139	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0013c	51		 push	 ecx
  0013d	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00140	52		 push	 edx
  00141	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>
  00149	eb 29		 jmp	 SHORT $L201023
$L201024:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  0014b	8b 45 a8	 mov	 eax, DWORD PTR __Ptr$199831[ebp]
  0014e	50		 push	 eax
  0014f	8b 4d a4	 mov	 ecx, DWORD PTR __Newvec$199830[ebp]
  00152	51		 push	 ecx
  00153	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  0015b	8b 55 ac	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0015e	52		 push	 edx
  0015f	8b 45 a4	 mov	 eax, DWORD PTR __Newvec$199830[ebp]
  00162	50		 push	 eax
  00163	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::deallocate

; 834  : 			_RERAISE;

  0016b	6a 00		 push	 0
  0016d	6a 00		 push	 0
  0016f	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201023:

; 835  : 			_CATCH_END

  00174	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 836  : 
; 837  : 			_Count += size();

  0017b	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  00183	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00186	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  00189	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00190	74 3a		 je	 SHORT $L199838

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  00192	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  00195	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00198	50		 push	 eax
  00199	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0019c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0019f	52		 push	 edx
  001a0	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  001a8	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  001ab	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  001ae	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001b1	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  001b4	99		 cdq
  001b5	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  001ba	f7 f9		 idiv	 ecx
  001bc	50		 push	 eax
  001bd	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  001c0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001c3	50		 push	 eax
  001c4	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::deallocate
$L199838:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001cc	8b 4d ac	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  001cf	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  001d2	03 4d a4	 add	 ecx, DWORD PTR __Newvec$199830[ebp]
  001d5	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  001d8	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 844  : 			_Mylast = _Newvec + _Count;

  001db	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001de	6b c0 3c	 imul	 eax, 60			; 0000003cH
  001e1	03 45 a4	 add	 eax, DWORD PTR __Newvec$199830[ebp]
  001e4	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  001e7	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

  001ea	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  001ed	8b 45 a4	 mov	 eax, DWORD PTR __Newvec$199830[ebp]
  001f0	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001f3	e9 2d 01 00 00	 jmp	 $L199825
$L199828:
  001f8	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  001fb	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001fe	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  00201	99		 cdq
  00202	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00207	f7 f9		 idiv	 ecx
  00209	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0020c	0f 83 af 00 00
	00		 jae	 $L199841

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00212	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00215	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00218	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  0021b	52		 push	 edx
  0021c	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  0021f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00222	51		 push	 ecx
  00223	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00226	52		 push	 edx
  00227	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0022a	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>

; 851  : 
; 852  : 			_TRY_BEGIN

  0022f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  00233	8d 45 b0	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00236	50		 push	 eax
  00237	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0023a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0023d	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  00240	99		 cdq
  00241	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00246	f7 f9		 idiv	 ecx
  00248	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0024b	2b d0		 sub	 edx, eax
  0024d	52		 push	 edx
  0024e	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00251	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00254	51		 push	 ecx
  00255	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00258	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill
  0025d	eb 28		 jmp	 SHORT $L201025
$L201026:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  0025f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00262	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00265	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00268	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0026b	52		 push	 edx
  0026c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0026f	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00272	03 4d 08	 add	 ecx, DWORD PTR __Where$[ebp]
  00275	51		 push	 ecx
  00276	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00279	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy

; 857  : 			_RERAISE;

  0027e	6a 00		 push	 0
  00280	6a 00		 push	 0
  00282	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201025:

; 858  : 			_CATCH_END

  00287	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 859  : 
; 860  : 			_Mylast += _Count;

  0028e	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00291	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00294	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00297	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0029a	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0029d	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  002a0	8d 55 b0	 lea	 edx, DWORD PTR __Tmp$[ebp]
  002a3	52		 push	 edx
  002a4	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002a7	6b c0 3c	 imul	 eax, 60			; 0000003cH
  002aa	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  002ad	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002b0	2b d0		 sub	 edx, eax
  002b2	52		 push	 edx
  002b3	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  002b6	50		 push	 eax
  002b7	e8 00 00 00 00	 call	 ??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z ; std::fill<TAB_ITEM *,TAB_ITEM>
  002bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002bf	eb 64		 jmp	 SHORT $L199825
$L199841:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  002c1	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  002c4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002c7	89 55 a0	 mov	 DWORD PTR __Oldend$199851[ebp], edx

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002ca	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  002cd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002d0	51		 push	 ecx
  002d1	8b 55 a0	 mov	 edx, DWORD PTR __Oldend$199851[ebp]
  002d4	52		 push	 edx
  002d5	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002d8	6b c0 3c	 imul	 eax, 60			; 0000003cH
  002db	8b 4d a0	 mov	 ecx, DWORD PTR __Oldend$199851[ebp]
  002de	2b c8		 sub	 ecx, eax
  002e0	51		 push	 ecx
  002e1	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  002e4	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>
  002e9	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  002ec	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  002ef	8b 45 a0	 mov	 eax, DWORD PTR __Oldend$199851[ebp]
  002f2	50		 push	 eax
  002f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002f6	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  002f9	8b 55 a0	 mov	 edx, DWORD PTR __Oldend$199851[ebp]
  002fc	2b d1		 sub	 edx, ecx
  002fe	52		 push	 edx
  002ff	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00302	50		 push	 eax
  00303	e8 00 00 00 00	 call	 ??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ; std::copy_backward<TAB_ITEM *,TAB_ITEM *>
  00308	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  0030b	8d 4d b0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0030e	51		 push	 ecx
  0030f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00312	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00315	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  00318	52		 push	 edx
  00319	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0031c	50		 push	 eax
  0031d	e8 00 00 00 00	 call	 ??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z ; std::fill<TAB_ITEM *,TAB_ITEM>
  00322	83 c4 0c	 add	 esp, 12			; 0000000cH
$L199825:

; 873  : 			}
; 874  : 		}

  00325	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0032c	8d 4d b0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0032f	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
$L201020:
  00334	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00337	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0033e	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00341	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00346	5f		 pop	 edi
  00347	5e		 pop	 esi
  00348	5b		 pop	 ebx
  00349	8b e5		 mov	 esp, ebp
  0034b	5d		 pop	 ebp
  0034c	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201027:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TAB_ITEM@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201029
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Insert_n
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201046 DD	0ffffffffH
	DD	FLAT:$L201042
$T201044 DD	019930520H
	DD	01H
	DD	FLAT:$T201046
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
	ORG $-30
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T201041 = -80						; size = 28
$T201040 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T201041[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T201041[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T201040[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T201040[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201039:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201042:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T201041[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201044
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z PROC NEAR	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z PROC NEAR ; std::allocator<TAB_ITEM>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ENDP ; std::allocator<TAB_ITEM>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z ; std::_Allocate<TAB_ITEM>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z PROC NEAR ; std::allocator<TAB_ITEM>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z ; std::_Allocate<TAB_ITEM>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z ENDP ; std::allocator<TAB_ITEM>::allocate
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode, COMDAT

; 112  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 114  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval, COMDAT

; 117  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 119  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy
; Function compile flags: /Odt
;	COMDAT ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnext$ = -8						; size = 4
__Pnode$ = -4						; size = 4
?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear, COMDAT
; _this$ = ecx

; 610  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00015	83 c4 04	 add	 esp, 4
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	89 55 fc	 mov	 DWORD PTR __Pnode$[ebp], edx

; 613  : 		_Nextnode(_Myhead) = _Myhead;

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00029	83 c4 04	 add	 esp, 4
  0002c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00032	89 08		 mov	 DWORD PTR [eax], ecx

; 614  : 		_Prevnode(_Myhead) = _Myhead;

  00034	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  00040	83 c4 04	 add	 esp, 4
  00043	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	89 10		 mov	 DWORD PTR [eax], edx

; 615  : 		_Mysize = 0;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

  00055	eb 06		 jmp	 SHORT $L199888
$L199889:
  00057	8b 4d f8	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  0005a	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx
$L199888:
  0005d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00063	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00066	74 2d		 je	 SHORT $L199885

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

  00068	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00071	83 c4 04	 add	 esp, 4
  00074	8b 10		 mov	 edx, DWORD PTR [eax]
  00076	89 55 f8	 mov	 DWORD PTR __Pnext$[ebp], edx

; 620  : 			this->_Alnod.destroy(_Pnode);

  00079	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy

; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

  00085	6a 01		 push	 1
  00087	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 622  : 			}

  00093	eb c2		 jmp	 SHORT $L199889
$L199885:

; 623  : 		}

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear
_TEXT	ENDS
PUBLIC	??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>
PUBLIC	??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
;	COMDAT ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = 8						; size = 1
??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 64   : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
  0001d	8d 4d 08	 lea	 ecx, DWORD PTR __Al$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 01	 add	 ecx, 1
  00027	e8 00 00 00 00	 call	 ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>

; 65   : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 157  : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 170  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 			_Ptr = _Nextnode(_Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00012	83 c4 04	 add	 esp, 4
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 02		 mov	 DWORD PTR [edx], eax

; 172  : 			return (*this);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 173  : 			}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	6b c0 3c	 imul	 eax, 60			; 0000003cH
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 01		 add	 eax, DWORD PTR [ecx]
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	89 02		 mov	 DWORD PTR [edx], eax

; 257  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*
_TEXT	ENDS
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201091 DD	0ffffffffH
	DD	FLAT:$L201086
$T201089 DD	019930520H
	DD	01H
	DD	FLAT:$T201091
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0TAB_ITEM@@QAE@ABU0@@Z PROC NEAR			; TAB_ITEM::TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0TAB_ITEM@@QAE@ABU0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00036	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00039	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0003f	83 c1 20	 add	 ecx, 32			; 00000020H
  00042	51		 push	 ecx
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 20	 add	 ecx, 32			; 00000020H
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201086:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0TAB_ITEM@@QAE@ABU0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201089
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0TAB_ITEM@@QAE@ABU0@@Z ENDP				; TAB_ITEM::TAB_ITEM
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ PROC NEAR	; std::allocator<TAB_ITEM>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc 44 44
	44 04		 mov	 DWORD PTR __Count$[ebp], 71582788 ; 04444444H

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L201099
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L201100
$L201099:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L201100:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ ENDP	; std::allocator<TAB_ITEM>::max_size
_TEXT	ENDS
PUBLIC	??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 44   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>

; 45   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
;	COMDAT ??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Cont$ = 12						; size = 4
??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z PROC NEAR ; std::back_inserter<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >, COMDAT

; 55   : 	{	// return a back_insert_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   : 	return (std::back_insert_iterator<_Container>(_Cont));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Cont$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 57   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z ENDP ; std::back_inserter<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z ; std::_Ptr_cat<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
PUBLIC	??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T201109 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z PROC NEAR ; std::copy<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >, COMDAT

; 1039 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00004	8d 45 14	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z ; std::_Ptr_cat<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T201109[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T201109[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
  00030	83 c4 14	 add	 esp, 20			; 00000014H
  00033	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1041 : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z ENDP ; std::copy<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
PUBLIC	??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<TAB_ITEM *,TAB_ITEM *>
; Function compile flags: /Odt
;	COMDAT ??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z
_TEXT	SEGMENT
$T201112 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z PROC NEAR ; std::copy<TAB_ITEM *,TAB_ITEM *>, COMDAT

; 1039 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T201112[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T201112[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<TAB_ITEM *,TAB_ITEM *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1041 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ENDP ; std::copy<TAB_ITEM *,TAB_ITEM *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT
$T201115 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z PROC NEAR ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T201115[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T201115[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z ENDP ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT
$T201118 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00004	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T201118[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T201118[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z ENDP ; std::_Uninitialized_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Uninitialized_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Uninitialized_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z PROC NEAR ; std::fill<TAB_ITEM *,TAB_ITEM>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1135 : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L200155
$L200156:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 3c	 add	 eax, 60			; 0000003cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L200155:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L200154

; 1136 : 		*_First = _Val;

  00016	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001d	e8 00 00 00 00	 call	 ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
  00022	eb e1		 jmp	 SHORT $L200156
$L200154:

; 1137 : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z ENDP ; std::fill<TAB_ITEM *,TAB_ITEM>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<TAB_ITEM *,TAB_ITEM *>
; Function compile flags: /Odt
;	COMDAT ??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z
_TEXT	SEGMENT
$T201125 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z PROC NEAR ; std::copy_backward<TAB_ITEM *,TAB_ITEM *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T201125[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T201125[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<TAB_ITEM *,TAB_ITEM *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ENDP ; std::copy_backward<TAB_ITEM *,TAB_ITEM *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z PROC NEAR ; std::_Allocate<TAB_ITEM>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z ENDP ; std::_Allocate<TAB_ITEM>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Odt
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
$T201134 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	50		 push	 eax
  0000a	6a 04		 push	 4
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00011	83 c4 08	 add	 esp, 8
  00014	89 45 fc	 mov	 DWORD PTR $T201134[ebp], eax
  00017	83 7d fc 00	 cmp	 DWORD PTR $T201134[ebp], 0
  0001b	74 12		 je	 SHORT $L201135
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T201134[ebp]
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	89 01		 mov	 DWORD PTR [ecx], eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR $T201134[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0002d	eb 07		 jmp	 SHORT $L200184
$L201135:
  0002f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L200184:

; 43   : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
_TEXT	ENDS
;	COMDAT ??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Cont$ = 8						; size = 4
??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z PROC NEAR ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >, COMDAT
; _this$ = ecx

; 23   : 		{	// construct with container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Cont$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 24   : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z ENDP ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z PROC NEAR ; std::_Ptr_cat<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z ENDP ; std::_Ptr_cat<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
_TEXT	ENDS
PUBLIC	??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator=
PUBLIC	??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator*
PUBLIC	??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator++
; Function compile flags: /Odt
;	COMDAT ??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >, COMDAT

; 1020 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1021 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	eb 10		 jmp	 SHORT $L200198
$L200199:
  00005	8d 4d 14	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00008	e8 00 00 00 00	 call	 ??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator++
  0000d	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
$L200198:
  00015	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00018	50		 push	 eax
  00019	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0001c	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 1a		 je	 SHORT $L200200

; 1022 : 		*_Dest = *_First;

  00028	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0002b	e8 00 00 00 00	 call	 ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*
  00030	50		 push	 eax
  00031	8d 4d 14	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00034	e8 00 00 00 00	 call	 ??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator*
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 ??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator=
  00040	eb c3		 jmp	 SHORT $L200199
$L200200:

; 1023 : 	return (_Dest);

  00042	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00045	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
  00048	89 02		 mov	 DWORD PTR [edx], eax
  0004a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1024 : 	}

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z PROC NEAR ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ENDP ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<TAB_ITEM *,TAB_ITEM *>, COMDAT

; 1020 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1021 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	eb 12		 jmp	 SHORT $L200204
$L200205:
  00005	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00008	83 c0 3c	 add	 eax, 60			; 0000003cH
  0000b	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00014	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$L200204:
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	3b 55 0c	 cmp	 edx, DWORD PTR __Last$[ebp]
  0001d	74 0e		 je	 SHORT $L200206

; 1022 : 		*_Dest = *_First;

  0001f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00026	e8 00 00 00 00	 call	 ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
  0002b	eb d8		 jmp	 SHORT $L200205
$L200206:

; 1023 : 	return (_Dest);

  0002d	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1024 : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<TAB_ITEM *,TAB_ITEM *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ; std::allocator<TAB_ITEM>::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L200208
$L200209:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 3c	 add	 eax, 60			; 0000003cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L200208:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L200207

; 226  : 		_Al.destroy(_First);

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001d	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ; std::allocator<TAB_ITEM>::destroy
  00022	eb e1		 jmp	 SHORT $L200209
$L200207:

; 227  : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z ; std::allocator<TAB_ITEM>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T201164 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T201166 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L201160
$T201165 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T201166
$T201162 DD	019930520H
	DD	02H
	DD	FLAT:$T201164
	DD	01H
	DD	FLAT:$T201165
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 208  : 	_FwdIt _Next = _First;

  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 209  : 
; 210  : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  0002d	eb 12		 jmp	 SHORT $L200214
$L200215:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00032	83 e9 01	 sub	 ecx, 1
  00035	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 3c	 add	 edx, 60			; 0000003cH
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L200214:
  00041	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00045	76 12		 jbe	 SHORT $L200216

; 212  : 		_Al.construct(_First, _Val);

  00047	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00052	e8 00 00 00 00	 call	 ?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z ; std::allocator<TAB_ITEM>::construct
  00057	eb d6		 jmp	 SHORT $L200215
$L200216:
  00059	eb 2a		 jmp	 SHORT $L201159
$L201160:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

  0005b	eb 09		 jmp	 SHORT $L200217
$L200218:
  0005d	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00060	83 c2 3c	 add	 edx, 60			; 0000003cH
  00063	89 55 ec	 mov	 DWORD PTR __Next$[ebp], edx
$L200217:
  00066	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00069	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  0006c	74 0e		 je	 SHORT $L200219

; 215  : 		_Al.destroy(_Next);

  0006e	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00071	51		 push	 ecx
  00072	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00075	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ; std::allocator<TAB_ITEM>::destroy
  0007a	eb e1		 jmp	 SHORT $L200218
$L200219:

; 216  : 	_RERAISE;

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201159:

; 217  : 	_CATCH_END

  00085	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$L201158:

; 218  : 	}

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201162
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
PUBLIC	??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
;	COMDAT ??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT
$T201171 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T201171[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T201171[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z ENDP ; std::_Uninitialized_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<TAB_ITEM *,TAB_ITEM *>, COMDAT

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L200262:

; 1049 : 	while (_First != _Last)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00009	74 20		 je	 SHORT $L200263

; 1050 : 		*--_Dest = *--_Last;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	83 e9 3c	 sub	 ecx, 60			; 0000003cH
  00011	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  00014	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00017	83 ea 3c	 sub	 edx, 60			; 0000003cH
  0001a	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0001d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00024	e8 00 00 00 00	 call	 ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
  00029	eb d8		 jmp	 SHORT $L200262
$L200263:

; 1051 : 	return (_Dest);

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1052 : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<TAB_ITEM *,TAB_ITEM *>
_TEXT	ENDS
PUBLIC	??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z ; std::_Construct<TAB_ITEM,TAB_ITEM>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z PROC NEAR ; std::allocator<TAB_ITEM>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z ; std::_Construct<TAB_ITEM,TAB_ITEM>
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z ENDP ; std::allocator<TAB_ITEM>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z	; std::_Destroy<TAB_ITEM>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z PROC NEAR ; std::allocator<TAB_ITEM>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z ; std::_Destroy<TAB_ITEM>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ENDP ; std::allocator<TAB_ITEM>::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
_TEXT	ENDS
;	COMDAT ??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z PROC NEAR ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator=, COMDAT
; _this$ = ecx

; 28   : 		{	// push value into container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 		container->push_back(_Val);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00010	e8 00 00 00 00	 call	 ?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::push_back

; 30   : 		return (*this);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 31   : 		}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z ENDP ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ PROC NEAR ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator*, COMDAT
; _this$ = ecx

; 34   : 		{	// pretend to return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 36   : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ PROC NEAR ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator++, COMDAT
; _this$ = ecx

; 39   : 		{	// pretend to preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 41   : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator++
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T201191 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T201193 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L201187
$T201192 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T201193
$T201189 DD	019930520H
	DD	02H
	DD	FLAT:$T201191
	DD	01H
	DD	FLAT:$T201192
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 78   : 	_FwdIt _Next = _Dest;

  00020	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 79   : 
; 80   : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  0002d	eb 12		 jmp	 SHORT $L200287
$L200288:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00035	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 3c	 add	 edx, 60			; 0000003cH
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L200287:
  00041	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00044	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00047	74 12		 je	 SHORT $L200289

; 82   : 		_Al.construct(_Dest, *_First);

  00049	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00050	52		 push	 edx
  00051	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00054	e8 00 00 00 00	 call	 ?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z ; std::allocator<TAB_ITEM>::construct
  00059	eb d4		 jmp	 SHORT $L200288
$L200289:
  0005b	eb 2a		 jmp	 SHORT $L201186
$L201187:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  0005d	eb 09		 jmp	 SHORT $L200290
$L200291:
  0005f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00062	83 c0 3c	 add	 eax, 60			; 0000003cH
  00065	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$L200290:
  00068	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  0006b	3b 4d 10	 cmp	 ecx, DWORD PTR __Dest$[ebp]
  0006e	74 0e		 je	 SHORT $L200292

; 85   : 		_Al.destroy(_Next);

  00070	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00073	52		 push	 edx
  00074	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00077	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ; std::allocator<TAB_ITEM>::destroy
  0007c	eb e1		 jmp	 SHORT $L200291
$L200292:

; 86   : 	_RERAISE;

  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201186:

; 87   : 	_CATCH_END

  00087	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 88   : 	return (_Dest);

  0008e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$L201185:

; 89   : 	}

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201189
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T201206 DD	0ffffffffH
	DD	FLAT:$L201202
$T201204 DD	019930520H
	DD	01H
	DD	FLAT:$T201206
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -24						; size = 4
$T201199 = -20						; size = 4
$T201198 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z PROC NEAR ; std::_Construct<TAB_ITEM,TAB_ITEM>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001e	50		 push	 eax
  0001f	6a 3c		 push	 60			; 0000003cH
  00021	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00026	83 c4 08	 add	 esp, 8
  00029	89 45 ec	 mov	 DWORD PTR $T201199[ebp], eax
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	83 7d ec 00	 cmp	 DWORD PTR $T201199[ebp], 0
  00037	74 11		 je	 SHORT $L201200
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR $T201199[ebp]
  00040	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@ABU0@@Z
  00045	89 45 e8	 mov	 DWORD PTR tv74[ebp], eax
  00048	eb 07		 jmp	 SHORT $L201201
$L201200:
  0004a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L201201:
  00051	8b 55 e8	 mov	 edx, DWORD PTR tv74[ebp]
  00054	89 55 f0	 mov	 DWORD PTR $T201198[ebp], edx
  00057	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 43   : 	}

  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00061	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201202:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ec	 mov	 ecx, DWORD PTR $T201199[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201204
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z ENDP ; std::_Construct<TAB_ITEM,TAB_ITEM>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_GTAB_ITEM@@QAEPAXI@Z				; TAB_ITEM::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z PROC NEAR ; std::_Destroy<TAB_ITEM>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00003	6a 00		 push	 0
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??_GTAB_ITEM@@QAEPAXI@Z

; 50   : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z ENDP	; std::_Destroy<TAB_ITEM>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GTAB_ITEM@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTAB_ITEM@@QAEPAXI@Z PROC NEAR			; TAB_ITEM::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L200304
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L200304:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GTAB_ITEM@@QAEPAXI@Z ENDP				; TAB_ITEM::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 28   : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201227 DD	0ffffffffH
	DD	FLAT:$L201222
$T201225 DD	019930520H
	DD	01H
	DD	FLAT:$T201227
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 20   : 		}

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201222:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201225
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102266
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102266:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201239 DD	0ffffffffH
	DD	FLAT:$L201234
$T201237 DD	019930520H
	DD	01H
	DD	FLAT:$T201239
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201234:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201237
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102332
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102332:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201254 DD	0ffffffffH
	DD	FLAT:$L201249
$T201252 DD	019930520H
	DD	01H
	DD	FLAT:$T201254
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0003f	52		 push	 edx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201249:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201252
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
END
