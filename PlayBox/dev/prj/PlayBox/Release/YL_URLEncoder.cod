; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\boxgit\PlayBox\CommonLib\common\YL_URLEncoder.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@HHDGIIFB@0123456789abcdefABCDEF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@_W@std@@YAD_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@_WDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0IPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@D@std@@YADDABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVdomain_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVrange_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@codecvt_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@_WDH@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4underflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4overflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVunderflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4domain_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_exception@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4invalid_argument@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$codecvt@_WDH@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4range_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_exception@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$codecvt@_WDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R2invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVinvalid_argument@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVoverflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
CONST	SEGMENT
_urlchr_table DB 02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	00H
	DB	02H
	DB	03H
	DB	01H
	DB	02H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	DB	02H
	DB	03H
	DB	02H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	02H
	DB	02H
	DB	00H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
$SG10266 DB	'0123456789ABCDEF', 00H
	ORG $+3
$SG10267 DB	'0123456789ABCDEF', 00H
	ORG $+3
$SG10280 DB	'0123456789ABCDEF', 00H
	ORG $+3
$SG10281 DB	'0123456789ABCDEF', 00H
	ORG $+3
$SG10294 DB	'0123456789ABCDEF', 00H
	ORG $+3
$SG10295 DB	'0123456789ABCDEF', 00H
CONST	ENDS
PUBLIC	?encode@YL_URLEncoder@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z ; YL_URLEncoder::encode
EXTRN	__imp_?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z:NEAR
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__except_list:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T14233	DD	0ffffffffH
	DD	FLAT:$L14221
	DD	00H
	DD	FLAT:$L14220
$T14227	DD	019930520H
	DD	02H
	DD	FLAT:$T14233
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\commonlib\common\yl_urlencoder.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv90 = -57						; size = 1
$T14222 = -56						; size = 4
_c$10265 = -49						; size = 1
___encoded$ = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
___p$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_url$ = 12						; size = 4
?encode@YL_URLEncoder@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z PROC NEAR ; YL_URLEncoder::encode

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?encode@YL_URLEncoder@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 30	 sub	 esp, 48			; 00000030H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T14222[ebp], 0

; 114  : 	string __encoded;

  0002a	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00033	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 115  : 	const char *__p = url.c_str();

  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _url$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00043	89 45 f0	 mov	 DWORD PTR ___p$[ebp], eax
$L10262:

; 116  : 
; 117  : 	while (*__p) {

  00046	8b 45 f0	 mov	 eax, DWORD PTR ___p$[ebp]
  00049	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004c	85 c9		 test	 ecx, ecx
  0004e	0f 84 82 00 00
	00		 je	 $L10263

; 118  : 		if (url_char_needs_escaping(__p)) {

  00054	8b 55 f0	 mov	 edx, DWORD PTR ___p$[ebp]
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 ?url_char_needs_escaping@@YA_NPBD@Z ; url_char_needs_escaping
  0005d	83 c4 04	 add	 esp, 4
  00060	0f b6 c0	 movzx	 eax, al
  00063	85 c0		 test	 eax, eax
  00065	74 4c		 je	 SHORT $L10264

; 119  : 			unsigned char c = *__p++;

  00067	8b 4d f0	 mov	 ecx, DWORD PTR ___p$[ebp]
  0006a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0006c	88 55 cf	 mov	 BYTE PTR _c$10265[ebp], dl
  0006f	8b 45 f0	 mov	 eax, DWORD PTR ___p$[ebp]
  00072	83 c0 01	 add	 eax, 1
  00075	89 45 f0	 mov	 DWORD PTR ___p$[ebp], eax

; 120  : 			__encoded.push_back('%');

  00078	6a 25		 push	 37			; 00000025H
  0007a	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z

; 121  : 			__encoded.push_back(XNUM_TO_DIGIT (c >> 4));

  00083	0f b6 4d cf	 movzx	 ecx, BYTE PTR _c$10265[ebp]
  00087	c1 f9 04	 sar	 ecx, 4
  0008a	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR $SG10266[ecx]
  00090	52		 push	 edx
  00091	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z

; 122  : 			__encoded.push_back(XNUM_TO_DIGIT (c & 0xf));

  0009a	0f b6 45 cf	 movzx	 eax, BYTE PTR _c$10265[ebp]
  0009e	83 e0 0f	 and	 eax, 15			; 0000000fH
  000a1	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR $SG10267[eax]
  000a7	51		 push	 ecx
  000a8	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z

; 123  : 		} else {

  000b1	eb 1e		 jmp	 SHORT $L10268
$L10264:

; 124  : 			__encoded.push_back(*__p++);

  000b3	8b 55 f0	 mov	 edx, DWORD PTR ___p$[ebp]
  000b6	8a 02		 mov	 al, BYTE PTR [edx]
  000b8	88 45 c7	 mov	 BYTE PTR tv90[ebp], al
  000bb	8a 4d c7	 mov	 cl, BYTE PTR tv90[ebp]
  000be	51		 push	 ecx
  000bf	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
  000c8	8b 55 f0	 mov	 edx, DWORD PTR ___p$[ebp]
  000cb	83 c2 01	 add	 edx, 1
  000ce	89 55 f0	 mov	 DWORD PTR ___p$[ebp], edx
$L10268:

; 125  : 		}
; 126  : 	}

  000d1	e9 70 ff ff ff	 jmp	 $L10262
$L10263:

; 127  : 
; 128  : 	return __encoded;

  000d6	8d 45 d0	 lea	 eax, DWORD PTR ___encoded$[ebp]
  000d9	50		 push	 eax
  000da	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  000e3	8b 4d c8	 mov	 ecx, DWORD PTR $T14222[ebp]
  000e6	83 c9 01	 or	 ecx, 1
  000e9	89 4d c8	 mov	 DWORD PTR $T14222[ebp], ecx
  000ec	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000f0	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  000f9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 129  : }

  000fc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ff	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00106	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00109	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L14220:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14221:
  00009	8b 45 c8	 mov	 eax, DWORD PTR $T14222[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L14223
  00015	83 65 c8 fe	 and	 DWORD PTR $T14222[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14223:
  00022	c3		 ret	 0
__ehhandler$?encode@YL_URLEncoder@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14227
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?encode@YL_URLEncoder@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z ENDP ; YL_URLEncoder::encode
EXTRN	__imp__isxdigit:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_p$ = 8							; size = 4
?url_char_needs_escaping@@YA_NPBD@Z PROC NEAR		; url_char_needs_escaping

; 96   : {

  00120	55		 push	 ebp
  00121	8b ec		 mov	 ebp, esp

; 97   : 	if (*p == '%')

  00123	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00126	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00129	83 f9 25	 cmp	 ecx, 37			; 00000025H
  0012c	75 32		 jne	 SHORT $L10247

; 98   : 	{
; 99   : 		if (isxdigit(*(p + 1)) && isxdigit(*(p + 2)))

  0012e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00131	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  00135	50		 push	 eax
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isxdigit
  0013c	83 c4 04	 add	 esp, 4
  0013f	85 c0		 test	 eax, eax
  00141	74 19		 je	 SHORT $L10248
  00143	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00146	0f be 51 02	 movsx	 edx, BYTE PTR [ecx+2]
  0014a	52		 push	 edx
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isxdigit
  00151	83 c4 04	 add	 esp, 4
  00154	85 c0		 test	 eax, eax
  00156	74 04		 je	 SHORT $L10248

; 100  : 			return false;

  00158	32 c0		 xor	 al, al
  0015a	eb 2e		 jmp	 SHORT $L10246
$L10248:

; 101  : 		else
; 102  : 			/* Garbled %.. sequence: encode `%'. */
; 103  : 			return true;

  0015c	b0 01		 mov	 al, 1
  0015e	eb 2a		 jmp	 SHORT $L10246
$L10247:

; 104  : 	}
; 105  : 	else if (URL_UNSAFE_CHAR (*p) && !URL_RESERVED_CHAR (*p))

  00160	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00163	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00166	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _urlchr_table[ecx]
  0016d	83 e2 02	 and	 edx, 2
  00170	74 16		 je	 SHORT $L10253
  00172	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00175	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00178	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _urlchr_table[ecx]
  0017f	83 e2 01	 and	 edx, 1
  00182	75 04		 jne	 SHORT $L10253

; 106  : 		return true;

  00184	b0 01		 mov	 al, 1
  00186	eb 02		 jmp	 SHORT $L10246
$L10253:

; 107  : 	else
; 108  : 		return false;

  00188	32 c0		 xor	 al, al
$L10246:

; 109  : }

  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
?url_char_needs_escaping@@YA_NPBD@Z ENDP		; url_char_needs_escaping
_TEXT	ENDS
PUBLIC	?encode@YL_URLEncoder@@SAPADPADPBD@Z		; YL_URLEncoder::encode
; Function compile flags: /Odt
_TEXT	SEGMENT
_c$10279 = -9						; size = 1
___p$ = -8						; size = 4
___p1$ = -4						; size = 4
_tourl$ = 8						; size = 4
_fromurl$ = 12						; size = 4
?encode@YL_URLEncoder@@SAPADPADPBD@Z PROC NEAR		; YL_URLEncoder::encode

; 132  : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp
  00193	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 133  : 	const char *__p = fromurl;

  00196	8b 45 0c	 mov	 eax, DWORD PTR _fromurl$[ebp]
  00199	89 45 f8	 mov	 DWORD PTR ___p$[ebp], eax

; 134  : 	char *__p1 = tourl;

  0019c	8b 4d 08	 mov	 ecx, DWORD PTR _tourl$[ebp]
  0019f	89 4d fc	 mov	 DWORD PTR ___p1$[ebp], ecx
$L10276:

; 135  : 
; 136  : 	while (*__p) {

  001a2	8b 55 f8	 mov	 edx, DWORD PTR ___p$[ebp]
  001a5	0f be 02	 movsx	 eax, BYTE PTR [edx]
  001a8	85 c0		 test	 eax, eax
  001aa	0f 84 8c 00 00
	00		 je	 $L10277

; 137  : 		if (url_char_needs_escaping(__p)) {

  001b0	8b 4d f8	 mov	 ecx, DWORD PTR ___p$[ebp]
  001b3	51		 push	 ecx
  001b4	e8 00 00 00 00	 call	 ?url_char_needs_escaping@@YA_NPBD@Z ; url_char_needs_escaping
  001b9	83 c4 04	 add	 esp, 4
  001bc	0f b6 d0	 movzx	 edx, al
  001bf	85 d2		 test	 edx, edx
  001c1	74 58		 je	 SHORT $L10278

; 138  : 			unsigned char c = *__p++;

  001c3	8b 45 f8	 mov	 eax, DWORD PTR ___p$[ebp]
  001c6	8a 08		 mov	 cl, BYTE PTR [eax]
  001c8	88 4d f7	 mov	 BYTE PTR _c$10279[ebp], cl
  001cb	8b 55 f8	 mov	 edx, DWORD PTR ___p$[ebp]
  001ce	83 c2 01	 add	 edx, 1
  001d1	89 55 f8	 mov	 DWORD PTR ___p$[ebp], edx

; 139  : 			*__p1++ = ('%');

  001d4	8b 45 fc	 mov	 eax, DWORD PTR ___p1$[ebp]
  001d7	c6 00 25	 mov	 BYTE PTR [eax], 37	; 00000025H
  001da	8b 4d fc	 mov	 ecx, DWORD PTR ___p1$[ebp]
  001dd	83 c1 01	 add	 ecx, 1
  001e0	89 4d fc	 mov	 DWORD PTR ___p1$[ebp], ecx

; 140  : 			*__p1++ = XNUM_TO_DIGIT (c >> 4);

  001e3	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$10279[ebp]
  001e7	c1 fa 04	 sar	 edx, 4
  001ea	8b 45 fc	 mov	 eax, DWORD PTR ___p1$[ebp]
  001ed	8a 8a 00 00 00
	00		 mov	 cl, BYTE PTR $SG10280[edx]
  001f3	88 08		 mov	 BYTE PTR [eax], cl
  001f5	8b 55 fc	 mov	 edx, DWORD PTR ___p1$[ebp]
  001f8	83 c2 01	 add	 edx, 1
  001fb	89 55 fc	 mov	 DWORD PTR ___p1$[ebp], edx

; 141  : 			*__p1++ = XNUM_TO_DIGIT (c & 0xf);

  001fe	0f b6 45 f7	 movzx	 eax, BYTE PTR _c$10279[ebp]
  00202	83 e0 0f	 and	 eax, 15			; 0000000fH
  00205	8b 4d fc	 mov	 ecx, DWORD PTR ___p1$[ebp]
  00208	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $SG10281[eax]
  0020e	88 11		 mov	 BYTE PTR [ecx], dl
  00210	8b 45 fc	 mov	 eax, DWORD PTR ___p1$[ebp]
  00213	83 c0 01	 add	 eax, 1
  00216	89 45 fc	 mov	 DWORD PTR ___p1$[ebp], eax

; 142  : 		} else {

  00219	eb 1c		 jmp	 SHORT $L10282
$L10278:

; 143  : 			*__p1++ = *__p++;

  0021b	8b 4d fc	 mov	 ecx, DWORD PTR ___p1$[ebp]
  0021e	8b 55 f8	 mov	 edx, DWORD PTR ___p$[ebp]
  00221	8a 02		 mov	 al, BYTE PTR [edx]
  00223	88 01		 mov	 BYTE PTR [ecx], al
  00225	8b 4d fc	 mov	 ecx, DWORD PTR ___p1$[ebp]
  00228	83 c1 01	 add	 ecx, 1
  0022b	89 4d fc	 mov	 DWORD PTR ___p1$[ebp], ecx
  0022e	8b 55 f8	 mov	 edx, DWORD PTR ___p$[ebp]
  00231	83 c2 01	 add	 edx, 1
  00234	89 55 f8	 mov	 DWORD PTR ___p$[ebp], edx
$L10282:

; 144  : 		}
; 145  : 	}

  00237	e9 66 ff ff ff	 jmp	 $L10276
$L10277:

; 146  : 
; 147  : 	*__p1 = '\0';

  0023c	8b 45 fc	 mov	 eax, DWORD PTR ___p1$[ebp]
  0023f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 148  : 
; 149  : 	return tourl;

  00242	8b 45 08	 mov	 eax, DWORD PTR _tourl$[ebp]

; 150  : }

  00245	8b e5		 mov	 esp, ebp
  00247	5d		 pop	 ebp
  00248	c3		 ret	 0
?encode@YL_URLEncoder@@SAPADPADPBD@Z ENDP		; YL_URLEncoder::encode
_TEXT	ENDS
PUBLIC	?encodeQuery@YL_URLEncoder@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z ; YL_URLEncoder::encodeQuery
xdata$x	SEGMENT
$T14247	DD	0ffffffffH
	DD	FLAT:$L14240
	DD	00H
	DD	FLAT:$L14239
$T14244	DD	019930520H
	DD	02H
	DD	FLAT:$T14247
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv90 = -57						; size = 1
$T14241 = -56						; size = 4
_c$10293 = -49						; size = 1
___encoded$ = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
___p$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_query$ = 12						; size = 4
?encodeQuery@YL_URLEncoder@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z PROC NEAR ; YL_URLEncoder::encodeQuery

; 153  : {

  00250	55		 push	 ebp
  00251	8b ec		 mov	 ebp, esp
  00253	6a ff		 push	 -1
  00255	68 00 00 00 00	 push	 __ehhandler$?encodeQuery@YL_URLEncoder@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z
  0025a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00260	50		 push	 eax
  00261	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00268	83 ec 30	 sub	 esp, 48			; 00000030H
  0026b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00270	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00273	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T14241[ebp], 0

; 154  : 	string __encoded;

  0027a	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  0027d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00283	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 155  : 	const char *__p = query.c_str();

  0028a	8b 4d 0c	 mov	 ecx, DWORD PTR _query$[ebp]
  0028d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00293	89 45 f0	 mov	 DWORD PTR ___p$[ebp], eax
$L10290:

; 156  : 
; 157  : 	while (*__p) {

  00296	8b 45 f0	 mov	 eax, DWORD PTR ___p$[ebp]
  00299	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0029c	85 c9		 test	 ecx, ecx
  0029e	0f 84 82 00 00
	00		 je	 $L10291

; 158  : 		if (query_char_needs_escaping(__p)) {

  002a4	8b 55 f0	 mov	 edx, DWORD PTR ___p$[ebp]
  002a7	52		 push	 edx
  002a8	e8 00 00 00 00	 call	 ?query_char_needs_escaping@@YA_NPBD@Z ; query_char_needs_escaping
  002ad	83 c4 04	 add	 esp, 4
  002b0	0f b6 c0	 movzx	 eax, al
  002b3	85 c0		 test	 eax, eax
  002b5	74 4c		 je	 SHORT $L10292

; 159  : 			unsigned char c = *__p++;

  002b7	8b 4d f0	 mov	 ecx, DWORD PTR ___p$[ebp]
  002ba	8a 11		 mov	 dl, BYTE PTR [ecx]
  002bc	88 55 cf	 mov	 BYTE PTR _c$10293[ebp], dl
  002bf	8b 45 f0	 mov	 eax, DWORD PTR ___p$[ebp]
  002c2	83 c0 01	 add	 eax, 1
  002c5	89 45 f0	 mov	 DWORD PTR ___p$[ebp], eax

; 160  : 			__encoded.push_back('%');

  002c8	6a 25		 push	 37			; 00000025H
  002ca	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  002cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z

; 161  : 			__encoded.push_back(XNUM_TO_DIGIT (c >> 4));

  002d3	0f b6 4d cf	 movzx	 ecx, BYTE PTR _c$10293[ebp]
  002d7	c1 f9 04	 sar	 ecx, 4
  002da	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR $SG10294[ecx]
  002e0	52		 push	 edx
  002e1	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  002e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z

; 162  : 			__encoded.push_back(XNUM_TO_DIGIT (c & 0xf));

  002ea	0f b6 45 cf	 movzx	 eax, BYTE PTR _c$10293[ebp]
  002ee	83 e0 0f	 and	 eax, 15			; 0000000fH
  002f1	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR $SG10295[eax]
  002f7	51		 push	 ecx
  002f8	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  002fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z

; 163  : 		} else {

  00301	eb 1e		 jmp	 SHORT $L10296
$L10292:

; 164  : 			__encoded.push_back(*__p++);

  00303	8b 55 f0	 mov	 edx, DWORD PTR ___p$[ebp]
  00306	8a 02		 mov	 al, BYTE PTR [edx]
  00308	88 45 c7	 mov	 BYTE PTR tv90[ebp], al
  0030b	8a 4d c7	 mov	 cl, BYTE PTR tv90[ebp]
  0030e	51		 push	 ecx
  0030f	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  00312	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
  00318	8b 55 f0	 mov	 edx, DWORD PTR ___p$[ebp]
  0031b	83 c2 01	 add	 edx, 1
  0031e	89 55 f0	 mov	 DWORD PTR ___p$[ebp], edx
$L10296:

; 165  : 		}
; 166  : 	}

  00321	e9 70 ff ff ff	 jmp	 $L10290
$L10291:

; 167  : 
; 168  : 	return __encoded;

  00326	8d 45 d0	 lea	 eax, DWORD PTR ___encoded$[ebp]
  00329	50		 push	 eax
  0032a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0032d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00333	8b 4d c8	 mov	 ecx, DWORD PTR $T14241[ebp]
  00336	83 c9 01	 or	 ecx, 1
  00339	89 4d c8	 mov	 DWORD PTR $T14241[ebp], ecx
  0033c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00340	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  00343	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00349	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 169  : }

  0034c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0034f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00356	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00359	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035e	8b e5		 mov	 esp, ebp
  00360	5d		 pop	 ebp
  00361	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L14239:
  0002d	8d 4d d0	 lea	 ecx, DWORD PTR ___encoded$[ebp]
  00030	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14240:
  00036	8b 45 c8	 mov	 eax, DWORD PTR $T14241[ebp]
  00039	83 e0 01	 and	 eax, 1
  0003c	0f 84 0d 00 00
	00		 je	 $L14242
  00042	83 65 c8 fe	 and	 DWORD PTR $T14241[ebp], -2 ; fffffffeH
  00046	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00049	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14242:
  0004f	c3		 ret	 0
__ehhandler$?encodeQuery@YL_URLEncoder@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z:
  00050	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14244
  00055	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?encodeQuery@YL_URLEncoder@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z ENDP ; YL_URLEncoder::encodeQuery
; Function compile flags: /Odt
_TEXT	SEGMENT
_p$ = 8							; size = 4
?query_char_needs_escaping@@YA_NPBD@Z PROC NEAR		; query_char_needs_escaping

; 78   : {

  00370	55		 push	 ebp
  00371	8b ec		 mov	 ebp, esp

; 79   : 	if (*p == '%')

  00373	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00376	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00379	83 f9 25	 cmp	 ecx, 37			; 00000025H
  0037c	75 32		 jne	 SHORT $L10235

; 80   : 	{
; 81   : 		if (isxdigit(*(p + 1)) && isxdigit(*(p + 2)))

  0037e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00381	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  00385	50		 push	 eax
  00386	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isxdigit
  0038c	83 c4 04	 add	 esp, 4
  0038f	85 c0		 test	 eax, eax
  00391	74 19		 je	 SHORT $L10236
  00393	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00396	0f be 51 02	 movsx	 edx, BYTE PTR [ecx+2]
  0039a	52		 push	 edx
  0039b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isxdigit
  003a1	83 c4 04	 add	 esp, 4
  003a4	85 c0		 test	 eax, eax
  003a6	74 04		 je	 SHORT $L10236

; 82   : 			return false;

  003a8	32 c0		 xor	 al, al
  003aa	eb 2e		 jmp	 SHORT $L10234
$L10236:

; 83   : 		else
; 84   : 			/* Garbled %.. sequence: encode `%'. */
; 85   : 			return true;

  003ac	b0 01		 mov	 al, 1
  003ae	eb 2a		 jmp	 SHORT $L10234
$L10235:

; 86   : 	}
; 87   : 	else if (URL_UNSAFE_CHAR (*p) || URL_RESERVED_CHAR (*p))

  003b0	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  003b3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  003b6	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _urlchr_table[ecx]
  003bd	83 e2 02	 and	 edx, 2
  003c0	75 12		 jne	 SHORT $L10242
  003c2	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  003c5	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  003c8	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _urlchr_table[ecx]
  003cf	83 e2 01	 and	 edx, 1
  003d2	74 04		 je	 SHORT $L10241
$L10242:

; 88   : 		return true;

  003d4	b0 01		 mov	 al, 1
  003d6	eb 02		 jmp	 SHORT $L10234
$L10241:

; 89   : 	else
; 90   : 		return false;

  003d8	32 c0		 xor	 al, al
$L10234:

; 91   : 
; 92   : }

  003da	5d		 pop	 ebp
  003db	c3		 ret	 0
?query_char_needs_escaping@@YA_NPBD@Z ENDP		; query_char_needs_escaping
_TEXT	ENDS
PUBLIC	?decode@YL_URLEncoder@@SAPADPAD@Z		; YL_URLEncoder::decode
EXTRN	__imp__toupper:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv147 = -20						; size = 4
tv133 = -16						; size = 4
tv72 = -10						; size = 1
_c$10308 = -9						; size = 1
_t$ = -8						; size = 4
_h$ = -4						; size = 4
_s$ = 8							; size = 4
?decode@YL_URLEncoder@@SAPADPAD@Z PROC NEAR		; YL_URLEncoder::decode

; 172  : {

  003e0	55		 push	 ebp
  003e1	8b ec		 mov	 ebp, esp
  003e3	83 ec 14	 sub	 esp, 20			; 00000014H

; 173  : 	char *t = s;                  /* t - tortoise */

  003e6	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  003e9	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax

; 174  : 	char *h = s;                  /* h - hare     */

  003ec	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  003ef	89 4d fc	 mov	 DWORD PTR _h$[ebp], ecx

; 175  : 
; 176  : 	for (; *h; h++, t++)

  003f2	eb 12		 jmp	 SHORT $L10302
$L10303:
  003f4	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  003f7	83 c2 01	 add	 edx, 1
  003fa	89 55 fc	 mov	 DWORD PTR _h$[ebp], edx
  003fd	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp]
  00400	83 c0 01	 add	 eax, 1
  00403	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax
$L10302:
  00406	8b 4d fc	 mov	 ecx, DWORD PTR _h$[ebp]
  00409	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0040c	85 d2		 test	 edx, edx
  0040e	0f 84 06 01 00
	00		 je	 $L10304

; 177  : 	{
; 178  : 		if (*h != '%')

  00414	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  00417	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0041a	83 f9 25	 cmp	 ecx, 37			; 00000025H
  0041d	74 26		 je	 SHORT $L10305
$copychar$10306:

; 179  : 		{
; 180  : copychar:
; 181  : 			*t = (*h=='+')?' ':*h;

  0041f	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  00422	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00425	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00428	75 06		 jne	 SHORT $L14250
  0042a	c6 45 f6 20	 mov	 BYTE PTR tv72[ebp], 32	; 00000020H
  0042e	eb 08		 jmp	 SHORT $L14251
$L14250:
  00430	8b 4d fc	 mov	 ecx, DWORD PTR _h$[ebp]
  00433	8a 11		 mov	 dl, BYTE PTR [ecx]
  00435	88 55 f6	 mov	 BYTE PTR tv72[ebp], dl
$L14251:
  00438	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp]
  0043b	8a 4d f6	 mov	 cl, BYTE PTR tv72[ebp]
  0043e	88 08		 mov	 BYTE PTR [eax], cl

; 182  : 		}
; 183  : 		else

  00440	e9 d0 00 00 00	 jmp	 $L10307
$L10305:

; 184  : 		{
; 185  : 			char c;
; 186  : 			/* Do nothing if '%' is not followed by two hex digits. */
; 187  : 			if (!h[1] || !h[2] || !(isxdigit (h[1]) && isxdigit (h[2])))

  00445	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  00448	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  0044c	85 c0		 test	 eax, eax
  0044e	74 35		 je	 SHORT $L10310
  00450	8b 4d fc	 mov	 ecx, DWORD PTR _h$[ebp]
  00453	0f be 51 02	 movsx	 edx, BYTE PTR [ecx+2]
  00457	85 d2		 test	 edx, edx
  00459	74 2a		 je	 SHORT $L10310
  0045b	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  0045e	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00462	51		 push	 ecx
  00463	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isxdigit
  00469	83 c4 04	 add	 esp, 4
  0046c	85 c0		 test	 eax, eax
  0046e	74 15		 je	 SHORT $L10310
  00470	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  00473	0f be 42 02	 movsx	 eax, BYTE PTR [edx+2]
  00477	50		 push	 eax
  00478	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isxdigit
  0047e	83 c4 04	 add	 esp, 4
  00481	85 c0		 test	 eax, eax
  00483	75 02		 jne	 SHORT $L10309
$L10310:

; 188  : 				goto copychar;

  00485	eb 98		 jmp	 SHORT $copychar$10306
$L10309:

; 189  : 			c = X2DIGITS_TO_NUM (h[1], h[2]);

  00487	8b 4d fc	 mov	 ecx, DWORD PTR _h$[ebp]
  0048a	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]
  0048e	83 fa 41	 cmp	 edx, 65			; 00000041H
  00491	7d 0f		 jge	 SHORT $L14252
  00493	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  00496	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  0049a	83 e9 30	 sub	 ecx, 48			; 00000030H
  0049d	89 4d f0	 mov	 DWORD PTR tv133[ebp], ecx
  004a0	eb 17		 jmp	 SHORT $L14253
$L14252:
  004a2	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  004a5	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  004a9	50		 push	 eax
  004aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  004b0	83 c4 04	 add	 esp, 4
  004b3	83 e8 37	 sub	 eax, 55			; 00000037H
  004b6	89 45 f0	 mov	 DWORD PTR tv133[ebp], eax
$L14253:
  004b9	8b 4d fc	 mov	 ecx, DWORD PTR _h$[ebp]
  004bc	0f be 51 02	 movsx	 edx, BYTE PTR [ecx+2]
  004c0	83 fa 41	 cmp	 edx, 65			; 00000041H
  004c3	7d 0f		 jge	 SHORT $L14254
  004c5	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  004c8	0f be 48 02	 movsx	 ecx, BYTE PTR [eax+2]
  004cc	83 e9 30	 sub	 ecx, 48			; 00000030H
  004cf	89 4d ec	 mov	 DWORD PTR tv147[ebp], ecx
  004d2	eb 17		 jmp	 SHORT $L14255
$L14254:
  004d4	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  004d7	0f be 42 02	 movsx	 eax, BYTE PTR [edx+2]
  004db	50		 push	 eax
  004dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  004e2	83 c4 04	 add	 esp, 4
  004e5	83 e8 37	 sub	 eax, 55			; 00000037H
  004e8	89 45 ec	 mov	 DWORD PTR tv147[ebp], eax
$L14255:
  004eb	8b 4d f0	 mov	 ecx, DWORD PTR tv133[ebp]
  004ee	c1 e1 04	 shl	 ecx, 4
  004f1	03 4d ec	 add	 ecx, DWORD PTR tv147[ebp]
  004f4	88 4d f7	 mov	 BYTE PTR _c$10308[ebp], cl

; 190  : 			/* Don't unescape %00 because there is no way to insert it
; 191  : 			*              into a C string without effectively truncating it. */
; 192  : 			if (c == '\0')

  004f7	0f be 55 f7	 movsx	 edx, BYTE PTR _c$10308[ebp]
  004fb	85 d2		 test	 edx, edx
  004fd	75 05		 jne	 SHORT $L10312

; 193  : 				goto copychar;

  004ff	e9 1b ff ff ff	 jmp	 $copychar$10306
$L10312:

; 194  : 			*t = c;

  00504	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp]
  00507	8a 4d f7	 mov	 cl, BYTE PTR _c$10308[ebp]
  0050a	88 08		 mov	 BYTE PTR [eax], cl

; 195  : 			h += 2;

  0050c	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  0050f	83 c2 02	 add	 edx, 2
  00512	89 55 fc	 mov	 DWORD PTR _h$[ebp], edx
$L10307:

; 196  : 		}
; 197  : 	}

  00515	e9 da fe ff ff	 jmp	 $L10303
$L10304:

; 198  : 	*t = '\0';

  0051a	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp]
  0051d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 199  : 
; 200  : 	return s;

  00520	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]

; 201  : }

  00523	8b e5		 mov	 esp, ebp
  00525	5d		 pop	 ebp
  00526	c3		 ret	 0
?decode@YL_URLEncoder@@SAPADPAD@Z ENDP			; YL_URLEncoder::decode
_TEXT	ENDS
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T14265	DD	0ffffffffH
	DD	FLAT:$L14259
	DD	00H
	DD	FLAT:$L14258
$T14263	DD	019930520H
	DD	02H
	DD	FLAT:$T14265
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T14260 = -44						; size = 4
$T14257 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T14260[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T14257[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T14260[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T14260[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T14257[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14258:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T14257[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14259:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T14260[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L14261
  00015	83 65 d4 fe	 and	 DWORD PTR $T14260[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14261:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14263
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14278	DD	0ffffffffH
	DD	FLAT:$L14272
	DD	00H
	DD	FLAT:$L14271
$T14276	DD	019930520H
	DD	02H
	DD	FLAT:$T14278
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T14273 = -44						; size = 4
$T14270 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T14273[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T14270[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T14273[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T14273[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T14270[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14271:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T14270[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14272:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T14273[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L14274
  00015	83 65 d4 fe	 and	 DWORD PTR $T14273[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14274:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14276
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14291	DD	0ffffffffH
	DD	FLAT:$L14285
	DD	00H
	DD	FLAT:$L14284
$T14289	DD	019930520H
	DD	02H
	DD	FLAT:$T14291
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T14286 = -44						; size = 4
$T14283 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 1
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T14286[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00022	8a 45 0c	 mov	 al, BYTE PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	6a 01		 push	 1
  00028	8d 4d d8	 lea	 ecx, DWORD PTR $T14283[ebp]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
  00031	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  00034	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00037	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  0003a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00041	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00044	52		 push	 edx
  00045	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00058	8b 45 d4	 mov	 eax, DWORD PTR $T14286[ebp]
  0005b	83 c8 01	 or	 eax, 1
  0005e	89 45 d4	 mov	 DWORD PTR $T14286[ebp], eax
  00061	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00065	8d 4d d8	 lea	 ecx, DWORD PTR $T14283[ebp]
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14284:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T14283[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14285:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T14286[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L14287
  00015	83 65 d4 fe	 and	 DWORD PTR $T14286[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14287:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14289
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14304	DD	0ffffffffH
	DD	FLAT:$L14298
	DD	00H
	DD	FLAT:$L14297
$T14302	DD	019930520H
	DD	02H
	DD	FLAT:$T14304
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T14299 = -44						; size = 4
$T14296 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T14299[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T14296[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T14299[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T14299[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T14296[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14297:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T14296[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14298:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T14299[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L14300
  00015	83 65 d4 fe	 and	 DWORD PTR $T14299[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14300:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14302
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14317	DD	0ffffffffH
	DD	FLAT:$L14311
	DD	00H
	DD	FLAT:$L14310
$T14315	DD	019930520H
	DD	02H
	DD	FLAT:$T14317
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T14312 = -44						; size = 4
$T14309 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T14312[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T14309[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8a 55 10	 mov	 dl, BYTE PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T14312[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T14312[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T14309[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14310:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T14309[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14311:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T14312[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L14313
  00015	83 65 d4 fe	 and	 DWORD PTR $T14312[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L14313:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14315
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14330	DD	0ffffffffH
	DD	FLAT:$L14324
	DD	00H
	DD	FLAT:$L14323
$T14328	DD	019930520H
	DD	02H
	DD	FLAT:$T14330
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T14325 = -44						; size = 4
$T14322 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T14325[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T14322[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T14325[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T14325[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T14322[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14323:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T14322[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L14324:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T14325[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L14326
  00015	83 65 d4 fe	 and	 DWORD PTR $T14325[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L14326:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14328
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14343	DD	0ffffffffH
	DD	FLAT:$L14337
	DD	00H
	DD	FLAT:$L14336
$T14341	DD	019930520H
	DD	02H
	DD	FLAT:$T14343
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T14338 = -44						; size = 4
$T14335 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T14338[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T14335[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T14338[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T14338[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T14335[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14336:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T14335[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L14337:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T14338[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L14339
  00015	83 65 d4 fe	 and	 DWORD PTR $T14338[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L14339:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14341
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14356	DD	0ffffffffH
	DD	FLAT:$L14350
	DD	00H
	DD	FLAT:$L14349
$T14354	DD	019930520H
	DD	02H
	DD	FLAT:$T14356
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T14351 = -44						; size = 4
$T14348 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 2
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T14351[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00022	66 8b 45 0c	 mov	 ax, WORD PTR __Left$[ebp]
  00026	50		 push	 eax
  00027	6a 01		 push	 1
  00029	8d 4d d8	 lea	 ecx, DWORD PTR $T14348[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
  00032	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  00035	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00038	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  0003b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00042	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00045	52		 push	 edx
  00046	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00059	8b 45 d4	 mov	 eax, DWORD PTR $T14351[ebp]
  0005c	83 c8 01	 or	 eax, 1
  0005f	89 45 d4	 mov	 DWORD PTR $T14351[ebp], eax
  00062	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00066	8d 4d d8	 lea	 ecx, DWORD PTR $T14348[ebp]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14349:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T14348[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L14350:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T14351[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L14352
  00015	83 65 d4 fe	 and	 DWORD PTR $T14351[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L14352:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14354
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14369	DD	0ffffffffH
	DD	FLAT:$L14363
	DD	00H
	DD	FLAT:$L14362
$T14367	DD	019930520H
	DD	02H
	DD	FLAT:$T14369
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T14364 = -44						; size = 4
$T14361 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T14364[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T14361[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T14364[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T14364[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T14361[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14362:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T14361[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L14363:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T14364[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L14365
  00015	83 65 d4 fe	 and	 DWORD PTR $T14364[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L14365:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14367
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14382	DD	0ffffffffH
	DD	FLAT:$L14376
	DD	00H
	DD	FLAT:$L14375
$T14380	DD	019930520H
	DD	02H
	DD	FLAT:$T14382
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T14377 = -44						; size = 4
$T14374 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 2
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T14377[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T14374[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	66 8b 55 10	 mov	 dx, WORD PTR __Right$[ebp]
  00043	52		 push	 edx
  00044	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00057	8b 45 d4	 mov	 eax, DWORD PTR $T14377[ebp]
  0005a	83 c8 01	 or	 eax, 1
  0005d	89 45 d4	 mov	 DWORD PTR $T14377[ebp], eax
  00060	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00064	8d 4d d8	 lea	 ecx, DWORD PTR $T14374[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14375:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T14374[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L14376:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T14377[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L14378
  00015	83 65 d4 fe	 and	 DWORD PTR $T14377[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L14378:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14380
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?to_char_type@?$char_traits@D@std@@SADABH@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@D@std@@SAHXZ:NEAR
EXTRN	__imp_?is@?$ctype@D@std@@QBE_NFD@Z:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_??1locale@std@@QAE@XZ:NEAR
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB:DWORD
EXTRN	__imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z:NEAR
EXTRN	__imp_?width@ios_base@std@@QBEHXZ:NEAR
EXTRN	__imp_?width@ios_base@std@@QAEHH@Z:NEAR
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:NEAR
EXTRN	__imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14399	DD	0ffffffffH
	DD	FLAT:$L14394
	DD	00H
	DD	FLAT:$L14395
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T14401	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L14393
$T14400	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T14401
$T14397	DD	019930520H
	DD	04H
	DD	FLAT:$T14399
	DD	01H
	DD	FLAT:$T14400
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv205 = -112						; size = 1
tv204 = -111						; size = 1
tv203 = -110						; size = 1
tv202 = -109						; size = 1
tv201 = -108						; size = 4
tv200 = -104						; size = 4
tv199 = -100						; size = 4
tv198 = -96						; size = 4
tv197 = -92						; size = 4
tv196 = -88						; size = 4
tv135 = -84						; size = 4
tv195 = -80						; size = 4
tv194 = -76						; size = 4
tv193 = -72						; size = 4
tv192 = -68						; size = 4
tv189 = -64						; size = 4
tv65 = -60						; size = 4
$T14391 = -56						; size = 4
$T14390 = -52						; size = 4
$T14387 = -48						; size = 4
__Meta$13013 = -44					; size = 4
__Size$13010 = -40					; size = 4
__Ctype_fac$13007 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 dc 01 00
	00		 je	 $L14392

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00055	8d 55 d0	 lea	 edx, DWORD PTR $T14387[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00061	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00064	8b ca		 mov	 ecx, edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0006c	89 45 c4	 mov	 DWORD PTR tv65[ebp], eax
  0006f	8b 45 c4	 mov	 eax, DWORD PTR tv65[ebp]
  00072	89 45 c0	 mov	 DWORD PTR tv189[ebp], eax
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00079	8b 4d c0	 mov	 ecx, DWORD PTR tv189[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 dc	 mov	 DWORD PTR __Ctype_fac$13007[ebp], eax
  00088	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0008c	8d 4d d0	 lea	 ecx, DWORD PTR $T14387[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	50		 push	 eax
  0009e	6a 00		 push	 0
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000a9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000be	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  000c1	83 7d bc 00	 cmp	 DWORD PTR tv192[ebp], 0
  000c5	7e 46		 jle	 SHORT $L14388
  000c7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000d2	8b ca		 mov	 ecx, edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000da	89 45 b8	 mov	 DWORD PTR tv193[ebp], eax
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  000e6	89 45 b4	 mov	 DWORD PTR tv194[ebp], eax
  000e9	8b 45 b8	 mov	 eax, DWORD PTR tv193[ebp]
  000ec	3b 45 b4	 cmp	 eax, DWORD PTR tv194[ebp]
  000ef	73 1c		 jae	 SHORT $L14388
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f9	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00102	89 45 b0	 mov	 DWORD PTR tv195[ebp], eax
  00105	8b 45 b0	 mov	 eax, DWORD PTR tv195[ebp]
  00108	89 45 ac	 mov	 DWORD PTR tv135[ebp], eax
  0010b	eb 12		 jmp	 SHORT $L14389
$L14388:
  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00116	89 45 a8	 mov	 DWORD PTR tv196[ebp], eax
  00119	8b 4d a8	 mov	 ecx, DWORD PTR tv196[ebp]
  0011c	89 4d ac	 mov	 DWORD PTR tv135[ebp], ecx
$L14389:
  0011f	8b 55 ac	 mov	 edx, DWORD PTR tv135[ebp]
  00122	89 55 d8	 mov	 DWORD PTR __Size$13010[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00125	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0012d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00130	8b ca		 mov	 ecx, edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00138	89 45 a4	 mov	 DWORD PTR tv197[ebp], eax
  0013b	8b 4d a4	 mov	 ecx, DWORD PTR tv197[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00144	89 45 a0	 mov	 DWORD PTR tv198[ebp], eax
  00147	8b 45 a0	 mov	 eax, DWORD PTR tv198[ebp]
  0014a	89 45 d4	 mov	 DWORD PTR __Meta$13013[ebp], eax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  0014d	eb 2f		 jmp	 SHORT $L13014
$L13015:
  0014f	8b 4d d8	 mov	 ecx, DWORD PTR __Size$13010[ebp]
  00152	83 e9 01	 sub	 ecx, 1
  00155	89 4d d8	 mov	 DWORD PTR __Size$13010[ebp], ecx
  00158	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0015b	8b 02		 mov	 eax, DWORD PTR [edx]
  0015d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00160	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00169	89 45 9c	 mov	 DWORD PTR tv199[ebp], eax
  0016c	8b 4d 9c	 mov	 ecx, DWORD PTR tv199[ebp]
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00175	89 45 98	 mov	 DWORD PTR tv200[ebp], eax
  00178	8b 4d 98	 mov	 ecx, DWORD PTR tv200[ebp]
  0017b	89 4d d4	 mov	 DWORD PTR __Meta$13013[ebp], ecx
$L13014:
  0017e	83 7d d8 00	 cmp	 DWORD PTR __Size$13010[ebp], 0
  00182	0f 86 8a 00 00
	00		 jbe	 $L13016

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0018e	89 45 94	 mov	 DWORD PTR tv201[ebp], eax
  00191	8b 55 94	 mov	 edx, DWORD PTR tv201[ebp]
  00194	89 55 cc	 mov	 DWORD PTR $T14390[ebp], edx
  00197	8d 45 d4	 lea	 eax, DWORD PTR __Meta$13013[ebp]
  0019a	50		 push	 eax
  0019b	8d 4d cc	 lea	 ecx, DWORD PTR $T14390[ebp]
  0019e	51		 push	 ecx
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  001a5	83 c4 08	 add	 esp, 8
  001a8	88 45 93	 mov	 BYTE PTR tv202[ebp], al
  001ab	0f b6 55 93	 movzx	 edx, BYTE PTR tv202[ebp]
  001af	85 d2		 test	 edx, edx
  001b1	74 0b		 je	 SHORT $L13018

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  001b3	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001b6	83 c8 01	 or	 eax, 1
  001b9	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  001bc	eb 54		 jmp	 SHORT $L13016
$L13018:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  001be	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$13013[ebp]
  001c1	51		 push	 ecx
  001c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  001c8	83 c4 04	 add	 esp, 4
  001cb	88 45 92	 mov	 BYTE PTR tv203[ebp], al
  001ce	8a 55 92	 mov	 dl, BYTE PTR tv203[ebp]
  001d1	52		 push	 edx
  001d2	6a 48		 push	 72			; 00000048H
  001d4	8b 4d dc	 mov	 ecx, DWORD PTR __Ctype_fac$13007[ebp]
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@D@std@@QBE_NFD@Z
  001dd	88 45 91	 mov	 BYTE PTR tv204[ebp], al
  001e0	0f b6 45 91	 movzx	 eax, BYTE PTR tv204[ebp]
  001e4	85 c0		 test	 eax, eax
  001e6	74 02		 je	 SHORT $L13020

; 454  : 				break;	// whitespace, quit

  001e8	eb 28		 jmp	 SHORT $L13016
$L13020:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  001ea	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$13013[ebp]
  001ed	51		 push	 ecx
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  001f4	83 c4 04	 add	 esp, 4
  001f7	88 45 90	 mov	 BYTE PTR tv205[ebp], al
  001fa	8a 55 90	 mov	 dl, BYTE PTR tv205[ebp]
  001fd	52		 push	 edx
  001fe	6a 01		 push	 1
  00200	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z

; 458  : 				_Changed = true;

  00209	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  0020d	e9 3d ff ff ff	 jmp	 $L13015
$L13016:
  00212	eb 1d		 jmp	 SHORT $L14392
$L14393:

; 460  : 		_CATCH_IO_(_Istr)

  00214	6a 01		 push	 1
  00216	6a 04		 push	 4
  00218	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0021b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00220	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00223	8b ca		 mov	 ecx, edx
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0022b	b8 00 00 00 00	 mov	 eax, $L14392
  00230	c3		 ret	 0
$L14392:
  00231	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  00238	6a 00		 push	 0
  0023a	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0023d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023f	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00242	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00245	8b ca		 mov	 ecx, edx
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z

; 464  : 	if (!_Changed)

  0024d	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  00251	85 c0		 test	 eax, eax
  00253	75 09		 jne	 SHORT $L13022

; 465  : 		_State |= ios_base::failbit;

  00255	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00258	83 c9 02	 or	 ecx, 2
  0025b	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L13022:

; 466  : 	_Istr.setstate(_State);

  0025e	6a 00		 push	 0
  00260	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00263	52		 push	 edx
  00264	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00267	8b 08		 mov	 ecx, DWORD PTR [eax]
  00269	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0026c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0026f	8b ca		 mov	 ecx, edx
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 467  : 	return (_Istr);

  00277	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0027a	89 45 c8	 mov	 DWORD PTR $T14391[ebp], eax
  0027d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00284	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00287	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0028c	8b 45 c8	 mov	 eax, DWORD PTR $T14391[ebp]

; 468  : 	}

  0028f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00292	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00299	5f		 pop	 edi
  0029a	5e		 pop	 esi
  0029b	5b		 pop	 ebx
  0029c	8b e5		 mov	 esp, ebp
  0029e	5d		 pop	 ebp
  0029f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14394:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
$L14395:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T14387[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14397
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T14413	DD	0ffffffffH
	DD	FLAT:$L14409
$T14411	DD	019930520H
	DD	01H
	DD	FLAT:$T14413
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0002f	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14409:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14411
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L11543

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L11543:

; 61   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L12405

; 54   : 				_Myistr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L12405:

; 55   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@@
PUBLIC	__CTA2?AVbad_cast@@
PUBLIC	??_R0?AVbad_cast@@@8				; bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_??0bad_cast@@QAE@PBD@Z:NEAR
EXTRN	__CxxThrowException@8:NEAR
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:NEAR
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:NEAR
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:NEAR
EXTRN	__imp_?_Incref@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Register@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z:NEAR
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??0bad_cast@@QAE@ABV0@@Z:NEAR			; bad_cast::bad_cast
EXTRN	??1bad_cast@@UAE@XZ:NEAR			; bad_cast::~bad_cast
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14431	DD	0ffffffffH
	DD	FLAT:$L14427
$T14429	DD	019930520H
	DD	01H
	DD	FLAT:$T14431
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT
__TI2?AVbad_cast@@ DD 00H
	DD	FLAT:??1bad_cast@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@@@8 DD FLAT:??_7type_info@@6B@		; bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T14426 = -48						; size = 4
$T14424 = -44						; size = 12
__Pfmod$12936 = -32					; size = 4
__Psave$ = -28						; size = 4
__Lock$ = -24						; size = 4
__Id$ = -20						; size = 4
__Pf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<char> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 24	 sub	 esp, 36			; 00000024H

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	6a 00		 push	 0
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  00032	89 45 e4	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00041	89 45 ec	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00044	8b 4d ec	 mov	 ecx, DWORD PTR __Id$[ebp]
  00047	51		 push	 ecx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00051	89 45 f0	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00054	83 7d f0 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00058	74 02		 je	 SHORT $L12919

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  0005a	eb 62		 jmp	 SHORT $L12920
$L12919:
  0005c	83 7d e4 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  00060	74 08		 je	 SHORT $L12921

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00062	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  00065	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00068	eb 54		 jmp	 SHORT $L12920
$L12921:
  0006a	8d 45 e4	 lea	 eax, DWORD PTR __Psave$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
  00074	83 c4 04	 add	 esp, 4
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	75 1c		 jne	 SHORT $L12924

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  00081	8d 4d d4	 lea	 ecx, DWORD PTR $T14424[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  0008f	8d 4d d4	 lea	 ecx, DWORD PTR $T14424[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 __CxxThrowException@8
$L12924:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  00098	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  0009b	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Psave$[ebp]
  000a1	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000a6	8b 4d e4	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000a9	89 4d e0	 mov	 DWORD PTR __Pfmod$12936[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ac	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$12936[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$12936[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L12920:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000be	8b 55 f0	 mov	 edx, DWORD PTR __Pf$[ebp]
  000c1	89 55 d0	 mov	 DWORD PTR $T14426[ebp], edx
  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d4	8b 45 d0	 mov	 eax, DWORD PTR $T14426[ebp]
$L14423:

; 347  : 	}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14427:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14429
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00003	6a 0a		 push	 10			; 0000000aH
  00005	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0000d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00010	8b ca		 mov	 ecx, edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00018	50		 push	 eax
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z:NEAR
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14447	DD	0ffffffffH
	DD	FLAT:$L14443
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T14449	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L14442
$T14448	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T14449
$T14445	DD	019930520H
	DD	03H
	DD	FLAT:$T14447
	DD	01H
	DD	FLAT:$T14448
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
tv175 = -89						; size = 1
tv174 = -88						; size = 4
tv173 = -84						; size = 4
tv172 = -80						; size = 4
tv171 = -74						; size = 1
tv170 = -73						; size = 1
tv169 = -72						; size = 4
tv168 = -68						; size = 4
tv167 = -64						; size = 4
tv166 = -60						; size = 4
tv165 = -56						; size = 4
tv65 = -52						; size = 4
$T14440 = -48						; size = 4
$T14439 = -44						; size = 4
__Meta$13033 = -40					; size = 4
__Metadelim$13032 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 66 01 00
	00		 je	 $L14441

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  0006d	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z
  00077	83 c4 04	 add	 esp, 4
  0007a	89 45 cc	 mov	 DWORD PTR tv65[ebp], eax
  0007d	8b 55 cc	 mov	 edx, DWORD PTR tv65[ebp]
  00080	89 55 dc	 mov	 DWORD PTR __Metadelim$13032[ebp], edx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00083	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0008b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0008e	8b ca		 mov	 ecx, edx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00096	89 45 c8	 mov	 DWORD PTR tv165[ebp], eax
  00099	8b 4d c8	 mov	 ecx, DWORD PTR tv165[ebp]
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000a2	89 45 c4	 mov	 DWORD PTR tv166[ebp], eax
  000a5	8b 45 c4	 mov	 eax, DWORD PTR tv166[ebp]
  000a8	89 45 d8	 mov	 DWORD PTR __Meta$13033[ebp], eax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000ab	eb 26		 jmp	 SHORT $L13034
$L13035:
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000be	89 45 c0	 mov	 DWORD PTR tv167[ebp], eax
  000c1	8b 4d c0	 mov	 ecx, DWORD PTR tv167[ebp]
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000ca	89 45 bc	 mov	 DWORD PTR tv168[ebp], eax
  000cd	8b 45 bc	 mov	 eax, DWORD PTR tv168[ebp]
  000d0	89 45 d8	 mov	 DWORD PTR __Meta$13033[ebp], eax
$L13034:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  000d9	89 45 b8	 mov	 DWORD PTR tv169[ebp], eax
  000dc	8b 4d b8	 mov	 ecx, DWORD PTR tv169[ebp]
  000df	89 4d d4	 mov	 DWORD PTR $T14439[ebp], ecx
  000e2	8d 55 d8	 lea	 edx, DWORD PTR __Meta$13033[ebp]
  000e5	52		 push	 edx
  000e6	8d 45 d4	 lea	 eax, DWORD PTR $T14439[ebp]
  000e9	50		 push	 eax
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  000f0	83 c4 08	 add	 esp, 8
  000f3	88 45 b7	 mov	 BYTE PTR tv170[ebp], al
  000f6	0f b6 4d b7	 movzx	 ecx, BYTE PTR tv170[ebp]
  000fa	85 c9		 test	 ecx, ecx
  000fc	74 0e		 je	 SHORT $L13038

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  000fe	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00101	83 ca 01	 or	 edx, 1
  00104	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  00107	e9 92 00 00 00	 jmp	 $L13036
$L13038:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  0010c	8d 45 dc	 lea	 eax, DWORD PTR __Metadelim$13032[ebp]
  0010f	50		 push	 eax
  00110	8d 4d d8	 lea	 ecx, DWORD PTR __Meta$13033[ebp]
  00113	51		 push	 ecx
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  0011a	83 c4 08	 add	 esp, 8
  0011d	88 45 b6	 mov	 BYTE PTR tv171[ebp], al
  00120	0f b6 55 b6	 movzx	 edx, BYTE PTR tv171[ebp]
  00124	85 d2		 test	 edx, edx
  00126	74 25		 je	 SHORT $L13040

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00128	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  0012c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00134	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00137	8b ca		 mov	 ecx, edx
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0013f	89 45 b0	 mov	 DWORD PTR tv172[ebp], eax
  00142	8b 4d b0	 mov	 ecx, DWORD PTR tv172[ebp]
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ

; 501  : 				break;

  0014b	eb 51		 jmp	 SHORT $L13036
$L13040:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  0014d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00156	89 45 ac	 mov	 DWORD PTR tv173[ebp], eax
  00159	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00162	89 45 a8	 mov	 DWORD PTR tv174[ebp], eax
  00165	8b 45 ac	 mov	 eax, DWORD PTR tv173[ebp]
  00168	3b 45 a8	 cmp	 eax, DWORD PTR tv174[ebp]
  0016b	77 0b		 ja	 SHORT $L13042

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  0016d	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00170	83 c9 02	 or	 ecx, 2
  00173	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  00176	eb 26		 jmp	 SHORT $L13036
$L13042:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  00178	8d 55 d8	 lea	 edx, DWORD PTR __Meta$13033[ebp]
  0017b	52		 push	 edx
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  00182	83 c4 04	 add	 esp, 4
  00185	88 45 a7	 mov	 BYTE PTR tv175[ebp], al
  00188	8a 45 a7	 mov	 al, BYTE PTR tv175[ebp]
  0018b	50		 push	 eax
  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z

; 511  : 				_Changed = true;

  00195	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  00199	e9 0f ff ff ff	 jmp	 $L13035
$L13036:
  0019e	eb 1b		 jmp	 SHORT $L14441
$L14442:

; 513  : 		_CATCH_IO_(_Istr)

  001a0	6a 01		 push	 1
  001a2	6a 04		 push	 4
  001a4	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a9	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001ac	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001b5	b8 00 00 00 00	 mov	 eax, $L14441
  001ba	c3		 ret	 0
$L14441:
  001bb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  001c2	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $L13044

; 517  : 		_State |= ios_base::failbit;

  001ca	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001cd	83 c9 02	 or	 ecx, 2
  001d0	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L13044:

; 518  : 	_Istr.setstate(_State);

  001d3	6a 00		 push	 0
  001d5	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001d8	52		 push	 edx
  001d9	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001de	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001e1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001e4	8b ca		 mov	 ecx, edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 519  : 	return (_Istr);

  001ec	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001ef	89 45 d0	 mov	 DWORD PTR $T14440[ebp], eax
  001f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001f9	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  001fc	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00201	8b 45 d0	 mov	 eax, DWORD PTR $T14440[ebp]

; 520  : 	}

  00204	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00207	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	5b		 pop	 ebx
  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14443:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14445
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z:NEAR
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:NEAR
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:NEAR
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14469	DD	0ffffffffH
	DD	FLAT:$L14465
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T14471	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L14464
$T14470	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T14471
$T14467	DD	019930520H
	DD	03H
	DD	FLAT:$T14469
	DD	01H
	DD	FLAT:$T14470
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv221 = -129						; size = 1
tv220 = -128						; size = 4
tv219 = -124						; size = 4
tv218 = -120						; size = 4
tv217 = -114						; size = 1
tv216 = -113						; size = 1
tv215 = -112						; size = 4
tv214 = -108						; size = 4
tv213 = -104						; size = 4
tv212 = -100						; size = 4
tv211 = -93						; size = 1
tv210 = -92						; size = 4
tv209 = -88						; size = 4
tv208 = -84						; size = 4
tv207 = -77						; size = 1
tv83 = -76						; size = 4
tv81 = -72						; size = 4
$T14462 = -68						; size = 4
$T14461 = -64						; size = 4
$T14460 = -60						; size = 4
$T14459 = -56						; size = 4
$T14458 = -52						; size = 4
$T14457 = -48						; size = 4
$T14456 = -44						; size = 4
__Count$13067 = -40					; size = 4
__Size$ = -36						; size = 4
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 74	 sub	 esp, 116		; 00000074H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00032	89 45 dc	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0003d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00040	8b ca		 mov	 ecx, edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00048	85 c0		 test	 eax, eax
  0004a	7e 33		 jle	 SHORT $L14454
  0004c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00054	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00057	8b ca		 mov	 ecx, edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0005f	3b 45 dc	 cmp	 eax, DWORD PTR __Size$[ebp]
  00062	76 1b		 jbe	 SHORT $L14454
  00064	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00077	2b 45 dc	 sub	 eax, DWORD PTR __Size$[ebp]
  0007a	89 45 b8	 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 07		 jmp	 SHORT $L14455
$L14454:
  0007f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L14455:
  00086	8b 45 b8	 mov	 eax, DWORD PTR tv81[ebp]
  00089	89 45 e8	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008f	51		 push	 ecx
  00090	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00093	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  0009f	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000a2	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000a7	0f b6 d0	 movzx	 edx, al
  000aa	85 d2		 test	 edx, edx
  000ac	75 0e		 jne	 SHORT $L13056

; 550  : 		_State |= ios_base::badbit;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000b1	83 c8 04	 or	 eax, 4
  000b4	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000b7	e9 22 02 00 00	 jmp	 $L14463
$L13056:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  000d1	89 45 b4	 mov	 DWORD PTR tv83[ebp], eax
  000d4	8b 45 b4	 mov	 eax, DWORD PTR tv83[ebp]
  000d7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000dc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000df	0f 84 8a 00 00
	00		 je	 $L13059

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000e5	eb 09		 jmp	 SHORT $L13060
$L13061:
  000e7	8b 4d e8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  000ea	83 e9 01	 sub	 ecx, 1
  000ed	89 4d e8	 mov	 DWORD PTR __Pad$[ebp], ecx
$L13060:
  000f0	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  000f4	76 79		 jbe	 SHORT $L13059

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  000f6	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000f9	8b 02		 mov	 eax, DWORD PTR [edx]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000fe	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  00107	88 45 b3	 mov	 BYTE PTR tv207[ebp], al
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0010d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00112	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0011b	89 45 ac	 mov	 DWORD PTR tv208[ebp], eax
  0011e	8a 45 b3	 mov	 al, BYTE PTR tv207[ebp]
  00121	50		 push	 eax
  00122	8b 4d ac	 mov	 ecx, DWORD PTR tv208[ebp]
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0012b	89 45 a8	 mov	 DWORD PTR tv209[ebp], eax
  0012e	8b 4d a8	 mov	 ecx, DWORD PTR tv209[ebp]
  00131	89 4d d4	 mov	 DWORD PTR $T14456[ebp], ecx
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0013a	89 45 a4	 mov	 DWORD PTR tv210[ebp], eax
  0013d	8b 55 a4	 mov	 edx, DWORD PTR tv210[ebp]
  00140	89 55 d0	 mov	 DWORD PTR $T14457[ebp], edx
  00143	8d 45 d4	 lea	 eax, DWORD PTR $T14456[ebp]
  00146	50		 push	 eax
  00147	8d 4d d0	 lea	 ecx, DWORD PTR $T14457[ebp]
  0014a	51		 push	 ecx
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00151	83 c4 08	 add	 esp, 8
  00154	88 45 a3	 mov	 BYTE PTR tv211[ebp], al
  00157	0f b6 55 a3	 movzx	 edx, BYTE PTR tv211[ebp]
  0015b	85 d2		 test	 edx, edx
  0015d	74 0b		 je	 SHORT $L13065

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  0015f	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00162	83 c8 04	 or	 eax, 4
  00165	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  00168	eb 05		 jmp	 SHORT $L13059
$L13065:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  0016a	e9 78 ff ff ff	 jmp	 $L13061
$L13059:
  0016f	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00173	0f 85 91 00 00
	00		 jne	 $L13066

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00179	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Count$13067[ebp], 0
  00180	eb 09		 jmp	 SHORT $L13068
$L13069:
  00182	8b 4d d8	 mov	 ecx, DWORD PTR __Count$13067[ebp]
  00185	83 c1 01	 add	 ecx, 1
  00188	89 4d d8	 mov	 DWORD PTR __Count$13067[ebp], ecx
$L13068:
  0018b	8b 55 d8	 mov	 edx, DWORD PTR __Count$13067[ebp]
  0018e	3b 55 dc	 cmp	 edx, DWORD PTR __Size$[ebp]
  00191	73 77		 jae	 SHORT $L13066

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  00193	8b 45 d8	 mov	 eax, DWORD PTR __Count$13067[ebp]
  00196	50		 push	 eax
  00197	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
  001a0	89 45 9c	 mov	 DWORD PTR tv212[ebp], eax
  001a3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001ab	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001b4	89 45 98	 mov	 DWORD PTR tv213[ebp], eax
  001b7	8b 45 9c	 mov	 eax, DWORD PTR tv212[ebp]
  001ba	8a 08		 mov	 cl, BYTE PTR [eax]
  001bc	51		 push	 ecx
  001bd	8b 4d 98	 mov	 ecx, DWORD PTR tv213[ebp]
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  001c6	89 45 94	 mov	 DWORD PTR tv214[ebp], eax
  001c9	8b 55 94	 mov	 edx, DWORD PTR tv214[ebp]
  001cc	89 55 cc	 mov	 DWORD PTR $T14458[ebp], edx
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  001d5	89 45 90	 mov	 DWORD PTR tv215[ebp], eax
  001d8	8b 45 90	 mov	 eax, DWORD PTR tv215[ebp]
  001db	89 45 c8	 mov	 DWORD PTR $T14459[ebp], eax
  001de	8d 4d cc	 lea	 ecx, DWORD PTR $T14458[ebp]
  001e1	51		 push	 ecx
  001e2	8d 55 c8	 lea	 edx, DWORD PTR $T14459[ebp]
  001e5	52		 push	 edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  001ec	83 c4 08	 add	 esp, 8
  001ef	88 45 8f	 mov	 BYTE PTR tv216[ebp], al
  001f2	0f b6 45 8f	 movzx	 eax, BYTE PTR tv216[ebp]
  001f6	85 c0		 test	 eax, eax
  001f8	74 0b		 je	 SHORT $L13073

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  001fa	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001fd	83 c9 04	 or	 ecx, 4
  00200	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  00203	eb 05		 jmp	 SHORT $L13066
$L13073:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00205	e9 78 ff ff ff	 jmp	 $L13069
$L13066:
  0020a	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  0020e	0f 85 98 00 00
	00		 jne	 $L13074

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00214	eb 09		 jmp	 SHORT $L13075
$L13076:
  00216	8b 55 e8	 mov	 edx, DWORD PTR __Pad$[ebp]
  00219	83 ea 01	 sub	 edx, 1
  0021c	89 55 e8	 mov	 DWORD PTR __Pad$[ebp], edx
$L13075:
  0021f	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00223	0f 86 83 00 00
	00		 jbe	 $L13074

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  00229	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0022c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00231	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00234	8b ca		 mov	 ecx, edx
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0023c	88 45 8e	 mov	 BYTE PTR tv217[ebp], al
  0023f	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00242	8b 08		 mov	 ecx, DWORD PTR [eax]
  00244	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00247	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0024a	8b ca		 mov	 ecx, edx
  0024c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00252	89 45 88	 mov	 DWORD PTR tv218[ebp], eax
  00255	8a 45 8e	 mov	 al, BYTE PTR tv217[ebp]
  00258	50		 push	 eax
  00259	8b 4d 88	 mov	 ecx, DWORD PTR tv218[ebp]
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00262	89 45 84	 mov	 DWORD PTR tv219[ebp], eax
  00265	8b 4d 84	 mov	 ecx, DWORD PTR tv219[ebp]
  00268	89 4d c4	 mov	 DWORD PTR $T14460[ebp], ecx
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  00271	89 45 80	 mov	 DWORD PTR tv220[ebp], eax
  00274	8b 55 80	 mov	 edx, DWORD PTR tv220[ebp]
  00277	89 55 c0	 mov	 DWORD PTR $T14461[ebp], edx
  0027a	8d 45 c4	 lea	 eax, DWORD PTR $T14460[ebp]
  0027d	50		 push	 eax
  0027e	8d 4d c0	 lea	 ecx, DWORD PTR $T14461[ebp]
  00281	51		 push	 ecx
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00288	83 c4 08	 add	 esp, 8
  0028b	88 85 7f ff ff
	ff		 mov	 BYTE PTR tv221[ebp], al
  00291	0f b6 95 7f ff
	ff ff		 movzx	 edx, BYTE PTR tv221[ebp]
  00298	85 d2		 test	 edx, edx
  0029a	74 0b		 je	 SHORT $L13080

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  0029c	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0029f	83 c8 04	 or	 eax, 4
  002a2	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  002a5	eb 05		 jmp	 SHORT $L13074
$L13080:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  002a7	e9 6a ff ff ff	 jmp	 $L13076
$L13074:
  002ac	6a 00		 push	 0
  002ae	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  002b3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002b6	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  002bf	eb 1d		 jmp	 SHORT $L14463
$L14464:

; 581  : 		_CATCH_IO_(_Ostr)

  002c1	6a 01		 push	 1
  002c3	6a 04		 push	 4
  002c5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ca	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002cd	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002d0	8b ca		 mov	 ecx, edx
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  002d8	b8 00 00 00 00	 mov	 eax, $L14463
  002dd	c3		 ret	 0
$L14463:
  002de	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  002e5	6a 00		 push	 0
  002e7	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002ea	50		 push	 eax
  002eb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002f3	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 585  : 	return (_Ostr);

  002fc	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002ff	89 45 bc	 mov	 DWORD PTR $T14462[ebp], eax
  00302	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00309	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0030c	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00311	8b 45 bc	 mov	 eax, DWORD PTR $T14462[ebp]

; 586  : 	}

  00314	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00317	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0031e	5f		 pop	 edi
  0031f	5e		 pop	 esi
  00320	5b		 pop	 ebx
  00321	8b e5		 mov	 esp, ebp
  00323	5d		 pop	 ebp
  00324	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14465:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14467
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T14480	DD	0ffffffffH
	DD	FLAT:$L14476
$T14478	DD	019930520H
	DD	01H
	DD	FLAT:$T14480
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00037	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	74 30		 je	 SHORT $L12414
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  00058	85 c0		 test	 eax, eax
  0005a	74 1b		 je	 SHORT $L12414

; 90   : 				_Ostr.tie()->flush();

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b ca		 mov	 ecx, edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0006f	8b c8		 mov	 ecx, eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$L12414:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00077	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00082	8b ca		 mov	 ecx, edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14476:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14478
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:NEAR
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14489	DD	0ffffffffH
	DD	FLAT:$L14485
$T14487	DD	019930520H
	DD	01H
	DD	FLAT:$T14489
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0b		 jne	 SHORT $L12416

; 99   : 				this->_Myostr._Osfx();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$L12416:

; 100  : 			}

  0003b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14485:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14487
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L12666

; 70   : 				_Myostr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L12666:

; 71   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L12669

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L12669:

; 77   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@_W@std@@SAGXZ:NEAR
EXTRN	__imp_?is@?$ctype@_W@std@@QBE_NF_W@Z:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB:DWORD
EXTRN	__imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z:NEAR
EXTRN	__imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T14512	DD	0ffffffffH
	DD	FLAT:$L14507
	DD	00H
	DD	FLAT:$L14508
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T14514	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L14506
$T14513	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T14514
$T14510	DD	019930520H
	DD	04H
	DD	FLAT:$T14512
	DD	01H
	DD	FLAT:$T14513
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv205 = -112						; size = 2
tv204 = -109						; size = 1
tv203 = -108						; size = 2
tv202 = -105						; size = 1
tv201 = -104						; size = 2
tv200 = -102						; size = 2
tv199 = -100						; size = 4
tv198 = -94						; size = 2
tv197 = -92						; size = 4
tv196 = -88						; size = 4
tv135 = -84						; size = 4
tv195 = -80						; size = 4
tv194 = -76						; size = 4
tv193 = -72						; size = 4
tv192 = -68						; size = 4
tv189 = -64						; size = 4
tv65 = -60						; size = 4
$T14504 = -56						; size = 4
$T14503 = -50						; size = 2
$T14500 = -48						; size = 4
__Meta$13097 = -44					; size = 2
__Size$13094 = -40					; size = 4
__Ctype_fac$13091 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 e9 01 00
	00		 je	 $L14505

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00055	8d 55 d0	 lea	 edx, DWORD PTR $T14500[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00061	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00064	8b ca		 mov	 ecx, edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0006c	89 45 c4	 mov	 DWORD PTR tv65[ebp], eax
  0006f	8b 45 c4	 mov	 eax, DWORD PTR tv65[ebp]
  00072	89 45 c0	 mov	 DWORD PTR tv189[ebp], eax
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00079	8b 4d c0	 mov	 ecx, DWORD PTR tv189[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 dc	 mov	 DWORD PTR __Ctype_fac$13091[ebp], eax
  00088	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0008c	8d 4d d0	 lea	 ecx, DWORD PTR $T14500[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	50		 push	 eax
  0009e	6a 00		 push	 0
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000a9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000be	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  000c1	83 7d bc 00	 cmp	 DWORD PTR tv192[ebp], 0
  000c5	7e 46		 jle	 SHORT $L14501
  000c7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000d2	8b ca		 mov	 ecx, edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000da	89 45 b8	 mov	 DWORD PTR tv193[ebp], eax
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  000e6	89 45 b4	 mov	 DWORD PTR tv194[ebp], eax
  000e9	8b 45 b8	 mov	 eax, DWORD PTR tv193[ebp]
  000ec	3b 45 b4	 cmp	 eax, DWORD PTR tv194[ebp]
  000ef	73 1c		 jae	 SHORT $L14501
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f9	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00102	89 45 b0	 mov	 DWORD PTR tv195[ebp], eax
  00105	8b 45 b0	 mov	 eax, DWORD PTR tv195[ebp]
  00108	89 45 ac	 mov	 DWORD PTR tv135[ebp], eax
  0010b	eb 12		 jmp	 SHORT $L14502
$L14501:
  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00116	89 45 a8	 mov	 DWORD PTR tv196[ebp], eax
  00119	8b 4d a8	 mov	 ecx, DWORD PTR tv196[ebp]
  0011c	89 4d ac	 mov	 DWORD PTR tv135[ebp], ecx
$L14502:
  0011f	8b 55 ac	 mov	 edx, DWORD PTR tv135[ebp]
  00122	89 55 d8	 mov	 DWORD PTR __Size$13094[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00125	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0012d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00130	8b ca		 mov	 ecx, edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00138	89 45 a4	 mov	 DWORD PTR tv197[ebp], eax
  0013b	8b 4d a4	 mov	 ecx, DWORD PTR tv197[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  00144	66 89 45 a2	 mov	 WORD PTR tv198[ebp], ax
  00148	66 8b 45 a2	 mov	 ax, WORD PTR tv198[ebp]
  0014c	66 89 45 d4	 mov	 WORD PTR __Meta$13097[ebp], ax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  00150	eb 32		 jmp	 SHORT $L13098
$L13099:
  00152	8b 4d d8	 mov	 ecx, DWORD PTR __Size$13094[ebp]
  00155	83 e9 01	 sub	 ecx, 1
  00158	89 4d d8	 mov	 DWORD PTR __Size$13094[ebp], ecx
  0015b	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0015e	8b 02		 mov	 eax, DWORD PTR [edx]
  00160	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00163	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0016c	89 45 9c	 mov	 DWORD PTR tv199[ebp], eax
  0016f	8b 4d 9c	 mov	 ecx, DWORD PTR tv199[ebp]
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  00178	66 89 45 9a	 mov	 WORD PTR tv200[ebp], ax
  0017c	66 8b 4d 9a	 mov	 cx, WORD PTR tv200[ebp]
  00180	66 89 4d d4	 mov	 WORD PTR __Meta$13097[ebp], cx
$L13098:
  00184	83 7d d8 00	 cmp	 DWORD PTR __Size$13094[ebp], 0
  00188	0f 86 91 00 00
	00		 jbe	 $L13100

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00194	66 89 45 98	 mov	 WORD PTR tv201[ebp], ax
  00198	66 8b 55 98	 mov	 dx, WORD PTR tv201[ebp]
  0019c	66 89 55 ce	 mov	 WORD PTR $T14503[ebp], dx
  001a0	8d 45 d4	 lea	 eax, DWORD PTR __Meta$13097[ebp]
  001a3	50		 push	 eax
  001a4	8d 4d ce	 lea	 ecx, DWORD PTR $T14503[ebp]
  001a7	51		 push	 ecx
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  001ae	83 c4 08	 add	 esp, 8
  001b1	88 45 97	 mov	 BYTE PTR tv202[ebp], al
  001b4	0f b6 55 97	 movzx	 edx, BYTE PTR tv202[ebp]
  001b8	85 d2		 test	 edx, edx
  001ba	74 0b		 je	 SHORT $L13102

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  001bc	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001bf	83 c8 01	 or	 eax, 1
  001c2	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  001c5	eb 58		 jmp	 SHORT $L13100
$L13102:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  001c7	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$13097[ebp]
  001ca	51		 push	 ecx
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  001d1	83 c4 04	 add	 esp, 4
  001d4	66 89 45 94	 mov	 WORD PTR tv203[ebp], ax
  001d8	66 8b 55 94	 mov	 dx, WORD PTR tv203[ebp]
  001dc	52		 push	 edx
  001dd	6a 48		 push	 72			; 00000048H
  001df	8b 4d dc	 mov	 ecx, DWORD PTR __Ctype_fac$13091[ebp]
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z
  001e8	88 45 93	 mov	 BYTE PTR tv204[ebp], al
  001eb	0f b6 45 93	 movzx	 eax, BYTE PTR tv204[ebp]
  001ef	85 c0		 test	 eax, eax
  001f1	74 02		 je	 SHORT $L13104

; 454  : 				break;	// whitespace, quit

  001f3	eb 2a		 jmp	 SHORT $L13100
$L13104:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  001f5	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$13097[ebp]
  001f8	51		 push	 ecx
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  001ff	83 c4 04	 add	 esp, 4
  00202	66 89 45 90	 mov	 WORD PTR tv205[ebp], ax
  00206	66 8b 55 90	 mov	 dx, WORD PTR tv205[ebp]
  0020a	52		 push	 edx
  0020b	6a 01		 push	 1
  0020d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z

; 458  : 				_Changed = true;

  00216	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  0021a	e9 33 ff ff ff	 jmp	 $L13099
$L13100:
  0021f	eb 1d		 jmp	 SHORT $L14505
$L14506:

; 460  : 		_CATCH_IO_(_Istr)

  00221	6a 01		 push	 1
  00223	6a 04		 push	 4
  00225	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00228	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0022d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00230	8b ca		 mov	 ecx, edx
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  00238	b8 00 00 00 00	 mov	 eax, $L14505
  0023d	c3		 ret	 0
$L14505:
  0023e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  00245	6a 00		 push	 0
  00247	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0024a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024c	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0024f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00252	8b ca		 mov	 ecx, edx
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z

; 464  : 	if (!_Changed)

  0025a	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  0025e	85 c0		 test	 eax, eax
  00260	75 09		 jne	 SHORT $L13106

; 465  : 		_State |= ios_base::failbit;

  00262	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00265	83 c9 02	 or	 ecx, 2
  00268	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L13106:

; 466  : 	_Istr.setstate(_State);

  0026b	6a 00		 push	 0
  0026d	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00270	52		 push	 edx
  00271	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00274	8b 08		 mov	 ecx, DWORD PTR [eax]
  00276	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00279	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0027c	8b ca		 mov	 ecx, edx
  0027e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 467  : 	return (_Istr);

  00284	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00287	89 45 c8	 mov	 DWORD PTR $T14504[ebp], eax
  0028a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00291	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00294	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00299	8b 45 c8	 mov	 eax, DWORD PTR $T14504[ebp]

; 468  : 	}

  0029c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0029f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002a6	5f		 pop	 edi
  002a7	5e		 pop	 esi
  002a8	5b		 pop	 ebx
  002a9	8b e5		 mov	 esp, ebp
  002ab	5d		 pop	 ebp
  002ac	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14507:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
$L14508:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T14500[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14510
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T14526	DD	0ffffffffH
	DD	FLAT:$L14522
$T14524	DD	019930520H
	DD	01H
	DD	FLAT:$T14526
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0002f	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14522:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14524
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L11550

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L11550:

; 61   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L12408

; 54   : 				_Myistr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L12408:

; 55   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
EXTRN	__imp_?id@?$ctype@_W@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14543	DD	0ffffffffH
	DD	FLAT:$L14539
$T14541	DD	019930520H
	DD	01H
	DD	FLAT:$T14543
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T14538 = -48						; size = 4
$T14537 = -44						; size = 12
__Pfmod$12964 = -32					; size = 4
__Psave$ = -28						; size = 4
__Lock$ = -24						; size = 4
__Id$ = -20						; size = 4
__Pf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 24	 sub	 esp, 36			; 00000024H

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	6a 00		 push	 0
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  00032	89 45 e4	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@_W@std@@2V0locale@2@A
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00041	89 45 ec	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00044	8b 4d ec	 mov	 ecx, DWORD PTR __Id$[ebp]
  00047	51		 push	 ecx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00051	89 45 f0	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00054	83 7d f0 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00058	74 02		 je	 SHORT $L12955

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  0005a	eb 62		 jmp	 SHORT $L12956
$L12955:
  0005c	83 7d e4 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  00060	74 08		 je	 SHORT $L12957

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00062	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  00065	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00068	eb 54		 jmp	 SHORT $L12956
$L12957:
  0006a	8d 45 e4	 lea	 eax, DWORD PTR __Psave$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z
  00074	83 c4 04	 add	 esp, 4
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	75 1c		 jne	 SHORT $L12960

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  00081	8d 4d d4	 lea	 ecx, DWORD PTR $T14537[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  0008f	8d 4d d4	 lea	 ecx, DWORD PTR $T14537[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 __CxxThrowException@8
$L12960:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  00098	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  0009b	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Psave$[ebp]
  000a1	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000a6	8b 4d e4	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000a9	89 4d e0	 mov	 DWORD PTR __Pfmod$12964[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ac	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$12964[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$12964[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L12956:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000be	8b 55 f0	 mov	 edx, DWORD PTR __Pf$[ebp]
  000c1	89 55 d0	 mov	 DWORD PTR $T14538[ebp], edx
  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d4	8b 45 d0	 mov	 eax, DWORD PTR $T14538[ebp]
$L14536:

; 347  : 	}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14539:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14541
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00003	6a 0a		 push	 10			; 0000000aH
  00005	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0000d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00010	8b ca		 mov	 ecx, edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  00018	50		 push	 eax
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
EXTRN	__imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z:NEAR
EXTRN	__imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14559	DD	0ffffffffH
	DD	FLAT:$L14555
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T14561	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L14554
$T14560	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T14561
$T14557	DD	019930520H
	DD	03H
	DD	FLAT:$T14559
	DD	01H
	DD	FLAT:$T14560
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT
tv175 = -86						; size = 2
tv174 = -84						; size = 4
tv173 = -80						; size = 4
tv172 = -76						; size = 4
tv171 = -70						; size = 1
tv170 = -69						; size = 1
tv169 = -68						; size = 2
tv168 = -66						; size = 2
tv167 = -64						; size = 4
tv166 = -58						; size = 2
tv165 = -56						; size = 4
tv65 = -50						; size = 2
$T14552 = -48						; size = 4
$T14551 = -42						; size = 2
__Meta$13117 = -40					; size = 2
__Metadelim$13116 = -36					; size = 2
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 2
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 48	 sub	 esp, 72			; 00000048H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 74 01 00
	00		 je	 $L14553

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  0006d	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z
  00077	83 c4 04	 add	 esp, 4
  0007a	66 89 45 ce	 mov	 WORD PTR tv65[ebp], ax
  0007e	66 8b 55 ce	 mov	 dx, WORD PTR tv65[ebp]
  00082	66 89 55 dc	 mov	 WORD PTR __Metadelim$13116[ebp], dx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00086	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0008e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00091	8b ca		 mov	 ecx, edx
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00099	89 45 c8	 mov	 DWORD PTR tv165[ebp], eax
  0009c	8b 4d c8	 mov	 ecx, DWORD PTR tv165[ebp]
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000a5	66 89 45 c6	 mov	 WORD PTR tv166[ebp], ax
  000a9	66 8b 45 c6	 mov	 ax, WORD PTR tv166[ebp]
  000ad	66 89 45 d8	 mov	 WORD PTR __Meta$13117[ebp], ax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000b1	eb 29		 jmp	 SHORT $L13118
$L13119:
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000bb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  000c4	89 45 c0	 mov	 DWORD PTR tv167[ebp], eax
  000c7	8b 4d c0	 mov	 ecx, DWORD PTR tv167[ebp]
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000d0	66 89 45 be	 mov	 WORD PTR tv168[ebp], ax
  000d4	66 8b 45 be	 mov	 ax, WORD PTR tv168[ebp]
  000d8	66 89 45 d8	 mov	 WORD PTR __Meta$13117[ebp], ax
$L13118:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  000e2	66 89 45 bc	 mov	 WORD PTR tv169[ebp], ax
  000e6	66 8b 4d bc	 mov	 cx, WORD PTR tv169[ebp]
  000ea	66 89 4d d6	 mov	 WORD PTR $T14551[ebp], cx
  000ee	8d 55 d8	 lea	 edx, DWORD PTR __Meta$13117[ebp]
  000f1	52		 push	 edx
  000f2	8d 45 d6	 lea	 eax, DWORD PTR $T14551[ebp]
  000f5	50		 push	 eax
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  000fc	83 c4 08	 add	 esp, 8
  000ff	88 45 bb	 mov	 BYTE PTR tv170[ebp], al
  00102	0f b6 4d bb	 movzx	 ecx, BYTE PTR tv170[ebp]
  00106	85 c9		 test	 ecx, ecx
  00108	74 0e		 je	 SHORT $L13122

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  0010a	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  0010d	83 ca 01	 or	 edx, 1
  00110	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  00113	e9 94 00 00 00	 jmp	 $L13120
$L13122:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  00118	8d 45 dc	 lea	 eax, DWORD PTR __Metadelim$13116[ebp]
  0011b	50		 push	 eax
  0011c	8d 4d d8	 lea	 ecx, DWORD PTR __Meta$13117[ebp]
  0011f	51		 push	 ecx
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  00126	83 c4 08	 add	 esp, 8
  00129	88 45 ba	 mov	 BYTE PTR tv171[ebp], al
  0012c	0f b6 55 ba	 movzx	 edx, BYTE PTR tv171[ebp]
  00130	85 d2		 test	 edx, edx
  00132	74 25		 je	 SHORT $L13124

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00134	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  00138	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0013b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00140	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00143	8b ca		 mov	 ecx, edx
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0014b	89 45 b4	 mov	 DWORD PTR tv172[ebp], eax
  0014e	8b 4d b4	 mov	 ecx, DWORD PTR tv172[ebp]
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ

; 501  : 				break;

  00157	eb 53		 jmp	 SHORT $L13120
$L13124:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  00159	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00162	89 45 b0	 mov	 DWORD PTR tv173[ebp], eax
  00165	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  0016e	89 45 ac	 mov	 DWORD PTR tv174[ebp], eax
  00171	8b 45 b0	 mov	 eax, DWORD PTR tv173[ebp]
  00174	3b 45 ac	 cmp	 eax, DWORD PTR tv174[ebp]
  00177	77 0b		 ja	 SHORT $L13126

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  00179	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  0017c	83 c9 02	 or	 ecx, 2
  0017f	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  00182	eb 28		 jmp	 SHORT $L13120
$L13126:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  00184	8d 55 d8	 lea	 edx, DWORD PTR __Meta$13117[ebp]
  00187	52		 push	 edx
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  0018e	83 c4 04	 add	 esp, 4
  00191	66 89 45 aa	 mov	 WORD PTR tv175[ebp], ax
  00195	66 8b 45 aa	 mov	 ax, WORD PTR tv175[ebp]
  00199	50		 push	 eax
  0019a	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z

; 511  : 				_Changed = true;

  001a3	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  001a7	e9 07 ff ff ff	 jmp	 $L13119
$L13120:
  001ac	eb 1b		 jmp	 SHORT $L14553
$L14554:

; 513  : 		_CATCH_IO_(_Istr)

  001ae	6a 01		 push	 1
  001b0	6a 04		 push	 4
  001b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b7	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001ba	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  001c3	b8 00 00 00 00	 mov	 eax, $L14553
  001c8	c3		 ret	 0
$L14553:
  001c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  001d0	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  001d4	85 c0		 test	 eax, eax
  001d6	75 09		 jne	 SHORT $L13128

; 517  : 		_State |= ios_base::failbit;

  001d8	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001db	83 c9 02	 or	 ecx, 2
  001de	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L13128:

; 518  : 	_Istr.setstate(_State);

  001e1	6a 00		 push	 0
  001e3	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001e6	52		 push	 edx
  001e7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ec	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001ef	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001f2	8b ca		 mov	 ecx, edx
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 519  : 	return (_Istr);

  001fa	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001fd	89 45 d0	 mov	 DWORD PTR $T14552[ebp], eax
  00200	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00207	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0020a	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0020f	8b 45 d0	 mov	 eax, DWORD PTR $T14552[ebp]

; 520  : 	}

  00212	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00215	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0021c	5f		 pop	 edi
  0021d	5e		 pop	 esi
  0021e	5b		 pop	 ebx
  0021f	8b e5		 mov	 esp, ebp
  00221	5d		 pop	 ebp
  00222	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14555:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
__ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14557
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z:NEAR
EXTRN	__imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z:NEAR
EXTRN	__imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14581	DD	0ffffffffH
	DD	FLAT:$L14577
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T14583	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L14576
$T14582	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T14583
$T14579	DD	019930520H
	DD	03H
	DD	FLAT:$T14581
	DD	01H
	DD	FLAT:$T14582
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv221 = -105						; size = 1
tv220 = -104						; size = 2
tv219 = -102						; size = 2
tv218 = -100						; size = 4
tv217 = -96						; size = 2
tv216 = -93						; size = 1
tv215 = -92						; size = 2
tv214 = -90						; size = 2
tv213 = -88						; size = 4
tv212 = -84						; size = 4
tv211 = -77						; size = 1
tv210 = -76						; size = 2
tv209 = -74						; size = 2
tv208 = -72						; size = 4
tv207 = -66						; size = 2
tv83 = -64						; size = 4
tv81 = -60						; size = 4
$T14574 = -56						; size = 4
$T14573 = -52						; size = 2
$T14572 = -50						; size = 2
$T14571 = -48						; size = 2
$T14570 = -46						; size = 2
$T14569 = -44						; size = 2
$T14568 = -42						; size = 2
__Count$13151 = -40					; size = 4
__Size$ = -36						; size = 4
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00032	89 45 dc	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0003d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00040	8b ca		 mov	 ecx, edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00048	85 c0		 test	 eax, eax
  0004a	7e 33		 jle	 SHORT $L14566
  0004c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00054	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00057	8b ca		 mov	 ecx, edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0005f	3b 45 dc	 cmp	 eax, DWORD PTR __Size$[ebp]
  00062	76 1b		 jbe	 SHORT $L14566
  00064	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00077	2b 45 dc	 sub	 eax, DWORD PTR __Size$[ebp]
  0007a	89 45 c4	 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 07		 jmp	 SHORT $L14567
$L14566:
  0007f	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L14567:
  00086	8b 45 c4	 mov	 eax, DWORD PTR tv81[ebp]
  00089	89 45 e8	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008f	51		 push	 ecx
  00090	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00093	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  0009f	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000a2	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  000a7	0f b6 d0	 movzx	 edx, al
  000aa	85 d2		 test	 edx, edx
  000ac	75 0e		 jne	 SHORT $L13140

; 550  : 		_State |= ios_base::badbit;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000b1	83 c8 04	 or	 eax, 4
  000b4	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000b7	e9 37 02 00 00	 jmp	 $L14575
$L13140:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  000d1	89 45 c0	 mov	 DWORD PTR tv83[ebp], eax
  000d4	8b 45 c0	 mov	 eax, DWORD PTR tv83[ebp]
  000d7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000dc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000df	0f 84 96 00 00
	00		 je	 $L13143

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000e5	eb 09		 jmp	 SHORT $L13144
$L13145:
  000e7	8b 4d e8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  000ea	83 e9 01	 sub	 ecx, 1
  000ed	89 4d e8	 mov	 DWORD PTR __Pad$[ebp], ecx
$L13144:
  000f0	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  000f4	0f 86 81 00 00
	00		 jbe	 $L13143

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  000fa	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00102	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  0010b	66 89 45 be	 mov	 WORD PTR tv207[ebp], ax
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00117	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00120	89 45 b8	 mov	 DWORD PTR tv208[ebp], eax
  00123	66 8b 45 be	 mov	 ax, WORD PTR tv207[ebp]
  00127	50		 push	 eax
  00128	8b 4d b8	 mov	 ecx, DWORD PTR tv208[ebp]
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00131	66 89 45 b6	 mov	 WORD PTR tv209[ebp], ax
  00135	66 8b 4d b6	 mov	 cx, WORD PTR tv209[ebp]
  00139	66 89 4d d6	 mov	 WORD PTR $T14568[ebp], cx
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00143	66 89 45 b4	 mov	 WORD PTR tv210[ebp], ax
  00147	66 8b 55 b4	 mov	 dx, WORD PTR tv210[ebp]
  0014b	66 89 55 d4	 mov	 WORD PTR $T14569[ebp], dx
  0014f	8d 45 d6	 lea	 eax, DWORD PTR $T14568[ebp]
  00152	50		 push	 eax
  00153	8d 4d d4	 lea	 ecx, DWORD PTR $T14569[ebp]
  00156	51		 push	 ecx
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  0015d	83 c4 08	 add	 esp, 8
  00160	88 45 b3	 mov	 BYTE PTR tv211[ebp], al
  00163	0f b6 55 b3	 movzx	 edx, BYTE PTR tv211[ebp]
  00167	85 d2		 test	 edx, edx
  00169	74 0b		 je	 SHORT $L13149

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  0016b	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0016e	83 c8 04	 or	 eax, 4
  00171	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  00174	eb 05		 jmp	 SHORT $L13143
$L13149:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  00176	e9 6c ff ff ff	 jmp	 $L13145
$L13143:
  0017b	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  0017f	0f 85 98 00 00
	00		 jne	 $L13150

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00185	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Count$13151[ebp], 0
  0018c	eb 09		 jmp	 SHORT $L13152
$L13153:
  0018e	8b 4d d8	 mov	 ecx, DWORD PTR __Count$13151[ebp]
  00191	83 c1 01	 add	 ecx, 1
  00194	89 4d d8	 mov	 DWORD PTR __Count$13151[ebp], ecx
$L13152:
  00197	8b 55 d8	 mov	 edx, DWORD PTR __Count$13151[ebp]
  0019a	3b 55 dc	 cmp	 edx, DWORD PTR __Size$[ebp]
  0019d	73 7e		 jae	 SHORT $L13150

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  0019f	8b 45 d8	 mov	 eax, DWORD PTR __Count$13151[ebp]
  001a2	50		 push	 eax
  001a3	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z
  001ac	89 45 ac	 mov	 DWORD PTR tv212[ebp], eax
  001af	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b4	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001b7	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  001c0	89 45 a8	 mov	 DWORD PTR tv213[ebp], eax
  001c3	8b 45 ac	 mov	 eax, DWORD PTR tv212[ebp]
  001c6	66 8b 08	 mov	 cx, WORD PTR [eax]
  001c9	51		 push	 ecx
  001ca	8b 4d a8	 mov	 ecx, DWORD PTR tv213[ebp]
  001cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  001d3	66 89 45 a6	 mov	 WORD PTR tv214[ebp], ax
  001d7	66 8b 55 a6	 mov	 dx, WORD PTR tv214[ebp]
  001db	66 89 55 d2	 mov	 WORD PTR $T14570[ebp], dx
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  001e5	66 89 45 a4	 mov	 WORD PTR tv215[ebp], ax
  001e9	66 8b 45 a4	 mov	 ax, WORD PTR tv215[ebp]
  001ed	66 89 45 d0	 mov	 WORD PTR $T14571[ebp], ax
  001f1	8d 4d d2	 lea	 ecx, DWORD PTR $T14570[ebp]
  001f4	51		 push	 ecx
  001f5	8d 55 d0	 lea	 edx, DWORD PTR $T14571[ebp]
  001f8	52		 push	 edx
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  001ff	83 c4 08	 add	 esp, 8
  00202	88 45 a3	 mov	 BYTE PTR tv216[ebp], al
  00205	0f b6 45 a3	 movzx	 eax, BYTE PTR tv216[ebp]
  00209	85 c0		 test	 eax, eax
  0020b	74 0b		 je	 SHORT $L13157

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  0020d	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00210	83 c9 04	 or	 ecx, 4
  00213	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  00216	eb 05		 jmp	 SHORT $L13150
$L13157:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00218	e9 71 ff ff ff	 jmp	 $L13153
$L13150:
  0021d	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00221	0f 85 9a 00 00
	00		 jne	 $L13158

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00227	eb 09		 jmp	 SHORT $L13159
$L13160:
  00229	8b 55 e8	 mov	 edx, DWORD PTR __Pad$[ebp]
  0022c	83 ea 01	 sub	 edx, 1
  0022f	89 55 e8	 mov	 DWORD PTR __Pad$[ebp], edx
$L13159:
  00232	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00236	0f 86 85 00 00
	00		 jbe	 $L13158

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  0023c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0023f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00241	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00244	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00247	8b ca		 mov	 ecx, edx
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  0024f	66 89 45 a0	 mov	 WORD PTR tv217[ebp], ax
  00253	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00256	8b 08		 mov	 ecx, DWORD PTR [eax]
  00258	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0025b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0025e	8b ca		 mov	 ecx, edx
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00266	89 45 9c	 mov	 DWORD PTR tv218[ebp], eax
  00269	66 8b 45 a0	 mov	 ax, WORD PTR tv217[ebp]
  0026d	50		 push	 eax
  0026e	8b 4d 9c	 mov	 ecx, DWORD PTR tv218[ebp]
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00277	66 89 45 9a	 mov	 WORD PTR tv219[ebp], ax
  0027b	66 8b 4d 9a	 mov	 cx, WORD PTR tv219[ebp]
  0027f	66 89 4d ce	 mov	 WORD PTR $T14572[ebp], cx
  00283	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00289	66 89 45 98	 mov	 WORD PTR tv220[ebp], ax
  0028d	66 8b 55 98	 mov	 dx, WORD PTR tv220[ebp]
  00291	66 89 55 cc	 mov	 WORD PTR $T14573[ebp], dx
  00295	8d 45 ce	 lea	 eax, DWORD PTR $T14572[ebp]
  00298	50		 push	 eax
  00299	8d 4d cc	 lea	 ecx, DWORD PTR $T14573[ebp]
  0029c	51		 push	 ecx
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  002a3	83 c4 08	 add	 esp, 8
  002a6	88 45 97	 mov	 BYTE PTR tv221[ebp], al
  002a9	0f b6 55 97	 movzx	 edx, BYTE PTR tv221[ebp]
  002ad	85 d2		 test	 edx, edx
  002af	74 0b		 je	 SHORT $L13164

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  002b1	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002b4	83 c8 04	 or	 eax, 4
  002b7	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  002ba	eb 05		 jmp	 SHORT $L13158
$L13164:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  002bc	e9 68 ff ff ff	 jmp	 $L13160
$L13158:
  002c1	6a 00		 push	 0
  002c3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002cb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  002d4	eb 1d		 jmp	 SHORT $L14575
$L14576:

; 581  : 		_CATCH_IO_(_Ostr)

  002d6	6a 01		 push	 1
  002d8	6a 04		 push	 4
  002da	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002df	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002e2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002e5	8b ca		 mov	 ecx, edx
  002e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  002ed	b8 00 00 00 00	 mov	 eax, $L14575
  002f2	c3		 ret	 0
$L14575:
  002f3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  002fa	6a 00		 push	 0
  002fc	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002ff	50		 push	 eax
  00300	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00303	8b 11		 mov	 edx, DWORD PTR [ecx]
  00305	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00308	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 585  : 	return (_Ostr);

  00311	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00314	89 45 c8	 mov	 DWORD PTR $T14574[ebp], eax
  00317	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0031e	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00321	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00326	8b 45 c8	 mov	 eax, DWORD PTR $T14574[ebp]

; 586  : 	}

  00329	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0032c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00333	5f		 pop	 edi
  00334	5e		 pop	 esi
  00335	5b		 pop	 ebx
  00336	8b e5		 mov	 esp, ebp
  00338	5d		 pop	 ebp
  00339	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14577:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14579
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T14592	DD	0ffffffffH
	DD	FLAT:$L14588
$T14590	DD	019930520H
	DD	01H
	DD	FLAT:$T14592
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00037	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	74 30		 je	 SHORT $L12422
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  00058	85 c0		 test	 eax, eax
  0005a	74 1b		 je	 SHORT $L12422

; 90   : 				_Ostr.tie()->flush();

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b ca		 mov	 ecx, edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  0006f	8b c8		 mov	 ecx, eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
$L12422:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00077	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00082	8b ca		 mov	 ecx, edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14588:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14590
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
EXTRN	__imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14601	DD	0ffffffffH
	DD	FLAT:$L14597
$T14599	DD	019930520H
	DD	01H
	DD	FLAT:$T14601
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0b		 jne	 SHORT $L12424

; 99   : 				this->_Myostr._Osfx();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L12424:

; 100  : 			}

  0003b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14597:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T14599
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L12672

; 70   : 				_Myostr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L12672:

; 71   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L12675

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L12675:

; 77   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
END
