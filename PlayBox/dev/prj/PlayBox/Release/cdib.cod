; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\Gui\Bitmap\cdib.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT _$E5
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??_GCDib@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CDib@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CDib@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CDib@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCDib@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4CDib@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CArchive@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFile@CArchive@@QBEPAVCFile@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA5PAVCUserException@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCObject@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCException@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCSimpleException@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCUserException@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0PAX@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0PAVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0PAVCSimpleException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0PAVCUserException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI5PAVCUserException@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0CUserException@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSimpleException@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSimpleException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CUserException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CUserException@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCUserException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CUserException@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CUserException@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CUserException@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSimpleException@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCSimpleException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CException@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GCUserException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CUserException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0PAVCException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SeekToBegin@CFile@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CDib@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?classCDib@CDib@@2UCRuntimeClass@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CObject@@SGPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CLSID_AVIFile
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _CLSID_AVISimpleUnMarshal
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IID_IAVIEditStream
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IID_IGetFrame
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IID_IAVIStreaming
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IID_IAVIStream
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IID_IAVIFile
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?classCDib@CDib@@2UCRuntimeClass@@A		; CDib::classCDib
PUBLIC	?CreateObject@CDib@@SGPAVCObject@@XZ		; CDib::CreateObject
PUBLIC	_IID_IAVIFile
PUBLIC	_IID_IAVIStream
PUBLIC	_IID_IAVIStreaming
PUBLIC	_IID_IGetFrame
PUBLIC	_IID_IAVIEditStream
PUBLIC	_CLSID_AVISimpleUnMarshal
PUBLIC	_CLSID_AVIFile
EXTRN	?GetThisClass@CObject@@SGPAUCRuntimeClass@@XZ:NEAR ; CObject::GetThisClass
_BSS	SEGMENT
_g_count DD	01H DUP (?)
_BSS	ENDS
;	COMDAT _IID_IAVIFile
CONST	SEGMENT
_IID_IAVIFile DD 020020H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _IID_IAVIStream
CONST	SEGMENT
_IID_IAVIStream DD 020021H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _IID_IAVIStreaming
CONST	SEGMENT
_IID_IAVIStreaming DD 020022H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _IID_IGetFrame
CONST	SEGMENT
_IID_IGetFrame DD 020023H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _IID_IAVIEditStream
CONST	SEGMENT
_IID_IAVIEditStream DD 020024H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _CLSID_AVISimpleUnMarshal
CONST	SEGMENT
_CLSID_AVISimpleUnMarshal DD 020009H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _CLSID_AVIFile
CONST	SEGMENT
_CLSID_AVIFile DD 020000H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
CONST	SEGMENT
$SG202661 DB	'CDib', 00H
CONST	ENDS
;	COMDAT ?classCDib@CDib@@2UCRuntimeClass@@A
_DATA	SEGMENT
?classCDib@CDib@@2UCRuntimeClass@@A DD FLAT:$SG202661	; CDib::classCDib
	DD	038H
	DD	00H
	DD	FLAT:?CreateObject@CDib@@SGPAVCObject@@XZ
	DD	FLAT:?GetThisClass@CObject@@SGPAUCRuntimeClass@@XZ
	DD	00H
	DD	FLAT:?_init_CDib@@3UAFX_CLASSINIT@@A
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG202777 DB	'Invalid bitmap file', 00H
$SG202813 DB	'Invalid bitmap file', 00H
$SG202836 DB	'Invalid bitmap file', 00H
$SG202887 DB	'AttachMemory error', 00H
	ORG $+1
$SG203027 DB	'Unable to compress this DIB', 00H
$SG203030 DB	'Driver can''t do compression', 00H
$SG203087 DB	'Read error', 00H
	ORG $+1
$SG203127 DB	'ReadSection error', 00H
	ORG $+2
$SG203146 DB	'write error', 00H
CONST	ENDS
PUBLIC	??0CDib@@IAE@XZ					; CDib::CDib
PUBLIC	??2CObject@@SGPAXI@Z				; CObject::operator new
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T203721 DD	0ffffffffH
	DD	FLAT:$L203714
$T203718 DD	019930520H
	DD	01H
	DD	FLAT:$T203721
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\bitmap\cdib.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv71 = -24						; size = 4
$T203711 = -20						; size = 4
$T203710 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?CreateObject@CDib@@SGPAVCObject@@XZ PROC NEAR		; CDib::CreateObject

; 13   : IMPLEMENT_SERIAL(CDib, CObject, 0);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateObject@CDib@@SGPAVCObject@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	6a 38		 push	 56			; 00000038H
  0001d	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  00022	89 45 ec	 mov	 DWORD PTR $T203711[ebp], eax
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	83 7d ec 00	 cmp	 DWORD PTR $T203711[ebp], 0
  00030	74 0d		 je	 SHORT $L203712
  00032	8b 4d ec	 mov	 ecx, DWORD PTR $T203711[ebp]
  00035	e8 00 00 00 00	 call	 ??0CDib@@IAE@XZ		; CDib::CDib
  0003a	89 45 e8	 mov	 DWORD PTR tv71[ebp], eax
  0003d	eb 07		 jmp	 SHORT $L203713
$L203712:
  0003f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L203713:
  00046	8b 45 e8	 mov	 eax, DWORD PTR tv71[ebp]
  00049	89 45 f0	 mov	 DWORD PTR $T203710[ebp], eax
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR $T203710[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L203714:
  00000	8b 45 ec	 mov	 eax, DWORD PTR $T203711[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00009	c3		 ret	 0
__ehhandler$?CreateObject@CDib@@SGPAVCObject@@XZ:
  0000a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203718
  0000f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreateObject@CDib@@SGPAVCObject@@XZ ENDP		; CDib::CreateObject
PUBLIC	?GetThisClass@CDib@@SGPAUCRuntimeClass@@XZ	; CDib::GetThisClass
; Function compile flags: /Odt
_TEXT	SEGMENT
?GetThisClass@CDib@@SGPAUCRuntimeClass@@XZ PROC NEAR	; CDib::GetThisClass

; 13   : IMPLEMENT_SERIAL(CDib, CObject, 0);

  00070	55		 push	 ebp
  00071	8b ec		 mov	 ebp, esp
  00073	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?classCDib@CDib@@2UCRuntimeClass@@A ; CDib::classCDib
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?GetThisClass@CDib@@SGPAUCRuntimeClass@@XZ ENDP		; CDib::GetThisClass
_TEXT	ENDS
PUBLIC	?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ	; CDib::GetRuntimeClass
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ PROC NEAR ; CDib::GetRuntimeClass
; _this$ = ecx

; 13   : IMPLEMENT_SERIAL(CDib, CObject, 0);

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	51		 push	 ecx
  00084	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00087	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?classCDib@CDib@@2UCRuntimeClass@@A ; CDib::classCDib
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ ENDP	; CDib::GetRuntimeClass
_TEXT	ENDS
PUBLIC	??5@YGAAVCArchive@@AAV0@AAPAVCDib@@@Z		; operator>>
EXTRN	?ReadObject@CArchive@@QAEPAVCObject@@PBUCRuntimeClass@@@Z:NEAR ; CArchive::ReadObject
; Function compile flags: /Odt
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pOb$ = 12						; size = 4
??5@YGAAVCArchive@@AAV0@AAPAVCDib@@@Z PROC NEAR		; operator>>

; 13   : IMPLEMENT_SERIAL(CDib, CObject, 0);

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp
  00093	e8 00 00 00 00	 call	 ?GetThisClass@CDib@@SGPAUCRuntimeClass@@XZ ; CDib::GetThisClass
  00098	50		 push	 eax
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0009c	e8 00 00 00 00	 call	 ?ReadObject@CArchive@@QAEPAVCObject@@PBUCRuntimeClass@@@Z ; CArchive::ReadObject
  000a1	8b 4d 0c	 mov	 ecx, DWORD PTR _pOb$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax
  000a6	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  000a9	5d		 pop	 ebp
  000aa	c2 08 00	 ret	 8
??5@YGAAVCArchive@@AAV0@AAPAVCDib@@@Z ENDP		; operator>>
_TEXT	ENDS
PUBLIC	?Empty@CDib@@QAEXXZ				; CDib::Empty
PUBLIC	?Serialize@CDib@@MAEXAAVCArchive@@@Z		; CDib::Serialize
PUBLIC	??_7CDib@@6B@					; CDib::`vftable'
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_GCDib@@MAEPAXI@Z				; CDib::`scalar deleting destructor'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
PUBLIC	??0CObject@@IAE@XZ				; CObject::CObject
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	??_R4CDib@@6B@					; CDib::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDib@@@8				; CDib `RTTI Type Descriptor'
PUBLIC	??_R3CDib@@8					; CDib::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDib@@8					; CDib::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CDib@@8				; CDib::`RTTI Base Class Descriptor at (0,-1,0,0)'
EXTRN	??_ECDib@@MAEPAXI@Z:NEAR			; CDib::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
xdata$x	SEGMENT
$T203731 DD	0ffffffffH
	DD	FLAT:$L203727
$T203729 DD	019930520H
	DD	01H
	DD	FLAT:$T203731
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CDib@@6B@
CONST	SEGMENT
??_7CDib@@6B@ DD FLAT:??_R4CDib@@6B@			; CDib::`vftable'
	DD	FLAT:?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECDib@@MAEPAXI@Z
	DD	FLAT:?Serialize@CDib@@MAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CDib@@6B@
rdata$r	SEGMENT
??_R4CDib@@6B@ DD 00H					; CDib::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDib@@@8
	DD	FLAT:??_R3CDib@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDib@@@8
_DATA	SEGMENT
??_R0?AVCDib@@@8 DD FLAT:??_7type_info@@6B@		; CDib `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDib@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CDib@@8
rdata$r	SEGMENT
??_R3CDib@@8 DD	00H					; CDib::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CDib@@8
rdata$r	ENDS
;	COMDAT ??_R2CDib@@8
rdata$r	SEGMENT
??_R2CDib@@8 DD	FLAT:??_R1A@?0A@A@CDib@@8		; CDib::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDib@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CDib@@8 DD FLAT:??_R0?AVCDib@@@8		; CDib::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CDib@@IAE@XZ PROC NEAR				; CDib::CDib
; _this$ = ecx

; 18   : {

  000b0	55		 push	 ebp
  000b1	8b ec		 mov	 ebp, esp
  000b3	6a ff		 push	 -1
  000b5	68 00 00 00 00	 push	 __ehhandler$??0CDib@@IAE@XZ
  000ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  000c0	50		 push	 eax
  000c1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  000c8	51		 push	 ecx
  000c9	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  000cc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	e8 00 00 00 00	 call	 ??0CObject@@IAE@XZ	; CObject::CObject
  000d4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000db	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000de	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDib@@6B@

; 19   : 	m_hFile = NULL;

  000e4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 20   : 	m_hBitmap = NULL;

  000ee	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000f1	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 21   : 	m_hPalette = NULL;

  000f8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000fb	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 22   : 	m_nBmihAlloc = m_nImageAlloc = noAlloc;

  00102	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  0010c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0010f	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 23   : 	m_lpvFile = NULL;

  00116	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00119	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 24   : 	Empty();

  00120	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 25   : }

  00128	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0012f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00132	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00135	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L203727:
  00014	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e9 00 00 00 00	 jmp	 ??1CObject@@UAE@XZ	; CObject::~CObject
__ehhandler$??0CDib@@IAE@XZ:
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203729
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CDib@@IAE@XZ ENDP					; CDib::CDib
PUBLIC	??1CDib@@MAE@XZ					; CDib::~CDib
; Function compile flags: /Odt
;	COMDAT ??_GCDib@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCDib@@MAEPAXI@Z PROC NEAR				; CDib::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDib@@MAE@XZ		; CDib::~CDib
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L202685
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L202685:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCDib@@MAEPAXI@Z ENDP				; CDib::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CDib@@IAE@VCSize@@H@Z			; CDib::CDib
PUBLIC	?ComputePaletteSize@CDib@@AAEXH@Z		; CDib::ComputePaletteSize
PUBLIC	?ComputeMetrics@CDib@@AAEXXZ			; CDib::ComputeMetrics
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	_memset:NEAR
xdata$x	SEGMENT
$T203740 DD	0ffffffffH
	DD	FLAT:$L203736
$T203738 DD	019930520H
	DD	01H
	DD	FLAT:$T203740
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T203735 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_size$ = 8						; size = 8
_nBitCount$ = 16					; size = 4
??0CDib@@IAE@VCSize@@H@Z PROC NEAR			; CDib::CDib
; _this$ = ecx

; 28   : {

  00140	55		 push	 ebp
  00141	8b ec		 mov	 ebp, esp
  00143	6a ff		 push	 -1
  00145	68 00 00 00 00	 push	 __ehhandler$??0CDib@@IAE@VCSize@@H@Z
  0014a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00150	50		 push	 eax
  00151	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00158	83 ec 08	 sub	 esp, 8
  0015b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0015e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	e8 00 00 00 00	 call	 ??0CObject@@IAE@XZ	; CObject::CObject
  00166	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0016d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00170	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDib@@6B@

; 29   : 	m_hFile = NULL;

  00176	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00179	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 30   : 	m_hBitmap = NULL;

  00180	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00183	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 31   : 	m_hPalette = NULL;

  0018a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0018d	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 32   : 	m_nBmihAlloc = m_nImageAlloc = noAlloc;

  00194	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  0019e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001a1	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 33   : 	Empty();

  001a8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 34   : 	ComputePaletteSize(nBitCount);

  001b0	8b 45 10	 mov	 eax, DWORD PTR _nBitCount$[ebp]
  001b3	50		 push	 eax
  001b4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 35   : 	m_lpBMIH = (LPBITMAPINFOHEADER) new 
; 36   : 		char[sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * m_nColorTableEntries];

  001bc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001bf	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  001c2	8d 04 95 28 00
	00 00		 lea	 eax, DWORD PTR [edx*4+40]
  001c9	50		 push	 eax
  001ca	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  001cf	83 c4 04	 add	 esp, 4
  001d2	89 45 f0	 mov	 DWORD PTR $T203735[ebp], eax
  001d5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d8	8b 55 f0	 mov	 edx, DWORD PTR $T203735[ebp]
  001db	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 37   : 	m_nBmihAlloc = crtAlloc;

  001de	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001e1	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 38   : 	m_lpBMIH->biSize = sizeof(BITMAPINFOHEADER);

  001e8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001eb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001ee	c7 02 28 00 00
	00		 mov	 DWORD PTR [edx], 40	; 00000028H

; 39   : 	m_lpBMIH->biWidth = size.cx;

  001f4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001f7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001fa	8b 55 08	 mov	 edx, DWORD PTR _size$[ebp]
  001fd	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 40   : 	m_lpBMIH->biHeight = size.cy;

  00200	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00203	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00206	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp+4]
  00209	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 41   : 	m_lpBMIH->biPlanes = 1;

  0020c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0020f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00212	66 c7 41 0c 01
	00		 mov	 WORD PTR [ecx+12], 1

; 42   : 	m_lpBMIH->biBitCount = nBitCount;

  00218	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0021b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0021e	66 8b 4d 10	 mov	 cx, WORD PTR _nBitCount$[ebp]
  00222	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 43   : 	m_lpBMIH->biCompression = BI_RGB;

  00226	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00229	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0022c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 44   : 	m_lpBMIH->biSizeImage = 0;

  00233	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00236	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00239	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 45   : 	m_lpBMIH->biXPelsPerMeter = 0;

  00240	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00243	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00246	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 46   : 	m_lpBMIH->biYPelsPerMeter = 0;

  0024d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00250	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00253	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 47   : 	m_lpBMIH->biClrUsed = m_nColorTableEntries;

  0025a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0025d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00260	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00263	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00266	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 48   : 	m_lpBMIH->biClrImportant = m_nColorTableEntries;

  00269	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0026c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0026f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00272	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00275	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 49   : 	ComputeMetrics();

  00278	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0027b	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 50   : 	memset(m_lpvColorTable, 0, sizeof(RGBQUAD) * m_nColorTableEntries);

  00280	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00283	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00286	c1 e1 02	 shl	 ecx, 2
  00289	51		 push	 ecx
  0028a	6a 00		 push	 0
  0028c	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0028f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00292	50		 push	 eax
  00293	e8 00 00 00 00	 call	 _memset
  00298	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 	m_lpImage = NULL;  // no data yet

  0029b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0029e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 52   : }

  002a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002ac	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002b9	8b e5		 mov	 esp, ebp
  002bb	5d		 pop	 ebp
  002bc	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L203736:
  00026	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1CObject@@UAE@XZ	; CObject::~CObject
__ehhandler$??0CDib@@IAE@VCSize@@H@Z:
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203738
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CDib@@IAE@VCSize@@H@Z ENDP				; CDib::CDib
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
xdata$x	SEGMENT
$T203747 DD	0ffffffffH
	DD	FLAT:$L203743
$T203745 DD	019930520H
	DD	01H
	DD	FLAT:$T203747
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T203742 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CDib@@MAE@XZ PROC NEAR				; CDib::~CDib
; _this$ = ecx

; 55   : {

  002c0	55		 push	 ebp
  002c1	8b ec		 mov	 ebp, esp
  002c3	6a ff		 push	 -1
  002c5	68 00 00 00 00	 push	 __ehhandler$??1CDib@@MAE@XZ
  002ca	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  002d0	50		 push	 eax
  002d1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  002d8	83 ec 08	 sub	 esp, 8
  002db	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  002de	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002e1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDib@@6B@
  002e7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 56   : 	delete m_lpvFile ;

  002ee	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002f1	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  002f4	89 55 f0	 mov	 DWORD PTR $T203742[ebp], edx
  002f7	8b 45 f0	 mov	 eax, DWORD PTR $T203742[ebp]
  002fa	50		 push	 eax
  002fb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00300	83 c4 04	 add	 esp, 4

; 57   : 	g_count --;

  00303	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_count
  00309	83 e9 01	 sub	 ecx, 1
  0030c	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_count, ecx

; 58   : 	//TRACE("m_lpvFile Destroy: %d\n", g_count);
; 59   : 	m_lpvFile = NULL;

  00312	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00315	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 60   : 
; 61   : 	Empty();

  0031c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0031f	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 62   : }

  00324	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0032b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0032e	e8 00 00 00 00	 call	 ??1CObject@@UAE@XZ	; CObject::~CObject
  00333	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00336	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0033d	8b e5		 mov	 esp, ebp
  0033f	5d		 pop	 ebp
  00340	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L203743:
  00038	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1CObject@@UAE@XZ	; CObject::~CObject
__ehhandler$??1CDib@@MAE@XZ:
  00040	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203745
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CDib@@MAE@XZ ENDP					; CDib::~CDib
PUBLIC	??0CSize@@QAE@HH@Z				; CSize::CSize
PUBLIC	?GetDimensions@CDib@@QAE?AVCSize@@XZ		; CDib::GetDimensions
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetDimensions@CDib@@QAE?AVCSize@@XZ PROC NEAR		; CDib::GetDimensions
; _this$ = ecx

; 65   : {	

  00350	55		 push	 ebp
  00351	8b ec		 mov	 ebp, esp
  00353	51		 push	 ecx
  00354	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   : 	if(m_lpBMIH == NULL) return CSize(0, 0);

  00357	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0035a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0035e	75 11		 jne	 SHORT $L202706
  00360	6a 00		 push	 0
  00362	6a 00		 push	 0
  00364	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00367	e8 00 00 00 00	 call	 ??0CSize@@QAE@HH@Z	; CSize::CSize
  0036c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0036f	eb 1f		 jmp	 SHORT $L202705
$L202706:

; 67   : 	return CSize((int) m_lpBMIH->biWidth, (int) m_lpBMIH->biHeight);

  00371	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00374	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00377	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0037a	50		 push	 eax
  0037b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0037e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00381	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00384	50		 push	 eax
  00385	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00388	e8 00 00 00 00	 call	 ??0CSize@@QAE@HH@Z	; CSize::CSize
  0038d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L202705:

; 68   : }

  00390	8b e5		 mov	 esp, ebp
  00392	5d		 pop	 ebp
  00393	c2 04 00	 ret	 4
?GetDimensions@CDib@@QAE?AVCSize@@XZ ENDP		; CDib::GetDimensions
_TEXT	ENDS
PUBLIC	??0CRect@@QAE@XZ				; CRect::CRect
PUBLIC	?Width@CRect@@QBEHXZ				; CRect::Width
PUBLIC	?Height@CRect@@QBEHXZ				; CRect::Height
PUBLIC	?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z ; CDib::CcutBitmap
PUBLIC	?SeekToBegin@CFile@@QAEXXZ			; CFile::SeekToBegin
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	__imp__GlobalAlloc@8:NEAR
EXTRN	__imp__GlobalLock@4:NEAR
EXTRN	__imp__GlobalUnlock@4:NEAR
EXTRN	__imp__GlobalFree@4:NEAR
EXTRN	??0CMemFile@@QAE@I@Z:NEAR			; CMemFile::CMemFile
EXTRN	_memcpy:NEAR
xdata$x	SEGMENT
$T203770 DD	0ffffffffH
	DD	FLAT:$L203762
$T203764 DD	019930520H
	DD	01H
	DD	FLAT:$T203770
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv159 = -104						; size = 4
tv138 = -100						; size = 4
tv82 = -96						; size = 4
tv74 = -92						; size = 4
_this$ = -88						; size = 4
$T203761 = -84						; size = 4
$T203754 = -80						; size = 4
$T203751 = -76						; size = 4
$T203750 = -72						; size = 4
_y$202745 = -68						; size = 4
_lpbmpInfo$ = -64					; size = 4
_nHeight$ = -60						; size = 4
_ret$ = -56						; size = 4
_addBitS$ = -52						; size = 4
_nWidth$ = -48						; size = 4
_len$ = -44						; size = 4
_hTmpBuf$ = -40						; size = 4
_nLineBytes$ = -36					; size = 4
_pFile$ = -32						; size = 4
_rect$ = -28						; size = 4
_lpPic$ = -24						; size = 4
_addBitB$ = -20						; size = 4
_lpFhdr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lpImage$ = 8						; size = 4
_pCutRect$ = 12						; size = 4
_ppFile$ = 16						; size = 4
?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z PROC NEAR ; CDib::CcutBitmap
; _this$ = ecx

; 70   : {

  003a0	55		 push	 ebp
  003a1	8b ec		 mov	 ebp, esp
  003a3	6a ff		 push	 -1
  003a5	68 00 00 00 00	 push	 __ehhandler$?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z
  003aa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  003b0	50		 push	 eax
  003b1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  003b8	83 ec 5c	 sub	 esp, 92			; 0000005cH
  003bb	56		 push	 esi
  003bc	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx

; 71   : 	if( pCutRect == NULL ) return FALSE;

  003bf	83 7d 0c 00	 cmp	 DWORD PTR _pCutRect$[ebp], 0
  003c3	75 07		 jne	 SHORT $L202717
  003c5	33 c0		 xor	 eax, eax
  003c7	e9 3f 03 00 00	 jmp	 $L202716
$L202717:

; 72   : 	if( lpImage == NULL ) return FALSE;

  003cc	83 7d 08 00	 cmp	 DWORD PTR _lpImage$[ebp], 0
  003d0	75 07		 jne	 SHORT $L202718
  003d2	33 c0		 xor	 eax, eax
  003d4	e9 32 03 00 00	 jmp	 $L202716
$L202718:

; 73   : 
; 74   : 	CMemFile * pFile ;
; 75   : 	* ppFile =   new CMemFile;

  003d9	6a 28		 push	 40			; 00000028H
  003db	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  003e0	89 45 b4	 mov	 DWORD PTR $T203751[ebp], eax
  003e3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  003ea	83 7d b4 00	 cmp	 DWORD PTR $T203751[ebp], 0
  003ee	74 12		 je	 SHORT $L203752
  003f0	68 00 04 00 00	 push	 1024			; 00000400H
  003f5	8b 4d b4	 mov	 ecx, DWORD PTR $T203751[ebp]
  003f8	e8 00 00 00 00	 call	 ??0CMemFile@@QAE@I@Z	; CMemFile::CMemFile
  003fd	89 45 a4	 mov	 DWORD PTR tv74[ebp], eax
  00400	eb 07		 jmp	 SHORT $L203753
$L203752:
  00402	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L203753:
  00409	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  0040c	89 45 b8	 mov	 DWORD PTR $T203750[ebp], eax
  0040f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00416	8b 4d 10	 mov	 ecx, DWORD PTR _ppFile$[ebp]
  00419	8b 55 b8	 mov	 edx, DWORD PTR $T203750[ebp]
  0041c	89 11		 mov	 DWORD PTR [ecx], edx

; 76   : 	pFile = *ppFile;

  0041e	8b 45 10	 mov	 eax, DWORD PTR _ppFile$[ebp]
  00421	8b 08		 mov	 ecx, DWORD PTR [eax]
  00423	89 4d e0	 mov	 DWORD PTR _pFile$[ebp], ecx

; 77   : 	BOOL ret=FALSE;

  00426	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 78   : 
; 79   : 	//分析位图信息,
; 80   : 	int len=sizeof(BITMAPFILEHEADER);

  0042d	c7 45 d4 0e 00
	00 00		 mov	 DWORD PTR _len$[ebp], 14 ; 0000000eH

; 81   : 	LPBITMAPFILEHEADER lpFhdr=(LPBITMAPFILEHEADER)lpImage;//文件头信息

  00434	8b 55 08	 mov	 edx, DWORD PTR _lpImage$[ebp]
  00437	89 55 f0	 mov	 DWORD PTR _lpFhdr$[ebp], edx

; 82   : 	LPBITMAPINFOHEADER lpbmpInfo = (LPBITMAPINFOHEADER)(lpImage+sizeof(BITMAPFILEHEADER));//位图头信息

  0043a	8b 45 08	 mov	 eax, DWORD PTR _lpImage$[ebp]
  0043d	83 c0 0e	 add	 eax, 14			; 0000000eH
  00440	89 45 c0	 mov	 DWORD PTR _lpbmpInfo$[ebp], eax

; 83   : 
; 84   : 
; 85   : 	int nLineBytes=0,nHeight=0,nWidth=0;

  00443	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _nLineBytes$[ebp], 0
  0044a	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _nHeight$[ebp], 0
  00451	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _nWidth$[ebp], 0

; 86   : 	nHeight = lpbmpInfo->biHeight;//源图像高

  00458	8b 4d c0	 mov	 ecx, DWORD PTR _lpbmpInfo$[ebp]
  0045b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0045e	89 55 c4	 mov	 DWORD PTR _nHeight$[ebp], edx

; 87   : 	nWidth = lpbmpInfo->biWidth; //源图像宽

  00461	8b 45 c0	 mov	 eax, DWORD PTR _lpbmpInfo$[ebp]
  00464	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00467	89 4d d0	 mov	 DWORD PTR _nWidth$[ebp], ecx

; 88   : 	
; 89   : 	CRect* rect = new CRect;

  0046a	6a 10		 push	 16			; 00000010H
  0046c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00471	83 c4 04	 add	 esp, 4
  00474	89 45 b0	 mov	 DWORD PTR $T203754[ebp], eax
  00477	83 7d b0 00	 cmp	 DWORD PTR $T203754[ebp], 0
  0047b	74 0d		 je	 SHORT $L203755
  0047d	8b 4d b0	 mov	 ecx, DWORD PTR $T203754[ebp]
  00480	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect
  00485	89 45 a0	 mov	 DWORD PTR tv82[ebp], eax
  00488	eb 07		 jmp	 SHORT $L203756
$L203755:
  0048a	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$L203756:
  00491	8b 55 a0	 mov	 edx, DWORD PTR tv82[ebp]
  00494	89 55 e4	 mov	 DWORD PTR _rect$[ebp], edx

; 90   : 	
; 91   : 	if( pCutRect->rect)

  00497	8b 45 0c	 mov	 eax, DWORD PTR _pCutRect$[ebp]
  0049a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0049d	74 0a		 je	 SHORT $L202738

; 92   : 	{
; 93   : 		rect = pCutRect->rect;

  0049f	8b 4d 0c	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  004a2	8b 11		 mov	 edx, DWORD PTR [ecx]
  004a4	89 55 e4	 mov	 DWORD PTR _rect$[ebp], edx

; 94   : 	}
; 95   : 	else

  004a7	eb 45		 jmp	 SHORT $L202739
$L202738:

; 96   : 	{
; 97   : 		rect->left =  pCutRect->index * nWidth/pCutRect->count;

  004a9	8b 45 0c	 mov	 eax, DWORD PTR _pCutRect$[ebp]
  004ac	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  004af	0f af 45 d0	 imul	 eax, DWORD PTR _nWidth$[ebp]
  004b3	8b 4d 0c	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  004b6	33 d2		 xor	 edx, edx
  004b8	f7 71 04	 div	 DWORD PTR [ecx+4]
  004bb	8b 55 e4	 mov	 edx, DWORD PTR _rect$[ebp]
  004be	89 02		 mov	 DWORD PTR [edx], eax

; 98   : 		rect->right =  (pCutRect->index+1) * nWidth/pCutRect->count;

  004c0	8b 45 0c	 mov	 eax, DWORD PTR _pCutRect$[ebp]
  004c3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  004c6	83 c0 01	 add	 eax, 1
  004c9	0f af 45 d0	 imul	 eax, DWORD PTR _nWidth$[ebp]
  004cd	8b 4d 0c	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  004d0	33 d2		 xor	 edx, edx
  004d2	f7 71 04	 div	 DWORD PTR [ecx+4]
  004d5	8b 55 e4	 mov	 edx, DWORD PTR _rect$[ebp]
  004d8	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 99   : 		rect->top = 0;

  004db	8b 45 e4	 mov	 eax, DWORD PTR _rect$[ebp]
  004de	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 100  : 		rect->bottom = nHeight;

  004e5	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  004e8	8b 55 c4	 mov	 edx, DWORD PTR _nHeight$[ebp]
  004eb	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L202739:

; 101  : 	}
; 102  : 
; 103  : 
; 104  : 	
; 105  : 	int addBitS = rect->Width()*3%4 ==0? 0:4-rect->Width()*3%4;

  004ee	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  004f1	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  004f6	6b c0 03	 imul	 eax, 3
  004f9	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  004fe	79 05		 jns	 SHORT $L203766
  00500	48		 dec	 eax
  00501	83 c8 fc	 or	 eax, -4			; fffffffcH
  00504	40		 inc	 eax
$L203766:
  00505	85 c0		 test	 eax, eax
  00507	75 09		 jne	 SHORT $L203757
  00509	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv138[ebp], 0
  00510	eb 21		 jmp	 SHORT $L203758
$L203757:
  00512	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  00515	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  0051a	6b c0 03	 imul	 eax, 3
  0051d	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00522	79 05		 jns	 SHORT $L203767
  00524	48		 dec	 eax
  00525	83 c8 fc	 or	 eax, -4			; fffffffcH
  00528	40		 inc	 eax
$L203767:
  00529	b9 04 00 00 00	 mov	 ecx, 4
  0052e	2b c8		 sub	 ecx, eax
  00530	89 4d 9c	 mov	 DWORD PTR tv138[ebp], ecx
$L203758:
  00533	8b 55 9c	 mov	 edx, DWORD PTR tv138[ebp]
  00536	89 55 cc	 mov	 DWORD PTR _addBitS$[ebp], edx

; 106  : 	HGLOBAL hTmpBuf = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,(rect->Width()+addBitS)*rect->Height()*3);

  00539	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  0053c	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00541	8b f0		 mov	 esi, eax
  00543	03 75 cc	 add	 esi, DWORD PTR _addBitS$[ebp]
  00546	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  00549	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0054e	0f af f0	 imul	 esi, eax
  00551	6b f6 03	 imul	 esi, 3
  00554	56		 push	 esi
  00555	6a 42		 push	 66			; 00000042H
  00557	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  0055d	89 45 d8	 mov	 DWORD PTR _hTmpBuf$[ebp], eax

; 107  : 	LPSTR lpPic = (LPSTR)GlobalLock(hTmpBuf);

  00560	8b 45 d8	 mov	 eax, DWORD PTR _hTmpBuf$[ebp]
  00563	50		 push	 eax
  00564	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  0056a	89 45 e8	 mov	 DWORD PTR _lpPic$[ebp], eax

; 108  : 
; 109  : 	
; 110  : 	int addBitB = lpbmpInfo->biWidth * 3%4 == 0 ? 0 : 4-lpbmpInfo->biWidth * 3%4;

  0056d	8b 4d c0	 mov	 ecx, DWORD PTR _lpbmpInfo$[ebp]
  00570	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00573	6b d2 03	 imul	 edx, 3
  00576	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  0057c	79 05		 jns	 SHORT $L203768
  0057e	4a		 dec	 edx
  0057f	83 ca fc	 or	 edx, -4			; fffffffcH
  00582	42		 inc	 edx
$L203768:
  00583	85 d2		 test	 edx, edx
  00585	75 09		 jne	 SHORT $L203759
  00587	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv159[ebp], 0
  0058e	eb 20		 jmp	 SHORT $L203760
$L203759:
  00590	8b 45 c0	 mov	 eax, DWORD PTR _lpbmpInfo$[ebp]
  00593	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00596	6b c9 03	 imul	 ecx, 3
  00599	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0059f	79 05		 jns	 SHORT $L203769
  005a1	49		 dec	 ecx
  005a2	83 c9 fc	 or	 ecx, -4			; fffffffcH
  005a5	41		 inc	 ecx
$L203769:
  005a6	ba 04 00 00 00	 mov	 edx, 4
  005ab	2b d1		 sub	 edx, ecx
  005ad	89 55 98	 mov	 DWORD PTR tv159[ebp], edx
$L203760:
  005b0	8b 45 98	 mov	 eax, DWORD PTR tv159[ebp]
  005b3	89 45 ec	 mov	 DWORD PTR _addBitB$[ebp], eax

; 111  : 
; 112  : 	// 拷贝原始图像到新分配的图像存储区
; 113  : 	for(int y=rect->top;y< rect->bottom; y++)

  005b6	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  005b9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  005bc	89 55 bc	 mov	 DWORD PTR _y$202745[ebp], edx
  005bf	eb 09		 jmp	 SHORT $L202746
$L202747:
  005c1	8b 45 bc	 mov	 eax, DWORD PTR _y$202745[ebp]
  005c4	83 c0 01	 add	 eax, 1
  005c7	89 45 bc	 mov	 DWORD PTR _y$202745[ebp], eax
$L202746:
  005ca	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  005cd	8b 55 bc	 mov	 edx, DWORD PTR _y$202745[ebp]
  005d0	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  005d3	7d 75		 jge	 SHORT $L202748

; 114  : 	{
; 115  : 		
; 116  : 		memcpy(lpPic,lpImage+lpFhdr->bfOffBits+y* (lpbmpInfo->biWidth * 3+addBitB)+rect->left*3, rect->Width()*3 );

  005d5	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  005d8	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  005dd	6b c0 03	 imul	 eax, 3
  005e0	50		 push	 eax
  005e1	8b 45 f0	 mov	 eax, DWORD PTR _lpFhdr$[ebp]
  005e4	8b 4d 08	 mov	 ecx, DWORD PTR _lpImage$[ebp]
  005e7	03 48 0a	 add	 ecx, DWORD PTR [eax+10]
  005ea	8b 55 c0	 mov	 edx, DWORD PTR _lpbmpInfo$[ebp]
  005ed	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  005f0	6b c0 03	 imul	 eax, 3
  005f3	03 45 ec	 add	 eax, DWORD PTR _addBitB$[ebp]
  005f6	0f af 45 bc	 imul	 eax, DWORD PTR _y$202745[ebp]
  005fa	03 c8		 add	 ecx, eax
  005fc	8b 55 e4	 mov	 edx, DWORD PTR _rect$[ebp]
  005ff	8b 02		 mov	 eax, DWORD PTR [edx]
  00601	6b c0 03	 imul	 eax, 3
  00604	03 c8		 add	 ecx, eax
  00606	51		 push	 ecx
  00607	8b 4d e8	 mov	 ecx, DWORD PTR _lpPic$[ebp]
  0060a	51		 push	 ecx
  0060b	e8 00 00 00 00	 call	 _memcpy
  00610	83 c4 0c	 add	 esp, 12			; 0000000cH

; 117  : 		lpPic+= rect->Width()*3;

  00613	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  00616	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  0061b	6b c0 03	 imul	 eax, 3
  0061e	03 45 e8	 add	 eax, DWORD PTR _lpPic$[ebp]
  00621	89 45 e8	 mov	 DWORD PTR _lpPic$[ebp], eax

; 118  : 		if(addBitS != 0 )

  00624	83 7d cc 00	 cmp	 DWORD PTR _addBitS$[ebp], 0
  00628	74 1b		 je	 SHORT $L202749

; 119  : 		{
; 120  : 			ZeroMemory(lpPic,addBitS);

  0062a	8b 55 cc	 mov	 edx, DWORD PTR _addBitS$[ebp]
  0062d	52		 push	 edx
  0062e	6a 00		 push	 0
  00630	8b 45 e8	 mov	 eax, DWORD PTR _lpPic$[ebp]
  00633	50		 push	 eax
  00634	e8 00 00 00 00	 call	 _memset
  00639	83 c4 0c	 add	 esp, 12			; 0000000cH

; 121  : 			lpPic+= addBitS;

  0063c	8b 4d e8	 mov	 ecx, DWORD PTR _lpPic$[ebp]
  0063f	03 4d cc	 add	 ecx, DWORD PTR _addBitS$[ebp]
  00642	89 4d e8	 mov	 DWORD PTR _lpPic$[ebp], ecx
$L202749:

; 122  : 		}
; 123  : 	}

  00645	e9 77 ff ff ff	 jmp	 $L202747
$L202748:

; 124  : 
; 125  : 	//将指针移回开始位置
; 126  : 	lpPic=lpPic-(rect->Width()*3+addBitS)*rect->Height();

  0064a	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  0064d	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00652	8b f0		 mov	 esi, eax
  00654	6b f6 03	 imul	 esi, 3
  00657	03 75 cc	 add	 esi, DWORD PTR _addBitS$[ebp]
  0065a	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  0065d	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00662	0f af f0	 imul	 esi, eax
  00665	8b 55 e8	 mov	 edx, DWORD PTR _lpPic$[ebp]
  00668	2b d6		 sub	 edx, esi
  0066a	89 55 e8	 mov	 DWORD PTR _lpPic$[ebp], edx

; 127  : 
; 128  : 	//存储位图
; 129  : 	//除了高度，宽度，不改变原始图像的其它信息
; 130  : 	lpbmpInfo->biWidth=rect->Width();

  0066d	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  00670	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00675	8b 4d c0	 mov	 ecx, DWORD PTR _lpbmpInfo$[ebp]
  00678	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 131  : 	lpbmpInfo->biHeight=rect->Height();

  0067b	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  0067e	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00683	8b 55 c0	 mov	 edx, DWORD PTR _lpbmpInfo$[ebp]
  00686	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 132  : 
; 133  : 	pFile->Write(lpFhdr,len);//写文件头

  00689	8b 45 d4	 mov	 eax, DWORD PTR _len$[ebp]
  0068c	50		 push	 eax
  0068d	8b 4d f0	 mov	 ecx, DWORD PTR _lpFhdr$[ebp]
  00690	51		 push	 ecx
  00691	8b 55 e0	 mov	 edx, DWORD PTR _pFile$[ebp]
  00694	8b 02		 mov	 eax, DWORD PTR [edx]
  00696	8b 4d e0	 mov	 ecx, DWORD PTR _pFile$[ebp]
  00699	ff 50 40	 call	 DWORD PTR [eax+64]

; 134  : 	pFile->Write( lpbmpInfo,sizeof(BITMAPINFOHEADER));//写位图信息

  0069c	6a 28		 push	 40			; 00000028H
  0069e	8b 4d c0	 mov	 ecx, DWORD PTR _lpbmpInfo$[ebp]
  006a1	51		 push	 ecx
  006a2	8b 55 e0	 mov	 edx, DWORD PTR _pFile$[ebp]
  006a5	8b 02		 mov	 eax, DWORD PTR [edx]
  006a7	8b 4d e0	 mov	 ecx, DWORD PTR _pFile$[ebp]
  006aa	ff 50 40	 call	 DWORD PTR [eax+64]

; 135  : 	pFile->Write( lpPic,(rect->Width()*3+addBitS)*rect->Height() );//写拷贝过来的图像像素

  006ad	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  006b0	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  006b5	8b f0		 mov	 esi, eax
  006b7	6b f6 03	 imul	 esi, 3
  006ba	03 75 cc	 add	 esi, DWORD PTR _addBitS$[ebp]
  006bd	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp]
  006c0	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  006c5	0f af f0	 imul	 esi, eax
  006c8	56		 push	 esi
  006c9	8b 4d e8	 mov	 ecx, DWORD PTR _lpPic$[ebp]
  006cc	51		 push	 ecx
  006cd	8b 55 e0	 mov	 edx, DWORD PTR _pFile$[ebp]
  006d0	8b 02		 mov	 eax, DWORD PTR [edx]
  006d2	8b 4d e0	 mov	 ecx, DWORD PTR _pFile$[ebp]
  006d5	ff 50 40	 call	 DWORD PTR [eax+64]

; 136  : 	
; 137  : 	pFile->SeekToBegin();

  006d8	8b 4d e0	 mov	 ecx, DWORD PTR _pFile$[ebp]
  006db	e8 00 00 00 00	 call	 ?SeekToBegin@CFile@@QAEXXZ ; CFile::SeekToBegin

; 138  : 
; 139  : 	GlobalUnlock (hTmpBuf);//释放

  006e0	8b 4d d8	 mov	 ecx, DWORD PTR _hTmpBuf$[ebp]
  006e3	51		 push	 ecx
  006e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 140  : 	GlobalFree (hTmpBuf);

  006ea	8b 55 d8	 mov	 edx, DWORD PTR _hTmpBuf$[ebp]
  006ed	52		 push	 edx
  006ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 141  : 
; 142  : 
; 143  : 	delete rect;

  006f4	8b 45 e4	 mov	 eax, DWORD PTR _rect$[ebp]
  006f7	89 45 ac	 mov	 DWORD PTR $T203761[ebp], eax
  006fa	8b 4d ac	 mov	 ecx, DWORD PTR $T203761[ebp]
  006fd	51		 push	 ecx
  006fe	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00703	83 c4 04	 add	 esp, 4

; 144  : 	return TRUE;

  00706	b8 01 00 00 00	 mov	 eax, 1
$L202716:

; 145  : }

  0070b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0070e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00715	5e		 pop	 esi
  00716	8b e5		 mov	 esp, ebp
  00718	5d		 pop	 ebp
  00719	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L203762:
  0004a	8b 45 b4	 mov	 eax, DWORD PTR $T203751[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00053	c3		 ret	 0
__ehhandler$?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z:
  00054	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203764
  00059	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z ENDP ; CDib::CcutBitmap
PUBLIC	?AttachMemory@CDib@@QAEHPAXH0@Z			; CDib::AttachMemory
PUBLIC	?AttachMapFile2@CDib@@IAEHPAXIPAUCutRect@1@H@Z	; CDib::AttachMapFile2
PUBLIC	?DetachMapFile@CDib@@AAEXXZ			; CDib::DetachMapFile
EXTRN	?AfxMessageBox@@YGHPBDII@Z:NEAR			; AfxMessageBox
; Function compile flags: /Odt
_TEXT	SEGMENT
tv143 = -48						; size = 4
_this$ = -44						; size = 4
$T203775 = -40						; size = 4
$T203774 = -36						; size = 4
$T203773 = -32						; size = 4
$T203772 = -28						; size = 4
_nLenght$202770 = -24					; size = 4
_hImageBuf$ = -20					; size = 4
_retLen$ = -16						; size = 4
_nLenght$ = -12						; size = 4
_lpImage$ = -8						; size = 4
_memFile$ = -4						; size = 4
_pVoid$ = 8						; size = 4
_size$ = 12						; size = 4
_pCutRect$ = 16						; size = 4
_bShare$ = 20						; size = 4
?AttachMapFile2@CDib@@IAEHPAXIPAUCutRect@1@H@Z PROC NEAR ; CDib::AttachMapFile2
; _this$ = ecx

; 147  : {

  00720	55		 push	 ebp
  00721	8b ec		 mov	 ebp, esp
  00723	83 ec 30	 sub	 esp, 48			; 00000030H
  00726	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 148  : 	if(size<=0) return FALSE;

  00729	83 7d 0c 00	 cmp	 DWORD PTR _size$[ebp], 0
  0072d	77 07		 ja	 SHORT $L202759
  0072f	33 c0		 xor	 eax, eax
  00731	e9 83 01 00 00	 jmp	 $L202758
$L202759:

; 149  : 
; 150  : 	HGLOBAL hImageBuf = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,size);

  00736	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00739	50		 push	 eax
  0073a	6a 42		 push	 66			; 00000042H
  0073c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00742	89 45 ec	 mov	 DWORD PTR _hImageBuf$[ebp], eax

; 151  : 	if(!hImageBuf)

  00745	83 7d ec 00	 cmp	 DWORD PTR _hImageBuf$[ebp], 0
  00749	75 07		 jne	 SHORT $L202761

; 152  : 	{
; 153  : 		//分配失败则返回
; 154  : 		return FALSE;

  0074b	33 c0		 xor	 eax, eax
  0074d	e9 67 01 00 00	 jmp	 $L202758
$L202761:

; 155  : 	}
; 156  : 
; 157  : 	LPSTR lpImage = (LPSTR)GlobalLock(hImageBuf);

  00752	8b 4d ec	 mov	 ecx, DWORD PTR _hImageBuf$[ebp]
  00755	51		 push	 ecx
  00756	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  0075c	89 45 f8	 mov	 DWORD PTR _lpImage$[ebp], eax

; 158  : 
; 159  : 	//将图像读入内存
; 160  : 	DWORD retLen=0;

  0075f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _retLen$[ebp], 0

; 161  : //	retLen=f.Read(lpImage,dwBitsSize);
; 162  : 	memcpy(lpImage, pVoid, size );

  00766	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  00769	52		 push	 edx
  0076a	8b 45 08	 mov	 eax, DWORD PTR _pVoid$[ebp]
  0076d	50		 push	 eax
  0076e	8b 4d f8	 mov	 ecx, DWORD PTR _lpImage$[ebp]
  00771	51		 push	 ecx
  00772	e8 00 00 00 00	 call	 _memcpy
  00777	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  : 	
; 164  : 
; 165  : 	CMemFile* memFile = NULL;

  0077a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _memFile$[ebp], 0

; 166  : 	CcutBitmap(lpImage,pCutRect,&memFile);

  00781	8d 55 fc	 lea	 edx, DWORD PTR _memFile$[ebp]
  00784	52		 push	 edx
  00785	8b 45 10	 mov	 eax, DWORD PTR _pCutRect$[ebp]
  00788	50		 push	 eax
  00789	8b 4d f8	 mov	 ecx, DWORD PTR _lpImage$[ebp]
  0078c	51		 push	 ecx
  0078d	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00790	e8 00 00 00 00	 call	 ?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z ; CDib::CcutBitmap

; 167  : 
; 168  : 
; 169  : 	GlobalUnlock (hImageBuf);//释放

  00795	8b 55 ec	 mov	 edx, DWORD PTR _hImageBuf$[ebp]
  00798	52		 push	 edx
  00799	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 170  : 	GlobalFree (hImageBuf);

  0079f	8b 45 ec	 mov	 eax, DWORD PTR _hImageBuf$[ebp]
  007a2	50		 push	 eax
  007a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 171  : 
; 172  : 	if(m_lpvFile != NULL)

  007a9	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  007ac	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  007b0	74 2e		 je	 SHORT $L202766

; 173  : 	{
; 174  : 		delete m_lpvFile;

  007b2	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  007b5	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  007b8	89 45 e4	 mov	 DWORD PTR $T203772[ebp], eax
  007bb	8b 4d e4	 mov	 ecx, DWORD PTR $T203772[ebp]
  007be	51		 push	 ecx
  007bf	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007c4	83 c4 04	 add	 esp, 4

; 175  : 		g_count --;

  007c7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_count
  007cd	83 ea 01	 sub	 edx, 1
  007d0	89 15 00 00 00
	00		 mov	 DWORD PTR _g_count, edx

; 176  : 		//	TRACE("m_lpvFile Destroy: %d\n", g_count);
; 177  : 		m_lpvFile = NULL;

  007d6	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  007d9	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
$L202766:

; 178  : 	}
; 179  : 
; 180  : 	UINT nLenght = 0;

  007e0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nLenght$[ebp], 0

; 181  : 	if( memFile )

  007e7	83 7d fc 00	 cmp	 DWORD PTR _memFile$[ebp], 0
  007eb	0f 84 c6 00 00
	00		 je	 $L202769

; 182  : 	{
; 183  : 		UINT nLenght = memFile->GetLength();

  007f1	8b 4d fc	 mov	 ecx, DWORD PTR _memFile$[ebp]
  007f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  007f6	8b 4d fc	 mov	 ecx, DWORD PTR _memFile$[ebp]
  007f9	ff 52 38	 call	 DWORD PTR [edx+56]
  007fc	89 45 e8	 mov	 DWORD PTR _nLenght$202770[ebp], eax

; 184  : 	m_lpvFile = new unsigned char [nLenght];

  007ff	8b 45 e8	 mov	 eax, DWORD PTR _nLenght$202770[ebp]
  00802	50		 push	 eax
  00803	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00808	83 c4 04	 add	 esp, 4
  0080b	89 45 e0	 mov	 DWORD PTR $T203773[ebp], eax
  0080e	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00811	8b 55 e0	 mov	 edx, DWORD PTR $T203773[ebp]
  00814	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 185  : 	g_count ++;

  00817	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_count
  0081c	83 c0 01	 add	 eax, 1
  0081f	a3 00 00 00 00	 mov	 DWORD PTR _g_count, eax

; 186  : 
; 187  : 	memFile->Read(m_lpvFile, nLenght);

  00824	8b 4d e8	 mov	 ecx, DWORD PTR _nLenght$202770[ebp]
  00827	51		 push	 ecx
  00828	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0082b	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0082e	50		 push	 eax
  0082f	8b 4d fc	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00832	8b 11		 mov	 edx, DWORD PTR [ecx]
  00834	8b 4d fc	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00837	ff 52 3c	 call	 DWORD PTR [edx+60]

; 188  : 
; 189  : 	memFile->Close();

  0083a	8b 45 fc	 mov	 eax, DWORD PTR _memFile$[ebp]
  0083d	8b 10		 mov	 edx, DWORD PTR [eax]
  0083f	8b 4d fc	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00842	ff 52 54	 call	 DWORD PTR [edx+84]

; 190  : 
; 191  : 	delete memFile;

  00845	8b 45 fc	 mov	 eax, DWORD PTR _memFile$[ebp]
  00848	89 45 d8	 mov	 DWORD PTR $T203775[ebp], eax
  0084b	8b 4d d8	 mov	 ecx, DWORD PTR $T203775[ebp]
  0084e	89 4d dc	 mov	 DWORD PTR $T203774[ebp], ecx
  00851	83 7d dc 00	 cmp	 DWORD PTR $T203774[ebp], 0
  00855	74 12		 je	 SHORT $L203776
  00857	6a 01		 push	 1
  00859	8b 55 dc	 mov	 edx, DWORD PTR $T203774[ebp]
  0085c	8b 02		 mov	 eax, DWORD PTR [edx]
  0085e	8b 4d dc	 mov	 ecx, DWORD PTR $T203774[ebp]
  00861	ff 50 04	 call	 DWORD PTR [eax+4]
  00864	89 45 d0	 mov	 DWORD PTR tv143[ebp], eax
  00867	eb 07		 jmp	 SHORT $L203777
$L203776:
  00869	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv143[ebp], 0
$L203777:

; 192  : 
; 193  : 	if(((LPBITMAPFILEHEADER) m_lpvFile)->bfType != 0x4d42) {

  00870	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00873	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00876	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00879	3d 42 4d 00 00	 cmp	 eax, 19778		; 00004d42H
  0087e	74 1a		 je	 SHORT $L202776

; 194  : 		AfxMessageBox("Invalid bitmap file");

  00880	6a 00		 push	 0
  00882	6a 00		 push	 0
  00884	68 00 00 00 00	 push	 OFFSET FLAT:$SG202777
  00889	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 195  : 		DetachMapFile();

  0088e	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00891	e8 00 00 00 00	 call	 ?DetachMapFile@CDib@@AAEXXZ ; CDib::DetachMapFile

; 196  : 		return FALSE;

  00896	33 c0		 xor	 eax, eax
  00898	eb 1f		 jmp	 SHORT $L202758
$L202776:

; 197  : 	}
; 198  : 	AttachMemory((LPBYTE) m_lpvFile + sizeof(BITMAPFILEHEADER));

  0089a	6a 00		 push	 0
  0089c	6a 00		 push	 0
  0089e	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  008a1	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  008a4	83 c2 0e	 add	 edx, 14			; 0000000eH
  008a7	52		 push	 edx
  008a8	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  008ab	e8 00 00 00 00	 call	 ?AttachMemory@CDib@@QAEHPAXH0@Z ; CDib::AttachMemory

; 199  : 	//	m_lpvFile = lpvFile;
; 200  : 	//	m_hFile = hFile;
; 201  : 	//
; 202  : 	//*(m_lpImage+100) = 5;
; 203  : 	return TRUE;

  008b0	b8 01 00 00 00	 mov	 eax, 1
  008b5	eb 02		 jmp	 SHORT $L202758
$L202769:

; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		return FALSE;

  008b7	33 c0		 xor	 eax, eax
$L202758:

; 208  : 	}
; 209  : }

  008b9	8b e5		 mov	 esp, ebp
  008bb	5d		 pop	 ebp
  008bc	c2 10 00	 ret	 16			; 00000010H
?AttachMapFile2@CDib@@IAEHPAXIPAUCutRect@1@H@Z ENDP	; CDib::AttachMapFile2
_TEXT	ENDS
PUBLIC	?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z	; CDib::AttachMapFile2
EXTRN	__imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z:NEAR
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:NEAR
EXTRN	??0CFile@@QAE@XZ:NEAR				; CFile::CFile
EXTRN	?Open@CFile@@UAEHPBDIPAVCFileException@@@Z:NEAR	; CFile::Open
EXTRN	?GetLength@CFile@@UBE_KXZ:NEAR			; CFile::GetLength
EXTRN	?Read@CFile@@UAEIPAXI@Z:NEAR			; CFile::Read
EXTRN	?Close@CFile@@UAEXXZ:NEAR			; CFile::Close
EXTRN	??1CFile@@UAE@XZ:NEAR				; CFile::~CFile
xdata$x	SEGMENT
$T203796 DD	0ffffffffH
	DD	FLAT:$L203791
	DD	00H
	DD	FLAT:$L203792
$T203794 DD	019930520H
	DD	02H
	DD	FLAT:$T203796
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv168 = -108						; size = 4
_this$ = -104						; size = 4
$T203790 = -100						; size = 4
$T203789 = -96						; size = 4
$T203788 = -92						; size = 4
$T203785 = -88						; size = 4
$T203784 = -84						; size = 4
$T203783 = -80						; size = 4
$T203782 = -76						; size = 4
$T203781 = -72						; size = 4
$T203780 = -68						; size = 4
$T203779 = -64						; size = 4
_nLenght$202806 = -60					; size = 4
_dwBitsSize$ = -56					; size = 4
_hImageBuf$ = -52					; size = 4
_retLen$ = -48						; size = 4
_str$ = -44						; size = 4
_nLenght$ = -40						; size = 4
_f$ = -36						; size = 16
_lpImage$ = -20						; size = 4
_memFile$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_strPathname$ = 8					; size = 4
_pCutRect$ = 12						; size = 4
_bShare$ = 16						; size = 4
?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z PROC NEAR	; CDib::AttachMapFile2
; _this$ = ecx

; 211  : {

  008c0	55		 push	 ebp
  008c1	8b ec		 mov	 ebp, esp
  008c3	6a ff		 push	 -1
  008c5	68 00 00 00 00	 push	 __ehhandler$?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z
  008ca	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  008d0	50		 push	 eax
  008d1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  008d8	83 ec 60	 sub	 esp, 96			; 00000060H
  008db	89 4d 98	 mov	 DWORD PTR _this$[ebp], ecx

; 212  : 	CFile f ;

  008de	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  008e1	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile
  008e6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 213  : 
; 214  : 	if(!f.Open(strPathname, CFile::modeRead))

  008ed	6a 00		 push	 0
  008ef	6a 00		 push	 0
  008f1	8b 45 08	 mov	 eax, DWORD PTR _strPathname$[ebp]
  008f4	50		 push	 eax
  008f5	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  008f8	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  008fd	85 c0		 test	 eax, eax
  008ff	75 1e		 jne	 SHORT $L202788

; 215  : 		return false;

  00901	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T203779[ebp], 0
  00908	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0090f	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00912	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00917	8b 45 c0	 mov	 eax, DWORD PTR $T203779[ebp]
  0091a	e9 82 02 00 00	 jmp	 $L202786
$L202788:

; 216  : 
; 217  : 
; 218  : 	DWORD dwBitsSize=f.GetLength();//文件长度

  0091f	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00922	e8 00 00 00 00	 call	 ?GetLength@CFile@@UBE_KXZ ; CFile::GetLength
  00927	89 45 c8	 mov	 DWORD PTR _dwBitsSize$[ebp], eax

; 219  : 
; 220  : 	HGLOBAL hImageBuf = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,dwBitsSize);

  0092a	8b 4d c8	 mov	 ecx, DWORD PTR _dwBitsSize$[ebp]
  0092d	51		 push	 ecx
  0092e	6a 42		 push	 66			; 00000042H
  00930	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00936	89 45 cc	 mov	 DWORD PTR _hImageBuf$[ebp], eax

; 221  : 	if(!hImageBuf)

  00939	83 7d cc 00	 cmp	 DWORD PTR _hImageBuf$[ebp], 0
  0093d	75 26		 jne	 SHORT $L202792

; 222  : 	{
; 223  : 		//分配失败则返回
; 224  : 		f.Close();

  0093f	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00942	e8 00 00 00 00	 call	 ?Close@CFile@@UAEXXZ	; CFile::Close

; 225  : 		return FALSE;

  00947	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T203780[ebp], 0
  0094e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00955	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00958	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  0095d	8b 45 bc	 mov	 eax, DWORD PTR $T203780[ebp]
  00960	e9 3c 02 00 00	 jmp	 $L202786
$L202792:

; 226  : 	}
; 227  : 
; 228  : 	LPSTR lpImage = (LPSTR)GlobalLock(hImageBuf);

  00965	8b 55 cc	 mov	 edx, DWORD PTR _hImageBuf$[ebp]
  00968	52		 push	 edx
  00969	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  0096f	89 45 ec	 mov	 DWORD PTR _lpImage$[ebp], eax

; 229  : 
; 230  : 	//将图像读入内存
; 231  : 	DWORD retLen=0;

  00972	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _retLen$[ebp], 0

; 232  : 	retLen=f.Read(lpImage,dwBitsSize);

  00979	8b 45 c8	 mov	 eax, DWORD PTR _dwBitsSize$[ebp]
  0097c	50		 push	 eax
  0097d	8b 4d ec	 mov	 ecx, DWORD PTR _lpImage$[ebp]
  00980	51		 push	 ecx
  00981	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00984	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  00989	89 45 d0	 mov	 DWORD PTR _retLen$[ebp], eax

; 233  : 	if(retLen<dwBitsSize)

  0098c	8b 55 d0	 mov	 edx, DWORD PTR _retLen$[ebp]
  0098f	3b 55 c8	 cmp	 edx, DWORD PTR _dwBitsSize$[ebp]
  00992	73 40		 jae	 SHORT $L202797

; 234  : 	{
; 235  : 		if(hImageBuf!=NULL)

  00994	83 7d cc 00	 cmp	 DWORD PTR _hImageBuf$[ebp], 0
  00998	74 14		 je	 SHORT $L202798

; 236  : 		{
; 237  : 			GlobalUnlock (hImageBuf);

  0099a	8b 45 cc	 mov	 eax, DWORD PTR _hImageBuf$[ebp]
  0099d	50		 push	 eax
  0099e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 238  : 			GlobalFree (hImageBuf);

  009a4	8b 4d cc	 mov	 ecx, DWORD PTR _hImageBuf$[ebp]
  009a7	51		 push	 ecx
  009a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
$L202798:

; 239  : 		}
; 240  : 		f.Close();

  009ae	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  009b1	e8 00 00 00 00	 call	 ?Close@CFile@@UAEXXZ	; CFile::Close

; 241  : 		return FALSE;

  009b6	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T203781[ebp], 0
  009bd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  009c4	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  009c7	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  009cc	8b 45 b8	 mov	 eax, DWORD PTR $T203781[ebp]
  009cf	e9 cd 01 00 00	 jmp	 $L202786
$L202797:

; 242  : 	}
; 243  : 
; 244  : 
; 245  : 	CString str;

  009d4	8d 4d d4	 lea	 ecx, DWORD PTR _str$[ebp]
  009d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  009dd	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 246  : 	str =strPathname;

  009e1	8b 55 08	 mov	 edx, DWORD PTR _strPathname$[ebp]
  009e4	52		 push	 edx
  009e5	8d 4d d4	 lea	 ecx, DWORD PTR _str$[ebp]
  009e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 247  : 
; 248  : 	CMemFile* memFile = NULL;

  009ee	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _memFile$[ebp], 0

; 249  : 	CcutBitmap(lpImage, pCutRect,&memFile);

  009f5	8d 45 f0	 lea	 eax, DWORD PTR _memFile$[ebp]
  009f8	50		 push	 eax
  009f9	8b 4d 0c	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  009fc	51		 push	 ecx
  009fd	8b 55 ec	 mov	 edx, DWORD PTR _lpImage$[ebp]
  00a00	52		 push	 edx
  00a01	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00a04	e8 00 00 00 00	 call	 ?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z ; CDib::CcutBitmap

; 250  : 	str.ReleaseBuffer();

  00a09	6a ff		 push	 -1
  00a0b	8d 4d d4	 lea	 ecx, DWORD PTR _str$[ebp]
  00a0e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z

; 251  : 
; 252  : 	GlobalUnlock (hImageBuf);//释放

  00a14	8b 45 cc	 mov	 eax, DWORD PTR _hImageBuf$[ebp]
  00a17	50		 push	 eax
  00a18	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 253  : 	GlobalFree (hImageBuf);

  00a1e	8b 4d cc	 mov	 ecx, DWORD PTR _hImageBuf$[ebp]
  00a21	51		 push	 ecx
  00a22	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 254  : 
; 255  : 	if(m_lpvFile != NULL)

  00a28	8b 55 98	 mov	 edx, DWORD PTR _this$[ebp]
  00a2b	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00a2f	74 2c		 je	 SHORT $L202802

; 256  : 	{
; 257  : 		delete m_lpvFile;

  00a31	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00a34	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00a37	89 4d b4	 mov	 DWORD PTR $T203782[ebp], ecx
  00a3a	8b 55 b4	 mov	 edx, DWORD PTR $T203782[ebp]
  00a3d	52		 push	 edx
  00a3e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a43	83 c4 04	 add	 esp, 4

; 258  : 		g_count --;

  00a46	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_count
  00a4b	83 e8 01	 sub	 eax, 1
  00a4e	a3 00 00 00 00	 mov	 DWORD PTR _g_count, eax

; 259  : 		//	TRACE("m_lpvFile Destroy: %d\n", g_count);
; 260  : 		m_lpvFile = NULL;

  00a53	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00a56	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
$L202802:

; 261  : 	}
; 262  : 
; 263  : 	UINT nLenght = 0;

  00a5d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _nLenght$[ebp], 0

; 264  : 	if( memFile )

  00a64	83 7d f0 00	 cmp	 DWORD PTR _memFile$[ebp], 0
  00a68	0f 84 0d 01 00
	00		 je	 $L202805

; 265  : 	{
; 266  : 		UINT nLenght = memFile->GetLength();

  00a6e	8b 55 f0	 mov	 edx, DWORD PTR _memFile$[ebp]
  00a71	8b 02		 mov	 eax, DWORD PTR [edx]
  00a73	8b 4d f0	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00a76	ff 50 38	 call	 DWORD PTR [eax+56]
  00a79	89 45 c4	 mov	 DWORD PTR _nLenght$202806[ebp], eax

; 267  : 	m_lpvFile = new unsigned char [nLenght];

  00a7c	8b 4d c4	 mov	 ecx, DWORD PTR _nLenght$202806[ebp]
  00a7f	51		 push	 ecx
  00a80	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00a85	83 c4 04	 add	 esp, 4
  00a88	89 45 b0	 mov	 DWORD PTR $T203783[ebp], eax
  00a8b	8b 55 98	 mov	 edx, DWORD PTR _this$[ebp]
  00a8e	8b 45 b0	 mov	 eax, DWORD PTR $T203783[ebp]
  00a91	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 268  : 	g_count ++;

  00a94	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_count
  00a9a	83 c1 01	 add	 ecx, 1
  00a9d	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_count, ecx

; 269  : 
; 270  : 	memFile->Read(m_lpvFile, nLenght);

  00aa3	8b 55 c4	 mov	 edx, DWORD PTR _nLenght$202806[ebp]
  00aa6	52		 push	 edx
  00aa7	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00aaa	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00aad	51		 push	 ecx
  00aae	8b 55 f0	 mov	 edx, DWORD PTR _memFile$[ebp]
  00ab1	8b 02		 mov	 eax, DWORD PTR [edx]
  00ab3	8b 4d f0	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00ab6	ff 50 3c	 call	 DWORD PTR [eax+60]

; 271  : 
; 272  : 	memFile->Close();

  00ab9	8b 4d f0	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00abc	8b 11		 mov	 edx, DWORD PTR [ecx]
  00abe	8b 4d f0	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00ac1	ff 52 54	 call	 DWORD PTR [edx+84]

; 273  : 
; 274  : 	delete memFile;

  00ac4	8b 45 f0	 mov	 eax, DWORD PTR _memFile$[ebp]
  00ac7	89 45 a8	 mov	 DWORD PTR $T203785[ebp], eax
  00aca	8b 4d a8	 mov	 ecx, DWORD PTR $T203785[ebp]
  00acd	89 4d ac	 mov	 DWORD PTR $T203784[ebp], ecx
  00ad0	83 7d ac 00	 cmp	 DWORD PTR $T203784[ebp], 0
  00ad4	74 12		 je	 SHORT $L203786
  00ad6	6a 01		 push	 1
  00ad8	8b 55 ac	 mov	 edx, DWORD PTR $T203784[ebp]
  00adb	8b 02		 mov	 eax, DWORD PTR [edx]
  00add	8b 4d ac	 mov	 ecx, DWORD PTR $T203784[ebp]
  00ae0	ff 50 04	 call	 DWORD PTR [eax+4]
  00ae3	89 45 94	 mov	 DWORD PTR tv168[ebp], eax
  00ae6	eb 07		 jmp	 SHORT $L203787
$L203786:
  00ae8	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv168[ebp], 0
$L203787:

; 275  : 
; 276  : 	if(((LPBITMAPFILEHEADER) m_lpvFile)->bfType != 0x4d42) {

  00aef	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00af2	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00af5	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00af8	3d 42 4d 00 00	 cmp	 eax, 19778		; 00004d42H
  00afd	74 3e		 je	 SHORT $L202812

; 277  : 		AfxMessageBox("Invalid bitmap file");

  00aff	6a 00		 push	 0
  00b01	6a 00		 push	 0
  00b03	68 00 00 00 00	 push	 OFFSET FLAT:$SG202813
  00b08	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 278  : 		DetachMapFile();

  00b0d	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00b10	e8 00 00 00 00	 call	 ?DetachMapFile@CDib@@AAEXXZ ; CDib::DetachMapFile

; 279  : 		return FALSE;

  00b15	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T203788[ebp], 0
  00b1c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00b20	8d 4d d4	 lea	 ecx, DWORD PTR _str$[ebp]
  00b23	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00b29	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b30	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00b33	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00b38	8b 45 a4	 mov	 eax, DWORD PTR $T203788[ebp]
  00b3b	eb 64		 jmp	 SHORT $L202786
$L202812:

; 280  : 	}
; 281  : 	AttachMemory((LPBYTE) m_lpvFile + sizeof(BITMAPFILEHEADER));

  00b3d	6a 00		 push	 0
  00b3f	6a 00		 push	 0
  00b41	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00b44	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00b47	83 c2 0e	 add	 edx, 14			; 0000000eH
  00b4a	52		 push	 edx
  00b4b	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00b4e	e8 00 00 00 00	 call	 ?AttachMemory@CDib@@QAEHPAXH0@Z ; CDib::AttachMemory

; 282  : 	//	m_lpvFile = lpvFile;
; 283  : 	//	m_hFile = hFile;
; 284  : 	//
; 285  : 	//*(m_lpImage+100) = 5;
; 286  : 	return TRUE;

  00b53	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR $T203789[ebp], 1
  00b5a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00b5e	8d 4d d4	 lea	 ecx, DWORD PTR _str$[ebp]
  00b61	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00b67	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b6e	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00b71	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00b76	8b 45 a0	 mov	 eax, DWORD PTR $T203789[ebp]
  00b79	eb 26		 jmp	 SHORT $L202786
$L202805:

; 287  : 	}
; 288  : 	else
; 289  : 	{
; 290  : 		return FALSE;

  00b7b	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T203790[ebp], 0
  00b82	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00b86	8d 4d d4	 lea	 ecx, DWORD PTR _str$[ebp]
  00b89	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00b8f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b96	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00b99	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00b9e	8b 45 9c	 mov	 eax, DWORD PTR $T203790[ebp]
$L202786:

; 291  : 	}
; 292  : }

  00ba1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00ba4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00bab	8b e5		 mov	 esp, ebp
  00bad	5d		 pop	 ebp
  00bae	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L203791:
  0005e	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00061	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
$L203792:
  00066	8d 4d d4	 lea	 ecx, DWORD PTR _str$[ebp]
  00069	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z:
  0006f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203794
  00074	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z ENDP	; CDib::AttachMapFile2
PUBLIC	?AttachMapFile@CDib@@IAEHPBDH@Z			; CDib::AttachMapFile
xdata$x	SEGMENT
$T203807 DD	0ffffffffH
	DD	FLAT:$L203803
$T203805 DD	019930520H
	DD	01H
	DD	FLAT:$T203807
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T203802 = -52						; size = 4
$T203801 = -48						; size = 4
$T203800 = -44						; size = 4
$T203799 = -40						; size = 4
$T203798 = -36						; size = 4
_len$ = -32						; size = 4
_f$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
_strPathname$ = 8					; size = 4
_bShare$ = 12						; size = 4
?AttachMapFile@CDib@@IAEHPBDH@Z PROC NEAR		; CDib::AttachMapFile
; _this$ = ecx

; 294  : {

  00bc0	55		 push	 ebp
  00bc1	8b ec		 mov	 ebp, esp
  00bc3	6a ff		 push	 -1
  00bc5	68 00 00 00 00	 push	 __ehhandler$?AttachMapFile@CDib@@IAEHPBDH@Z
  00bca	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00bd0	50		 push	 eax
  00bd1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00bd8	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00bdb	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 295  : 	//// if we open the same file twice, Windows treats it as 2 separate files
; 296  : 	//// doesn't work with rare BMP files where # palette entries > biClrUsed
; 297  : 	////HANDLE hFile = ::CreateFile(strPathname, GENERIC_WRITE | GENERIC_READ,
; 298  : 	////	bShare ? FILE_SHARE_READ : 0,
; 299  : 	////	NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
; 300  : 	//HANDLE hFile = ::CreateFile(strPathname, GENERIC_READ|GENERIC_WRITE,
; 301  : 	//	FILE_SHARE_WRITE|FILE_SHARE_READ,	NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
; 302  : 	//ASSERT(hFile != INVALID_HANDLE_VALUE);
; 303  : 	//DWORD dwFileSize = ::GetFileSize(hFile, NULL);
; 304  : 	////HANDLE hMap = ::CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
; 305  : 	//HANDLE hMap = ::CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
; 306  : 	//
; 307  : 	//DWORD dwErr = ::GetLastError();
; 308  : 	//if(hMap == NULL) {
; 309  : 	//	AfxMessageBox("Empty bitmap file");
; 310  : 	//	AfxMessageBox(CString(strPathname));
; 311  : 	//	return FALSE;
; 312  : 	//}
; 313  : 	////LPVOID lpvFile = ::MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0); // map whole file
; 314  : 	//LPVOID lpvFile = ::MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0); // map whole file
; 315  : 	CFile f ;

  00bde	8d 4d e4	 lea	 ecx, DWORD PTR _f$[ebp]
  00be1	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile
  00be6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 316  : 
; 317  : 	if(!f.Open(strPathname, CFile::modeRead))

  00bed	6a 00		 push	 0
  00bef	6a 00		 push	 0
  00bf1	8b 45 08	 mov	 eax, DWORD PTR _strPathname$[ebp]
  00bf4	50		 push	 eax
  00bf5	8d 4d e4	 lea	 ecx, DWORD PTR _f$[ebp]
  00bf8	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  00bfd	85 c0		 test	 eax, eax
  00bff	75 1e		 jne	 SHORT $L202826

; 318  : 		return false;

  00c01	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T203798[ebp], 0
  00c08	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c0f	8d 4d e4	 lea	 ecx, DWORD PTR _f$[ebp]
  00c12	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00c17	8b 45 dc	 mov	 eax, DWORD PTR $T203798[ebp]
  00c1a	e9 f5 00 00 00	 jmp	 $L202824
$L202826:

; 319  : 
; 320  : 	int len = (int)f.GetLength(); 

  00c1f	8d 4d e4	 lea	 ecx, DWORD PTR _f$[ebp]
  00c22	e8 00 00 00 00	 call	 ?GetLength@CFile@@UBE_KXZ ; CFile::GetLength
  00c27	89 45 e0	 mov	 DWORD PTR _len$[ebp], eax

; 321  : 
; 322  : 	if(m_lpvFile != NULL)

  00c2a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c2d	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  00c31	74 2e		 je	 SHORT $L202830

; 323  : 	{
; 324  : 		delete m_lpvFile;

  00c33	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00c36	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00c39	89 45 d8	 mov	 DWORD PTR $T203799[ebp], eax
  00c3c	8b 4d d8	 mov	 ecx, DWORD PTR $T203799[ebp]
  00c3f	51		 push	 ecx
  00c40	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c45	83 c4 04	 add	 esp, 4

; 325  : 		g_count --;

  00c48	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_count
  00c4e	83 ea 01	 sub	 edx, 1
  00c51	89 15 00 00 00
	00		 mov	 DWORD PTR _g_count, edx

; 326  : 	//	TRACE("m_lpvFile Destroy: %d\n", g_count);
; 327  : 		m_lpvFile = NULL;

  00c57	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00c5a	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
$L202830:

; 328  : 	}
; 329  : 	m_lpvFile = new unsigned char [len];

  00c61	8b 4d e0	 mov	 ecx, DWORD PTR _len$[ebp]
  00c64	51		 push	 ecx
  00c65	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00c6a	83 c4 04	 add	 esp, 4
  00c6d	89 45 d4	 mov	 DWORD PTR $T203800[ebp], eax
  00c70	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00c73	8b 45 d4	 mov	 eax, DWORD PTR $T203800[ebp]
  00c76	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 330  : 	g_count ++;

  00c79	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_count
  00c7f	83 c1 01	 add	 ecx, 1
  00c82	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_count, ecx

; 331  : 	//TRACE("m_lpvFile Allocate: %d\n", g_count);
; 332  : 	f.Read(m_lpvFile, len);

  00c88	8b 55 e0	 mov	 edx, DWORD PTR _len$[ebp]
  00c8b	52		 push	 edx
  00c8c	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00c8f	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00c92	51		 push	 ecx
  00c93	8d 4d e4	 lea	 ecx, DWORD PTR _f$[ebp]
  00c96	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read

; 333  : 
; 334  : 	f.Close();

  00c9b	8d 4d e4	 lea	 ecx, DWORD PTR _f$[ebp]
  00c9e	e8 00 00 00 00	 call	 ?Close@CFile@@UAEXXZ	; CFile::Close

; 335  : 
; 336  : 	if(((LPBITMAPFILEHEADER) m_lpvFile)->bfType != 0x4d42) {

  00ca3	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00ca6	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00ca9	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00cac	81 f9 42 4d 00
	00		 cmp	 ecx, 19778		; 00004d42H
  00cb2	74 31		 je	 SHORT $L202835

; 337  : 		AfxMessageBox("Invalid bitmap file");

  00cb4	6a 00		 push	 0
  00cb6	6a 00		 push	 0
  00cb8	68 00 00 00 00	 push	 OFFSET FLAT:$SG202836
  00cbd	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 338  : 		DetachMapFile();

  00cc2	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00cc5	e8 00 00 00 00	 call	 ?DetachMapFile@CDib@@AAEXXZ ; CDib::DetachMapFile

; 339  : 		return FALSE;

  00cca	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T203801[ebp], 0
  00cd1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00cd8	8d 4d e4	 lea	 ecx, DWORD PTR _f$[ebp]
  00cdb	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00ce0	8b 45 d0	 mov	 eax, DWORD PTR $T203801[ebp]
  00ce3	eb 2f		 jmp	 SHORT $L202824
$L202835:

; 340  : 	}
; 341  : 	AttachMemory((LPBYTE) m_lpvFile + sizeof(BITMAPFILEHEADER));

  00ce5	6a 00		 push	 0
  00ce7	6a 00		 push	 0
  00ce9	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00cec	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00cef	83 c0 0e	 add	 eax, 14			; 0000000eH
  00cf2	50		 push	 eax
  00cf3	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00cf6	e8 00 00 00 00	 call	 ?AttachMemory@CDib@@QAEHPAXH0@Z ; CDib::AttachMemory

; 342  : //	m_lpvFile = lpvFile;
; 343  : //	m_hFile = hFile;
; 344  : //
; 345  : 	//*(m_lpImage+100) = 5;
; 346  : 	return TRUE;

  00cfb	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR $T203802[ebp], 1
  00d02	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d09	8d 4d e4	 lea	 ecx, DWORD PTR _f$[ebp]
  00d0c	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00d11	8b 45 cc	 mov	 eax, DWORD PTR $T203802[ebp]
$L202824:

; 347  : }

  00d14	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00d17	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00d1e	8b e5		 mov	 esp, ebp
  00d20	5d		 pop	 ebp
  00d21	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
$L203803:
  00079	8d 4d e4	 lea	 ecx, DWORD PTR _f$[ebp]
  0007c	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
__ehhandler$?AttachMapFile@CDib@@IAEHPBDH@Z:
  00081	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203805
  00086	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AttachMapFile@CDib@@IAEHPBDH@Z ENDP			; CDib::AttachMapFile
PUBLIC	?CopyToMapFile@CDib@@IAEHPBD@Z			; CDib::CopyToMapFile
PUBLIC	?MakePalette@CDib@@IAEHXZ			; CDib::MakePalette
EXTRN	__imp__CreateFileA@28:NEAR
EXTRN	__imp__MapViewOfFile@20:NEAR
EXTRN	__imp__CreateFileMappingA@24:NEAR
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -52						; size = 4
_bmfh$ = -48						; size = 14
_dwErr$ = -32						; size = 4
_dwSizeImage$ = -28					; size = 4
_hFile$ = -24						; size = 4
_lpvFile$ = -20						; size = 4
_lpBMIH$ = -16						; size = 4
_hMap$ = -12						; size = 4
_nSize$ = -8						; size = 4
_lpbCurrent$ = -4					; size = 4
_strPathname$ = 8					; size = 4
?CopyToMapFile@CDib@@IAEHPBD@Z PROC NEAR		; CDib::CopyToMapFile
; _this$ = ecx

; 350  : {

  00d30	55		 push	 ebp
  00d31	8b ec		 mov	 ebp, esp
  00d33	83 ec 34	 sub	 esp, 52			; 00000034H
  00d36	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 351  : 	// copies DIB to a new file, releases prior pointers
; 352  : 	// if you previously used CreateSection, the HBITMAP will be NULL (and unusable)
; 353  : 	BITMAPFILEHEADER bmfh;
; 354  : 	bmfh.bfType = 0x4d42;  // 'BM'

  00d39	66 c7 45 d0 42
	4d		 mov	 WORD PTR _bmfh$[ebp], 19778 ; 00004d42H

; 355  : 	bmfh.bfSize = m_dwSizeImage + sizeof(BITMAPINFOHEADER) +
; 356  : 			sizeof(RGBQUAD) * m_nColorTableEntries + sizeof(BITMAPFILEHEADER);

  00d3f	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00d42	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00d45	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00d48	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00d4b	8d 4c 81 36	 lea	 ecx, DWORD PTR [ecx+eax*4+54]
  00d4f	89 4d d2	 mov	 DWORD PTR _bmfh$[ebp+2], ecx

; 357  : 	// meaning of bfSize open to interpretation
; 358  : 	bmfh.bfReserved1 = bmfh.bfReserved2 = 0;

  00d52	66 c7 45 d8 00
	00		 mov	 WORD PTR _bmfh$[ebp+8], 0
  00d58	66 8b 55 d8	 mov	 dx, WORD PTR _bmfh$[ebp+8]
  00d5c	66 89 55 d6	 mov	 WORD PTR _bmfh$[ebp+6], dx

; 359  : 	bmfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) +
; 360  : 			sizeof(RGBQUAD) * m_nColorTableEntries;	

  00d60	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00d63	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00d66	8d 14 8d 36 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+54]
  00d6d	89 55 da	 mov	 DWORD PTR _bmfh$[ebp+10], edx

; 361  : 	HANDLE hFile = ::CreateFile(strPathname, GENERIC_WRITE | GENERIC_READ, 0, NULL,
; 362  : 		CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  00d70	6a 00		 push	 0
  00d72	68 80 00 00 00	 push	 128			; 00000080H
  00d77	6a 02		 push	 2
  00d79	6a 00		 push	 0
  00d7b	6a 00		 push	 0
  00d7d	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00d82	8b 45 08	 mov	 eax, DWORD PTR _strPathname$[ebp]
  00d85	50		 push	 eax
  00d86	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00d8c	89 45 e8	 mov	 DWORD PTR _hFile$[ebp], eax

; 363  : 	ASSERT(hFile != INVALID_HANDLE_VALUE);
; 364  : 	int nSize =  sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) +
; 365  : 				sizeof(RGBQUAD) * m_nColorTableEntries +  m_dwSizeImage;

  00d8f	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d92	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00d95	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00d98	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00d9b	8d 54 91 36	 lea	 edx, DWORD PTR [ecx+edx*4+54]
  00d9f	89 55 f8	 mov	 DWORD PTR _nSize$[ebp], edx

; 366  : 	HANDLE hMap = ::CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, nSize, NULL);

  00da2	6a 00		 push	 0
  00da4	8b 45 f8	 mov	 eax, DWORD PTR _nSize$[ebp]
  00da7	50		 push	 eax
  00da8	6a 00		 push	 0
  00daa	6a 04		 push	 4
  00dac	6a 00		 push	 0
  00dae	8b 4d e8	 mov	 ecx, DWORD PTR _hFile$[ebp]
  00db1	51		 push	 ecx
  00db2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileMappingA@24
  00db8	89 45 f4	 mov	 DWORD PTR _hMap$[ebp], eax

; 367  : 	DWORD dwErr = ::GetLastError();

  00dbb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00dc1	89 45 e0	 mov	 DWORD PTR _dwErr$[ebp], eax

; 368  : 	ASSERT(hMap != NULL);
; 369  : 	LPVOID lpvFile = ::MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0); // map whole file

  00dc4	6a 00		 push	 0
  00dc6	6a 00		 push	 0
  00dc8	6a 00		 push	 0
  00dca	6a 02		 push	 2
  00dcc	8b 55 f4	 mov	 edx, DWORD PTR _hMap$[ebp]
  00dcf	52		 push	 edx
  00dd0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapViewOfFile@20
  00dd6	89 45 ec	 mov	 DWORD PTR _lpvFile$[ebp], eax

; 370  : 	ASSERT(lpvFile != NULL);
; 371  : 	LPBYTE lpbCurrent = (LPBYTE) lpvFile;

  00dd9	8b 45 ec	 mov	 eax, DWORD PTR _lpvFile$[ebp]
  00ddc	89 45 fc	 mov	 DWORD PTR _lpbCurrent$[ebp], eax

; 372  : 	memcpy(lpbCurrent, &bmfh, sizeof(BITMAPFILEHEADER)); // file header

  00ddf	6a 0e		 push	 14			; 0000000eH
  00de1	8d 4d d0	 lea	 ecx, DWORD PTR _bmfh$[ebp]
  00de4	51		 push	 ecx
  00de5	8b 55 fc	 mov	 edx, DWORD PTR _lpbCurrent$[ebp]
  00de8	52		 push	 edx
  00de9	e8 00 00 00 00	 call	 _memcpy
  00dee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 373  : 	lpbCurrent += sizeof(BITMAPFILEHEADER);

  00df1	8b 45 fc	 mov	 eax, DWORD PTR _lpbCurrent$[ebp]
  00df4	83 c0 0e	 add	 eax, 14			; 0000000eH
  00df7	89 45 fc	 mov	 DWORD PTR _lpbCurrent$[ebp], eax

; 374  : 	LPBITMAPINFOHEADER lpBMIH = (LPBITMAPINFOHEADER) lpbCurrent;

  00dfa	8b 4d fc	 mov	 ecx, DWORD PTR _lpbCurrent$[ebp]
  00dfd	89 4d f0	 mov	 DWORD PTR _lpBMIH$[ebp], ecx

; 375  : 	memcpy(lpbCurrent, m_lpBMIH,
; 376  : 		sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * m_nColorTableEntries); // info

  00e00	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00e03	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00e06	8d 0c 85 28 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+40]
  00e0d	51		 push	 ecx
  00e0e	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00e11	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00e14	50		 push	 eax
  00e15	8b 4d fc	 mov	 ecx, DWORD PTR _lpbCurrent$[ebp]
  00e18	51		 push	 ecx
  00e19	e8 00 00 00 00	 call	 _memcpy
  00e1e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 377  : 	lpbCurrent += sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * m_nColorTableEntries;

  00e21	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00e24	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00e27	8b 4d fc	 mov	 ecx, DWORD PTR _lpbCurrent$[ebp]
  00e2a	8d 54 81 28	 lea	 edx, DWORD PTR [ecx+eax*4+40]
  00e2e	89 55 fc	 mov	 DWORD PTR _lpbCurrent$[ebp], edx

; 378  : 	memcpy(lpbCurrent, m_lpImage, m_dwSizeImage); // bit image

  00e31	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00e34	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00e37	51		 push	 ecx
  00e38	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00e3b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00e3e	50		 push	 eax
  00e3f	8b 4d fc	 mov	 ecx, DWORD PTR _lpbCurrent$[ebp]
  00e42	51		 push	 ecx
  00e43	e8 00 00 00 00	 call	 _memcpy
  00e48	83 c4 0c	 add	 esp, 12			; 0000000cH

; 379  : 	DWORD dwSizeImage = m_dwSizeImage;

  00e4b	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00e4e	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00e51	89 45 e4	 mov	 DWORD PTR _dwSizeImage$[ebp], eax

; 380  : 	Empty();

  00e54	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e57	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 381  : 	m_dwSizeImage = dwSizeImage;

  00e5c	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e5f	8b 55 e4	 mov	 edx, DWORD PTR _dwSizeImage$[ebp]
  00e62	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 382  : 	m_nBmihAlloc = m_nImageAlloc = noAlloc;

  00e65	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00e68	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00e6f	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e72	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 383  : 	m_lpBMIH = lpBMIH;

  00e79	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00e7c	8b 45 f0	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  00e7f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 384  : 	m_lpImage = lpbCurrent;

  00e82	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e85	8b 55 fc	 mov	 edx, DWORD PTR _lpbCurrent$[ebp]
  00e88	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 385  : 	m_hFile = hFile;

  00e8b	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00e8e	8b 4d e8	 mov	 ecx, DWORD PTR _hFile$[ebp]
  00e91	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 386  : 	m_hMap = hMap;

  00e94	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00e97	8b 45 f4	 mov	 eax, DWORD PTR _hMap$[ebp]
  00e9a	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 387  : 	m_lpvFile = lpvFile;

  00e9d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ea0	8b 55 ec	 mov	 edx, DWORD PTR _lpvFile$[ebp]
  00ea3	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 388  : 	ComputePaletteSize(m_lpBMIH->biBitCount);

  00ea6	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00ea9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00eac	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  00eb0	52		 push	 edx
  00eb1	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00eb4	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 389  : 	ComputeMetrics();

  00eb9	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ebc	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 390  : 	MakePalette();

  00ec1	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ec4	e8 00 00 00 00	 call	 ?MakePalette@CDib@@IAEHXZ ; CDib::MakePalette

; 391  : 	return TRUE;

  00ec9	b8 01 00 00 00	 mov	 eax, 1

; 392  : }

  00ece	8b e5		 mov	 esp, ebp
  00ed0	5d		 pop	 ebp
  00ed1	c2 04 00	 ret	 4
?CopyToMapFile@CDib@@IAEHPBD@Z ENDP			; CDib::CopyToMapFile
_TEXT	ENDS
PUBLIC	??_R0PAVCException@@@8				; CException * `RTTI Type Descriptor'
EXTRN	?Delete@CException@@QAEXXZ:NEAR			; CException::Delete
xdata$x	SEGMENT
$T203818 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T203820 DD	00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0ffffffecH
	DD	FLAT:$L203812
$T203819 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T203820
$T203816 DD	019930520H
	DD	02H
	DD	FLAT:$T203818
	DD	01H
	DD	FLAT:$T203819
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0PAVCException@@@8
_DATA	SEGMENT
??_R0PAVCException@@@8 DD FLAT:??_7type_info@@6B@	; CException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCException@@', 00H
	ORG $-25
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.PAVCException@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T203810 = -24						; size = 4
_pe$202886 = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpvMem$ = 8						; size = 4
_bMustDelete$ = 12					; size = 4
_hGlobal$ = 16						; size = 4
?AttachMemory@CDib@@QAEHPAXH0@Z PROC NEAR		; CDib::AttachMemory
; _this$ = ecx

; 395  : {

  00ee0	55		 push	 ebp
  00ee1	8b ec		 mov	 ebp, esp
  00ee3	6a ff		 push	 -1
  00ee5	68 00 00 00 00	 push	 __ehhandler$?AttachMemory@CDib@@QAEHPAXH0@Z
  00eea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00ef0	50		 push	 eax
  00ef1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00ef8	51		 push	 ecx
  00ef9	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00efc	53		 push	 ebx
  00efd	56		 push	 esi
  00efe	57		 push	 edi
  00eff	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00f02	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 	// assumes contiguous BITMAPINFOHEADER, color table, image
; 397  : 	// color table could be zero length
; 398  : 	Empty();

  00f05	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f08	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 399  : 	m_hGlobal = hGlobal;

  00f0d	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00f10	8b 4d 10	 mov	 ecx, DWORD PTR _hGlobal$[ebp]
  00f13	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 400  : 	if(bMustDelete == FALSE) {

  00f16	83 7d 0c 00	 cmp	 DWORD PTR _bMustDelete$[ebp], 0
  00f1a	75 0c		 jne	 SHORT $L202880

; 401  : 		m_nBmihAlloc = noAlloc;

  00f1c	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00f1f	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 402  : 	}
; 403  : 	else {

  00f26	eb 10		 jmp	 SHORT $L202881
$L202880:

; 404  : 		m_nBmihAlloc = ((hGlobal == NULL) ? crtAlloc : heapAlloc);

  00f28	33 c0		 xor	 eax, eax
  00f2a	83 7d 10 00	 cmp	 DWORD PTR _hGlobal$[ebp], 0
  00f2e	0f 95 c0	 setne	 al
  00f31	40		 inc	 eax
  00f32	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f35	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$L202881:

; 405  : 	}
; 406  : 	try {

  00f38	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 407  : 		m_lpBMIH = (LPBITMAPINFOHEADER) lpvMem;

  00f3f	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00f42	8b 45 08	 mov	 eax, DWORD PTR _lpvMem$[ebp]
  00f45	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 408  : 		ComputeMetrics();

  00f48	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f4b	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 409  : 		ComputePaletteSize(m_lpBMIH->biBitCount);

  00f50	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f53	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00f56	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00f5a	50		 push	 eax
  00f5b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f5e	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 410  : 		m_lpImage = (LPBYTE) m_lpvColorTable + sizeof(RGBQUAD) * m_nColorTableEntries;

  00f63	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f66	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00f69	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00f6c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00f6f	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  00f72	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00f75	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00f78	eb 23		 jmp	 SHORT $L203811
$L203812:

; 411  : 		//MakePalette();
; 412  : 	}
; 413  : 	catch(CException* pe) {
; 414  : 		AfxMessageBox("AttachMemory error");

  00f7a	6a 00		 push	 0
  00f7c	6a 00		 push	 0
  00f7e	68 00 00 00 00	 push	 OFFSET FLAT:$SG202887
  00f83	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 415  : 		pe->Delete();

  00f88	8b 4d ec	 mov	 ecx, DWORD PTR _pe$202886[ebp]
  00f8b	e8 00 00 00 00	 call	 ?Delete@CException@@QAEXXZ ; CException::Delete

; 416  : 		return FALSE;

  00f90	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T203810[ebp], 0
  00f97	b8 00 00 00 00	 mov	 eax, $L203814
  00f9c	c3		 ret	 0
$L203811:

; 417  : 	}

  00f9d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 418  : 	return TRUE;

  00fa4	eb 05		 jmp	 SHORT $L203813
$L203814:

; 416  : 		return FALSE;

  00fa6	8b 45 e8	 mov	 eax, DWORD PTR $T203810[ebp]
  00fa9	eb 05		 jmp	 SHORT $L202879
$L203813:

; 418  : 	return TRUE;

  00fab	b8 01 00 00 00	 mov	 eax, 1
$L202879:

; 419  : }

  00fb0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00fb3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00fba	5f		 pop	 edi
  00fbb	5e		 pop	 esi
  00fbc	5b		 pop	 ebx
  00fbd	8b e5		 mov	 esp, ebp
  00fbf	5d		 pop	 ebp
  00fc0	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$?AttachMemory@CDib@@QAEHPAXH0@Z:
  0008b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203816
  00090	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AttachMemory@CDib@@QAEHPAXH0@Z ENDP			; CDib::AttachMemory
PUBLIC	?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ		; CDC::GetSafeHdc
PUBLIC	?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z	; CDib::CreateBitmap
PUBLIC	?DrawTransParent@CDib@@IAEIPAVCDC@@VCRect@@1K@Z	; CDib::DrawTransParent
EXTRN	__imp__SelectObject@8:NEAR
EXTRN	__imp__CreateCompatibleDC@4:NEAR
EXTRN	__imp__TransparentBlt@44:NEAR
EXTRN	__imp__DeleteDC@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hdcCompatible$202898 = -4				; size = 4
_pDC$ = 8						; size = 4
_rcSrc$ = 12						; size = 16
_rcDst$ = 28						; size = 16
_color$ = 44						; size = 4
?DrawTransParent@CDib@@IAEIPAVCDC@@VCRect@@1K@Z PROC NEAR ; CDib::DrawTransParent
; _this$ = ecx

; 422  : {

  00fd0	55		 push	 ebp
  00fd1	8b ec		 mov	 ebp, esp
  00fd3	83 ec 08	 sub	 esp, 8
  00fd6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 423  : 	if(this->m_hBitmap == NULL)

  00fd9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00fdc	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00fe0	75 0c		 jne	 SHORT $L202896

; 424  : 		this->CreateBitmap(pDC);

  00fe2	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00fe5	51		 push	 ecx
  00fe6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00fe9	e8 00 00 00 00	 call	 ?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ; CDib::CreateBitmap
$L202896:

; 425  : 	
; 426  : 	if(true)

  00fee	ba 01 00 00 00	 mov	 edx, 1
  00ff3	85 d2		 test	 edx, edx
  00ff5	74 7b		 je	 SHORT $L202895

; 427  : 	{
; 428  : 		HDC  hdcCompatible = CreateCompatibleDC(pDC->GetSafeHdc()); 

  00ff7	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00ffa	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  00fff	50		 push	 eax
  01000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  01006	89 45 fc	 mov	 DWORD PTR _hdcCompatible$202898[ebp], eax

; 429  : 		SelectObject(hdcCompatible, m_hBitmap);

  01009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0100c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0100f	51		 push	 ecx
  01010	8b 55 fc	 mov	 edx, DWORD PTR _hdcCompatible$202898[ebp]
  01013	52		 push	 edx
  01014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 430  : 
; 431  : 		::TransparentBlt(pDC->m_hDC, rcDst.left, rcDst.top, rcDst.Width(), rcDst.Height(),hdcCompatible,
; 432  : 			rcSrc.left, rcSrc.top, rcSrc.Width(), rcSrc.Height(), color);

  0101a	8b 45 2c	 mov	 eax, DWORD PTR _color$[ebp]
  0101d	50		 push	 eax
  0101e	8d 4d 0c	 lea	 ecx, DWORD PTR _rcSrc$[ebp]
  01021	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01026	50		 push	 eax
  01027	8d 4d 0c	 lea	 ecx, DWORD PTR _rcSrc$[ebp]
  0102a	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  0102f	50		 push	 eax
  01030	8b 4d 10	 mov	 ecx, DWORD PTR _rcSrc$[ebp+4]
  01033	51		 push	 ecx
  01034	8b 55 0c	 mov	 edx, DWORD PTR _rcSrc$[ebp]
  01037	52		 push	 edx
  01038	8b 45 fc	 mov	 eax, DWORD PTR _hdcCompatible$202898[ebp]
  0103b	50		 push	 eax
  0103c	8d 4d 1c	 lea	 ecx, DWORD PTR _rcDst$[ebp]
  0103f	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01044	50		 push	 eax
  01045	8d 4d 1c	 lea	 ecx, DWORD PTR _rcDst$[ebp]
  01048	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  0104d	50		 push	 eax
  0104e	8b 4d 20	 mov	 ecx, DWORD PTR _rcDst$[ebp+4]
  01051	51		 push	 ecx
  01052	8b 55 1c	 mov	 edx, DWORD PTR _rcDst$[ebp]
  01055	52		 push	 edx
  01056	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  01059	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0105c	51		 push	 ecx
  0105d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TransparentBlt@44

; 433  : 		DeleteDC(hdcCompatible);

  01063	8b 55 fc	 mov	 edx, DWORD PTR _hdcCompatible$202898[ebp]
  01066	52		 push	 edx
  01067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 434  : 		return true;

  0106d	b8 01 00 00 00	 mov	 eax, 1
$L202895:

; 435  : 	}
; 436  : 	/*else
; 437  : 	{
; 438  : 		if(rcSrc.Width() == rcDst.Width() && rcSrc.Height() == rcDst.Height())
; 439  : 		{
; 440  : 			::BitBlt(pDC->m_hDC, rcDst.left, rcDst.top, rcDst.Width(), rcDst.Height() , m_hBitmap, rcSrc.left, rcSrc.top, SRCCOPY);
; 441  : 		}
; 442  : 		else
; 443  : 		{
; 444  : 			::StretchBlt(pDC->m_hDC, rcDst.left, rcDst.top, rcDst.Width(), rcDst.Height() , m_hBitmap, rcSrc.left, rcSrc.top,rcSrc.Width(), rcSrc.Height(), SRCCOPY);
; 445  : 		}
; 446  : 	}*/
; 447  : }

  01072	8b e5		 mov	 esp, ebp
  01074	5d		 pop	 ebp
  01075	c2 28 00	 ret	 40			; 00000028H
?DrawTransParent@CDib@@IAEIPAVCDC@@VCRect@@1K@Z ENDP	; CDib::DrawTransParent
_TEXT	ENDS
PUBLIC	?UsePalette@CDib@@IAEIPAVCDC@@H@Z		; CDib::UsePalette
EXTRN	__imp__RealizePalette@4:NEAR
EXTRN	__imp__SelectPalette@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hdc$ = -4						; size = 4
_pDC$ = 8						; size = 4
_bBackground$ = 12					; size = 4
?UsePalette@CDib@@IAEIPAVCDC@@H@Z PROC NEAR		; CDib::UsePalette
; _this$ = ecx

; 450  : {

  01080	55		 push	 ebp
  01081	8b ec		 mov	 ebp, esp
  01083	83 ec 08	 sub	 esp, 8
  01086	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 451  : 	if(m_hPalette == NULL) return 0;

  01089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0108c	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  01090	75 04		 jne	 SHORT $L202904
  01092	33 c0		 xor	 eax, eax
  01094	eb 2a		 jmp	 SHORT $L202903
$L202904:

; 452  : 	HDC hdc = pDC->GetSafeHdc();

  01096	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01099	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0109e	89 45 fc	 mov	 DWORD PTR _hdc$[ebp], eax

; 453  : 	::SelectPalette(hdc, m_hPalette, bBackground);

  010a1	8b 4d 0c	 mov	 ecx, DWORD PTR _bBackground$[ebp]
  010a4	51		 push	 ecx
  010a5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  010a8	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  010ab	50		 push	 eax
  010ac	8b 4d fc	 mov	 ecx, DWORD PTR _hdc$[ebp]
  010af	51		 push	 ecx
  010b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12

; 454  : 	return ::RealizePalette(hdc);

  010b6	8b 55 fc	 mov	 edx, DWORD PTR _hdc$[ebp]
  010b9	52		 push	 edx
  010ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RealizePalette@4
$L202903:

; 455  : }

  010c0	8b e5		 mov	 esp, ebp
  010c2	5d		 pop	 ebp
  010c3	c2 08 00	 ret	 8
?UsePalette@CDib@@IAEIPAVCDC@@H@Z ENDP			; CDib::UsePalette
_TEXT	ENDS
PUBLIC	?Draw@CDib@@IAEHPAVCDC@@VCPoint@@VCSize@@HKW4DrawMode@1@@Z ; CDib::Draw
EXTRN	?SetStretchBltMode@CDC@@QAEHH@Z:NEAR		; CDC::SetStretchBltMode
EXTRN	__imp__StretchDIBits@52:NEAR
EXTRN	__imp__CreateCompatibleBitmap@12:NEAR
EXTRN	__imp__DeleteObject@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv319 = -80						; size = 4
tv308 = -76						; size = 4
tv297 = -72						; size = 4
tv233 = -68						; size = 4
tv227 = -64						; size = 4
_this$ = -60						; size = 4
_j$202951 = -56						; size = 4
_i$202947 = -52						; size = 4
_cy$202946 = -48					; size = 4
_hbmScreen$202940 = -44					; size = 4
_hdcCompatible$202939 = -40				; size = 4
_cx$202945 = -36					; size = 4
_old$202941 = -32					; size = 4
_hbmScreen$202932 = -28					; size = 4
_hdcCompatible$202931 = -24				; size = 4
_old$202933 = -20					; size = 4
_hbmScreen$202924 = -16					; size = 4
_hdcCompatible$202923 = -12				; size = 4
_old$202925 = -8					; size = 4
_hOldPalette$ = -4					; size = 4
_pDC$ = 8						; size = 4
_origin$ = 12						; size = 8
_size$ = 20						; size = 8
_IsBKTransparent$ = 28					; size = 4
_mask$ = 32						; size = 4
_mode$ = 36						; size = 4
?Draw@CDib@@IAEHPAVCDC@@VCPoint@@VCSize@@HKW4DrawMode@1@@Z PROC NEAR ; CDib::Draw
; _this$ = ecx

; 458  : {

  010d0	55		 push	 ebp
  010d1	8b ec		 mov	 ebp, esp
  010d3	83 ec 50	 sub	 esp, 80			; 00000050H
  010d6	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 459  : 	if(m_lpBMIH == NULL) return FALSE;

  010d9	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  010dc	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  010e0	75 07		 jne	 SHORT $L202915
  010e2	33 c0		 xor	 eax, eax
  010e4	e9 bd 04 00 00	 jmp	 $L202914
$L202915:

; 460  : 	HPALETTE hOldPalette = NULL;

  010e9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hOldPalette$[ebp], 0

; 461  : 	if(m_hPalette != NULL) {

  010f0	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  010f3	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  010f7	74 1b		 je	 SHORT $L202917

; 462  : 		hOldPalette = ::SelectPalette(pDC->GetSafeHdc(), m_hPalette, TRUE);

  010f9	6a 01		 push	 1
  010fb	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  010fe	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  01101	50		 push	 eax
  01102	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01105	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0110a	50		 push	 eax
  0110b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  01111	89 45 fc	 mov	 DWORD PTR _hOldPalette$[ebp], eax
$L202917:

; 463  : 	}
; 464  : 	pDC->SetStretchBltMode(COLORONCOLOR);

  01114	6a 03		 push	 3
  01116	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01119	e8 00 00 00 00	 call	 ?SetStretchBltMode@CDC@@QAEHH@Z ; CDC::SetStretchBltMode

; 465  : 
; 466  : 	if(!IsBKTransparent)

  0111e	83 7d 1c 00	 cmp	 DWORD PTR _IsBKTransparent$[ebp], 0
  01122	75 51		 jne	 SHORT $L202918

; 467  : 	{	
; 468  : 		::StretchDIBits(pDC->GetSafeHdc(), origin.x, origin.y, size.cx, size.cy,
; 469  : 			0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 470  : 			m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  01124	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01129	6a 00		 push	 0
  0112b	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0112e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01131	52		 push	 edx
  01132	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  01135	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01138	51		 push	 ecx
  01139	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0113c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0113f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01142	51		 push	 ecx
  01143	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  01146	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01149	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0114c	51		 push	 ecx
  0114d	6a 00		 push	 0
  0114f	6a 00		 push	 0
  01151	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  01154	52		 push	 edx
  01155	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  01158	50		 push	 eax
  01159	8b 4d 10	 mov	 ecx, DWORD PTR _origin$[ebp+4]
  0115c	51		 push	 ecx
  0115d	8b 55 0c	 mov	 edx, DWORD PTR _origin$[ebp]
  01160	52		 push	 edx
  01161	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01164	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01169	50		 push	 eax
  0116a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52

; 471  : 	}
; 472  : 	else

  01170	e9 11 04 00 00	 jmp	 $L202921
$L202918:

; 473  : 	{
; 474  : 		if(mode == STRETCH)

  01175	83 7d 24 01	 cmp	 DWORD PTR _mode$[ebp], 1
  01179	0f 85 da 00 00
	00		 jne	 $L202922

; 475  : 		{
; 476  : 			HDC  hdcCompatible = CreateCompatibleDC(pDC->GetSafeHdc()); 

  0117f	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01182	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01187	50		 push	 eax
  01188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  0118e	89 45 f4	 mov	 DWORD PTR _hdcCompatible$202923[ebp], eax

; 477  : 			HBITMAP  hbmScreen = CreateCompatibleBitmap(pDC->GetSafeHdc(), 
; 478  : 							size.cx, size.cy);

  01191	8b 45 18	 mov	 eax, DWORD PTR _size$[ebp+4]
  01194	50		 push	 eax
  01195	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  01198	51		 push	 ecx
  01199	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0119c	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  011a1	50		 push	 eax
  011a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  011a8	89 45 f0	 mov	 DWORD PTR _hbmScreen$202924[ebp], eax

; 479  : 			HBITMAP old = (HBITMAP)SelectObject(hdcCompatible, hbmScreen);

  011ab	8b 55 f0	 mov	 edx, DWORD PTR _hbmScreen$202924[ebp]
  011ae	52		 push	 edx
  011af	8b 45 f4	 mov	 eax, DWORD PTR _hdcCompatible$202923[ebp]
  011b2	50		 push	 eax
  011b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  011b9	89 45 f8	 mov	 DWORD PTR _old$202925[ebp], eax

; 480  : 
; 481  : 			::StretchDIBits(hdcCompatible, 0, 0, size.cx, size.cy,
; 482  : 				0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 483  : 				m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  011bc	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  011c1	6a 00		 push	 0
  011c3	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  011c6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  011c9	52		 push	 edx
  011ca	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  011cd	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  011d0	51		 push	 ecx
  011d1	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  011d4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  011d7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  011da	51		 push	 ecx
  011db	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  011de	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  011e1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  011e4	51		 push	 ecx
  011e5	6a 00		 push	 0
  011e7	6a 00		 push	 0
  011e9	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  011ec	52		 push	 edx
  011ed	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  011f0	50		 push	 eax
  011f1	6a 00		 push	 0
  011f3	6a 00		 push	 0
  011f5	8b 4d f4	 mov	 ecx, DWORD PTR _hdcCompatible$202923[ebp]
  011f8	51		 push	 ecx
  011f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52

; 484  : 			TransparentBlt(pDC->GetSafeHdc(),origin.x, origin.y, size.cx, size.cy,hdcCompatible,0,0,size.cx, size.cy,mask);

  011ff	8b 55 20	 mov	 edx, DWORD PTR _mask$[ebp]
  01202	52		 push	 edx
  01203	8b 45 18	 mov	 eax, DWORD PTR _size$[ebp+4]
  01206	50		 push	 eax
  01207	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  0120a	51		 push	 ecx
  0120b	6a 00		 push	 0
  0120d	6a 00		 push	 0
  0120f	8b 55 f4	 mov	 edx, DWORD PTR _hdcCompatible$202923[ebp]
  01212	52		 push	 edx
  01213	8b 45 18	 mov	 eax, DWORD PTR _size$[ebp+4]
  01216	50		 push	 eax
  01217	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  0121a	51		 push	 ecx
  0121b	8b 55 10	 mov	 edx, DWORD PTR _origin$[ebp+4]
  0121e	52		 push	 edx
  0121f	8b 45 0c	 mov	 eax, DWORD PTR _origin$[ebp]
  01222	50		 push	 eax
  01223	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01226	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0122b	50		 push	 eax
  0122c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TransparentBlt@44

; 485  : 			SelectObject(hdcCompatible, old);

  01232	8b 4d f8	 mov	 ecx, DWORD PTR _old$202925[ebp]
  01235	51		 push	 ecx
  01236	8b 55 f4	 mov	 edx, DWORD PTR _hdcCompatible$202923[ebp]
  01239	52		 push	 edx
  0123a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 486  : 			DeleteObject(hbmScreen);

  01240	8b 45 f0	 mov	 eax, DWORD PTR _hbmScreen$202924[ebp]
  01243	50		 push	 eax
  01244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 487  : 			DeleteDC(hdcCompatible);

  0124a	8b 4d f4	 mov	 ecx, DWORD PTR _hdcCompatible$202923[ebp]
  0124d	51		 push	 ecx
  0124e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 488  : 		}
; 489  : 		else if(mode == NORMAL)

  01254	e9 2d 03 00 00	 jmp	 $L202921
$L202922:
  01259	83 7d 24 00	 cmp	 DWORD PTR _mode$[ebp], 0
  0125d	0f 85 42 01 00
	00		 jne	 $L202930

; 490  : 		{
; 491  : 			HDC  hdcCompatible = CreateCompatibleDC(pDC->GetSafeHdc()); 

  01263	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01266	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0126b	50		 push	 eax
  0126c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  01272	89 45 e8	 mov	 DWORD PTR _hdcCompatible$202931[ebp], eax

; 492  : 			HBITMAP  hbmScreen = CreateCompatibleBitmap(pDC->GetSafeHdc(), 
; 493  : 							m_lpBMIH->biWidth, m_lpBMIH->biHeight);

  01275	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  01278	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0127b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0127e	51		 push	 ecx
  0127f	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  01282	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01285	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01288	51		 push	 ecx
  01289	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0128c	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01291	50		 push	 eax
  01292	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  01298	89 45 e4	 mov	 DWORD PTR _hbmScreen$202932[ebp], eax

; 494  : 			HBITMAP old = (HBITMAP)SelectObject(hdcCompatible, hbmScreen);

  0129b	8b 55 e4	 mov	 edx, DWORD PTR _hbmScreen$202932[ebp]
  0129e	52		 push	 edx
  0129f	8b 45 e8	 mov	 eax, DWORD PTR _hdcCompatible$202931[ebp]
  012a2	50		 push	 eax
  012a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  012a9	89 45 ec	 mov	 DWORD PTR _old$202933[ebp], eax

; 495  : 
; 496  : 			::StretchDIBits(hdcCompatible, 0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 497  : 				0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 498  : 				m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  012ac	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  012b1	6a 00		 push	 0
  012b3	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  012b6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  012b9	52		 push	 edx
  012ba	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  012bd	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  012c0	51		 push	 ecx
  012c1	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  012c4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  012c7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  012ca	51		 push	 ecx
  012cb	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  012ce	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  012d1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  012d4	51		 push	 ecx
  012d5	6a 00		 push	 0
  012d7	6a 00		 push	 0
  012d9	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  012dc	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  012df	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  012e2	51		 push	 ecx
  012e3	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  012e6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  012e9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  012ec	51		 push	 ecx
  012ed	6a 00		 push	 0
  012ef	6a 00		 push	 0
  012f1	8b 55 e8	 mov	 edx, DWORD PTR _hdcCompatible$202931[ebp]
  012f4	52		 push	 edx
  012f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52

; 499  : 
; 500  : 			size.cx = (size.cx > m_lpBMIH->biWidth)? m_lpBMIH->biWidth : size.cx;

  012fb	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  012fe	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01301	8b 55 14	 mov	 edx, DWORD PTR _size$[ebp]
  01304	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  01307	7e 0e		 jle	 SHORT $L203824
  01309	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0130c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0130f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01312	89 55 c0	 mov	 DWORD PTR tv227[ebp], edx
  01315	eb 06		 jmp	 SHORT $L203825
$L203824:
  01317	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  0131a	89 45 c0	 mov	 DWORD PTR tv227[ebp], eax
$L203825:
  0131d	8b 4d c0	 mov	 ecx, DWORD PTR tv227[ebp]
  01320	89 4d 14	 mov	 DWORD PTR _size$[ebp], ecx

; 501  : 			size.cy = (size.cy > m_lpBMIH->biHeight)? m_lpBMIH->biHeight : size.cy;

  01323	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  01326	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01329	8b 4d 18	 mov	 ecx, DWORD PTR _size$[ebp+4]
  0132c	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0132f	7e 0e		 jle	 SHORT $L203826
  01331	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  01334	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01337	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0133a	89 4d bc	 mov	 DWORD PTR tv233[ebp], ecx
  0133d	eb 06		 jmp	 SHORT $L203827
$L203826:
  0133f	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  01342	89 55 bc	 mov	 DWORD PTR tv233[ebp], edx
$L203827:
  01345	8b 45 bc	 mov	 eax, DWORD PTR tv233[ebp]
  01348	89 45 18	 mov	 DWORD PTR _size$[ebp+4], eax

; 502  : 
; 503  : 			TransparentBlt(pDC->GetSafeHdc(),origin.x, origin.y, size.cx, size.cy,hdcCompatible,0,0,size.cx, size.cy,mask);

  0134b	8b 4d 20	 mov	 ecx, DWORD PTR _mask$[ebp]
  0134e	51		 push	 ecx
  0134f	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  01352	52		 push	 edx
  01353	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  01356	50		 push	 eax
  01357	6a 00		 push	 0
  01359	6a 00		 push	 0
  0135b	8b 4d e8	 mov	 ecx, DWORD PTR _hdcCompatible$202931[ebp]
  0135e	51		 push	 ecx
  0135f	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  01362	52		 push	 edx
  01363	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  01366	50		 push	 eax
  01367	8b 4d 10	 mov	 ecx, DWORD PTR _origin$[ebp+4]
  0136a	51		 push	 ecx
  0136b	8b 55 0c	 mov	 edx, DWORD PTR _origin$[ebp]
  0136e	52		 push	 edx
  0136f	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01372	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01377	50		 push	 eax
  01378	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TransparentBlt@44

; 504  : 			SelectObject(hdcCompatible, old);

  0137e	8b 45 ec	 mov	 eax, DWORD PTR _old$202933[ebp]
  01381	50		 push	 eax
  01382	8b 4d e8	 mov	 ecx, DWORD PTR _hdcCompatible$202931[ebp]
  01385	51		 push	 ecx
  01386	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 505  : 			DeleteObject(hbmScreen);

  0138c	8b 55 e4	 mov	 edx, DWORD PTR _hbmScreen$202932[ebp]
  0138f	52		 push	 edx
  01390	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 506  : 			DeleteDC(hdcCompatible);

  01396	8b 45 e8	 mov	 eax, DWORD PTR _hdcCompatible$202931[ebp]
  01399	50		 push	 eax
  0139a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 507  : 		}
; 508  : 		else if(mode == TILE)

  013a0	e9 e1 01 00 00	 jmp	 $L202921
$L202930:
  013a5	83 7d 24 02	 cmp	 DWORD PTR _mode$[ebp], 2
  013a9	0f 85 d7 01 00
	00		 jne	 $L202921

; 509  : 		{
; 510  : 			HDC  hdcCompatible = CreateCompatibleDC(pDC->GetSafeHdc()); 

  013af	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  013b2	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  013b7	50		 push	 eax
  013b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  013be	89 45 d8	 mov	 DWORD PTR _hdcCompatible$202939[ebp], eax

; 511  : 			HBITMAP  hbmScreen = CreateCompatibleBitmap(pDC->GetSafeHdc(), 
; 512  : 				m_lpBMIH->biWidth, m_lpBMIH->biHeight);

  013c1	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  013c4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  013c7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  013ca	50		 push	 eax
  013cb	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  013ce	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  013d1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  013d4	50		 push	 eax
  013d5	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  013d8	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  013dd	50		 push	 eax
  013de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  013e4	89 45 d4	 mov	 DWORD PTR _hbmScreen$202940[ebp], eax

; 513  : 			HBITMAP old = (HBITMAP)SelectObject(hdcCompatible, hbmScreen);

  013e7	8b 4d d4	 mov	 ecx, DWORD PTR _hbmScreen$202940[ebp]
  013ea	51		 push	 ecx
  013eb	8b 55 d8	 mov	 edx, DWORD PTR _hdcCompatible$202939[ebp]
  013ee	52		 push	 edx
  013ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  013f5	89 45 e0	 mov	 DWORD PTR _old$202941[ebp], eax

; 514  : 
; 515  : 			::StretchDIBits(hdcCompatible, 0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 516  : 				0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 517  : 				m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  013f8	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  013fd	6a 00		 push	 0
  013ff	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  01402	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01405	51		 push	 ecx
  01406	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  01409	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0140c	50		 push	 eax
  0140d	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01410	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01413	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01416	50		 push	 eax
  01417	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0141a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0141d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01420	50		 push	 eax
  01421	6a 00		 push	 0
  01423	6a 00		 push	 0
  01425	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01428	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0142b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0142e	50		 push	 eax
  0142f	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01432	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01435	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01438	50		 push	 eax
  01439	6a 00		 push	 0
  0143b	6a 00		 push	 0
  0143d	8b 4d d8	 mov	 ecx, DWORD PTR _hdcCompatible$202939[ebp]
  01440	51		 push	 ecx
  01441	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52

; 518  : 
; 519  : 			size.cy = (size.cy > m_lpBMIH->biHeight)? m_lpBMIH->biHeight : size.cy;

  01447	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0144a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0144d	8b 4d 18	 mov	 ecx, DWORD PTR _size$[ebp+4]
  01450	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  01453	7e 0e		 jle	 SHORT $L203828
  01455	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  01458	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0145b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0145e	89 4d b8	 mov	 DWORD PTR tv297[ebp], ecx
  01461	eb 06		 jmp	 SHORT $L203829
$L203828:
  01463	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  01466	89 55 b8	 mov	 DWORD PTR tv297[ebp], edx
$L203829:
  01469	8b 45 b8	 mov	 eax, DWORD PTR tv297[ebp]
  0146c	89 45 18	 mov	 DWORD PTR _size$[ebp+4], eax

; 520  : 
; 521  : 			int cx = size.cx;

  0146f	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  01472	89 4d dc	 mov	 DWORD PTR _cx$202945[ebp], ecx

; 522  : 			int cy = size.cy;

  01475	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  01478	89 55 d0	 mov	 DWORD PTR _cy$202946[ebp], edx

; 523  : 			for(int i = 0 ; i<size.cx; i+= m_lpBMIH->biWidth)

  0147b	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$202947[ebp], 0
  01482	eb 0f		 jmp	 SHORT $L202948
$L202949:
  01484	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  01487	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0148a	8b 55 cc	 mov	 edx, DWORD PTR _i$202947[ebp]
  0148d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  01490	89 55 cc	 mov	 DWORD PTR _i$202947[ebp], edx
$L202948:
  01493	8b 45 cc	 mov	 eax, DWORD PTR _i$202947[ebp]
  01496	3b 45 14	 cmp	 eax, DWORD PTR _size$[ebp]
  01499	0f 8d c5 00 00
	00		 jge	 $L202950

; 524  : 			{
; 525  : 				cx = size.cx - i;

  0149f	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  014a2	2b 4d cc	 sub	 ecx, DWORD PTR _i$202947[ebp]
  014a5	89 4d dc	 mov	 DWORD PTR _cx$202945[ebp], ecx

; 526  : 				cx = (cx > m_lpBMIH->biWidth) ? m_lpBMIH->biWidth : cx;

  014a8	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  014ab	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  014ae	8b 4d dc	 mov	 ecx, DWORD PTR _cx$202945[ebp]
  014b1	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  014b4	7e 0e		 jle	 SHORT $L203830
  014b6	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  014b9	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  014bc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  014bf	89 4d b4	 mov	 DWORD PTR tv308[ebp], ecx
  014c2	eb 06		 jmp	 SHORT $L203831
$L203830:
  014c4	8b 55 dc	 mov	 edx, DWORD PTR _cx$202945[ebp]
  014c7	89 55 b4	 mov	 DWORD PTR tv308[ebp], edx
$L203831:
  014ca	8b 45 b4	 mov	 eax, DWORD PTR tv308[ebp]
  014cd	89 45 dc	 mov	 DWORD PTR _cx$202945[ebp], eax

; 527  : 				for(int j = 0; j<size.cy; j+= m_lpBMIH->biHeight)

  014d0	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _j$202951[ebp], 0
  014d7	eb 0f		 jmp	 SHORT $L202952
$L202953:
  014d9	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  014dc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  014df	8b 45 c8	 mov	 eax, DWORD PTR _j$202951[ebp]
  014e2	03 42 08	 add	 eax, DWORD PTR [edx+8]
  014e5	89 45 c8	 mov	 DWORD PTR _j$202951[ebp], eax
$L202952:
  014e8	8b 4d c8	 mov	 ecx, DWORD PTR _j$202951[ebp]
  014eb	3b 4d 18	 cmp	 ecx, DWORD PTR _size$[ebp+4]
  014ee	7d 6f		 jge	 SHORT $L202954

; 528  : 				{
; 529  : 					cy = size.cy - j;

  014f0	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  014f3	2b 55 c8	 sub	 edx, DWORD PTR _j$202951[ebp]
  014f6	89 55 d0	 mov	 DWORD PTR _cy$202946[ebp], edx

; 530  : 					cy = (cy > m_lpBMIH->biHeight)? m_lpBMIH->biHeight : cy;

  014f9	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  014fc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  014ff	8b 55 d0	 mov	 edx, DWORD PTR _cy$202946[ebp]
  01502	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  01505	7e 0e		 jle	 SHORT $L203832
  01507	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0150a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0150d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01510	89 55 b0	 mov	 DWORD PTR tv319[ebp], edx
  01513	eb 06		 jmp	 SHORT $L203833
$L203832:
  01515	8b 45 d0	 mov	 eax, DWORD PTR _cy$202946[ebp]
  01518	89 45 b0	 mov	 DWORD PTR tv319[ebp], eax
$L203833:
  0151b	8b 4d b0	 mov	 ecx, DWORD PTR tv319[ebp]
  0151e	89 4d d0	 mov	 DWORD PTR _cy$202946[ebp], ecx

; 531  : 					TransparentBlt(pDC->GetSafeHdc(),origin.x + i, origin.y + j, 
; 532  : 						cx, cy,hdcCompatible,0,0,cx, cy,mask);

  01521	8b 55 20	 mov	 edx, DWORD PTR _mask$[ebp]
  01524	52		 push	 edx
  01525	8b 45 d0	 mov	 eax, DWORD PTR _cy$202946[ebp]
  01528	50		 push	 eax
  01529	8b 4d dc	 mov	 ecx, DWORD PTR _cx$202945[ebp]
  0152c	51		 push	 ecx
  0152d	6a 00		 push	 0
  0152f	6a 00		 push	 0
  01531	8b 55 d8	 mov	 edx, DWORD PTR _hdcCompatible$202939[ebp]
  01534	52		 push	 edx
  01535	8b 45 d0	 mov	 eax, DWORD PTR _cy$202946[ebp]
  01538	50		 push	 eax
  01539	8b 4d dc	 mov	 ecx, DWORD PTR _cx$202945[ebp]
  0153c	51		 push	 ecx
  0153d	8b 55 10	 mov	 edx, DWORD PTR _origin$[ebp+4]
  01540	03 55 c8	 add	 edx, DWORD PTR _j$202951[ebp]
  01543	52		 push	 edx
  01544	8b 45 0c	 mov	 eax, DWORD PTR _origin$[ebp]
  01547	03 45 cc	 add	 eax, DWORD PTR _i$202947[ebp]
  0154a	50		 push	 eax
  0154b	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0154e	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01553	50		 push	 eax
  01554	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TransparentBlt@44

; 533  : 				}

  0155a	e9 7a ff ff ff	 jmp	 $L202953
$L202954:

; 534  : 			}

  0155f	e9 20 ff ff ff	 jmp	 $L202949
$L202950:

; 535  : 			SelectObject(hdcCompatible, old);

  01564	8b 4d e0	 mov	 ecx, DWORD PTR _old$202941[ebp]
  01567	51		 push	 ecx
  01568	8b 55 d8	 mov	 edx, DWORD PTR _hdcCompatible$202939[ebp]
  0156b	52		 push	 edx
  0156c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 536  : 			DeleteObject(hbmScreen);

  01572	8b 45 d4	 mov	 eax, DWORD PTR _hbmScreen$202940[ebp]
  01575	50		 push	 eax
  01576	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 537  : 			DeleteDC(hdcCompatible);

  0157c	8b 4d d8	 mov	 ecx, DWORD PTR _hdcCompatible$202939[ebp]
  0157f	51		 push	 ecx
  01580	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$L202921:

; 538  : 		}
; 539  : 	}
; 540  : 	if (hOldPalette != NULL)

  01586	83 7d fc 00	 cmp	 DWORD PTR _hOldPalette$[ebp], 0
  0158a	74 15		 je	 SHORT $L202955

; 541  : 	{
; 542  : 		::SelectPalette(pDC->GetSafeHdc(), hOldPalette, TRUE);

  0158c	6a 01		 push	 1
  0158e	8b 55 fc	 mov	 edx, DWORD PTR _hOldPalette$[ebp]
  01591	52		 push	 edx
  01592	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01595	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0159a	50		 push	 eax
  0159b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
$L202955:

; 543  : 	}
; 544  : 	
; 545  : 	return TRUE;

  015a1	b8 01 00 00 00	 mov	 eax, 1
$L202914:

; 546  : }

  015a6	8b e5		 mov	 esp, ebp
  015a8	5d		 pop	 ebp
  015a9	c2 20 00	 ret	 32			; 00000020H
?Draw@CDib@@IAEHPAVCDC@@VCPoint@@VCSize@@HKW4DrawMode@1@@Z ENDP ; CDib::Draw
_TEXT	ENDS
PUBLIC	?CreateSection@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ; CDib::CreateSection
EXTRN	__imp__CreateDIBSection@24:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?CreateSection@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z PROC NEAR ; CDib::CreateSection
; _this$ = ecx

; 549  : {

  015b0	55		 push	 ebp
  015b1	8b ec		 mov	 ebp, esp
  015b3	51		 push	 ecx
  015b4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 550  : 	if(m_lpBMIH == NULL) return NULL;

  015b7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015ba	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  015be	75 04		 jne	 SHORT $L202960
  015c0	33 c0		 xor	 eax, eax
  015c2	eb 52		 jmp	 SHORT $L202959
$L202960:

; 551  : 	if(m_lpImage != NULL) return NULL; // can only do this if image doesn't exist

  015c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  015c7	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  015cb	74 04		 je	 SHORT $L202961
  015cd	33 c0		 xor	 eax, eax
  015cf	eb 45		 jmp	 SHORT $L202959
$L202961:

; 552  : 	if(m_hBitmap != NULL)

  015d1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  015d4	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  015d8	74 0d		 je	 SHORT $L202962

; 553  : 		::DeleteObject(m_hBitmap);

  015da	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015dd	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  015e0	51		 push	 ecx
  015e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$L202962:

; 554  : 	m_hBitmap = ::CreateDIBSection(pDC->GetSafeHdc(), (LPBITMAPINFO) m_lpBMIH,
; 555  : 		DIB_RGB_COLORS,	(LPVOID*) &m_lpImage, NULL, 0);

  015e7	6a 00		 push	 0
  015e9	6a 00		 push	 0
  015eb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  015ee	83 c2 10	 add	 edx, 16			; 00000010H
  015f1	52		 push	 edx
  015f2	6a 00		 push	 0
  015f4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015f7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  015fa	51		 push	 ecx
  015fb	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  015fe	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01603	50		 push	 eax
  01604	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBSection@24
  0160a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0160d	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 556  : 	ASSERT(m_lpImage != NULL);
; 557  : 	return m_hBitmap;

  01610	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01613	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
$L202959:

; 558  : }

  01616	8b e5		 mov	 esp, ebp
  01618	5d		 pop	 ebp
  01619	c2 04 00	 ret	 4
?CreateSection@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ENDP	; CDib::CreateSection
_TEXT	ENDS
EXTRN	__imp__CreatePalette@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T203837 = -20						; size = 4
$T203836 = -16						; size = 4
_i$202979 = -12						; size = 4
_pLogPal$ = -8						; size = 4
_pDibQuad$ = -4						; size = 4
?MakePalette@CDib@@IAEHXZ PROC NEAR			; CDib::MakePalette
; _this$ = ecx

; 561  : {

  01620	55		 push	 ebp
  01621	8b ec		 mov	 ebp, esp
  01623	83 ec 18	 sub	 esp, 24			; 00000018H
  01626	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 562  : 	// makes a logical palette (m_hPalette) from the DIB's color table
; 563  : 	// this palette will be selected and realized prior to drawing the DIB
; 564  : 	if(m_nColorTableEntries == 0) return FALSE;

  01629	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0162c	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  01630	75 07		 jne	 SHORT $L202969
  01632	33 c0		 xor	 eax, eax
  01634	e9 dd 00 00 00	 jmp	 $L202968
$L202969:

; 565  : 	if(m_hPalette != NULL) ::DeleteObject(m_hPalette);

  01639	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0163c	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  01640	74 0d		 je	 SHORT $L202970
  01642	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  01645	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  01648	50		 push	 eax
  01649	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$L202970:

; 566  : 	TRACE("CDib::MakePalette -- m_nColorTableEntries = %d\n", m_nColorTableEntries);
; 567  : 	LPLOGPALETTE pLogPal = (LPLOGPALETTE) new char[2 * sizeof(WORD) +
; 568  : 		m_nColorTableEntries * sizeof(PALETTEENTRY)];

  0164f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  01652	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  01655	8d 04 95 04 00
	00 00		 lea	 eax, DWORD PTR [edx*4+4]
  0165c	50		 push	 eax
  0165d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  01662	83 c4 04	 add	 esp, 4
  01665	89 45 f0	 mov	 DWORD PTR $T203836[ebp], eax
  01668	8b 4d f0	 mov	 ecx, DWORD PTR $T203836[ebp]
  0166b	89 4d f8	 mov	 DWORD PTR _pLogPal$[ebp], ecx

; 569  : 	pLogPal->palVersion = 0x300;

  0166e	8b 55 f8	 mov	 edx, DWORD PTR _pLogPal$[ebp]
  01671	66 c7 02 00 03	 mov	 WORD PTR [edx], 768	; 00000300H

; 570  : 	pLogPal->palNumEntries = m_nColorTableEntries;

  01676	8b 45 f8	 mov	 eax, DWORD PTR _pLogPal$[ebp]
  01679	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0167c	66 8b 51 24	 mov	 dx, WORD PTR [ecx+36]
  01680	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 571  : 	LPRGBQUAD pDibQuad = (LPRGBQUAD) m_lpvColorTable;

  01684	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  01687	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0168a	89 4d fc	 mov	 DWORD PTR _pDibQuad$[ebp], ecx

; 572  : 	for(int i = 0; i < m_nColorTableEntries; i++) {

  0168d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$202979[ebp], 0
  01694	eb 09		 jmp	 SHORT $L202980
$L202981:
  01696	8b 55 f4	 mov	 edx, DWORD PTR _i$202979[ebp]
  01699	83 c2 01	 add	 edx, 1
  0169c	89 55 f4	 mov	 DWORD PTR _i$202979[ebp], edx
$L202980:
  0169f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  016a2	8b 4d f4	 mov	 ecx, DWORD PTR _i$202979[ebp]
  016a5	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  016a8	7d 45		 jge	 SHORT $L202982

; 573  : 		pLogPal->palPalEntry[i].peRed = pDibQuad->rgbRed;

  016aa	8b 55 f4	 mov	 edx, DWORD PTR _i$202979[ebp]
  016ad	8b 45 f8	 mov	 eax, DWORD PTR _pLogPal$[ebp]
  016b0	8b 4d fc	 mov	 ecx, DWORD PTR _pDibQuad$[ebp]
  016b3	8a 49 02	 mov	 cl, BYTE PTR [ecx+2]
  016b6	88 4c 90 04	 mov	 BYTE PTR [eax+edx*4+4], cl

; 574  : 		pLogPal->palPalEntry[i].peGreen = pDibQuad->rgbGreen;

  016ba	8b 55 f4	 mov	 edx, DWORD PTR _i$202979[ebp]
  016bd	8b 45 f8	 mov	 eax, DWORD PTR _pLogPal$[ebp]
  016c0	8b 4d fc	 mov	 ecx, DWORD PTR _pDibQuad$[ebp]
  016c3	8a 49 01	 mov	 cl, BYTE PTR [ecx+1]
  016c6	88 4c 90 05	 mov	 BYTE PTR [eax+edx*4+5], cl

; 575  : 		pLogPal->palPalEntry[i].peBlue = pDibQuad->rgbBlue;

  016ca	8b 55 f4	 mov	 edx, DWORD PTR _i$202979[ebp]
  016cd	8b 45 f8	 mov	 eax, DWORD PTR _pLogPal$[ebp]
  016d0	8b 4d fc	 mov	 ecx, DWORD PTR _pDibQuad$[ebp]
  016d3	8a 09		 mov	 cl, BYTE PTR [ecx]
  016d5	88 4c 90 06	 mov	 BYTE PTR [eax+edx*4+6], cl

; 576  : 		pLogPal->palPalEntry[i].peFlags = 0;

  016d9	8b 55 f4	 mov	 edx, DWORD PTR _i$202979[ebp]
  016dc	8b 45 f8	 mov	 eax, DWORD PTR _pLogPal$[ebp]
  016df	c6 44 90 07 00	 mov	 BYTE PTR [eax+edx*4+7], 0

; 577  : 		pDibQuad++;

  016e4	8b 4d fc	 mov	 ecx, DWORD PTR _pDibQuad$[ebp]
  016e7	83 c1 04	 add	 ecx, 4
  016ea	89 4d fc	 mov	 DWORD PTR _pDibQuad$[ebp], ecx

; 578  : 	}

  016ed	eb a7		 jmp	 SHORT $L202981
$L202982:

; 579  : 	m_hPalette = ::CreatePalette(pLogPal);

  016ef	8b 55 f8	 mov	 edx, DWORD PTR _pLogPal$[ebp]
  016f2	52		 push	 edx
  016f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreatePalette@4
  016f9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  016fc	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 580  : 	delete pLogPal;

  016ff	8b 55 f8	 mov	 edx, DWORD PTR _pLogPal$[ebp]
  01702	89 55 ec	 mov	 DWORD PTR $T203837[ebp], edx
  01705	8b 45 ec	 mov	 eax, DWORD PTR $T203837[ebp]
  01708	50		 push	 eax
  01709	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0170e	83 c4 04	 add	 esp, 4

; 581  : 	return TRUE;

  01711	b8 01 00 00 00	 mov	 eax, 1
$L202968:

; 582  : }	

  01716	8b e5		 mov	 esp, ebp
  01718	5d		 pop	 ebp
  01719	c3		 ret	 0
?MakePalette@CDib@@IAEHXZ ENDP				; CDib::MakePalette
_TEXT	ENDS
PUBLIC	?SetSystemPalette@CDib@@IAEHPAVCDC@@@Z		; CDib::SetSystemPalette
EXTRN	__imp__CreateHalftonePalette@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?SetSystemPalette@CDib@@IAEHPAVCDC@@@Z PROC NEAR	; CDib::SetSystemPalette
; _this$ = ecx

; 585  : {

  01720	55		 push	 ebp
  01721	8b ec		 mov	 ebp, esp
  01723	51		 push	 ecx
  01724	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 	// if the DIB doesn't have a color table, we can use the system's halftone palette
; 587  : 	if(m_nColorTableEntries != 0) return FALSE;

  01727	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0172a	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0172e	74 04		 je	 SHORT $L202988
  01730	33 c0		 xor	 eax, eax
  01732	eb 1a		 jmp	 SHORT $L202987
$L202988:

; 588  : 	m_hPalette = ::CreateHalftonePalette(pDC->GetSafeHdc());

  01734	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01737	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0173c	50		 push	 eax
  0173d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateHalftonePalette@4
  01743	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01746	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 589  : 	return TRUE;

  01749	b8 01 00 00 00	 mov	 eax, 1
$L202987:

; 590  : }

  0174e	8b e5		 mov	 esp, ebp
  01750	5d		 pop	 ebp
  01751	c2 04 00	 ret	 4
?SetSystemPalette@CDib@@IAEHPAVCDC@@@Z ENDP		; CDib::SetSystemPalette
_TEXT	ENDS
EXTRN	__imp__CreateDIBitmap@24:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hBitmap$ = -4						; size = 4
_pDC$ = 8						; size = 4
?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z PROC NEAR ; CDib::CreateBitmap
; _this$ = ecx

; 593  : {

  01760	55		 push	 ebp
  01761	8b ec		 mov	 ebp, esp
  01763	83 ec 08	 sub	 esp, 8
  01766	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 594  :     if (m_dwSizeImage == 0) return NULL;

  01769	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0176c	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  01770	75 04		 jne	 SHORT $L202993
  01772	33 c0		 xor	 eax, eax
  01774	eb 37		 jmp	 SHORT $L202992
$L202993:

; 595  :     HBITMAP hBitmap = ::CreateDIBitmap(pDC->GetSafeHdc(), m_lpBMIH,
; 596  :             CBM_INIT, m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS);

  01776	6a 00		 push	 0
  01778	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0177b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0177e	52		 push	 edx
  0177f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01782	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01785	51		 push	 ecx
  01786	6a 04		 push	 4
  01788	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0178b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0178e	50		 push	 eax
  0178f	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01792	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01797	50		 push	 eax
  01798	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBitmap@24
  0179e	89 45 fc	 mov	 DWORD PTR _hBitmap$[ebp], eax

; 597  :     ASSERT(hBitmap != NULL);
; 598  : 	this->m_hBitmap = hBitmap;

  017a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  017a4	8b 55 fc	 mov	 edx, DWORD PTR _hBitmap$[ebp]
  017a7	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 599  :     return hBitmap;

  017aa	8b 45 fc	 mov	 eax, DWORD PTR _hBitmap$[ebp]
$L202992:

; 600  : }

  017ad	8b e5		 mov	 esp, ebp
  017af	5d		 pop	 ebp
  017b0	c2 04 00	 ret	 4
?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ENDP	; CDib::CreateBitmap
_TEXT	ENDS
PUBLIC	?Compress@CDib@@IAEHPAVCDC@@H@Z			; CDib::Compress
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	__imp__GetDIBits@28:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv129 = -52						; size = 4
_this$ = -48						; size = 4
$T203844 = -44						; size = 4
$T203843 = -40						; size = 4
$T203842 = -36						; size = 4
$T203841 = -32						; size = 4
_dwBytes$203034 = -28					; size = 4
_hdc$ = -24						; size = 4
_hOldPalette$ = -20					; size = 4
_hBitmap$ = -16						; size = 4
_lpBMIH$ = -12						; size = 4
_lpImage$ = -8						; size = 4
_nSize$ = -4						; size = 4
_pDC$ = 8						; size = 4
_bCompress$ = 12					; size = 4
?Compress@CDib@@IAEHPAVCDC@@H@Z PROC NEAR		; CDib::Compress
; _this$ = ecx

; 603  : {

  017c0	55		 push	 ebp
  017c1	8b ec		 mov	 ebp, esp
  017c3	83 ec 34	 sub	 esp, 52			; 00000034H
  017c6	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 604  : 	// 1. makes GDI bitmap from existing DIB
; 605  : 	// 2. makes a new DIB from GDI bitmap with compression
; 606  : 	// 3. cleans up the original DIB
; 607  : 	// 4. puts the new DIB in the object
; 608  : 	if((m_lpBMIH->biBitCount != 4) && (m_lpBMIH->biBitCount != 8)) return FALSE;

  017c9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  017cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  017cf	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  017d3	83 fa 04	 cmp	 edx, 4
  017d6	74 16		 je	 SHORT $L203002
  017d8	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  017db	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  017de	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  017e2	83 fa 08	 cmp	 edx, 8
  017e5	74 07		 je	 SHORT $L203002
  017e7	33 c0		 xor	 eax, eax
  017e9	e9 9b 02 00 00	 jmp	 $L203001
$L203002:

; 609  : 		// compression supported only for 4 bpp and 8 bpp DIBs
; 610  : 	if(m_hBitmap) return FALSE; // can't compress a DIB Section!

  017ee	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  017f1	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  017f5	74 07		 je	 SHORT $L203003
  017f7	33 c0		 xor	 eax, eax
  017f9	e9 8b 02 00 00	 jmp	 $L203001
$L203003:

; 611  : 	TRACE("Compress: original palette size = %d\n", m_nColorTableEntries); 
; 612  : 	HDC hdc = pDC->GetSafeHdc();

  017fe	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01801	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01806	89 45 e8	 mov	 DWORD PTR _hdc$[ebp], eax

; 613  : 	HPALETTE hOldPalette = ::SelectPalette(hdc, m_hPalette, FALSE);

  01809	6a 00		 push	 0
  0180b	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0180e	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  01811	52		 push	 edx
  01812	8b 45 e8	 mov	 eax, DWORD PTR _hdc$[ebp]
  01815	50		 push	 eax
  01816	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  0181c	89 45 ec	 mov	 DWORD PTR _hOldPalette$[ebp], eax

; 614  : 	HBITMAP hBitmap;  // temporary
; 615  : 	if((hBitmap = CreateBitmap(pDC)) == NULL) return FALSE;

  0181f	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01822	51		 push	 ecx
  01823	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  01826	e8 00 00 00 00	 call	 ?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ; CDib::CreateBitmap
  0182b	89 45 f0	 mov	 DWORD PTR _hBitmap$[ebp], eax
  0182e	83 7d f0 00	 cmp	 DWORD PTR _hBitmap$[ebp], 0
  01832	75 07		 jne	 SHORT $L203007
  01834	33 c0		 xor	 eax, eax
  01836	e9 4e 02 00 00	 jmp	 $L203001
$L203007:

; 616  : 	int nSize = sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * m_nColorTableEntries;

  0183b	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  0183e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  01841	8d 0c 85 28 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+40]
  01848	89 4d fc	 mov	 DWORD PTR _nSize$[ebp], ecx

; 617  : 	LPBITMAPINFOHEADER lpBMIH = (LPBITMAPINFOHEADER) new char[nSize];

  0184b	8b 55 fc	 mov	 edx, DWORD PTR _nSize$[ebp]
  0184e	52		 push	 edx
  0184f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  01854	83 c4 04	 add	 esp, 4
  01857	89 45 e0	 mov	 DWORD PTR $T203841[ebp], eax
  0185a	8b 45 e0	 mov	 eax, DWORD PTR $T203841[ebp]
  0185d	89 45 f4	 mov	 DWORD PTR _lpBMIH$[ebp], eax

; 618  : 	memcpy(lpBMIH, m_lpBMIH, nSize);  // new header

  01860	8b 4d fc	 mov	 ecx, DWORD PTR _nSize$[ebp]
  01863	51		 push	 ecx
  01864	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  01867	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0186a	50		 push	 eax
  0186b	8b 4d f4	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  0186e	51		 push	 ecx
  0186f	e8 00 00 00 00	 call	 _memcpy
  01874	83 c4 0c	 add	 esp, 12			; 0000000cH

; 619  : 	if(bCompress) {

  01877	83 7d 0c 00	 cmp	 DWORD PTR _bCompress$[ebp], 0
  0187b	0f 84 ef 00 00
	00		 je	 $L203015

; 620  : 		switch (lpBMIH->biBitCount) {

  01881	8b 55 f4	 mov	 edx, DWORD PTR _lpBMIH$[ebp]
  01884	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  01888	89 45 cc	 mov	 DWORD PTR tv129[ebp], eax
  0188b	83 7d cc 04	 cmp	 DWORD PTR tv129[ebp], 4
  0188f	74 08		 je	 SHORT $L203020
  01891	83 7d cc 08	 cmp	 DWORD PTR tv129[ebp], 8
  01895	74 0e		 je	 SHORT $L203021
  01897	eb 16		 jmp	 SHORT $L203017
$L203020:

; 621  : 		case 4:
; 622  : 			lpBMIH->biCompression = BI_RLE4;

  01899	8b 4d f4	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  0189c	c7 41 10 02 00
	00 00		 mov	 DWORD PTR [ecx+16], 2

; 623  : 			break;

  018a3	eb 0a		 jmp	 SHORT $L203017
$L203021:

; 624  : 		case 8:
; 625  : 			lpBMIH->biCompression = BI_RLE8;

  018a5	8b 55 f4	 mov	 edx, DWORD PTR _lpBMIH$[ebp]
  018a8	c7 42 10 01 00
	00 00		 mov	 DWORD PTR [edx+16], 1
$L203017:

; 626  : 			break;
; 627  : 		default:
; 628  : 			ASSERT(FALSE);
; 629  : 		}
; 630  : 		// calls GetDIBits with null data pointer to get size of compressed DIB
; 631  : 		if(!::GetDIBits(pDC->GetSafeHdc(), hBitmap, 0, (UINT) lpBMIH->biHeight,
; 632  : 						NULL, (LPBITMAPINFO) lpBMIH, DIB_RGB_COLORS)) {

  018af	6a 00		 push	 0
  018b1	8b 45 f4	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  018b4	50		 push	 eax
  018b5	6a 00		 push	 0
  018b7	8b 4d f4	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  018ba	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  018bd	52		 push	 edx
  018be	6a 00		 push	 0
  018c0	8b 45 f0	 mov	 eax, DWORD PTR _hBitmap$[ebp]
  018c3	50		 push	 eax
  018c4	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  018c7	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  018cc	50		 push	 eax
  018cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDIBits@28
  018d3	85 c0		 test	 eax, eax
  018d5	75 41		 jne	 SHORT $L203026

; 633  : 			AfxMessageBox("Unable to compress this DIB");

  018d7	6a 00		 push	 0
  018d9	6a 00		 push	 0
  018db	68 00 00 00 00	 push	 OFFSET FLAT:$SG203027
  018e0	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 634  : 			// probably a problem with the color table
; 635  : 	 		::DeleteObject(hBitmap);

  018e5	8b 4d f0	 mov	 ecx, DWORD PTR _hBitmap$[ebp]
  018e8	51		 push	 ecx
  018e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 636  : 			delete [] lpBMIH;

  018ef	8b 55 f4	 mov	 edx, DWORD PTR _lpBMIH$[ebp]
  018f2	89 55 dc	 mov	 DWORD PTR $T203842[ebp], edx
  018f5	8b 45 dc	 mov	 eax, DWORD PTR $T203842[ebp]
  018f8	50		 push	 eax
  018f9	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  018fe	83 c4 04	 add	 esp, 4

; 637  : 			::SelectPalette(hdc, hOldPalette, FALSE);

  01901	6a 00		 push	 0
  01903	8b 4d ec	 mov	 ecx, DWORD PTR _hOldPalette$[ebp]
  01906	51		 push	 ecx
  01907	8b 55 e8	 mov	 edx, DWORD PTR _hdc$[ebp]
  0190a	52		 push	 edx
  0190b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12

; 638  : 			return FALSE; 

  01911	33 c0		 xor	 eax, eax
  01913	e9 71 01 00 00	 jmp	 $L203001
$L203026:

; 639  : 		}
; 640  : 		if (lpBMIH->biSizeImage == 0) {

  01918	8b 45 f4	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  0191b	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0191f	75 41		 jne	 SHORT $L203029

; 641  : 			AfxMessageBox("Driver can't do compression");

  01921	6a 00		 push	 0
  01923	6a 00		 push	 0
  01925	68 00 00 00 00	 push	 OFFSET FLAT:$SG203030
  0192a	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 642  : 	 		::DeleteObject(hBitmap);

  0192f	8b 4d f0	 mov	 ecx, DWORD PTR _hBitmap$[ebp]
  01932	51		 push	 ecx
  01933	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 643  : 			delete [] lpBMIH;

  01939	8b 55 f4	 mov	 edx, DWORD PTR _lpBMIH$[ebp]
  0193c	89 55 d8	 mov	 DWORD PTR $T203843[ebp], edx
  0193f	8b 45 d8	 mov	 eax, DWORD PTR $T203843[ebp]
  01942	50		 push	 eax
  01943	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  01948	83 c4 04	 add	 esp, 4

; 644  : 			::SelectPalette(hdc, hOldPalette, FALSE);

  0194b	6a 00		 push	 0
  0194d	8b 4d ec	 mov	 ecx, DWORD PTR _hOldPalette$[ebp]
  01950	51		 push	 ecx
  01951	8b 55 e8	 mov	 edx, DWORD PTR _hdc$[ebp]
  01954	52		 push	 edx
  01955	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12

; 645  : 			return FALSE; 

  0195b	33 c0		 xor	 eax, eax
  0195d	e9 27 01 00 00	 jmp	 $L203001
$L203029:

; 646  : 		}
; 647  : 		else {
; 648  : 			m_dwSizeImage = lpBMIH->biSizeImage;

  01962	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  01965	8b 4d f4	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  01968	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0196b	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 649  : 		}
; 650  : 	}
; 651  : 	else {

  0196e	eb 6b		 jmp	 SHORT $L203033
$L203015:

; 652  : 		lpBMIH->biCompression = BI_RGB; // decompress

  01970	8b 45 f4	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  01973	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 653  : 		// figure the image size from the bitmap width and height
; 654  : 		DWORD dwBytes = ((DWORD) lpBMIH->biWidth * lpBMIH->biBitCount) / 32;

  0197a	8b 4d f4	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  0197d	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  01981	8b 45 f4	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  01984	0f af 50 04	 imul	 edx, DWORD PTR [eax+4]
  01988	c1 ea 05	 shr	 edx, 5
  0198b	89 55 e4	 mov	 DWORD PTR _dwBytes$203034[ebp], edx

; 655  : 		if(((DWORD) lpBMIH->biWidth * lpBMIH->biBitCount) % 32) {

  0198e	8b 4d f4	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  01991	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  01995	8b 45 f4	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  01998	8b ca		 mov	 ecx, edx
  0199a	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  0199e	8b c1		 mov	 eax, ecx
  019a0	33 d2		 xor	 edx, edx
  019a2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  019a7	f7 f1		 div	 ecx
  019a9	85 d2		 test	 edx, edx
  019ab	74 09		 je	 SHORT $L203037

; 656  : 			dwBytes++;

  019ad	8b 55 e4	 mov	 edx, DWORD PTR _dwBytes$203034[ebp]
  019b0	83 c2 01	 add	 edx, 1
  019b3	89 55 e4	 mov	 DWORD PTR _dwBytes$203034[ebp], edx
$L203037:

; 657  : 		}
; 658  : 		dwBytes *= 4;

  019b6	8b 45 e4	 mov	 eax, DWORD PTR _dwBytes$203034[ebp]
  019b9	c1 e0 02	 shl	 eax, 2
  019bc	89 45 e4	 mov	 DWORD PTR _dwBytes$203034[ebp], eax

; 659  : 		m_dwSizeImage = dwBytes * lpBMIH->biHeight; // no compression

  019bf	8b 4d f4	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  019c2	8b 55 e4	 mov	 edx, DWORD PTR _dwBytes$203034[ebp]
  019c5	0f af 51 08	 imul	 edx, DWORD PTR [ecx+8]
  019c9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  019cc	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 660  : 		lpBMIH->biSizeImage = m_dwSizeImage;

  019cf	8b 4d f4	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  019d2	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  019d5	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  019d8	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L203033:

; 661  : 	} 
; 662  : 	// second GetDIBits call to make DIB
; 663  : 	LPBYTE lpImage = (LPBYTE) new char[m_dwSizeImage];

  019db	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  019de	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  019e1	52		 push	 edx
  019e2	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  019e7	83 c4 04	 add	 esp, 4
  019ea	89 45 d4	 mov	 DWORD PTR $T203844[ebp], eax
  019ed	8b 45 d4	 mov	 eax, DWORD PTR $T203844[ebp]
  019f0	89 45 f8	 mov	 DWORD PTR _lpImage$[ebp], eax

; 664  : 	VERIFY(::GetDIBits(pDC->GetSafeHdc(), hBitmap, 0, (UINT) lpBMIH->biHeight,
; 665  :     		lpImage, (LPBITMAPINFO) lpBMIH, DIB_RGB_COLORS));

  019f3	6a 00		 push	 0
  019f5	8b 4d f4	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  019f8	51		 push	 ecx
  019f9	8b 55 f8	 mov	 edx, DWORD PTR _lpImage$[ebp]
  019fc	52		 push	 edx
  019fd	8b 45 f4	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  01a00	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01a03	51		 push	 ecx
  01a04	6a 00		 push	 0
  01a06	8b 55 f0	 mov	 edx, DWORD PTR _hBitmap$[ebp]
  01a09	52		 push	 edx
  01a0a	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01a0d	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01a12	50		 push	 eax
  01a13	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDIBits@28

; 666  :     TRACE("dib successfully created - height = %d\n", lpBMIH->biHeight);
; 667  : 	::DeleteObject(hBitmap);

  01a19	8b 45 f0	 mov	 eax, DWORD PTR _hBitmap$[ebp]
  01a1c	50		 push	 eax
  01a1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 668  : 	Empty();

  01a23	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  01a26	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 669  : 	m_nBmihAlloc = m_nImageAlloc = crtAlloc;

  01a2b	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  01a2e	c7 41 1c 01 00
	00 00		 mov	 DWORD PTR [ecx+28], 1
  01a35	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  01a38	c7 42 18 01 00
	00 00		 mov	 DWORD PTR [edx+24], 1

; 670  : 	m_lpBMIH = lpBMIH;

  01a3f	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  01a42	8b 4d f4	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  01a45	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 671  : 	m_lpImage = lpImage;

  01a48	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  01a4b	8b 45 f8	 mov	 eax, DWORD PTR _lpImage$[ebp]
  01a4e	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 672  : 	ComputeMetrics();

  01a51	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  01a54	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 673  : 	ComputePaletteSize(m_lpBMIH->biBitCount);

  01a59	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  01a5c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01a5f	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  01a63	50		 push	 eax
  01a64	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  01a67	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 674  : 	MakePalette();

  01a6c	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  01a6f	e8 00 00 00 00	 call	 ?MakePalette@CDib@@IAEHXZ ; CDib::MakePalette

; 675  : 	::SelectPalette(hdc, hOldPalette, FALSE);

  01a74	6a 00		 push	 0
  01a76	8b 4d ec	 mov	 ecx, DWORD PTR _hOldPalette$[ebp]
  01a79	51		 push	 ecx
  01a7a	8b 55 e8	 mov	 edx, DWORD PTR _hdc$[ebp]
  01a7d	52		 push	 edx
  01a7e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12

; 676  : 	TRACE("Compress: new palette size = %d\n", m_nColorTableEntries); 
; 677  : 	return TRUE;

  01a84	b8 01 00 00 00	 mov	 eax, 1
$L203001:

; 678  : }

  01a89	8b e5		 mov	 esp, ebp
  01a8b	5d		 pop	 ebp
  01a8c	c2 08 00	 ret	 8
?Compress@CDib@@IAEHPAVCDC@@H@Z ENDP			; CDib::Compress
_TEXT	ENDS
PUBLIC	?Read@CDib@@IAEHPAVCFile@@@Z			; CDib::Read
PUBLIC	__TI5PAVCUserException@@
PUBLIC	__CTA5PAVCUserException@@
PUBLIC	??_R0PAVCUserException@@@8			; CUserException * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAVCUserException@@@84
PUBLIC	??_R0PAVCSimpleException@@@8			; CSimpleException * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAVCSimpleException@@@84
PUBLIC	__CT??_R0PAVCException@@@84
PUBLIC	??_R0PAVCObject@@@8				; CObject * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAVCObject@@@84
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAX@84
PUBLIC	??0CUserException@@QAE@XZ			; CUserException::CUserException
EXTRN	__CxxThrowException@8:NEAR
xdata$x	SEGMENT
$T203869 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L203862
	DD	00H
	DD	FLAT:$L203863
	DD	0ffffffffH
	DD	00H
$T203871 DD	00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0ffffffd4H
	DD	FLAT:$L203861
$T203870 DD	00H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T203871
$T203867 DD	019930520H
	DD	04H
	DD	FLAT:$T203869
	DD	01H
	DD	FLAT:$T203870
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __TI5PAVCUserException@@
xdata$x	SEGMENT
__TI5PAVCUserException@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA5PAVCUserException@@
xdata$x	ENDS
;	COMDAT __CTA5PAVCUserException@@
xdata$x	SEGMENT
__CTA5PAVCUserException@@ DD 05H
	DD	FLAT:__CT??_R0PAVCUserException@@@84
	DD	FLAT:__CT??_R0PAVCSimpleException@@@84
	DD	FLAT:__CT??_R0PAVCException@@@84
	DD	FLAT:__CT??_R0PAVCObject@@@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCUserException@@@84
xdata$x	SEGMENT
__CT??_R0PAVCUserException@@@84 DD 01H
	DD	FLAT:??_R0PAVCUserException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAVCUserException@@@8
_DATA	SEGMENT
??_R0PAVCUserException@@@8 DD FLAT:??_7type_info@@6B@	; CUserException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCUserException@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0PAVCSimpleException@@@84
xdata$x	SEGMENT
__CT??_R0PAVCSimpleException@@@84 DD 01H
	DD	FLAT:??_R0PAVCSimpleException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAVCSimpleException@@@8
_DATA	SEGMENT
??_R0PAVCSimpleException@@@8 DD FLAT:??_7type_info@@6B@	; CSimpleException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCSimpleException@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0PAVCException@@@84
xdata$x	SEGMENT
__CT??_R0PAVCException@@@84 DD 01H
	DD	FLAT:??_R0PAVCException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCObject@@@84
xdata$x	SEGMENT
__CT??_R0PAVCObject@@@84 DD 01H
	DD	FLAT:??_R0PAVCObject@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAVCObject@@@8
_DATA	SEGMENT
??_R0PAVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCObject@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAX@8
_DATA	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
tv173 = -128						; size = 4
tv172 = -124						; size = 4
tv171 = -120						; size = 4
tv170 = -116						; size = 4
tv90 = -112						; size = 4
tv169 = -108						; size = 4
tv167 = -104						; size = 4
tv79 = -100						; size = 4
tv166 = -96						; size = 4
tv164 = -92						; size = 4
tv163 = -88						; size = 4
_this$ = -84						; size = 4
$T203859 = -80						; size = 4
$T203858 = -76						; size = 4
$T203857 = -72						; size = 4
$T203854 = -68						; size = 4
$T203853 = -64						; size = 4
$T203852 = -60						; size = 4
$T203848 = -56						; size = 4
$T203847 = -52						; size = 4
$T203846 = -48						; size = 4
_pe$203086 = -44					; size = 4
_bmfh$ = -40						; size = 14
_nCount$ = -24						; size = 4
_nSize$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_pFile$ = 8						; size = 4
?Read@CDib@@IAEHPAVCFile@@@Z PROC NEAR			; CDib::Read
; _this$ = ecx

; 681  : {

  01a90	55		 push	 ebp
  01a91	8b ec		 mov	 ebp, esp
  01a93	6a ff		 push	 -1
  01a95	68 00 00 00 00	 push	 __ehhandler$?Read@CDib@@IAEHPAVCFile@@@Z
  01a9a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01aa0	50		 push	 eax
  01aa1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01aa8	51		 push	 ecx
  01aa9	83 ec 70	 sub	 esp, 112		; 00000070H
  01aac	53		 push	 ebx
  01aad	56		 push	 esi
  01aae	57		 push	 edi
  01aaf	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  01ab2	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 682  : 	// 1. read file header to get size of info hdr + color table
; 683  : 	// 2. read info hdr (to get image size) and color table
; 684  : 	// 3. read image
; 685  : 	// can't use bfSize in file header
; 686  : 	Empty();

  01ab5	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  01ab8	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 687  : 	int nCount, nSize;
; 688  : 	BITMAPFILEHEADER bmfh;
; 689  : 	try {

  01abd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 690  : 		nCount = pFile->Read((LPVOID) &bmfh, sizeof(BITMAPFILEHEADER));

  01ac4	6a 0e		 push	 14			; 0000000eH
  01ac6	8d 45 d8	 lea	 eax, DWORD PTR _bmfh$[ebp]
  01ac9	50		 push	 eax
  01aca	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01acd	8b 11		 mov	 edx, DWORD PTR [ecx]
  01acf	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01ad2	ff 52 3c	 call	 DWORD PTR [edx+60]
  01ad5	89 45 a8	 mov	 DWORD PTR tv163[ebp], eax
  01ad8	8b 45 a8	 mov	 eax, DWORD PTR tv163[ebp]
  01adb	89 45 e8	 mov	 DWORD PTR _nCount$[ebp], eax

; 691  : 		if(nCount != sizeof(BITMAPFILEHEADER)) {

  01ade	83 7d e8 0e	 cmp	 DWORD PTR _nCount$[ebp], 14 ; 0000000eH
  01ae2	74 55		 je	 SHORT $L203056

; 692  : 			throw new CUserException;

  01ae4	68 98 00 00 00	 push	 152			; 00000098H
  01ae9	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  01aee	89 45 a4	 mov	 DWORD PTR tv164[ebp], eax
  01af1	8b 4d a4	 mov	 ecx, DWORD PTR tv164[ebp]
  01af4	89 4d c8	 mov	 DWORD PTR $T203848[ebp], ecx
  01af7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  01afb	83 7d c8 00	 cmp	 DWORD PTR $T203848[ebp], 0
  01aff	74 13		 je	 SHORT $L203849
  01b01	8b 4d c8	 mov	 ecx, DWORD PTR $T203848[ebp]
  01b04	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  01b09	89 45 a0	 mov	 DWORD PTR tv166[ebp], eax
  01b0c	8b 55 a0	 mov	 edx, DWORD PTR tv166[ebp]
  01b0f	89 55 9c	 mov	 DWORD PTR tv79[ebp], edx
  01b12	eb 07		 jmp	 SHORT $L203850
$L203849:
  01b14	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$L203850:
  01b1b	8b 45 9c	 mov	 eax, DWORD PTR tv79[ebp]
  01b1e	89 45 cc	 mov	 DWORD PTR $T203847[ebp], eax
  01b21	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  01b25	8b 4d cc	 mov	 ecx, DWORD PTR $T203847[ebp]
  01b28	89 4d d0	 mov	 DWORD PTR $T203846[ebp], ecx
  01b2b	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  01b30	8d 55 d0	 lea	 edx, DWORD PTR $T203846[ebp]
  01b33	52		 push	 edx
  01b34	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203056:

; 693  : 		}
; 694  : 		if(bmfh.bfType != 0x4d42) {

  01b39	0f b7 45 d8	 movzx	 eax, WORD PTR _bmfh$[ebp]
  01b3d	3d 42 4d 00 00	 cmp	 eax, 19778		; 00004d42H
  01b42	74 55		 je	 SHORT $L203073

; 695  : 			throw new CUserException;

  01b44	68 98 00 00 00	 push	 152			; 00000098H
  01b49	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  01b4e	89 45 98	 mov	 DWORD PTR tv167[ebp], eax
  01b51	8b 4d 98	 mov	 ecx, DWORD PTR tv167[ebp]
  01b54	89 4d bc	 mov	 DWORD PTR $T203854[ebp], ecx
  01b57	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  01b5b	83 7d bc 00	 cmp	 DWORD PTR $T203854[ebp], 0
  01b5f	74 13		 je	 SHORT $L203855
  01b61	8b 4d bc	 mov	 ecx, DWORD PTR $T203854[ebp]
  01b64	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  01b69	89 45 94	 mov	 DWORD PTR tv169[ebp], eax
  01b6c	8b 55 94	 mov	 edx, DWORD PTR tv169[ebp]
  01b6f	89 55 90	 mov	 DWORD PTR tv90[ebp], edx
  01b72	eb 07		 jmp	 SHORT $L203856
$L203855:
  01b74	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
$L203856:
  01b7b	8b 45 90	 mov	 eax, DWORD PTR tv90[ebp]
  01b7e	89 45 c0	 mov	 DWORD PTR $T203853[ebp], eax
  01b81	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  01b85	8b 4d c0	 mov	 ecx, DWORD PTR $T203853[ebp]
  01b88	89 4d c4	 mov	 DWORD PTR $T203852[ebp], ecx
  01b8b	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  01b90	8d 55 c4	 lea	 edx, DWORD PTR $T203852[ebp]
  01b93	52		 push	 edx
  01b94	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203073:

; 696  : 		}
; 697  : 		nSize = bmfh.bfOffBits - sizeof(BITMAPFILEHEADER);

  01b99	8b 45 e2	 mov	 eax, DWORD PTR _bmfh$[ebp+10]
  01b9c	83 e8 0e	 sub	 eax, 14			; 0000000eH
  01b9f	89 45 ec	 mov	 DWORD PTR _nSize$[ebp], eax

; 698  : 		m_lpBMIH = (LPBITMAPINFOHEADER) new char[nSize];

  01ba2	8b 4d ec	 mov	 ecx, DWORD PTR _nSize$[ebp]
  01ba5	51		 push	 ecx
  01ba6	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  01bab	83 c4 04	 add	 esp, 4
  01bae	89 45 8c	 mov	 DWORD PTR tv170[ebp], eax
  01bb1	8b 55 8c	 mov	 edx, DWORD PTR tv170[ebp]
  01bb4	89 55 b8	 mov	 DWORD PTR $T203857[ebp], edx
  01bb7	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  01bba	8b 4d b8	 mov	 ecx, DWORD PTR $T203857[ebp]
  01bbd	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 699  : 		m_nBmihAlloc = m_nImageAlloc = crtAlloc;

  01bc0	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  01bc3	c7 42 1c 01 00
	00 00		 mov	 DWORD PTR [edx+28], 1
  01bca	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  01bcd	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 700  : 		nCount = pFile->Read(m_lpBMIH, nSize); // info hdr & color table

  01bd4	8b 4d ec	 mov	 ecx, DWORD PTR _nSize$[ebp]
  01bd7	51		 push	 ecx
  01bd8	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  01bdb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01bde	50		 push	 eax
  01bdf	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01be2	8b 11		 mov	 edx, DWORD PTR [ecx]
  01be4	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01be7	ff 52 3c	 call	 DWORD PTR [edx+60]
  01bea	89 45 88	 mov	 DWORD PTR tv171[ebp], eax
  01bed	8b 45 88	 mov	 eax, DWORD PTR tv171[ebp]
  01bf0	89 45 e8	 mov	 DWORD PTR _nCount$[ebp], eax

; 701  : 		ComputeMetrics();

  01bf3	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  01bf6	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 702  : 		ComputePaletteSize(m_lpBMIH->biBitCount);

  01bfb	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  01bfe	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01c01	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  01c05	50		 push	 eax
  01c06	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  01c09	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 703  : 		MakePalette();

  01c0e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  01c11	e8 00 00 00 00	 call	 ?MakePalette@CDib@@IAEHXZ ; CDib::MakePalette

; 704  : 		m_lpImage = (LPBYTE) new char[m_dwSizeImage];

  01c16	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  01c19	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  01c1c	52		 push	 edx
  01c1d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  01c22	83 c4 04	 add	 esp, 4
  01c25	89 45 84	 mov	 DWORD PTR tv172[ebp], eax
  01c28	8b 45 84	 mov	 eax, DWORD PTR tv172[ebp]
  01c2b	89 45 b4	 mov	 DWORD PTR $T203858[ebp], eax
  01c2e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  01c31	8b 55 b4	 mov	 edx, DWORD PTR $T203858[ebp]
  01c34	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 705  : 		nCount = pFile->Read(m_lpImage, m_dwSizeImage); // image only

  01c37	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  01c3a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  01c3d	51		 push	 ecx
  01c3e	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  01c41	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  01c44	50		 push	 eax
  01c45	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01c48	8b 11		 mov	 edx, DWORD PTR [ecx]
  01c4a	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01c4d	ff 52 3c	 call	 DWORD PTR [edx+60]
  01c50	89 45 80	 mov	 DWORD PTR tv173[ebp], eax
  01c53	8b 45 80	 mov	 eax, DWORD PTR tv173[ebp]
  01c56	89 45 e8	 mov	 DWORD PTR _nCount$[ebp], eax
  01c59	eb 23		 jmp	 SHORT $L203860
$L203861:

; 706  : 	}
; 707  : 	catch(CException* pe) {
; 708  : 		AfxMessageBox("Read error");

  01c5b	6a 00		 push	 0
  01c5d	6a 00		 push	 0
  01c5f	68 00 00 00 00	 push	 OFFSET FLAT:$SG203087
  01c64	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 709  : 		pe->Delete();

  01c69	8b 4d d4	 mov	 ecx, DWORD PTR _pe$203086[ebp]
  01c6c	e8 00 00 00 00	 call	 ?Delete@CException@@QAEXXZ ; CException::Delete

; 710  : 		return FALSE;

  01c71	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T203859[ebp], 0
  01c78	b8 00 00 00 00	 mov	 eax, $L203865
  01c7d	c3		 ret	 0
$L203860:

; 711  : 	}

  01c7e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 712  : 	return TRUE;

  01c85	eb 05		 jmp	 SHORT $L203864
$L203865:

; 710  : 		return FALSE;

  01c87	8b 45 b0	 mov	 eax, DWORD PTR $T203859[ebp]
  01c8a	eb 05		 jmp	 SHORT $L203845
$L203864:

; 712  : 	return TRUE;

  01c8c	b8 01 00 00 00	 mov	 eax, 1
$L203845:

; 713  : }

  01c91	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  01c94	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01c9b	5f		 pop	 edi
  01c9c	5e		 pop	 esi
  01c9d	5b		 pop	 ebx
  01c9e	8b e5		 mov	 esp, ebp
  01ca0	5d		 pop	 ebp
  01ca1	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L203862:
  00095	8b 45 c8	 mov	 eax, DWORD PTR $T203848[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  0009e	c3		 ret	 0
$L203863:
  0009f	8b 45 bc	 mov	 eax, DWORD PTR $T203854[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  000a8	c3		 ret	 0
__ehhandler$?Read@CDib@@IAEHPAVCFile@@@Z:
  000a9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203867
  000ae	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Read@CDib@@IAEHPAVCFile@@@Z ENDP			; CDib::Read
PUBLIC	?ReadSection@CDib@@IAEHPAVCFile@@PAVCDC@@@Z	; CDib::ReadSection
xdata$x	SEGMENT
$T203900 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L203892
	DD	00H
	DD	FLAT:$L203893
	DD	00H
	DD	FLAT:$L203894
	DD	0ffffffffH
	DD	00H
$T203902 DD	00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0ffffffd4H
	DD	FLAT:$L203891
$T203901 DD	00H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T203902
$T203898 DD	019930520H
	DD	05H
	DD	FLAT:$T203900
	DD	01H
	DD	FLAT:$T203901
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv200 = -148						; size = 4
tv199 = -144						; size = 4
tv147 = -140						; size = 4
tv198 = -136						; size = 4
tv196 = -132						; size = 4
tv195 = -128						; size = 4
tv194 = -124						; size = 4
tv90 = -120						; size = 4
tv193 = -116						; size = 4
tv191 = -112						; size = 4
tv79 = -108						; size = 4
tv190 = -104						; size = 4
tv188 = -100						; size = 4
tv187 = -96						; size = 4
_this$ = -92						; size = 4
$T203889 = -88						; size = 4
$T203886 = -84						; size = 4
$T203885 = -80						; size = 4
$T203884 = -76						; size = 4
$T203883 = -72						; size = 4
$T203880 = -68						; size = 4
$T203879 = -64						; size = 4
$T203878 = -60						; size = 4
$T203875 = -56						; size = 4
$T203874 = -52						; size = 4
$T203873 = -48						; size = 4
_pe$203126 = -44					; size = 4
_bmfh$ = -40						; size = 14
_nCount$ = -24						; size = 4
_nSize$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_pFile$ = 8						; size = 4
_pDC$ = 12						; size = 4
?ReadSection@CDib@@IAEHPAVCFile@@PAVCDC@@@Z PROC NEAR	; CDib::ReadSection
; _this$ = ecx

; 716  : {

  01cb0	55		 push	 ebp
  01cb1	8b ec		 mov	 ebp, esp
  01cb3	6a ff		 push	 -1
  01cb5	68 00 00 00 00	 push	 __ehhandler$?ReadSection@CDib@@IAEHPAVCFile@@PAVCDC@@@Z
  01cba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01cc0	50		 push	 eax
  01cc1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01cc8	51		 push	 ecx
  01cc9	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  01ccf	53		 push	 ebx
  01cd0	56		 push	 esi
  01cd1	57		 push	 edi
  01cd2	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  01cd5	89 4d a4	 mov	 DWORD PTR _this$[ebp], ecx

; 717  : 	// new function reads BMP from disk and creates a DIB section
; 718  : 	//    allows modification of bitmaps from disk
; 719  : 	// 1. read file header to get size of info hdr + color table
; 720  : 	// 2. read info hdr (to get image size) and color table
; 721  : 	// 3. create DIB section based on header parms
; 722  : 	// 4. read image into memory that CreateDibSection allocates
; 723  : 	Empty();

  01cd8	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  01cdb	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 724  : 	int nCount, nSize;
; 725  : 	BITMAPFILEHEADER bmfh;
; 726  : 	try {

  01ce0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 727  : 		nCount = pFile->Read((LPVOID) &bmfh, sizeof(BITMAPFILEHEADER));

  01ce7	6a 0e		 push	 14			; 0000000eH
  01ce9	8d 45 d8	 lea	 eax, DWORD PTR _bmfh$[ebp]
  01cec	50		 push	 eax
  01ced	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01cf0	8b 11		 mov	 edx, DWORD PTR [ecx]
  01cf2	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01cf5	ff 52 3c	 call	 DWORD PTR [edx+60]
  01cf8	89 45 a0	 mov	 DWORD PTR tv187[ebp], eax
  01cfb	8b 45 a0	 mov	 eax, DWORD PTR tv187[ebp]
  01cfe	89 45 e8	 mov	 DWORD PTR _nCount$[ebp], eax

; 728  : 		if(nCount != sizeof(BITMAPFILEHEADER)) {

  01d01	83 7d e8 0e	 cmp	 DWORD PTR _nCount$[ebp], 14 ; 0000000eH
  01d05	74 55		 je	 SHORT $L203101

; 729  : 			throw new CUserException;

  01d07	68 98 00 00 00	 push	 152			; 00000098H
  01d0c	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  01d11	89 45 9c	 mov	 DWORD PTR tv188[ebp], eax
  01d14	8b 4d 9c	 mov	 ecx, DWORD PTR tv188[ebp]
  01d17	89 4d c8	 mov	 DWORD PTR $T203875[ebp], ecx
  01d1a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  01d1e	83 7d c8 00	 cmp	 DWORD PTR $T203875[ebp], 0
  01d22	74 13		 je	 SHORT $L203876
  01d24	8b 4d c8	 mov	 ecx, DWORD PTR $T203875[ebp]
  01d27	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  01d2c	89 45 98	 mov	 DWORD PTR tv190[ebp], eax
  01d2f	8b 55 98	 mov	 edx, DWORD PTR tv190[ebp]
  01d32	89 55 94	 mov	 DWORD PTR tv79[ebp], edx
  01d35	eb 07		 jmp	 SHORT $L203877
$L203876:
  01d37	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$L203877:
  01d3e	8b 45 94	 mov	 eax, DWORD PTR tv79[ebp]
  01d41	89 45 cc	 mov	 DWORD PTR $T203874[ebp], eax
  01d44	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  01d48	8b 4d cc	 mov	 ecx, DWORD PTR $T203874[ebp]
  01d4b	89 4d d0	 mov	 DWORD PTR $T203873[ebp], ecx
  01d4e	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  01d53	8d 55 d0	 lea	 edx, DWORD PTR $T203873[ebp]
  01d56	52		 push	 edx
  01d57	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203101:

; 730  : 		}
; 731  : 		if(bmfh.bfType != 0x4d42) {

  01d5c	0f b7 45 d8	 movzx	 eax, WORD PTR _bmfh$[ebp]
  01d60	3d 42 4d 00 00	 cmp	 eax, 19778		; 00004d42H
  01d65	74 55		 je	 SHORT $L203107

; 732  : 			throw new CUserException;

  01d67	68 98 00 00 00	 push	 152			; 00000098H
  01d6c	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  01d71	89 45 90	 mov	 DWORD PTR tv191[ebp], eax
  01d74	8b 4d 90	 mov	 ecx, DWORD PTR tv191[ebp]
  01d77	89 4d bc	 mov	 DWORD PTR $T203880[ebp], ecx
  01d7a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  01d7e	83 7d bc 00	 cmp	 DWORD PTR $T203880[ebp], 0
  01d82	74 13		 je	 SHORT $L203881
  01d84	8b 4d bc	 mov	 ecx, DWORD PTR $T203880[ebp]
  01d87	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  01d8c	89 45 8c	 mov	 DWORD PTR tv193[ebp], eax
  01d8f	8b 55 8c	 mov	 edx, DWORD PTR tv193[ebp]
  01d92	89 55 88	 mov	 DWORD PTR tv90[ebp], edx
  01d95	eb 07		 jmp	 SHORT $L203882
$L203881:
  01d97	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
$L203882:
  01d9e	8b 45 88	 mov	 eax, DWORD PTR tv90[ebp]
  01da1	89 45 c0	 mov	 DWORD PTR $T203879[ebp], eax
  01da4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  01da8	8b 4d c0	 mov	 ecx, DWORD PTR $T203879[ebp]
  01dab	89 4d c4	 mov	 DWORD PTR $T203878[ebp], ecx
  01dae	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  01db3	8d 55 c4	 lea	 edx, DWORD PTR $T203878[ebp]
  01db6	52		 push	 edx
  01db7	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203107:

; 733  : 		}
; 734  : 		nSize = bmfh.bfOffBits - sizeof(BITMAPFILEHEADER);

  01dbc	8b 45 e2	 mov	 eax, DWORD PTR _bmfh$[ebp+10]
  01dbf	83 e8 0e	 sub	 eax, 14			; 0000000eH
  01dc2	89 45 ec	 mov	 DWORD PTR _nSize$[ebp], eax

; 735  : 		m_lpBMIH = (LPBITMAPINFOHEADER) new char[nSize];

  01dc5	8b 4d ec	 mov	 ecx, DWORD PTR _nSize$[ebp]
  01dc8	51		 push	 ecx
  01dc9	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  01dce	83 c4 04	 add	 esp, 4
  01dd1	89 45 84	 mov	 DWORD PTR tv194[ebp], eax
  01dd4	8b 55 84	 mov	 edx, DWORD PTR tv194[ebp]
  01dd7	89 55 b8	 mov	 DWORD PTR $T203883[ebp], edx
  01dda	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  01ddd	8b 4d b8	 mov	 ecx, DWORD PTR $T203883[ebp]
  01de0	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 736  : 		m_nBmihAlloc = crtAlloc;

  01de3	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  01de6	c7 42 18 01 00
	00 00		 mov	 DWORD PTR [edx+24], 1

; 737  : 		m_nImageAlloc = noAlloc;

  01ded	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  01df0	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 738  : 		nCount = pFile->Read(m_lpBMIH, nSize); // info hdr & color table

  01df7	8b 4d ec	 mov	 ecx, DWORD PTR _nSize$[ebp]
  01dfa	51		 push	 ecx
  01dfb	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  01dfe	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01e01	50		 push	 eax
  01e02	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01e05	8b 11		 mov	 edx, DWORD PTR [ecx]
  01e07	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01e0a	ff 52 3c	 call	 DWORD PTR [edx+60]
  01e0d	89 45 80	 mov	 DWORD PTR tv195[ebp], eax
  01e10	8b 45 80	 mov	 eax, DWORD PTR tv195[ebp]
  01e13	89 45 e8	 mov	 DWORD PTR _nCount$[ebp], eax

; 739  : 		if(m_lpBMIH->biCompression != BI_RGB) {

  01e16	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  01e19	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01e1c	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  01e20	74 6a		 je	 SHORT $L203117

; 740  : 			throw new CUserException;

  01e22	68 98 00 00 00	 push	 152			; 00000098H
  01e27	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  01e2c	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv196[ebp], eax
  01e32	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  01e38	89 45 ac	 mov	 DWORD PTR $T203886[ebp], eax
  01e3b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  01e3f	83 7d ac 00	 cmp	 DWORD PTR $T203886[ebp], 0
  01e43	74 1c		 je	 SHORT $L203887
  01e45	8b 4d ac	 mov	 ecx, DWORD PTR $T203886[ebp]
  01e48	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  01e4d	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv198[ebp], eax
  01e53	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv198[ebp]
  01e59	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv147[ebp], ecx
  01e5f	eb 0a		 jmp	 SHORT $L203888
$L203887:
  01e61	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv147[ebp], 0
$L203888:
  01e6b	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv147[ebp]
  01e71	89 55 b0	 mov	 DWORD PTR $T203885[ebp], edx
  01e74	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  01e78	8b 45 b0	 mov	 eax, DWORD PTR $T203885[ebp]
  01e7b	89 45 b4	 mov	 DWORD PTR $T203884[ebp], eax
  01e7e	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  01e83	8d 4d b4	 lea	 ecx, DWORD PTR $T203884[ebp]
  01e86	51		 push	 ecx
  01e87	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203117:

; 741  : 		}
; 742  : 		ComputeMetrics();

  01e8c	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  01e8f	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 743  : 		ComputePaletteSize(m_lpBMIH->biBitCount);

  01e94	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  01e97	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01e9a	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  01e9e	51		 push	 ecx
  01e9f	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  01ea2	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 744  : 		MakePalette();

  01ea7	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  01eaa	e8 00 00 00 00	 call	 ?MakePalette@CDib@@IAEHXZ ; CDib::MakePalette

; 745  : 		UsePalette(pDC);

  01eaf	6a 00		 push	 0
  01eb1	8b 55 0c	 mov	 edx, DWORD PTR _pDC$[ebp]
  01eb4	52		 push	 edx
  01eb5	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  01eb8	e8 00 00 00 00	 call	 ?UsePalette@CDib@@IAEIPAVCDC@@H@Z ; CDib::UsePalette

; 746  : 		m_hBitmap = ::CreateDIBSection(pDC->GetSafeHdc(), (LPBITMAPINFO) m_lpBMIH,
; 747  : 			DIB_RGB_COLORS,	(LPVOID*) &m_lpImage, NULL, 0);

  01ebd	8b 4d 0c	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01ec0	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01ec5	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv199[ebp], eax
  01ecb	6a 00		 push	 0
  01ecd	6a 00		 push	 0
  01ecf	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  01ed2	83 c0 10	 add	 eax, 16			; 00000010H
  01ed5	50		 push	 eax
  01ed6	6a 00		 push	 0
  01ed8	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  01edb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01ede	52		 push	 edx
  01edf	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv199[ebp]
  01ee5	50		 push	 eax
  01ee6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBSection@24
  01eec	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  01eef	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 748  : 		ASSERT(m_lpImage != NULL);
; 749  : 		nCount = pFile->Read(m_lpImage, m_dwSizeImage); // image only

  01ef2	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  01ef5	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01ef8	50		 push	 eax
  01ef9	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  01efc	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  01eff	52		 push	 edx
  01f00	8b 45 08	 mov	 eax, DWORD PTR _pFile$[ebp]
  01f03	8b 10		 mov	 edx, DWORD PTR [eax]
  01f05	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01f08	ff 52 3c	 call	 DWORD PTR [edx+60]
  01f0b	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv200[ebp], eax
  01f11	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv200[ebp]
  01f17	89 45 e8	 mov	 DWORD PTR _nCount$[ebp], eax
  01f1a	eb 23		 jmp	 SHORT $L203890
$L203891:

; 750  : 	}
; 751  : 	catch(CException* pe) {
; 752  : 		AfxMessageBox("ReadSection error");

  01f1c	6a 00		 push	 0
  01f1e	6a 00		 push	 0
  01f20	68 00 00 00 00	 push	 OFFSET FLAT:$SG203127
  01f25	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 753  : 		pe->Delete();

  01f2a	8b 4d d4	 mov	 ecx, DWORD PTR _pe$203126[ebp]
  01f2d	e8 00 00 00 00	 call	 ?Delete@CException@@QAEXXZ ; CException::Delete

; 754  : 		return FALSE;

  01f32	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T203889[ebp], 0
  01f39	b8 00 00 00 00	 mov	 eax, $L203896
  01f3e	c3		 ret	 0
$L203890:

; 755  : 	}

  01f3f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 756  : 	return TRUE;

  01f46	eb 05		 jmp	 SHORT $L203895
$L203896:

; 754  : 		return FALSE;

  01f48	8b 45 a8	 mov	 eax, DWORD PTR $T203889[ebp]
  01f4b	eb 05		 jmp	 SHORT $L203872
$L203895:

; 756  : 	return TRUE;

  01f4d	b8 01 00 00 00	 mov	 eax, 1
$L203872:

; 757  : }

  01f52	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  01f55	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01f5c	5f		 pop	 edi
  01f5d	5e		 pop	 esi
  01f5e	5b		 pop	 ebx
  01f5f	8b e5		 mov	 esp, ebp
  01f61	5d		 pop	 ebp
  01f62	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
$L203892:
  000b3	8b 45 c8	 mov	 eax, DWORD PTR $T203875[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  000bc	c3		 ret	 0
$L203893:
  000bd	8b 45 bc	 mov	 eax, DWORD PTR $T203880[ebp]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  000c6	c3		 ret	 0
$L203894:
  000c7	8b 45 ac	 mov	 eax, DWORD PTR $T203886[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  000d0	c3		 ret	 0
__ehhandler$?ReadSection@CDib@@IAEHPAVCFile@@PAVCDC@@@Z:
  000d1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203898
  000d6	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ReadSection@CDib@@IAEHPAVCFile@@PAVCDC@@@Z ENDP	; CDib::ReadSection
PUBLIC	?Write@CDib@@IAEHPAVCFile@@@Z			; CDib::Write
xdata$x	SEGMENT
$T203912 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T203914 DD	00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0ffffffd8H
	DD	FLAT:$L203906
$T203913 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T203914
$T203910 DD	019930520H
	DD	02H
	DD	FLAT:$T203912
	DD	01H
	DD	FLAT:$T203913
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T203904 = -44						; size = 4
_pe$203145 = -40					; size = 4
_bmfh$ = -36						; size = 14
_nSizeHdr$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pFile$ = 8						; size = 4
?Write@CDib@@IAEHPAVCFile@@@Z PROC NEAR			; CDib::Write
; _this$ = ecx

; 760  : {

  01f70	55		 push	 ebp
  01f71	8b ec		 mov	 ebp, esp
  01f73	6a ff		 push	 -1
  01f75	68 00 00 00 00	 push	 __ehhandler$?Write@CDib@@IAEHPAVCFile@@@Z
  01f7a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01f80	50		 push	 eax
  01f81	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01f88	51		 push	 ecx
  01f89	83 ec 20	 sub	 esp, 32			; 00000020H
  01f8c	53		 push	 ebx
  01f8d	56		 push	 esi
  01f8e	57		 push	 edi
  01f8f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  01f92	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 761  : 	BITMAPFILEHEADER bmfh;
; 762  : 	bmfh.bfType = 0x4d42;  // 'BM'

  01f95	66 c7 45 dc 42
	4d		 mov	 WORD PTR _bmfh$[ebp], 19778 ; 00004d42H

; 763  : 	int nSizeHdr = sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * m_nColorTableEntries;

  01f9b	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  01f9e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01fa1	8d 14 8d 28 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+40]
  01fa8	89 55 ec	 mov	 DWORD PTR _nSizeHdr$[ebp], edx

; 764  : 	bmfh.bfSize = 0;

  01fab	c7 45 de 00 00
	00 00		 mov	 DWORD PTR _bmfh$[ebp+2], 0

; 765  : //	bmfh.bfSize = sizeof(BITMAPFILEHEADER) + nSizeHdr + m_dwSizeImage;
; 766  : 	// meaning of bfSize open to interpretation (bytes, words, dwords?) -- we won't use it
; 767  : 	bmfh.bfReserved1 = bmfh.bfReserved2 = 0;

  01fb2	66 c7 45 e4 00
	00		 mov	 WORD PTR _bmfh$[ebp+8], 0
  01fb8	66 8b 45 e4	 mov	 ax, WORD PTR _bmfh$[ebp+8]
  01fbc	66 89 45 e2	 mov	 WORD PTR _bmfh$[ebp+6], ax

; 768  : 	bmfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) +
; 769  : 			sizeof(RGBQUAD) * m_nColorTableEntries;	

  01fc0	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  01fc3	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  01fc6	8d 04 95 36 00
	00 00		 lea	 eax, DWORD PTR [edx*4+54]
  01fcd	89 45 e6	 mov	 DWORD PTR _bmfh$[ebp+10], eax

; 770  : 	try {

  01fd0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 771  : 		pFile->Write((LPVOID) &bmfh, sizeof(BITMAPFILEHEADER));

  01fd7	6a 0e		 push	 14			; 0000000eH
  01fd9	8d 4d dc	 lea	 ecx, DWORD PTR _bmfh$[ebp]
  01fdc	51		 push	 ecx
  01fdd	8b 55 08	 mov	 edx, DWORD PTR _pFile$[ebp]
  01fe0	8b 02		 mov	 eax, DWORD PTR [edx]
  01fe2	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01fe5	ff 50 40	 call	 DWORD PTR [eax+64]

; 772  : 		pFile->Write((LPVOID) m_lpBMIH,  nSizeHdr);

  01fe8	8b 4d ec	 mov	 ecx, DWORD PTR _nSizeHdr$[ebp]
  01feb	51		 push	 ecx
  01fec	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  01fef	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01ff2	50		 push	 eax
  01ff3	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01ff6	8b 11		 mov	 edx, DWORD PTR [ecx]
  01ff8	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  01ffb	ff 52 40	 call	 DWORD PTR [edx+64]

; 773  : 		pFile->Write((LPVOID) m_lpImage, m_dwSizeImage);

  01ffe	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  02001	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  02004	51		 push	 ecx
  02005	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  02008	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0200b	50		 push	 eax
  0200c	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  0200f	8b 11		 mov	 edx, DWORD PTR [ecx]
  02011	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  02014	ff 52 40	 call	 DWORD PTR [edx+64]
  02017	eb 23		 jmp	 SHORT $L203905
$L203906:

; 774  : 	}
; 775  : 	catch(CException* pe) {
; 776  : 		pe->Delete();

  02019	8b 4d d8	 mov	 ecx, DWORD PTR _pe$203145[ebp]
  0201c	e8 00 00 00 00	 call	 ?Delete@CException@@QAEXXZ ; CException::Delete

; 777  : 		AfxMessageBox("write error");

  02021	6a 00		 push	 0
  02023	6a 00		 push	 0
  02025	68 00 00 00 00	 push	 OFFSET FLAT:$SG203146
  0202a	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 778  : 		return FALSE;

  0202f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T203904[ebp], 0
  02036	b8 00 00 00 00	 mov	 eax, $L203908
  0203b	c3		 ret	 0
$L203905:

; 779  : 	}

  0203c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 780  : 	return TRUE;

  02043	eb 05		 jmp	 SHORT $L203907
$L203908:

; 778  : 		return FALSE;

  02045	8b 45 d4	 mov	 eax, DWORD PTR $T203904[ebp]
  02048	eb 05		 jmp	 SHORT $L203132
$L203907:

; 780  : 	return TRUE;

  0204a	b8 01 00 00 00	 mov	 eax, 1
$L203132:

; 781  : }

  0204f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  02052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02059	5f		 pop	 edi
  0205a	5e		 pop	 esi
  0205b	5b		 pop	 ebx
  0205c	8b e5		 mov	 esp, ebp
  0205e	5d		 pop	 ebp
  0205f	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$?Write@CDib@@IAEHPAVCFile@@@Z:
  000db	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203910
  000e0	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Write@CDib@@IAEHPAVCFile@@@Z ENDP			; CDib::Write
PUBLIC	?IsStoring@CArchive@@QBEHXZ			; CArchive::IsStoring
PUBLIC	?GetFile@CArchive@@QBEPAVCFile@@XZ		; CArchive::GetFile
EXTRN	?Flush@CArchive@@QAEXXZ:NEAR			; CArchive::Flush
; Function compile flags: /Odt
_TEXT	SEGMENT
tv76 = -16						; size = 4
tv67 = -12						; size = 4
_this$ = -8						; size = 4
_dwPos$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@CDib@@MAEXAAVCArchive@@@Z PROC NEAR		; CDib::Serialize
; _this$ = ecx

; 784  : {

  02070	55		 push	 ebp
  02071	8b ec		 mov	 ebp, esp
  02073	83 ec 10	 sub	 esp, 16			; 00000010H
  02076	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 785  : 	DWORD dwPos;
; 786  : 	dwPos = (DWORD)ar.GetFile()->GetPosition();

  02079	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0207c	e8 00 00 00 00	 call	 ?GetFile@CArchive@@QBEPAVCFile@@XZ ; CArchive::GetFile
  02081	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  02084	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  02087	8b 10		 mov	 edx, DWORD PTR [eax]
  02089	8b 4d f4	 mov	 ecx, DWORD PTR tv67[ebp]
  0208c	ff 52 14	 call	 DWORD PTR [edx+20]
  0208f	89 45 fc	 mov	 DWORD PTR _dwPos$[ebp], eax

; 787  : 	TRACE("CDib::Serialize -- pos = %d\n", dwPos);
; 788  : 	ar.Flush();

  02092	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  02095	e8 00 00 00 00	 call	 ?Flush@CArchive@@QAEXXZ	; CArchive::Flush

; 789  : 	dwPos = (DWORD)ar.GetFile()->GetPosition();

  0209a	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0209d	e8 00 00 00 00	 call	 ?GetFile@CArchive@@QBEPAVCFile@@XZ ; CArchive::GetFile
  020a2	89 45 f0	 mov	 DWORD PTR tv76[ebp], eax
  020a5	8b 45 f0	 mov	 eax, DWORD PTR tv76[ebp]
  020a8	8b 10		 mov	 edx, DWORD PTR [eax]
  020aa	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  020ad	ff 52 14	 call	 DWORD PTR [edx+20]
  020b0	89 45 fc	 mov	 DWORD PTR _dwPos$[ebp], eax

; 790  : 	TRACE("CDib::Serialize -- pos = %d\n", dwPos);
; 791  : 	if(ar.IsStoring()) {

  020b3	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  020b6	e8 00 00 00 00	 call	 ?IsStoring@CArchive@@QBEHXZ ; CArchive::IsStoring
  020bb	85 c0		 test	 eax, eax
  020bd	74 13		 je	 SHORT $L203155

; 792  : 		Write(ar.GetFile());

  020bf	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  020c2	e8 00 00 00 00	 call	 ?GetFile@CArchive@@QBEPAVCFile@@XZ ; CArchive::GetFile
  020c7	50		 push	 eax
  020c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  020cb	e8 00 00 00 00	 call	 ?Write@CDib@@IAEHPAVCFile@@@Z ; CDib::Write

; 793  : 	}
; 794  : 	else {

  020d0	eb 11		 jmp	 SHORT $L203151
$L203155:

; 795  : 		Read(ar.GetFile());

  020d2	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  020d5	e8 00 00 00 00	 call	 ?GetFile@CArchive@@QBEPAVCFile@@XZ ; CArchive::GetFile
  020da	50		 push	 eax
  020db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  020de	e8 00 00 00 00	 call	 ?Read@CDib@@IAEHPAVCFile@@@Z ; CDib::Read
$L203151:

; 796  : 	}
; 797  : }

  020e3	8b e5		 mov	 esp, ebp
  020e5	5d		 pop	 ebp
  020e6	c2 04 00	 ret	 4
?Serialize@CDib@@MAEXAAVCArchive@@@Z ENDP		; CDib::Serialize
; Function compile flags: /Odt
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_nBitCount$ = 8						; size = 4
?ComputePaletteSize@CDib@@AAEXH@Z PROC NEAR		; CDib::ComputePaletteSize
; _this$ = ecx

; 801  : {

  020f0	55		 push	 ebp
  020f1	8b ec		 mov	 ebp, esp
  020f3	83 ec 08	 sub	 esp, 8
  020f6	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 	if((m_lpBMIH == NULL) || (m_lpBMIH->biClrUsed == 0)) {

  020f9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  020fc	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  02100	74 0c		 je	 SHORT $L203162
  02102	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02105	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02108	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0210c	75 56		 jne	 SHORT $L203161
$L203162:

; 803  : 		switch(nBitCount) {

  0210e	8b 45 08	 mov	 eax, DWORD PTR _nBitCount$[ebp]
  02111	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  02114	8b 4d f8	 mov	 ecx, DWORD PTR tv69[ebp]
  02117	83 e9 01	 sub	 ecx, 1
  0211a	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
  0211d	83 7d f8 1f	 cmp	 DWORD PTR tv69[ebp], 31	; 0000001fH
  02121	77 3f		 ja	 SHORT $L203164
  02123	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  02126	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $L203917[edx]
  0212d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L203918[eax*4]
$L203167:

; 804  : 			case 1:
; 805  : 				m_nColorTableEntries = 2;

  02134	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02137	c7 41 24 02 00
	00 00		 mov	 DWORD PTR [ecx+36], 2

; 806  : 				break;

  0213e	eb 22		 jmp	 SHORT $L203164
$L203168:

; 807  : 			case 4:
; 808  : 				m_nColorTableEntries = 16;

  02140	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02143	c7 42 24 10 00
	00 00		 mov	 DWORD PTR [edx+36], 16	; 00000010H

; 809  : 				break;

  0214a	eb 16		 jmp	 SHORT $L203164
$L203169:

; 810  : 			case 8:
; 811  : 				m_nColorTableEntries = 256;

  0214c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0214f	c7 40 24 00 01
	00 00		 mov	 DWORD PTR [eax+36], 256	; 00000100H

; 812  : 				break;

  02156	eb 0a		 jmp	 SHORT $L203164
$L203170:

; 813  : 			case 16:
; 814  : 			case 24:
; 815  : 			case 32:
; 816  : 				m_nColorTableEntries = 0;

  02158	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0215b	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
$L203164:

; 817  : 				break;
; 818  : 			default:
; 819  : 				ASSERT(FALSE);
; 820  : 		}
; 821  : 	}
; 822  : 	else {

  02162	eb 0f		 jmp	 SHORT $L203160
$L203161:

; 823  : 		m_nColorTableEntries = m_lpBMIH->biClrUsed;

  02164	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02167	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0216a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0216d	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  02170	89 51 24	 mov	 DWORD PTR [ecx+36], edx
$L203160:

; 824  : 	}
; 825  : 	ASSERT((m_nColorTableEntries >= 0) && (m_nColorTableEntries <= 256)); 
; 826  : }

  02173	8b e5		 mov	 esp, ebp
  02175	5d		 pop	 ebp
  02176	c2 04 00	 ret	 4
$L203918:
  02179	00 00 00 00	 DD	 $L203167
  0217d	00 00 00 00	 DD	 $L203168
  02181	00 00 00 00	 DD	 $L203169
  02185	00 00 00 00	 DD	 $L203170
  02189	00 00 00 00	 DD	 $L203164
$L203917:
  0218d	00		 DB	 0
  0218e	04		 DB	 4
  0218f	04		 DB	 4
  02190	01		 DB	 1
  02191	04		 DB	 4
  02192	04		 DB	 4
  02193	04		 DB	 4
  02194	02		 DB	 2
  02195	04		 DB	 4
  02196	04		 DB	 4
  02197	04		 DB	 4
  02198	04		 DB	 4
  02199	04		 DB	 4
  0219a	04		 DB	 4
  0219b	04		 DB	 4
  0219c	03		 DB	 3
  0219d	04		 DB	 4
  0219e	04		 DB	 4
  0219f	04		 DB	 4
  021a0	04		 DB	 4
  021a1	04		 DB	 4
  021a2	04		 DB	 4
  021a3	04		 DB	 4
  021a4	03		 DB	 3
  021a5	04		 DB	 4
  021a6	04		 DB	 4
  021a7	04		 DB	 4
  021a8	04		 DB	 4
  021a9	04		 DB	 4
  021aa	04		 DB	 4
  021ab	04		 DB	 4
  021ac	03		 DB	 3
?ComputePaletteSize@CDib@@AAEXH@Z ENDP			; CDib::ComputePaletteSize
_TEXT	ENDS
xdata$x	SEGMENT
$T203929 DD	0ffffffffH
	DD	FLAT:$L203925
$T203927 DD	019930520H
	DD	01H
	DD	FLAT:$T203929
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv74 = -36						; size = 4
_this$ = -32						; size = 4
$T203922 = -28						; size = 4
$T203921 = -24						; size = 4
$T203920 = -20						; size = 4
_dwBytes$203186 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ComputeMetrics@CDib@@AAEXXZ PROC NEAR			; CDib::ComputeMetrics
; _this$ = ecx

; 829  : {

  021b0	55		 push	 ebp
  021b1	8b ec		 mov	 ebp, esp
  021b3	6a ff		 push	 -1
  021b5	68 00 00 00 00	 push	 __ehhandler$?ComputeMetrics@CDib@@AAEXXZ
  021ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  021c0	50		 push	 eax
  021c1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  021c8	83 ec 18	 sub	 esp, 24			; 00000018H
  021cb	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 830  : 	if(m_lpBMIH->biSize != sizeof(BITMAPINFOHEADER)) {

  021ce	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  021d1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  021d4	83 39 28	 cmp	 DWORD PTR [ecx], 40	; 00000028H
  021d7	74 4f		 je	 SHORT $L203179

; 831  : 		TRACE("Not a valid Windows bitmap -- probably an OS/2 bitmap\n");
; 832  : 		throw new CUserException;

  021d9	68 98 00 00 00	 push	 152			; 00000098H
  021de	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  021e3	89 45 e4	 mov	 DWORD PTR $T203922[ebp], eax
  021e6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  021ed	83 7d e4 00	 cmp	 DWORD PTR $T203922[ebp], 0
  021f1	74 0d		 je	 SHORT $L203923
  021f3	8b 4d e4	 mov	 ecx, DWORD PTR $T203922[ebp]
  021f6	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  021fb	89 45 dc	 mov	 DWORD PTR tv74[ebp], eax
  021fe	eb 07		 jmp	 SHORT $L203924
$L203923:
  02200	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L203924:
  02207	8b 55 dc	 mov	 edx, DWORD PTR tv74[ebp]
  0220a	89 55 e8	 mov	 DWORD PTR $T203921[ebp], edx
  0220d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02214	8b 45 e8	 mov	 eax, DWORD PTR $T203921[ebp]
  02217	89 45 ec	 mov	 DWORD PTR $T203920[ebp], eax
  0221a	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  0221f	8d 4d ec	 lea	 ecx, DWORD PTR $T203920[ebp]
  02222	51		 push	 ecx
  02223	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203179:

; 833  : 	}
; 834  : 	m_dwSizeImage = m_lpBMIH->biSizeImage;

  02228	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0222b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0222e	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  02231	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  02234	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 835  : 	if(m_dwSizeImage == 0) {

  02237	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0223a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0223e	75 60		 jne	 SHORT $L203185

; 836  : 		DWORD dwBytes = ((DWORD) m_lpBMIH->biWidth * m_lpBMIH->biBitCount) / 32;

  02240	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  02243	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02246	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  02249	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0224c	0f b7 41 0e	 movzx	 eax, WORD PTR [ecx+14]
  02250	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  02254	c1 e8 05	 shr	 eax, 5
  02257	89 45 f0	 mov	 DWORD PTR _dwBytes$203186[ebp], eax

; 837  : 		if(((DWORD) m_lpBMIH->biWidth * m_lpBMIH->biBitCount) % 32) {

  0225a	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0225d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02260	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  02263	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02266	0f b7 41 0e	 movzx	 eax, WORD PTR [ecx+14]
  0226a	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  0226e	33 d2		 xor	 edx, edx
  02270	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  02275	f7 f1		 div	 ecx
  02277	85 d2		 test	 edx, edx
  02279	74 09		 je	 SHORT $L203189

; 838  : 			dwBytes++;

  0227b	8b 55 f0	 mov	 edx, DWORD PTR _dwBytes$203186[ebp]
  0227e	83 c2 01	 add	 edx, 1
  02281	89 55 f0	 mov	 DWORD PTR _dwBytes$203186[ebp], edx
$L203189:

; 839  : 		}
; 840  : 		dwBytes *= 4;

  02284	8b 45 f0	 mov	 eax, DWORD PTR _dwBytes$203186[ebp]
  02287	c1 e0 02	 shl	 eax, 2
  0228a	89 45 f0	 mov	 DWORD PTR _dwBytes$203186[ebp], eax

; 841  : 		m_dwSizeImage = dwBytes * m_lpBMIH->biHeight; // no compression

  0228d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  02290	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02293	8b 45 f0	 mov	 eax, DWORD PTR _dwBytes$203186[ebp]
  02296	0f af 42 08	 imul	 eax, DWORD PTR [edx+8]
  0229a	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0229d	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$L203185:

; 842  : 	}
; 843  : 	m_lpvColorTable = (LPBYTE) m_lpBMIH + sizeof(BITMAPINFOHEADER);

  022a0	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  022a3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  022a6	83 c0 28	 add	 eax, 40			; 00000028H
  022a9	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  022ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L203919:

; 844  : }

  022af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  022b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  022b9	8b e5		 mov	 esp, ebp
  022bb	5d		 pop	 ebp
  022bc	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L203925:
  000e5	8b 45 e4	 mov	 eax, DWORD PTR $T203922[ebp]
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  000ee	c3		 ret	 0
__ehhandler$?ComputeMetrics@CDib@@AAEXXZ:
  000ef	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203927
  000f4	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ComputeMetrics@CDib@@AAEXXZ ENDP			; CDib::ComputeMetrics
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T203932 = -8						; size = 4
$T203931 = -4						; size = 4
?Empty@CDib@@QAEXXZ PROC NEAR				; CDib::Empty
; _this$ = ecx

; 847  : {

  022c0	55		 push	 ebp
  022c1	8b ec		 mov	 ebp, esp
  022c3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  022c6	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 848  : 	// this is supposed to clean up whatever is in the DIB
; 849  : 	DetachMapFile();

  022c9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  022cc	e8 00 00 00 00	 call	 ?DetachMapFile@CDib@@AAEXXZ ; CDib::DetachMapFile

; 850  : 	if(m_nBmihAlloc == crtAlloc) {

  022d1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  022d4	83 78 18 01	 cmp	 DWORD PTR [eax+24], 1
  022d8	75 17		 jne	 SHORT $L203195

; 851  : 		delete [] m_lpBMIH;

  022da	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  022dd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  022e0	89 55 fc	 mov	 DWORD PTR $T203931[ebp], edx
  022e3	8b 45 fc	 mov	 eax, DWORD PTR $T203931[ebp]
  022e6	50		 push	 eax
  022e7	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  022ec	83 c4 04	 add	 esp, 4

; 852  : 	}
; 853  : 	else if(m_nBmihAlloc == heapAlloc) {

  022ef	eb 23		 jmp	 SHORT $L203197
$L203195:
  022f1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  022f4	83 79 18 02	 cmp	 DWORD PTR [ecx+24], 2
  022f8	75 1a		 jne	 SHORT $L203197

; 854  : 		::GlobalUnlock(m_hGlobal);

  022fa	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  022fd	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  02300	50		 push	 eax
  02301	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 855  : 		::GlobalFree(m_hGlobal);

  02307	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0230a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0230d	52		 push	 edx
  0230e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
$L203197:

; 856  : 	}
; 857  : 	if(m_nImageAlloc == crtAlloc) delete [] m_lpImage;

  02314	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  02317	83 78 1c 01	 cmp	 DWORD PTR [eax+28], 1
  0231b	75 15		 jne	 SHORT $L203199
  0231d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02320	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  02323	89 55 f8	 mov	 DWORD PTR $T203932[ebp], edx
  02326	8b 45 f8	 mov	 eax, DWORD PTR $T203932[ebp]
  02329	50		 push	 eax
  0232a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0232f	83 c4 04	 add	 esp, 4
$L203199:

; 858  : 	if(m_hPalette != NULL) ::DeleteObject(m_hPalette);

  02332	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02335	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  02339	74 0d		 je	 SHORT $L203201
  0233b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0233e	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  02341	50		 push	 eax
  02342	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$L203201:

; 859  : 	if(m_hBitmap != NULL) ::DeleteObject(m_hBitmap);

  02348	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0234b	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0234f	74 0d		 je	 SHORT $L203202
  02351	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  02354	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  02357	50		 push	 eax
  02358	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$L203202:

; 860  : 	m_nBmihAlloc = m_nImageAlloc = noAlloc;

  0235e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02361	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  02368	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0236b	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 861  : 	m_hGlobal = NULL;

  02372	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  02375	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 862  : 	m_lpBMIH = NULL;

  0237c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0237f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 863  : 	//m_lpImage = NULL;
; 864  : 	m_lpvColorTable = NULL;

  02386	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  02389	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 865  : 	m_nColorTableEntries = 0;

  02390	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  02393	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 866  : 	m_dwSizeImage = 0;

  0239a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0239d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 867  : 	//m_lpvFile = NULL;
; 868  : 	m_hMap = NULL;

  023a4	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  023a7	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 869  : 	m_hFile = NULL;

  023ae	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  023b1	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 870  : 	m_hBitmap = NULL;

  023b8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  023bb	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 871  : 	m_hPalette = NULL;

  023c2	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  023c5	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 872  : }

  023cc	8b e5		 mov	 esp, ebp
  023ce	5d		 pop	 ebp
  023cf	c3		 ret	 0
?Empty@CDib@@QAEXXZ ENDP				; CDib::Empty
; Function compile flags: /Odt
_this$ = -4						; size = 4
?DetachMapFile@CDib@@AAEXXZ PROC NEAR			; CDib::DetachMapFile
; _this$ = ecx

; 875  : {

  023d0	55		 push	 ebp
  023d1	8b ec		 mov	 ebp, esp
  023d3	51		 push	 ecx
  023d4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 876  : 
; 877  : 	return;
; 878  : 	//if(m_hFile == NULL) return;
; 879  : 	//::UnmapViewOfFile(m_lpvFile);
; 880  : 	//::CloseHandle(m_hMap);
; 881  : 	//::CloseHandle(m_hFile);
; 882  : 	//m_hFile = NULL;
; 883  : }

  023d7	8b e5		 mov	 esp, ebp
  023d9	5d		 pop	 ebp
  023da	c3		 ret	 0
?DetachMapFile@CDib@@AAEXXZ ENDP			; CDib::DetachMapFile
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initCX$ = 8						; size = 4
_initCY$ = 12						; size = 4
??0CSize@@QAE@HH@Z PROC NEAR				; CSize::CSize, COMDAT
; _this$ = ecx

; 24   : 	{ cx = initCX; cy = initCY; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _initCX$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _initCY$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0CSize@@QAE@HH@Z ENDP					; CSize::CSize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRect@@QAE@XZ PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 110  : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CRect@@QAE@XZ ENDP					; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Width@CRect@@QBEHXZ PROC NEAR				; CRect::Width, COMDAT
; _this$ = ecx

; 123  : 	{ return right - left; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Width@CRect@@QBEHXZ ENDP				; CRect::Width
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Height@CRect@@QBEHXZ PROC NEAR				; CRect::Height, COMDAT
; _this$ = ecx

; 125  : 	{ return bottom - top; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?Height@CRect@@QBEHXZ ENDP				; CRect::Height
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CObject@@IAE@XZ PROC NEAR				; CObject::CObject, COMDAT
; _this$ = ecx

; 21   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CObject@@IAE@XZ ENDP					; CObject::CObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CObject@@UAE@XZ PROC NEAR				; CObject::~CObject, COMDAT
; _this$ = ecx

; 23   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC NEAR				; CObject::operator delete, COMDAT

; 31   : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??2CObject@@SGPAXI@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
??2CObject@@SGPAXI@Z PROC NEAR				; CObject::operator new, COMDAT

; 37   : 	{ return ::operator new(nSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _nSize$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??2CObject@@SGPAXI@Z ENDP				; CObject::operator new
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AssertValid@CObject@@UBEXXZ PROC NEAR			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 41   : 	{ /* no asserts in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC NEAR	; CObject::Dump, COMDAT
; _this$ = ecx

; 43   : 	{ /* no dumping in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SeekToBegin@CFile@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SeekToBegin@CFile@@QAEXXZ PROC NEAR			; CFile::SeekToBegin, COMDAT
; _this$ = ecx

; 99   : 	{ Seek(0, CFile::begin); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	ff 52 30	 call	 DWORD PTR [edx+48]
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?SeekToBegin@CFile@@QAEXXZ ENDP				; CFile::SeekToBegin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsStoring@CArchive@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStoring@CArchive@@QBEHXZ PROC NEAR			; CArchive::IsStoring, COMDAT
; _this$ = ecx

; 133  : 	{ return (m_nMode & CArchive::load) == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000d	83 e0 01	 and	 eax, 1
  00010	f7 d8		 neg	 eax
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?IsStoring@CArchive@@QBEHXZ ENDP			; CArchive::IsStoring
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetFile@CArchive@@QBEPAVCFile@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFile@CArchive@@QBEPAVCFile@@XZ PROC NEAR		; CArchive::GetFile, COMDAT
; _this$ = ecx

; 139  : 	{ return m_pFile; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetFile@CArchive@@QBEPAVCFile@@XZ ENDP			; CArchive::GetFile
_TEXT	ENDS
PUBLIC	??0CSimpleException@@QAE@XZ			; CSimpleException::CSimpleException
PUBLIC	??_R1A@?0A@A@CSimpleException@@8		; CSimpleException::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCSimpleException@@@8			; CSimpleException `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CException@@8			; CException::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCException@@@8				; CException `RTTI Type Descriptor'
PUBLIC	??_R4CUserException@@6B@			; CUserException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCUserException@@@8			; CUserException `RTTI Type Descriptor'
PUBLIC	??_R3CUserException@@8				; CUserException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CUserException@@8				; CUserException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CUserException@@8			; CUserException::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	??_7CUserException@@6B@				; CUserException::`vftable'
PUBLIC	??_GCUserException@@UAEPAXI@Z			; CUserException::`scalar deleting destructor'
EXTRN	?GetErrorMessage@CSimpleException@@UAEHPADIPAI@Z:NEAR ; CSimpleException::GetErrorMessage
EXTRN	?ReportError@CException@@UAEHII@Z:NEAR		; CException::ReportError
EXTRN	?GetRuntimeClass@CUserException@@UBEPAUCRuntimeClass@@XZ:NEAR ; CUserException::GetRuntimeClass
EXTRN	??_ECUserException@@UAEPAXI@Z:NEAR		; CUserException::`vector deleting destructor'
;	COMDAT ??_7CUserException@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
CONST	SEGMENT
??_7CUserException@@6B@ DD FLAT:??_R4CUserException@@6B@ ; CUserException::`vftable'
	DD	FLAT:?GetRuntimeClass@CUserException@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECUserException@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?GetErrorMessage@CSimpleException@@UAEHPADIPAI@Z
	DD	FLAT:?ReportError@CException@@UAEHII@Z
CONST	ENDS
;	COMDAT ??_R4CUserException@@6B@
rdata$r	SEGMENT
??_R4CUserException@@6B@ DD 00H				; CUserException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCUserException@@@8
	DD	FLAT:??_R3CUserException@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCUserException@@@8
_DATA	SEGMENT
??_R0?AVCUserException@@@8 DD FLAT:??_7type_info@@6B@	; CUserException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCUserException@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CUserException@@8
rdata$r	SEGMENT
??_R3CUserException@@8 DD 00H				; CUserException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CUserException@@8
rdata$r	ENDS
;	COMDAT ??_R2CUserException@@8
rdata$r	SEGMENT
??_R2CUserException@@8 DD FLAT:??_R1A@?0A@A@CUserException@@8 ; CUserException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CSimpleException@@8
	DD	FLAT:??_R1A@?0A@A@CException@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CUserException@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CUserException@@8 DD FLAT:??_R0?AVCUserException@@@8 ; CUserException::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSimpleException@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CSimpleException@@8 DD FLAT:??_R0?AVCSimpleException@@@8 ; CSimpleException::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCSimpleException@@@8
_DATA	SEGMENT
??_R0?AVCSimpleException@@@8 DD FLAT:??_7type_info@@6B@	; CSimpleException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSimpleException@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CException@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CException@@8 DD FLAT:??_R0?AVCException@@@8 ; CException::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCException@@@8
_DATA	SEGMENT
??_R0?AVCException@@@8 DD FLAT:??_7type_info@@6B@	; CException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCException@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0CUserException@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CUserException@@QAE@XZ PROC NEAR			; CUserException::CUserException, COMDAT
; _this$ = ecx

; 70   : 	: CSimpleException() { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CSimpleException@@QAE@XZ ; CSimpleException::CSimpleException
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CUserException@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CUserException@@QAE@XZ ENDP				; CUserException::CUserException
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC NEAR	; CObject::Serialize, COMDAT
; _this$ = ecx

; 25   : 	{ /* CObject does not serialize anything by default */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
_TEXT	ENDS
EXTRN	??0CException@@QAE@XZ:NEAR			; CException::CException
; Function compile flags: /Odt
;	COMDAT ??0CSimpleException@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CSimpleException@@QAE@XZ PROC NEAR			; CSimpleException::CSimpleException, COMDAT
; _this$ = ecx

; 57   : 	{ m_bInitialized = FALSE; m_bLoaded = FALSE; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CException@@QAE@XZ	; CException::CException
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0CSimpleException@@QAE@XZ ENDP			; CSimpleException::CSimpleException
_TEXT	ENDS
PUBLIC	??1CUserException@@UAE@XZ			; CUserException::~CUserException
; Function compile flags: /Odt
;	COMDAT ??_GCUserException@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCUserException@@UAEPAXI@Z PROC NEAR			; CUserException::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CUserException@@UAE@XZ ; CUserException::~CUserException
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41474
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41474:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCUserException@@UAEPAXI@Z ENDP			; CUserException::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CSimpleException@@UAE@XZ			; CSimpleException::~CSimpleException
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
;	COMDAT ??1CUserException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CUserException@@UAE@XZ PROC NEAR			; CUserException::~CUserException, COMDAT
; _this$ = ecx

; 74   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CUserException@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CSimpleException@@UAE@XZ ; CSimpleException::~CSimpleException
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CUserException@@UAE@XZ ENDP				; CUserException::~CUserException
_TEXT	ENDS
PUBLIC	??1CException@@UAE@XZ				; CException::~CException
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
;	COMDAT ??1CSimpleException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CSimpleException@@UAE@XZ PROC NEAR			; CSimpleException::~CSimpleException, COMDAT
; _this$ = ecx

; 61   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CException@@UAE@XZ	; CException::~CException
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CSimpleException@@UAE@XZ ENDP			; CSimpleException::~CSimpleException
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CException@@UAE@XZ PROC NEAR				; CException::~CException, COMDAT
; _this$ = ecx

; 55   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CObject@@UAE@XZ	; CObject::~CObject
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CException@@UAE@XZ ENDP				; CException::~CException
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ PROC NEAR		; CDC::GetSafeHdc, COMDAT
; _this$ = ecx

; 316  : 	{ return this == NULL ? NULL : m_hDC; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  0000d	75 09		 jne	 SHORT $L203980
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00016	eb 09		 jmp	 SHORT $L203981
$L203980:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	89 4d f8	 mov	 DWORD PTR tv66[ebp], ecx
$L203981:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ENDP			; CDC::GetSafeHdc
_TEXT	ENDS
PUBLIC	??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z	; AFX_CLASSINIT::AFX_CLASSINIT
CRT$XCU	SEGMENT
_$S6	DD	FLAT:_$E5
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\bitmap\cdib.cpp
CRT$XCU	ENDS
;	COMDAT _$E5
text$yc	SEGMENT
_$E5	PROC NEAR					; COMDAT

; 13   : IMPLEMENT_SERIAL(CDib, CObject, 0);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 ?GetThisClass@CDib@@SGPAUCRuntimeClass@@XZ ; CDib::GetThisClass
  00008	50		 push	 eax
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?_init_CDib@@3UAFX_CLASSINIT@@A ; _init_CDib
  0000e	e8 00 00 00 00	 call	 ??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z ; AFX_CLASSINIT::AFX_CLASSINIT
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_$E5	ENDP
text$yc	ENDS
EXTRN	?AfxClassInit@@YGXPAUCRuntimeClass@@@Z:NEAR	; AfxClassInit
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.h
;	COMDAT ??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pNewClass$ = 8						; size = 4
??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z PROC NEAR	; AFX_CLASSINIT::AFX_CLASSINIT, COMDAT
; _this$ = ecx

; 346  : 	{ AFX_CLASSINIT(CRuntimeClass* pNewClass) { AfxClassInit(pNewClass); } };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pNewClass$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?AfxClassInit@@YGXPAUCRuntimeClass@@@Z ; AfxClassInit
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z ENDP		; AFX_CLASSINIT::AFX_CLASSINIT
_TEXT	ENDS
PUBLIC	?_init_CDib@@3UAFX_CLASSINIT@@A			; _init_CDib
_BSS	SEGMENT
?_init_CDib@@3UAFX_CLASSINIT@@A DB 01H DUP (?)		; _init_CDib
_BSS	ENDS
END
