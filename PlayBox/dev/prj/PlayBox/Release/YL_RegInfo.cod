; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\boxgit\PlayBox\CommonLib\common\YL_RegInfo.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@HHDGIIFB@0123456789abcdefABCDEF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@_W@std@@YAD_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@_WDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0IPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@D@std@@YADDABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVdomain_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVrange_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@codecvt_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@_WDH@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4underflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4overflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVunderflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4domain_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_exception@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4invalid_argument@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$codecvt@_WDH@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4range_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_exception@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$codecvt@_WDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R2invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVinvalid_argument@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVoverflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
CONST	SEGMENT
$SG64476 DB	00H
	ORG $+3
$SG64491 DB	'\', 00H
$SG64520 DB	00H
CONST	ENDS
PUBLIC	?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_RegInfo::CreateKey
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
EXTRN	__imp__RegCloseKey@4:NEAR
EXTRN	__imp__RegCreateKeyExA@36:NEAR
; Function compile flags: /Odt
; File d:\boxgit\playbox\commonlib\common\yl_reginfo.cpp
_TEXT	SEGMENT
_err$ = -8						; size = 4
_hKey$ = -4						; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; YL_RegInfo::CreateKey

; 4    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 5    : 	HKEY hKey; 		
; 6    : 	LONG err;
; 7    : 	err = RegCreateKeyEx(hRegKey, strRegEntry.c_str(), 0L, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,&hKey, NULL );

  00006	6a 00		 push	 0
  00008	8d 45 fc	 lea	 eax, DWORD PTR _hKey$[ebp]
  0000b	50		 push	 eax
  0000c	6a 00		 push	 0
  0000e	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00022	50		 push	 eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  0002d	89 45 f8	 mov	 DWORD PTR _err$[ebp], eax

; 8    : 
; 9    : 	if( err == ERROR_SUCCESS )

  00030	83 7d f8 00	 cmp	 DWORD PTR _err$[ebp], 0
  00034	75 12		 jne	 SHORT $L64461

; 10   : 	{
; 11   : 		if( RegCloseKey( hKey ) == ERROR_SUCCESS )

  00036	8b 55 fc	 mov	 edx, DWORD PTR _hKey$[ebp]
  00039	52		 push	 edx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00040	85 c0		 test	 eax, eax
  00042	75 04		 jne	 SHORT $L64461

; 12   : 		{
; 13   : 			return true;

  00044	b0 01		 mov	 al, 1
  00046	eb 02		 jmp	 SHORT $L64458
$L64461:

; 14   : 		}
; 15   : 	}
; 16   : 		
; 17   : 	return false;		

  00048	32 c0		 xor	 al, al
$L64458:

; 18   : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; YL_RegInfo::CreateKey
_TEXT	ENDS
PUBLIC	?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD@Z	; YL_RegInfo::CreateKey
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T68556	DD	0ffffffffH
	DD	FLAT:$L68549
$T68553	DD	019930520H
	DD	01H
	DD	FLAT:$T68556
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv74 = -52						; size = 4
tv75 = -48						; size = 4
$T68548 = -44						; size = 28
$T68547 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD@Z PROC NEAR	; YL_RegInfo::CreateKey

; 21   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	6a ff		 push	 -1
  00055	68 00 00 00 00	 push	 __ehhandler$?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD@Z
  0005a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00060	50		 push	 eax
  00061	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00068	83 ec 28	 sub	 esp, 40			; 00000028H

; 22   : 	if( pszRegEntry == NULL )

  0006b	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  0006f	75 04		 jne	 SHORT $L64467

; 23   : 	{
; 24   : 		return false;

  00071	32 c0		 xor	 al, al
  00073	eb 43		 jmp	 SHORT $L64466
$L64467:

; 25   : 	}
; 26   : 	return CreateKey( hRegKey,string(pszRegEntry) );

  00075	8b 45 0c	 mov	 eax, DWORD PTR _pszRegEntry$[ebp]
  00078	50		 push	 eax
  00079	8d 4d d4	 lea	 ecx, DWORD PTR $T68548[ebp]
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00082	89 45 d0	 mov	 DWORD PTR tv75[ebp], eax
  00085	8b 4d d0	 mov	 ecx, DWORD PTR tv75[ebp]
  00088	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  0008b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00092	8b 55 cc	 mov	 edx, DWORD PTR tv74[ebp]
  00095	52		 push	 edx
  00096	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_RegInfo::CreateKey
  0009f	83 c4 08	 add	 esp, 8
  000a2	88 45 f3	 mov	 BYTE PTR $T68547[ebp], al
  000a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ac	8d 4d d4	 lea	 ecx, DWORD PTR $T68548[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  000b5	8a 45 f3	 mov	 al, BYTE PTR $T68547[ebp]
$L64466:

; 27   : }

  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L68549:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T68548[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68553
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD@Z ENDP	; YL_RegInfo::CreateKey
PUBLIC	?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; YL_RegInfo::DeleteKey
PUBLIC	?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z	; YL_RegInfo::DeleteKey
EXTRN	__imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp__RegDeleteKeyA@8:NEAR
EXTRN	__imp__RegDeleteValueA@8:NEAR
EXTRN	__imp__RegEnumKeyExA@32:NEAR
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:NEAR
EXTRN	__imp__RegOpenKeyExA@20:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z:NEAR
xdata$x	SEGMENT
$T68573	DD	0ffffffffH
	DD	FLAT:$L68565
	DD	00H
	DD	FLAT:$L68566
$T68568	DD	019930520H
	DD	02H
	DD	FLAT:$T68573
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T68564 = -373						; size = 1
$T68563 = -372						; size = 1
$T68562 = -371						; size = 1
$T68561 = -370						; size = 1
$T68560 = -369						; size = 1
_err$64503 = -368					; size = 4
_hKey$64502 = -364					; size = 4
_strTmp$64496 = -360					; size = 28
_strSubKey$64482 = -332					; size = 28
_ftWrite$64481 = -304					; size = 8
_lResult$64477 = -296					; size = 4
_szName$64479 = -292					; size = 260
__$ArrayPad$ = -24					; size = 4
_hKey$64480 = -20					; size = 4
_dwSize$64478 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
_strKeyName$ = 16					; size = 4
?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z PROC NEAR ; YL_RegInfo::DeleteKey

; 30   : {		

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	6a ff		 push	 -1
  000d5	68 00 00 00 00	 push	 __ehhandler$?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z
  000da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  000e0	50		 push	 eax
  000e1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  000e8	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  000ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000f3	89 45 e8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 31   : 	if( strKeyName == "" )

  000f6	68 00 00 00 00	 push	 OFFSET FLAT:$SG64476
  000fb	8b 45 10	 mov	 eax, DWORD PTR _strKeyName$[ebp]
  000fe	50		 push	 eax
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
  00105	83 c4 08	 add	 esp, 8
  00108	0f b6 c8	 movzx	 ecx, al
  0010b	85 c9		 test	 ecx, ecx
  0010d	0f 84 7c 02 00
	00		 je	 $L64475

; 32   : 	{
; 33   : 		LONG lResult;
; 34   : 		DWORD dwSize;
; 35   : 		TCHAR szName[MAX_PATH];
; 36   : 		HKEY hKey;
; 37   : 		FILETIME ftWrite;
; 38   : 		
; 39   : 		string strSubKey = strRegEntry;

  00113	8b 55 0c	 mov	 edx, DWORD PTR _strRegEntry$[ebp]
  00116	52		 push	 edx
  00117	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00123	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 				
; 41   : 
; 42   : 		// First, see if we can delete the key without having
; 43   : 		// to recurse.
; 44   : 
; 45   : 		lResult = RegDeleteKey(hRegKey, strSubKey.c_str());

  0012a	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00136	50		 push	 eax
  00137	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  0013a	50		 push	 eax
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteKeyA@8
  00141	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _lResult$64477[ebp], eax

; 46   : 
; 47   : 		if (lResult == ERROR_SUCCESS) 

  00147	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _lResult$64477[ebp], 0
  0014e	75 25		 jne	 SHORT $L64483

; 48   : 			return true;

  00150	c6 85 8f fe ff
	ff 01		 mov	 BYTE PTR $T68560[ebp], 1
  00157	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0015e	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  00164	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0016a	8a 85 8f fe ff
	ff		 mov	 al, BYTE PTR $T68560[ebp]
  00170	e9 ad 02 00 00	 jmp	 $L64474
$L64483:

; 49   : 
; 50   : 		lResult = RegOpenKeyEx (hRegKey, strSubKey.c_str(), 0, KEY_READ, &hKey);

  00175	8d 4d ec	 lea	 ecx, DWORD PTR _hKey$64480[ebp]
  00178	51		 push	 ecx
  00179	68 19 00 02 00	 push	 131097			; 00020019H
  0017e	6a 00		 push	 0
  00180	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0018c	50		 push	 eax
  0018d	8b 55 08	 mov	 edx, DWORD PTR _hRegKey$[ebp]
  00190	52		 push	 edx
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00197	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _lResult$64477[ebp], eax

; 51   : 
; 52   : 		if (lResult != ERROR_SUCCESS) 

  0019d	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _lResult$64477[ebp], 0
  001a4	74 53		 je	 SHORT $L64485

; 53   : 		{
; 54   : 			if (lResult == ERROR_FILE_NOT_FOUND) 

  001a6	83 bd d8 fe ff
	ff 02		 cmp	 DWORD PTR _lResult$64477[ebp], 2
  001ad	75 25		 jne	 SHORT $L64486

; 55   : 			{
; 56   : 				return true;

  001af	c6 85 8e fe ff
	ff 01		 mov	 BYTE PTR $T68561[ebp], 1
  001b6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001bd	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001c9	8a 85 8e fe ff
	ff		 mov	 al, BYTE PTR $T68561[ebp]
  001cf	e9 4e 02 00 00	 jmp	 $L64474
$L64486:

; 57   : 			} 
; 58   : 			else 
; 59   : 			{			
; 60   : 				return false;

  001d4	c6 85 8d fe ff
	ff 00		 mov	 BYTE PTR $T68562[ebp], 0
  001db	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001e2	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001ee	8a 85 8d fe ff
	ff		 mov	 al, BYTE PTR $T68562[ebp]
  001f4	e9 29 02 00 00	 jmp	 $L64474
$L64485:

; 61   : 			}
; 62   : 		}
; 63   : 
; 64   : 		// Check for an ending slash and add one if it is missing.
; 65   : 
; 66   : 		if( strSubKey[strSubKey.length()-1] != '\\' )

  001f9	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  001ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00205	83 e8 01	 sub	 eax, 1
  00208	50		 push	 eax
  00209	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  0020f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
  00215	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00218	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0021b	74 11		 je	 SHORT $L64490

; 67   : 		{
; 68   : 			strSubKey += "\\";

  0021d	68 00 00 00 00	 push	 OFFSET FLAT:$SG64491
  00222	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$L64490:

; 69   : 		}
; 70   : 
; 71   : 		// Enumerate the keys
; 72   : 
; 73   : 		dwSize = MAX_PATH;

  0022e	c7 45 f0 04 01
	00 00		 mov	 DWORD PTR _dwSize$64478[ebp], 260 ; 00000104H

; 74   : 		lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
; 75   : 			NULL, NULL, &ftWrite);

  00235	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _ftWrite$64481[ebp]
  0023b	51		 push	 ecx
  0023c	6a 00		 push	 0
  0023e	6a 00		 push	 0
  00240	6a 00		 push	 0
  00242	8d 55 f0	 lea	 edx, DWORD PTR _dwSize$64478[ebp]
  00245	52		 push	 edx
  00246	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _szName$64479[ebp]
  0024c	50		 push	 eax
  0024d	6a 00		 push	 0
  0024f	8b 4d ec	 mov	 ecx, DWORD PTR _hKey$64480[ebp]
  00252	51		 push	 ecx
  00253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegEnumKeyExA@32
  00259	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _lResult$64477[ebp], eax

; 76   : 
; 77   : 		if (lResult == ERROR_SUCCESS) 

  0025f	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _lResult$64477[ebp], 0
  00266	0f 85 ac 00 00
	00		 jne	 $L64492
$L64493:

; 78   : 		{
; 79   : 			do {
; 80   : 				
; 81   : 				string strTmp = strSubKey;

  0026c	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR _strSubKey$64482[ebp]
  00272	52		 push	 edx
  00273	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$64496[ebp]
  00279	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0027f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 82   : 				strTmp += szName;

  00283	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _szName$64479[ebp]
  00289	50		 push	 eax
  0028a	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$64496[ebp]
  00290	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 83   : 
; 84   : 				if (!DeleteKey(hRegKey, strTmp.c_str()))

  00296	6a 00		 push	 0
  00298	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$64496[ebp]
  0029e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  002a4	50		 push	 eax
  002a5	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  002a8	51		 push	 ecx
  002a9	e8 00 00 00 00	 call	 ?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z ; YL_RegInfo::DeleteKey
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	0f b6 d0	 movzx	 edx, al
  002b4	85 d2		 test	 edx, edx
  002b6	75 12		 jne	 SHORT $L64497

; 85   : 				{
; 86   : 					break;

  002b8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002bc	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$64496[ebp]
  002c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  002c8	eb 4e		 jmp	 SHORT $L64492
$L64497:

; 87   : 				}
; 88   : 
; 89   : 				dwSize = MAX_PATH;

  002ca	c7 45 f0 04 01
	00 00		 mov	 DWORD PTR _dwSize$64478[ebp], 260 ; 00000104H

; 90   : 
; 91   : 				lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
; 92   : 					NULL, NULL, &ftWrite);

  002d1	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _ftWrite$64481[ebp]
  002d7	50		 push	 eax
  002d8	6a 00		 push	 0
  002da	6a 00		 push	 0
  002dc	6a 00		 push	 0
  002de	8d 4d f0	 lea	 ecx, DWORD PTR _dwSize$64478[ebp]
  002e1	51		 push	 ecx
  002e2	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _szName$64479[ebp]
  002e8	52		 push	 edx
  002e9	6a 00		 push	 0
  002eb	8b 45 ec	 mov	 eax, DWORD PTR _hKey$64480[ebp]
  002ee	50		 push	 eax
  002ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegEnumKeyExA@32
  002f5	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _lResult$64477[ebp], eax

; 93   : 
; 94   : 			} while (lResult == ERROR_SUCCESS);

  002fb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002ff	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$64496[ebp]
  00305	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0030b	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _lResult$64477[ebp], 0
  00312	0f 84 54 ff ff
	ff		 je	 $L64493
$L64492:

; 95   : 		}
; 96   : 
; 97   : 		RegCloseKey (hKey);

  00318	8b 4d ec	 mov	 ecx, DWORD PTR _hKey$64480[ebp]
  0031b	51		 push	 ecx
  0031c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 98   : 
; 99   : 		// Try again to delete the key.
; 100  : 
; 101  : 		lResult = RegDeleteKey(hRegKey, strRegEntry.c_str());

  00322	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  00325	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0032b	50		 push	 eax
  0032c	8b 55 08	 mov	 edx, DWORD PTR _hRegKey$[ebp]
  0032f	52		 push	 edx
  00330	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteKeyA@8
  00336	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _lResult$64477[ebp], eax

; 102  : 
; 103  : 		if (lResult == ERROR_SUCCESS) 

  0033c	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _lResult$64477[ebp], 0
  00343	75 25		 jne	 SHORT $L64498

; 104  : 			return true;

  00345	c6 85 8c fe ff
	ff 01		 mov	 BYTE PTR $T68563[ebp], 1
  0034c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00353	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  00359	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0035f	8a 85 8c fe ff
	ff		 mov	 al, BYTE PTR $T68563[ebp]
  00365	e9 b8 00 00 00	 jmp	 $L64474
$L64498:

; 105  : 
; 106  : 		return false;

  0036a	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR $T68564[ebp], 0
  00371	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00378	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  0037e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00384	8a 85 8b fe ff
	ff		 mov	 al, BYTE PTR $T68564[ebp]
  0038a	e9 93 00 00 00	 jmp	 $L64474
$L64475:

; 107  : 	} 
; 108  : 	else
; 109  : 	{
; 110  : 		HKEY hKey; 
; 111  : 		LONG err ; 
; 112  : 		err = RegOpenKeyEx(hRegKey, strRegEntry.c_str(),0, KEY_ALL_ACCESS, &hKey);

  0038f	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _hKey$64502[ebp]
  00395	50		 push	 eax
  00396	68 3f 00 0f 00	 push	 983103			; 000f003fH
  0039b	6a 00		 push	 0
  0039d	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  003a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  003a6	50		 push	 eax
  003a7	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  003aa	51		 push	 ecx
  003ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  003b1	89 85 90 fe ff
	ff		 mov	 DWORD PTR _err$64503[ebp], eax

; 113  : 		if(err == ERROR_SUCCESS) 

  003b7	83 bd 90 fe ff
	ff 00		 cmp	 DWORD PTR _err$64503[ebp], 0
  003be	75 53		 jne	 SHORT $L64504

; 114  : 		{ 
; 115  : 			err = RegDeleteValue(hKey, strKeyName.c_str()); 

  003c0	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  003c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  003c9	50		 push	 eax
  003ca	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR _hKey$64502[ebp]
  003d0	52		 push	 edx
  003d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteValueA@8
  003d7	89 85 90 fe ff
	ff		 mov	 DWORD PTR _err$64503[ebp], eax

; 116  : 			if( (err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS ) || (err == ERROR_FILE_NOT_FOUND ) )

  003dd	83 bd 90 fe ff
	ff 00		 cmp	 DWORD PTR _err$64503[ebp], 0
  003e4	75 11		 jne	 SHORT $L64507
  003e6	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _hKey$64502[ebp]
  003ec	50		 push	 eax
  003ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  003f3	85 c0		 test	 eax, eax
  003f5	74 09		 je	 SHORT $L64506
$L64507:
  003f7	83 bd 90 fe ff
	ff 02		 cmp	 DWORD PTR _err$64503[ebp], 2
  003fe	75 04		 jne	 SHORT $L64505
$L64506:

; 117  : 			{
; 118  : 				return true;

  00400	b0 01		 mov	 al, 1
  00402	eb 1e		 jmp	 SHORT $L64474
$L64505:

; 119  : 			}
; 120  : 			RegCloseKey( hKey );

  00404	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _hKey$64502[ebp]
  0040a	51		 push	 ecx
  0040b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 121  : 		} 
; 122  : 		else if( err == ERROR_FILE_NOT_FOUND )

  00411	eb 0d		 jmp	 SHORT $L64508
$L64504:
  00413	83 bd 90 fe ff
	ff 02		 cmp	 DWORD PTR _err$64503[ebp], 2
  0041a	75 04		 jne	 SHORT $L64508

; 123  : 		{
; 124  : 			return true;

  0041c	b0 01		 mov	 al, 1
  0041e	eb 02		 jmp	 SHORT $L64474
$L64508:

; 125  : 		}
; 126  : 
; 127  : 		return false;

  00420	32 c0		 xor	 al, al
$L64474:

; 128  : 	}
; 129  : }

  00422	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00425	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0042c	8b 4d e8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0042f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00434	8b e5		 mov	 esp, ebp
  00436	5d		 pop	 ebp
  00437	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L68565:
  00013	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$64482[ebp]
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68566:
  0001f	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$64496[ebp]
  00025	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z:
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68568
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ENDP ; YL_RegInfo::DeleteKey
xdata$x	SEGMENT
$T68588	DD	0ffffffffH
	DD	FLAT:$L68581
	DD	00H
	DD	FLAT:$L68582
	DD	0ffffffffH
	DD	FLAT:$L68583
	DD	02H
	DD	FLAT:$L68584
$T68586	DD	019930520H
	DD	04H
	DD	FLAT:$T68588
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv131 = -156						; size = 4
tv133 = -152						; size = 4
tv129 = -148						; size = 4
tv132 = -144						; size = 4
tv95 = -140						; size = 4
tv68 = -136						; size = 4
$T68580 = -132						; size = 28
$T68579 = -104						; size = 28
$T68578 = -73						; size = 1
$T68577 = -72						; size = 28
$T68576 = -44						; size = 28
$T68575 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
_pszKeyName$ = 16					; size = 4
?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z PROC NEAR	; YL_RegInfo::DeleteKey

; 132  : {

  00440	55		 push	 ebp
  00441	8b ec		 mov	 ebp, esp
  00443	6a ff		 push	 -1
  00445	68 00 00 00 00	 push	 __ehhandler$?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z
  0044a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00450	50		 push	 eax
  00451	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00458	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H

; 133  : 	if( pszRegEntry == NULL )

  0045e	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  00462	75 07		 jne	 SHORT $L64515

; 134  : 	{
; 135  : 		return false;

  00464	32 c0		 xor	 al, al
  00466	e9 09 01 00 00	 jmp	 $L64514
$L64515:

; 136  : 	}
; 137  : 	if( pszKeyName == NULL )

  0046b	83 7d 10 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  0046f	75 77		 jne	 SHORT $L64516

; 138  : 	{
; 139  : 		return DeleteKey( hRegKey,string(pszRegEntry) );

  00471	68 00 00 00 00	 push	 OFFSET FLAT:$SG64520
  00476	8d 4d d4	 lea	 ecx, DWORD PTR $T68576[ebp]
  00479	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0047f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00486	8b 45 0c	 mov	 eax, DWORD PTR _pszRegEntry$[ebp]
  00489	50		 push	 eax
  0048a	8d 4d b8	 lea	 ecx, DWORD PTR $T68577[ebp]
  0048d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00493	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  00499	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv68[ebp]
  0049f	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv95[ebp], ecx
  004a5	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  004a9	8d 55 d4	 lea	 edx, DWORD PTR $T68576[ebp]
  004ac	52		 push	 edx
  004ad	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv95[ebp]
  004b3	50		 push	 eax
  004b4	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  004b7	51		 push	 ecx
  004b8	e8 00 00 00 00	 call	 ?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; YL_RegInfo::DeleteKey
  004bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c0	88 45 f3	 mov	 BYTE PTR $T68575[ebp], al
  004c3	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  004c7	8d 4d b8	 lea	 ecx, DWORD PTR $T68577[ebp]
  004ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  004d0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004d7	8d 4d d4	 lea	 ecx, DWORD PTR $T68576[ebp]
  004da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  004e0	8a 45 f3	 mov	 al, BYTE PTR $T68575[ebp]
  004e3	e9 8c 00 00 00	 jmp	 $L64514
$L64516:

; 140  : 	}
; 141  : 	else
; 142  : 	{
; 143  : 		return DeleteKey( hRegKey,string(pszRegEntry),string(pszKeyName) );

  004e8	8b 55 10	 mov	 edx, DWORD PTR _pszKeyName$[ebp]
  004eb	52		 push	 edx
  004ec	8d 4d 98	 lea	 ecx, DWORD PTR $T68579[ebp]
  004ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  004f5	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv132[ebp], eax
  004fb	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv132[ebp]
  00501	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
  00507	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0050e	8b 4d 0c	 mov	 ecx, DWORD PTR _pszRegEntry$[ebp]
  00511	51		 push	 ecx
  00512	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T68580[ebp]
  00518	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0051e	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv133[ebp], eax
  00524	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv133[ebp]
  0052a	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv131[ebp], edx
  00530	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00534	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv129[ebp]
  0053a	50		 push	 eax
  0053b	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv131[ebp]
  00541	51		 push	 ecx
  00542	8b 55 08	 mov	 edx, DWORD PTR _hRegKey$[ebp]
  00545	52		 push	 edx
  00546	e8 00 00 00 00	 call	 ?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; YL_RegInfo::DeleteKey
  0054b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0054e	88 45 b7	 mov	 BYTE PTR $T68578[ebp], al
  00551	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00555	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T68580[ebp]
  0055b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00561	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00568	8d 4d 98	 lea	 ecx, DWORD PTR $T68579[ebp]
  0056b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00571	8a 45 b7	 mov	 al, BYTE PTR $T68578[ebp]
$L64514:

; 144  : 	}
; 145  : }

  00574	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00577	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0057e	8b e5		 mov	 esp, ebp
  00580	5d		 pop	 ebp
  00581	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L68581:
  00035	8d 4d d4	 lea	 ecx, DWORD PTR $T68576[ebp]
  00038	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68582:
  0003e	8d 4d b8	 lea	 ecx, DWORD PTR $T68577[ebp]
  00041	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68583:
  00047	8d 4d 98	 lea	 ecx, DWORD PTR $T68579[ebp]
  0004a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68584:
  00050	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T68580[ebp]
  00056	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z:
  0005c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68586
  00061	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z ENDP	; YL_RegInfo::DeleteKey
PUBLIC	?DeleteValue@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; YL_RegInfo::DeleteValue
; Function compile flags: /Odt
_TEXT	SEGMENT
_err$ = -8						; size = 4
_hKey$ = -4						; size = 4
_regClass$ = 8						; size = 4
_regEntry$ = 12						; size = 4
_valueName$ = 16					; size = 4
?DeleteValue@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z PROC NEAR ; YL_RegInfo::DeleteValue

; 148  : {

  00590	55		 push	 ebp
  00591	8b ec		 mov	 ebp, esp
  00593	83 ec 08	 sub	 esp, 8

; 149  : 	HKEY hKey; 
; 150  : 	LONG err ; 
; 151  : 	err = RegOpenKeyEx(regClass, regEntry.c_str(),0, KEY_ALL_ACCESS, &hKey);

  00596	8d 45 fc	 lea	 eax, DWORD PTR _hKey$[ebp]
  00599	50		 push	 eax
  0059a	68 3f 00 0f 00	 push	 983103			; 000f003fH
  0059f	6a 00		 push	 0
  005a1	8b 4d 0c	 mov	 ecx, DWORD PTR _regEntry$[ebp]
  005a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  005aa	50		 push	 eax
  005ab	8b 4d 08	 mov	 ecx, DWORD PTR _regClass$[ebp]
  005ae	51		 push	 ecx
  005af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  005b5	89 45 f8	 mov	 DWORD PTR _err$[ebp], eax

; 152  : 	if(err == ERROR_SUCCESS) 

  005b8	83 7d f8 00	 cmp	 DWORD PTR _err$[ebp], 0
  005bc	75 21		 jne	 SHORT $L64532

; 153  : 	{ 
; 154  : 		err = RegDeleteValue(hKey, valueName.c_str()); 

  005be	8b 4d 10	 mov	 ecx, DWORD PTR _valueName$[ebp]
  005c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  005c7	50		 push	 eax
  005c8	8b 55 fc	 mov	 edx, DWORD PTR _hKey$[ebp]
  005cb	52		 push	 edx
  005cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteValueA@8
  005d2	89 45 f8	 mov	 DWORD PTR _err$[ebp], eax

; 155  : 		RegCloseKey(hKey); 

  005d5	8b 45 fc	 mov	 eax, DWORD PTR _hKey$[ebp]
  005d8	50		 push	 eax
  005d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L64532:

; 156  : 	} 
; 157  : 
; 158  : 	return err;

  005df	8b 45 f8	 mov	 eax, DWORD PTR _err$[ebp]

; 159  : }

  005e2	8b e5		 mov	 esp, ebp
  005e4	5d		 pop	 ebp
  005e5	c3		 ret	 0
?DeleteValue@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ENDP ; YL_RegInfo::DeleteValue
_TEXT	ENDS
PUBLIC	?DeleteSubKey@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; YL_RegInfo::DeleteSubKey
; Function compile flags: /Odt
_TEXT	SEGMENT
_err$ = -8						; size = 4
_hKey$ = -4						; size = 4
_regClass$ = 8						; size = 4
_regEntry$ = 12						; size = 4
_keyName$ = 16						; size = 4
?DeleteSubKey@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z PROC NEAR ; YL_RegInfo::DeleteSubKey

; 162  : {

  005f0	55		 push	 ebp
  005f1	8b ec		 mov	 ebp, esp
  005f3	83 ec 08	 sub	 esp, 8

; 163  : 	HKEY hKey; 
; 164  : 	LONG err ; 
; 165  : 	err = RegOpenKeyEx(regClass, regEntry.c_str(),0, KEY_ALL_ACCESS, &hKey);

  005f6	8d 45 fc	 lea	 eax, DWORD PTR _hKey$[ebp]
  005f9	50		 push	 eax
  005fa	68 3f 00 0f 00	 push	 983103			; 000f003fH
  005ff	6a 00		 push	 0
  00601	8b 4d 0c	 mov	 ecx, DWORD PTR _regEntry$[ebp]
  00604	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0060a	50		 push	 eax
  0060b	8b 4d 08	 mov	 ecx, DWORD PTR _regClass$[ebp]
  0060e	51		 push	 ecx
  0060f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00615	89 45 f8	 mov	 DWORD PTR _err$[ebp], eax

; 166  : 	if(err == ERROR_SUCCESS) 

  00618	83 7d f8 00	 cmp	 DWORD PTR _err$[ebp], 0
  0061c	75 21		 jne	 SHORT $L64540

; 167  : 	{ 
; 168  : 		err = RegDeleteKey(hKey, keyName.c_str()); 

  0061e	8b 4d 10	 mov	 ecx, DWORD PTR _keyName$[ebp]
  00621	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00627	50		 push	 eax
  00628	8b 55 fc	 mov	 edx, DWORD PTR _hKey$[ebp]
  0062b	52		 push	 edx
  0062c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteKeyA@8
  00632	89 45 f8	 mov	 DWORD PTR _err$[ebp], eax

; 169  : 		RegCloseKey(hKey); 

  00635	8b 45 fc	 mov	 eax, DWORD PTR _hKey$[ebp]
  00638	50		 push	 eax
  00639	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L64540:

; 170  : 	} 
; 171  : 
; 172  : 	return err;

  0063f	8b 45 f8	 mov	 eax, DWORD PTR _err$[ebp]

; 173  : }

  00642	8b e5		 mov	 esp, ebp
  00644	5d		 pop	 ebp
  00645	c3		 ret	 0
?DeleteSubKey@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ENDP ; YL_RegInfo::DeleteSubKey
_TEXT	ENDS
PUBLIC	?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@11@Z ; YL_RegInfo::WriteString
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp__RegSetValueExA@24:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_err$64561 = -32					; size = 4
_dw$64559 = -28						; size = 4
_regType$64562 = -24					; size = 4
_hKey$64558 = -20					; size = 4
_err$ = -16						; size = 4
_dw$ = -12						; size = 4
_regType$ = -8						; size = 4
_hKey$ = -4						; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
_strKeyName$ = 16					; size = 4
_strKeyValue$ = 20					; size = 4
?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@11@Z PROC NEAR ; YL_RegInfo::WriteString

; 176  : {

  00650	55		 push	 ebp
  00651	8b ec		 mov	 ebp, esp
  00653	83 ec 20	 sub	 esp, 32			; 00000020H

; 177  : 	HKEY hKey;
; 178  : 	DWORD dw = (DWORD)strKeyValue.size(); 

  00656	8b 4d 14	 mov	 ecx, DWORD PTR _strKeyValue$[ebp]
  00659	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  0065f	89 45 f4	 mov	 DWORD PTR _dw$[ebp], eax

; 179  : 	LONG err = -1; 

  00662	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1

; 180  : 	DWORD regType = REG_SZ; 	

  00669	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _regType$[ebp], 1

; 181  : 
; 182  : 	err = RegOpenKeyEx( hRegKey, strRegEntry.c_str(),0, KEY_SET_VALUE, &hKey ) ;

  00670	8d 45 fc	 lea	 eax, DWORD PTR _hKey$[ebp]
  00673	50		 push	 eax
  00674	6a 02		 push	 2
  00676	6a 00		 push	 0
  00678	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  0067b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00681	50		 push	 eax
  00682	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  00685	51		 push	 ecx
  00686	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  0068c	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 183  : 	if(err == ERROR_SUCCESS)

  0068f	83 7d f0 00	 cmp	 DWORD PTR _err$[ebp], 0
  00693	75 55		 jne	 SHORT $L64552

; 184  : 	{ 
; 185  : 		err = RegSetValueEx( hKey, strKeyName.c_str() , 0, regType, (LPBYTE) strKeyValue.c_str(), dw ); 

  00695	8b 55 f4	 mov	 edx, DWORD PTR _dw$[ebp]
  00698	52		 push	 edx
  00699	8b 4d 14	 mov	 ecx, DWORD PTR _strKeyValue$[ebp]
  0069c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  006a2	50		 push	 eax
  006a3	8b 45 f8	 mov	 eax, DWORD PTR _regType$[ebp]
  006a6	50		 push	 eax
  006a7	6a 00		 push	 0
  006a9	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  006ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  006b2	50		 push	 eax
  006b3	8b 4d fc	 mov	 ecx, DWORD PTR _hKey$[ebp]
  006b6	51		 push	 ecx
  006b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  006bd	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 186  : 		if( err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS )

  006c0	83 7d f0 00	 cmp	 DWORD PTR _err$[ebp], 0
  006c4	75 15		 jne	 SHORT $L64554
  006c6	8b 55 fc	 mov	 edx, DWORD PTR _hKey$[ebp]
  006c9	52		 push	 edx
  006ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  006d0	85 c0		 test	 eax, eax
  006d2	75 07		 jne	 SHORT $L64554

; 187  : 		{
; 188  : 			return true;

  006d4	b0 01		 mov	 al, 1
  006d6	e9 c2 00 00 00	 jmp	 $L64546
$L64554:

; 189  : 		}
; 190  : 		RegCloseKey( hKey );

  006db	8b 45 fc	 mov	 eax, DWORD PTR _hKey$[ebp]
  006de	50		 push	 eax
  006df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 191  : 	} 
; 192  : 	else if( err == ERROR_FILE_NOT_FOUND )

  006e5	e9 b1 00 00 00	 jmp	 $L64555
$L64552:
  006ea	83 7d f0 02	 cmp	 DWORD PTR _err$[ebp], 2
  006ee	0f 85 a7 00 00
	00		 jne	 $L64555

; 193  : 	{		
; 194  : 		if( CreateKey( hRegKey,strRegEntry) )

  006f4	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  006f7	51		 push	 ecx
  006f8	8b 55 08	 mov	 edx, DWORD PTR _hRegKey$[ebp]
  006fb	52		 push	 edx
  006fc	e8 00 00 00 00	 call	 ?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_RegInfo::CreateKey
  00701	83 c4 08	 add	 esp, 8
  00704	0f b6 c0	 movzx	 eax, al
  00707	85 c0		 test	 eax, eax
  00709	0f 84 8c 00 00
	00		 je	 $L64555

; 195  : 		{
; 196  : 			HKEY hKey;
; 197  : 			DWORD dw = (DWORD)strKeyValue.size(); 

  0070f	8b 4d 14	 mov	 ecx, DWORD PTR _strKeyValue$[ebp]
  00712	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00718	89 45 e4	 mov	 DWORD PTR _dw$64559[ebp], eax

; 198  : 			LONG err = -1; 

  0071b	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _err$64561[ebp], -1

; 199  : 			DWORD regType = REG_SZ; 	

  00722	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _regType$64562[ebp], 1

; 200  : 
; 201  : 			err = RegOpenKeyEx( hRegKey, strRegEntry.c_str(),0, KEY_SET_VALUE, &hKey ) ;

  00729	8d 4d ec	 lea	 ecx, DWORD PTR _hKey$64558[ebp]
  0072c	51		 push	 ecx
  0072d	6a 02		 push	 2
  0072f	6a 00		 push	 0
  00731	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  00734	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0073a	50		 push	 eax
  0073b	8b 55 08	 mov	 edx, DWORD PTR _hRegKey$[ebp]
  0073e	52		 push	 edx
  0073f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00745	89 45 e0	 mov	 DWORD PTR _err$64561[ebp], eax

; 202  : 			if(err == ERROR_SUCCESS)

  00748	83 7d e0 00	 cmp	 DWORD PTR _err$64561[ebp], 0
  0074c	75 4d		 jne	 SHORT $L64555

; 203  : 			{ 
; 204  : 				err = RegSetValueEx( hKey, strKeyName.c_str() , 0, regType, (LPBYTE) strKeyValue.c_str(), dw ); 

  0074e	8b 45 e4	 mov	 eax, DWORD PTR _dw$64559[ebp]
  00751	50		 push	 eax
  00752	8b 4d 14	 mov	 ecx, DWORD PTR _strKeyValue$[ebp]
  00755	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0075b	50		 push	 eax
  0075c	8b 4d e8	 mov	 ecx, DWORD PTR _regType$64562[ebp]
  0075f	51		 push	 ecx
  00760	6a 00		 push	 0
  00762	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  00765	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0076b	50		 push	 eax
  0076c	8b 55 ec	 mov	 edx, DWORD PTR _hKey$64558[ebp]
  0076f	52		 push	 edx
  00770	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00776	89 45 e0	 mov	 DWORD PTR _err$64561[ebp], eax

; 205  : 				if( err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS )

  00779	83 7d e0 00	 cmp	 DWORD PTR _err$64561[ebp], 0
  0077d	75 12		 jne	 SHORT $L64565
  0077f	8b 45 ec	 mov	 eax, DWORD PTR _hKey$64558[ebp]
  00782	50		 push	 eax
  00783	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00789	85 c0		 test	 eax, eax
  0078b	75 04		 jne	 SHORT $L64565

; 206  : 				{
; 207  : 					return true;

  0078d	b0 01		 mov	 al, 1
  0078f	eb 0c		 jmp	 SHORT $L64546
$L64565:

; 208  : 				}
; 209  : 				RegCloseKey( hKey );

  00791	8b 4d ec	 mov	 ecx, DWORD PTR _hKey$64558[ebp]
  00794	51		 push	 ecx
  00795	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L64555:

; 210  : 			} 			
; 211  : 		}
; 212  : 	}
; 213  : 
; 214  : 	return false;

  0079b	32 c0		 xor	 al, al
$L64546:

; 215  : }

  0079d	8b e5		 mov	 esp, ebp
  0079f	5d		 pop	 ebp
  007a0	c3		 ret	 0
?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@11@Z ENDP ; YL_RegInfo::WriteString
_TEXT	ENDS
PUBLIC	?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@PBD11@Z	; YL_RegInfo::WriteString
xdata$x	SEGMENT
$T68603	DD	0ffffffffH
	DD	FLAT:$L68597
	DD	00H
	DD	FLAT:$L68598
	DD	01H
	DD	FLAT:$L68599
$T68601	DD	019930520H
	DD	03H
	DD	FLAT:$T68603
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv92 = -124						; size = 4
tv95 = -120						; size = 4
tv90 = -116						; size = 4
tv94 = -112						; size = 4
tv88 = -108						; size = 4
tv93 = -104						; size = 4
$T68596 = -100						; size = 28
$T68595 = -72						; size = 28
$T68594 = -44						; size = 28
$T68593 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
_pszKeyName$ = 16					; size = 4
_pszKeyValue$ = 20					; size = 4
?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@PBD11@Z PROC NEAR ; YL_RegInfo::WriteString

; 218  : {

  007b0	55		 push	 ebp
  007b1	8b ec		 mov	 ebp, esp
  007b3	6a ff		 push	 -1
  007b5	68 00 00 00 00	 push	 __ehhandler$?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@PBD11@Z
  007ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  007c0	50		 push	 eax
  007c1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  007c8	83 ec 70	 sub	 esp, 112		; 00000070H

; 219  : 	if( pszRegEntry == NULL || pszKeyName == NULL || pszKeyValue == NULL )

  007cb	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  007cf	74 0c		 je	 SHORT $L64573
  007d1	83 7d 10 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  007d5	74 06		 je	 SHORT $L64573
  007d7	83 7d 14 00	 cmp	 DWORD PTR _pszKeyValue$[ebp], 0
  007db	75 07		 jne	 SHORT $L64572
$L64573:

; 220  : 	{
; 221  : 		return false;

  007dd	32 c0		 xor	 al, al
  007df	e9 99 00 00 00	 jmp	 $L64571
$L64572:

; 222  : 	}
; 223  : 	return WriteString( hRegKey,string(pszRegEntry),string(pszKeyName),string(pszKeyValue) );

  007e4	8b 45 14	 mov	 eax, DWORD PTR _pszKeyValue$[ebp]
  007e7	50		 push	 eax
  007e8	8d 4d d4	 lea	 ecx, DWORD PTR $T68594[ebp]
  007eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  007f1	89 45 98	 mov	 DWORD PTR tv93[ebp], eax
  007f4	8b 4d 98	 mov	 ecx, DWORD PTR tv93[ebp]
  007f7	89 4d 94	 mov	 DWORD PTR tv88[ebp], ecx
  007fa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00801	8b 55 10	 mov	 edx, DWORD PTR _pszKeyName$[ebp]
  00804	52		 push	 edx
  00805	8d 4d b8	 lea	 ecx, DWORD PTR $T68595[ebp]
  00808	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0080e	89 45 90	 mov	 DWORD PTR tv94[ebp], eax
  00811	8b 45 90	 mov	 eax, DWORD PTR tv94[ebp]
  00814	89 45 8c	 mov	 DWORD PTR tv90[ebp], eax
  00817	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0081b	8b 4d 0c	 mov	 ecx, DWORD PTR _pszRegEntry$[ebp]
  0081e	51		 push	 ecx
  0081f	8d 4d 9c	 lea	 ecx, DWORD PTR $T68596[ebp]
  00822	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00828	89 45 88	 mov	 DWORD PTR tv95[ebp], eax
  0082b	8b 55 88	 mov	 edx, DWORD PTR tv95[ebp]
  0082e	89 55 84	 mov	 DWORD PTR tv92[ebp], edx
  00831	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00835	8b 45 94	 mov	 eax, DWORD PTR tv88[ebp]
  00838	50		 push	 eax
  00839	8b 4d 8c	 mov	 ecx, DWORD PTR tv90[ebp]
  0083c	51		 push	 ecx
  0083d	8b 55 84	 mov	 edx, DWORD PTR tv92[ebp]
  00840	52		 push	 edx
  00841	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  00844	50		 push	 eax
  00845	e8 00 00 00 00	 call	 ?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@11@Z ; YL_RegInfo::WriteString
  0084a	83 c4 10	 add	 esp, 16			; 00000010H
  0084d	88 45 f3	 mov	 BYTE PTR $T68593[ebp], al
  00850	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00854	8d 4d 9c	 lea	 ecx, DWORD PTR $T68596[ebp]
  00857	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0085d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00861	8d 4d b8	 lea	 ecx, DWORD PTR $T68595[ebp]
  00864	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0086a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00871	8d 4d d4	 lea	 ecx, DWORD PTR $T68594[ebp]
  00874	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0087a	8a 45 f3	 mov	 al, BYTE PTR $T68593[ebp]
$L64571:

; 224  : }

  0087d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00880	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00887	8b e5		 mov	 esp, ebp
  00889	5d		 pop	 ebp
  0088a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L68597:
  00066	8d 4d d4	 lea	 ecx, DWORD PTR $T68594[ebp]
  00069	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68598:
  0006f	8d 4d b8	 lea	 ecx, DWORD PTR $T68595[ebp]
  00072	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68599:
  00078	8d 4d 9c	 lea	 ecx, DWORD PTR $T68596[ebp]
  0007b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@PBD11@Z:
  00081	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68601
  00086	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@PBD11@Z ENDP	; YL_RegInfo::WriteString
PUBLIC	?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAV34@@Z ; YL_RegInfo::ReadString
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	__imp__RegQueryValueExA@24:NEAR
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
$T68606 = -32						; size = 4
$T68605 = -28						; size = 4
_buf2$64592 = -24					; size = 4
_buf1$ = -17						; size = 1
_err$ = -16						; size = 4
_dw$ = -12						; size = 4
_regType$ = -8						; size = 4
_hKey$ = -4						; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
_strKeyName$ = 16					; size = 4
_strKeyValue$ = 20					; size = 4
?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAV34@@Z PROC NEAR ; YL_RegInfo::ReadString

; 228  : {

  00890	55		 push	 ebp
  00891	8b ec		 mov	 ebp, esp
  00893	83 ec 20	 sub	 esp, 32			; 00000020H

; 229  : 	HKEY hKey; 
; 230  : 	DWORD dw = 0; 

  00896	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0

; 231  : 	LONG err ; 
; 232  : 	DWORD regType = REG_SZ;

  0089d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _regType$[ebp], 1

; 233  : 	char buf1[1];
; 234  : 	
; 235  : 	buf1[0] = 0;

  008a4	c6 45 ef 00	 mov	 BYTE PTR _buf1$[ebp], 0

; 236  : 	err = RegOpenKeyEx( hRegKey, strRegEntry.c_str() ,0, KEY_READ, &hKey );

  008a8	8d 45 fc	 lea	 eax, DWORD PTR _hKey$[ebp]
  008ab	50		 push	 eax
  008ac	68 19 00 02 00	 push	 131097			; 00020019H
  008b1	6a 00		 push	 0
  008b3	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  008b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  008bc	50		 push	 eax
  008bd	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  008c0	51		 push	 ecx
  008c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  008c7	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 237  : 	if(err == ERROR_SUCCESS) 

  008ca	83 7d f0 00	 cmp	 DWORD PTR _err$[ebp], 0
  008ce	0f 85 af 00 00
	00		 jne	 $L64589

; 238  : 	{
; 239  : 		err = RegQueryValueEx( hKey, strKeyName.c_str() , 0, &regType,(LPBYTE) buf1, &dw); 

  008d4	8d 55 f4	 lea	 edx, DWORD PTR _dw$[ebp]
  008d7	52		 push	 edx
  008d8	8d 45 ef	 lea	 eax, DWORD PTR _buf1$[ebp]
  008db	50		 push	 eax
  008dc	8d 4d f8	 lea	 ecx, DWORD PTR _regType$[ebp]
  008df	51		 push	 ecx
  008e0	6a 00		 push	 0
  008e2	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  008e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  008eb	50		 push	 eax
  008ec	8b 55 fc	 mov	 edx, DWORD PTR _hKey$[ebp]
  008ef	52		 push	 edx
  008f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  008f6	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 240  : 		if(err == ERROR_MORE_DATA)

  008f9	81 7d f0 ea 00
	00 00		 cmp	 DWORD PTR _err$[ebp], 234 ; 000000eaH
  00900	75 77		 jne	 SHORT $L64591

; 241  : 		{
; 242  : 			char* buf2 = new char[dw + 1];

  00902	8b 45 f4	 mov	 eax, DWORD PTR _dw$[ebp]
  00905	83 c0 01	 add	 eax, 1
  00908	50		 push	 eax
  00909	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0090e	83 c4 04	 add	 esp, 4
  00911	89 45 e4	 mov	 DWORD PTR $T68605[ebp], eax
  00914	8b 4d e4	 mov	 ecx, DWORD PTR $T68605[ebp]
  00917	89 4d e8	 mov	 DWORD PTR _buf2$64592[ebp], ecx

; 243  : 			err = RegQueryValueEx(hKey, strKeyName.c_str() , 0, &regType,(LPBYTE) buf2 , &dw); 

  0091a	8d 55 f4	 lea	 edx, DWORD PTR _dw$[ebp]
  0091d	52		 push	 edx
  0091e	8b 45 e8	 mov	 eax, DWORD PTR _buf2$64592[ebp]
  00921	50		 push	 eax
  00922	8d 4d f8	 lea	 ecx, DWORD PTR _regType$[ebp]
  00925	51		 push	 ecx
  00926	6a 00		 push	 0
  00928	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  0092b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00931	50		 push	 eax
  00932	8b 55 fc	 mov	 edx, DWORD PTR _hKey$[ebp]
  00935	52		 push	 edx
  00936	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  0093c	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 244  : 			buf2[dw] = 0;

  0093f	8b 45 e8	 mov	 eax, DWORD PTR _buf2$64592[ebp]
  00942	03 45 f4	 add	 eax, DWORD PTR _dw$[ebp]
  00945	c6 00 00	 mov	 BYTE PTR [eax], 0

; 245  : 			strKeyValue = buf2;

  00948	8b 4d e8	 mov	 ecx, DWORD PTR _buf2$64592[ebp]
  0094b	51		 push	 ecx
  0094c	8b 4d 14	 mov	 ecx, DWORD PTR _strKeyValue$[ebp]
  0094f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 246  : 			delete[] buf2;

  00955	8b 55 e8	 mov	 edx, DWORD PTR _buf2$64592[ebp]
  00958	89 55 e0	 mov	 DWORD PTR $T68606[ebp], edx
  0095b	8b 45 e0	 mov	 eax, DWORD PTR $T68606[ebp]
  0095e	50		 push	 eax
  0095f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00964	83 c4 04	 add	 esp, 4

; 247  : 			if( RegCloseKey(hKey) == ERROR_SUCCESS )

  00967	8b 4d fc	 mov	 ecx, DWORD PTR _hKey$[ebp]
  0096a	51		 push	 ecx
  0096b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00971	85 c0		 test	 eax, eax
  00973	75 04		 jne	 SHORT $L64591

; 248  : 			{
; 249  : 				return true;

  00975	b0 01		 mov	 al, 1
  00977	eb 0c		 jmp	 SHORT $L64583
$L64591:

; 250  : 			}
; 251  : 		}	
; 252  : 		RegCloseKey( hKey );

  00979	8b 55 fc	 mov	 edx, DWORD PTR _hKey$[ebp]
  0097c	52		 push	 edx
  0097d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L64589:

; 253  : 	} 
; 254  : 
; 255  : 	return false;

  00983	32 c0		 xor	 al, al
$L64583:

; 256  : }

  00985	8b e5		 mov	 esp, ebp
  00987	5d		 pop	 ebp
  00988	c3		 ret	 0
?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAV34@@Z ENDP ; YL_RegInfo::ReadString
_TEXT	ENDS
PUBLIC	?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@PBD1QADI@Z ; YL_RegInfo::ReadString
EXTRN	_strcpy:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
xdata$x	SEGMENT
$T68628	DD	0ffffffffH
	DD	FLAT:$L68616
	DD	00H
	DD	FLAT:$L68618
	DD	01H
	DD	FLAT:$L68620
$T68625	DD	019930520H
	DD	03H
	DD	FLAT:$T68628
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv90 = -132						; size = 4
tv140 = -128						; size = 4
tv148 = -124						; size = 4
tv135 = -120						; size = 4
tv67 = -116						; size = 4
$T68617 = -112						; size = 4
$T68615 = -106						; size = 1
$T68614 = -105						; size = 1
$T68611 = -104						; size = 28
$T68610 = -76						; size = 28
$T68609 = -45						; size = 1
_strKeyValue$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
_pszKeyName$ = 16					; size = 4
_szBuffer$ = 20						; size = 4
_unBuffLen$ = 24					; size = 4
?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@PBD1QADI@Z PROC NEAR ; YL_RegInfo::ReadString

; 259  : {

  00990	55		 push	 ebp
  00991	8b ec		 mov	 ebp, esp
  00993	6a ff		 push	 -1
  00995	68 00 00 00 00	 push	 __ehhandler$?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@PBD1QADI@Z
  0099a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  009a0	50		 push	 eax
  009a1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  009a8	83 ec 78	 sub	 esp, 120		; 00000078H
  009ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  009b0	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  009b3	c7 45 90 00 00
	00 00		 mov	 DWORD PTR $T68617[ebp], 0

; 260  : 	if( pszRegEntry == NULL || pszKeyName == NULL)

  009ba	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  009be	74 06		 je	 SHORT $L64606
  009c0	83 7d 10 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  009c4	75 07		 jne	 SHORT $L64605
$L64606:

; 261  : 	{
; 262  : 		return false;

  009c6	32 c0		 xor	 al, al
  009c8	e9 30 01 00 00	 jmp	 $L64604
$L64605:

; 263  : 	}
; 264  : 	string strKeyValue;

  009cd	8d 4d d4	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  009d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  009d6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 265  : 	if( ReadString( hRegKey,string(pszRegEntry),string(pszKeyName),strKeyValue) && strKeyValue.length() <= unBuffLen - 1  )

  009dd	8b 45 10	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  009e0	50		 push	 eax
  009e1	8d 4d b4	 lea	 ecx, DWORD PTR $T68610[ebp]
  009e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  009ea	89 45 8c	 mov	 DWORD PTR tv67[ebp], eax
  009ed	8b 4d 8c	 mov	 ecx, DWORD PTR tv67[ebp]
  009f0	89 4d 88	 mov	 DWORD PTR tv135[ebp], ecx
  009f3	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  009f7	8b 55 90	 mov	 edx, DWORD PTR $T68617[ebp]
  009fa	83 ca 01	 or	 edx, 1
  009fd	89 55 90	 mov	 DWORD PTR $T68617[ebp], edx
  00a00	8b 45 0c	 mov	 eax, DWORD PTR _pszRegEntry$[ebp]
  00a03	50		 push	 eax
  00a04	8d 4d 98	 lea	 ecx, DWORD PTR $T68611[ebp]
  00a07	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00a0d	89 45 84	 mov	 DWORD PTR tv148[ebp], eax
  00a10	8b 4d 84	 mov	 ecx, DWORD PTR tv148[ebp]
  00a13	89 4d 80	 mov	 DWORD PTR tv140[ebp], ecx
  00a16	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00a1d	8b 55 90	 mov	 edx, DWORD PTR $T68617[ebp]
  00a20	83 ca 02	 or	 edx, 2
  00a23	89 55 90	 mov	 DWORD PTR $T68617[ebp], edx
  00a26	8d 45 d4	 lea	 eax, DWORD PTR _strKeyValue$[ebp]
  00a29	50		 push	 eax
  00a2a	8b 4d 88	 mov	 ecx, DWORD PTR tv135[ebp]
  00a2d	51		 push	 ecx
  00a2e	8b 55 80	 mov	 edx, DWORD PTR tv140[ebp]
  00a31	52		 push	 edx
  00a32	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  00a35	50		 push	 eax
  00a36	e8 00 00 00 00	 call	 ?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAV34@@Z ; YL_RegInfo::ReadString
  00a3b	83 c4 10	 add	 esp, 16			; 00000010H
  00a3e	0f b6 c8	 movzx	 ecx, al
  00a41	85 c9		 test	 ecx, ecx
  00a43	74 1f		 je	 SHORT $L68612
  00a45	8d 4d d4	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  00a48	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00a4e	8b 55 18	 mov	 edx, DWORD PTR _unBuffLen$[ebp]
  00a51	83 ea 01	 sub	 edx, 1
  00a54	3b c2		 cmp	 eax, edx
  00a56	77 0c		 ja	 SHORT $L68612
  00a58	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv90[ebp], 1
  00a62	eb 0a		 jmp	 SHORT $L68613
$L68612:
  00a64	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
$L68613:
  00a6e	8a 85 7c ff ff
	ff		 mov	 al, BYTE PTR tv90[ebp]
  00a74	88 45 d3	 mov	 BYTE PTR $T68609[ebp], al
  00a77	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00a7e	8b 4d 90	 mov	 ecx, DWORD PTR $T68617[ebp]
  00a81	83 e1 02	 and	 ecx, 2
  00a84	74 0d		 je	 SHORT $L68622
  00a86	83 65 90 fd	 and	 DWORD PTR $T68617[ebp], -3 ; fffffffdH
  00a8a	8d 4d 98	 lea	 ecx, DWORD PTR $T68611[ebp]
  00a8d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68622:
  00a93	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00a9a	8b 55 90	 mov	 edx, DWORD PTR $T68617[ebp]
  00a9d	83 e2 01	 and	 edx, 1
  00aa0	74 0d		 je	 SHORT $L68623
  00aa2	83 65 90 fe	 and	 DWORD PTR $T68617[ebp], -2 ; fffffffeH
  00aa6	8d 4d b4	 lea	 ecx, DWORD PTR $T68610[ebp]
  00aa9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68623:
  00aaf	0f b6 45 d3	 movzx	 eax, BYTE PTR $T68609[ebp]
  00ab3	85 c0		 test	 eax, eax
  00ab5	74 2f		 je	 SHORT $L64610

; 266  : 	{
; 267  : 		strcpy( szBuffer,strKeyValue.c_str() );

  00ab7	8d 4d d4	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  00aba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00ac0	50		 push	 eax
  00ac1	8b 4d 14	 mov	 ecx, DWORD PTR _szBuffer$[ebp]
  00ac4	51		 push	 ecx
  00ac5	e8 00 00 00 00	 call	 _strcpy
  00aca	83 c4 08	 add	 esp, 8

; 268  : 		return true;

  00acd	c6 45 97 01	 mov	 BYTE PTR $T68614[ebp], 1
  00ad1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ad8	8d 4d d4	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  00adb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00ae1	8a 45 97	 mov	 al, BYTE PTR $T68614[ebp]
  00ae4	eb 17		 jmp	 SHORT $L64604
$L64610:

; 269  : 	}
; 270  : 	return false;

  00ae6	c6 45 96 00	 mov	 BYTE PTR $T68615[ebp], 0
  00aea	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00af1	8d 4d d4	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  00af4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00afa	8a 45 96	 mov	 al, BYTE PTR $T68615[ebp]
$L64604:

; 271  : }

  00afd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00b00	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00b07	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b0a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b0f	8b e5		 mov	 esp, ebp
  00b11	5d		 pop	 ebp
  00b12	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L68616:
  0008b	8d 4d d4	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  0008e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68618:
  00094	8b 45 90	 mov	 eax, DWORD PTR $T68617[ebp]
  00097	83 e0 01	 and	 eax, 1
  0009a	0f 84 0d 00 00
	00		 je	 $L68619
  000a0	83 65 90 fe	 and	 DWORD PTR $T68617[ebp], -2 ; fffffffeH
  000a4	8d 4d b4	 lea	 ecx, DWORD PTR $T68610[ebp]
  000a7	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68619:
  000ad	c3		 ret	 0
$L68620:
  000ae	8b 45 90	 mov	 eax, DWORD PTR $T68617[ebp]
  000b1	83 e0 02	 and	 eax, 2
  000b4	0f 84 0d 00 00
	00		 je	 $L68621
  000ba	83 65 90 fd	 and	 DWORD PTR $T68617[ebp], -3 ; fffffffdH
  000be	8d 4d 98	 lea	 ecx, DWORD PTR $T68611[ebp]
  000c1	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68621:
  000c7	c3		 ret	 0
__ehhandler$?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@PBD1QADI@Z:
  000c8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68625
  000cd	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@PBD1QADI@Z ENDP	; YL_RegInfo::ReadString
PUBLIC	?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1ABI@Z ; YL_RegInfo::WriteDWORD
; Function compile flags: /Odt
_TEXT	SEGMENT
_err$64632 = -32					; size = 4
_dw$64631 = -28						; size = 4
_regType$64633 = -24					; size = 4
_hKey$64630 = -20					; size = 4
_err$ = -16						; size = 4
_dw$ = -12						; size = 4
_regType$ = -8						; size = 4
_hKey$ = -4						; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
_strKeyName$ = 16					; size = 4
_unValue$ = 20						; size = 4
?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1ABI@Z PROC NEAR ; YL_RegInfo::WriteDWORD

; 275  : {

  00b20	55		 push	 ebp
  00b21	8b ec		 mov	 ebp, esp
  00b23	83 ec 20	 sub	 esp, 32			; 00000020H

; 276  : 
; 277  : 	HKEY hKey;
; 278  : 	DWORD dw = 4; 

  00b26	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 4

; 279  : 	LONG err = -1; 

  00b2d	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1

; 280  : 	DWORD regType = REG_DWORD; 	

  00b34	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _regType$[ebp], 4

; 281  : 
; 282  : 	err = RegOpenKeyEx(hRegKey, strRegEntry.c_str(),0, KEY_SET_VALUE, &hKey) ;

  00b3b	8d 45 fc	 lea	 eax, DWORD PTR _hKey$[ebp]
  00b3e	50		 push	 eax
  00b3f	6a 02		 push	 2
  00b41	6a 00		 push	 0
  00b43	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  00b46	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00b4c	50		 push	 eax
  00b4d	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  00b50	51		 push	 ecx
  00b51	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00b57	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 283  : 	if(err == ERROR_SUCCESS)

  00b5a	83 7d f0 00	 cmp	 DWORD PTR _err$[ebp], 0
  00b5e	75 4f		 jne	 SHORT $L64624

; 284  : 	{ 
; 285  : 		err = RegSetValueEx(hKey, strKeyName.c_str() , 0, regType, (LPBYTE) &unValue, dw); 

  00b60	8b 55 f4	 mov	 edx, DWORD PTR _dw$[ebp]
  00b63	52		 push	 edx
  00b64	8b 45 14	 mov	 eax, DWORD PTR _unValue$[ebp]
  00b67	50		 push	 eax
  00b68	8b 4d f8	 mov	 ecx, DWORD PTR _regType$[ebp]
  00b6b	51		 push	 ecx
  00b6c	6a 00		 push	 0
  00b6e	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  00b71	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00b77	50		 push	 eax
  00b78	8b 55 fc	 mov	 edx, DWORD PTR _hKey$[ebp]
  00b7b	52		 push	 edx
  00b7c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00b82	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 286  : 		if( err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS )

  00b85	83 7d f0 00	 cmp	 DWORD PTR _err$[ebp], 0
  00b89	75 15		 jne	 SHORT $L64626
  00b8b	8b 45 fc	 mov	 eax, DWORD PTR _hKey$[ebp]
  00b8e	50		 push	 eax
  00b8f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00b95	85 c0		 test	 eax, eax
  00b97	75 07		 jne	 SHORT $L64626

; 287  : 		{
; 288  : 			return true;

  00b99	b0 01		 mov	 al, 1
  00b9b	e9 b7 00 00 00	 jmp	 $L64619
$L64626:

; 289  : 		}	
; 290  : 		RegCloseKey( hKey );

  00ba0	8b 4d fc	 mov	 ecx, DWORD PTR _hKey$[ebp]
  00ba3	51		 push	 ecx
  00ba4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 291  : 	} 
; 292  : 	else if( err == ERROR_FILE_NOT_FOUND )

  00baa	e9 a6 00 00 00	 jmp	 $L64627
$L64624:
  00baf	83 7d f0 02	 cmp	 DWORD PTR _err$[ebp], 2
  00bb3	0f 85 9c 00 00
	00		 jne	 $L64627

; 293  : 	{		
; 294  : 		if( CreateKey( hRegKey,strRegEntry) )

  00bb9	8b 55 0c	 mov	 edx, DWORD PTR _strRegEntry$[ebp]
  00bbc	52		 push	 edx
  00bbd	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  00bc0	50		 push	 eax
  00bc1	e8 00 00 00 00	 call	 ?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_RegInfo::CreateKey
  00bc6	83 c4 08	 add	 esp, 8
  00bc9	0f b6 c8	 movzx	 ecx, al
  00bcc	85 c9		 test	 ecx, ecx
  00bce	0f 84 81 00 00
	00		 je	 $L64627

; 295  : 		{
; 296  : 			HKEY hKey;
; 297  : 			DWORD dw = 4; 

  00bd4	c7 45 e4 04 00
	00 00		 mov	 DWORD PTR _dw$64631[ebp], 4

; 298  : 			LONG err = -1; 

  00bdb	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _err$64632[ebp], -1

; 299  : 			DWORD regType = REG_DWORD; 	

  00be2	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR _regType$64633[ebp], 4

; 300  : 
; 301  : 			err = RegOpenKeyEx(hRegKey, strRegEntry.c_str(),0, KEY_SET_VALUE, &hKey) ;

  00be9	8d 55 ec	 lea	 edx, DWORD PTR _hKey$64630[ebp]
  00bec	52		 push	 edx
  00bed	6a 02		 push	 2
  00bef	6a 00		 push	 0
  00bf1	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  00bf4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00bfa	50		 push	 eax
  00bfb	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  00bfe	50		 push	 eax
  00bff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00c05	89 45 e0	 mov	 DWORD PTR _err$64632[ebp], eax

; 302  : 			if(err == ERROR_SUCCESS)

  00c08	83 7d e0 00	 cmp	 DWORD PTR _err$64632[ebp], 0
  00c0c	75 47		 jne	 SHORT $L64627

; 303  : 			{ 
; 304  : 				err = RegSetValueEx(hKey, strKeyName.c_str() , 0, regType, (LPBYTE) &unValue, dw); 

  00c0e	8b 4d e4	 mov	 ecx, DWORD PTR _dw$64631[ebp]
  00c11	51		 push	 ecx
  00c12	8b 55 14	 mov	 edx, DWORD PTR _unValue$[ebp]
  00c15	52		 push	 edx
  00c16	8b 45 e8	 mov	 eax, DWORD PTR _regType$64633[ebp]
  00c19	50		 push	 eax
  00c1a	6a 00		 push	 0
  00c1c	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  00c1f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00c25	50		 push	 eax
  00c26	8b 4d ec	 mov	 ecx, DWORD PTR _hKey$64630[ebp]
  00c29	51		 push	 ecx
  00c2a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00c30	89 45 e0	 mov	 DWORD PTR _err$64632[ebp], eax

; 305  : 				if( err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS )

  00c33	83 7d e0 00	 cmp	 DWORD PTR _err$64632[ebp], 0
  00c37	75 12		 jne	 SHORT $L64636
  00c39	8b 55 ec	 mov	 edx, DWORD PTR _hKey$64630[ebp]
  00c3c	52		 push	 edx
  00c3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00c43	85 c0		 test	 eax, eax
  00c45	75 04		 jne	 SHORT $L64636

; 306  : 				{
; 307  : 					return true;

  00c47	b0 01		 mov	 al, 1
  00c49	eb 0c		 jmp	 SHORT $L64619
$L64636:

; 308  : 				}	
; 309  : 				RegCloseKey( hKey );

  00c4b	8b 45 ec	 mov	 eax, DWORD PTR _hKey$64630[ebp]
  00c4e	50		 push	 eax
  00c4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L64627:

; 310  : 			}
; 311  : 		}
; 312  : 	}
; 313  : 
; 314  : 	return false;

  00c55	32 c0		 xor	 al, al
$L64619:

; 315  : }

  00c57	8b e5		 mov	 esp, ebp
  00c59	5d		 pop	 ebp
  00c5a	c3		 ret	 0
?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1ABI@Z ENDP ; YL_RegInfo::WriteDWORD
_TEXT	ENDS
PUBLIC	?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1ABI@Z ; YL_RegInfo::WriteDWORD
xdata$x	SEGMENT
$T68639	DD	0ffffffffH
	DD	FLAT:$L68634
	DD	00H
	DD	FLAT:$L68635
$T68637	DD	019930520H
	DD	02H
	DD	FLAT:$T68639
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv84 = -88						; size = 4
tv86 = -84						; size = 4
tv82 = -80						; size = 4
tv85 = -76						; size = 4
$T68633 = -72						; size = 28
$T68632 = -44						; size = 28
$T68631 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
_pszKeyName$ = 16					; size = 4
_unValue$ = 20						; size = 4
?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1ABI@Z PROC NEAR ; YL_RegInfo::WriteDWORD

; 317  : {

  00c60	55		 push	 ebp
  00c61	8b ec		 mov	 ebp, esp
  00c63	6a ff		 push	 -1
  00c65	68 00 00 00 00	 push	 __ehhandler$?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1ABI@Z
  00c6a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00c70	50		 push	 eax
  00c71	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00c78	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 318  : 	if( pszRegEntry == NULL || pszKeyName == NULL )

  00c7b	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  00c7f	74 06		 je	 SHORT $L64644
  00c81	83 7d 10 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  00c85	75 04		 jne	 SHORT $L64643
$L64644:

; 319  : 	{
; 320  : 		return false;

  00c87	32 c0		 xor	 al, al
  00c89	eb 72		 jmp	 SHORT $L64642
$L64643:

; 321  : 	}
; 322  : 	return WriteDWORD( hRegKey,string(pszRegEntry),string(pszKeyName),unValue );

  00c8b	8b 45 10	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  00c8e	50		 push	 eax
  00c8f	8d 4d d4	 lea	 ecx, DWORD PTR $T68632[ebp]
  00c92	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00c98	89 45 b4	 mov	 DWORD PTR tv85[ebp], eax
  00c9b	8b 4d b4	 mov	 ecx, DWORD PTR tv85[ebp]
  00c9e	89 4d b0	 mov	 DWORD PTR tv82[ebp], ecx
  00ca1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00ca8	8b 55 0c	 mov	 edx, DWORD PTR _pszRegEntry$[ebp]
  00cab	52		 push	 edx
  00cac	8d 4d b8	 lea	 ecx, DWORD PTR $T68633[ebp]
  00caf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00cb5	89 45 ac	 mov	 DWORD PTR tv86[ebp], eax
  00cb8	8b 45 ac	 mov	 eax, DWORD PTR tv86[ebp]
  00cbb	89 45 a8	 mov	 DWORD PTR tv84[ebp], eax
  00cbe	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00cc2	8b 4d 14	 mov	 ecx, DWORD PTR _unValue$[ebp]
  00cc5	51		 push	 ecx
  00cc6	8b 55 b0	 mov	 edx, DWORD PTR tv82[ebp]
  00cc9	52		 push	 edx
  00cca	8b 45 a8	 mov	 eax, DWORD PTR tv84[ebp]
  00ccd	50		 push	 eax
  00cce	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  00cd1	51		 push	 ecx
  00cd2	e8 00 00 00 00	 call	 ?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1ABI@Z ; YL_RegInfo::WriteDWORD
  00cd7	83 c4 10	 add	 esp, 16			; 00000010H
  00cda	88 45 f3	 mov	 BYTE PTR $T68631[ebp], al
  00cdd	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00ce1	8d 4d b8	 lea	 ecx, DWORD PTR $T68633[ebp]
  00ce4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00cea	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00cf1	8d 4d d4	 lea	 ecx, DWORD PTR $T68632[ebp]
  00cf4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00cfa	8a 45 f3	 mov	 al, BYTE PTR $T68631[ebp]
$L64642:

; 323  : }

  00cfd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00d00	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00d07	8b e5		 mov	 esp, ebp
  00d09	5d		 pop	 ebp
  00d0a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L68634:
  000d2	8d 4d d4	 lea	 ecx, DWORD PTR $T68632[ebp]
  000d5	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68635:
  000db	8d 4d b8	 lea	 ecx, DWORD PTR $T68633[ebp]
  000de	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1ABI@Z:
  000e4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68637
  000e9	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1ABI@Z ENDP	; YL_RegInfo::WriteDWORD
PUBLIC	?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAI@Z ; YL_RegInfo::ReadDWORD
; Function compile flags: /Odt
_TEXT	SEGMENT
_err$ = -16						; size = 4
_dw$ = -12						; size = 4
_regType$ = -8						; size = 4
_hKey$ = -4						; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
_strKeyName$ = 16					; size = 4
_unValue$ = 20						; size = 4
?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAI@Z PROC NEAR ; YL_RegInfo::ReadDWORD

; 327  : {

  00d10	55		 push	 ebp
  00d11	8b ec		 mov	 ebp, esp
  00d13	83 ec 10	 sub	 esp, 16			; 00000010H

; 328  : 	HKEY hKey; 
; 329  : 	DWORD dw = 4; 

  00d16	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 4

; 330  : 	LONG err ; 
; 331  : 	DWORD regType = REG_DWORD;

  00d1d	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _regType$[ebp], 4

; 332  : 	
; 333  : 	err = RegOpenKeyEx(hRegKey, strRegEntry.c_str() ,0, KEY_READ, &hKey);

  00d24	8d 45 fc	 lea	 eax, DWORD PTR _hKey$[ebp]
  00d27	50		 push	 eax
  00d28	68 19 00 02 00	 push	 131097			; 00020019H
  00d2d	6a 00		 push	 0
  00d2f	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  00d32	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00d38	50		 push	 eax
  00d39	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  00d3c	51		 push	 ecx
  00d3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00d43	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 334  : 	if(err == ERROR_SUCCESS) 

  00d46	83 7d f0 00	 cmp	 DWORD PTR _err$[ebp], 0
  00d4a	75 47		 jne	 SHORT $L64658

; 335  : 	{ 
; 336  : 		err = RegQueryValueEx(hKey, strKeyName.c_str() , 0, &regType,(LPBYTE) &unValue, &dw); 

  00d4c	8d 55 f4	 lea	 edx, DWORD PTR _dw$[ebp]
  00d4f	52		 push	 edx
  00d50	8b 45 14	 mov	 eax, DWORD PTR _unValue$[ebp]
  00d53	50		 push	 eax
  00d54	8d 4d f8	 lea	 ecx, DWORD PTR _regType$[ebp]
  00d57	51		 push	 ecx
  00d58	6a 00		 push	 0
  00d5a	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  00d5d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00d63	50		 push	 eax
  00d64	8b 55 fc	 mov	 edx, DWORD PTR _hKey$[ebp]
  00d67	52		 push	 edx
  00d68	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00d6e	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 337  : 		if( err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS )

  00d71	83 7d f0 00	 cmp	 DWORD PTR _err$[ebp], 0
  00d75	75 12		 jne	 SHORT $L64660
  00d77	8b 45 fc	 mov	 eax, DWORD PTR _hKey$[ebp]
  00d7a	50		 push	 eax
  00d7b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00d81	85 c0		 test	 eax, eax
  00d83	75 04		 jne	 SHORT $L64660

; 338  : 		{
; 339  : 			return true;

  00d85	b0 01		 mov	 al, 1
  00d87	eb 0c		 jmp	 SHORT $L64653
$L64660:

; 340  : 		}
; 341  : 		RegCloseKey( hKey );

  00d89	8b 4d fc	 mov	 ecx, DWORD PTR _hKey$[ebp]
  00d8c	51		 push	 ecx
  00d8d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L64658:

; 342  : 	} 
; 343  : 
; 344  : 	return false;

  00d93	32 c0		 xor	 al, al
$L64653:

; 345  : }

  00d95	8b e5		 mov	 esp, ebp
  00d97	5d		 pop	 ebp
  00d98	c3		 ret	 0
?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAI@Z ENDP ; YL_RegInfo::ReadDWORD
_TEXT	ENDS
PUBLIC	?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1AAI@Z	; YL_RegInfo::ReadDWORD
xdata$x	SEGMENT
$T68650	DD	0ffffffffH
	DD	FLAT:$L68645
	DD	00H
	DD	FLAT:$L68646
$T68648	DD	019930520H
	DD	02H
	DD	FLAT:$T68650
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv84 = -88						; size = 4
tv86 = -84						; size = 4
tv82 = -80						; size = 4
tv85 = -76						; size = 4
$T68644 = -72						; size = 28
$T68643 = -44						; size = 28
$T68642 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
_pszKeyName$ = 16					; size = 4
_unValue$ = 20						; size = 4
?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1AAI@Z PROC NEAR ; YL_RegInfo::ReadDWORD

; 348  : {

  00da0	55		 push	 ebp
  00da1	8b ec		 mov	 ebp, esp
  00da3	6a ff		 push	 -1
  00da5	68 00 00 00 00	 push	 __ehhandler$?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1AAI@Z
  00daa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00db0	50		 push	 eax
  00db1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00db8	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 349  : 	if( pszRegEntry == NULL || pszKeyName == NULL )

  00dbb	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  00dbf	74 06		 je	 SHORT $L64668
  00dc1	83 7d 10 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  00dc5	75 04		 jne	 SHORT $L64667
$L64668:

; 350  : 	{
; 351  : 		return false;

  00dc7	32 c0		 xor	 al, al
  00dc9	eb 72		 jmp	 SHORT $L64666
$L64667:

; 352  : 	}
; 353  : 	return ReadDWORD( hRegKey,string(pszRegEntry),string(pszKeyName),unValue );

  00dcb	8b 45 10	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  00dce	50		 push	 eax
  00dcf	8d 4d d4	 lea	 ecx, DWORD PTR $T68643[ebp]
  00dd2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00dd8	89 45 b4	 mov	 DWORD PTR tv85[ebp], eax
  00ddb	8b 4d b4	 mov	 ecx, DWORD PTR tv85[ebp]
  00dde	89 4d b0	 mov	 DWORD PTR tv82[ebp], ecx
  00de1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00de8	8b 55 0c	 mov	 edx, DWORD PTR _pszRegEntry$[ebp]
  00deb	52		 push	 edx
  00dec	8d 4d b8	 lea	 ecx, DWORD PTR $T68644[ebp]
  00def	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00df5	89 45 ac	 mov	 DWORD PTR tv86[ebp], eax
  00df8	8b 45 ac	 mov	 eax, DWORD PTR tv86[ebp]
  00dfb	89 45 a8	 mov	 DWORD PTR tv84[ebp], eax
  00dfe	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00e02	8b 4d 14	 mov	 ecx, DWORD PTR _unValue$[ebp]
  00e05	51		 push	 ecx
  00e06	8b 55 b0	 mov	 edx, DWORD PTR tv82[ebp]
  00e09	52		 push	 edx
  00e0a	8b 45 a8	 mov	 eax, DWORD PTR tv84[ebp]
  00e0d	50		 push	 eax
  00e0e	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  00e11	51		 push	 ecx
  00e12	e8 00 00 00 00	 call	 ?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAI@Z ; YL_RegInfo::ReadDWORD
  00e17	83 c4 10	 add	 esp, 16			; 00000010H
  00e1a	88 45 f3	 mov	 BYTE PTR $T68642[ebp], al
  00e1d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00e21	8d 4d b8	 lea	 ecx, DWORD PTR $T68644[ebp]
  00e24	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00e2a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00e31	8d 4d d4	 lea	 ecx, DWORD PTR $T68643[ebp]
  00e34	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00e3a	8a 45 f3	 mov	 al, BYTE PTR $T68642[ebp]
$L64666:

; 354  : }

  00e3d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00e40	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00e47	8b e5		 mov	 esp, ebp
  00e49	5d		 pop	 ebp
  00e4a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L68645:
  000ee	8d 4d d4	 lea	 ecx, DWORD PTR $T68643[ebp]
  000f1	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68646:
  000f7	8d 4d b8	 lea	 ecx, DWORD PTR $T68644[ebp]
  000fa	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1AAI@Z:
  00100	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68648
  00105	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1AAI@Z ENDP	; YL_RegInfo::ReadDWORD
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T68660	DD	0ffffffffH
	DD	FLAT:$L68654
	DD	00H
	DD	FLAT:$L68653
$T68658	DD	019930520H
	DD	02H
	DD	FLAT:$T68660
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68655 = -44						; size = 4
$T68652 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68655[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68652[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68655[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68655[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68652[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68653:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68652[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68654:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68655[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68656
  00015	83 65 d4 fe	 and	 DWORD PTR $T68655[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68656:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68658
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68673	DD	0ffffffffH
	DD	FLAT:$L68667
	DD	00H
	DD	FLAT:$L68666
$T68671	DD	019930520H
	DD	02H
	DD	FLAT:$T68673
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68668 = -44						; size = 4
$T68665 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68668[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68665[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68668[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68668[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68665[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68666:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68665[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68667:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68668[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68669
  00015	83 65 d4 fe	 and	 DWORD PTR $T68668[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68669:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68671
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68686	DD	0ffffffffH
	DD	FLAT:$L68680
	DD	00H
	DD	FLAT:$L68679
$T68684	DD	019930520H
	DD	02H
	DD	FLAT:$T68686
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T68681 = -44						; size = 4
$T68678 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 1
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68681[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00022	8a 45 0c	 mov	 al, BYTE PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	6a 01		 push	 1
  00028	8d 4d d8	 lea	 ecx, DWORD PTR $T68678[ebp]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
  00031	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  00034	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00037	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  0003a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00041	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00044	52		 push	 edx
  00045	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00058	8b 45 d4	 mov	 eax, DWORD PTR $T68681[ebp]
  0005b	83 c8 01	 or	 eax, 1
  0005e	89 45 d4	 mov	 DWORD PTR $T68681[ebp], eax
  00061	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00065	8d 4d d8	 lea	 ecx, DWORD PTR $T68678[ebp]
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68679:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68678[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68680:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68681[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68682
  00015	83 65 d4 fe	 and	 DWORD PTR $T68681[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68682:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68684
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68699	DD	0ffffffffH
	DD	FLAT:$L68693
	DD	00H
	DD	FLAT:$L68692
$T68697	DD	019930520H
	DD	02H
	DD	FLAT:$T68699
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68694 = -44						; size = 4
$T68691 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68694[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68691[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68694[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68694[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68691[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68692:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68691[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68693:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68694[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68695
  00015	83 65 d4 fe	 and	 DWORD PTR $T68694[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68695:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68697
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68712	DD	0ffffffffH
	DD	FLAT:$L68706
	DD	00H
	DD	FLAT:$L68705
$T68710	DD	019930520H
	DD	02H
	DD	FLAT:$T68712
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68707 = -44						; size = 4
$T68704 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68707[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68704[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8a 55 10	 mov	 dl, BYTE PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68707[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68707[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68704[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68705:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68704[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68706:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68707[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68708
  00015	83 65 d4 fe	 and	 DWORD PTR $T68707[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68708:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68710
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68725	DD	0ffffffffH
	DD	FLAT:$L68719
	DD	00H
	DD	FLAT:$L68718
$T68723	DD	019930520H
	DD	02H
	DD	FLAT:$T68725
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68720 = -44						; size = 4
$T68717 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68720[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68717[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68720[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68720[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68717[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68718:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68717[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68719:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68720[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68721
  00015	83 65 d4 fe	 and	 DWORD PTR $T68720[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68721:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68723
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68738	DD	0ffffffffH
	DD	FLAT:$L68732
	DD	00H
	DD	FLAT:$L68731
$T68736	DD	019930520H
	DD	02H
	DD	FLAT:$T68738
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68733 = -44						; size = 4
$T68730 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68733[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68730[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68733[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68733[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68730[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68731:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68730[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68732:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68733[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68734
  00015	83 65 d4 fe	 and	 DWORD PTR $T68733[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68734:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68736
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68751	DD	0ffffffffH
	DD	FLAT:$L68745
	DD	00H
	DD	FLAT:$L68744
$T68749	DD	019930520H
	DD	02H
	DD	FLAT:$T68751
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T68746 = -44						; size = 4
$T68743 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 2
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68746[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00022	66 8b 45 0c	 mov	 ax, WORD PTR __Left$[ebp]
  00026	50		 push	 eax
  00027	6a 01		 push	 1
  00029	8d 4d d8	 lea	 ecx, DWORD PTR $T68743[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
  00032	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  00035	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00038	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  0003b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00042	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00045	52		 push	 edx
  00046	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00059	8b 45 d4	 mov	 eax, DWORD PTR $T68746[ebp]
  0005c	83 c8 01	 or	 eax, 1
  0005f	89 45 d4	 mov	 DWORD PTR $T68746[ebp], eax
  00062	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00066	8d 4d d8	 lea	 ecx, DWORD PTR $T68743[ebp]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68744:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68743[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68745:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68746[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68747
  00015	83 65 d4 fe	 and	 DWORD PTR $T68746[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68747:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68749
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68764	DD	0ffffffffH
	DD	FLAT:$L68758
	DD	00H
	DD	FLAT:$L68757
$T68762	DD	019930520H
	DD	02H
	DD	FLAT:$T68764
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68759 = -44						; size = 4
$T68756 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68759[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68756[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68759[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68759[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68756[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68757:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68756[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68758:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68759[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68760
  00015	83 65 d4 fe	 and	 DWORD PTR $T68759[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68760:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68762
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68777	DD	0ffffffffH
	DD	FLAT:$L68771
	DD	00H
	DD	FLAT:$L68770
$T68775	DD	019930520H
	DD	02H
	DD	FLAT:$T68777
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68772 = -44						; size = 4
$T68769 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 2
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68772[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68769[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	66 8b 55 10	 mov	 dx, WORD PTR __Right$[ebp]
  00043	52		 push	 edx
  00044	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00057	8b 45 d4	 mov	 eax, DWORD PTR $T68772[ebp]
  0005a	83 c8 01	 or	 eax, 1
  0005d	89 45 d4	 mov	 DWORD PTR $T68772[ebp], eax
  00060	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00064	8d 4d d8	 lea	 ecx, DWORD PTR $T68769[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68770:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68769[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68771:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68772[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68773
  00015	83 65 d4 fe	 and	 DWORD PTR $T68772[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68773:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68775
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?is@?$ctype@D@std@@QBE_NFD@Z:NEAR
EXTRN	__imp_?to_char_type@?$char_traits@D@std@@SADABH@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@D@std@@SAHXZ:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_??1locale@std@@QAE@XZ:NEAR
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB:DWORD
EXTRN	__imp_?width@ios_base@std@@QBEHXZ:NEAR
EXTRN	__imp_?width@ios_base@std@@QAEHH@Z:NEAR
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:NEAR
EXTRN	__imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68794	DD	0ffffffffH
	DD	FLAT:$L68789
	DD	00H
	DD	FLAT:$L68790
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68796	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68788
$T68795	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T68796
$T68792	DD	019930520H
	DD	04H
	DD	FLAT:$T68794
	DD	01H
	DD	FLAT:$T68795
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv205 = -112						; size = 1
tv204 = -111						; size = 1
tv203 = -110						; size = 1
tv202 = -109						; size = 1
tv201 = -108						; size = 4
tv200 = -104						; size = 4
tv199 = -100						; size = 4
tv198 = -96						; size = 4
tv197 = -92						; size = 4
tv196 = -88						; size = 4
tv135 = -84						; size = 4
tv195 = -80						; size = 4
tv194 = -76						; size = 4
tv193 = -72						; size = 4
tv192 = -68						; size = 4
tv189 = -64						; size = 4
tv65 = -60						; size = 4
$T68786 = -56						; size = 4
$T68785 = -52						; size = 4
$T68782 = -48						; size = 4
__Meta$67344 = -44					; size = 4
__Size$67341 = -40					; size = 4
__Ctype_fac$67338 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 dc 01 00
	00		 je	 $L68787

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00055	8d 55 d0	 lea	 edx, DWORD PTR $T68782[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00061	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00064	8b ca		 mov	 ecx, edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0006c	89 45 c4	 mov	 DWORD PTR tv65[ebp], eax
  0006f	8b 45 c4	 mov	 eax, DWORD PTR tv65[ebp]
  00072	89 45 c0	 mov	 DWORD PTR tv189[ebp], eax
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00079	8b 4d c0	 mov	 ecx, DWORD PTR tv189[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 dc	 mov	 DWORD PTR __Ctype_fac$67338[ebp], eax
  00088	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0008c	8d 4d d0	 lea	 ecx, DWORD PTR $T68782[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	50		 push	 eax
  0009e	6a 00		 push	 0
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000a9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000be	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  000c1	83 7d bc 00	 cmp	 DWORD PTR tv192[ebp], 0
  000c5	7e 46		 jle	 SHORT $L68783
  000c7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000d2	8b ca		 mov	 ecx, edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000da	89 45 b8	 mov	 DWORD PTR tv193[ebp], eax
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  000e6	89 45 b4	 mov	 DWORD PTR tv194[ebp], eax
  000e9	8b 45 b8	 mov	 eax, DWORD PTR tv193[ebp]
  000ec	3b 45 b4	 cmp	 eax, DWORD PTR tv194[ebp]
  000ef	73 1c		 jae	 SHORT $L68783
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f9	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00102	89 45 b0	 mov	 DWORD PTR tv195[ebp], eax
  00105	8b 45 b0	 mov	 eax, DWORD PTR tv195[ebp]
  00108	89 45 ac	 mov	 DWORD PTR tv135[ebp], eax
  0010b	eb 12		 jmp	 SHORT $L68784
$L68783:
  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00116	89 45 a8	 mov	 DWORD PTR tv196[ebp], eax
  00119	8b 4d a8	 mov	 ecx, DWORD PTR tv196[ebp]
  0011c	89 4d ac	 mov	 DWORD PTR tv135[ebp], ecx
$L68784:
  0011f	8b 55 ac	 mov	 edx, DWORD PTR tv135[ebp]
  00122	89 55 d8	 mov	 DWORD PTR __Size$67341[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00125	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0012d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00130	8b ca		 mov	 ecx, edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00138	89 45 a4	 mov	 DWORD PTR tv197[ebp], eax
  0013b	8b 4d a4	 mov	 ecx, DWORD PTR tv197[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00144	89 45 a0	 mov	 DWORD PTR tv198[ebp], eax
  00147	8b 45 a0	 mov	 eax, DWORD PTR tv198[ebp]
  0014a	89 45 d4	 mov	 DWORD PTR __Meta$67344[ebp], eax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  0014d	eb 2f		 jmp	 SHORT $L67345
$L67346:
  0014f	8b 4d d8	 mov	 ecx, DWORD PTR __Size$67341[ebp]
  00152	83 e9 01	 sub	 ecx, 1
  00155	89 4d d8	 mov	 DWORD PTR __Size$67341[ebp], ecx
  00158	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0015b	8b 02		 mov	 eax, DWORD PTR [edx]
  0015d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00160	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00169	89 45 9c	 mov	 DWORD PTR tv199[ebp], eax
  0016c	8b 4d 9c	 mov	 ecx, DWORD PTR tv199[ebp]
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00175	89 45 98	 mov	 DWORD PTR tv200[ebp], eax
  00178	8b 4d 98	 mov	 ecx, DWORD PTR tv200[ebp]
  0017b	89 4d d4	 mov	 DWORD PTR __Meta$67344[ebp], ecx
$L67345:
  0017e	83 7d d8 00	 cmp	 DWORD PTR __Size$67341[ebp], 0
  00182	0f 86 8a 00 00
	00		 jbe	 $L67347

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0018e	89 45 94	 mov	 DWORD PTR tv201[ebp], eax
  00191	8b 55 94	 mov	 edx, DWORD PTR tv201[ebp]
  00194	89 55 cc	 mov	 DWORD PTR $T68785[ebp], edx
  00197	8d 45 d4	 lea	 eax, DWORD PTR __Meta$67344[ebp]
  0019a	50		 push	 eax
  0019b	8d 4d cc	 lea	 ecx, DWORD PTR $T68785[ebp]
  0019e	51		 push	 ecx
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  001a5	83 c4 08	 add	 esp, 8
  001a8	88 45 93	 mov	 BYTE PTR tv202[ebp], al
  001ab	0f b6 55 93	 movzx	 edx, BYTE PTR tv202[ebp]
  001af	85 d2		 test	 edx, edx
  001b1	74 0b		 je	 SHORT $L67349

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  001b3	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001b6	83 c8 01	 or	 eax, 1
  001b9	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  001bc	eb 54		 jmp	 SHORT $L67347
$L67349:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  001be	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$67344[ebp]
  001c1	51		 push	 ecx
  001c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  001c8	83 c4 04	 add	 esp, 4
  001cb	88 45 92	 mov	 BYTE PTR tv203[ebp], al
  001ce	8a 55 92	 mov	 dl, BYTE PTR tv203[ebp]
  001d1	52		 push	 edx
  001d2	6a 48		 push	 72			; 00000048H
  001d4	8b 4d dc	 mov	 ecx, DWORD PTR __Ctype_fac$67338[ebp]
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@D@std@@QBE_NFD@Z
  001dd	88 45 91	 mov	 BYTE PTR tv204[ebp], al
  001e0	0f b6 45 91	 movzx	 eax, BYTE PTR tv204[ebp]
  001e4	85 c0		 test	 eax, eax
  001e6	74 02		 je	 SHORT $L67351

; 454  : 				break;	// whitespace, quit

  001e8	eb 28		 jmp	 SHORT $L67347
$L67351:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  001ea	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$67344[ebp]
  001ed	51		 push	 ecx
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  001f4	83 c4 04	 add	 esp, 4
  001f7	88 45 90	 mov	 BYTE PTR tv205[ebp], al
  001fa	8a 55 90	 mov	 dl, BYTE PTR tv205[ebp]
  001fd	52		 push	 edx
  001fe	6a 01		 push	 1
  00200	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z

; 458  : 				_Changed = true;

  00209	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  0020d	e9 3d ff ff ff	 jmp	 $L67346
$L67347:
  00212	eb 1d		 jmp	 SHORT $L68787
$L68788:

; 460  : 		_CATCH_IO_(_Istr)

  00214	6a 01		 push	 1
  00216	6a 04		 push	 4
  00218	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0021b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00220	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00223	8b ca		 mov	 ecx, edx
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0022b	b8 00 00 00 00	 mov	 eax, $L68787
  00230	c3		 ret	 0
$L68787:
  00231	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  00238	6a 00		 push	 0
  0023a	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0023d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023f	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00242	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00245	8b ca		 mov	 ecx, edx
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z

; 464  : 	if (!_Changed)

  0024d	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  00251	85 c0		 test	 eax, eax
  00253	75 09		 jne	 SHORT $L67353

; 465  : 		_State |= ios_base::failbit;

  00255	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00258	83 c9 02	 or	 ecx, 2
  0025b	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L67353:

; 466  : 	_Istr.setstate(_State);

  0025e	6a 00		 push	 0
  00260	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00263	52		 push	 edx
  00264	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00267	8b 08		 mov	 ecx, DWORD PTR [eax]
  00269	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0026c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0026f	8b ca		 mov	 ecx, edx
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 467  : 	return (_Istr);

  00277	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0027a	89 45 c8	 mov	 DWORD PTR $T68786[ebp], eax
  0027d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00284	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00287	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0028c	8b 45 c8	 mov	 eax, DWORD PTR $T68786[ebp]

; 468  : 	}

  0028f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00292	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00299	5f		 pop	 edi
  0029a	5e		 pop	 esi
  0029b	5b		 pop	 ebx
  0029c	8b e5		 mov	 esp, ebp
  0029e	5d		 pop	 ebp
  0029f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68789:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
$L68790:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T68782[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68792
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T68808	DD	0ffffffffH
	DD	FLAT:$L68804
$T68806	DD	019930520H
	DD	01H
	DD	FLAT:$T68808
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0002f	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68804:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68806
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L65870

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L65870:

; 61   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L66757

; 54   : 				_Myistr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L66757:

; 55   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@@
PUBLIC	__CTA2?AVbad_cast@@
PUBLIC	??_R0?AVbad_cast@@@8				; bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
EXTRN	__CxxThrowException@8:NEAR
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:NEAR
EXTRN	__imp_?_Incref@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Register@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z:NEAR
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??0bad_cast@@QAE@ABV0@@Z:NEAR			; bad_cast::bad_cast
EXTRN	??1bad_cast@@UAE@XZ:NEAR			; bad_cast::~bad_cast
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:NEAR
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_??0bad_cast@@QAE@PBD@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68826	DD	0ffffffffH
	DD	FLAT:$L68822
$T68824	DD	019930520H
	DD	01H
	DD	FLAT:$T68826
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT
__TI2?AVbad_cast@@ DD 00H
	DD	FLAT:??1bad_cast@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@@@8 DD FLAT:??_7type_info@@6B@		; bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T68821 = -48						; size = 4
$T68819 = -44						; size = 12
__Pfmod$67267 = -32					; size = 4
__Psave$ = -28						; size = 4
__Lock$ = -24						; size = 4
__Id$ = -20						; size = 4
__Pf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<char> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 24	 sub	 esp, 36			; 00000024H

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	6a 00		 push	 0
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  00032	89 45 e4	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00041	89 45 ec	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00044	8b 4d ec	 mov	 ecx, DWORD PTR __Id$[ebp]
  00047	51		 push	 ecx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00051	89 45 f0	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00054	83 7d f0 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00058	74 02		 je	 SHORT $L67250

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  0005a	eb 62		 jmp	 SHORT $L67251
$L67250:
  0005c	83 7d e4 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  00060	74 08		 je	 SHORT $L67252

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00062	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  00065	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00068	eb 54		 jmp	 SHORT $L67251
$L67252:
  0006a	8d 45 e4	 lea	 eax, DWORD PTR __Psave$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
  00074	83 c4 04	 add	 esp, 4
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	75 1c		 jne	 SHORT $L67255

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  00081	8d 4d d4	 lea	 ecx, DWORD PTR $T68819[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  0008f	8d 4d d4	 lea	 ecx, DWORD PTR $T68819[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 __CxxThrowException@8
$L67255:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  00098	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  0009b	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Psave$[ebp]
  000a1	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000a6	8b 4d e4	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000a9	89 4d e0	 mov	 DWORD PTR __Pfmod$67267[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ac	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$67267[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$67267[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L67251:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000be	8b 55 f0	 mov	 edx, DWORD PTR __Pf$[ebp]
  000c1	89 55 d0	 mov	 DWORD PTR $T68821[ebp], edx
  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d4	8b 45 d0	 mov	 eax, DWORD PTR $T68821[ebp]
$L68818:

; 347  : 	}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68822:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68824
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00003	6a 0a		 push	 10			; 0000000aH
  00005	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0000d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00010	8b ca		 mov	 ecx, edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00018	50		 push	 eax
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
EXTRN	__imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z:NEAR
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68842	DD	0ffffffffH
	DD	FLAT:$L68838
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68844	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68837
$T68843	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T68844
$T68840	DD	019930520H
	DD	03H
	DD	FLAT:$T68842
	DD	01H
	DD	FLAT:$T68843
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
tv175 = -89						; size = 1
tv174 = -88						; size = 4
tv173 = -84						; size = 4
tv172 = -80						; size = 4
tv171 = -74						; size = 1
tv170 = -73						; size = 1
tv169 = -72						; size = 4
tv168 = -68						; size = 4
tv167 = -64						; size = 4
tv166 = -60						; size = 4
tv165 = -56						; size = 4
tv65 = -52						; size = 4
$T68835 = -48						; size = 4
$T68834 = -44						; size = 4
__Meta$67364 = -40					; size = 4
__Metadelim$67363 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 66 01 00
	00		 je	 $L68836

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  0006d	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z
  00077	83 c4 04	 add	 esp, 4
  0007a	89 45 cc	 mov	 DWORD PTR tv65[ebp], eax
  0007d	8b 55 cc	 mov	 edx, DWORD PTR tv65[ebp]
  00080	89 55 dc	 mov	 DWORD PTR __Metadelim$67363[ebp], edx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00083	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0008b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0008e	8b ca		 mov	 ecx, edx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00096	89 45 c8	 mov	 DWORD PTR tv165[ebp], eax
  00099	8b 4d c8	 mov	 ecx, DWORD PTR tv165[ebp]
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000a2	89 45 c4	 mov	 DWORD PTR tv166[ebp], eax
  000a5	8b 45 c4	 mov	 eax, DWORD PTR tv166[ebp]
  000a8	89 45 d8	 mov	 DWORD PTR __Meta$67364[ebp], eax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000ab	eb 26		 jmp	 SHORT $L67365
$L67366:
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000be	89 45 c0	 mov	 DWORD PTR tv167[ebp], eax
  000c1	8b 4d c0	 mov	 ecx, DWORD PTR tv167[ebp]
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000ca	89 45 bc	 mov	 DWORD PTR tv168[ebp], eax
  000cd	8b 45 bc	 mov	 eax, DWORD PTR tv168[ebp]
  000d0	89 45 d8	 mov	 DWORD PTR __Meta$67364[ebp], eax
$L67365:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  000d9	89 45 b8	 mov	 DWORD PTR tv169[ebp], eax
  000dc	8b 4d b8	 mov	 ecx, DWORD PTR tv169[ebp]
  000df	89 4d d4	 mov	 DWORD PTR $T68834[ebp], ecx
  000e2	8d 55 d8	 lea	 edx, DWORD PTR __Meta$67364[ebp]
  000e5	52		 push	 edx
  000e6	8d 45 d4	 lea	 eax, DWORD PTR $T68834[ebp]
  000e9	50		 push	 eax
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  000f0	83 c4 08	 add	 esp, 8
  000f3	88 45 b7	 mov	 BYTE PTR tv170[ebp], al
  000f6	0f b6 4d b7	 movzx	 ecx, BYTE PTR tv170[ebp]
  000fa	85 c9		 test	 ecx, ecx
  000fc	74 0e		 je	 SHORT $L67369

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  000fe	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00101	83 ca 01	 or	 edx, 1
  00104	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  00107	e9 92 00 00 00	 jmp	 $L67367
$L67369:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  0010c	8d 45 dc	 lea	 eax, DWORD PTR __Metadelim$67363[ebp]
  0010f	50		 push	 eax
  00110	8d 4d d8	 lea	 ecx, DWORD PTR __Meta$67364[ebp]
  00113	51		 push	 ecx
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  0011a	83 c4 08	 add	 esp, 8
  0011d	88 45 b6	 mov	 BYTE PTR tv171[ebp], al
  00120	0f b6 55 b6	 movzx	 edx, BYTE PTR tv171[ebp]
  00124	85 d2		 test	 edx, edx
  00126	74 25		 je	 SHORT $L67371

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00128	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  0012c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00134	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00137	8b ca		 mov	 ecx, edx
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0013f	89 45 b0	 mov	 DWORD PTR tv172[ebp], eax
  00142	8b 4d b0	 mov	 ecx, DWORD PTR tv172[ebp]
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ

; 501  : 				break;

  0014b	eb 51		 jmp	 SHORT $L67367
$L67371:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  0014d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00156	89 45 ac	 mov	 DWORD PTR tv173[ebp], eax
  00159	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00162	89 45 a8	 mov	 DWORD PTR tv174[ebp], eax
  00165	8b 45 ac	 mov	 eax, DWORD PTR tv173[ebp]
  00168	3b 45 a8	 cmp	 eax, DWORD PTR tv174[ebp]
  0016b	77 0b		 ja	 SHORT $L67373

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  0016d	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00170	83 c9 02	 or	 ecx, 2
  00173	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  00176	eb 26		 jmp	 SHORT $L67367
$L67373:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  00178	8d 55 d8	 lea	 edx, DWORD PTR __Meta$67364[ebp]
  0017b	52		 push	 edx
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  00182	83 c4 04	 add	 esp, 4
  00185	88 45 a7	 mov	 BYTE PTR tv175[ebp], al
  00188	8a 45 a7	 mov	 al, BYTE PTR tv175[ebp]
  0018b	50		 push	 eax
  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z

; 511  : 				_Changed = true;

  00195	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  00199	e9 0f ff ff ff	 jmp	 $L67366
$L67367:
  0019e	eb 1b		 jmp	 SHORT $L68836
$L68837:

; 513  : 		_CATCH_IO_(_Istr)

  001a0	6a 01		 push	 1
  001a2	6a 04		 push	 4
  001a4	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a9	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001ac	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001b5	b8 00 00 00 00	 mov	 eax, $L68836
  001ba	c3		 ret	 0
$L68836:
  001bb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  001c2	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $L67375

; 517  : 		_State |= ios_base::failbit;

  001ca	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001cd	83 c9 02	 or	 ecx, 2
  001d0	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L67375:

; 518  : 	_Istr.setstate(_State);

  001d3	6a 00		 push	 0
  001d5	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001d8	52		 push	 edx
  001d9	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001de	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001e1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001e4	8b ca		 mov	 ecx, edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 519  : 	return (_Istr);

  001ec	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001ef	89 45 d0	 mov	 DWORD PTR $T68835[ebp], eax
  001f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001f9	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  001fc	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00201	8b 45 d0	 mov	 eax, DWORD PTR $T68835[ebp]

; 520  : 	}

  00204	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00207	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	5b		 pop	 ebx
  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68838:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68840
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z:NEAR
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:NEAR
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:NEAR
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68864	DD	0ffffffffH
	DD	FLAT:$L68860
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68866	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68859
$T68865	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T68866
$T68862	DD	019930520H
	DD	03H
	DD	FLAT:$T68864
	DD	01H
	DD	FLAT:$T68865
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv221 = -129						; size = 1
tv220 = -128						; size = 4
tv219 = -124						; size = 4
tv218 = -120						; size = 4
tv217 = -114						; size = 1
tv216 = -113						; size = 1
tv215 = -112						; size = 4
tv214 = -108						; size = 4
tv213 = -104						; size = 4
tv212 = -100						; size = 4
tv211 = -93						; size = 1
tv210 = -92						; size = 4
tv209 = -88						; size = 4
tv208 = -84						; size = 4
tv207 = -77						; size = 1
tv83 = -76						; size = 4
tv81 = -72						; size = 4
$T68857 = -68						; size = 4
$T68856 = -64						; size = 4
$T68855 = -60						; size = 4
$T68854 = -56						; size = 4
$T68853 = -52						; size = 4
$T68852 = -48						; size = 4
$T68851 = -44						; size = 4
__Count$67398 = -40					; size = 4
__Size$ = -36						; size = 4
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 74	 sub	 esp, 116		; 00000074H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00032	89 45 dc	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0003d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00040	8b ca		 mov	 ecx, edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00048	85 c0		 test	 eax, eax
  0004a	7e 33		 jle	 SHORT $L68849
  0004c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00054	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00057	8b ca		 mov	 ecx, edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0005f	3b 45 dc	 cmp	 eax, DWORD PTR __Size$[ebp]
  00062	76 1b		 jbe	 SHORT $L68849
  00064	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00077	2b 45 dc	 sub	 eax, DWORD PTR __Size$[ebp]
  0007a	89 45 b8	 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 07		 jmp	 SHORT $L68850
$L68849:
  0007f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L68850:
  00086	8b 45 b8	 mov	 eax, DWORD PTR tv81[ebp]
  00089	89 45 e8	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008f	51		 push	 ecx
  00090	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00093	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  0009f	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000a2	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000a7	0f b6 d0	 movzx	 edx, al
  000aa	85 d2		 test	 edx, edx
  000ac	75 0e		 jne	 SHORT $L67387

; 550  : 		_State |= ios_base::badbit;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000b1	83 c8 04	 or	 eax, 4
  000b4	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000b7	e9 22 02 00 00	 jmp	 $L68858
$L67387:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  000d1	89 45 b4	 mov	 DWORD PTR tv83[ebp], eax
  000d4	8b 45 b4	 mov	 eax, DWORD PTR tv83[ebp]
  000d7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000dc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000df	0f 84 8a 00 00
	00		 je	 $L67390

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000e5	eb 09		 jmp	 SHORT $L67391
$L67392:
  000e7	8b 4d e8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  000ea	83 e9 01	 sub	 ecx, 1
  000ed	89 4d e8	 mov	 DWORD PTR __Pad$[ebp], ecx
$L67391:
  000f0	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  000f4	76 79		 jbe	 SHORT $L67390

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  000f6	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000f9	8b 02		 mov	 eax, DWORD PTR [edx]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000fe	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  00107	88 45 b3	 mov	 BYTE PTR tv207[ebp], al
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0010d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00112	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0011b	89 45 ac	 mov	 DWORD PTR tv208[ebp], eax
  0011e	8a 45 b3	 mov	 al, BYTE PTR tv207[ebp]
  00121	50		 push	 eax
  00122	8b 4d ac	 mov	 ecx, DWORD PTR tv208[ebp]
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0012b	89 45 a8	 mov	 DWORD PTR tv209[ebp], eax
  0012e	8b 4d a8	 mov	 ecx, DWORD PTR tv209[ebp]
  00131	89 4d d4	 mov	 DWORD PTR $T68851[ebp], ecx
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0013a	89 45 a4	 mov	 DWORD PTR tv210[ebp], eax
  0013d	8b 55 a4	 mov	 edx, DWORD PTR tv210[ebp]
  00140	89 55 d0	 mov	 DWORD PTR $T68852[ebp], edx
  00143	8d 45 d4	 lea	 eax, DWORD PTR $T68851[ebp]
  00146	50		 push	 eax
  00147	8d 4d d0	 lea	 ecx, DWORD PTR $T68852[ebp]
  0014a	51		 push	 ecx
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00151	83 c4 08	 add	 esp, 8
  00154	88 45 a3	 mov	 BYTE PTR tv211[ebp], al
  00157	0f b6 55 a3	 movzx	 edx, BYTE PTR tv211[ebp]
  0015b	85 d2		 test	 edx, edx
  0015d	74 0b		 je	 SHORT $L67396

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  0015f	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00162	83 c8 04	 or	 eax, 4
  00165	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  00168	eb 05		 jmp	 SHORT $L67390
$L67396:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  0016a	e9 78 ff ff ff	 jmp	 $L67392
$L67390:
  0016f	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00173	0f 85 91 00 00
	00		 jne	 $L67397

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00179	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Count$67398[ebp], 0
  00180	eb 09		 jmp	 SHORT $L67399
$L67400:
  00182	8b 4d d8	 mov	 ecx, DWORD PTR __Count$67398[ebp]
  00185	83 c1 01	 add	 ecx, 1
  00188	89 4d d8	 mov	 DWORD PTR __Count$67398[ebp], ecx
$L67399:
  0018b	8b 55 d8	 mov	 edx, DWORD PTR __Count$67398[ebp]
  0018e	3b 55 dc	 cmp	 edx, DWORD PTR __Size$[ebp]
  00191	73 77		 jae	 SHORT $L67397

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  00193	8b 45 d8	 mov	 eax, DWORD PTR __Count$67398[ebp]
  00196	50		 push	 eax
  00197	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
  001a0	89 45 9c	 mov	 DWORD PTR tv212[ebp], eax
  001a3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001ab	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001b4	89 45 98	 mov	 DWORD PTR tv213[ebp], eax
  001b7	8b 45 9c	 mov	 eax, DWORD PTR tv212[ebp]
  001ba	8a 08		 mov	 cl, BYTE PTR [eax]
  001bc	51		 push	 ecx
  001bd	8b 4d 98	 mov	 ecx, DWORD PTR tv213[ebp]
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  001c6	89 45 94	 mov	 DWORD PTR tv214[ebp], eax
  001c9	8b 55 94	 mov	 edx, DWORD PTR tv214[ebp]
  001cc	89 55 cc	 mov	 DWORD PTR $T68853[ebp], edx
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  001d5	89 45 90	 mov	 DWORD PTR tv215[ebp], eax
  001d8	8b 45 90	 mov	 eax, DWORD PTR tv215[ebp]
  001db	89 45 c8	 mov	 DWORD PTR $T68854[ebp], eax
  001de	8d 4d cc	 lea	 ecx, DWORD PTR $T68853[ebp]
  001e1	51		 push	 ecx
  001e2	8d 55 c8	 lea	 edx, DWORD PTR $T68854[ebp]
  001e5	52		 push	 edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  001ec	83 c4 08	 add	 esp, 8
  001ef	88 45 8f	 mov	 BYTE PTR tv216[ebp], al
  001f2	0f b6 45 8f	 movzx	 eax, BYTE PTR tv216[ebp]
  001f6	85 c0		 test	 eax, eax
  001f8	74 0b		 je	 SHORT $L67404

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  001fa	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001fd	83 c9 04	 or	 ecx, 4
  00200	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  00203	eb 05		 jmp	 SHORT $L67397
$L67404:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00205	e9 78 ff ff ff	 jmp	 $L67400
$L67397:
  0020a	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  0020e	0f 85 98 00 00
	00		 jne	 $L67405

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00214	eb 09		 jmp	 SHORT $L67406
$L67407:
  00216	8b 55 e8	 mov	 edx, DWORD PTR __Pad$[ebp]
  00219	83 ea 01	 sub	 edx, 1
  0021c	89 55 e8	 mov	 DWORD PTR __Pad$[ebp], edx
$L67406:
  0021f	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00223	0f 86 83 00 00
	00		 jbe	 $L67405

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  00229	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0022c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00231	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00234	8b ca		 mov	 ecx, edx
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0023c	88 45 8e	 mov	 BYTE PTR tv217[ebp], al
  0023f	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00242	8b 08		 mov	 ecx, DWORD PTR [eax]
  00244	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00247	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0024a	8b ca		 mov	 ecx, edx
  0024c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00252	89 45 88	 mov	 DWORD PTR tv218[ebp], eax
  00255	8a 45 8e	 mov	 al, BYTE PTR tv217[ebp]
  00258	50		 push	 eax
  00259	8b 4d 88	 mov	 ecx, DWORD PTR tv218[ebp]
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00262	89 45 84	 mov	 DWORD PTR tv219[ebp], eax
  00265	8b 4d 84	 mov	 ecx, DWORD PTR tv219[ebp]
  00268	89 4d c4	 mov	 DWORD PTR $T68855[ebp], ecx
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  00271	89 45 80	 mov	 DWORD PTR tv220[ebp], eax
  00274	8b 55 80	 mov	 edx, DWORD PTR tv220[ebp]
  00277	89 55 c0	 mov	 DWORD PTR $T68856[ebp], edx
  0027a	8d 45 c4	 lea	 eax, DWORD PTR $T68855[ebp]
  0027d	50		 push	 eax
  0027e	8d 4d c0	 lea	 ecx, DWORD PTR $T68856[ebp]
  00281	51		 push	 ecx
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00288	83 c4 08	 add	 esp, 8
  0028b	88 85 7f ff ff
	ff		 mov	 BYTE PTR tv221[ebp], al
  00291	0f b6 95 7f ff
	ff ff		 movzx	 edx, BYTE PTR tv221[ebp]
  00298	85 d2		 test	 edx, edx
  0029a	74 0b		 je	 SHORT $L67411

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  0029c	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0029f	83 c8 04	 or	 eax, 4
  002a2	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  002a5	eb 05		 jmp	 SHORT $L67405
$L67411:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  002a7	e9 6a ff ff ff	 jmp	 $L67407
$L67405:
  002ac	6a 00		 push	 0
  002ae	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  002b3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002b6	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  002bf	eb 1d		 jmp	 SHORT $L68858
$L68859:

; 581  : 		_CATCH_IO_(_Ostr)

  002c1	6a 01		 push	 1
  002c3	6a 04		 push	 4
  002c5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ca	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002cd	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002d0	8b ca		 mov	 ecx, edx
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  002d8	b8 00 00 00 00	 mov	 eax, $L68858
  002dd	c3		 ret	 0
$L68858:
  002de	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  002e5	6a 00		 push	 0
  002e7	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002ea	50		 push	 eax
  002eb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002f3	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 585  : 	return (_Ostr);

  002fc	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002ff	89 45 bc	 mov	 DWORD PTR $T68857[ebp], eax
  00302	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00309	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0030c	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00311	8b 45 bc	 mov	 eax, DWORD PTR $T68857[ebp]

; 586  : 	}

  00314	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00317	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0031e	5f		 pop	 edi
  0031f	5e		 pop	 esi
  00320	5b		 pop	 ebx
  00321	8b e5		 mov	 esp, ebp
  00323	5d		 pop	 ebp
  00324	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68860:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68862
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T68875	DD	0ffffffffH
	DD	FLAT:$L68871
$T68873	DD	019930520H
	DD	01H
	DD	FLAT:$T68875
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00037	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	74 30		 je	 SHORT $L66766
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  00058	85 c0		 test	 eax, eax
  0005a	74 1b		 je	 SHORT $L66766

; 90   : 				_Ostr.tie()->flush();

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b ca		 mov	 ecx, edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0006f	8b c8		 mov	 ecx, eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$L66766:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00077	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00082	8b ca		 mov	 ecx, edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68871:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68873
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:NEAR
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68884	DD	0ffffffffH
	DD	FLAT:$L68880
$T68882	DD	019930520H
	DD	01H
	DD	FLAT:$T68884
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0b		 jne	 SHORT $L66768

; 99   : 				this->_Myostr._Osfx();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$L66768:

; 100  : 			}

  0003b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68880:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68882
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L67003

; 70   : 				_Myostr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L67003:

; 71   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L67006

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L67006:

; 77   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?is@?$ctype@_W@std@@QBE_NF_W@Z:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB:DWORD
EXTRN	__imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z:NEAR
EXTRN	__imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ:NEAR
EXTRN	__imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@_W@std@@SAGXZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T68907	DD	0ffffffffH
	DD	FLAT:$L68902
	DD	00H
	DD	FLAT:$L68903
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68909	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68901
$T68908	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T68909
$T68905	DD	019930520H
	DD	04H
	DD	FLAT:$T68907
	DD	01H
	DD	FLAT:$T68908
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv205 = -112						; size = 2
tv204 = -109						; size = 1
tv203 = -108						; size = 2
tv202 = -105						; size = 1
tv201 = -104						; size = 2
tv200 = -102						; size = 2
tv199 = -100						; size = 4
tv198 = -94						; size = 2
tv197 = -92						; size = 4
tv196 = -88						; size = 4
tv135 = -84						; size = 4
tv195 = -80						; size = 4
tv194 = -76						; size = 4
tv193 = -72						; size = 4
tv192 = -68						; size = 4
tv189 = -64						; size = 4
tv65 = -60						; size = 4
$T68899 = -56						; size = 4
$T68898 = -50						; size = 2
$T68895 = -48						; size = 4
__Meta$67428 = -44					; size = 2
__Size$67425 = -40					; size = 4
__Ctype_fac$67422 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 e9 01 00
	00		 je	 $L68900

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00055	8d 55 d0	 lea	 edx, DWORD PTR $T68895[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00061	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00064	8b ca		 mov	 ecx, edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0006c	89 45 c4	 mov	 DWORD PTR tv65[ebp], eax
  0006f	8b 45 c4	 mov	 eax, DWORD PTR tv65[ebp]
  00072	89 45 c0	 mov	 DWORD PTR tv189[ebp], eax
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00079	8b 4d c0	 mov	 ecx, DWORD PTR tv189[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 dc	 mov	 DWORD PTR __Ctype_fac$67422[ebp], eax
  00088	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0008c	8d 4d d0	 lea	 ecx, DWORD PTR $T68895[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	50		 push	 eax
  0009e	6a 00		 push	 0
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000a9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000be	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  000c1	83 7d bc 00	 cmp	 DWORD PTR tv192[ebp], 0
  000c5	7e 46		 jle	 SHORT $L68896
  000c7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000d2	8b ca		 mov	 ecx, edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000da	89 45 b8	 mov	 DWORD PTR tv193[ebp], eax
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  000e6	89 45 b4	 mov	 DWORD PTR tv194[ebp], eax
  000e9	8b 45 b8	 mov	 eax, DWORD PTR tv193[ebp]
  000ec	3b 45 b4	 cmp	 eax, DWORD PTR tv194[ebp]
  000ef	73 1c		 jae	 SHORT $L68896
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f9	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00102	89 45 b0	 mov	 DWORD PTR tv195[ebp], eax
  00105	8b 45 b0	 mov	 eax, DWORD PTR tv195[ebp]
  00108	89 45 ac	 mov	 DWORD PTR tv135[ebp], eax
  0010b	eb 12		 jmp	 SHORT $L68897
$L68896:
  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00116	89 45 a8	 mov	 DWORD PTR tv196[ebp], eax
  00119	8b 4d a8	 mov	 ecx, DWORD PTR tv196[ebp]
  0011c	89 4d ac	 mov	 DWORD PTR tv135[ebp], ecx
$L68897:
  0011f	8b 55 ac	 mov	 edx, DWORD PTR tv135[ebp]
  00122	89 55 d8	 mov	 DWORD PTR __Size$67425[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00125	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0012d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00130	8b ca		 mov	 ecx, edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00138	89 45 a4	 mov	 DWORD PTR tv197[ebp], eax
  0013b	8b 4d a4	 mov	 ecx, DWORD PTR tv197[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  00144	66 89 45 a2	 mov	 WORD PTR tv198[ebp], ax
  00148	66 8b 45 a2	 mov	 ax, WORD PTR tv198[ebp]
  0014c	66 89 45 d4	 mov	 WORD PTR __Meta$67428[ebp], ax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  00150	eb 32		 jmp	 SHORT $L67429
$L67430:
  00152	8b 4d d8	 mov	 ecx, DWORD PTR __Size$67425[ebp]
  00155	83 e9 01	 sub	 ecx, 1
  00158	89 4d d8	 mov	 DWORD PTR __Size$67425[ebp], ecx
  0015b	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0015e	8b 02		 mov	 eax, DWORD PTR [edx]
  00160	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00163	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0016c	89 45 9c	 mov	 DWORD PTR tv199[ebp], eax
  0016f	8b 4d 9c	 mov	 ecx, DWORD PTR tv199[ebp]
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  00178	66 89 45 9a	 mov	 WORD PTR tv200[ebp], ax
  0017c	66 8b 4d 9a	 mov	 cx, WORD PTR tv200[ebp]
  00180	66 89 4d d4	 mov	 WORD PTR __Meta$67428[ebp], cx
$L67429:
  00184	83 7d d8 00	 cmp	 DWORD PTR __Size$67425[ebp], 0
  00188	0f 86 91 00 00
	00		 jbe	 $L67431

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00194	66 89 45 98	 mov	 WORD PTR tv201[ebp], ax
  00198	66 8b 55 98	 mov	 dx, WORD PTR tv201[ebp]
  0019c	66 89 55 ce	 mov	 WORD PTR $T68898[ebp], dx
  001a0	8d 45 d4	 lea	 eax, DWORD PTR __Meta$67428[ebp]
  001a3	50		 push	 eax
  001a4	8d 4d ce	 lea	 ecx, DWORD PTR $T68898[ebp]
  001a7	51		 push	 ecx
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  001ae	83 c4 08	 add	 esp, 8
  001b1	88 45 97	 mov	 BYTE PTR tv202[ebp], al
  001b4	0f b6 55 97	 movzx	 edx, BYTE PTR tv202[ebp]
  001b8	85 d2		 test	 edx, edx
  001ba	74 0b		 je	 SHORT $L67433

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  001bc	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001bf	83 c8 01	 or	 eax, 1
  001c2	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  001c5	eb 58		 jmp	 SHORT $L67431
$L67433:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  001c7	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$67428[ebp]
  001ca	51		 push	 ecx
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  001d1	83 c4 04	 add	 esp, 4
  001d4	66 89 45 94	 mov	 WORD PTR tv203[ebp], ax
  001d8	66 8b 55 94	 mov	 dx, WORD PTR tv203[ebp]
  001dc	52		 push	 edx
  001dd	6a 48		 push	 72			; 00000048H
  001df	8b 4d dc	 mov	 ecx, DWORD PTR __Ctype_fac$67422[ebp]
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z
  001e8	88 45 93	 mov	 BYTE PTR tv204[ebp], al
  001eb	0f b6 45 93	 movzx	 eax, BYTE PTR tv204[ebp]
  001ef	85 c0		 test	 eax, eax
  001f1	74 02		 je	 SHORT $L67435

; 454  : 				break;	// whitespace, quit

  001f3	eb 2a		 jmp	 SHORT $L67431
$L67435:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  001f5	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$67428[ebp]
  001f8	51		 push	 ecx
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  001ff	83 c4 04	 add	 esp, 4
  00202	66 89 45 90	 mov	 WORD PTR tv205[ebp], ax
  00206	66 8b 55 90	 mov	 dx, WORD PTR tv205[ebp]
  0020a	52		 push	 edx
  0020b	6a 01		 push	 1
  0020d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z

; 458  : 				_Changed = true;

  00216	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  0021a	e9 33 ff ff ff	 jmp	 $L67430
$L67431:
  0021f	eb 1d		 jmp	 SHORT $L68900
$L68901:

; 460  : 		_CATCH_IO_(_Istr)

  00221	6a 01		 push	 1
  00223	6a 04		 push	 4
  00225	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00228	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0022d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00230	8b ca		 mov	 ecx, edx
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  00238	b8 00 00 00 00	 mov	 eax, $L68900
  0023d	c3		 ret	 0
$L68900:
  0023e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  00245	6a 00		 push	 0
  00247	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0024a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024c	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0024f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00252	8b ca		 mov	 ecx, edx
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z

; 464  : 	if (!_Changed)

  0025a	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  0025e	85 c0		 test	 eax, eax
  00260	75 09		 jne	 SHORT $L67437

; 465  : 		_State |= ios_base::failbit;

  00262	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00265	83 c9 02	 or	 ecx, 2
  00268	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L67437:

; 466  : 	_Istr.setstate(_State);

  0026b	6a 00		 push	 0
  0026d	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00270	52		 push	 edx
  00271	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00274	8b 08		 mov	 ecx, DWORD PTR [eax]
  00276	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00279	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0027c	8b ca		 mov	 ecx, edx
  0027e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 467  : 	return (_Istr);

  00284	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00287	89 45 c8	 mov	 DWORD PTR $T68899[ebp], eax
  0028a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00291	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00294	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00299	8b 45 c8	 mov	 eax, DWORD PTR $T68899[ebp]

; 468  : 	}

  0029c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0029f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002a6	5f		 pop	 edi
  002a7	5e		 pop	 esi
  002a8	5b		 pop	 ebx
  002a9	8b e5		 mov	 esp, ebp
  002ab	5d		 pop	 ebp
  002ac	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68902:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
$L68903:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T68895[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68905
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T68921	DD	0ffffffffH
	DD	FLAT:$L68917
$T68919	DD	019930520H
	DD	01H
	DD	FLAT:$T68921
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0002f	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68917:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68919
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L65877

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L65877:

; 61   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L66760

; 54   : 				_Myistr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L66760:

; 55   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
EXTRN	__imp_?id@?$ctype@_W@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68938	DD	0ffffffffH
	DD	FLAT:$L68934
$T68936	DD	019930520H
	DD	01H
	DD	FLAT:$T68938
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T68933 = -48						; size = 4
$T68932 = -44						; size = 12
__Pfmod$67295 = -32					; size = 4
__Psave$ = -28						; size = 4
__Lock$ = -24						; size = 4
__Id$ = -20						; size = 4
__Pf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 24	 sub	 esp, 36			; 00000024H

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	6a 00		 push	 0
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  00032	89 45 e4	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@_W@std@@2V0locale@2@A
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00041	89 45 ec	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00044	8b 4d ec	 mov	 ecx, DWORD PTR __Id$[ebp]
  00047	51		 push	 ecx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00051	89 45 f0	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00054	83 7d f0 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00058	74 02		 je	 SHORT $L67286

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  0005a	eb 62		 jmp	 SHORT $L67287
$L67286:
  0005c	83 7d e4 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  00060	74 08		 je	 SHORT $L67288

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00062	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  00065	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00068	eb 54		 jmp	 SHORT $L67287
$L67288:
  0006a	8d 45 e4	 lea	 eax, DWORD PTR __Psave$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z
  00074	83 c4 04	 add	 esp, 4
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	75 1c		 jne	 SHORT $L67291

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  00081	8d 4d d4	 lea	 ecx, DWORD PTR $T68932[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  0008f	8d 4d d4	 lea	 ecx, DWORD PTR $T68932[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 __CxxThrowException@8
$L67291:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  00098	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  0009b	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Psave$[ebp]
  000a1	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000a6	8b 4d e4	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000a9	89 4d e0	 mov	 DWORD PTR __Pfmod$67295[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ac	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$67295[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$67295[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L67287:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000be	8b 55 f0	 mov	 edx, DWORD PTR __Pf$[ebp]
  000c1	89 55 d0	 mov	 DWORD PTR $T68933[ebp], edx
  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d4	8b 45 d0	 mov	 eax, DWORD PTR $T68933[ebp]
$L68931:

; 347  : 	}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68934:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68936
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00003	6a 0a		 push	 10			; 0000000aH
  00005	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0000d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00010	8b ca		 mov	 ecx, edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  00018	50		 push	 eax
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
EXTRN	__imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68954	DD	0ffffffffH
	DD	FLAT:$L68950
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68956	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68949
$T68955	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T68956
$T68952	DD	019930520H
	DD	03H
	DD	FLAT:$T68954
	DD	01H
	DD	FLAT:$T68955
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT
tv175 = -86						; size = 2
tv174 = -84						; size = 4
tv173 = -80						; size = 4
tv172 = -76						; size = 4
tv171 = -70						; size = 1
tv170 = -69						; size = 1
tv169 = -68						; size = 2
tv168 = -66						; size = 2
tv167 = -64						; size = 4
tv166 = -58						; size = 2
tv165 = -56						; size = 4
tv65 = -50						; size = 2
$T68947 = -48						; size = 4
$T68946 = -42						; size = 2
__Meta$67448 = -40					; size = 2
__Metadelim$67447 = -36					; size = 2
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 2
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 48	 sub	 esp, 72			; 00000048H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 74 01 00
	00		 je	 $L68948

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  0006d	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z
  00077	83 c4 04	 add	 esp, 4
  0007a	66 89 45 ce	 mov	 WORD PTR tv65[ebp], ax
  0007e	66 8b 55 ce	 mov	 dx, WORD PTR tv65[ebp]
  00082	66 89 55 dc	 mov	 WORD PTR __Metadelim$67447[ebp], dx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00086	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0008e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00091	8b ca		 mov	 ecx, edx
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00099	89 45 c8	 mov	 DWORD PTR tv165[ebp], eax
  0009c	8b 4d c8	 mov	 ecx, DWORD PTR tv165[ebp]
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000a5	66 89 45 c6	 mov	 WORD PTR tv166[ebp], ax
  000a9	66 8b 45 c6	 mov	 ax, WORD PTR tv166[ebp]
  000ad	66 89 45 d8	 mov	 WORD PTR __Meta$67448[ebp], ax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000b1	eb 29		 jmp	 SHORT $L67449
$L67450:
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000bb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  000c4	89 45 c0	 mov	 DWORD PTR tv167[ebp], eax
  000c7	8b 4d c0	 mov	 ecx, DWORD PTR tv167[ebp]
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000d0	66 89 45 be	 mov	 WORD PTR tv168[ebp], ax
  000d4	66 8b 45 be	 mov	 ax, WORD PTR tv168[ebp]
  000d8	66 89 45 d8	 mov	 WORD PTR __Meta$67448[ebp], ax
$L67449:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  000e2	66 89 45 bc	 mov	 WORD PTR tv169[ebp], ax
  000e6	66 8b 4d bc	 mov	 cx, WORD PTR tv169[ebp]
  000ea	66 89 4d d6	 mov	 WORD PTR $T68946[ebp], cx
  000ee	8d 55 d8	 lea	 edx, DWORD PTR __Meta$67448[ebp]
  000f1	52		 push	 edx
  000f2	8d 45 d6	 lea	 eax, DWORD PTR $T68946[ebp]
  000f5	50		 push	 eax
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  000fc	83 c4 08	 add	 esp, 8
  000ff	88 45 bb	 mov	 BYTE PTR tv170[ebp], al
  00102	0f b6 4d bb	 movzx	 ecx, BYTE PTR tv170[ebp]
  00106	85 c9		 test	 ecx, ecx
  00108	74 0e		 je	 SHORT $L67453

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  0010a	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  0010d	83 ca 01	 or	 edx, 1
  00110	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  00113	e9 94 00 00 00	 jmp	 $L67451
$L67453:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  00118	8d 45 dc	 lea	 eax, DWORD PTR __Metadelim$67447[ebp]
  0011b	50		 push	 eax
  0011c	8d 4d d8	 lea	 ecx, DWORD PTR __Meta$67448[ebp]
  0011f	51		 push	 ecx
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  00126	83 c4 08	 add	 esp, 8
  00129	88 45 ba	 mov	 BYTE PTR tv171[ebp], al
  0012c	0f b6 55 ba	 movzx	 edx, BYTE PTR tv171[ebp]
  00130	85 d2		 test	 edx, edx
  00132	74 25		 je	 SHORT $L67455

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00134	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  00138	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0013b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00140	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00143	8b ca		 mov	 ecx, edx
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0014b	89 45 b4	 mov	 DWORD PTR tv172[ebp], eax
  0014e	8b 4d b4	 mov	 ecx, DWORD PTR tv172[ebp]
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ

; 501  : 				break;

  00157	eb 53		 jmp	 SHORT $L67451
$L67455:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  00159	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00162	89 45 b0	 mov	 DWORD PTR tv173[ebp], eax
  00165	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  0016e	89 45 ac	 mov	 DWORD PTR tv174[ebp], eax
  00171	8b 45 b0	 mov	 eax, DWORD PTR tv173[ebp]
  00174	3b 45 ac	 cmp	 eax, DWORD PTR tv174[ebp]
  00177	77 0b		 ja	 SHORT $L67457

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  00179	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  0017c	83 c9 02	 or	 ecx, 2
  0017f	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  00182	eb 28		 jmp	 SHORT $L67451
$L67457:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  00184	8d 55 d8	 lea	 edx, DWORD PTR __Meta$67448[ebp]
  00187	52		 push	 edx
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  0018e	83 c4 04	 add	 esp, 4
  00191	66 89 45 aa	 mov	 WORD PTR tv175[ebp], ax
  00195	66 8b 45 aa	 mov	 ax, WORD PTR tv175[ebp]
  00199	50		 push	 eax
  0019a	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z

; 511  : 				_Changed = true;

  001a3	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  001a7	e9 07 ff ff ff	 jmp	 $L67450
$L67451:
  001ac	eb 1b		 jmp	 SHORT $L68948
$L68949:

; 513  : 		_CATCH_IO_(_Istr)

  001ae	6a 01		 push	 1
  001b0	6a 04		 push	 4
  001b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b7	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001ba	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  001c3	b8 00 00 00 00	 mov	 eax, $L68948
  001c8	c3		 ret	 0
$L68948:
  001c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  001d0	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  001d4	85 c0		 test	 eax, eax
  001d6	75 09		 jne	 SHORT $L67459

; 517  : 		_State |= ios_base::failbit;

  001d8	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001db	83 c9 02	 or	 ecx, 2
  001de	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L67459:

; 518  : 	_Istr.setstate(_State);

  001e1	6a 00		 push	 0
  001e3	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001e6	52		 push	 edx
  001e7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ec	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001ef	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001f2	8b ca		 mov	 ecx, edx
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 519  : 	return (_Istr);

  001fa	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001fd	89 45 d0	 mov	 DWORD PTR $T68947[ebp], eax
  00200	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00207	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0020a	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0020f	8b 45 d0	 mov	 eax, DWORD PTR $T68947[ebp]

; 520  : 	}

  00212	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00215	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0021c	5f		 pop	 edi
  0021d	5e		 pop	 esi
  0021e	5b		 pop	 ebx
  0021f	8b e5		 mov	 esp, ebp
  00221	5d		 pop	 ebp
  00222	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68950:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
__ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68952
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z:NEAR
EXTRN	__imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z:NEAR
EXTRN	__imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68976	DD	0ffffffffH
	DD	FLAT:$L68972
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68978	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68971
$T68977	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T68978
$T68974	DD	019930520H
	DD	03H
	DD	FLAT:$T68976
	DD	01H
	DD	FLAT:$T68977
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv221 = -105						; size = 1
tv220 = -104						; size = 2
tv219 = -102						; size = 2
tv218 = -100						; size = 4
tv217 = -96						; size = 2
tv216 = -93						; size = 1
tv215 = -92						; size = 2
tv214 = -90						; size = 2
tv213 = -88						; size = 4
tv212 = -84						; size = 4
tv211 = -77						; size = 1
tv210 = -76						; size = 2
tv209 = -74						; size = 2
tv208 = -72						; size = 4
tv207 = -66						; size = 2
tv83 = -64						; size = 4
tv81 = -60						; size = 4
$T68969 = -56						; size = 4
$T68968 = -52						; size = 2
$T68967 = -50						; size = 2
$T68966 = -48						; size = 2
$T68965 = -46						; size = 2
$T68964 = -44						; size = 2
$T68963 = -42						; size = 2
__Count$67482 = -40					; size = 4
__Size$ = -36						; size = 4
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00032	89 45 dc	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0003d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00040	8b ca		 mov	 ecx, edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00048	85 c0		 test	 eax, eax
  0004a	7e 33		 jle	 SHORT $L68961
  0004c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00054	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00057	8b ca		 mov	 ecx, edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0005f	3b 45 dc	 cmp	 eax, DWORD PTR __Size$[ebp]
  00062	76 1b		 jbe	 SHORT $L68961
  00064	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00077	2b 45 dc	 sub	 eax, DWORD PTR __Size$[ebp]
  0007a	89 45 c4	 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 07		 jmp	 SHORT $L68962
$L68961:
  0007f	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L68962:
  00086	8b 45 c4	 mov	 eax, DWORD PTR tv81[ebp]
  00089	89 45 e8	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008f	51		 push	 ecx
  00090	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00093	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  0009f	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000a2	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  000a7	0f b6 d0	 movzx	 edx, al
  000aa	85 d2		 test	 edx, edx
  000ac	75 0e		 jne	 SHORT $L67471

; 550  : 		_State |= ios_base::badbit;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000b1	83 c8 04	 or	 eax, 4
  000b4	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000b7	e9 37 02 00 00	 jmp	 $L68970
$L67471:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  000d1	89 45 c0	 mov	 DWORD PTR tv83[ebp], eax
  000d4	8b 45 c0	 mov	 eax, DWORD PTR tv83[ebp]
  000d7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000dc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000df	0f 84 96 00 00
	00		 je	 $L67474

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000e5	eb 09		 jmp	 SHORT $L67475
$L67476:
  000e7	8b 4d e8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  000ea	83 e9 01	 sub	 ecx, 1
  000ed	89 4d e8	 mov	 DWORD PTR __Pad$[ebp], ecx
$L67475:
  000f0	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  000f4	0f 86 81 00 00
	00		 jbe	 $L67474

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  000fa	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00102	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  0010b	66 89 45 be	 mov	 WORD PTR tv207[ebp], ax
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00117	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00120	89 45 b8	 mov	 DWORD PTR tv208[ebp], eax
  00123	66 8b 45 be	 mov	 ax, WORD PTR tv207[ebp]
  00127	50		 push	 eax
  00128	8b 4d b8	 mov	 ecx, DWORD PTR tv208[ebp]
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00131	66 89 45 b6	 mov	 WORD PTR tv209[ebp], ax
  00135	66 8b 4d b6	 mov	 cx, WORD PTR tv209[ebp]
  00139	66 89 4d d6	 mov	 WORD PTR $T68963[ebp], cx
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00143	66 89 45 b4	 mov	 WORD PTR tv210[ebp], ax
  00147	66 8b 55 b4	 mov	 dx, WORD PTR tv210[ebp]
  0014b	66 89 55 d4	 mov	 WORD PTR $T68964[ebp], dx
  0014f	8d 45 d6	 lea	 eax, DWORD PTR $T68963[ebp]
  00152	50		 push	 eax
  00153	8d 4d d4	 lea	 ecx, DWORD PTR $T68964[ebp]
  00156	51		 push	 ecx
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  0015d	83 c4 08	 add	 esp, 8
  00160	88 45 b3	 mov	 BYTE PTR tv211[ebp], al
  00163	0f b6 55 b3	 movzx	 edx, BYTE PTR tv211[ebp]
  00167	85 d2		 test	 edx, edx
  00169	74 0b		 je	 SHORT $L67480

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  0016b	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0016e	83 c8 04	 or	 eax, 4
  00171	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  00174	eb 05		 jmp	 SHORT $L67474
$L67480:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  00176	e9 6c ff ff ff	 jmp	 $L67476
$L67474:
  0017b	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  0017f	0f 85 98 00 00
	00		 jne	 $L67481

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00185	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Count$67482[ebp], 0
  0018c	eb 09		 jmp	 SHORT $L67483
$L67484:
  0018e	8b 4d d8	 mov	 ecx, DWORD PTR __Count$67482[ebp]
  00191	83 c1 01	 add	 ecx, 1
  00194	89 4d d8	 mov	 DWORD PTR __Count$67482[ebp], ecx
$L67483:
  00197	8b 55 d8	 mov	 edx, DWORD PTR __Count$67482[ebp]
  0019a	3b 55 dc	 cmp	 edx, DWORD PTR __Size$[ebp]
  0019d	73 7e		 jae	 SHORT $L67481

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  0019f	8b 45 d8	 mov	 eax, DWORD PTR __Count$67482[ebp]
  001a2	50		 push	 eax
  001a3	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z
  001ac	89 45 ac	 mov	 DWORD PTR tv212[ebp], eax
  001af	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b4	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001b7	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  001c0	89 45 a8	 mov	 DWORD PTR tv213[ebp], eax
  001c3	8b 45 ac	 mov	 eax, DWORD PTR tv212[ebp]
  001c6	66 8b 08	 mov	 cx, WORD PTR [eax]
  001c9	51		 push	 ecx
  001ca	8b 4d a8	 mov	 ecx, DWORD PTR tv213[ebp]
  001cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  001d3	66 89 45 a6	 mov	 WORD PTR tv214[ebp], ax
  001d7	66 8b 55 a6	 mov	 dx, WORD PTR tv214[ebp]
  001db	66 89 55 d2	 mov	 WORD PTR $T68965[ebp], dx
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  001e5	66 89 45 a4	 mov	 WORD PTR tv215[ebp], ax
  001e9	66 8b 45 a4	 mov	 ax, WORD PTR tv215[ebp]
  001ed	66 89 45 d0	 mov	 WORD PTR $T68966[ebp], ax
  001f1	8d 4d d2	 lea	 ecx, DWORD PTR $T68965[ebp]
  001f4	51		 push	 ecx
  001f5	8d 55 d0	 lea	 edx, DWORD PTR $T68966[ebp]
  001f8	52		 push	 edx
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  001ff	83 c4 08	 add	 esp, 8
  00202	88 45 a3	 mov	 BYTE PTR tv216[ebp], al
  00205	0f b6 45 a3	 movzx	 eax, BYTE PTR tv216[ebp]
  00209	85 c0		 test	 eax, eax
  0020b	74 0b		 je	 SHORT $L67488

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  0020d	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00210	83 c9 04	 or	 ecx, 4
  00213	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  00216	eb 05		 jmp	 SHORT $L67481
$L67488:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00218	e9 71 ff ff ff	 jmp	 $L67484
$L67481:
  0021d	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00221	0f 85 9a 00 00
	00		 jne	 $L67489

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00227	eb 09		 jmp	 SHORT $L67490
$L67491:
  00229	8b 55 e8	 mov	 edx, DWORD PTR __Pad$[ebp]
  0022c	83 ea 01	 sub	 edx, 1
  0022f	89 55 e8	 mov	 DWORD PTR __Pad$[ebp], edx
$L67490:
  00232	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00236	0f 86 85 00 00
	00		 jbe	 $L67489

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  0023c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0023f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00241	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00244	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00247	8b ca		 mov	 ecx, edx
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  0024f	66 89 45 a0	 mov	 WORD PTR tv217[ebp], ax
  00253	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00256	8b 08		 mov	 ecx, DWORD PTR [eax]
  00258	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0025b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0025e	8b ca		 mov	 ecx, edx
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00266	89 45 9c	 mov	 DWORD PTR tv218[ebp], eax
  00269	66 8b 45 a0	 mov	 ax, WORD PTR tv217[ebp]
  0026d	50		 push	 eax
  0026e	8b 4d 9c	 mov	 ecx, DWORD PTR tv218[ebp]
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00277	66 89 45 9a	 mov	 WORD PTR tv219[ebp], ax
  0027b	66 8b 4d 9a	 mov	 cx, WORD PTR tv219[ebp]
  0027f	66 89 4d ce	 mov	 WORD PTR $T68967[ebp], cx
  00283	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00289	66 89 45 98	 mov	 WORD PTR tv220[ebp], ax
  0028d	66 8b 55 98	 mov	 dx, WORD PTR tv220[ebp]
  00291	66 89 55 cc	 mov	 WORD PTR $T68968[ebp], dx
  00295	8d 45 ce	 lea	 eax, DWORD PTR $T68967[ebp]
  00298	50		 push	 eax
  00299	8d 4d cc	 lea	 ecx, DWORD PTR $T68968[ebp]
  0029c	51		 push	 ecx
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  002a3	83 c4 08	 add	 esp, 8
  002a6	88 45 97	 mov	 BYTE PTR tv221[ebp], al
  002a9	0f b6 55 97	 movzx	 edx, BYTE PTR tv221[ebp]
  002ad	85 d2		 test	 edx, edx
  002af	74 0b		 je	 SHORT $L67495

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  002b1	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002b4	83 c8 04	 or	 eax, 4
  002b7	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  002ba	eb 05		 jmp	 SHORT $L67489
$L67495:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  002bc	e9 68 ff ff ff	 jmp	 $L67491
$L67489:
  002c1	6a 00		 push	 0
  002c3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002cb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  002d4	eb 1d		 jmp	 SHORT $L68970
$L68971:

; 581  : 		_CATCH_IO_(_Ostr)

  002d6	6a 01		 push	 1
  002d8	6a 04		 push	 4
  002da	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002df	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002e2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002e5	8b ca		 mov	 ecx, edx
  002e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  002ed	b8 00 00 00 00	 mov	 eax, $L68970
  002f2	c3		 ret	 0
$L68970:
  002f3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  002fa	6a 00		 push	 0
  002fc	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002ff	50		 push	 eax
  00300	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00303	8b 11		 mov	 edx, DWORD PTR [ecx]
  00305	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00308	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 585  : 	return (_Ostr);

  00311	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00314	89 45 c8	 mov	 DWORD PTR $T68969[ebp], eax
  00317	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0031e	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00321	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00326	8b 45 c8	 mov	 eax, DWORD PTR $T68969[ebp]

; 586  : 	}

  00329	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0032c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00333	5f		 pop	 edi
  00334	5e		 pop	 esi
  00335	5b		 pop	 ebx
  00336	8b e5		 mov	 esp, ebp
  00338	5d		 pop	 ebp
  00339	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68972:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68974
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T68987	DD	0ffffffffH
	DD	FLAT:$L68983
$T68985	DD	019930520H
	DD	01H
	DD	FLAT:$T68987
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00037	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	74 30		 je	 SHORT $L66774
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  00058	85 c0		 test	 eax, eax
  0005a	74 1b		 je	 SHORT $L66774

; 90   : 				_Ostr.tie()->flush();

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b ca		 mov	 ecx, edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  0006f	8b c8		 mov	 ecx, eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
$L66774:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00077	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00082	8b ca		 mov	 ecx, edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68983:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68985
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
EXTRN	__imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68996	DD	0ffffffffH
	DD	FLAT:$L68992
$T68994	DD	019930520H
	DD	01H
	DD	FLAT:$T68996
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0b		 jne	 SHORT $L66776

; 99   : 				this->_Myostr._Osfx();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L66776:

; 100  : 			}

  0003b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68992:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68994
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L67009

; 70   : 				_Myostr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L67009:

; 71   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L67012

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L67012:

; 77   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
END
