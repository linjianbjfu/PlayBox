; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\boxgit\PlayBox\CommonLib\common\YL_Base64.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?YL_Base64Encode@@YAHPADPBDH@Z			; YL_Base64Encode
;	COMDAT ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA
; File d:\boxgit\playbox\commonlib\common\yl_base64.cpp
_DATA	SEGMENT
?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA DB 041H	; `YL_Base64Encode'::`2'::tbl
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02bH
	DB	02fH
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
_s$ = -16						; size = 4
_i$ = -12						; size = 4
_to$ = -8						; size = 4
_p$ = -4						; size = 4
_b64store$ = 8						; size = 4
_str$ = 12						; size = 4
_length$ = 16						; size = 4
?YL_Base64Encode@@YAHPADPBDH@Z PROC NEAR		; YL_Base64Encode

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8    :   /* Conversion table.  */
; 9    :   static char tbl[64] = {
; 10   :     'A','B','C','D','E','F','G','H',
; 11   :     'I','J','K','L','M','N','O','P',
; 12   :     'Q','R','S','T','U','V','W','X',
; 13   :     'Y','Z','a','b','c','d','e','f',
; 14   :     'g','h','i','j','k','l','m','n',
; 15   :     'o','p','q','r','s','t','u','v',
; 16   :     'w','x','y','z','0','1','2','3',
; 17   :     '4','5','6','7','8','9','+','/'
; 18   :   };
; 19   :   int i;
; 20   :   const unsigned char *s = (const unsigned char *) str;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR _s$[ebp], eax

; 21   :   char *p = b64store;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _b64store$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 22   : 
; 23   :   ///* Transform the 3x8 bits to 4x6 bits, as required by base64.  */
; 24   :   //for (i = 0; i < length; i += 3)
; 25   :   //  {
; 26   :   //    *p++ = tbl[s[0] >> 2];
; 27   :   //    *p++ = tbl[((s[0] & 3) << 4) + (s[1] >> 4)];
; 28   :   //    *p++ = tbl[((s[1] & 0xf) << 2) + (s[2] >> 6)];
; 29   :   //    *p++ = tbl[s[2] & 0x3f];
; 30   :   //    s += 3;
; 31   :   //  }
; 32   : 
; 33   :   ///* Pad the result if necessary...  */
; 34   :   //if (i == length + 1)
; 35   :   //  *(p - 1) = '=';
; 36   :   //else if (i == length + 2)
; 37   :   //  *(p - 1) = *(p - 2) = '=';
; 38   : 
; 39   :   int to = length - length % 3;

  00012	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  00015	99		 cdq
  00016	b9 03 00 00 00	 mov	 ecx, 3
  0001b	f7 f9		 idiv	 ecx
  0001d	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  00020	2b c2		 sub	 eax, edx
  00022	89 45 f8	 mov	 DWORD PTR _to$[ebp], eax

; 40   :   /* Transform the 3x8 bits to 4x6 bits, as required by base64.  */
; 41   :   for (i = 0; i < to; i += 3)

  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002c	eb 09		 jmp	 SHORT $L939
$L940:
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00031	83 c1 03	 add	 ecx, 3
  00034	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L939:
  00037	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0003a	3b 55 f8	 cmp	 edx, DWORD PTR _to$[ebp]
  0003d	0f 8d 9d 00 00
	00		 jge	 $L941

; 42   :   {
; 43   : 	  *p++ = tbl[s[0] >> 2];

  00043	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  00046	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00049	c1 f9 02	 sar	 ecx, 2
  0004c	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0004f	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[ecx]
  00055	88 02		 mov	 BYTE PTR [edx], al
  00057	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0005a	83 c1 01	 add	 ecx, 1
  0005d	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 44   : 	  *p++ = tbl[((s[0] & 3) << 4) + (s[1] >> 4)];

  00060	8b 55 f0	 mov	 edx, DWORD PTR _s$[ebp]
  00063	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00066	83 e0 03	 and	 eax, 3
  00069	c1 e0 04	 shl	 eax, 4
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _s$[ebp]
  0006f	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00073	c1 fa 04	 sar	 edx, 4
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00079	8a 94 10 00 00
	00 00		 mov	 dl, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[eax+edx]
  00080	88 11		 mov	 BYTE PTR [ecx], dl
  00082	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00085	83 c0 01	 add	 eax, 1
  00088	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 45   : 	  *p++ = tbl[((s[1] & 0xf) << 2) + (s[2] >> 6)];

  0008b	8b 4d f0	 mov	 ecx, DWORD PTR _s$[ebp]
  0008e	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00092	83 e2 0f	 and	 edx, 15			; 0000000fH
  00095	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  00098	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0009c	c1 f9 06	 sar	 ecx, 6
  0009f	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000a2	8a 8c 91 00 00
	00 00		 mov	 cl, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[ecx+edx*4]
  000a9	88 08		 mov	 BYTE PTR [eax], cl
  000ab	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  000ae	83 c2 01	 add	 edx, 1
  000b1	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 46   : 	  *p++ = tbl[s[2] & 0x3f];

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  000bb	83 e1 3f	 and	 ecx, 63			; 0000003fH
  000be	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  000c1	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[ecx]
  000c7	88 02		 mov	 BYTE PTR [edx], al
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000cc	83 c1 01	 add	 ecx, 1
  000cf	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 47   : 	  s += 3;

  000d2	8b 55 f0	 mov	 edx, DWORD PTR _s$[ebp]
  000d5	83 c2 03	 add	 edx, 3
  000d8	89 55 f0	 mov	 DWORD PTR _s$[ebp], edx

; 48   :   }

  000db	e9 4e ff ff ff	 jmp	 $L940
$L941:

; 49   : 
; 50   :   if (length - to == 1)

  000e0	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  000e3	2b 45 f8	 sub	 eax, DWORD PTR _to$[ebp]
  000e6	83 f8 01	 cmp	 eax, 1
  000e9	75 60		 jne	 SHORT $L942

; 51   :   { //! one char.
; 52   : 	  *p++ = tbl[s[0] >> 2];

  000eb	8b 4d f0	 mov	 ecx, DWORD PTR _s$[ebp]
  000ee	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000f1	c1 fa 02	 sar	 edx, 2
  000f4	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000f7	8a 8a 00 00 00
	00		 mov	 cl, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[edx]
  000fd	88 08		 mov	 BYTE PTR [eax], cl
  000ff	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00102	83 c2 01	 add	 edx, 1
  00105	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 53   : 	  *p++ = tbl[((s[0] & 3) << 4)];

  00108	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  0010b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0010e	83 e1 03	 and	 ecx, 3
  00111	c1 e1 04	 shl	 ecx, 4
  00114	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00117	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[ecx]
  0011d	88 02		 mov	 BYTE PTR [edx], al
  0011f	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00122	83 c1 01	 add	 ecx, 1
  00125	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 54   : 	  *p++ = '=';

  00128	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0012b	c6 02 3d	 mov	 BYTE PTR [edx], 61	; 0000003dH
  0012e	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00131	83 c0 01	 add	 eax, 1
  00134	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 55   : 	  *p++ = '=';

  00137	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0013a	c6 01 3d	 mov	 BYTE PTR [ecx], 61	; 0000003dH
  0013d	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00140	83 c2 01	 add	 edx, 1
  00143	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 56   :   }
; 57   :   else if (length - to == 2)

  00146	e9 81 00 00 00	 jmp	 $L943
$L942:
  0014b	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  0014e	2b 45 f8	 sub	 eax, DWORD PTR _to$[ebp]
  00151	83 f8 02	 cmp	 eax, 2
  00154	75 76		 jne	 SHORT $L943

; 58   :   {
; 59   : 	  *p++ = tbl[s[0] >> 2];

  00156	8b 4d f0	 mov	 ecx, DWORD PTR _s$[ebp]
  00159	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0015c	c1 fa 02	 sar	 edx, 2
  0015f	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00162	8a 8a 00 00 00
	00		 mov	 cl, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[edx]
  00168	88 08		 mov	 BYTE PTR [eax], cl
  0016a	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0016d	83 c2 01	 add	 edx, 1
  00170	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 60   : 	  *p++ = tbl[((s[0] & 3) << 4) + (s[1] >> 4)];

  00173	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  00176	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00179	83 e1 03	 and	 ecx, 3
  0017c	c1 e1 04	 shl	 ecx, 4
  0017f	8b 55 f0	 mov	 edx, DWORD PTR _s$[ebp]
  00182	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00186	c1 f8 04	 sar	 eax, 4
  00189	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0018c	8a 84 01 00 00
	00 00		 mov	 al, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[ecx+eax]
  00193	88 02		 mov	 BYTE PTR [edx], al
  00195	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00198	83 c1 01	 add	 ecx, 1
  0019b	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 61   : 	  *p++ = tbl[((s[1] & 0xf) << 2)];

  0019e	8b 55 f0	 mov	 edx, DWORD PTR _s$[ebp]
  001a1	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  001a5	83 e0 0f	 and	 eax, 15			; 0000000fH
  001a8	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  001ab	8a 14 85 00 00
	00 00		 mov	 dl, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[eax*4]
  001b2	88 11		 mov	 BYTE PTR [ecx], dl
  001b4	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  001b7	83 c0 01	 add	 eax, 1
  001ba	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 62   : 	  *p++ = '=';

  001bd	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  001c0	c6 01 3d	 mov	 BYTE PTR [ecx], 61	; 0000003dH
  001c3	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  001c6	83 c2 01	 add	 edx, 1
  001c9	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx
$L943:

; 63   :   }
; 64   : 
; 65   :   /* ...and zero-terminate it.  */
; 66   :   *p = '\0';

  001cc	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  001cf	c6 00 00	 mov	 BYTE PTR [eax], 0

; 67   : 
; 68   :   return (int)(p - b64store);

  001d2	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  001d5	2b 45 08	 sub	 eax, DWORD PTR _b64store$[ebp]

; 69   : }

  001d8	8b e5		 mov	 esp, ebp
  001da	5d		 pop	 ebp
  001db	c3		 ret	 0
?YL_Base64Encode@@YAHPADPBDH@Z ENDP			; YL_Base64Encode
_TEXT	ENDS
PUBLIC	?YL_Base64Decode@@YAHPADPBD@Z			; YL_Base64Decode
;	COMDAT ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA
_DATA	SEGMENT
?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA DW 0ffffH ; `YL_Base64Decode'::`2'::base64_char_to_value
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	03eH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	03fH
	DW	034H
	DW	035H
	DW	036H
	DW	037H
	DW	038H
	DW	039H
	DW	03aH
	DW	03bH
	DW	03cH
	DW	03dH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	00H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	0fH
	DW	010H
	DW	011H
	DW	012H
	DW	013H
	DW	014H
	DW	015H
	DW	016H
	DW	017H
	DW	018H
	DW	019H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	01aH
	DW	01bH
	DW	01cH
	DW	01dH
	DW	01eH
	DW	01fH
	DW	020H
	DW	021H
	DW	022H
	DW	023H
	DW	024H
	DW	025H
	DW	026H
	DW	027H
	DW	028H
	DW	029H
	DW	02aH
	DW	02bH
	DW	02cH
	DW	02dH
	DW	02eH
	DW	02fH
	DW	030H
	DW	031H
	DW	032H
	DW	033H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
_c$957 = -13						; size = 1
_value$958 = -12					; size = 4
_q$ = -8						; size = 4
_p$ = -4						; size = 4
_to$ = 8						; size = 4
_base64$ = 12						; size = 4
?YL_Base64Decode@@YAHPADPBD@Z PROC NEAR			; YL_Base64Decode

; 83   : {

  001e0	55		 push	 ebp
  001e1	8b ec		 mov	 ebp, esp
  001e3	83 ec 10	 sub	 esp, 16			; 00000010H

; 84   :   /* Table of base64 values for first 128 characters.  Note that this
; 85   :      assumes ASCII (but so does Wget in other places).  */
; 86   :   static short base64_char_to_value[128] =
; 87   :     {
; 88   :       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,	/*   0-  9 */
; 89   :       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,	/*  10- 19 */
; 90   :       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,	/*  20- 29 */
; 91   :       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,	/*  30- 39 */
; 92   :       -1,  -1,  -1,  62,  -1,  -1,  -1,  63,  52,  53,	/*  40- 49 */
; 93   :       54,  55,  56,  57,  58,  59,  60,  61,  -1,  -1,	/*  50- 59 */
; 94   :       -1,  -1,  -1,  -1,  -1,  0,   1,   2,   3,   4,	/*  60- 69 */
; 95   :       5,   6,   7,   8,   9,   10,  11,  12,  13,  14,	/*  70- 79 */
; 96   :       15,  16,  17,  18,  19,  20,  21,  22,  23,  24,	/*  80- 89 */
; 97   :       25,  -1,  -1,  -1,  -1,  -1,  -1,  26,  27,  28,	/*  90- 99 */
; 98   :       29,  30,  31,  32,  33,  34,  35,  36,  37,  38,	/* 100-109 */
; 99   :       39,  40,  41,  42,  43,  44,  45,  46,  47,  48,	/* 110-119 */
; 100  :       49,  50,  51,  -1,  -1,  -1,  -1,  -1		/* 120-127 */
; 101  :     };
; 102  : 
; 103  :   const char *p = base64;

  001e6	8b 45 0c	 mov	 eax, DWORD PTR _base64$[ebp]
  001e9	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 104  :   char *q = to;

  001ec	8b 4d 08	 mov	 ecx, DWORD PTR _to$[ebp]
  001ef	89 4d f8	 mov	 DWORD PTR _q$[ebp], ecx
$L955:

; 105  : 
; 106  :   while (1)

  001f2	ba 01 00 00 00	 mov	 edx, 1
  001f7	85 d2		 test	 edx, edx
  001f9	0f 84 67 02 00
	00		 je	 $L956
$L959:

; 107  :     {
; 108  :       unsigned char c;
; 109  :       unsigned long value;
; 110  : 
; 111  :       /* Process first byte of a quadruplet.  */
; 112  :       NEXT_BASE64_CHAR (c, p);

  001ff	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00202	8a 08		 mov	 cl, BYTE PTR [eax]
  00204	88 4d f3	 mov	 BYTE PTR _c$957[ebp], cl
  00207	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0020a	83 c2 01	 add	 edx, 1
  0020d	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx
  00210	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$957[ebp]
  00214	85 c0		 test	 eax, eax
  00216	74 25		 je	 SHORT $L961
  00218	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  0021c	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00222	75 10		 jne	 SHORT $L964
  00224	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  00228	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[edx*2]
  00230	85 c0		 test	 eax, eax
  00232	7d 09		 jge	 SHORT $L961
$L964:
  00234	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  00238	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  0023b	75 c2		 jne	 SHORT $L959
$L961:

; 113  :       if (!c)

  0023d	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  00241	85 d2		 test	 edx, edx
  00243	75 05		 jne	 SHORT $L965

; 114  : 	break;

  00245	e9 1c 02 00 00	 jmp	 $L956
$L965:

; 115  :       if (c == '=')

  0024a	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$957[ebp]
  0024e	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  00251	75 08		 jne	 SHORT $L966

; 116  : 	return -1;		/* illegal '=' while decoding base64 */

  00253	83 c8 ff	 or	 eax, -1
  00256	e9 11 02 00 00	 jmp	 $L949
$L966:

; 117  :       value = base64_char_to_value[c] << 18;

  0025b	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  0025f	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[ecx*2]
  00267	c1 e2 12	 shl	 edx, 18			; 00000012H
  0026a	89 55 f4	 mov	 DWORD PTR _value$958[ebp], edx
$L967:

; 118  : 
; 119  :       /* Process scond byte of a quadruplet.  */
; 120  :       NEXT_BASE64_CHAR (c, p);

  0026d	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00270	8a 08		 mov	 cl, BYTE PTR [eax]
  00272	88 4d f3	 mov	 BYTE PTR _c$957[ebp], cl
  00275	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00278	83 c2 01	 add	 edx, 1
  0027b	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx
  0027e	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$957[ebp]
  00282	85 c0		 test	 eax, eax
  00284	74 25		 je	 SHORT $L969
  00286	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  0028a	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00290	75 10		 jne	 SHORT $L972
  00292	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  00296	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[edx*2]
  0029e	85 c0		 test	 eax, eax
  002a0	7d 09		 jge	 SHORT $L969
$L972:
  002a2	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  002a6	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  002a9	75 c2		 jne	 SHORT $L967
$L969:

; 121  :       if (!c)

  002ab	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  002af	85 d2		 test	 edx, edx
  002b1	75 08		 jne	 SHORT $L973

; 122  : 	return -1;		/* premature EOF while decoding base64 */

  002b3	83 c8 ff	 or	 eax, -1
  002b6	e9 b1 01 00 00	 jmp	 $L949
$L973:

; 123  :       if (c == '=')

  002bb	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$957[ebp]
  002bf	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  002c2	75 08		 jne	 SHORT $L974

; 124  : 	return -1;		/* illegal `=' while decoding base64 */

  002c4	83 c8 ff	 or	 eax, -1
  002c7	e9 a0 01 00 00	 jmp	 $L949
$L974:

; 125  :       value |= base64_char_to_value[c] << 12;

  002cc	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  002d0	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[ecx*2]
  002d8	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  002db	0b 55 f4	 or	 edx, DWORD PTR _value$958[ebp]
  002de	89 55 f4	 mov	 DWORD PTR _value$958[ebp], edx

; 126  :       *q++ = (char)(value >> 16);

  002e1	8b 45 f4	 mov	 eax, DWORD PTR _value$958[ebp]
  002e4	c1 e8 10	 shr	 eax, 16			; 00000010H
  002e7	8b 4d f8	 mov	 ecx, DWORD PTR _q$[ebp]
  002ea	88 01		 mov	 BYTE PTR [ecx], al
  002ec	8b 55 f8	 mov	 edx, DWORD PTR _q$[ebp]
  002ef	83 c2 01	 add	 edx, 1
  002f2	89 55 f8	 mov	 DWORD PTR _q$[ebp], edx
$L976:

; 127  : 
; 128  :       /* Process third byte of a quadruplet.  */
; 129  :       NEXT_BASE64_CHAR (c, p);

  002f5	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  002f8	8a 08		 mov	 cl, BYTE PTR [eax]
  002fa	88 4d f3	 mov	 BYTE PTR _c$957[ebp], cl
  002fd	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00300	83 c2 01	 add	 edx, 1
  00303	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx
  00306	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$957[ebp]
  0030a	85 c0		 test	 eax, eax
  0030c	74 25		 je	 SHORT $L978
  0030e	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  00312	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00318	75 10		 jne	 SHORT $L981
  0031a	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  0031e	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[edx*2]
  00326	85 c0		 test	 eax, eax
  00328	7d 09		 jge	 SHORT $L978
$L981:
  0032a	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  0032e	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  00331	75 c2		 jne	 SHORT $L976
$L978:

; 130  :       if (!c)

  00333	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  00337	85 d2		 test	 edx, edx
  00339	75 08		 jne	 SHORT $L982

; 131  : 	return -1;		/* premature EOF while decoding base64 */

  0033b	83 c8 ff	 or	 eax, -1
  0033e	e9 29 01 00 00	 jmp	 $L949
$L982:

; 132  : 
; 133  :       if (c == '=')

  00343	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$957[ebp]
  00347	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  0034a	75 64		 jne	 SHORT $L983
$L984:

; 134  : 	{
; 135  : 	  NEXT_BASE64_CHAR (c, p);

  0034c	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0034f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00351	88 55 f3	 mov	 BYTE PTR _c$957[ebp], dl
  00354	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00357	83 c0 01	 add	 eax, 1
  0035a	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
  0035d	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  00361	85 c9		 test	 ecx, ecx
  00363	74 25		 je	 SHORT $L986
  00365	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  00369	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0036f	75 10		 jne	 SHORT $L989
  00371	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$957[ebp]
  00375	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[eax*2]
  0037d	85 c9		 test	 ecx, ecx
  0037f	7d 09		 jge	 SHORT $L986
$L989:
  00381	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  00385	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  00388	75 c2		 jne	 SHORT $L984
$L986:

; 136  : 	  if (!c)

  0038a	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$957[ebp]
  0038e	85 c0		 test	 eax, eax
  00390	75 08		 jne	 SHORT $L990

; 137  : 	    return -1;		/* premature EOF while decoding base64 */

  00392	83 c8 ff	 or	 eax, -1
  00395	e9 d2 00 00 00	 jmp	 $L949
$L990:

; 138  : 	  if (c != '=')

  0039a	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  0039e	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  003a1	74 08		 je	 SHORT $L991

; 139  : 	    return -1;		/* padding `=' expected but not found */

  003a3	83 c8 ff	 or	 eax, -1
  003a6	e9 c1 00 00 00	 jmp	 $L949
$L991:

; 140  : 	  continue;

  003ab	e9 42 fe ff ff	 jmp	 $L955
$L983:

; 141  : 	}
; 142  : 
; 143  :       value |= base64_char_to_value[c] << 6;

  003b0	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  003b4	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[edx*2]
  003bc	c1 e0 06	 shl	 eax, 6
  003bf	0b 45 f4	 or	 eax, DWORD PTR _value$958[ebp]
  003c2	89 45 f4	 mov	 DWORD PTR _value$958[ebp], eax

; 144  :       *q++ = (char)(0xff & value >> 8);

  003c5	8b 4d f4	 mov	 ecx, DWORD PTR _value$958[ebp]
  003c8	c1 e9 08	 shr	 ecx, 8
  003cb	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003d1	8b 55 f8	 mov	 edx, DWORD PTR _q$[ebp]
  003d4	88 0a		 mov	 BYTE PTR [edx], cl
  003d6	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  003d9	83 c0 01	 add	 eax, 1
  003dc	89 45 f8	 mov	 DWORD PTR _q$[ebp], eax
$L993:

; 145  : 
; 146  :       /* Process fourth byte of a quadruplet.  */
; 147  :       NEXT_BASE64_CHAR (c, p);

  003df	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  003e2	8a 11		 mov	 dl, BYTE PTR [ecx]
  003e4	88 55 f3	 mov	 BYTE PTR _c$957[ebp], dl
  003e7	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  003ea	83 c0 01	 add	 eax, 1
  003ed	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
  003f0	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  003f4	85 c9		 test	 ecx, ecx
  003f6	74 25		 je	 SHORT $L995
  003f8	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  003fc	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00402	75 10		 jne	 SHORT $L998
  00404	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$957[ebp]
  00408	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[eax*2]
  00410	85 c9		 test	 ecx, ecx
  00412	7d 09		 jge	 SHORT $L995
$L998:
  00414	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  00418	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  0041b	75 c2		 jne	 SHORT $L993
$L995:

; 148  :       if (!c)

  0041d	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$957[ebp]
  00421	85 c0		 test	 eax, eax
  00423	75 05		 jne	 SHORT $L999

; 149  : 	return -1;		/* premature EOF while decoding base64 */

  00425	83 c8 ff	 or	 eax, -1
  00428	eb 42		 jmp	 SHORT $L949
$L999:

; 150  :       if (c == '=')

  0042a	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$957[ebp]
  0042e	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  00431	75 05		 jne	 SHORT $L1000

; 151  : 	continue;

  00433	e9 ba fd ff ff	 jmp	 $L955
$L1000:

; 152  : 
; 153  :       value |= base64_char_to_value[c];

  00438	0f b6 55 f3	 movzx	 edx, BYTE PTR _c$957[ebp]
  0043c	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[edx*2]
  00444	0b 45 f4	 or	 eax, DWORD PTR _value$958[ebp]
  00447	89 45 f4	 mov	 DWORD PTR _value$958[ebp], eax

; 154  :       *q++ = (char)(0xff & value);

  0044a	8b 4d f4	 mov	 ecx, DWORD PTR _value$958[ebp]
  0044d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00453	8b 55 f8	 mov	 edx, DWORD PTR _q$[ebp]
  00456	88 0a		 mov	 BYTE PTR [edx], cl
  00458	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  0045b	83 c0 01	 add	 eax, 1
  0045e	89 45 f8	 mov	 DWORD PTR _q$[ebp], eax

; 155  :     }

  00461	e9 8c fd ff ff	 jmp	 $L955
$L956:

; 156  : 
; 157  :   return (int)(q - to);

  00466	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  00469	2b 45 08	 sub	 eax, DWORD PTR _to$[ebp]
$L949:

; 158  : }

  0046c	8b e5		 mov	 esp, ebp
  0046e	5d		 pop	 ebp
  0046f	c3		 ret	 0
?YL_Base64Decode@@YAHPADPBD@Z ENDP			; YL_Base64Decode
_TEXT	ENDS
PUBLIC	?YL_Base64Encode@@YAHPADPBDH1@Z			; YL_Base64Encode
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	_memcpy:NEAR
EXTRN	_strlen:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
$T1054 = -28						; size = 4
$T1053 = -24						; size = 4
_j$1018 = -20						; size = 4
_i$1014 = -16						; size = 4
___tmp$ = -12						; size = 4
_ret$ = -8						; size = 4
___len$ = -4						; size = 4
_b64store$ = 8						; size = 4
_str$ = 12						; size = 4
_length$ = 16						; size = 4
_xor_string$ = 20					; size = 4
?YL_Base64Encode@@YAHPADPBDH1@Z PROC NEAR		; YL_Base64Encode

; 161  : {

  00470	55		 push	 ebp
  00471	8b ec		 mov	 ebp, esp
  00473	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 162  : 	char *__tmp = new char[length];

  00476	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  00479	50		 push	 eax
  0047a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0047f	83 c4 04	 add	 esp, 4
  00482	89 45 e8	 mov	 DWORD PTR $T1053[ebp], eax
  00485	8b 4d e8	 mov	 ecx, DWORD PTR $T1053[ebp]
  00488	89 4d f4	 mov	 DWORD PTR ___tmp$[ebp], ecx

; 163  : 	memcpy(__tmp, str, length);

  0048b	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp]
  0048e	52		 push	 edx
  0048f	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00492	50		 push	 eax
  00493	8b 4d f4	 mov	 ecx, DWORD PTR ___tmp$[ebp]
  00496	51		 push	 ecx
  00497	e8 00 00 00 00	 call	 _memcpy
  0049c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 164  : 
; 165  : 	int __len = (int)strlen(xor_string);

  0049f	8b 55 14	 mov	 edx, DWORD PTR _xor_string$[ebp]
  004a2	52		 push	 edx
  004a3	e8 00 00 00 00	 call	 _strlen
  004a8	83 c4 04	 add	 esp, 4
  004ab	89 45 fc	 mov	 DWORD PTR ___len$[ebp], eax

; 166  : 
; 167  : 	for (int i = 0; i < length; )

  004ae	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$1014[ebp], 0
$L1016:
  004b5	8b 45 f0	 mov	 eax, DWORD PTR _i$1014[ebp]
  004b8	3b 45 10	 cmp	 eax, DWORD PTR _length$[ebp]
  004bb	7d 4b		 jge	 SHORT $L1017

; 168  : 	{
; 169  : 		for (int j = 0; j < __len && i < length; j++)

  004bd	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _j$1018[ebp], 0
  004c4	eb 09		 jmp	 SHORT $L1019
$L1020:
  004c6	8b 4d ec	 mov	 ecx, DWORD PTR _j$1018[ebp]
  004c9	83 c1 01	 add	 ecx, 1
  004cc	89 4d ec	 mov	 DWORD PTR _j$1018[ebp], ecx
$L1019:
  004cf	8b 55 ec	 mov	 edx, DWORD PTR _j$1018[ebp]
  004d2	3b 55 fc	 cmp	 edx, DWORD PTR ___len$[ebp]
  004d5	7d 2f		 jge	 SHORT $L1021
  004d7	8b 45 f0	 mov	 eax, DWORD PTR _i$1014[ebp]
  004da	3b 45 10	 cmp	 eax, DWORD PTR _length$[ebp]
  004dd	7d 27		 jge	 SHORT $L1021

; 170  : 		{
; 171  : 			__tmp[i++] ^= xor_string[j];

  004df	8b 4d 14	 mov	 ecx, DWORD PTR _xor_string$[ebp]
  004e2	03 4d ec	 add	 ecx, DWORD PTR _j$1018[ebp]
  004e5	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  004e8	8b 45 f4	 mov	 eax, DWORD PTR ___tmp$[ebp]
  004eb	03 45 f0	 add	 eax, DWORD PTR _i$1014[ebp]
  004ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  004f1	33 ca		 xor	 ecx, edx
  004f3	8b 55 f4	 mov	 edx, DWORD PTR ___tmp$[ebp]
  004f6	03 55 f0	 add	 edx, DWORD PTR _i$1014[ebp]
  004f9	88 0a		 mov	 BYTE PTR [edx], cl
  004fb	8b 45 f0	 mov	 eax, DWORD PTR _i$1014[ebp]
  004fe	83 c0 01	 add	 eax, 1
  00501	89 45 f0	 mov	 DWORD PTR _i$1014[ebp], eax

; 172  : 		}

  00504	eb c0		 jmp	 SHORT $L1020
$L1021:

; 173  : 	}

  00506	eb ad		 jmp	 SHORT $L1016
$L1017:

; 174  : 
; 175  : 	int ret = YL_Base64Encode(b64store, __tmp, length);

  00508	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp]
  0050b	51		 push	 ecx
  0050c	8b 55 f4	 mov	 edx, DWORD PTR ___tmp$[ebp]
  0050f	52		 push	 edx
  00510	8b 45 08	 mov	 eax, DWORD PTR _b64store$[ebp]
  00513	50		 push	 eax
  00514	e8 00 00 00 00	 call	 ?YL_Base64Encode@@YAHPADPBDH@Z ; YL_Base64Encode
  00519	83 c4 0c	 add	 esp, 12			; 0000000cH
  0051c	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 176  : 	delete []__tmp;

  0051f	8b 4d f4	 mov	 ecx, DWORD PTR ___tmp$[ebp]
  00522	89 4d e4	 mov	 DWORD PTR $T1054[ebp], ecx
  00525	8b 55 e4	 mov	 edx, DWORD PTR $T1054[ebp]
  00528	52		 push	 edx
  00529	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0052e	83 c4 04	 add	 esp, 4

; 177  : 
; 178  : 	return ret;

  00531	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 179  : }

  00534	8b e5		 mov	 esp, ebp
  00536	5d		 pop	 ebp
  00537	c3		 ret	 0
?YL_Base64Encode@@YAHPADPBDH1@Z ENDP			; YL_Base64Encode
_TEXT	ENDS
PUBLIC	?YL_Base64Decode@@YAHPADPBD1@Z			; YL_Base64Decode
; Function compile flags: /Odt
_TEXT	SEGMENT
_j$1037 = -16						; size = 4
_i$1033 = -12						; size = 4
_ret$ = -8						; size = 4
___len$ = -4						; size = 4
_to$ = 8						; size = 4
_base64$ = 12						; size = 4
_xor_string$ = 16					; size = 4
?YL_Base64Decode@@YAHPADPBD1@Z PROC NEAR		; YL_Base64Decode

; 182  : {

  00540	55		 push	 ebp
  00541	8b ec		 mov	 ebp, esp
  00543	83 ec 10	 sub	 esp, 16			; 00000010H

; 183  : 	int ret = YL_Base64Decode(to, base64);

  00546	8b 45 0c	 mov	 eax, DWORD PTR _base64$[ebp]
  00549	50		 push	 eax
  0054a	8b 4d 08	 mov	 ecx, DWORD PTR _to$[ebp]
  0054d	51		 push	 ecx
  0054e	e8 00 00 00 00	 call	 ?YL_Base64Decode@@YAHPADPBD@Z ; YL_Base64Decode
  00553	83 c4 08	 add	 esp, 8
  00556	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 184  : 	if (ret == -1)

  00559	83 7d f8 ff	 cmp	 DWORD PTR _ret$[ebp], -1
  0055d	75 05		 jne	 SHORT $L1030

; 185  : 		return -1;

  0055f	83 c8 ff	 or	 eax, -1
  00562	eb 6c		 jmp	 SHORT $L1028
$L1030:

; 186  : 
; 187  : 	int __len = (int)strlen(xor_string);

  00564	8b 55 10	 mov	 edx, DWORD PTR _xor_string$[ebp]
  00567	52		 push	 edx
  00568	e8 00 00 00 00	 call	 _strlen
  0056d	83 c4 04	 add	 esp, 4
  00570	89 45 fc	 mov	 DWORD PTR ___len$[ebp], eax

; 188  : 
; 189  : 	for (int i = 0; i < ret; )

  00573	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1033[ebp], 0
$L1035:
  0057a	8b 45 f4	 mov	 eax, DWORD PTR _i$1033[ebp]
  0057d	3b 45 f8	 cmp	 eax, DWORD PTR _ret$[ebp]
  00580	7d 4b		 jge	 SHORT $L1036

; 190  : 	{
; 191  : 		for (int j = 0; j < __len && i < ret; j++)

  00582	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _j$1037[ebp], 0
  00589	eb 09		 jmp	 SHORT $L1038
$L1039:
  0058b	8b 4d f0	 mov	 ecx, DWORD PTR _j$1037[ebp]
  0058e	83 c1 01	 add	 ecx, 1
  00591	89 4d f0	 mov	 DWORD PTR _j$1037[ebp], ecx
$L1038:
  00594	8b 55 f0	 mov	 edx, DWORD PTR _j$1037[ebp]
  00597	3b 55 fc	 cmp	 edx, DWORD PTR ___len$[ebp]
  0059a	7d 2f		 jge	 SHORT $L1040
  0059c	8b 45 f4	 mov	 eax, DWORD PTR _i$1033[ebp]
  0059f	3b 45 f8	 cmp	 eax, DWORD PTR _ret$[ebp]
  005a2	7d 27		 jge	 SHORT $L1040

; 192  : 		{
; 193  : 			to[i++] ^= xor_string[j];

  005a4	8b 4d 10	 mov	 ecx, DWORD PTR _xor_string$[ebp]
  005a7	03 4d f0	 add	 ecx, DWORD PTR _j$1037[ebp]
  005aa	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  005ad	8b 45 08	 mov	 eax, DWORD PTR _to$[ebp]
  005b0	03 45 f4	 add	 eax, DWORD PTR _i$1033[ebp]
  005b3	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  005b6	33 ca		 xor	 ecx, edx
  005b8	8b 55 08	 mov	 edx, DWORD PTR _to$[ebp]
  005bb	03 55 f4	 add	 edx, DWORD PTR _i$1033[ebp]
  005be	88 0a		 mov	 BYTE PTR [edx], cl
  005c0	8b 45 f4	 mov	 eax, DWORD PTR _i$1033[ebp]
  005c3	83 c0 01	 add	 eax, 1
  005c6	89 45 f4	 mov	 DWORD PTR _i$1033[ebp], eax

; 194  : 		}

  005c9	eb c0		 jmp	 SHORT $L1039
$L1040:

; 195  : 	}

  005cb	eb ad		 jmp	 SHORT $L1035
$L1036:

; 196  : 
; 197  : 	return ret;

  005cd	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
$L1028:

; 198  : }

  005d0	8b e5		 mov	 esp, ebp
  005d2	5d		 pop	 ebp
  005d3	c3		 ret	 0
?YL_Base64Decode@@YAHPADPBD1@Z ENDP			; YL_Base64Decode
_TEXT	ENDS
END
