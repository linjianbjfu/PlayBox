; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\Gui\CommonControl\SkinScroll\coolscroll.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG22590 DB	01H DUP (?)
	ALIGN	4

?count@?1??CalcThumbSize@@9@9 DD 01H DUP (?)		; `CalcThumbSize'::`2'::count
?lastportion@?1??MouseMove@@9@9 DD 01H DUP (?)		; `MouseMove'::`2'::lastportion
?lastbutton@?1??MouseMove@@9@9 DD 01H DUP (?)		; `MouseMove'::`2'::lastbutton
_uCurrentButton DD 01H DUP (?)
_uMouseOverId DD 01H DUP (?)
_uScrollTimerMsg DD 01H DUP (?)
_uScrollTimerId DD 01H DUP (?)
_hwndCurCoolSB DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_uCurrentScrollbar DD 0ffffffffH
_uCurrentScrollPortion DD 0ffffffffH
_nLastPos DD	0ffffffffH
_uMouseOverScrollbar DD 0ffffffffH
_uHitTestPortion DD 0ffffffffH
_uLastHitTestPortion DD 0ffffffffH
_uScrollTimerPortion DD 0ffffffffH
?wCheckPat@?1??DrawCheckedRect@@9@9 DW 0aaaaH		; `DrawCheckedRect'::`2'::wCheckPat
	DW	05555H
	DW	0aaaaH
	DW	05555H
	DW	0aaaaH
	DW	05555H
	DW	0aaaaH
	DW	05555H
_curTool DD	0ffffffffH
?lastpos@?5??CoolSBWndProc@@9@9 DD 0ffffffffH		; `CoolSBWndProc'::`6'::lastpos
_DATA	ENDS
PUBLIC	_CoolSB_IsThumbTracking@4
EXTRN	_GetScrollWndFromHwnd:NEAR
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\skinscroll\coolscroll.c
_TEXT	SEGMENT
_sw$ = -4						; size = 4
_hwnd$ = 8						; size = 4
_CoolSB_IsThumbTracking@4 PROC NEAR

; 105  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 106  : 	SCROLLWND *sw;
; 107  : 
; 108  : 	if((sw = GetScrollWndFromHwnd(hwnd)) == NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _GetScrollWndFromHwnd
  0000d	83 c4 04	 add	 esp, 4
  00010	89 45 fc	 mov	 DWORD PTR _sw$[ebp], eax
  00013	83 7d fc 00	 cmp	 DWORD PTR _sw$[ebp], 0
  00017	75 04		 jne	 SHORT $L22460

; 109  : 		return FALSE;

  00019	33 c0		 xor	 eax, eax
  0001b	eb 09		 jmp	 SHORT $L22457
$L22460:

; 110  : 	else
; 111  : 		return sw->fThumbTracking; 

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _sw$[ebp]
  00020	8b 81 a0 06 00
	00		 mov	 eax, DWORD PTR [ecx+1696]
$L22457:

; 112  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
_CoolSB_IsThumbTracking@4 ENDP
_TEXT	ENDS
PUBLIC	_DrawBlankButton
EXTRN	__imp__GetSysColorBrush@4:NEAR
EXTRN	__imp__FillRect@12:NEAR
EXTRN	__imp__DrawEdge@16:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_rc$ = -16						; size = 16
_hdc$ = 8						; size = 4
_rect$ = 12						; size = 4
_drawflag$ = 16						; size = 4
_DrawBlankButton PROC NEAR

; 386  : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	83 ec 10	 sub	 esp, 16			; 00000010H

; 387  : 	RECT rc = *rect;

  00036	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 4d f0	 mov	 DWORD PTR _rc$[ebp], ecx
  0003e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00041	89 55 f4	 mov	 DWORD PTR _rc$[ebp+4], edx
  00044	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00047	89 4d f8	 mov	 DWORD PTR _rc$[ebp+8], ecx
  0004a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0004d	89 55 fc	 mov	 DWORD PTR _rc$[ebp+12], edx

; 388  : 		
; 389  : #ifndef FLAT_SCROLLBARS	
; 390  : 	drawflag &= ~BF_FLAT;
; 391  : #endif
; 392  : 	
; 393  : 	DrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT | drawflag | BF_ADJUST);

  00050	8b 45 10	 mov	 eax, DWORD PTR _drawflag$[ebp]
  00053	83 c8 0f	 or	 eax, 15			; 0000000fH
  00056	0d 00 20 00 00	 or	 eax, 8192		; 00002000H
  0005b	50		 push	 eax
  0005c	6a 05		 push	 5
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR _rc$[ebp]
  00061	51		 push	 ecx
  00062	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  00065	52		 push	 edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawEdge@16

; 394  : 	FillRect(hdc, &rc, GetSysColorBrush(COLOR_BTNFACE));

  0006c	6a 0f		 push	 15			; 0000000fH
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColorBrush@4
  00074	50		 push	 eax
  00075	8d 45 f0	 lea	 eax, DWORD PTR _rc$[ebp]
  00078	50		 push	 eax
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0007c	51		 push	 ecx
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 395  : }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_DrawBlankButton ENDP
_TEXT	ENDS
PUBLIC	_GetScrollRect
; Function compile flags: /Odt
_TEXT	SEGMENT
_sw$ = 8						; size = 4
_nBar$ = 12						; size = 4
_hwnd$ = 16						; size = 4
_rect$ = 20						; size = 4
_GetScrollRect PROC NEAR

; 471  : {

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp

; 472  : 	if(nBar == SB_HORZ)

  00093	83 7d 0c 00	 cmp	 DWORD PTR _nBar$[ebp], 0
  00097	75 16		 jne	 SHORT $L22648

; 473  : 		return GetHScrollRect(sw, hwnd, rect);

  00099	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 10	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  000a0	51		 push	 ecx
  000a1	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 _GetHScrollRect
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ad	eb 1e		 jmp	 SHORT $L22647
$L22648:

; 474  : 	else if(nBar == SB_VERT)

  000af	83 7d 0c 01	 cmp	 DWORD PTR _nBar$[ebp], 1
  000b3	75 16		 jne	 SHORT $L22650

; 475  : 		return GetVScrollRect(sw, hwnd, rect);

  000b5	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d 10	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  000bc	51		 push	 ecx
  000bd	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 _GetVScrollRect
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	eb 02		 jmp	 SHORT $L22647
$L22650:

; 476  : 	else
; 477  : 		return FALSE;

  000cb	33 c0		 xor	 eax, eax
$L22647:

; 478  : }

  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_GetScrollRect ENDP
_TEXT	ENDS
EXTRN	__imp__GetWindowRect@8:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv140 = -12						; size = 4
tv92 = -8						; size = 4
tv75 = -4						; size = 4
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_GetHScrollRect PROC NEAR

; 411  : {

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 412  : 	GetWindowRect(hwnd, rect);

  000d6	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  000d9	50		 push	 eax
  000da	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  000dd	51		 push	 ecx
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 413  : 	
; 414  : 	if(sw->fLeftScrollbar)

  000e4	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  000e7	83 ba a4 06 00
	00 00		 cmp	 DWORD PTR [edx+1700], 0
  000ee	74 59		 je	 SHORT $L22626

; 415  : 	{
; 416  : 		rect->left  += sw->cxLeftEdge + (sw->sbarVert.fScrollVisible ? 
; 417  : 					GetScrollMetric(&sw->sbarVert, SM_CXVERTSB) : 0);

  000f0	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  000f3	83 b8 58 03 00
	00 00		 cmp	 DWORD PTR [eax+856], 0
  000fa	74 19		 je	 SHORT $L23859
  000fc	6a 01		 push	 1
  000fe	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00101	81 c1 54 03 00
	00		 add	 ecx, 852		; 00000354H
  00107	51		 push	 ecx
  00108	e8 00 00 00 00	 call	 _GetScrollMetric
  0010d	83 c4 08	 add	 esp, 8
  00110	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  00113	eb 07		 jmp	 SHORT $L23860
$L23859:
  00115	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$L23860:
  0011c	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0011f	8b 82 ac 06 00
	00		 mov	 eax, DWORD PTR [edx+1708]
  00125	03 45 fc	 add	 eax, DWORD PTR tv75[ebp]
  00128	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0012b	03 01		 add	 eax, DWORD PTR [ecx]
  0012d	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  00130	89 02		 mov	 DWORD PTR [edx], eax

; 418  : 		rect->right -= sw->cxRightEdge;

  00132	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  00135	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00138	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0013b	2b 91 b0 06 00
	00		 sub	 edx, DWORD PTR [ecx+1712]
  00141	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  00144	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 419  : 	}
; 420  : 	else

  00147	eb 58		 jmp	 SHORT $L22627
$L22626:

; 421  : 	{
; 422  : 		rect->left   += sw->cxLeftEdge;					//left window edge

  00149	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0014c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014e	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00151	03 90 ac 06 00
	00		 add	 edx, DWORD PTR [eax+1708]
  00157	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0015a	89 11		 mov	 DWORD PTR [ecx], edx

; 423  : 	
; 424  : 		rect->right  -= sw->cxRightEdge +				//right window edge
; 425  : 					(sw->sbarVert.fScrollVisible ? 
; 426  : 					GetScrollMetric(&sw->sbarVert, SM_CXVERTSB) : 0);

  0015c	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0015f	83 ba 58 03 00
	00 00		 cmp	 DWORD PTR [edx+856], 0
  00166	74 18		 je	 SHORT $L23861
  00168	6a 01		 push	 1
  0016a	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0016d	05 54 03 00 00	 add	 eax, 852		; 00000354H
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _GetScrollMetric
  00178	83 c4 08	 add	 esp, 8
  0017b	89 45 f8	 mov	 DWORD PTR tv92[ebp], eax
  0017e	eb 07		 jmp	 SHORT $L23862
$L23861:
  00180	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$L23862:
  00187	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0018a	8b 91 b0 06 00
	00		 mov	 edx, DWORD PTR [ecx+1712]
  00190	03 55 f8	 add	 edx, DWORD PTR tv92[ebp]
  00193	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  00196	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00199	2b ca		 sub	 ecx, edx
  0019b	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  0019e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$L22627:

; 427  : 	}
; 428  : 	
; 429  : 	rect->bottom -= sw->cyBottomEdge;				//bottom window edge

  001a1	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  001a4	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  001a7	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  001aa	2b 91 b8 06 00
	00		 sub	 edx, DWORD PTR [ecx+1720]
  001b0	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  001b3	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 430  : 	
; 431  : 	rect->top	  = rect->bottom -
; 432  : 					(sw->sbarHorz.fScrollVisible ?
; 433  : 					GetScrollMetric(&sw->sbarHorz, SM_CYHORZSB) : 0);

  001b6	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  001b9	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  001bd	74 16		 je	 SHORT $L23863
  001bf	6a 01		 push	 1
  001c1	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  001c4	83 c2 08	 add	 edx, 8
  001c7	52		 push	 edx
  001c8	e8 00 00 00 00	 call	 _GetScrollMetric
  001cd	83 c4 08	 add	 esp, 8
  001d0	89 45 f4	 mov	 DWORD PTR tv140[ebp], eax
  001d3	eb 07		 jmp	 SHORT $L23864
$L23863:
  001d5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$L23864:
  001dc	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  001df	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001e2	2b 4d f4	 sub	 ecx, DWORD PTR tv140[ebp]
  001e5	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  001e8	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 434  : 	
; 435  : 	return TRUE;

  001eb	b8 01 00 00 00	 mov	 eax, 1

; 436  : }

  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c3		 ret	 0
_GetHScrollRect ENDP
_TEXT	ENDS
EXTRN	__imp__GetSystemMetrics@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_sbar$ = 8						; size = 4
_metric$ = 12						; size = 4
_GetScrollMetric PROC NEAR

; 269  : {

  00200	55		 push	 ebp
  00201	8b ec		 mov	 ebp, esp
  00203	56		 push	 esi

; 270  : 	if(sbar->nBarType == SB_HORZ)

  00204	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  00207	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  0020e	75 58		 jne	 SHORT $L22537

; 271  : 	{
; 272  : 		if(metric == SM_CXHORZSB)

  00210	83 7d 0c 00	 cmp	 DWORD PTR _metric$[ebp], 0
  00214	75 2c		 jne	 SHORT $L22538

; 273  : 		{
; 274  : 			if(sbar->nArrowLength < 0)

  00216	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  00219	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0021d	7d 18		 jge	 SHORT $L22539

; 275  : 				return -sbar->nArrowLength * GetSystemMetrics(SM_CXHSCROLL);

  0021f	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  00222	8b 72 24	 mov	 esi, DWORD PTR [edx+36]
  00225	f7 de		 neg	 esi
  00227	6a 15		 push	 21			; 00000015H
  00229	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  0022f	0f af c6	 imul	 eax, esi
  00232	e9 91 00 00 00	 jmp	 $L22536
$L22539:

; 276  : 			else
; 277  : 				return sbar->nArrowLength;

  00237	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  0023a	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0023d	e9 86 00 00 00	 jmp	 $L22536
$L22538:

; 278  : 		}
; 279  : 		else
; 280  : 		{
; 281  : 			if(sbar->nArrowWidth < 0)

  00242	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  00245	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00249	7d 15		 jge	 SHORT $L22542

; 282  : 				return -sbar->nArrowWidth * GetSystemMetrics(SM_CYHSCROLL);

  0024b	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  0024e	8b 72 28	 mov	 esi, DWORD PTR [edx+40]
  00251	f7 de		 neg	 esi
  00253	6a 03		 push	 3
  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  0025b	0f af c6	 imul	 eax, esi
  0025e	eb 68		 jmp	 SHORT $L22536
$L22542:

; 283  : 			else
; 284  : 				return sbar->nArrowWidth;

  00260	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  00263	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00266	eb 60		 jmp	 SHORT $L22536
$L22537:

; 285  : 		}
; 286  : 	}
; 287  : 	else if(sbar->nBarType == SB_VERT)

  00268	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  0026b	83 b9 40 03 00
	00 01		 cmp	 DWORD PTR [ecx+832], 1
  00272	75 52		 jne	 SHORT $L22544

; 288  : 	{
; 289  : 		if(metric == SM_CYVERTSB)

  00274	83 7d 0c 00	 cmp	 DWORD PTR _metric$[ebp], 0
  00278	75 26		 jne	 SHORT $L22546

; 290  : 		{
; 291  : 			if(sbar->nArrowLength < 0)

  0027a	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  0027d	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  00281	7d 15		 jge	 SHORT $L22547

; 292  : 				return -sbar->nArrowLength * GetSystemMetrics(SM_CYVSCROLL);

  00283	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  00286	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  00289	f7 de		 neg	 esi
  0028b	6a 14		 push	 20			; 00000014H
  0028d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00293	0f af c6	 imul	 eax, esi
  00296	eb 30		 jmp	 SHORT $L22536
$L22547:

; 293  : 			else
; 294  : 				return sbar->nArrowLength;

  00298	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  0029b	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0029e	eb 28		 jmp	 SHORT $L22536
$L22546:

; 295  : 		}
; 296  : 		else
; 297  : 		{
; 298  : 			if(sbar->nArrowWidth < 0)

  002a0	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  002a3	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  002a7	7d 15		 jge	 SHORT $L22550

; 299  : 				return -sbar->nArrowWidth * GetSystemMetrics(SM_CXVSCROLL);

  002a9	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  002ac	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  002af	f7 de		 neg	 esi
  002b1	6a 02		 push	 2
  002b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  002b9	0f af c6	 imul	 eax, esi
  002bc	eb 0a		 jmp	 SHORT $L22536
$L22550:

; 300  : 			else
; 301  : 				return sbar->nArrowWidth;

  002be	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  002c1	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  002c4	eb 02		 jmp	 SHORT $L22536
$L22544:

; 302  : 		}
; 303  : 	}
; 304  : 
; 305  : 	return 0;

  002c6	33 c0		 xor	 eax, eax
$L22536:

; 306  : }

  002c8	5e		 pop	 esi
  002c9	5d		 pop	 ebp
  002ca	c3		 ret	 0
_GetScrollMetric ENDP
; Function compile flags: /Odt
tv138 = -12						; size = 4
tv93 = -8						; size = 4
tv78 = -4						; size = 4
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_GetVScrollRect PROC NEAR

; 443  : {

  002d0	55		 push	 ebp
  002d1	8b ec		 mov	 ebp, esp
  002d3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 444  : 	GetWindowRect(hwnd, rect);

  002d6	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  002d9	50		 push	 eax
  002da	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  002dd	51		 push	 ecx
  002de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 445  : 	rect->top	 += sw->cyTopEdge;						//top window edge

  002e4	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  002e7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002ea	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  002ed	03 81 b4 06 00
	00		 add	 eax, DWORD PTR [ecx+1716]
  002f3	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  002f6	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 446  : 	
; 447  : 	rect->bottom -= sw->cyBottomEdge + 
; 448  : 					(sw->sbarHorz.fScrollVisible ?		//bottom window edge
; 449  : 					GetScrollMetric(&sw->sbarHorz, SM_CYHORZSB) : 0);

  002f9	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  002fc	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00300	74 16		 je	 SHORT $L23867
  00302	6a 01		 push	 1
  00304	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00307	83 c1 08	 add	 ecx, 8
  0030a	51		 push	 ecx
  0030b	e8 00 00 00 00	 call	 _GetScrollMetric
  00310	83 c4 08	 add	 esp, 8
  00313	89 45 fc	 mov	 DWORD PTR tv78[ebp], eax
  00316	eb 07		 jmp	 SHORT $L23868
$L23867:
  00318	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$L23868:
  0031f	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00322	8b 82 b8 06 00
	00		 mov	 eax, DWORD PTR [edx+1720]
  00328	03 45 fc	 add	 eax, DWORD PTR tv78[ebp]
  0032b	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0032e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00331	2b d0		 sub	 edx, eax
  00333	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  00336	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 450  : 
; 451  : 	if(sw->fLeftScrollbar)

  00339	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0033c	83 b9 a4 06 00
	00 00		 cmp	 DWORD PTR [ecx+1700], 0
  00343	74 4f		 je	 SHORT $L22636

; 452  : 	{
; 453  : 		rect->left	+= sw->cxLeftEdge;

  00345	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  00348	8b 02		 mov	 eax, DWORD PTR [edx]
  0034a	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0034d	03 81 ac 06 00
	00		 add	 eax, DWORD PTR [ecx+1708]
  00353	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  00356	89 02		 mov	 DWORD PTR [edx], eax

; 454  : 		rect->right = rect->left + (sw->sbarVert.fScrollVisible ?
; 455  : 					GetScrollMetric(&sw->sbarVert, SM_CXVERTSB) : 0);

  00358	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0035b	83 b8 58 03 00
	00 00		 cmp	 DWORD PTR [eax+856], 0
  00362	74 19		 je	 SHORT $L23869
  00364	6a 01		 push	 1
  00366	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00369	81 c1 54 03 00
	00		 add	 ecx, 852		; 00000354H
  0036f	51		 push	 ecx
  00370	e8 00 00 00 00	 call	 _GetScrollMetric
  00375	83 c4 08	 add	 esp, 8
  00378	89 45 f8	 mov	 DWORD PTR tv93[ebp], eax
  0037b	eb 07		 jmp	 SHORT $L23870
$L23869:
  0037d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
$L23870:
  00384	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  00387	8b 02		 mov	 eax, DWORD PTR [edx]
  00389	03 45 f8	 add	 eax, DWORD PTR tv93[ebp]
  0038c	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0038f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 456  : 	}
; 457  : 	else

  00392	eb 4f		 jmp	 SHORT $L22637
$L22636:

; 458  : 	{
; 459  : 		rect->right  -= sw->cxRightEdge;

  00394	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  00397	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0039a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0039d	2b 88 b0 06 00
	00		 sub	 ecx, DWORD PTR [eax+1712]
  003a3	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  003a6	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 460  : 		rect->left    = rect->right - (sw->sbarVert.fScrollVisible ?	
; 461  : 					GetScrollMetric(&sw->sbarVert, SM_CXVERTSB) : 0);

  003a9	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  003ac	83 b8 58 03 00
	00 00		 cmp	 DWORD PTR [eax+856], 0
  003b3	74 19		 je	 SHORT $L23871
  003b5	6a 01		 push	 1
  003b7	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  003ba	81 c1 54 03 00
	00		 add	 ecx, 852		; 00000354H
  003c0	51		 push	 ecx
  003c1	e8 00 00 00 00	 call	 _GetScrollMetric
  003c6	83 c4 08	 add	 esp, 8
  003c9	89 45 f4	 mov	 DWORD PTR tv138[ebp], eax
  003cc	eb 07		 jmp	 SHORT $L23872
$L23871:
  003ce	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv138[ebp], 0
$L23872:
  003d5	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  003d8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  003db	2b 45 f4	 sub	 eax, DWORD PTR tv138[ebp]
  003de	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  003e1	89 01		 mov	 DWORD PTR [ecx], eax
$L22637:

; 462  : 	}
; 463  : 
; 464  : 	return TRUE;

  003e3	b8 01 00 00 00	 mov	 eax, 1

; 465  : }

  003e8	8b e5		 mov	 esp, ebp
  003ea	5d		 pop	 ebp
  003eb	c3		 ret	 0
_GetVScrollRect ENDP
_TEXT	ENDS
PUBLIC	_CoolSB_GetDC
EXTRN	__imp__GetWindowDC@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_hwnd$ = 8						; size = 4
_wParam$ = 12						; size = 4
_CoolSB_GetDC PROC NEAR

; 1384 : {

  003f0	55		 push	 ebp
  003f1	8b ec		 mov	 ebp, esp

; 1385 : 	// I just can't figure out GetDCEx, so I'll just use this:
; 1386 : 	return GetWindowDC(hwnd);

  003f3	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  003f6	50		 push	 eax
  003f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4

; 1387 : 
; 1388 : 	/*
; 1389 : 	RECT rc;
; 1390 : 	DWORD flags = 0x10000;
; 1391 : 	HRGN hrgn = (HRGN)wParam;
; 1392 : 
; 1393 : 	if(hrgn == (HRGN)1)
; 1394 : 	{
; 1395 : 		GetWindowRect(hwnd, &rc);
; 1396 : 		OffsetRect(&rc, -rc.left, -rc.top);
; 1397 : 		hrgn = CreateRectRgnIndirect(&rc);
; 1398 : 	}
; 1399 : 
; 1400 : 	if(GetWindowLong(hwnd, GWL_STYLE) & WS_CLIPCHILDREN)
; 1401 : 		flags |= DCX_CLIPCHILDREN;
; 1402 : 
; 1403 : 	if(GetWindowLong(hwnd, GWL_STYLE) & WS_CLIPSIBLINGS)
; 1404 : 		flags |= DCX_CLIPSIBLINGS;
; 1405 : 
; 1406 : 	return GetDCEx(hwnd, hrgn, flags | DCX_CACHE|DCX_NORESETATTRS|DCX_WINDOW | DCX_INTERSECTUPDATE);
; 1407 : 	*/
; 1408 : 
; 1409 : 	//return GetDCEx(hwnd, NULL, flags | DCX_WINDOW| DCX_NORESETATTRS);
; 1410 : }

  003fd	5d		 pop	 ebp
  003fe	c3		 ret	 0
_CoolSB_GetDC ENDP
_TEXT	ENDS
PUBLIC	_CoolSBWndProc@16
EXTRN	__imp__CallWindowProcA@20:NEAR
EXTRN	_UninitializeCoolSB@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv66 = -12						; size = 4
_oldproc$ = -8						; size = 4
_swnd$ = -4						; size = 4
_hwnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_CoolSBWndProc@16 PROC NEAR

; 3095 : {

  00400	55		 push	 ebp
  00401	8b ec		 mov	 ebp, esp
  00403	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3096 : 	WNDPROC oldproc;
; 3097 : 	SCROLLWND *swnd = GetScrollWndFromHwnd(hwnd);

  00406	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00409	50		 push	 eax
  0040a	e8 00 00 00 00	 call	 _GetScrollWndFromHwnd
  0040f	83 c4 04	 add	 esp, 4
  00412	89 45 fc	 mov	 DWORD PTR _swnd$[ebp], eax

; 3098 : 	static int count;
; 3099 : 
; 3100 : 	switch(message)

  00415	8b 4d 0c	 mov	 ecx, DWORD PTR _message$[ebp]
  00418	89 4d f4	 mov	 DWORD PTR tv66[ebp], ecx
  0041b	81 7d f4 a0 00
	00 00		 cmp	 DWORD PTR tv66[ebp], 160 ; 000000a0H
  00422	77 31		 ja	 SHORT $L23875
  00424	81 7d f4 a0 00
	00 00		 cmp	 DWORD PTR tv66[ebp], 160 ; 000000a0H
  0042b	0f 84 68 02 00
	00		 je	 $L23749
  00431	8b 55 f4	 mov	 edx, DWORD PTR tv66[ebp]
  00434	83 ea 20	 sub	 edx, 32			; 00000020H
  00437	89 55 f4	 mov	 DWORD PTR tv66[ebp], edx
  0043a	83 7d f4 65	 cmp	 DWORD PTR tv66[ebp], 101 ; 00000065H
  0043e	0f 87 b4 02 00
	00		 ja	 $L23724
  00444	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  00447	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $L23877[eax]
  0044e	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L23878[ecx*4]
$L23875:
  00455	81 7d f4 a8 00
	00 00		 cmp	 DWORD PTR tv66[ebp], 168 ; 000000a8H
  0045c	77 2d		 ja	 SHORT $L23876
  0045e	81 7d f4 a7 00
	00 00		 cmp	 DWORD PTR tv66[ebp], 167 ; 000000a7H
  00465	0f 83 d4 00 00
	00		 jae	 $L23731
  0046b	8b 55 f4	 mov	 edx, DWORD PTR tv66[ebp]
  0046e	81 ea a1 00 00
	00		 sub	 edx, 161		; 000000a1H
  00474	89 55 f4	 mov	 DWORD PTR tv66[ebp], edx
  00477	83 7d f4 04	 cmp	 DWORD PTR tv66[ebp], 4
  0047b	0f 87 77 02 00
	00		 ja	 $L23724
  00481	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  00484	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L23879[eax*4]
$L23876:
  0048b	81 7d f4 13 01
	00 00		 cmp	 DWORD PTR tv66[ebp], 275 ; 00000113H
  00492	0f 84 ad 01 00
	00		 je	 $L23743
  00498	81 7d f4 00 02
	00 00		 cmp	 DWORD PTR tv66[ebp], 512 ; 00000200H
  0049f	0f 84 83 01 00
	00		 je	 $L23742
  004a5	81 7d f4 02 02
	00 00		 cmp	 DWORD PTR tv66[ebp], 514 ; 00000202H
  004ac	0f 84 24 01 00
	00		 je	 $L23740
  004b2	e9 41 02 00 00	 jmp	 $L23724
$L23727:

; 3101 : 	{
; 3102 : 	case WM_NCDESTROY:
; 3103 : 		//this should NEVER be called, because the user
; 3104 : 		//should have called Uninitialize() themselves.
; 3105 : 
; 3106 : 		//However, if the user tries to call Uninitialize().. 
; 3107 : 		//after this window is destroyed, this window's entry in the lookup
; 3108 : 		//table will not be there, and the call will fail
; 3109 : 		oldproc = swnd->oldproc;

  004b7	8b 4d fc	 mov	 ecx, DWORD PTR _swnd$[ebp]
  004ba	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  004bd	89 55 f8	 mov	 DWORD PTR _oldproc$[ebp], edx

; 3110 : 		UninitializeCoolSB(hwnd);

  004c0	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  004c3	50		 push	 eax
  004c4	e8 00 00 00 00	 call	 _UninitializeCoolSB@4

; 3111 : 		
; 3112 : 		//we must call the original window procedure, otherwise it
; 3113 : 		//will never get the WM_NCDESTROY message, and it wouldn't
; 3114 : 		//be able to clean up etc.
; 3115 : 		return CallWindowProc(oldproc, hwnd, message, wParam, lParam);

  004c9	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  004cc	51		 push	 ecx
  004cd	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  004d0	52		 push	 edx
  004d1	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  004d4	50		 push	 eax
  004d5	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  004d8	51		 push	 ecx
  004d9	8b 55 f8	 mov	 edx, DWORD PTR _oldproc$[ebp]
  004dc	52		 push	 edx
  004dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  004e3	e9 2d 02 00 00	 jmp	 $L23718
$L23728:

; 3116 : 
; 3117 : 	case WM_NCCALCSIZE:
; 3118 : 		return NCCalcSize(swnd, hwnd, wParam, lParam);

  004e8	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  004eb	50		 push	 eax
  004ec	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  004ef	51		 push	 ecx
  004f0	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  004f3	52		 push	 edx
  004f4	8b 45 fc	 mov	 eax, DWORD PTR _swnd$[ebp]
  004f7	50		 push	 eax
  004f8	e8 00 00 00 00	 call	 _NCCalcSize
  004fd	83 c4 10	 add	 esp, 16			; 00000010H
  00500	e9 10 02 00 00	 jmp	 $L23718
$L23729:

; 3119 : 
; 3120 : 	case WM_NCPAINT:
; 3121 : 		return NCPaint(swnd, hwnd, wParam, lParam);	

  00505	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00508	51		 push	 ecx
  00509	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  0050c	52		 push	 edx
  0050d	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00510	50		 push	 eax
  00511	8b 4d fc	 mov	 ecx, DWORD PTR _swnd$[ebp]
  00514	51		 push	 ecx
  00515	e8 00 00 00 00	 call	 _NCPaint
  0051a	83 c4 10	 add	 esp, 16			; 00000010H
  0051d	e9 f3 01 00 00	 jmp	 $L23718
$L23730:

; 3122 : 
; 3123 : 	case WM_NCHITTEST:
; 3124 : 		return NCHitTest(swnd, hwnd, wParam, lParam);

  00522	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  00525	52		 push	 edx
  00526	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00529	50		 push	 eax
  0052a	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0052d	51		 push	 ecx
  0052e	8b 55 fc	 mov	 edx, DWORD PTR _swnd$[ebp]
  00531	52		 push	 edx
  00532	e8 00 00 00 00	 call	 _NCHitTest
  00537	83 c4 10	 add	 esp, 16			; 00000010H
  0053a	e9 d6 01 00 00	 jmp	 $L23718
$L23731:

; 3125 : 
; 3126 : 	case WM_NCRBUTTONDOWN: case WM_NCRBUTTONUP: 
; 3127 : 	case WM_NCMBUTTONDOWN: case WM_NCMBUTTONUP: 
; 3128 : 		RelayMouseEvent(hwnd, swnd->hwndToolTip, (WM_MOUSEMOVE-WM_NCMOUSEMOVE) + (message));

  0053f	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  00542	05 60 01 00 00	 add	 eax, 352		; 00000160H
  00547	50		 push	 eax
  00548	8b 4d fc	 mov	 ecx, DWORD PTR _swnd$[ebp]
  0054b	8b 91 a8 06 00
	00		 mov	 edx, DWORD PTR [ecx+1704]
  00551	52		 push	 edx
  00552	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00555	50		 push	 eax
  00556	e8 00 00 00 00	 call	 _RelayMouseEvent@12

; 3129 : 		if(wParam == HTHSCROLL || wParam == HTVSCROLL) 

  0055b	83 7d 10 06	 cmp	 DWORD PTR _wParam$[ebp], 6
  0055f	74 06		 je	 SHORT $L23733
  00561	83 7d 10 07	 cmp	 DWORD PTR _wParam$[ebp], 7
  00565	75 07		 jne	 SHORT $L23732
$L23733:

; 3130 : 			return 0;

  00567	33 c0		 xor	 eax, eax
  00569	e9 a7 01 00 00	 jmp	 $L23718
$L23732:

; 3131 : 		else 
; 3132 : 			break;

  0056e	e9 85 01 00 00	 jmp	 $L23724
$L23735:

; 3133 : 
; 3134 : 	case WM_NCLBUTTONDBLCLK:
; 3135 : 		//TRACE("WM_NCLBUTTONDBLCLK %d\n", count++);
; 3136 : 		if(wParam == HTHSCROLL || wParam == HTVSCROLL)

  00573	83 7d 10 06	 cmp	 DWORD PTR _wParam$[ebp], 6
  00577	74 06		 je	 SHORT $L23737
  00579	83 7d 10 07	 cmp	 DWORD PTR _wParam$[ebp], 7
  0057d	75 1d		 jne	 SHORT $L23736
$L23737:

; 3137 : 			return NCLButtonDown(swnd, hwnd, wParam, lParam);

  0057f	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00582	51		 push	 ecx
  00583	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00586	52		 push	 edx
  00587	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0058a	50		 push	 eax
  0058b	8b 4d fc	 mov	 ecx, DWORD PTR _swnd$[ebp]
  0058e	51		 push	 ecx
  0058f	e8 00 00 00 00	 call	 _NCLButtonDown
  00594	83 c4 10	 add	 esp, 16			; 00000010H
  00597	e9 79 01 00 00	 jmp	 $L23718
$L23736:

; 3138 : 		else
; 3139 : 			break;

  0059c	e9 57 01 00 00	 jmp	 $L23724
$L23739:

; 3140 : 
; 3141 : 	case WM_NCLBUTTONDOWN:
; 3142 : 		//TRACE("WM_NCLBUTTONDOWN%d\n", count++);
; 3143 : 		RelayMouseEvent(hwnd, swnd->hwndToolTip, WM_LBUTTONDOWN);

  005a1	68 01 02 00 00	 push	 513			; 00000201H
  005a6	8b 55 fc	 mov	 edx, DWORD PTR _swnd$[ebp]
  005a9	8b 82 a8 06 00
	00		 mov	 eax, DWORD PTR [edx+1704]
  005af	50		 push	 eax
  005b0	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  005b3	51		 push	 ecx
  005b4	e8 00 00 00 00	 call	 _RelayMouseEvent@12

; 3144 : 		return NCLButtonDown(swnd, hwnd, wParam, lParam);

  005b9	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  005bc	52		 push	 edx
  005bd	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  005c0	50		 push	 eax
  005c1	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  005c4	51		 push	 ecx
  005c5	8b 55 fc	 mov	 edx, DWORD PTR _swnd$[ebp]
  005c8	52		 push	 edx
  005c9	e8 00 00 00 00	 call	 _NCLButtonDown
  005ce	83 c4 10	 add	 esp, 16			; 00000010H
  005d1	e9 3f 01 00 00	 jmp	 $L23718
$L23740:

; 3145 : 
; 3146 : 
; 3147 : 	case WM_LBUTTONUP:
; 3148 : 		//TRACE("WM_LBUTTONUP %d\n", count++);
; 3149 : 		RelayMouseEvent(hwnd, swnd->hwndToolTip, WM_LBUTTONUP);

  005d6	68 02 02 00 00	 push	 514			; 00000202H
  005db	8b 45 fc	 mov	 eax, DWORD PTR _swnd$[ebp]
  005de	8b 88 a8 06 00
	00		 mov	 ecx, DWORD PTR [eax+1704]
  005e4	51		 push	 ecx
  005e5	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  005e8	52		 push	 edx
  005e9	e8 00 00 00 00	 call	 _RelayMouseEvent@12

; 3150 : 		return LButtonUp(swnd, hwnd, wParam, lParam);

  005ee	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  005f1	50		 push	 eax
  005f2	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  005f5	51		 push	 ecx
  005f6	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  005f9	52		 push	 edx
  005fa	8b 45 fc	 mov	 eax, DWORD PTR _swnd$[ebp]
  005fd	50		 push	 eax
  005fe	e8 00 00 00 00	 call	 _LButtonUp
  00603	83 c4 10	 add	 esp, 16			; 00000010H
  00606	e9 0a 01 00 00	 jmp	 $L23718
$L23741:

; 3151 : 
; 3152 : 	case WM_NOTIFY:
; 3153 : 		return CoolSB_Notify(swnd, hwnd, wParam, lParam);

  0060b	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  0060e	51		 push	 ecx
  0060f	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00612	52		 push	 edx
  00613	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00616	50		 push	 eax
  00617	8b 4d fc	 mov	 ecx, DWORD PTR _swnd$[ebp]
  0061a	51		 push	 ecx
  0061b	e8 00 00 00 00	 call	 _CoolSB_Notify
  00620	83 c4 10	 add	 esp, 16			; 00000010H
  00623	e9 ed 00 00 00	 jmp	 $L23718
$L23742:

; 3154 : 
; 3155 : 	//Mouse moves are received when we set the mouse capture,
; 3156 : 	//even when the mouse moves over the non-client area
; 3157 : 	case WM_MOUSEMOVE: 
; 3158 : 		//TRACE("WM_MOUSEMOVE %d\n", count++);
; 3159 : 		return MouseMove(swnd, hwnd, wParam, lParam);

  00628	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  0062b	52		 push	 edx
  0062c	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0062f	50		 push	 eax
  00630	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00633	51		 push	 ecx
  00634	8b 55 fc	 mov	 edx, DWORD PTR _swnd$[ebp]
  00637	52		 push	 edx
  00638	e8 00 00 00 00	 call	 _MouseMove
  0063d	83 c4 10	 add	 esp, 16			; 00000010H
  00640	e9 d0 00 00 00	 jmp	 $L23718
$L23743:

; 3160 : 	
; 3161 : 	case WM_TIMER:
; 3162 : 		return CoolSB_Timer(swnd, hwnd, wParam, lParam);

  00645	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00648	50		 push	 eax
  00649	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0064c	51		 push	 ecx
  0064d	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00650	52		 push	 edx
  00651	8b 45 fc	 mov	 eax, DWORD PTR _swnd$[ebp]
  00654	50		 push	 eax
  00655	e8 00 00 00 00	 call	 _CoolSB_Timer
  0065a	83 c4 10	 add	 esp, 16			; 00000010H
  0065d	e9 b3 00 00 00	 jmp	 $L23718
$L23744:

; 3163 : 
; 3164 : 	//case WM_STYLECHANGING:
; 3165 : 	//	return CoolSB_StyleChange(swnd, hwnd, WM_STYLECHANGING, wParam, lParam);
; 3166 : 	case WM_STYLECHANGED:
; 3167 : 
; 3168 : 		if(swnd->bPreventStyleChange)

  00662	8b 4d fc	 mov	 ecx, DWORD PTR _swnd$[ebp]
  00665	83 b9 bc 06 00
	00 00		 cmp	 DWORD PTR [ecx+1724], 0
  0066c	74 07		 je	 SHORT $L23745

; 3169 : 		{
; 3170 : 			// the NCPAINT handler has told us to eat this message!
; 3171 : 			return 0;

  0066e	33 c0		 xor	 eax, eax
  00670	e9 a0 00 00 00	 jmp	 $L23718
$L23745:

; 3172 : 		}
; 3173 : 		else
; 3174 : 		{
; 3175 :             if (message == WM_STYLECHANGED) 

  00675	83 7d 0c 7d	 cmp	 DWORD PTR _message$[ebp], 125 ; 0000007dH
  00679	75 1c		 jne	 SHORT $L23747

; 3176 : 				return CoolSB_StyleChange(swnd, hwnd, WM_STYLECHANGED, wParam, lParam);

  0067b	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  0067e	52		 push	 edx
  0067f	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00682	50		 push	 eax
  00683	6a 7d		 push	 125			; 0000007dH
  00685	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00688	51		 push	 ecx
  00689	8b 55 fc	 mov	 edx, DWORD PTR _swnd$[ebp]
  0068c	52		 push	 edx
  0068d	e8 00 00 00 00	 call	 _CoolSB_StyleChange
  00692	83 c4 14	 add	 esp, 20			; 00000014H
  00695	eb 7e		 jmp	 SHORT $L23718
$L23747:

; 3177 : 			else
; 3178 : 				break;

  00697	eb 5f		 jmp	 SHORT $L23724
$L23749:

; 3179 : 		}
; 3180 : 
; 3181 : 	case WM_NCMOUSEMOVE: 
; 3182 : 		{
; 3183 : 			static LONG lastpos = -1;
; 3184 : 
; 3185 : 			//TRACE("WM_NCMOUSEMOVE %d\n", count++);
; 3186 : 
; 3187 : 			//The problem with NCMOUSEMOVE is that it is sent continuously
; 3188 : 			//even when the mouse is stationary (under win2000 / win98)
; 3189 : 			//
; 3190 : 			//Tooltips don't like being sent a continous stream of mouse-moves
; 3191 : 			//if the cursor isn't moving, because they will think that the mouse
; 3192 : 			//is moving position, and the internal timer will never expire
; 3193 : 			//
; 3194 : 			if(lastpos != lParam)

  00699	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lastpos@?5??CoolSBWndProc@@9@9
  0069e	3b 45 14	 cmp	 eax, DWORD PTR _lParam$[ebp]
  006a1	74 21		 je	 SHORT $L23752

; 3195 : 			{
; 3196 : #pragma warning( disable: 4244)	
; 3197 : 				RelayMouseEvent(hwnd, swnd->hwndToolTip, WM_MOUSEMOVE);

  006a3	68 00 02 00 00	 push	 512			; 00000200H
  006a8	8b 4d fc	 mov	 ecx, DWORD PTR _swnd$[ebp]
  006ab	8b 91 a8 06 00
	00		 mov	 edx, DWORD PTR [ecx+1704]
  006b1	52		 push	 edx
  006b2	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  006b5	50		 push	 eax
  006b6	e8 00 00 00 00	 call	 _RelayMouseEvent@12

; 3198 : 				lastpos = lParam;

  006bb	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  006be	89 0d 00 00 00
	00		 mov	 DWORD PTR ?lastpos@?5??CoolSBWndProc@@9@9, ecx
$L23752:

; 3199 : #pragma warning( default: 4244)	
; 3200 : 			}
; 3201 : 		}
; 3202 : 
; 3203 : 		return NCMouseMove(swnd, hwnd, wParam, lParam);

  006c4	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  006c7	52		 push	 edx
  006c8	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  006cb	50		 push	 eax
  006cc	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  006cf	51		 push	 ecx
  006d0	8b 55 fc	 mov	 edx, DWORD PTR _swnd$[ebp]
  006d3	52		 push	 edx
  006d4	e8 00 00 00 00	 call	 _NCMouseMove
  006d9	83 c4 10	 add	 esp, 16			; 00000010H
  006dc	eb 37		 jmp	 SHORT $L23718
$L23753:

; 3204 : 
; 3205 : 
; 3206 : 	case WM_SETCURSOR:
; 3207 : 		return CoolSB_SetCursor(swnd, hwnd, wParam, lParam);

  006de	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  006e1	50		 push	 eax
  006e2	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  006e5	51		 push	 ecx
  006e6	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  006e9	52		 push	 edx
  006ea	8b 45 fc	 mov	 eax, DWORD PTR _swnd$[ebp]
  006ed	50		 push	 eax
  006ee	e8 00 00 00 00	 call	 _CoolSB_SetCursor
  006f3	83 c4 10	 add	 esp, 16			; 00000010H
  006f6	eb 1d		 jmp	 SHORT $L23718
$L23724:

; 3208 : 	case WM_CAPTURECHANGED:
; 3209 : 		break;
; 3210 : 
; 3211 : 	default:
; 3212 : 		break;
; 3213 : 	}
; 3214 : 	
; 3215 : 	return CallWindowProc(swnd->oldproc, hwnd, message, wParam, lParam);

  006f8	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  006fb	51		 push	 ecx
  006fc	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  006ff	52		 push	 edx
  00700	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  00703	50		 push	 eax
  00704	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00707	51		 push	 ecx
  00708	8b 55 fc	 mov	 edx, DWORD PTR _swnd$[ebp]
  0070b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0070e	50		 push	 eax
  0070f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
$L23718:

; 3216 : }

  00715	8b e5		 mov	 esp, ebp
  00717	5d		 pop	 ebp
  00718	c2 10 00	 ret	 16			; 00000010H
$L23878:
  0071b	00 00 00 00	 DD	 $L23753
  0071f	00 00 00 00	 DD	 $L23741
  00723	00 00 00 00	 DD	 $L23744
  00727	00 00 00 00	 DD	 $L23727
  0072b	00 00 00 00	 DD	 $L23728
  0072f	00 00 00 00	 DD	 $L23730
  00733	00 00 00 00	 DD	 $L23729
  00737	00 00 00 00	 DD	 $L23724
$L23877:
  0073b	00		 DB	 0
  0073c	07		 DB	 7
  0073d	07		 DB	 7
  0073e	07		 DB	 7
  0073f	07		 DB	 7
  00740	07		 DB	 7
  00741	07		 DB	 7
  00742	07		 DB	 7
  00743	07		 DB	 7
  00744	07		 DB	 7
  00745	07		 DB	 7
  00746	07		 DB	 7
  00747	07		 DB	 7
  00748	07		 DB	 7
  00749	07		 DB	 7
  0074a	07		 DB	 7
  0074b	07		 DB	 7
  0074c	07		 DB	 7
  0074d	07		 DB	 7
  0074e	07		 DB	 7
  0074f	07		 DB	 7
  00750	07		 DB	 7
  00751	07		 DB	 7
  00752	07		 DB	 7
  00753	07		 DB	 7
  00754	07		 DB	 7
  00755	07		 DB	 7
  00756	07		 DB	 7
  00757	07		 DB	 7
  00758	07		 DB	 7
  00759	07		 DB	 7
  0075a	07		 DB	 7
  0075b	07		 DB	 7
  0075c	07		 DB	 7
  0075d	07		 DB	 7
  0075e	07		 DB	 7
  0075f	07		 DB	 7
  00760	07		 DB	 7
  00761	07		 DB	 7
  00762	07		 DB	 7
  00763	07		 DB	 7
  00764	07		 DB	 7
  00765	07		 DB	 7
  00766	07		 DB	 7
  00767	07		 DB	 7
  00768	07		 DB	 7
  00769	01		 DB	 1
  0076a	07		 DB	 7
  0076b	07		 DB	 7
  0076c	07		 DB	 7
  0076d	07		 DB	 7
  0076e	07		 DB	 7
  0076f	07		 DB	 7
  00770	07		 DB	 7
  00771	07		 DB	 7
  00772	07		 DB	 7
  00773	07		 DB	 7
  00774	07		 DB	 7
  00775	07		 DB	 7
  00776	07		 DB	 7
  00777	07		 DB	 7
  00778	07		 DB	 7
  00779	07		 DB	 7
  0077a	07		 DB	 7
  0077b	07		 DB	 7
  0077c	07		 DB	 7
  0077d	07		 DB	 7
  0077e	07		 DB	 7
  0077f	07		 DB	 7
  00780	07		 DB	 7
  00781	07		 DB	 7
  00782	07		 DB	 7
  00783	07		 DB	 7
  00784	07		 DB	 7
  00785	07		 DB	 7
  00786	07		 DB	 7
  00787	07		 DB	 7
  00788	07		 DB	 7
  00789	07		 DB	 7
  0078a	07		 DB	 7
  0078b	07		 DB	 7
  0078c	07		 DB	 7
  0078d	07		 DB	 7
  0078e	07		 DB	 7
  0078f	07		 DB	 7
  00790	07		 DB	 7
  00791	07		 DB	 7
  00792	07		 DB	 7
  00793	07		 DB	 7
  00794	07		 DB	 7
  00795	07		 DB	 7
  00796	07		 DB	 7
  00797	07		 DB	 7
  00798	02		 DB	 2
  00799	07		 DB	 7
  0079a	07		 DB	 7
  0079b	07		 DB	 7
  0079c	07		 DB	 7
  0079d	03		 DB	 3
  0079e	04		 DB	 4
  0079f	05		 DB	 5
  007a0	06		 DB	 6
$L23879:
  007a1	00 00 00 00	 DD	 $L23739
  007a5	00 00 00 00	 DD	 $L23724
  007a9	00 00 00 00	 DD	 $L23735
  007ad	00 00 00 00	 DD	 $L23731
  007b1	00 00 00 00	 DD	 $L23731
_CoolSBWndProc@16 ENDP
_TEXT	ENDS
EXTRN	__imp__GetClientRect@8:NEAR
EXTRN	__imp__MapWindowPoints@16:NEAR
EXTRN	__imp__GetSysColor@4:NEAR
EXTRN	__imp__CopyRect@8:NEAR
EXTRN	__imp__OffsetRect@12:NEAR
EXTRN	__imp__GetWindowLongA@8:NEAR
EXTRN	__imp__SetWindowLongA@12:NEAR
EXTRN	__imp__GetParent@4:NEAR
EXTRN	__imp__ReleaseDC@8:NEAR
EXTRN	__imp__DrawFrameControl@16:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_rect2$23090 = -116					; size = 16
_hwndParent$23091 = -100				; size = 4
_parent$23089 = -96					; size = 16
_vbarheight$23073 = -80					; size = 4
_updown$23074 = -76					; size = 4
_hbarwidth$23064 = -72					; size = 4
_leftright$23065 = -68					; size = 4
_hdc$ = -64						; size = 4
_ret$ = -56						; size = 4
_dwStyle$ = -52						; size = 4
_sb$ = -48						; size = 4
_hrgn$ = -44						; size = 4
_fCustomDraw$ = -40					; size = 4
_winrect$ = -36						; size = 16
_rect$ = -20						; size = 16
_fUpdateAll$ = -4					; size = 4
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_NCPaint PROC NEAR

; 1413 : {

  007c0	55		 push	 ebp
  007c1	8b ec		 mov	 ebp, esp
  007c3	83 ec 74	 sub	 esp, 116		; 00000074H

; 1414 : 	SCROLLBAR *sb;
; 1415 : 	HDC hdc;
; 1416 : 	HRGN hrgn;
; 1417 : 	RECT winrect, rect;
; 1418 : 	HRGN clip;
; 1419 : 	BOOL fUpdateAll = ((LONG)wParam == 1);

  007c6	33 c0		 xor	 eax, eax
  007c8	83 7d 10 01	 cmp	 DWORD PTR _wParam$[ebp], 1
  007cc	0f 94 c0	 sete	 al
  007cf	89 45 fc	 mov	 DWORD PTR _fUpdateAll$[ebp], eax

; 1420 : 	BOOL fCustomDraw = FALSE;

  007d2	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _fCustomDraw$[ebp], 0

; 1421 : 	LRESULT ret;
; 1422 : 	DWORD dwStyle;
; 1423 : 
; 1424 : 	GetWindowRect(hwnd, &winrect);

  007d9	8d 4d dc	 lea	 ecx, DWORD PTR _winrect$[ebp]
  007dc	51		 push	 ecx
  007dd	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  007e0	52		 push	 edx
  007e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 1425 : 	
; 1426 : 	//if entire region needs painting, then make a region to cover the entire window
; 1427 : 	if(fUpdateAll)

  007e7	83 7d fc 00	 cmp	 DWORD PTR _fUpdateAll$[ebp], 0
  007eb	74 08		 je	 SHORT $L23059

; 1428 : 		hrgn = (HRGN)wParam;

  007ed	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  007f0	89 45 d4	 mov	 DWORD PTR _hrgn$[ebp], eax

; 1429 : 	else

  007f3	eb 06		 jmp	 SHORT $L23061
$L23059:

; 1430 : 		hrgn = (HRGN)wParam;

  007f5	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  007f8	89 4d d4	 mov	 DWORD PTR _hrgn$[ebp], ecx
$L23061:

; 1431 : 	
; 1432 : 	//hdc = GetWindowDC(hwnd);
; 1433 : 	hdc = CoolSB_GetDC(hwnd, wParam);

  007fb	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  007fe	52		 push	 edx
  007ff	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00802	50		 push	 eax
  00803	e8 00 00 00 00	 call	 _CoolSB_GetDC
  00808	83 c4 08	 add	 esp, 8
  0080b	89 45 c0	 mov	 DWORD PTR _hdc$[ebp], eax

; 1434 : 
; 1435 : 	//
; 1436 : 	//	Only draw the horizontal scrollbar if the window is tall enough
; 1437 : 	//
; 1438 : 	sb = &sw->sbarHorz;

  0080e	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00811	83 c1 08	 add	 ecx, 8
  00814	89 4d d0	 mov	 DWORD PTR _sb$[ebp], ecx

; 1439 : 	if(sb->fScrollVisible)

  00817	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  0081a	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0081e	0f 84 73 01 00
	00		 je	 $L23063

; 1440 : 	{
; 1441 : 		int hbarwidth = 0, leftright = 0;

  00824	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _hbarwidth$23064[ebp], 0
  0082b	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _leftright$23065[ebp], 0

; 1442 : 
; 1443 : 		//get the screen coordinates of the whole horizontal scrollbar area
; 1444 : 		GetHScrollRect(sw, hwnd, &rect);

  00832	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  00835	50		 push	 eax
  00836	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00839	51		 push	 ecx
  0083a	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0083d	52		 push	 edx
  0083e	e8 00 00 00 00	 call	 _GetHScrollRect
  00843	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1445 : 
; 1446 : 		//make the coordinates relative to the window for drawing
; 1447 : 		OffsetRect(&rect, -winrect.left, -winrect.top);

  00846	8b 45 e0	 mov	 eax, DWORD PTR _winrect$[ebp+4]
  00849	f7 d8		 neg	 eax
  0084b	50		 push	 eax
  0084c	8b 4d dc	 mov	 ecx, DWORD PTR _winrect$[ebp]
  0084f	f7 d9		 neg	 ecx
  00851	51		 push	 ecx
  00852	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  00855	52		 push	 edx
  00856	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 1448 : 
; 1449 : #ifdef INCLUDE_BUTTONS
; 1450 : 
; 1451 : 		//work out the size of any inserted buttons so we can dra them
; 1452 : 		sb->nButSizeBefore  = GetButtonSize(sb, hwnd, SBBP_LEFT);

  0085c	6a 01		 push	 1
  0085e	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00861	50		 push	 eax
  00862	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  00865	51		 push	 ecx
  00866	e8 00 00 00 00	 call	 _GetButtonSize
  0086b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0086e	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  00871	89 82 30 03 00
	00		 mov	 DWORD PTR [edx+816], eax

; 1453 : 		sb->nButSizeAfter   = GetButtonSize(sb, hwnd, SBBP_RIGHT);

  00877	6a 02		 push	 2
  00879	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0087c	50		 push	 eax
  0087d	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  00880	51		 push	 ecx
  00881	e8 00 00 00 00	 call	 _GetButtonSize
  00886	83 c4 0c	 add	 esp, 12			; 0000000cH
  00889	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  0088c	89 82 34 03 00
	00		 mov	 DWORD PTR [edx+820], eax

; 1454 : 
; 1455 : 		//make sure there is room for the buttons
; 1456 : 		hbarwidth = rect.right - rect.left;

  00892	8b 45 f4	 mov	 eax, DWORD PTR _rect$[ebp+8]
  00895	2b 45 ec	 sub	 eax, DWORD PTR _rect$[ebp]
  00898	89 45 b8	 mov	 DWORD PTR _hbarwidth$23064[ebp], eax

; 1457 : 
; 1458 : 		//check that we can fit any left/right buttons in the available space
; 1459 : 		if(sb->nButSizeAfter < (hbarwidth - MIN_COOLSB_SIZE))

  0089b	8b 4d b8	 mov	 ecx, DWORD PTR _hbarwidth$23064[ebp]
  0089e	83 e9 18	 sub	 ecx, 24			; 00000018H
  008a1	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  008a4	39 8a 34 03 00
	00		 cmp	 DWORD PTR [edx+820], ecx
  008aa	7d 77		 jge	 SHORT $L23066

; 1460 : 		{
; 1461 : 			//adjust the scrollbar rectangle to fit the buttons into
; 1462 : 			sb->fButVisibleAfter = TRUE;

  008ac	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  008af	c7 80 3c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+828], 1

; 1463 : 			rect.right -= sb->nButSizeAfter;

  008b9	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  008bc	8b 55 f4	 mov	 edx, DWORD PTR _rect$[ebp+8]
  008bf	2b 91 34 03 00
	00		 sub	 edx, DWORD PTR [ecx+820]
  008c5	89 55 f4	 mov	 DWORD PTR _rect$[ebp+8], edx

; 1464 : 			leftright |= SBBP_RIGHT;

  008c8	8b 45 bc	 mov	 eax, DWORD PTR _leftright$23065[ebp]
  008cb	83 c8 02	 or	 eax, 2
  008ce	89 45 bc	 mov	 DWORD PTR _leftright$23065[ebp], eax

; 1465 : 			
; 1466 : 			//check that there is enough space for the right buttons
; 1467 : 			if(sb->nButSizeBefore + sb->nButSizeAfter < (hbarwidth - MIN_COOLSB_SIZE))

  008d1	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  008d4	8b 91 30 03 00
	00		 mov	 edx, DWORD PTR [ecx+816]
  008da	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  008dd	03 90 34 03 00
	00		 add	 edx, DWORD PTR [eax+820]
  008e3	8b 4d b8	 mov	 ecx, DWORD PTR _hbarwidth$23064[ebp]
  008e6	83 e9 18	 sub	 ecx, 24			; 00000018H
  008e9	3b d1		 cmp	 edx, ecx
  008eb	7d 27		 jge	 SHORT $L23067

; 1468 : 			{
; 1469 : 				sb->fButVisibleBefore = TRUE;

  008ed	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  008f0	c7 82 38 03 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+824], 1

; 1470 : 				rect.left += sb->nButSizeBefore;

  008fa	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  008fd	8b 4d ec	 mov	 ecx, DWORD PTR _rect$[ebp]
  00900	03 88 30 03 00
	00		 add	 ecx, DWORD PTR [eax+816]
  00906	89 4d ec	 mov	 DWORD PTR _rect$[ebp], ecx

; 1471 : 				leftright |= SBBP_LEFT;

  00909	8b 55 bc	 mov	 edx, DWORD PTR _leftright$23065[ebp]
  0090c	83 ca 01	 or	 edx, 1
  0090f	89 55 bc	 mov	 DWORD PTR _leftright$23065[ebp], edx

; 1472 : 			}
; 1473 : 			else

  00912	eb 0d		 jmp	 SHORT $L23068
$L23067:

; 1474 : 				sb->fButVisibleBefore = FALSE;

  00914	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  00917	c7 80 38 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+824], 0
$L23068:

; 1475 : 		}	
; 1476 : 		else

  00921	eb 0d		 jmp	 SHORT $L23069
$L23066:

; 1477 : 			sb->fButVisibleAfter = FALSE;

  00923	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  00926	c7 81 3c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+828], 0
$L23069:

; 1478 : 		
; 1479 : 		
; 1480 : 		DrawHorzButtons(sb, hdc, &rect, leftright);

  00930	8b 55 bc	 mov	 edx, DWORD PTR _leftright$23065[ebp]
  00933	52		 push	 edx
  00934	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  00937	50		 push	 eax
  00938	8b 4d c0	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0093b	51		 push	 ecx
  0093c	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  0093f	52		 push	 edx
  00940	e8 00 00 00 00	 call	 _DrawHorzButtons
  00945	83 c4 10	 add	 esp, 16			; 00000010H

; 1481 : #endif// INCLUDE_BUTTONS		
; 1482 : 
; 1483 : 		if(uCurrentScrollbar == SB_HORZ)

  00948	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  0094f	75 26		 jne	 SHORT $L23070

; 1484 : 			fCustomDraw |= NCDrawHScrollbar(sb, hwnd, hdc, &rect, uScrollTimerPortion);

  00951	a1 00 00 00 00	 mov	 eax, DWORD PTR _uScrollTimerPortion
  00956	50		 push	 eax
  00957	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  0095a	51		 push	 ecx
  0095b	8b 55 c0	 mov	 edx, DWORD PTR _hdc$[ebp]
  0095e	52		 push	 edx
  0095f	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00962	50		 push	 eax
  00963	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  00966	51		 push	 ecx
  00967	e8 00 00 00 00	 call	 _NCDrawHScrollbar
  0096c	83 c4 14	 add	 esp, 20			; 00000014H
  0096f	0b 45 d8	 or	 eax, DWORD PTR _fCustomDraw$[ebp]
  00972	89 45 d8	 mov	 DWORD PTR _fCustomDraw$[ebp], eax

; 1485 : 		else

  00975	eb 20		 jmp	 SHORT $L23063
$L23070:

; 1486 : 			fCustomDraw |= NCDrawHScrollbar(sb, hwnd, hdc, &rect, HTSCROLL_NONE);

  00977	6a ff		 push	 -1
  00979	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  0097c	52		 push	 edx
  0097d	8b 45 c0	 mov	 eax, DWORD PTR _hdc$[ebp]
  00980	50		 push	 eax
  00981	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00984	51		 push	 ecx
  00985	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  00988	52		 push	 edx
  00989	e8 00 00 00 00	 call	 _NCDrawHScrollbar
  0098e	83 c4 14	 add	 esp, 20			; 00000014H
  00991	0b 45 d8	 or	 eax, DWORD PTR _fCustomDraw$[ebp]
  00994	89 45 d8	 mov	 DWORD PTR _fCustomDraw$[ebp], eax
$L23063:

; 1487 : 	}
; 1488 : 
; 1489 : 	//
; 1490 : 	// Only draw the vertical scrollbar if the window is wide enough to accomodate it
; 1491 : 	//
; 1492 : 	sb = &sw->sbarVert;

  00997	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0099a	05 54 03 00 00	 add	 eax, 852		; 00000354H
  0099f	89 45 d0	 mov	 DWORD PTR _sb$[ebp], eax

; 1493 : 	if(sb->fScrollVisible)

  009a2	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  009a5	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  009a9	0f 84 74 01 00
	00		 je	 $L23072

; 1494 : 	{
; 1495 : 		int vbarheight = 0, updown = 0;

  009af	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _vbarheight$23073[ebp], 0
  009b6	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _updown$23074[ebp], 0

; 1496 : 
; 1497 : 		//get the screen cooridinates of the whole horizontal scrollbar area
; 1498 : 		GetVScrollRect(sw, hwnd, &rect);

  009bd	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  009c0	52		 push	 edx
  009c1	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  009c4	50		 push	 eax
  009c5	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  009c8	51		 push	 ecx
  009c9	e8 00 00 00 00	 call	 _GetVScrollRect
  009ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1499 : 
; 1500 : 		//make the coordinates relative to the window for drawing
; 1501 : 		OffsetRect(&rect, -winrect.left, -winrect.top);

  009d1	8b 55 e0	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  009d4	f7 da		 neg	 edx
  009d6	52		 push	 edx
  009d7	8b 45 dc	 mov	 eax, DWORD PTR _winrect$[ebp]
  009da	f7 d8		 neg	 eax
  009dc	50		 push	 eax
  009dd	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  009e0	51		 push	 ecx
  009e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 1502 : 
; 1503 : #ifdef INCLUDE_BUTTONS
; 1504 : 
; 1505 : 		//work out the size of any inserted buttons so we can dra them
; 1506 : 		sb->nButSizeBefore  = GetButtonSize(sb, hwnd, SBBP_LEFT);

  009e7	6a 01		 push	 1
  009e9	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  009ec	52		 push	 edx
  009ed	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  009f0	50		 push	 eax
  009f1	e8 00 00 00 00	 call	 _GetButtonSize
  009f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  009f9	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  009fc	89 81 30 03 00
	00		 mov	 DWORD PTR [ecx+816], eax

; 1507 : 		sb->nButSizeAfter   = GetButtonSize(sb, hwnd, SBBP_RIGHT);

  00a02	6a 02		 push	 2
  00a04	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00a07	52		 push	 edx
  00a08	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  00a0b	50		 push	 eax
  00a0c	e8 00 00 00 00	 call	 _GetButtonSize
  00a11	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a14	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  00a17	89 81 34 03 00
	00		 mov	 DWORD PTR [ecx+820], eax

; 1508 : 
; 1509 : 		//make sure there is room for the buttons
; 1510 : 		vbarheight = rect.bottom - rect.top;

  00a1d	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp+12]
  00a20	2b 55 f0	 sub	 edx, DWORD PTR _rect$[ebp+4]
  00a23	89 55 b0	 mov	 DWORD PTR _vbarheight$23073[ebp], edx

; 1511 : 
; 1512 : 		//check that we can fit any left/right buttons in the available space
; 1513 : 		if(sb->nButSizeAfter < (vbarheight - MIN_COOLSB_SIZE))

  00a26	8b 45 b0	 mov	 eax, DWORD PTR _vbarheight$23073[ebp]
  00a29	83 e8 18	 sub	 eax, 24			; 00000018H
  00a2c	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  00a2f	39 81 34 03 00
	00		 cmp	 DWORD PTR [ecx+820], eax
  00a35	7d 77		 jge	 SHORT $L23075

; 1514 : 		{
; 1515 : 			//adjust the scrollbar rectangle to fit the buttons into
; 1516 : 			sb->fButVisibleAfter = TRUE;

  00a37	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  00a3a	c7 82 3c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+828], 1

; 1517 : 			rect.bottom -= sb->nButSizeAfter;

  00a44	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  00a47	8b 4d f8	 mov	 ecx, DWORD PTR _rect$[ebp+12]
  00a4a	2b 88 34 03 00
	00		 sub	 ecx, DWORD PTR [eax+820]
  00a50	89 4d f8	 mov	 DWORD PTR _rect$[ebp+12], ecx

; 1518 : 			updown |= SBBP_BOTTOM;

  00a53	8b 55 b4	 mov	 edx, DWORD PTR _updown$23074[ebp]
  00a56	83 ca 02	 or	 edx, 2
  00a59	89 55 b4	 mov	 DWORD PTR _updown$23074[ebp], edx

; 1519 : 			
; 1520 : 			//check that there is enough space for the right buttons
; 1521 : 			if(sb->nButSizeBefore + sb->nButSizeAfter < (vbarheight - MIN_COOLSB_SIZE))

  00a5c	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  00a5f	8b 88 30 03 00
	00		 mov	 ecx, DWORD PTR [eax+816]
  00a65	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  00a68	03 8a 34 03 00
	00		 add	 ecx, DWORD PTR [edx+820]
  00a6e	8b 45 b0	 mov	 eax, DWORD PTR _vbarheight$23073[ebp]
  00a71	83 e8 18	 sub	 eax, 24			; 00000018H
  00a74	3b c8		 cmp	 ecx, eax
  00a76	7d 27		 jge	 SHORT $L23076

; 1522 : 			{
; 1523 : 				sb->fButVisibleBefore = TRUE;

  00a78	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  00a7b	c7 81 38 03 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+824], 1

; 1524 : 				rect.top += sb->nButSizeBefore;

  00a85	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  00a88	8b 45 f0	 mov	 eax, DWORD PTR _rect$[ebp+4]
  00a8b	03 82 30 03 00
	00		 add	 eax, DWORD PTR [edx+816]
  00a91	89 45 f0	 mov	 DWORD PTR _rect$[ebp+4], eax

; 1525 : 				updown |= SBBP_TOP;

  00a94	8b 4d b4	 mov	 ecx, DWORD PTR _updown$23074[ebp]
  00a97	83 c9 01	 or	 ecx, 1
  00a9a	89 4d b4	 mov	 DWORD PTR _updown$23074[ebp], ecx

; 1526 : 			}
; 1527 : 			else

  00a9d	eb 0d		 jmp	 SHORT $L23077
$L23076:

; 1528 : 				sb->fButVisibleBefore = FALSE;

  00a9f	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  00aa2	c7 82 38 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+824], 0
$L23077:

; 1529 : 		}	
; 1530 : 		else

  00aac	eb 0d		 jmp	 SHORT $L23078
$L23075:

; 1531 : 			sb->fButVisibleAfter = FALSE;

  00aae	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  00ab1	c7 80 3c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+828], 0
$L23078:

; 1532 : 		
; 1533 : 	
; 1534 : 		DrawVertButtons(sb, hdc, &rect, updown);

  00abb	8b 4d b4	 mov	 ecx, DWORD PTR _updown$23074[ebp]
  00abe	51		 push	 ecx
  00abf	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  00ac2	52		 push	 edx
  00ac3	8b 45 c0	 mov	 eax, DWORD PTR _hdc$[ebp]
  00ac6	50		 push	 eax
  00ac7	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  00aca	51		 push	 ecx
  00acb	e8 00 00 00 00	 call	 _DrawVertButtons
  00ad0	83 c4 10	 add	 esp, 16			; 00000010H

; 1535 : #endif // INCLUDE_BUTTONS
; 1536 : 
; 1537 : 		if(uCurrentScrollbar == SB_VERT)

  00ad3	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uCurrentScrollbar, 1
  00ada	75 27		 jne	 SHORT $L23079

; 1538 : 			fCustomDraw |= NCDrawVScrollbar(sb, hwnd, hdc, &rect, uScrollTimerPortion);

  00adc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uScrollTimerPortion
  00ae2	52		 push	 edx
  00ae3	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  00ae6	50		 push	 eax
  00ae7	8b 4d c0	 mov	 ecx, DWORD PTR _hdc$[ebp]
  00aea	51		 push	 ecx
  00aeb	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00aee	52		 push	 edx
  00aef	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  00af2	50		 push	 eax
  00af3	e8 00 00 00 00	 call	 _NCDrawVScrollbar
  00af8	83 c4 14	 add	 esp, 20			; 00000014H
  00afb	0b 45 d8	 or	 eax, DWORD PTR _fCustomDraw$[ebp]
  00afe	89 45 d8	 mov	 DWORD PTR _fCustomDraw$[ebp], eax

; 1539 : 		else

  00b01	eb 20		 jmp	 SHORT $L23072
$L23079:

; 1540 : 			fCustomDraw |= NCDrawVScrollbar(sb, hwnd, hdc, &rect, HTSCROLL_NONE);

  00b03	6a ff		 push	 -1
  00b05	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  00b08	51		 push	 ecx
  00b09	8b 55 c0	 mov	 edx, DWORD PTR _hdc$[ebp]
  00b0c	52		 push	 edx
  00b0d	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00b10	50		 push	 eax
  00b11	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  00b14	51		 push	 ecx
  00b15	e8 00 00 00 00	 call	 _NCDrawVScrollbar
  00b1a	83 c4 14	 add	 esp, 20			; 00000014H
  00b1d	0b 45 d8	 or	 eax, DWORD PTR _fCustomDraw$[ebp]
  00b20	89 45 d8	 mov	 DWORD PTR _fCustomDraw$[ebp], eax
$L23072:

; 1541 : 	}
; 1542 : 
; 1543 : 	//Call the default window procedure for WM_NCPAINT, with the
; 1544 : 	//new window region. ** region must be in SCREEN coordinates **
; 1545 : 	dwStyle = GetWindowLong(hwnd, GWL_STYLE);

  00b23	6a f0		 push	 -16			; fffffff0H
  00b25	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00b28	52		 push	 edx
  00b29	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  00b2f	89 45 cc	 mov	 DWORD PTR _dwStyle$[ebp], eax

; 1546 : 
; 1547 :     // If the window has WS_(H-V)SCROLL bits set, we should reset them
; 1548 :     // to avoid windows taking the scrollbars into account.
; 1549 :     // We temporarily set a flag preventing the subsecuent 
; 1550 :     // WM_STYLECHANGING/WM_STYLECHANGED to be forwarded to 
; 1551 :     // the original window procedure
; 1552 :     if ( dwStyle & (WS_VSCROLL|WS_HSCROLL) )

  00b32	8b 45 cc	 mov	 eax, DWORD PTR _dwStyle$[ebp]
  00b35	25 00 00 30 00	 and	 eax, 3145728		; 00300000H
  00b3a	74 23		 je	 SHORT $L23081

; 1553 :     {
; 1554 :         sw->bPreventStyleChange = TRUE;

  00b3c	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00b3f	c7 81 bc 06 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+1724], 1

; 1555 :         SetWindowLong(hwnd, GWL_STYLE, dwStyle & ~(WS_VSCROLL|WS_HSCROLL));

  00b49	8b 55 cc	 mov	 edx, DWORD PTR _dwStyle$[ebp]
  00b4c	81 e2 ff ff cf
	ff		 and	 edx, -3145729		; ffcfffffH
  00b52	52		 push	 edx
  00b53	6a f0		 push	 -16			; fffffff0H
  00b55	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00b58	50		 push	 eax
  00b59	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12
$L23081:

; 1556 :     }
; 1557 : 	
; 1558 : 	ret = CallWindowProc(sw->oldproc, hwnd, WM_NCPAINT, (WPARAM)hrgn, lParam);

  00b5f	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00b62	51		 push	 ecx
  00b63	8b 55 d4	 mov	 edx, DWORD PTR _hrgn$[ebp]
  00b66	52		 push	 edx
  00b67	68 85 00 00 00	 push	 133			; 00000085H
  00b6c	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00b6f	50		 push	 eax
  00b70	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00b73	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00b76	52		 push	 edx
  00b77	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  00b7d	89 45 c8	 mov	 DWORD PTR _ret$[ebp], eax

; 1559 : 	
; 1560 :     if ( dwStyle & (WS_VSCROLL|WS_HSCROLL) )

  00b80	8b 45 cc	 mov	 eax, DWORD PTR _dwStyle$[ebp]
  00b83	25 00 00 30 00	 and	 eax, 3145728		; 00300000H
  00b88	74 1d		 je	 SHORT $L23083

; 1561 :     {
; 1562 :         SetWindowLong(hwnd, GWL_STYLE, dwStyle);

  00b8a	8b 4d cc	 mov	 ecx, DWORD PTR _dwStyle$[ebp]
  00b8d	51		 push	 ecx
  00b8e	6a f0		 push	 -16			; fffffff0H
  00b90	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00b93	52		 push	 edx
  00b94	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 1563 :         sw->bPreventStyleChange = FALSE;

  00b9a	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00b9d	c7 80 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1724], 0
$L23083:

; 1564 :     }
; 1565 : 
; 1566 : 
; 1567 : 	// DRAW THE DEAD AREA
; 1568 : 	// only do this if the horizontal and vertical bars are visible
; 1569 : 	if(sw->sbarHorz.fScrollVisible && sw->sbarVert.fScrollVisible)

  00ba7	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00baa	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00bae	0f 84 d0 01 00
	00		 je	 $L23084
  00bb4	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00bb7	83 ba 58 03 00
	00 00		 cmp	 DWORD PTR [edx+856], 0
  00bbe	0f 84 c0 01 00
	00		 je	 $L23084

; 1570 : 	{
; 1571 : 		GetWindowRect(hwnd, &rect);

  00bc4	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  00bc7	50		 push	 eax
  00bc8	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00bcb	51		 push	 ecx
  00bcc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 1572 : 		OffsetRect(&rect, -winrect.left, -winrect.top);

  00bd2	8b 55 e0	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  00bd5	f7 da		 neg	 edx
  00bd7	52		 push	 edx
  00bd8	8b 45 dc	 mov	 eax, DWORD PTR _winrect$[ebp]
  00bdb	f7 d8		 neg	 eax
  00bdd	50		 push	 eax
  00bde	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  00be1	51		 push	 ecx
  00be2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 1573 : 
; 1574 : 		rect.bottom -= sw->cyBottomEdge;

  00be8	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00beb	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp+12]
  00bee	2b 82 b8 06 00
	00		 sub	 eax, DWORD PTR [edx+1720]
  00bf4	89 45 f8	 mov	 DWORD PTR _rect$[ebp+12], eax

; 1575 : 		rect.top  = rect.bottom - GetScrollMetric(&sw->sbarHorz, SM_CYHORZSB);

  00bf7	6a 01		 push	 1
  00bf9	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00bfc	83 c1 08	 add	 ecx, 8
  00bff	51		 push	 ecx
  00c00	e8 00 00 00 00	 call	 _GetScrollMetric
  00c05	83 c4 08	 add	 esp, 8
  00c08	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp+12]
  00c0b	2b d0		 sub	 edx, eax
  00c0d	89 55 f0	 mov	 DWORD PTR _rect$[ebp+4], edx

; 1576 : 
; 1577 : 		if(sw->fLeftScrollbar)

  00c10	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00c13	83 b8 a4 06 00
	00 00		 cmp	 DWORD PTR [eax+1700], 0
  00c1a	74 2a		 je	 SHORT $L23085

; 1578 : 		{
; 1579 : 			rect.left += sw->cxLeftEdge;

  00c1c	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00c1f	8b 55 ec	 mov	 edx, DWORD PTR _rect$[ebp]
  00c22	03 91 ac 06 00
	00		 add	 edx, DWORD PTR [ecx+1708]
  00c28	89 55 ec	 mov	 DWORD PTR _rect$[ebp], edx

; 1580 : 			rect.right = rect.left + GetScrollMetric(&sw->sbarVert, SM_CXVERTSB);

  00c2b	6a 01		 push	 1
  00c2d	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00c30	05 54 03 00 00	 add	 eax, 852		; 00000354H
  00c35	50		 push	 eax
  00c36	e8 00 00 00 00	 call	 _GetScrollMetric
  00c3b	83 c4 08	 add	 esp, 8
  00c3e	03 45 ec	 add	 eax, DWORD PTR _rect$[ebp]
  00c41	89 45 f4	 mov	 DWORD PTR _rect$[ebp+8], eax

; 1581 : 		}
; 1582 : 		else

  00c44	eb 2a		 jmp	 SHORT $L23086
$L23085:

; 1583 : 		{
; 1584 : 			rect.right -= sw->cxRightEdge;

  00c46	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00c49	8b 55 f4	 mov	 edx, DWORD PTR _rect$[ebp+8]
  00c4c	2b 91 b0 06 00
	00		 sub	 edx, DWORD PTR [ecx+1712]
  00c52	89 55 f4	 mov	 DWORD PTR _rect$[ebp+8], edx

; 1585 : 			rect.left = rect.right  - GetScrollMetric(&sw->sbarVert, SM_CXVERTSB);

  00c55	6a 01		 push	 1
  00c57	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00c5a	05 54 03 00 00	 add	 eax, 852		; 00000354H
  00c5f	50		 push	 eax
  00c60	e8 00 00 00 00	 call	 _GetScrollMetric
  00c65	83 c4 08	 add	 esp, 8
  00c68	8b 4d f4	 mov	 ecx, DWORD PTR _rect$[ebp+8]
  00c6b	2b c8		 sub	 ecx, eax
  00c6d	89 4d ec	 mov	 DWORD PTR _rect$[ebp], ecx
$L23086:

; 1586 : 		}
; 1587 : 		
; 1588 : 		if(fCustomDraw)

  00c70	83 7d d8 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  00c74	74 23		 je	 SHORT $L23087

; 1589 : 			PostCustomDrawNotify(hwnd, hdc, SB_BOTH, &rect, 32, 0, 0, 0);

  00c76	6a 00		 push	 0
  00c78	6a 00		 push	 0
  00c7a	6a 00		 push	 0
  00c7c	6a 20		 push	 32			; 00000020H
  00c7e	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  00c81	52		 push	 edx
  00c82	6a 03		 push	 3
  00c84	8b 45 c0	 mov	 eax, DWORD PTR _hdc$[ebp]
  00c87	50		 push	 eax
  00c88	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00c8b	51		 push	 ecx
  00c8c	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  00c91	83 c4 20	 add	 esp, 32			; 00000020H

; 1590 : 		else

  00c94	e9 eb 00 00 00	 jmp	 $L23084
$L23087:

; 1591 : 		{
; 1592 : 			//calculate the position of THIS window's dead area
; 1593 : 			//with the position of the PARENT window's client rectangle.
; 1594 : 			//if THIS window has been positioned such that its bottom-right
; 1595 : 			//corner sits in the parent's bottom-right corner, then we should
; 1596 : 			//show the sizing-grip.
; 1597 : 			//Otherwise, assume this window is not in the right place, and
; 1598 : 			//just draw a blank rectangle
; 1599 : 			RECT parent;
; 1600 : 			RECT rect2;
; 1601 : 			HWND hwndParent = GetParent(hwnd);

  00c99	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00c9c	52		 push	 edx
  00c9d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00ca3	89 45 9c	 mov	 DWORD PTR _hwndParent$23091[ebp], eax

; 1602 : 
; 1603 : 			GetClientRect(hwndParent, &parent);

  00ca6	8d 45 a0	 lea	 eax, DWORD PTR _parent$23089[ebp]
  00ca9	50		 push	 eax
  00caa	8b 4d 9c	 mov	 ecx, DWORD PTR _hwndParent$23091[ebp]
  00cad	51		 push	 ecx
  00cae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 1604 : 			MapWindowPoints(hwndParent, 0, (POINT *)&parent, 2);

  00cb4	6a 02		 push	 2
  00cb6	8d 55 a0	 lea	 edx, DWORD PTR _parent$23089[ebp]
  00cb9	52		 push	 edx
  00cba	6a 00		 push	 0
  00cbc	8b 45 9c	 mov	 eax, DWORD PTR _hwndParent$23091[ebp]
  00cbf	50		 push	 eax
  00cc0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapWindowPoints@16

; 1605 : 
; 1606 : 			CopyRect(&rect2, &rect);

  00cc6	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  00cc9	51		 push	 ecx
  00cca	8d 55 8c	 lea	 edx, DWORD PTR _rect2$23090[ebp]
  00ccd	52		 push	 edx
  00cce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyRect@8

; 1607 : 			OffsetRect(&rect2, winrect.left, winrect.top);

  00cd4	8b 45 e0	 mov	 eax, DWORD PTR _winrect$[ebp+4]
  00cd7	50		 push	 eax
  00cd8	8b 4d dc	 mov	 ecx, DWORD PTR _winrect$[ebp]
  00cdb	51		 push	 ecx
  00cdc	8d 55 8c	 lea	 edx, DWORD PTR _rect2$23090[ebp]
  00cdf	52		 push	 edx
  00ce0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 1608 : 
; 1609 : 			if(!sw->fLeftScrollbar && parent.right == rect2.right+sw->cxRightEdge && parent.bottom == rect2.bottom+sw->cyBottomEdge
; 1610 : 			 || sw->fLeftScrollbar && parent.left  == rect2.left -sw->cxLeftEdge  && parent.bottom == rect2.bottom+sw->cyBottomEdge)

  00ce6	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00ce9	83 b8 a4 06 00
	00 00		 cmp	 DWORD PTR [eax+1700], 0
  00cf0	75 22		 jne	 SHORT $L23095
  00cf2	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00cf5	8b 55 94	 mov	 edx, DWORD PTR _rect2$23090[ebp+8]
  00cf8	03 91 b0 06 00
	00		 add	 edx, DWORD PTR [ecx+1712]
  00cfe	39 55 a8	 cmp	 DWORD PTR _parent$23089[ebp+8], edx
  00d01	75 11		 jne	 SHORT $L23095
  00d03	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00d06	8b 4d 98	 mov	 ecx, DWORD PTR _rect2$23090[ebp+12]
  00d09	03 88 b8 06 00
	00		 add	 ecx, DWORD PTR [eax+1720]
  00d0f	39 4d ac	 cmp	 DWORD PTR _parent$23089[ebp+12], ecx
  00d12	74 2e		 je	 SHORT $L23094
$L23095:
  00d14	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00d17	83 ba a4 06 00
	00 00		 cmp	 DWORD PTR [edx+1700], 0
  00d1e	74 4b		 je	 SHORT $L23093
  00d20	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00d23	8b 4d 8c	 mov	 ecx, DWORD PTR _rect2$23090[ebp]
  00d26	2b 88 ac 06 00
	00		 sub	 ecx, DWORD PTR [eax+1708]
  00d2c	39 4d a0	 cmp	 DWORD PTR _parent$23089[ebp], ecx
  00d2f	75 3a		 jne	 SHORT $L23093
  00d31	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00d34	8b 45 98	 mov	 eax, DWORD PTR _rect2$23090[ebp+12]
  00d37	03 82 b8 06 00
	00		 add	 eax, DWORD PTR [edx+1720]
  00d3d	39 45 ac	 cmp	 DWORD PTR _parent$23089[ebp+12], eax
  00d40	75 29		 jne	 SHORT $L23093
$L23094:

; 1611 : 				DrawFrameControl(hdc, &rect, DFC_SCROLL, sw->fLeftScrollbar ? DFCS_SCROLLSIZEGRIPRIGHT : DFCS_SCROLLSIZEGRIP );

  00d42	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00d45	33 d2		 xor	 edx, edx
  00d47	83 b9 a4 06 00
	00 00		 cmp	 DWORD PTR [ecx+1700], 0
  00d4e	0f 95 c2	 setne	 dl
  00d51	8d 14 d5 08 00
	00 00		 lea	 edx, DWORD PTR [edx*8+8]
  00d58	52		 push	 edx
  00d59	6a 03		 push	 3
  00d5b	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  00d5e	50		 push	 eax
  00d5f	8b 4d c0	 mov	 ecx, DWORD PTR _hdc$[ebp]
  00d62	51		 push	 ecx
  00d63	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16

; 1612 : 			else

  00d69	eb 19		 jmp	 SHORT $L23084
$L23093:

; 1613 : 				PaintRect(hdc, &rect, GetSysColor(COLOR_3DFACE));

  00d6b	6a 0f		 push	 15			; 0000000fH
  00d6d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  00d73	50		 push	 eax
  00d74	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  00d77	52		 push	 edx
  00d78	8b 45 c0	 mov	 eax, DWORD PTR _hdc$[ebp]
  00d7b	50		 push	 eax
  00d7c	e8 00 00 00 00	 call	 _PaintRect
  00d81	83 c4 0c	 add	 esp, 12			; 0000000cH
$L23084:

; 1614 : 		}
; 1615 : 	}
; 1616 : 
; 1617 : 	UNREFERENCED_PARAMETER(clip);
; 1618 : 
; 1619 : 	ReleaseDC(hwnd, hdc);

  00d84	8b 4d c0	 mov	 ecx, DWORD PTR _hdc$[ebp]
  00d87	51		 push	 ecx
  00d88	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00d8b	52		 push	 edx
  00d8c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 1620 : 	return ret;

  00d92	8b 45 c8	 mov	 eax, DWORD PTR _ret$[ebp]

; 1621 : }

  00d95	8b e5		 mov	 esp, ebp
  00d97	5d		 pop	 ebp
  00d98	c3		 ret	 0
_NCPaint ENDP
_TEXT	ENDS
EXTRN	__imp__ExtTextOutA@32:NEAR
EXTRN	__imp__SetBkColor@8:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_oldcol$ = -4						; size = 4
_hdc$ = 8						; size = 4
_rect$ = 12						; size = 4
_color$ = 16						; size = 4
_PaintRect PROC NEAR

; 374  : {

  00da0	55		 push	 ebp
  00da1	8b ec		 mov	 ebp, esp
  00da3	51		 push	 ecx

; 375  : 	COLORREF oldcol = SetBkColor(hdc, color);

  00da4	8b 45 10	 mov	 eax, DWORD PTR _color$[ebp]
  00da7	50		 push	 eax
  00da8	8b 4d 08	 mov	 ecx, DWORD PTR _hdc$[ebp]
  00dab	51		 push	 ecx
  00dac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  00db2	89 45 fc	 mov	 DWORD PTR _oldcol$[ebp], eax

; 376  : 	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, rect, _T(""), 0, 0);

  00db5	6a 00		 push	 0
  00db7	6a 00		 push	 0
  00db9	68 00 00 00 00	 push	 OFFSET FLAT:$SG22590
  00dbe	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  00dc1	52		 push	 edx
  00dc2	6a 02		 push	 2
  00dc4	6a 00		 push	 0
  00dc6	6a 00		 push	 0
  00dc8	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  00dcb	50		 push	 eax
  00dcc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExtTextOutA@32

; 377  : 	SetBkColor(hdc, oldcol);

  00dd2	8b 4d fc	 mov	 ecx, DWORD PTR _oldcol$[ebp]
  00dd5	51		 push	 ecx
  00dd6	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  00dd9	52		 push	 edx
  00dda	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 378  : }

  00de0	8b e5		 mov	 esp, ebp
  00de2	5d		 pop	 ebp
  00de3	c3		 ret	 0
_PaintRect ENDP
; Function compile flags: /Odt
_nPixels$ = -12					; size = 4
_i$ = -8						; size = 4
_sbut$ = -4						; size = 4
_sbar$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_uBeforeAfter$ = 16					; size = 4
_GetButtonSize PROC NEAR

; 509  : {

  00df0	55		 push	 ebp
  00df1	8b ec		 mov	 ebp, esp
  00df3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 510  : 	int i;
; 511  : 	int nPixels = 0;

  00df6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nPixels$[ebp], 0

; 512  : 
; 513  : 	SCROLLBUT *sbut = sbar->sbButtons;

  00dfd	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  00e00	83 c0 2c	 add	 eax, 44			; 0000002cH
  00e03	89 45 fc	 mov	 DWORD PTR _sbut$[ebp], eax

; 514  : 	
; 515  : 	for(i = 0; i < sbar->nButtons; i++)

  00e06	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00e0d	eb 09		 jmp	 SHORT $L22673
$L22674:
  00e0f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00e12	83 c1 01	 add	 ecx, 1
  00e15	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L22673:
  00e18	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  00e1b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00e1e	3b 82 2c 03 00
	00		 cmp	 eax, DWORD PTR [edx+812]
  00e24	7d 30		 jge	 SHORT $L22675

; 516  : 	{
; 517  : 		//only consider those buttons on the same side as nTopBottom says
; 518  : 		if(sbut[i].uPlacement == uBeforeAfter)

  00e26	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00e29	6b c9 30	 imul	 ecx, 48			; 00000030H
  00e2c	8b 55 fc	 mov	 edx, DWORD PTR _sbut$[ebp]
  00e2f	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  00e33	3b 45 10	 cmp	 eax, DWORD PTR _uBeforeAfter$[ebp]
  00e36	75 1c		 jne	 SHORT $L22676

; 519  : 		{
; 520  : 			nPixels += GetSingleButSize(sbar, &sbut[i]);

  00e38	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00e3b	6b c9 30	 imul	 ecx, 48			; 00000030H
  00e3e	03 4d fc	 add	 ecx, DWORD PTR _sbut$[ebp]
  00e41	51		 push	 ecx
  00e42	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  00e45	52		 push	 edx
  00e46	e8 00 00 00 00	 call	 _GetSingleButSize
  00e4b	83 c4 08	 add	 esp, 8
  00e4e	03 45 f4	 add	 eax, DWORD PTR _nPixels$[ebp]
  00e51	89 45 f4	 mov	 DWORD PTR _nPixels$[ebp], eax
$L22676:

; 521  : 		}
; 522  : 	}

  00e54	eb b9		 jmp	 SHORT $L22674
$L22675:

; 523  : 
; 524  : 	return nPixels;

  00e56	8b 45 f4	 mov	 eax, DWORD PTR _nPixels$[ebp]

; 525  : }

  00e59	8b e5		 mov	 esp, ebp
  00e5b	5d		 pop	 ebp
  00e5c	c3		 ret	 0
_GetButtonSize ENDP
; Function compile flags: /Odt
_sbar$ = 8						; size = 4
_sbut$ = 12						; size = 4
_GetSingleButSize PROC NEAR

; 490  : {

  00e60	55		 push	 ebp
  00e61	8b ec		 mov	 ebp, esp
  00e63	56		 push	 esi

; 491  : 	//multiple of the system button size
; 492  : 	//or a specific button size
; 493  : 	if(sbut->nSize < 0)

  00e64	8b 45 0c	 mov	 eax, DWORD PTR _sbut$[ebp]
  00e67	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00e6b	7d 36		 jge	 SHORT $L22658

; 494  : 	{
; 495  : 		if(sbar->nBarType == SB_HORZ)

  00e6d	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  00e70	83 b9 40 03 00
	00 00		 cmp	 DWORD PTR [ecx+832], 0
  00e77	75 15		 jne	 SHORT $L22659

; 496  : 			return -sbut->nSize * GetSystemMetrics(SM_CXHSCROLL);

  00e79	8b 55 0c	 mov	 edx, DWORD PTR _sbut$[ebp]
  00e7c	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  00e7f	f7 de		 neg	 esi
  00e81	6a 15		 push	 21			; 00000015H
  00e83	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00e89	0f af c6	 imul	 eax, esi
  00e8c	eb 1b		 jmp	 SHORT $L22657
$L22659:

; 497  : 		else 
; 498  : 			return -sbut->nSize * GetSystemMetrics(SM_CYVSCROLL);

  00e8e	8b 45 0c	 mov	 eax, DWORD PTR _sbut$[ebp]
  00e91	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00e94	f7 de		 neg	 esi
  00e96	6a 14		 push	 20			; 00000014H
  00e98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00e9e	0f af c6	 imul	 eax, esi
  00ea1	eb 06		 jmp	 SHORT $L22657
$L22658:

; 499  : 	}
; 500  : 	else
; 501  : 		return  sbut->nSize;

  00ea3	8b 4d 0c	 mov	 ecx, DWORD PTR _sbut$[ebp]
  00ea6	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
$L22657:

; 502  : }

  00ea9	5e		 pop	 esi
  00eaa	5d		 pop	 ebp
  00eab	c3		 ret	 0
_GetSingleButSize ENDP
_TEXT	ENDS
EXTRN	__imp__SendMessageA@16:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_nmcd$ = -48						; size = 48
_hwnd$ = 8						; size = 4
_hdc$ = 12						; size = 4
_nBar$ = 16						; size = 4
_prect$ = 20						; size = 4
_nItem$ = 24						; size = 4
_fMouseDown$ = 28					; size = 4
_fMouseOver$ = 32					; size = 4
_fInactive$ = 36					; size = 4
_PostCustomDrawNotify0 PROC NEAR

; 706  : {

  00eb0	55		 push	 ebp
  00eb1	8b ec		 mov	 ebp, esp
  00eb3	83 ec 30	 sub	 esp, 48			; 00000030H

; 707  : #ifdef CUSTOM_DRAW
; 708  : 	NMCSBCUSTOMDRAW	nmcd;
; 709  : 
; 710  : 	//fill in the standard header
; 711  : 	nmcd.hdr.hwndFrom = hwnd;

  00eb6	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00eb9	89 45 d0	 mov	 DWORD PTR _nmcd$[ebp], eax

; 712  : 	nmcd.hdr.idFrom   = GetWindowLong(hwnd, GWL_ID);

  00ebc	6a f4		 push	 -12			; fffffff4H
  00ebe	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00ec1	51		 push	 ecx
  00ec2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  00ec8	89 45 d4	 mov	 DWORD PTR _nmcd$[ebp+4], eax

; 713  : 	nmcd.hdr.code     = NM_COOLSB_CUSTOMDRAW;

  00ecb	c7 45 d8 01 f0
	ff ff		 mov	 DWORD PTR _nmcd$[ebp+8], -4095 ; fffff001H

; 714  : 
; 715  : 	nmcd.dwDrawStage  = CDDS_ITEMPREPAINT;

  00ed2	c7 45 dc 01 00
	01 00		 mov	 DWORD PTR _nmcd$[ebp+12], 65537 ; 00010001H

; 716  : 	nmcd.nBar		  = nBar;

  00ed9	8b 55 10	 mov	 edx, DWORD PTR _nBar$[ebp]
  00edc	89 55 fc	 mov	 DWORD PTR _nmcd$[ebp+44], edx

; 717  : 	nmcd.rect		  = *prect;

  00edf	8b 45 14	 mov	 eax, DWORD PTR _prect$[ebp]
  00ee2	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ee4	89 4d e4	 mov	 DWORD PTR _nmcd$[ebp+20], ecx
  00ee7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00eea	89 55 e8	 mov	 DWORD PTR _nmcd$[ebp+24], edx
  00eed	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00ef0	89 4d ec	 mov	 DWORD PTR _nmcd$[ebp+28], ecx
  00ef3	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00ef6	89 55 f0	 mov	 DWORD PTR _nmcd$[ebp+32], edx

; 718  : 	nmcd.uItem		  = nItem;

  00ef9	8b 45 18	 mov	 eax, DWORD PTR _nItem$[ebp]
  00efc	89 45 f4	 mov	 DWORD PTR _nmcd$[ebp+36], eax

; 719  : 	nmcd.hdc		  = hdc;

  00eff	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  00f02	89 4d e0	 mov	 DWORD PTR _nmcd$[ebp+16], ecx

; 720  : 
; 721  : 	if(fMouseDown) 

  00f05	83 7d 1c 00	 cmp	 DWORD PTR _fMouseDown$[ebp], 0
  00f09	74 09		 je	 SHORT $L22781

; 722  : 		nmcd.uState		  = CDIS_SELECTED;

  00f0b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _nmcd$[ebp+40], 1

; 723  : 	else if(fMouseOver)

  00f12	eb 25		 jmp	 SHORT $L22782
$L22781:
  00f14	83 7d 20 00	 cmp	 DWORD PTR _fMouseOver$[ebp], 0
  00f18	74 09		 je	 SHORT $L22783

; 724  : 		nmcd.uState		  = CDIS_HOT;

  00f1a	c7 45 f8 40 00
	00 00		 mov	 DWORD PTR _nmcd$[ebp+40], 64 ; 00000040H

; 725  : 	else if(fInactive)

  00f21	eb 16		 jmp	 SHORT $L22782
$L22783:
  00f23	83 7d 24 00	 cmp	 DWORD PTR _fInactive$[ebp], 0
  00f27	74 09		 je	 SHORT $L22785

; 726  : 		nmcd.uState		  = CDIS_DISABLED;

  00f29	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _nmcd$[ebp+40], 4

; 727  : 	else

  00f30	eb 07		 jmp	 SHORT $L22782
$L22785:

; 728  : 		nmcd.uState		  = CDIS_DEFAULT;

  00f32	c7 45 f8 20 00
	00 00		 mov	 DWORD PTR _nmcd$[ebp+40], 32 ; 00000020H
$L22782:

; 729  : 
; 730  : 	hwnd = GetParent(hwnd);

  00f39	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00f3c	52		 push	 edx
  00f3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00f43	89 45 08	 mov	 DWORD PTR _hwnd$[ebp], eax

; 731  : 	return SendMessage(hwnd, WM_NOTIFY, nmcd.hdr.idFrom, (LPARAM)&nmcd);

  00f46	8d 45 d0	 lea	 eax, DWORD PTR _nmcd$[ebp]
  00f49	50		 push	 eax
  00f4a	8b 4d d4	 mov	 ecx, DWORD PTR _nmcd$[ebp+4]
  00f4d	51		 push	 ecx
  00f4e	6a 4e		 push	 78			; 0000004eH
  00f50	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00f53	52		 push	 edx
  00f54	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 732  : #else
; 733  : 	return 0;
; 734  : #endif
; 735  : }

  00f5a	8b e5		 mov	 esp, ebp
  00f5c	5d		 pop	 ebp
  00f5d	c3		 ret	 0
_PostCustomDrawNotify0 ENDP
_TEXT	ENDS
EXTRN	__imp__SetRect@20:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv315 = -160						; size = 4
tv157 = -156						; size = 4
tv153 = -152						; size = 4
tv149 = -148						; size = 4
_rdis$22848 = -144					; size = 4
_ldis$22847 = -140					; size = 4
_fMouseOverR$ = -136					; size = 4
_uLeftButFlags$ = -132					; size = 4
_si$ = -128						; size = 4
_crInverse2$ = -124					; size = 4
_ret$ = -120						; size = 4
_thumb$ = -116						; size = 16
_fMouseDownR$ = -100					; size = 4
_crCheck2$ = -96					; size = 4
_ctrl$ = -92						; size = 16
_siMaxMin$ = -76					; size = 4
_crInverse1$ = -72					; size = 4
_uDEFlat$ = -68						; size = 4
_thumbpos$ = -64					; size = 4
_uDFCFlat$ = -60					; size = 4
_scrollwidth$ = -56					; size = 4
_thumbwidth$ = -52					; size = 4
_crCheck1$ = -48					; size = 4
_sbm$ = -44						; size = 16
_fCustomDraw$ = -28					; size = 4
_uRightButFlags$ = -24					; size = 4
_workingwidth$ = -20					; size = 4
_fMouseDownL$ = -16					; size = 4
_fBarHot$ = -12						; size = 4
_butwidth$ = -8						; size = 4
_fMouseOverL$ = -4					; size = 4
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_hdc$ = 16						; size = 4
_rect$ = 20						; size = 4
_uDrawFlags$ = 24					; size = 4
_NCDrawHScrollbar PROC NEAR

; 790  : {

  00f60	55		 push	 ebp
  00f61	8b ec		 mov	 ebp, esp
  00f63	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H

; 791  : 	SCROLLINFO *si;
; 792  : 	RECT ctrl, thumb;
; 793  : 	RECT sbm;
; 794  : 	int butwidth	 = GetScrollMetric(sb, SM_SCROLL_LENGTH);

  00f69	6a 00		 push	 0
  00f6b	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  00f6e	50		 push	 eax
  00f6f	e8 00 00 00 00	 call	 _GetScrollMetric
  00f74	83 c4 08	 add	 esp, 8
  00f77	89 45 f8	 mov	 DWORD PTR _butwidth$[ebp], eax

; 795  : 	int scrollwidth  = rect->right-rect->left;

  00f7a	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  00f7d	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  00f80	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00f83	2b 02		 sub	 eax, DWORD PTR [edx]
  00f85	89 45 c8	 mov	 DWORD PTR _scrollwidth$[ebp], eax

; 796  : 	int workingwidth = scrollwidth - butwidth*2;

  00f88	8b 4d f8	 mov	 ecx, DWORD PTR _butwidth$[ebp]
  00f8b	d1 e1		 shl	 ecx, 1
  00f8d	8b 55 c8	 mov	 edx, DWORD PTR _scrollwidth$[ebp]
  00f90	2b d1		 sub	 edx, ecx
  00f92	89 55 ec	 mov	 DWORD PTR _workingwidth$[ebp], edx

; 797  : 	int thumbwidth   = 0, thumbpos = 0;

  00f95	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _thumbwidth$[ebp], 0
  00f9c	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _thumbpos$[ebp], 0

; 798  : 	int siMaxMin;
; 799  : 
; 800  : 	LRESULT  ret = 0;

  00fa3	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 801  : 	BOOL fCustomDraw = 0;

  00faa	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _fCustomDraw$[ebp], 0

; 802  : 
; 803  : 	BOOL fMouseDownL = 0, fMouseOverL = 0, fBarHot = 0;

  00fb1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _fMouseDownL$[ebp], 0
  00fb8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fMouseOverL$[ebp], 0
  00fbf	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fBarHot$[ebp], 0

; 804  : 	BOOL fMouseDownR = 0, fMouseOverR = 0;

  00fc6	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _fMouseDownR$[ebp], 0
  00fcd	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _fMouseOverR$[ebp], 0

; 805  : 
; 806  : 	COLORREF crCheck1   = GetSBForeColor();

  00fd7	e8 00 00 00 00	 call	 _GetSBForeColor
  00fdc	89 45 d0	 mov	 DWORD PTR _crCheck1$[ebp], eax

; 807  : 	COLORREF crCheck2   = GetSBBackColor();

  00fdf	e8 00 00 00 00	 call	 _GetSBBackColor
  00fe4	89 45 a0	 mov	 DWORD PTR _crCheck2$[ebp], eax

; 808  : 	COLORREF crInverse1 = InvertCOLORREF(crCheck1);

  00fe7	8b 45 d0	 mov	 eax, DWORD PTR _crCheck1$[ebp]
  00fea	f7 d0		 not	 eax
  00fec	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00ff1	89 45 b8	 mov	 DWORD PTR _crInverse1$[ebp], eax

; 809  : 	COLORREF crInverse2 = InvertCOLORREF(crCheck2);

  00ff4	8b 4d a0	 mov	 ecx, DWORD PTR _crCheck2$[ebp]
  00ff7	f7 d1		 not	 ecx
  00ff9	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00fff	89 4d 84	 mov	 DWORD PTR _crInverse2$[ebp], ecx

; 810  : 
; 811  : 	UINT uDFCFlat = sb->fFlatScrollbar ? DFCS_FLAT : 0;

  01002	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01005	8b 82 44 03 00
	00		 mov	 eax, DWORD PTR [edx+836]
  0100b	f7 d8		 neg	 eax
  0100d	1b c0		 sbb	 eax, eax
  0100f	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  01014	89 45 c4	 mov	 DWORD PTR _uDFCFlat$[ebp], eax

; 812  : 	UINT uDEFlat  = sb->fFlatScrollbar ? BF_FLAT   : 0;

  01017	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  0101a	8b 91 44 03 00
	00		 mov	 edx, DWORD PTR [ecx+836]
  01020	f7 da		 neg	 edx
  01022	1b d2		 sbb	 edx, edx
  01024	81 e2 00 40 00
	00		 and	 edx, 16384		; 00004000H
  0102a	89 55 bc	 mov	 DWORD PTR _uDEFlat$[ebp], edx

; 813  : 
; 814  : 	//drawing flags to modify the appearance of the scrollbar buttons
; 815  : 	UINT uLeftButFlags  = DFCS_SCROLLLEFT;

  0102d	c7 85 7c ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _uLeftButFlags$[ebp], 2

; 816  : 	UINT uRightButFlags = DFCS_SCROLLRIGHT;

  01037	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR _uRightButFlags$[ebp], 3

; 817  : 
; 818  : 	if(scrollwidth <= 0)

  0103e	83 7d c8 00	 cmp	 DWORD PTR _scrollwidth$[ebp], 0
  01042	7f 07		 jg	 SHORT $L22841

; 819  : 		return 0;

  01044	33 c0		 xor	 eax, eax
  01046	e9 30 09 00 00	 jmp	 $L22815
$L22841:

; 820  : 
; 821  : 	si = &sb->scrollInfo;

  0104b	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0104e	83 c0 08	 add	 eax, 8
  01051	89 45 80	 mov	 DWORD PTR _si$[ebp], eax

; 822  : 	siMaxMin = si->nMax - si->nMin;

  01054	8b 4d 80	 mov	 ecx, DWORD PTR _si$[ebp]
  01057	8b 55 80	 mov	 edx, DWORD PTR _si$[ebp]
  0105a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0105d	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  01060	89 45 b4	 mov	 DWORD PTR _siMaxMin$[ebp], eax

; 823  : 
; 824  : 	if(hwnd != hwndCurCoolSB)

  01063	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  01066	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _hwndCurCoolSB
  0106c	74 07		 je	 SHORT $L22842

; 825  : 		uDrawFlags = HTSCROLL_NONE;

  0106e	c7 45 18 ff ff
	ff ff		 mov	 DWORD PTR _uDrawFlags$[ebp], -1
$L22842:

; 826  : 	//
; 827  : 	// work out the thumb size and position
; 828  : 	//
; 829  : 	CalcThumbSize(sb, rect, &thumbwidth, &thumbpos);

  01075	8d 55 c0	 lea	 edx, DWORD PTR _thumbpos$[ebp]
  01078	52		 push	 edx
  01079	8d 45 cc	 lea	 eax, DWORD PTR _thumbwidth$[ebp]
  0107c	50		 push	 eax
  0107d	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  01080	51		 push	 ecx
  01081	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01084	52		 push	 edx
  01085	e8 00 00 00 00	 call	 _CalcThumbSize
  0108a	83 c4 10	 add	 esp, 16			; 00000010H

; 830  : 	
; 831  : 	if(sb->fScrollFlags & ESB_DISABLE_LEFT)		uLeftButFlags  |= DFCS_INACTIVE;

  0108d	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01090	8b 08		 mov	 ecx, DWORD PTR [eax]
  01092	83 e1 01	 and	 ecx, 1
  01095	74 12		 je	 SHORT $L22843
  01097	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _uLeftButFlags$[ebp]
  0109d	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  010a3	89 95 7c ff ff
	ff		 mov	 DWORD PTR _uLeftButFlags$[ebp], edx
$L22843:

; 832  : 	if(sb->fScrollFlags & ESB_DISABLE_RIGHT)	uRightButFlags |= DFCS_INACTIVE;

  010a9	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  010ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  010ae	83 e1 02	 and	 ecx, 2
  010b1	74 0c		 je	 SHORT $L22844
  010b3	8b 55 e8	 mov	 edx, DWORD PTR _uRightButFlags$[ebp]
  010b6	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  010bc	89 55 e8	 mov	 DWORD PTR _uRightButFlags$[ebp], edx
$L22844:

; 833  : 
; 834  : 	//if we need to grey the arrows because there is no data to scroll
; 835  : 	if(!IsScrollInfoActive(si) && !(sb->fScrollFlags & CSBS_THUMBALWAYS))

  010bf	8b 45 80	 mov	 eax, DWORD PTR _si$[ebp]
  010c2	50		 push	 eax
  010c3	e8 00 00 00 00	 call	 _IsScrollInfoActive
  010c8	83 c4 04	 add	 esp, 4
  010cb	85 c0		 test	 eax, eax
  010cd	75 27		 jne	 SHORT $L22845
  010cf	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  010d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  010d4	83 e2 04	 and	 edx, 4
  010d7	75 1d		 jne	 SHORT $L22845

; 836  : 	{
; 837  : 		uLeftButFlags  |= DFCS_INACTIVE;

  010d9	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _uLeftButFlags$[ebp]
  010df	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  010e4	89 85 7c ff ff
	ff		 mov	 DWORD PTR _uLeftButFlags$[ebp], eax

; 838  : 		uRightButFlags |= DFCS_INACTIVE;

  010ea	8b 4d e8	 mov	 ecx, DWORD PTR _uRightButFlags$[ebp]
  010ed	81 c9 00 01 00
	00		 or	 ecx, 256		; 00000100H
  010f3	89 4d e8	 mov	 DWORD PTR _uRightButFlags$[ebp], ecx
$L22845:

; 839  : 	}
; 840  : 
; 841  : 	if(hwnd == hwndCurCoolSB)

  010f6	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  010f9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _hwndCurCoolSB
  010ff	0f 85 ef 00 00
	00		 jne	 $L22846

; 842  : 	{
; 843  : #ifdef FLAT_SCROLLBARS	
; 844  : 		BOOL ldis = !(uLeftButFlags & DFCS_INACTIVE);

  01105	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _uLeftButFlags$[ebp]
  0110b	25 00 01 00 00	 and	 eax, 256		; 00000100H
  01110	f7 d8		 neg	 eax
  01112	1b c0		 sbb	 eax, eax
  01114	40		 inc	 eax
  01115	89 85 74 ff ff
	ff		 mov	 DWORD PTR _ldis$22847[ebp], eax

; 845  : 		BOOL rdis = !(uRightButFlags & DFCS_INACTIVE);

  0111b	8b 4d e8	 mov	 ecx, DWORD PTR _uRightButFlags$[ebp]
  0111e	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  01124	f7 d9		 neg	 ecx
  01126	1b c9		 sbb	 ecx, ecx
  01128	41		 inc	 ecx
  01129	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _rdis$22848[ebp], ecx

; 846  : 
; 847  : 		fBarHot = (sb->nBarType == (int)uMouseOverScrollbar && sb->fFlatScrollbar == CSBS_HOTTRACKED);

  0112f	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01132	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  01138	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _uMouseOverScrollbar
  0113e	75 18		 jne	 SHORT $L23886
  01140	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01143	83 b9 44 03 00
	00 02		 cmp	 DWORD PTR [ecx+836], 2
  0114a	75 0c		 jne	 SHORT $L23886
  0114c	c7 85 6c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv149[ebp], 1
  01156	eb 0a		 jmp	 SHORT $L23887
$L23886:
  01158	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv149[ebp], 0
$L23887:
  01162	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR tv149[ebp]
  01168	89 55 f4	 mov	 DWORD PTR _fBarHot$[ebp], edx

; 848  : 		
; 849  : 		fMouseOverL = uHitTestPortion == HTSCROLL_LEFT && fBarHot && ldis;		

  0116b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uHitTestPortion, 0
  01172	75 1b		 jne	 SHORT $L23888
  01174	83 7d f4 00	 cmp	 DWORD PTR _fBarHot$[ebp], 0
  01178	74 15		 je	 SHORT $L23888
  0117a	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _ldis$22847[ebp], 0
  01181	74 0c		 je	 SHORT $L23888
  01183	c7 85 68 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv153[ebp], 1
  0118d	eb 0a		 jmp	 SHORT $L23889
$L23888:
  0118f	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$L23889:
  01199	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv153[ebp]
  0119f	89 45 fc	 mov	 DWORD PTR _fMouseOverL$[ebp], eax

; 850  : 		fMouseOverR = uHitTestPortion == HTSCROLL_RIGHT && fBarHot && rdis;

  011a2	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uHitTestPortion, 1
  011a9	75 1b		 jne	 SHORT $L23890
  011ab	83 7d f4 00	 cmp	 DWORD PTR _fBarHot$[ebp], 0
  011af	74 15		 je	 SHORT $L23890
  011b1	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _rdis$22848[ebp], 0
  011b8	74 0c		 je	 SHORT $L23890
  011ba	c7 85 64 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv157[ebp], 1
  011c4	eb 0a		 jmp	 SHORT $L23891
$L23890:
  011c6	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv157[ebp], 0
$L23891:
  011d0	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv157[ebp]
  011d6	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _fMouseOverR$[ebp], ecx

; 851  : #endif
; 852  : 		fMouseDownL = (uDrawFlags == HTSCROLL_LEFT);

  011dc	33 d2		 xor	 edx, edx
  011de	83 7d 18 00	 cmp	 DWORD PTR _uDrawFlags$[ebp], 0
  011e2	0f 94 c2	 sete	 dl
  011e5	89 55 f0	 mov	 DWORD PTR _fMouseDownL$[ebp], edx

; 853  : 		fMouseDownR = (uDrawFlags == HTSCROLL_RIGHT);

  011e8	33 c0		 xor	 eax, eax
  011ea	83 7d 18 01	 cmp	 DWORD PTR _uDrawFlags$[ebp], 1
  011ee	0f 94 c0	 sete	 al
  011f1	89 45 9c	 mov	 DWORD PTR _fMouseDownR$[ebp], eax
$L22846:

; 854  : 	}
; 855  : 
; 856  : 
; 857  : #ifdef CUSTOM_DRAW
; 858  : 	ret = PostCustomPrePostPaint(hwnd, hdc, sb, CDDS_PREPAINT);

  011f4	6a 01		 push	 1
  011f6	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  011f9	51		 push	 ecx
  011fa	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  011fd	52		 push	 edx
  011fe	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  01201	50		 push	 eax
  01202	e8 00 00 00 00	 call	 _PostCustomPrePostPaint0
  01207	83 c4 10	 add	 esp, 16			; 00000010H
  0120a	89 45 88	 mov	 DWORD PTR _ret$[ebp], eax

; 859  : 	fCustomDraw = (ret == CDRF_SKIPDEFAULT);

  0120d	33 c9		 xor	 ecx, ecx
  0120f	83 7d 88 04	 cmp	 DWORD PTR _ret$[ebp], 4
  01213	0f 94 c1	 sete	 cl
  01216	89 4d e4	 mov	 DWORD PTR _fCustomDraw$[ebp], ecx

; 860  : //fCustomDraw = TRUE;
; 861  : #endif
; 862  : 
; 863  : 	//
; 864  : 	// Draw the scrollbar now
; 865  : 	//
; 866  : 	if(scrollwidth > butwidth*2)

  01219	8b 55 f8	 mov	 edx, DWORD PTR _butwidth$[ebp]
  0121c	d1 e2		 shl	 edx, 1
  0121e	39 55 c8	 cmp	 DWORD PTR _scrollwidth$[ebp], edx
  01221	0f 8e 84 05 00
	00		 jle	 $L22850

; 867  : 	{
; 868  : 		//LEFT ARROW
; 869  : 		SetRect(&ctrl, rect->left, rect->top, rect->left + butwidth, rect->bottom);

  01227	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  0122a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0122d	51		 push	 ecx
  0122e	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  01231	8b 02		 mov	 eax, DWORD PTR [edx]
  01233	03 45 f8	 add	 eax, DWORD PTR _butwidth$[ebp]
  01236	50		 push	 eax
  01237	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  0123a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0123d	52		 push	 edx
  0123e	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01241	8b 08		 mov	 ecx, DWORD PTR [eax]
  01243	51		 push	 ecx
  01244	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01247	52		 push	 edx
  01248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 870  : 
; 871  : 		RotateRect0(sb, &ctrl);

  0124e	8d 45 a4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01251	50		 push	 eax
  01252	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01255	51		 push	 ecx
  01256	e8 00 00 00 00	 call	 _RotateRect0@8

; 872  : 
; 873  : 		if(fCustomDraw)

  0125b	83 7d e4 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  0125f	74 37		 je	 SHORT $L22851

; 874  : 			PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_LINELEFT, fMouseDownL, fMouseOverL, uLeftButFlags & DFCS_INACTIVE);

  01261	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _uLeftButFlags$[ebp]
  01267	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  0126d	52		 push	 edx
  0126e	8b 45 fc	 mov	 eax, DWORD PTR _fMouseOverL$[ebp]
  01271	50		 push	 eax
  01272	8b 4d f0	 mov	 ecx, DWORD PTR _fMouseDownL$[ebp]
  01275	51		 push	 ecx
  01276	6a 00		 push	 0
  01278	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  0127b	52		 push	 edx
  0127c	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0127f	8b 88 40 03 00
	00		 mov	 ecx, DWORD PTR [eax+832]
  01285	51		 push	 ecx
  01286	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  01289	52		 push	 edx
  0128a	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0128d	50		 push	 eax
  0128e	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01293	83 c4 20	 add	 esp, 32			; 00000020H

; 875  : 		else

  01296	eb 23		 jmp	 SHORT $L22852
$L22851:

; 876  : 			DrawScrollArrow(sb, hdc, &ctrl, uLeftButFlags, fMouseDownL, fMouseOverL);

  01298	8b 4d fc	 mov	 ecx, DWORD PTR _fMouseOverL$[ebp]
  0129b	51		 push	 ecx
  0129c	8b 55 f0	 mov	 edx, DWORD PTR _fMouseDownL$[ebp]
  0129f	52		 push	 edx
  012a0	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _uLeftButFlags$[ebp]
  012a6	50		 push	 eax
  012a7	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  012aa	51		 push	 ecx
  012ab	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  012ae	52		 push	 edx
  012af	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  012b2	50		 push	 eax
  012b3	e8 00 00 00 00	 call	 _DrawScrollArrow
  012b8	83 c4 18	 add	 esp, 24			; 00000018H
$L22852:

; 877  : 
; 878  : 		RotateRect0(sb, &ctrl);

  012bb	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  012be	51		 push	 ecx
  012bf	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  012c2	52		 push	 edx
  012c3	e8 00 00 00 00	 call	 _RotateRect0@8

; 879  : 
; 880  : 		//MIDDLE PORTION
; 881  : 		//if we can fit the thumbbar in, then draw it
; 882  : 		if(thumbwidth > 0 && thumbwidth <= workingwidth
; 883  : 			&& IsScrollInfoActive(si) && ((sb->fScrollFlags & ESB_DISABLE_BOTH) != ESB_DISABLE_BOTH))

  012c8	83 7d cc 00	 cmp	 DWORD PTR _thumbwidth$[ebp], 0
  012cc	0f 8e 78 02 00
	00		 jle	 $L22853
  012d2	8b 45 cc	 mov	 eax, DWORD PTR _thumbwidth$[ebp]
  012d5	3b 45 ec	 cmp	 eax, DWORD PTR _workingwidth$[ebp]
  012d8	0f 8f 6c 02 00
	00		 jg	 $L22853
  012de	8b 4d 80	 mov	 ecx, DWORD PTR _si$[ebp]
  012e1	51		 push	 ecx
  012e2	e8 00 00 00 00	 call	 _IsScrollInfoActive
  012e7	83 c4 04	 add	 esp, 4
  012ea	85 c0		 test	 eax, eax
  012ec	0f 84 58 02 00
	00		 je	 $L22853
  012f2	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  012f5	8b 02		 mov	 eax, DWORD PTR [edx]
  012f7	83 e0 03	 and	 eax, 3
  012fa	83 f8 03	 cmp	 eax, 3
  012fd	0f 84 47 02 00
	00		 je	 $L22853

; 884  : 		{	
; 885  : 			//Draw the scrollbar margin above the thumb
; 886  : 			SetRect(&sbm, rect->left + butwidth, rect->top, thumbpos, rect->bottom);

  01303	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  01306	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01309	52		 push	 edx
  0130a	8b 45 c0	 mov	 eax, DWORD PTR _thumbpos$[ebp]
  0130d	50		 push	 eax
  0130e	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  01311	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01314	52		 push	 edx
  01315	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01318	8b 08		 mov	 ecx, DWORD PTR [eax]
  0131a	03 4d f8	 add	 ecx, DWORD PTR _butwidth$[ebp]
  0131d	51		 push	 ecx
  0131e	8d 55 d4	 lea	 edx, DWORD PTR _sbm$[ebp]
  01321	52		 push	 edx
  01322	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 887  : 			
; 888  : 			RotateRect0(sb, &sbm);

  01328	8d 45 d4	 lea	 eax, DWORD PTR _sbm$[ebp]
  0132b	50		 push	 eax
  0132c	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  0132f	51		 push	 ecx
  01330	e8 00 00 00 00	 call	 _RotateRect0@8

; 889  : 			
; 890  : 			if(fCustomDraw)

  01335	83 7d e4 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  01339	74 30		 je	 SHORT $L22854

; 891  : 			{
; 892  : 				PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &sbm, SB_PAGELEFT, uDrawFlags == HTSCROLL_PAGELEFT, FALSE, FALSE);

  0133b	6a 00		 push	 0
  0133d	6a 00		 push	 0
  0133f	33 d2		 xor	 edx, edx
  01341	83 7d 18 02	 cmp	 DWORD PTR _uDrawFlags$[ebp], 2
  01345	0f 94 c2	 sete	 dl
  01348	52		 push	 edx
  01349	6a 02		 push	 2
  0134b	8d 45 d4	 lea	 eax, DWORD PTR _sbm$[ebp]
  0134e	50		 push	 eax
  0134f	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01352	8b 91 40 03 00
	00		 mov	 edx, DWORD PTR [ecx+832]
  01358	52		 push	 edx
  01359	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  0135c	50		 push	 eax
  0135d	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  01360	51		 push	 ecx
  01361	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01366	83 c4 20	 add	 esp, 32			; 00000020H

; 893  : 			}
; 894  : 			else

  01369	eb 38		 jmp	 SHORT $L22855
$L22854:

; 895  : 			{
; 896  : 				if(uDrawFlags == HTSCROLL_PAGELEFT)

  0136b	83 7d 18 02	 cmp	 DWORD PTR _uDrawFlags$[ebp], 2
  0136f	75 1a		 jne	 SHORT $L22856

; 897  : 					DrawCheckedRect(hdc, &sbm, crInverse1, crInverse2);

  01371	8b 55 84	 mov	 edx, DWORD PTR _crInverse2$[ebp]
  01374	52		 push	 edx
  01375	8b 45 b8	 mov	 eax, DWORD PTR _crInverse1$[ebp]
  01378	50		 push	 eax
  01379	8d 4d d4	 lea	 ecx, DWORD PTR _sbm$[ebp]
  0137c	51		 push	 ecx
  0137d	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  01380	52		 push	 edx
  01381	e8 00 00 00 00	 call	 _DrawCheckedRect
  01386	83 c4 10	 add	 esp, 16			; 00000010H

; 898  : 				else

  01389	eb 18		 jmp	 SHORT $L22855
$L22856:

; 899  : 					DrawCheckedRect(hdc, &sbm, crCheck1, crCheck2);

  0138b	8b 45 a0	 mov	 eax, DWORD PTR _crCheck2$[ebp]
  0138e	50		 push	 eax
  0138f	8b 4d d0	 mov	 ecx, DWORD PTR _crCheck1$[ebp]
  01392	51		 push	 ecx
  01393	8d 55 d4	 lea	 edx, DWORD PTR _sbm$[ebp]
  01396	52		 push	 edx
  01397	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  0139a	50		 push	 eax
  0139b	e8 00 00 00 00	 call	 _DrawCheckedRect
  013a0	83 c4 10	 add	 esp, 16			; 00000010H
$L22855:

; 900  : 
; 901  : 			}
; 902  : 
; 903  : 			RotateRect0(sb, &sbm);			

  013a3	8d 4d d4	 lea	 ecx, DWORD PTR _sbm$[ebp]
  013a6	51		 push	 ecx
  013a7	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  013aa	52		 push	 edx
  013ab	e8 00 00 00 00	 call	 _RotateRect0@8

; 904  : 			
; 905  : 			//Draw the margin below the thumb
; 906  : 			sbm.left = thumbpos+thumbwidth;

  013b0	8b 45 c0	 mov	 eax, DWORD PTR _thumbpos$[ebp]
  013b3	03 45 cc	 add	 eax, DWORD PTR _thumbwidth$[ebp]
  013b6	89 45 d4	 mov	 DWORD PTR _sbm$[ebp], eax

; 907  : 			sbm.right = rect->right - butwidth;

  013b9	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  013bc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  013bf	2b 55 f8	 sub	 edx, DWORD PTR _butwidth$[ebp]
  013c2	89 55 dc	 mov	 DWORD PTR _sbm$[ebp+8], edx

; 908  : 			
; 909  : 			RotateRect0(sb, &sbm);

  013c5	8d 45 d4	 lea	 eax, DWORD PTR _sbm$[ebp]
  013c8	50		 push	 eax
  013c9	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  013cc	51		 push	 ecx
  013cd	e8 00 00 00 00	 call	 _RotateRect0@8

; 910  : 			if(fCustomDraw)

  013d2	83 7d e4 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  013d6	74 30		 je	 SHORT $L22858

; 911  : 			{
; 912  : 				PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &sbm, SB_PAGERIGHT, uDrawFlags == HTSCROLL_PAGERIGHT, 0, 0);

  013d8	6a 00		 push	 0
  013da	6a 00		 push	 0
  013dc	33 d2		 xor	 edx, edx
  013de	83 7d 18 03	 cmp	 DWORD PTR _uDrawFlags$[ebp], 3
  013e2	0f 94 c2	 sete	 dl
  013e5	52		 push	 edx
  013e6	6a 03		 push	 3
  013e8	8d 45 d4	 lea	 eax, DWORD PTR _sbm$[ebp]
  013eb	50		 push	 eax
  013ec	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  013ef	8b 91 40 03 00
	00		 mov	 edx, DWORD PTR [ecx+832]
  013f5	52		 push	 edx
  013f6	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  013f9	50		 push	 eax
  013fa	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  013fd	51		 push	 ecx
  013fe	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01403	83 c4 20	 add	 esp, 32			; 00000020H

; 913  : 			}
; 914  : 			else

  01406	eb 38		 jmp	 SHORT $L22859
$L22858:

; 915  : 			{
; 916  : 				if(uDrawFlags == HTSCROLL_PAGERIGHT)

  01408	83 7d 18 03	 cmp	 DWORD PTR _uDrawFlags$[ebp], 3
  0140c	75 1a		 jne	 SHORT $L22860

; 917  : 					DrawCheckedRect(hdc, &sbm, crInverse1, crInverse2);

  0140e	8b 55 84	 mov	 edx, DWORD PTR _crInverse2$[ebp]
  01411	52		 push	 edx
  01412	8b 45 b8	 mov	 eax, DWORD PTR _crInverse1$[ebp]
  01415	50		 push	 eax
  01416	8d 4d d4	 lea	 ecx, DWORD PTR _sbm$[ebp]
  01419	51		 push	 ecx
  0141a	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  0141d	52		 push	 edx
  0141e	e8 00 00 00 00	 call	 _DrawCheckedRect
  01423	83 c4 10	 add	 esp, 16			; 00000010H

; 918  : 				else

  01426	eb 18		 jmp	 SHORT $L22859
$L22860:

; 919  : 					DrawCheckedRect(hdc, &sbm, crCheck1, crCheck2);

  01428	8b 45 a0	 mov	 eax, DWORD PTR _crCheck2$[ebp]
  0142b	50		 push	 eax
  0142c	8b 4d d0	 mov	 ecx, DWORD PTR _crCheck1$[ebp]
  0142f	51		 push	 ecx
  01430	8d 55 d4	 lea	 edx, DWORD PTR _sbm$[ebp]
  01433	52		 push	 edx
  01434	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  01437	50		 push	 eax
  01438	e8 00 00 00 00	 call	 _DrawCheckedRect
  0143d	83 c4 10	 add	 esp, 16			; 00000010H
$L22859:

; 920  : 			
; 921  : 			}
; 922  : 			RotateRect0(sb, &sbm);

  01440	8d 4d d4	 lea	 ecx, DWORD PTR _sbm$[ebp]
  01443	51		 push	 ecx
  01444	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01447	52		 push	 edx
  01448	e8 00 00 00 00	 call	 _RotateRect0@8

; 923  : 			
; 924  : 			//Draw the THUMB finally
; 925  : 			SetRect(&thumb, thumbpos, rect->top, thumbpos+thumbwidth, rect->bottom);

  0144d	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01450	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01453	51		 push	 ecx
  01454	8b 55 c0	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  01457	03 55 cc	 add	 edx, DWORD PTR _thumbwidth$[ebp]
  0145a	52		 push	 edx
  0145b	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  0145e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01461	51		 push	 ecx
  01462	8b 55 c0	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  01465	52		 push	 edx
  01466	8d 45 8c	 lea	 eax, DWORD PTR _thumb$[ebp]
  01469	50		 push	 eax
  0146a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 926  : 
; 927  : 			RotateRect0(sb, &thumb);			

  01470	8d 4d 8c	 lea	 ecx, DWORD PTR _thumb$[ebp]
  01473	51		 push	 ecx
  01474	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01477	52		 push	 edx
  01478	e8 00 00 00 00	 call	 _RotateRect0@8

; 928  : 
; 929  : 			if(fCustomDraw)

  0147d	83 7d e4 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  01481	74 5a		 je	 SHORT $L22862

; 930  : 			{
; 931  : 				PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &thumb, SB_THUMBTRACK, uDrawFlags==HTSCROLL_THUMB, uHitTestPortion == HTSCROLL_THUMB && fBarHot, FALSE);

  01483	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _uHitTestPortion, 5
  0148a	75 12		 jne	 SHORT $L23892
  0148c	83 7d f4 00	 cmp	 DWORD PTR _fBarHot$[ebp], 0
  01490	74 0c		 je	 SHORT $L23892
  01492	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv315[ebp], 1
  0149c	eb 0a		 jmp	 SHORT $L23893
$L23892:
  0149e	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv315[ebp], 0
$L23893:
  014a8	6a 00		 push	 0
  014aa	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv315[ebp]
  014b0	50		 push	 eax
  014b1	33 c9		 xor	 ecx, ecx
  014b3	83 7d 18 05	 cmp	 DWORD PTR _uDrawFlags$[ebp], 5
  014b7	0f 94 c1	 sete	 cl
  014ba	51		 push	 ecx
  014bb	6a 05		 push	 5
  014bd	8d 55 8c	 lea	 edx, DWORD PTR _thumb$[ebp]
  014c0	52		 push	 edx
  014c1	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  014c4	8b 88 40 03 00
	00		 mov	 ecx, DWORD PTR [eax+832]
  014ca	51		 push	 ecx
  014cb	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  014ce	52		 push	 edx
  014cf	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  014d2	50		 push	 eax
  014d3	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  014d8	83 c4 20	 add	 esp, 32			; 00000020H

; 932  : 			}
; 933  : 			else

  014db	eb 5b		 jmp	 SHORT $L22863
$L22862:

; 934  : 			{
; 935  : 
; 936  : #ifdef FLAT_SCROLLBARS	
; 937  : 				if(hwnd == hwndCurCoolSB && sb->fFlatScrollbar && (uDrawFlags == HTSCROLL_THUMB || 
; 938  : 				(uHitTestPortion == HTSCROLL_THUMB && fBarHot)))

  014dd	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  014e0	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _hwndCurCoolSB
  014e6	75 3c		 jne	 SHORT $L22864
  014e8	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  014eb	83 ba 44 03 00
	00 00		 cmp	 DWORD PTR [edx+836], 0
  014f2	74 30		 je	 SHORT $L22864
  014f4	83 7d 18 05	 cmp	 DWORD PTR _uDrawFlags$[ebp], 5
  014f8	74 0f		 je	 SHORT $L22865
  014fa	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _uHitTestPortion, 5
  01501	75 21		 jne	 SHORT $L22864
  01503	83 7d f4 00	 cmp	 DWORD PTR _fBarHot$[ebp], 0
  01507	74 1b		 je	 SHORT $L22864
$L22865:

; 939  : 				{	
; 940  : 					PaintRect(hdc, &thumb, GetSysColor(COLOR_3DSHADOW));

  01509	6a 10		 push	 16			; 00000010H
  0150b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  01511	50		 push	 eax
  01512	8d 45 8c	 lea	 eax, DWORD PTR _thumb$[ebp]
  01515	50		 push	 eax
  01516	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01519	51		 push	 ecx
  0151a	e8 00 00 00 00	 call	 _PaintRect
  0151f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 941  : 				}
; 942  : 				else

  01522	eb 14		 jmp	 SHORT $L22863
$L22864:

; 943  : #endif
; 944  : 				{
; 945  : 					DrawBlankButton(hdc, &thumb, uDEFlat);

  01524	8b 55 bc	 mov	 edx, DWORD PTR _uDEFlat$[ebp]
  01527	52		 push	 edx
  01528	8d 45 8c	 lea	 eax, DWORD PTR _thumb$[ebp]
  0152b	50		 push	 eax
  0152c	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0152f	51		 push	 ecx
  01530	e8 00 00 00 00	 call	 _DrawBlankButton
  01535	83 c4 0c	 add	 esp, 12			; 0000000cH
$L22863:

; 946  : 				}
; 947  : 			}
; 948  : 			RotateRect0(sb, &thumb);

  01538	8d 55 8c	 lea	 edx, DWORD PTR _thumb$[ebp]
  0153b	52		 push	 edx
  0153c	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0153f	50		 push	 eax
  01540	e8 00 00 00 00	 call	 _RotateRect0@8

; 949  : 
; 950  : 		}
; 951  : 		//otherwise, just leave that whole area blank
; 952  : 		else

  01545	e9 b9 01 00 00	 jmp	 $L22867
$L22853:

; 953  : 		{
; 954  : 			OffsetRect(&ctrl, butwidth, 0);

  0154a	6a 00		 push	 0
  0154c	8b 4d f8	 mov	 ecx, DWORD PTR _butwidth$[ebp]
  0154f	51		 push	 ecx
  01550	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01553	52		 push	 edx
  01554	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 955  : 			ctrl.right = rect->right - butwidth;

  0155a	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  0155d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01560	2b 4d f8	 sub	 ecx, DWORD PTR _butwidth$[ebp]
  01563	89 4d ac	 mov	 DWORD PTR _ctrl$[ebp+8], ecx

; 956  : 
; 957  : 			//if we always show the thumb covering the whole scrollbar,
; 958  : 			//then draw it that way
; 959  : 			if(!IsScrollInfoActive(si)	&& (sb->fScrollFlags & CSBS_THUMBALWAYS) 
; 960  : 				&& ctrl.right - ctrl.left > sb->nMinThumbSize)

  01566	8b 55 80	 mov	 edx, DWORD PTR _si$[ebp]
  01569	52		 push	 edx
  0156a	e8 00 00 00 00	 call	 _IsScrollInfoActive
  0156f	83 c4 04	 add	 esp, 4
  01572	85 c0		 test	 eax, eax
  01574	0f 85 29 01 00
	00		 jne	 $L22868
  0157a	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0157d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0157f	83 e1 04	 and	 ecx, 4
  01582	0f 84 1b 01 00
	00		 je	 $L22868
  01588	8b 55 ac	 mov	 edx, DWORD PTR _ctrl$[ebp+8]
  0158b	2b 55 a4	 sub	 edx, DWORD PTR _ctrl$[ebp]
  0158e	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01591	3b 90 48 03 00
	00		 cmp	 edx, DWORD PTR [eax+840]
  01597	0f 8e 06 01 00
	00		 jle	 $L22868

; 961  : 			{
; 962  : 				//leave a 1-pixel gap between the thumb + right button
; 963  : 				ctrl.right --;

  0159d	8b 4d ac	 mov	 ecx, DWORD PTR _ctrl$[ebp+8]
  015a0	83 e9 01	 sub	 ecx, 1
  015a3	89 4d ac	 mov	 DWORD PTR _ctrl$[ebp+8], ecx

; 964  : 				RotateRect0(sb, &ctrl);

  015a6	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  015a9	52		 push	 edx
  015aa	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  015ad	50		 push	 eax
  015ae	e8 00 00 00 00	 call	 _RotateRect0@8

; 965  : 
; 966  : 				if(fCustomDraw)

  015b3	83 7d e4 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  015b7	74 2a		 je	 SHORT $L22869

; 967  : 					PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_THUMBTRACK, fMouseDownL, FALSE, FALSE);

  015b9	6a 00		 push	 0
  015bb	6a 00		 push	 0
  015bd	8b 4d f0	 mov	 ecx, DWORD PTR _fMouseDownL$[ebp]
  015c0	51		 push	 ecx
  015c1	6a 05		 push	 5
  015c3	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  015c6	52		 push	 edx
  015c7	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  015ca	8b 88 40 03 00
	00		 mov	 ecx, DWORD PTR [eax+832]
  015d0	51		 push	 ecx
  015d1	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  015d4	52		 push	 edx
  015d5	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  015d8	50		 push	 eax
  015d9	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  015de	83 c4 20	 add	 esp, 32			; 00000020H

; 968  : 				else

  015e1	eb 41		 jmp	 SHORT $L22870
$L22869:

; 969  : 				{
; 970  : #ifdef FLAT_SCROLLBARS	
; 971  : 					if(sb->fFlatScrollbar == CSBS_HOTTRACKED && uDrawFlags == HTSCROLL_THUMB)

  015e3	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  015e6	83 b9 44 03 00
	00 02		 cmp	 DWORD PTR [ecx+836], 2
  015ed	75 21		 jne	 SHORT $L22871
  015ef	83 7d 18 05	 cmp	 DWORD PTR _uDrawFlags$[ebp], 5
  015f3	75 1b		 jne	 SHORT $L22871

; 972  : 						PaintRect(hdc, &ctrl, GetSysColor(COLOR_3DSHADOW));

  015f5	6a 10		 push	 16			; 00000010H
  015f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  015fd	50		 push	 eax
  015fe	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01601	52		 push	 edx
  01602	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  01605	50		 push	 eax
  01606	e8 00 00 00 00	 call	 _PaintRect
  0160b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 973  : 					else

  0160e	eb 14		 jmp	 SHORT $L22870
$L22871:

; 974  : #endif
; 975  : 						DrawBlankButton(hdc, &ctrl, uDEFlat);

  01610	8b 4d bc	 mov	 ecx, DWORD PTR _uDEFlat$[ebp]
  01613	51		 push	 ecx
  01614	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01617	52		 push	 edx
  01618	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  0161b	50		 push	 eax
  0161c	e8 00 00 00 00	 call	 _DrawBlankButton
  01621	83 c4 0c	 add	 esp, 12			; 0000000cH
$L22870:

; 976  : 
; 977  : 				}
; 978  : 				RotateRect0(sb, &ctrl);

  01624	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01627	51		 push	 ecx
  01628	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  0162b	52		 push	 edx
  0162c	e8 00 00 00 00	 call	 _RotateRect0@8

; 979  : 
; 980  : 				//draw the single-line gap
; 981  : 				ctrl.left = ctrl.right;

  01631	8b 45 ac	 mov	 eax, DWORD PTR _ctrl$[ebp+8]
  01634	89 45 a4	 mov	 DWORD PTR _ctrl$[ebp], eax

; 982  : 				ctrl.right += 1;

  01637	8b 4d ac	 mov	 ecx, DWORD PTR _ctrl$[ebp+8]
  0163a	83 c1 01	 add	 ecx, 1
  0163d	89 4d ac	 mov	 DWORD PTR _ctrl$[ebp+8], ecx

; 983  : 				
; 984  : 				RotateRect0(sb, &ctrl);

  01640	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01643	52		 push	 edx
  01644	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01647	50		 push	 eax
  01648	e8 00 00 00 00	 call	 _RotateRect0@8

; 985  : 				
; 986  : 				if(fCustomDraw)

  0164d	83 7d e4 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  01651	74 28		 je	 SHORT $L22873

; 987  : 					PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_PAGERIGHT, 0, 0, 0);

  01653	6a 00		 push	 0
  01655	6a 00		 push	 0
  01657	6a 00		 push	 0
  01659	6a 03		 push	 3
  0165b	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  0165e	51		 push	 ecx
  0165f	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01662	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  01668	50		 push	 eax
  01669	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0166c	51		 push	 ecx
  0166d	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  01670	52		 push	 edx
  01671	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01676	83 c4 20	 add	 esp, 32			; 00000020H

; 988  : 				else

  01679	eb 19		 jmp	 SHORT $L22874
$L22873:

; 989  : 					PaintRect(hdc, &ctrl, GetSysColor(COLOR_SCROLLBAR));

  0167b	6a 00		 push	 0
  0167d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  01683	50		 push	 eax
  01684	8d 45 a4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01687	50		 push	 eax
  01688	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0168b	51		 push	 ecx
  0168c	e8 00 00 00 00	 call	 _PaintRect
  01691	83 c4 0c	 add	 esp, 12			; 0000000cH
$L22874:

; 990  : 
; 991  : 				RotateRect0(sb, &ctrl);

  01694	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01697	52		 push	 edx
  01698	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0169b	50		 push	 eax
  0169c	e8 00 00 00 00	 call	 _RotateRect0@8

; 992  : 			}
; 993  : 			//otherwise, paint a blank if the thumb doesn't fit in
; 994  : 			else

  016a1	eb 60		 jmp	 SHORT $L22867
$L22868:

; 995  : 			{
; 996  : 				RotateRect0(sb, &ctrl);

  016a3	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  016a6	51		 push	 ecx
  016a7	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  016aa	52		 push	 edx
  016ab	e8 00 00 00 00	 call	 _RotateRect0@8

; 997  : 	
; 998  : 				if(fCustomDraw)

  016b0	83 7d e4 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  016b4	74 28		 je	 SHORT $L22876

; 999  : 					PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_PAGERIGHT, 0, 0, 0);

  016b6	6a 00		 push	 0
  016b8	6a 00		 push	 0
  016ba	6a 00		 push	 0
  016bc	6a 03		 push	 3
  016be	8d 45 a4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  016c1	50		 push	 eax
  016c2	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  016c5	8b 91 40 03 00
	00		 mov	 edx, DWORD PTR [ecx+832]
  016cb	52		 push	 edx
  016cc	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  016cf	50		 push	 eax
  016d0	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  016d3	51		 push	 ecx
  016d4	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  016d9	83 c4 20	 add	 esp, 32			; 00000020H

; 1000 : 				else

  016dc	eb 18		 jmp	 SHORT $L22877
$L22876:

; 1001 : 					DrawCheckedRect(hdc, &ctrl, crCheck1, crCheck2);

  016de	8b 55 a0	 mov	 edx, DWORD PTR _crCheck2$[ebp]
  016e1	52		 push	 edx
  016e2	8b 45 d0	 mov	 eax, DWORD PTR _crCheck1$[ebp]
  016e5	50		 push	 eax
  016e6	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  016e9	51		 push	 ecx
  016ea	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  016ed	52		 push	 edx
  016ee	e8 00 00 00 00	 call	 _DrawCheckedRect
  016f3	83 c4 10	 add	 esp, 16			; 00000010H
$L22877:

; 1002 : 				
; 1003 : 				RotateRect0(sb, &ctrl);

  016f6	8d 45 a4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  016f9	50		 push	 eax
  016fa	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  016fd	51		 push	 ecx
  016fe	e8 00 00 00 00	 call	 _RotateRect0@8
$L22867:

; 1004 : 			}
; 1005 : 		}
; 1006 : 
; 1007 : 		//RIGHT ARROW
; 1008 : 		SetRect(&ctrl, rect->right - butwidth, rect->top, rect->right, rect->bottom);

  01703	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  01706	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01709	50		 push	 eax
  0170a	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  0170d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01710	52		 push	 edx
  01711	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01714	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01717	51		 push	 ecx
  01718	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  0171b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0171e	2b 45 f8	 sub	 eax, DWORD PTR _butwidth$[ebp]
  01721	50		 push	 eax
  01722	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01725	51		 push	 ecx
  01726	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 1009 : 
; 1010 : 		RotateRect0(sb, &ctrl);

  0172c	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  0172f	52		 push	 edx
  01730	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01733	50		 push	 eax
  01734	e8 00 00 00 00	 call	 _RotateRect0@8

; 1011 : 
; 1012 : 		if(fCustomDraw)

  01739	83 7d e4 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  0173d	74 37		 je	 SHORT $L22878

; 1013 : 			PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_LINERIGHT, fMouseDownR, fMouseOverR, uRightButFlags & DFCS_INACTIVE);

  0173f	8b 4d e8	 mov	 ecx, DWORD PTR _uRightButFlags$[ebp]
  01742	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  01748	51		 push	 ecx
  01749	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _fMouseOverR$[ebp]
  0174f	52		 push	 edx
  01750	8b 45 9c	 mov	 eax, DWORD PTR _fMouseDownR$[ebp]
  01753	50		 push	 eax
  01754	6a 01		 push	 1
  01756	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01759	51		 push	 ecx
  0175a	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  0175d	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  01763	50		 push	 eax
  01764	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01767	51		 push	 ecx
  01768	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0176b	52		 push	 edx
  0176c	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01771	83 c4 20	 add	 esp, 32			; 00000020H

; 1014 : 		else

  01774	eb 23		 jmp	 SHORT $L22879
$L22878:

; 1015 : 			DrawScrollArrow(sb, hdc, &ctrl, uRightButFlags, fMouseDownR, fMouseOverR);

  01776	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _fMouseOverR$[ebp]
  0177c	50		 push	 eax
  0177d	8b 4d 9c	 mov	 ecx, DWORD PTR _fMouseDownR$[ebp]
  01780	51		 push	 ecx
  01781	8b 55 e8	 mov	 edx, DWORD PTR _uRightButFlags$[ebp]
  01784	52		 push	 edx
  01785	8d 45 a4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01788	50		 push	 eax
  01789	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0178c	51		 push	 ecx
  0178d	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01790	52		 push	 edx
  01791	e8 00 00 00 00	 call	 _DrawScrollArrow
  01796	83 c4 18	 add	 esp, 24			; 00000018H
$L22879:

; 1016 : 
; 1017 : 		RotateRect0(sb, &ctrl);

  01799	8d 45 a4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  0179c	50		 push	 eax
  0179d	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  017a0	51		 push	 ecx
  017a1	e8 00 00 00 00	 call	 _RotateRect0@8

; 1018 : 	}
; 1019 : 	//not enough room for the scrollbar, so just draw the buttons (scaled in size to fit)
; 1020 : 	else

  017a6	e9 b7 01 00 00	 jmp	 $L22880
$L22850:

; 1021 : 	{
; 1022 : 		butwidth = scrollwidth / 2;

  017ab	8b 45 c8	 mov	 eax, DWORD PTR _scrollwidth$[ebp]
  017ae	99		 cdq
  017af	2b c2		 sub	 eax, edx
  017b1	d1 f8		 sar	 eax, 1
  017b3	89 45 f8	 mov	 DWORD PTR _butwidth$[ebp], eax

; 1023 : 
; 1024 : 		//LEFT ARROW
; 1025 : 		SetRect(&ctrl, rect->left, rect->top, rect->left + butwidth, rect->bottom);

  017b6	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  017b9	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  017bc	50		 push	 eax
  017bd	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  017c0	8b 11		 mov	 edx, DWORD PTR [ecx]
  017c2	03 55 f8	 add	 edx, DWORD PTR _butwidth$[ebp]
  017c5	52		 push	 edx
  017c6	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  017c9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  017cc	51		 push	 ecx
  017cd	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  017d0	8b 02		 mov	 eax, DWORD PTR [edx]
  017d2	50		 push	 eax
  017d3	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  017d6	51		 push	 ecx
  017d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 1026 : 
; 1027 : 		RotateRect0(sb, &ctrl);

  017dd	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  017e0	52		 push	 edx
  017e1	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  017e4	50		 push	 eax
  017e5	e8 00 00 00 00	 call	 _RotateRect0@8

; 1028 : 		if(fCustomDraw)

  017ea	83 7d e4 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  017ee	74 37		 je	 SHORT $L22881

; 1029 : 			PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_LINELEFT, fMouseDownL, fMouseOverL, uLeftButFlags & DFCS_INACTIVE);

  017f0	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _uLeftButFlags$[ebp]
  017f6	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  017fc	51		 push	 ecx
  017fd	8b 55 fc	 mov	 edx, DWORD PTR _fMouseOverL$[ebp]
  01800	52		 push	 edx
  01801	8b 45 f0	 mov	 eax, DWORD PTR _fMouseDownL$[ebp]
  01804	50		 push	 eax
  01805	6a 00		 push	 0
  01807	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  0180a	51		 push	 ecx
  0180b	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  0180e	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  01814	50		 push	 eax
  01815	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01818	51		 push	 ecx
  01819	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0181c	52		 push	 edx
  0181d	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01822	83 c4 20	 add	 esp, 32			; 00000020H

; 1030 : 		else	

  01825	eb 23		 jmp	 SHORT $L22882
$L22881:

; 1031 : 			DrawScrollArrow(sb, hdc, &ctrl, uLeftButFlags, fMouseDownL, fMouseOverL);

  01827	8b 45 fc	 mov	 eax, DWORD PTR _fMouseOverL$[ebp]
  0182a	50		 push	 eax
  0182b	8b 4d f0	 mov	 ecx, DWORD PTR _fMouseDownL$[ebp]
  0182e	51		 push	 ecx
  0182f	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _uLeftButFlags$[ebp]
  01835	52		 push	 edx
  01836	8d 45 a4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01839	50		 push	 eax
  0183a	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0183d	51		 push	 ecx
  0183e	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01841	52		 push	 edx
  01842	e8 00 00 00 00	 call	 _DrawScrollArrow
  01847	83 c4 18	 add	 esp, 24			; 00000018H
$L22882:

; 1032 : 		RotateRect0(sb, &ctrl);

  0184a	8d 45 a4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  0184d	50		 push	 eax
  0184e	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01851	51		 push	 ecx
  01852	e8 00 00 00 00	 call	 _RotateRect0@8

; 1033 : 
; 1034 : 		//RIGHT ARROW
; 1035 : 		OffsetRect(&ctrl, scrollwidth - butwidth, 0);

  01857	6a 00		 push	 0
  01859	8b 55 c8	 mov	 edx, DWORD PTR _scrollwidth$[ebp]
  0185c	2b 55 f8	 sub	 edx, DWORD PTR _butwidth$[ebp]
  0185f	52		 push	 edx
  01860	8d 45 a4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01863	50		 push	 eax
  01864	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 1036 : 		
; 1037 : 		RotateRect0(sb, &ctrl);

  0186a	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  0186d	51		 push	 ecx
  0186e	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01871	52		 push	 edx
  01872	e8 00 00 00 00	 call	 _RotateRect0@8

; 1038 : 		if(fCustomDraw)

  01877	83 7d e4 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  0187b	74 36		 je	 SHORT $L22883

; 1039 : 			PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_LINERIGHT, fMouseDownR, fMouseOverR, uRightButFlags & DFCS_INACTIVE);

  0187d	8b 45 e8	 mov	 eax, DWORD PTR _uRightButFlags$[ebp]
  01880	25 00 01 00 00	 and	 eax, 256		; 00000100H
  01885	50		 push	 eax
  01886	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _fMouseOverR$[ebp]
  0188c	51		 push	 ecx
  0188d	8b 55 9c	 mov	 edx, DWORD PTR _fMouseDownR$[ebp]
  01890	52		 push	 edx
  01891	6a 01		 push	 1
  01893	8d 45 a4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01896	50		 push	 eax
  01897	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  0189a	8b 91 40 03 00
	00		 mov	 edx, DWORD PTR [ecx+832]
  018a0	52		 push	 edx
  018a1	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  018a4	50		 push	 eax
  018a5	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  018a8	51		 push	 ecx
  018a9	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  018ae	83 c4 20	 add	 esp, 32			; 00000020H

; 1040 : 		else

  018b1	eb 23		 jmp	 SHORT $L22884
$L22883:

; 1041 : 			DrawScrollArrow(sb, hdc, &ctrl, uRightButFlags, fMouseDownR, fMouseOverR);		

  018b3	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _fMouseOverR$[ebp]
  018b9	52		 push	 edx
  018ba	8b 45 9c	 mov	 eax, DWORD PTR _fMouseDownR$[ebp]
  018bd	50		 push	 eax
  018be	8b 4d e8	 mov	 ecx, DWORD PTR _uRightButFlags$[ebp]
  018c1	51		 push	 ecx
  018c2	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  018c5	52		 push	 edx
  018c6	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  018c9	50		 push	 eax
  018ca	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  018cd	51		 push	 ecx
  018ce	e8 00 00 00 00	 call	 _DrawScrollArrow
  018d3	83 c4 18	 add	 esp, 24			; 00000018H
$L22884:

; 1042 : 		RotateRect0(sb, &ctrl);

  018d6	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  018d9	52		 push	 edx
  018da	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  018dd	50		 push	 eax
  018de	e8 00 00 00 00	 call	 _RotateRect0@8

; 1043 : 
; 1044 : 		//if there is a gap between the buttons, fill it with a solid color
; 1045 : 		//if(butwidth & 0x0001)
; 1046 : 		if(ctrl.left != rect->left + butwidth)

  018e3	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  018e6	8b 11		 mov	 edx, DWORD PTR [ecx]
  018e8	03 55 f8	 add	 edx, DWORD PTR _butwidth$[ebp]
  018eb	39 55 a4	 cmp	 DWORD PTR _ctrl$[ebp], edx
  018ee	74 72		 je	 SHORT $L22880

; 1047 : 		{
; 1048 : 			ctrl.left --;

  018f0	8b 45 a4	 mov	 eax, DWORD PTR _ctrl$[ebp]
  018f3	83 e8 01	 sub	 eax, 1
  018f6	89 45 a4	 mov	 DWORD PTR _ctrl$[ebp], eax

; 1049 : 			ctrl.right -= butwidth;

  018f9	8b 4d ac	 mov	 ecx, DWORD PTR _ctrl$[ebp+8]
  018fc	2b 4d f8	 sub	 ecx, DWORD PTR _butwidth$[ebp]
  018ff	89 4d ac	 mov	 DWORD PTR _ctrl$[ebp+8], ecx

; 1050 : 			RotateRect0(sb, &ctrl);

  01902	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01905	52		 push	 edx
  01906	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01909	50		 push	 eax
  0190a	e8 00 00 00 00	 call	 _RotateRect0@8

; 1051 : 			
; 1052 : 			if(fCustomDraw)

  0190f	83 7d e4 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  01913	74 28		 je	 SHORT $L22886

; 1053 : 				PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_PAGERIGHT, 0, 0, 0);

  01915	6a 00		 push	 0
  01917	6a 00		 push	 0
  01919	6a 00		 push	 0
  0191b	6a 03		 push	 3
  0191d	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01920	51		 push	 ecx
  01921	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01924	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  0192a	50		 push	 eax
  0192b	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0192e	51		 push	 ecx
  0192f	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  01932	52		 push	 edx
  01933	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01938	83 c4 20	 add	 esp, 32			; 00000020H

; 1054 : 			else

  0193b	eb 18		 jmp	 SHORT $L22887
$L22886:

; 1055 : 				DrawCheckedRect(hdc, &ctrl, crCheck1, crCheck2);

  0193d	8b 45 a0	 mov	 eax, DWORD PTR _crCheck2$[ebp]
  01940	50		 push	 eax
  01941	8b 4d d0	 mov	 ecx, DWORD PTR _crCheck1$[ebp]
  01944	51		 push	 ecx
  01945	8d 55 a4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01948	52		 push	 edx
  01949	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  0194c	50		 push	 eax
  0194d	e8 00 00 00 00	 call	 _DrawCheckedRect
  01952	83 c4 10	 add	 esp, 16			; 00000010H
$L22887:

; 1056 : 
; 1057 : 			RotateRect0(sb, &ctrl);

  01955	8d 4d a4	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01958	51		 push	 ecx
  01959	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  0195c	52		 push	 edx
  0195d	e8 00 00 00 00	 call	 _RotateRect0@8
$L22880:

; 1058 : 		}
; 1059 : 			
; 1060 : 	}
; 1061 : 
; 1062 : #ifdef CUSTOM_DRAW
; 1063 : 	PostCustomPrePostPaint(hwnd, hdc, sb, CDDS_POSTPAINT);

  01962	6a 02		 push	 2
  01964	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01967	50		 push	 eax
  01968	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0196b	51		 push	 ecx
  0196c	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0196f	52		 push	 edx
  01970	e8 00 00 00 00	 call	 _PostCustomPrePostPaint0
  01975	83 c4 10	 add	 esp, 16			; 00000010H

; 1064 : #endif
; 1065 : 
; 1066 : 	return fCustomDraw;

  01978	8b 45 e4	 mov	 eax, DWORD PTR _fCustomDraw$[ebp]
$L22815:

; 1067 : }

  0197b	8b e5		 mov	 esp, ebp
  0197d	5d		 pop	 ebp
  0197e	c3		 ret	 0
_NCDrawHScrollbar ENDP
; Function compile flags: /Odt
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_RotateRect0@8 PROC NEAR

; 133  : {

  01980	55		 push	 ebp
  01981	8b ec		 mov	 ebp, esp

; 134  : 	if(sb->nBarType == SB_VERT)

  01983	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01986	83 b8 40 03 00
	00 01		 cmp	 DWORD PTR [eax+832], 1
  0198d	75 09		 jne	 SHORT $L22472

; 135  : 		RotateRect(rect);

  0198f	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  01992	51		 push	 ecx
  01993	e8 00 00 00 00	 call	 _RotateRect@4
$L22472:

; 136  : }

  01998	5d		 pop	 ebp
  01999	c2 08 00	 ret	 8
_RotateRect0@8 ENDP
; Function compile flags: /Odt
_temp$ = -4						; size = 4
_rect$ = 8						; size = 4
_RotateRect@4 PROC NEAR

; 118  : {

  019a0	55		 push	 ebp
  019a1	8b ec		 mov	 ebp, esp
  019a3	51		 push	 ecx

; 119  : 	int temp;
; 120  : 	temp = rect->left;

  019a4	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  019a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  019a9	89 4d fc	 mov	 DWORD PTR _temp$[ebp], ecx

; 121  : 	rect->left = rect->top;

  019ac	8b 55 08	 mov	 edx, DWORD PTR _rect$[ebp]
  019af	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  019b2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  019b5	89 0a		 mov	 DWORD PTR [edx], ecx

; 122  : 	rect->top = temp;

  019b7	8b 55 08	 mov	 edx, DWORD PTR _rect$[ebp]
  019ba	8b 45 fc	 mov	 eax, DWORD PTR _temp$[ebp]
  019bd	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 123  : 
; 124  : 	temp = rect->right;

  019c0	8b 4d 08	 mov	 ecx, DWORD PTR _rect$[ebp]
  019c3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  019c6	89 55 fc	 mov	 DWORD PTR _temp$[ebp], edx

; 125  : 	rect->right = rect->bottom;

  019c9	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  019cc	8b 4d 08	 mov	 ecx, DWORD PTR _rect$[ebp]
  019cf	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  019d2	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 126  : 	rect->bottom = temp;

  019d5	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  019d8	8b 4d fc	 mov	 ecx, DWORD PTR _temp$[ebp]
  019db	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 127  : }

  019de	8b e5		 mov	 esp, ebp
  019e0	5d		 pop	 ebp
  019e1	c2 04 00	 ret	 4
_RotateRect@4 ENDP
; Function compile flags: /Odt
_si$ = 8						; size = 4
_IsScrollInfoActive PROC NEAR

; 143  : {

  019f0	55		 push	 ebp
  019f1	8b ec		 mov	 ebp, esp

; 144  : 	if((si->nPage > (UINT)si->nMax
; 145  : 		|| si->nMax <= si->nMin || si->nMax == 0))

  019f3	8b 45 08	 mov	 eax, DWORD PTR _si$[ebp]
  019f6	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  019f9	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  019fc	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  019ff	77 17		 ja	 SHORT $L22480
  01a01	8b 45 08	 mov	 eax, DWORD PTR _si$[ebp]
  01a04	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  01a07	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01a0a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  01a0d	7e 09		 jle	 SHORT $L22480
  01a0f	8b 45 08	 mov	 eax, DWORD PTR _si$[ebp]
  01a12	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  01a16	75 04		 jne	 SHORT $L22479
$L22480:

; 146  : 		return FALSE;

  01a18	33 c0		 xor	 eax, eax
  01a1a	eb 05		 jmp	 SHORT $L22477
$L22479:

; 147  : 	else
; 148  : 		return TRUE;

  01a1c	b8 01 00 00 00	 mov	 eax, 1
$L22477:

; 149  : }

  01a21	5d		 pop	 ebp
  01a22	c3		 ret	 0
_IsScrollInfoActive ENDP
_TEXT	ENDS
EXTRN	__imp__BitBlt@36:NEAR
EXTRN	__imp__CreateBitmap@20:NEAR
EXTRN	__imp__CreateCompatibleBitmap@12:NEAR
EXTRN	__imp__CreateCompatibleDC@4:NEAR
EXTRN	__imp__DeleteDC@4:NEAR
EXTRN	__imp__DeleteObject@4:NEAR
EXTRN	__imp__UnrealizeObject@4:NEAR
EXTRN	__imp__GetStockObject@4:NEAR
EXTRN	__imp__SelectObject@8:NEAR
EXTRN	__imp__SetTextColor@8:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_hdcmem2$22512 = -56					; size = 4
_width$22518 = -52					; size = 4
_height$22519 = -48					; size = 4
_oldbm2$22516 = -44					; size = 4
_hdcmem1$22511 = -40					; size = 4
_hbm1$22513 = -36					; size = 4
_oldbm1$22514 = -32					; size = 4
_rc$22517 = -28						; size = 16
_hbm2$22515 = -12					; size = 4
_ret$ = -8						; size = 4
_flags$ = -4						; size = 4
_sbar$ = 8						; size = 4
_hdc$ = 12						; size = 4
_rect$ = 16						; size = 4
_arrow$ = 20						; size = 4
_fMouseDown$ = 24					; size = 4
_fMouseOver$ = 28					; size = 4
_DrawScrollArrow PROC NEAR

; 168  : {

  01a30	55		 push	 ebp
  01a31	8b ec		 mov	 ebp, esp
  01a33	83 ec 38	 sub	 esp, 56			; 00000038H

; 169  : 	UINT ret;
; 170  : 	UINT flags = arrow;

  01a36	8b 45 14	 mov	 eax, DWORD PTR _arrow$[ebp]
  01a39	89 45 fc	 mov	 DWORD PTR _flags$[ebp], eax

; 171  : 
; 172  : 	//HACKY bit so this routine can be called by vertical and horizontal code
; 173  : 	if(sbar->nBarType == SB_VERT)

  01a3c	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  01a3f	83 b9 40 03 00
	00 01		 cmp	 DWORD PTR [ecx+832], 1
  01a46	75 25		 jne	 SHORT $L22506

; 174  : 	{
; 175  : 		if(flags & DFCS_SCROLLLEFT)		flags = flags & ~DFCS_SCROLLLEFT  | DFCS_SCROLLUP;

  01a48	8b 55 fc	 mov	 edx, DWORD PTR _flags$[ebp]
  01a4b	83 e2 02	 and	 edx, 2
  01a4e	74 09		 je	 SHORT $L22507
  01a50	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  01a53	83 e0 fd	 and	 eax, -3			; fffffffdH
  01a56	89 45 fc	 mov	 DWORD PTR _flags$[ebp], eax
$L22507:

; 176  : 		if(flags & DFCS_SCROLLRIGHT)	flags = flags & ~DFCS_SCROLLRIGHT | DFCS_SCROLLDOWN;

  01a59	8b 4d fc	 mov	 ecx, DWORD PTR _flags$[ebp]
  01a5c	83 e1 03	 and	 ecx, 3
  01a5f	74 0c		 je	 SHORT $L22506
  01a61	8b 55 fc	 mov	 edx, DWORD PTR _flags$[ebp]
  01a64	83 e2 fc	 and	 edx, -4			; fffffffcH
  01a67	83 ca 01	 or	 edx, 1
  01a6a	89 55 fc	 mov	 DWORD PTR _flags$[ebp], edx
$L22506:

; 177  : 	}
; 178  : 
; 179  : 	if(fMouseDown) flags |= (DFCS_FLAT | DFCS_PUSHED);

  01a6d	83 7d 18 00	 cmp	 DWORD PTR _fMouseDown$[ebp], 0
  01a71	74 0b		 je	 SHORT $L22509
  01a73	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  01a76	0d 00 42 00 00	 or	 eax, 16896		; 00004200H
  01a7b	89 45 fc	 mov	 DWORD PTR _flags$[ebp], eax
$L22509:

; 180  : 
; 181  : #ifdef FLAT_SCROLLBARS
; 182  : 	if(sbar->fFlatScrollbar != CSBS_NORMAL)

  01a7e	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  01a81	83 b9 44 03 00
	00 00		 cmp	 DWORD PTR [ecx+836], 0
  01a88	0f 84 97 02 00
	00		 je	 $L22510

; 183  : 	{
; 184  : 		HDC hdcmem1, hdcmem2;
; 185  : 		HBITMAP hbm1, oldbm1;
; 186  : 		HBITMAP hbm2, oldbm2;
; 187  : 		RECT rc;
; 188  : 		int width, height;
; 189  : 
; 190  : 		rc = *rect;

  01a8e	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  01a91	8b 02		 mov	 eax, DWORD PTR [edx]
  01a93	89 45 e4	 mov	 DWORD PTR _rc$22517[ebp], eax
  01a96	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  01a99	89 4d e8	 mov	 DWORD PTR _rc$22517[ebp+4], ecx
  01a9c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01a9f	89 45 ec	 mov	 DWORD PTR _rc$22517[ebp+8], eax
  01aa2	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  01aa5	89 4d f0	 mov	 DWORD PTR _rc$22517[ebp+12], ecx

; 191  : 		width  = rc.right-rc.left;

  01aa8	8b 55 ec	 mov	 edx, DWORD PTR _rc$22517[ebp+8]
  01aab	2b 55 e4	 sub	 edx, DWORD PTR _rc$22517[ebp]
  01aae	89 55 cc	 mov	 DWORD PTR _width$22518[ebp], edx

; 192  : 		height = rc.bottom-rc.top;

  01ab1	8b 45 f0	 mov	 eax, DWORD PTR _rc$22517[ebp+12]
  01ab4	2b 45 e8	 sub	 eax, DWORD PTR _rc$22517[ebp+4]
  01ab7	89 45 d0	 mov	 DWORD PTR _height$22519[ebp], eax

; 193  : 		SetRect(&rc, 0, 0, width, height);

  01aba	8b 4d d0	 mov	 ecx, DWORD PTR _height$22519[ebp]
  01abd	51		 push	 ecx
  01abe	8b 55 cc	 mov	 edx, DWORD PTR _width$22518[ebp]
  01ac1	52		 push	 edx
  01ac2	6a 00		 push	 0
  01ac4	6a 00		 push	 0
  01ac6	8d 45 e4	 lea	 eax, DWORD PTR _rc$22517[ebp]
  01ac9	50		 push	 eax
  01aca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 194  : 
; 195  : 		//MONOCHROME bitmap to convert the arrow to black/white mask
; 196  : 		hdcmem1 = CreateCompatibleDC(hdc);

  01ad0	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01ad3	51		 push	 ecx
  01ad4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  01ada	89 45 d8	 mov	 DWORD PTR _hdcmem1$22511[ebp], eax

; 197  : 		hbm1    = CreateBitmap(width, height, 1, 1, NULL);

  01add	6a 00		 push	 0
  01adf	6a 01		 push	 1
  01ae1	6a 01		 push	 1
  01ae3	8b 55 d0	 mov	 edx, DWORD PTR _height$22519[ebp]
  01ae6	52		 push	 edx
  01ae7	8b 45 cc	 mov	 eax, DWORD PTR _width$22518[ebp]
  01aea	50		 push	 eax
  01aeb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateBitmap@20
  01af1	89 45 dc	 mov	 DWORD PTR _hbm1$22513[ebp], eax

; 198  : 		UnrealizeObject(hbm1);

  01af4	8b 4d dc	 mov	 ecx, DWORD PTR _hbm1$22513[ebp]
  01af7	51		 push	 ecx
  01af8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnrealizeObject@4

; 199  : 		oldbm1  = SelectObject(hdcmem1, hbm1);

  01afe	8b 55 dc	 mov	 edx, DWORD PTR _hbm1$22513[ebp]
  01b01	52		 push	 edx
  01b02	8b 45 d8	 mov	 eax, DWORD PTR _hdcmem1$22511[ebp]
  01b05	50		 push	 eax
  01b06	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01b0c	89 45 e0	 mov	 DWORD PTR _oldbm1$22514[ebp], eax

; 200  : 		
; 201  : 
; 202  : 		//NORMAL bitmap to draw the arrow into
; 203  : 		hdcmem2 = CreateCompatibleDC(hdc);

  01b0f	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01b12	51		 push	 ecx
  01b13	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  01b19	89 45 c8	 mov	 DWORD PTR _hdcmem2$22512[ebp], eax

; 204  : 		hbm2    = CreateCompatibleBitmap(hdc, width, height);

  01b1c	8b 55 d0	 mov	 edx, DWORD PTR _height$22519[ebp]
  01b1f	52		 push	 edx
  01b20	8b 45 cc	 mov	 eax, DWORD PTR _width$22518[ebp]
  01b23	50		 push	 eax
  01b24	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01b27	51		 push	 ecx
  01b28	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  01b2e	89 45 f4	 mov	 DWORD PTR _hbm2$22515[ebp], eax

; 205  : 		UnrealizeObject(hbm2);

  01b31	8b 55 f4	 mov	 edx, DWORD PTR _hbm2$22515[ebp]
  01b34	52		 push	 edx
  01b35	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnrealizeObject@4

; 206  : 		oldbm2  = SelectObject(hdcmem2, hbm2);

  01b3b	8b 45 f4	 mov	 eax, DWORD PTR _hbm2$22515[ebp]
  01b3e	50		 push	 eax
  01b3f	8b 4d c8	 mov	 ecx, DWORD PTR _hdcmem2$22512[ebp]
  01b42	51		 push	 ecx
  01b43	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01b49	89 45 d4	 mov	 DWORD PTR _oldbm2$22516[ebp], eax

; 207  : 		
; 208  : 
; 209  : 		flags = flags & ~DFCS_PUSHED | DFCS_FLAT;	//just in case

  01b4c	8b 55 fc	 mov	 edx, DWORD PTR _flags$[ebp]
  01b4f	81 e2 ff fd ff
	ff		 and	 edx, -513		; fffffdffH
  01b55	81 ca 00 40 00
	00		 or	 edx, 16384		; 00004000H
  01b5b	89 55 fc	 mov	 DWORD PTR _flags$[ebp], edx

; 210  : 		DrawFrameControl(hdcmem2, &rc, DFC_SCROLL, flags);

  01b5e	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  01b61	50		 push	 eax
  01b62	6a 03		 push	 3
  01b64	8d 4d e4	 lea	 ecx, DWORD PTR _rc$22517[ebp]
  01b67	51		 push	 ecx
  01b68	8b 55 c8	 mov	 edx, DWORD PTR _hdcmem2$22512[ebp]
  01b6b	52		 push	 edx
  01b6c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16

; 211  : 
; 212  : 
; 213  : #ifndef HOT_TRACKING
; 214  : 		if(fMouseDown)
; 215  : 		{
; 216  : 			//uncomment these to make the cool scrollbars
; 217  : 			//look like the common controls flat scrollbars
; 218  : 			//fMouseDown = FALSE;
; 219  : 			//fMouseOver = TRUE;
; 220  : 		}
; 221  : #endif
; 222  : 		//draw a flat monochrome version of a scrollbar arrow (dark)
; 223  : 		if(fMouseDown)

  01b72	83 7d 18 00	 cmp	 DWORD PTR _fMouseDown$[ebp], 0
  01b76	0f 84 89 00 00
	00		 je	 $L22521

; 224  : 		{
; 225  : 			SetBkColor(hdcmem2, GetSysColor(COLOR_BTNTEXT));

  01b7c	6a 12		 push	 18			; 00000012H
  01b7e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  01b84	50		 push	 eax
  01b85	8b 45 c8	 mov	 eax, DWORD PTR _hdcmem2$22512[ebp]
  01b88	50		 push	 eax
  01b89	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 226  : 			BitBlt(hdcmem1, 0, 0, width, height, hdcmem2, 0, 0, SRCCOPY);

  01b8f	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01b94	6a 00		 push	 0
  01b96	6a 00		 push	 0
  01b98	8b 4d c8	 mov	 ecx, DWORD PTR _hdcmem2$22512[ebp]
  01b9b	51		 push	 ecx
  01b9c	8b 55 d0	 mov	 edx, DWORD PTR _height$22519[ebp]
  01b9f	52		 push	 edx
  01ba0	8b 45 cc	 mov	 eax, DWORD PTR _width$22518[ebp]
  01ba3	50		 push	 eax
  01ba4	6a 00		 push	 0
  01ba6	6a 00		 push	 0
  01ba8	8b 4d d8	 mov	 ecx, DWORD PTR _hdcmem1$22511[ebp]
  01bab	51		 push	 ecx
  01bac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 227  : 			SetBkColor(hdc, 0x00ffffff);

  01bb2	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  01bb7	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  01bba	52		 push	 edx
  01bbb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 228  : 			SetTextColor(hdc, GetSysColor(COLOR_3DDKSHADOW));

  01bc1	6a 15		 push	 21			; 00000015H
  01bc3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  01bc9	50		 push	 eax
  01bca	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  01bcd	50		 push	 eax
  01bce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 229  : 			BitBlt(hdc, rect->left, rect->top, width, height, hdcmem1, 0, 0, SRCCOPY);

  01bd4	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01bd9	6a 00		 push	 0
  01bdb	6a 00		 push	 0
  01bdd	8b 4d d8	 mov	 ecx, DWORD PTR _hdcmem1$22511[ebp]
  01be0	51		 push	 ecx
  01be1	8b 55 d0	 mov	 edx, DWORD PTR _height$22519[ebp]
  01be4	52		 push	 edx
  01be5	8b 45 cc	 mov	 eax, DWORD PTR _width$22518[ebp]
  01be8	50		 push	 eax
  01be9	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  01bec	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01bef	52		 push	 edx
  01bf0	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  01bf3	8b 08		 mov	 ecx, DWORD PTR [eax]
  01bf5	51		 push	 ecx
  01bf6	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  01bf9	52		 push	 edx
  01bfa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 230  : 		}
; 231  : 		//draw a flat monochrome version of a scrollbar arrow (grey)
; 232  : 		else if(fMouseOver)

  01c00	e9 d3 00 00 00	 jmp	 $L22524
$L22521:
  01c05	83 7d 1c 00	 cmp	 DWORD PTR _fMouseOver$[ebp], 0
  01c09	0f 84 9d 00 00
	00		 je	 $L22525

; 233  : 		{
; 234  : 			SetBkColor(hdcmem2, GetSysColor(COLOR_BTNTEXT));

  01c0f	6a 12		 push	 18			; 00000012H
  01c11	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  01c17	50		 push	 eax
  01c18	8b 45 c8	 mov	 eax, DWORD PTR _hdcmem2$22512[ebp]
  01c1b	50		 push	 eax
  01c1c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 235  : 			FillRect(hdcmem1, &rc, GetStockObject(WHITE_BRUSH));

  01c22	6a 00		 push	 0
  01c24	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStockObject@4
  01c2a	50		 push	 eax
  01c2b	8d 4d e4	 lea	 ecx, DWORD PTR _rc$22517[ebp]
  01c2e	51		 push	 ecx
  01c2f	8b 55 d8	 mov	 edx, DWORD PTR _hdcmem1$22511[ebp]
  01c32	52		 push	 edx
  01c33	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 236  : 			BitBlt(hdcmem1, 0, 0, width, height, hdcmem2, 0, 0, SRCINVERT);

  01c39	68 46 00 66 00	 push	 6684742			; 00660046H
  01c3e	6a 00		 push	 0
  01c40	6a 00		 push	 0
  01c42	8b 45 c8	 mov	 eax, DWORD PTR _hdcmem2$22512[ebp]
  01c45	50		 push	 eax
  01c46	8b 4d d0	 mov	 ecx, DWORD PTR _height$22519[ebp]
  01c49	51		 push	 ecx
  01c4a	8b 55 cc	 mov	 edx, DWORD PTR _width$22518[ebp]
  01c4d	52		 push	 edx
  01c4e	6a 00		 push	 0
  01c50	6a 00		 push	 0
  01c52	8b 45 d8	 mov	 eax, DWORD PTR _hdcmem1$22511[ebp]
  01c55	50		 push	 eax
  01c56	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 237  : 
; 238  : 			SetBkColor(hdc, GetSysColor(COLOR_3DSHADOW));

  01c5c	6a 10		 push	 16			; 00000010H
  01c5e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  01c64	50		 push	 eax
  01c65	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01c68	51		 push	 ecx
  01c69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 239  : 			SetTextColor(hdc, 0x00ffffff);

  01c6f	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  01c74	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  01c77	52		 push	 edx
  01c78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 240  : 			BitBlt(hdc, rect->left, rect->top, width, height, hdcmem1, 0, 0, SRCCOPY);

  01c7e	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01c83	6a 00		 push	 0
  01c85	6a 00		 push	 0
  01c87	8b 45 d8	 mov	 eax, DWORD PTR _hdcmem1$22511[ebp]
  01c8a	50		 push	 eax
  01c8b	8b 4d d0	 mov	 ecx, DWORD PTR _height$22519[ebp]
  01c8e	51		 push	 ecx
  01c8f	8b 55 cc	 mov	 edx, DWORD PTR _width$22518[ebp]
  01c92	52		 push	 edx
  01c93	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  01c96	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01c99	51		 push	 ecx
  01c9a	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  01c9d	8b 02		 mov	 eax, DWORD PTR [edx]
  01c9f	50		 push	 eax
  01ca0	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01ca3	51		 push	 ecx
  01ca4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 241  : 		}
; 242  : 		//draw the arrow normally
; 243  : 		else

  01caa	eb 2c		 jmp	 SHORT $L22524
$L22525:

; 244  : 		{
; 245  : 			BitBlt(hdc, rect->left, rect->top, width, height, hdcmem2, 0, 0, SRCCOPY);

  01cac	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01cb1	6a 00		 push	 0
  01cb3	6a 00		 push	 0
  01cb5	8b 55 c8	 mov	 edx, DWORD PTR _hdcmem2$22512[ebp]
  01cb8	52		 push	 edx
  01cb9	8b 45 d0	 mov	 eax, DWORD PTR _height$22519[ebp]
  01cbc	50		 push	 eax
  01cbd	8b 4d cc	 mov	 ecx, DWORD PTR _width$22518[ebp]
  01cc0	51		 push	 ecx
  01cc1	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  01cc4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01cc7	50		 push	 eax
  01cc8	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  01ccb	8b 11		 mov	 edx, DWORD PTR [ecx]
  01ccd	52		 push	 edx
  01cce	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  01cd1	50		 push	 eax
  01cd2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
$L22524:

; 246  : 		}
; 247  : 
; 248  : 		SelectObject(hdcmem1, oldbm1);

  01cd8	8b 4d e0	 mov	 ecx, DWORD PTR _oldbm1$22514[ebp]
  01cdb	51		 push	 ecx
  01cdc	8b 55 d8	 mov	 edx, DWORD PTR _hdcmem1$22511[ebp]
  01cdf	52		 push	 edx
  01ce0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 249  : 		SelectObject(hdcmem2, oldbm2);

  01ce6	8b 45 d4	 mov	 eax, DWORD PTR _oldbm2$22516[ebp]
  01ce9	50		 push	 eax
  01cea	8b 4d c8	 mov	 ecx, DWORD PTR _hdcmem2$22512[ebp]
  01ced	51		 push	 ecx
  01cee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 250  : 		DeleteObject(hbm1);

  01cf4	8b 55 dc	 mov	 edx, DWORD PTR _hbm1$22513[ebp]
  01cf7	52		 push	 edx
  01cf8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 251  : 		DeleteObject(hbm2);

  01cfe	8b 45 f4	 mov	 eax, DWORD PTR _hbm2$22515[ebp]
  01d01	50		 push	 eax
  01d02	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 252  : 		DeleteDC(hdcmem1);

  01d08	8b 4d d8	 mov	 ecx, DWORD PTR _hdcmem1$22511[ebp]
  01d0b	51		 push	 ecx
  01d0c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 253  : 		DeleteDC(hdcmem2);

  01d12	8b 55 c8	 mov	 edx, DWORD PTR _hdcmem2$22512[ebp]
  01d15	52		 push	 edx
  01d16	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 254  : 
; 255  : 		ret = 0;

  01d1c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 256  : 	}
; 257  : 	else

  01d23	eb 17		 jmp	 SHORT $L22530
$L22510:

; 258  : #endif
; 259  : 	ret = DrawFrameControl(hdc, rect, DFC_SCROLL, flags);

  01d25	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  01d28	50		 push	 eax
  01d29	6a 03		 push	 3
  01d2b	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  01d2e	51		 push	 ecx
  01d2f	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  01d32	52		 push	 edx
  01d33	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16
  01d39	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
$L22530:

; 260  : 
; 261  : 	return ret;

  01d3c	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 262  : }

  01d3f	8b e5		 mov	 esp, ebp
  01d41	5d		 pop	 ebp
  01d42	c3		 ret	 0
_DrawScrollArrow ENDP
; Function compile flags: /Odt
_c2$ = -8						; size = 4
_c1$ = -4						; size = 4
_GetSBForeColor PROC NEAR

; 312  : {

  01d50	55		 push	 ebp
  01d51	8b ec		 mov	 ebp, esp
  01d53	83 ec 08	 sub	 esp, 8

; 313  : 	COLORREF c1 = GetSysColor(COLOR_3DHILIGHT);

  01d56	6a 14		 push	 20			; 00000014H
  01d58	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  01d5e	89 45 fc	 mov	 DWORD PTR _c1$[ebp], eax

; 314  : 	COLORREF c2 = GetSysColor(COLOR_WINDOW);

  01d61	6a 05		 push	 5
  01d63	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  01d69	89 45 f8	 mov	 DWORD PTR _c2$[ebp], eax

; 315  : 
; 316  : 	if(c1 != 0xffffff && c1 == c2)

  01d6c	81 7d fc ff ff
	ff 00		 cmp	 DWORD PTR _c1$[ebp], 16777215 ; 00ffffffH
  01d73	74 12		 je	 SHORT $L22557
  01d75	8b 45 fc	 mov	 eax, DWORD PTR _c1$[ebp]
  01d78	3b 45 f8	 cmp	 eax, DWORD PTR _c2$[ebp]
  01d7b	75 0a		 jne	 SHORT $L22557

; 317  : 	{
; 318  : 		return GetSysColor(COLOR_BTNFACE);

  01d7d	6a 0f		 push	 15			; 0000000fH
  01d7f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  01d85	eb 08		 jmp	 SHORT $L22554
$L22557:

; 319  : 	}
; 320  : 	else
; 321  : 	{
; 322  : 		return GetSysColor(COLOR_3DHILIGHT);

  01d87	6a 14		 push	 20			; 00000014H
  01d89	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
$L22554:

; 323  : 	}
; 324  : }

  01d8f	8b e5		 mov	 esp, ebp
  01d91	5d		 pop	 ebp
  01d92	c3		 ret	 0
_GetSBForeColor ENDP
; Function compile flags: /Odt
_GetSBBackColor PROC NEAR

; 327  : {

  01da0	55		 push	 ebp
  01da1	8b ec		 mov	 ebp, esp

; 328  : 	return GetSysColor(COLOR_SCROLLBAR);

  01da3	6a 00		 push	 0
  01da5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4

; 329  : }

  01dab	5d		 pop	 ebp
  01dac	c3		 ret	 0
_GetSBBackColor ENDP
_TEXT	ENDS
EXTRN	__imp__CreatePatternBrush@4:NEAR
EXTRN	__imp__SetBrushOrgEx@16:NEAR
EXTRN	__imp__PatBlt@24:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_fgold$ = -20						; size = 4
_bgold$ = -16						; size = 4
_hbmp$ = -12						; size = 4
_hbrold$ = -8						; size = 4
_hbr$ = -4						; size = 4
_hdc$ = 8						; size = 4
_rect$ = 12						; size = 4
_fg$ = 16						; size = 4
_bg$ = 20						; size = 4
_DrawCheckedRect PROC NEAR

; 336  : {

  01db0	55		 push	 ebp
  01db1	8b ec		 mov	 ebp, esp
  01db3	83 ec 14	 sub	 esp, 20			; 00000014H

; 337  : 	static WORD wCheckPat[8] = 
; 338  : 	{ 
; 339  : 		0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555 
; 340  : 	};
; 341  : 
; 342  : 	HBITMAP hbmp;
; 343  : 	HBRUSH  hbr, hbrold;
; 344  : 	COLORREF fgold, bgold;
; 345  : 
; 346  : 	hbmp = CreateBitmap(8, 8, 1, 1, wCheckPat);

  01db6	68 00 00 00 00	 push	 OFFSET FLAT:?wCheckPat@?1??DrawCheckedRect@@9@9
  01dbb	6a 01		 push	 1
  01dbd	6a 01		 push	 1
  01dbf	6a 08		 push	 8
  01dc1	6a 08		 push	 8
  01dc3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateBitmap@20
  01dc9	89 45 f4	 mov	 DWORD PTR _hbmp$[ebp], eax

; 347  : 	hbr  = CreatePatternBrush(hbmp);

  01dcc	8b 45 f4	 mov	 eax, DWORD PTR _hbmp$[ebp]
  01dcf	50		 push	 eax
  01dd0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreatePatternBrush@4
  01dd6	89 45 fc	 mov	 DWORD PTR _hbr$[ebp], eax

; 348  : 
; 349  : 	UnrealizeObject(hbr);

  01dd9	8b 4d fc	 mov	 ecx, DWORD PTR _hbr$[ebp]
  01ddc	51		 push	 ecx
  01ddd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnrealizeObject@4

; 350  : 	SetBrushOrgEx(hdc, rect->left, rect->top, 0);

  01de3	6a 00		 push	 0
  01de5	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  01de8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01deb	50		 push	 eax
  01dec	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  01def	8b 11		 mov	 edx, DWORD PTR [ecx]
  01df1	52		 push	 edx
  01df2	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  01df5	50		 push	 eax
  01df6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBrushOrgEx@16

; 351  : 
; 352  : 	hbrold = (HBRUSH)SelectObject(hdc, hbr);

  01dfc	8b 4d fc	 mov	 ecx, DWORD PTR _hbr$[ebp]
  01dff	51		 push	 ecx
  01e00	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  01e03	52		 push	 edx
  01e04	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01e0a	89 45 f8	 mov	 DWORD PTR _hbrold$[ebp], eax

; 353  : 
; 354  : 	fgold = SetTextColor(hdc, fg);

  01e0d	8b 45 10	 mov	 eax, DWORD PTR _fg$[ebp]
  01e10	50		 push	 eax
  01e11	8b 4d 08	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01e14	51		 push	 ecx
  01e15	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8
  01e1b	89 45 ec	 mov	 DWORD PTR _fgold$[ebp], eax

; 355  : 	bgold = SetBkColor(hdc, bg);

  01e1e	8b 55 14	 mov	 edx, DWORD PTR _bg$[ebp]
  01e21	52		 push	 edx
  01e22	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  01e25	50		 push	 eax
  01e26	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  01e2c	89 45 f0	 mov	 DWORD PTR _bgold$[ebp], eax

; 356  : 	
; 357  : 	PatBlt(hdc, rect->left, rect->top, 
; 358  : 				rect->right - rect->left, 
; 359  : 				rect->bottom - rect->top, 
; 360  : 				PATCOPY);

  01e2f	68 21 00 f0 00	 push	 15728673		; 00f00021H
  01e34	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  01e37	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  01e3a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  01e3d	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  01e40	50		 push	 eax
  01e41	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  01e44	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  01e47	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  01e4a	2b 02		 sub	 eax, DWORD PTR [edx]
  01e4c	50		 push	 eax
  01e4d	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  01e50	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01e53	52		 push	 edx
  01e54	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  01e57	8b 08		 mov	 ecx, DWORD PTR [eax]
  01e59	51		 push	 ecx
  01e5a	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  01e5d	52		 push	 edx
  01e5e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PatBlt@24

; 361  : 	
; 362  : 	SetBkColor(hdc, bgold);

  01e64	8b 45 f0	 mov	 eax, DWORD PTR _bgold$[ebp]
  01e67	50		 push	 eax
  01e68	8b 4d 08	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01e6b	51		 push	 ecx
  01e6c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 363  : 	SetTextColor(hdc, fgold);

  01e72	8b 55 ec	 mov	 edx, DWORD PTR _fgold$[ebp]
  01e75	52		 push	 edx
  01e76	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  01e79	50		 push	 eax
  01e7a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 364  : 	
; 365  : 	SelectObject(hdc, hbrold);

  01e80	8b 4d f8	 mov	 ecx, DWORD PTR _hbrold$[ebp]
  01e83	51		 push	 ecx
  01e84	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  01e87	52		 push	 edx
  01e88	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 366  : 	DeleteObject(hbr);

  01e8e	8b 45 fc	 mov	 eax, DWORD PTR _hbr$[ebp]
  01e91	50		 push	 eax
  01e92	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 367  : 	DeleteObject(hbmp);

  01e98	8b 4d f4	 mov	 ecx, DWORD PTR _hbmp$[ebp]
  01e9b	51		 push	 ecx
  01e9c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 368  : }

  01ea2	8b e5		 mov	 esp, ebp
  01ea4	5d		 pop	 ebp
  01ea5	c3		 ret	 0
_DrawCheckedRect ENDP
_TEXT	ENDS
EXTRN	__imp__MulDiv@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv92 = -44						; size = 4
_pagesize$22704 = -40					; size = 4
_startcoord$ = -36					; size = 4
_thumbsize$ = -32					; size = 4
_si$ = -28						; size = 4
_adjust$ = -24						; size = 4
_scrollsize$ = -20					; size = 4
_siMaxMin$ = -16					; size = 4
_workingsize$ = -12					; size = 4
_butsize$ = -8						; size = 4
_thumbpos$ = -4						; size = 4
_sbar$ = 8						; size = 4
_rect$ = 12						; size = 4
_pthumbsize$ = 16					; size = 4
_pthumbpos$ = 20					; size = 4
_CalcThumbSize PROC NEAR

; 534  : {

  01eb0	55		 push	 ebp
  01eb1	8b ec		 mov	 ebp, esp
  01eb3	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 535  : 	SCROLLINFO *si;
; 536  : 	int scrollsize;			//total size of the scrollbar including arrow buttons
; 537  : 	int workingsize;		//working area (where the thumb can slide)
; 538  : 	int siMaxMin;
; 539  : 	int butsize;
; 540  : 	int startcoord;
; 541  : 	int thumbpos = 0, thumbsize = 0;

  01eb6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _thumbpos$[ebp], 0
  01ebd	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _thumbsize$[ebp], 0

; 542  : 
; 543  : 	int adjust=0;

  01ec4	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _adjust$[ebp], 0

; 544  : 	static int count=0;
; 545  : 
; 546  : 	//work out the width (for a horizontal) or the height (for a vertical)
; 547  : 	//of a standard scrollbar button
; 548  : 	butsize = GetScrollMetric(sbar, SM_SCROLL_LENGTH);

  01ecb	6a 00		 push	 0
  01ecd	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  01ed0	50		 push	 eax
  01ed1	e8 00 00 00 00	 call	 _GetScrollMetric
  01ed6	83 c4 08	 add	 esp, 8
  01ed9	89 45 f8	 mov	 DWORD PTR _butsize$[ebp], eax

; 549  : 
; 550  : 	if(1) //sbar->nBarType == SB_HORZ)

  01edc	b9 01 00 00 00	 mov	 ecx, 1
  01ee1	85 c9		 test	 ecx, ecx
  01ee3	74 16		 je	 SHORT $L22698

; 551  : 	{
; 552  : 		scrollsize = rect->right - rect->left;

  01ee5	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  01ee8	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  01eeb	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  01eee	2b 08		 sub	 ecx, DWORD PTR [eax]
  01ef0	89 4d ec	 mov	 DWORD PTR _scrollsize$[ebp], ecx

; 553  : 		startcoord = rect->left;

  01ef3	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  01ef6	8b 02		 mov	 eax, DWORD PTR [edx]
  01ef8	89 45 dc	 mov	 DWORD PTR _startcoord$[ebp], eax
$L22698:

; 554  : 	}
; 555  : 	/*else if(sbar->nBarType == SB_VERT)
; 556  : 	{
; 557  : 		scrollsize = rect->bottom - rect->top;
; 558  : 		startcoord = rect->top;
; 559  : 	}
; 560  : 	else
; 561  : 	{
; 562  : 		return 0;
; 563  : 	}*/
; 564  : 
; 565  : 	si = &sbar->scrollInfo;

  01efb	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  01efe	83 c1 08	 add	 ecx, 8
  01f01	89 4d e4	 mov	 DWORD PTR _si$[ebp], ecx

; 566  : 	siMaxMin = si->nMax - si->nMin + 1;

  01f04	8b 55 e4	 mov	 edx, DWORD PTR _si$[ebp]
  01f07	8b 45 e4	 mov	 eax, DWORD PTR _si$[ebp]
  01f0a	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  01f0d	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  01f10	83 c1 01	 add	 ecx, 1
  01f13	89 4d f0	 mov	 DWORD PTR _siMaxMin$[ebp], ecx

; 567  : 	workingsize = scrollsize - butsize * 2;

  01f16	8b 55 f8	 mov	 edx, DWORD PTR _butsize$[ebp]
  01f19	d1 e2		 shl	 edx, 1
  01f1b	8b 45 ec	 mov	 eax, DWORD PTR _scrollsize$[ebp]
  01f1e	2b c2		 sub	 eax, edx
  01f20	89 45 f4	 mov	 DWORD PTR _workingsize$[ebp], eax

; 568  : 
; 569  : 	//
; 570  : 	// Work out the scrollbar thumb SIZE
; 571  : 	//
; 572  : 	if(si->nPage == 0)

  01f23	8b 4d e4	 mov	 ecx, DWORD PTR _si$[ebp]
  01f26	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  01f2a	75 08		 jne	 SHORT $L22699

; 573  : 	{
; 574  : 		thumbsize = butsize;

  01f2c	8b 55 f8	 mov	 edx, DWORD PTR _butsize$[ebp]
  01f2f	89 55 e0	 mov	 DWORD PTR _thumbsize$[ebp], edx

; 575  : 	}
; 576  : 	else if(siMaxMin > 0)

  01f32	eb 38		 jmp	 SHORT $L22700
$L22699:
  01f34	83 7d f0 00	 cmp	 DWORD PTR _siMaxMin$[ebp], 0
  01f38	7e 32		 jle	 SHORT $L22700

; 577  : 	{
; 578  : 		thumbsize = MulDiv(si->nPage, workingsize, siMaxMin);

  01f3a	8b 45 f0	 mov	 eax, DWORD PTR _siMaxMin$[ebp]
  01f3d	50		 push	 eax
  01f3e	8b 4d f4	 mov	 ecx, DWORD PTR _workingsize$[ebp]
  01f41	51		 push	 ecx
  01f42	8b 55 e4	 mov	 edx, DWORD PTR _si$[ebp]
  01f45	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  01f48	50		 push	 eax
  01f49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  01f4f	89 45 e0	 mov	 DWORD PTR _thumbsize$[ebp], eax

; 579  : 
; 580  : 		if(thumbsize < sbar->nMinThumbSize)

  01f52	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  01f55	8b 55 e0	 mov	 edx, DWORD PTR _thumbsize$[ebp]
  01f58	3b 91 48 03 00
	00		 cmp	 edx, DWORD PTR [ecx+840]
  01f5e	7d 0c		 jge	 SHORT $L22700

; 581  : 			thumbsize = sbar->nMinThumbSize;

  01f60	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  01f63	8b 88 48 03 00
	00		 mov	 ecx, DWORD PTR [eax+840]
  01f69	89 4d e0	 mov	 DWORD PTR _thumbsize$[ebp], ecx
$L22700:

; 582  : 	}
; 583  : 
; 584  : 	//
; 585  : 	// Work out the scrollbar thumb position
; 586  : 	//
; 587  : 	if(siMaxMin > 0)

  01f6c	83 7d f0 00	 cmp	 DWORD PTR _siMaxMin$[ebp], 0
  01f70	7e 66		 jle	 SHORT $L22703

; 588  : 	{
; 589  : 		int pagesize = max(1, si->nPage);

  01f72	8b 55 e4	 mov	 edx, DWORD PTR _si$[ebp]
  01f75	83 7a 10 01	 cmp	 DWORD PTR [edx+16], 1
  01f79	73 09		 jae	 SHORT $L23902
  01f7b	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  01f82	eb 09		 jmp	 SHORT $L23903
$L23902:
  01f84	8b 45 e4	 mov	 eax, DWORD PTR _si$[ebp]
  01f87	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01f8a	89 4d d4	 mov	 DWORD PTR tv92[ebp], ecx
$L23903:
  01f8d	8b 55 d4	 mov	 edx, DWORD PTR tv92[ebp]
  01f90	89 55 d8	 mov	 DWORD PTR _pagesize$22704[ebp], edx

; 590  : 		thumbpos = MulDiv(si->nPos - si->nMin, workingsize-thumbsize, siMaxMin - pagesize);

  01f93	8b 45 f0	 mov	 eax, DWORD PTR _siMaxMin$[ebp]
  01f96	2b 45 d8	 sub	 eax, DWORD PTR _pagesize$22704[ebp]
  01f99	50		 push	 eax
  01f9a	8b 4d f4	 mov	 ecx, DWORD PTR _workingsize$[ebp]
  01f9d	2b 4d e0	 sub	 ecx, DWORD PTR _thumbsize$[ebp]
  01fa0	51		 push	 ecx
  01fa1	8b 55 e4	 mov	 edx, DWORD PTR _si$[ebp]
  01fa4	8b 45 e4	 mov	 eax, DWORD PTR _si$[ebp]
  01fa7	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  01faa	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  01fad	51		 push	 ecx
  01fae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  01fb4	89 45 fc	 mov	 DWORD PTR _thumbpos$[ebp], eax

; 591  : 		
; 592  : 		if(thumbpos < 0)						

  01fb7	83 7d fc 00	 cmp	 DWORD PTR _thumbpos$[ebp], 0
  01fbb	7d 07		 jge	 SHORT $L22705

; 593  : 			thumbpos = 0;

  01fbd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _thumbpos$[ebp], 0
$L22705:

; 594  : 
; 595  : 		if(thumbpos >= workingsize-thumbsize)	

  01fc4	8b 55 f4	 mov	 edx, DWORD PTR _workingsize$[ebp]
  01fc7	2b 55 e0	 sub	 edx, DWORD PTR _thumbsize$[ebp]
  01fca	39 55 fc	 cmp	 DWORD PTR _thumbpos$[ebp], edx
  01fcd	7c 09		 jl	 SHORT $L22703

; 596  : 			thumbpos = workingsize-thumbsize;

  01fcf	8b 45 f4	 mov	 eax, DWORD PTR _workingsize$[ebp]
  01fd2	2b 45 e0	 sub	 eax, DWORD PTR _thumbsize$[ebp]
  01fd5	89 45 fc	 mov	 DWORD PTR _thumbpos$[ebp], eax
$L22703:

; 597  : 	}
; 598  : 
; 599  : 	thumbpos += startcoord + butsize;

  01fd8	8b 4d dc	 mov	 ecx, DWORD PTR _startcoord$[ebp]
  01fdb	03 4d f8	 add	 ecx, DWORD PTR _butsize$[ebp]
  01fde	03 4d fc	 add	 ecx, DWORD PTR _thumbpos$[ebp]
  01fe1	89 4d fc	 mov	 DWORD PTR _thumbpos$[ebp], ecx

; 600  : 
; 601  : 	*pthumbpos  = thumbpos;

  01fe4	8b 55 14	 mov	 edx, DWORD PTR _pthumbpos$[ebp]
  01fe7	8b 45 fc	 mov	 eax, DWORD PTR _thumbpos$[ebp]
  01fea	89 02		 mov	 DWORD PTR [edx], eax

; 602  : 	*pthumbsize = thumbsize;

  01fec	8b 4d 10	 mov	 ecx, DWORD PTR _pthumbsize$[ebp]
  01fef	8b 55 e0	 mov	 edx, DWORD PTR _thumbsize$[ebp]
  01ff2	89 11		 mov	 DWORD PTR [ecx], edx

; 603  : 
; 604  : 	return 1;

  01ff4	b8 01 00 00 00	 mov	 eax, 1

; 605  : }

  01ff9	8b e5		 mov	 esp, ebp
  01ffb	5d		 pop	 ebp
  01ffc	c3		 ret	 0
_CalcThumbSize ENDP
; Function compile flags: /Odt
_nmcd$ = -52						; size = 48
_ret$ = -4						; size = 4
_hwnd$ = 8						; size = 4
_hdc$ = 12						; size = 4
_sb$ = 16						; size = 4
_dwStage$ = 20						; size = 4
_PostCustomPrePostPaint0 PROC NEAR

; 684  : {

  02000	55		 push	 ebp
  02001	8b ec		 mov	 ebp, esp
  02003	83 ec 34	 sub	 esp, 52			; 00000034H

; 685  : #ifdef CUSTOM_DRAW
; 686  : 	NMCSBCUSTOMDRAW	nmcd;
; 687  : 	LRESULT ret;
; 688  : 
; 689  : 	CoolSB_ZeroMemory(&nmcd, sizeof nmcd);

  02006	6a 30		 push	 48			; 00000030H
  02008	8d 45 cc	 lea	 eax, DWORD PTR _nmcd$[ebp]
  0200b	50		 push	 eax
  0200c	e8 00 00 00 00	 call	 _CoolSB_ZeroMemory
  02011	83 c4 08	 add	 esp, 8

; 690  : 	nmcd.hdr.hwndFrom = hwnd;

  02014	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  02017	89 4d cc	 mov	 DWORD PTR _nmcd$[ebp], ecx

; 691  : 	nmcd.hdr.idFrom   = GetWindowLong(hwnd, GWL_ID);

  0201a	6a f4		 push	 -12			; fffffff4H
  0201c	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0201f	52		 push	 edx
  02020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  02026	89 45 d0	 mov	 DWORD PTR _nmcd$[ebp+4], eax

; 692  : 	nmcd.hdr.code     = NM_COOLSB_CUSTOMDRAW;

  02029	c7 45 d4 01 f0
	ff ff		 mov	 DWORD PTR _nmcd$[ebp+8], -4095 ; fffff001H

; 693  : 	nmcd.nBar		  = sb->nBarType;

  02030	8b 45 10	 mov	 eax, DWORD PTR _sb$[ebp]
  02033	8b 88 40 03 00
	00		 mov	 ecx, DWORD PTR [eax+832]
  02039	89 4d f8	 mov	 DWORD PTR _nmcd$[ebp+44], ecx

; 694  : 	nmcd.dwDrawStage  = dwStage;

  0203c	8b 55 14	 mov	 edx, DWORD PTR _dwStage$[ebp]
  0203f	89 55 d8	 mov	 DWORD PTR _nmcd$[ebp+12], edx

; 695  : 	nmcd.hdc		  = hdc;

  02042	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02045	89 45 dc	 mov	 DWORD PTR _nmcd$[ebp+16], eax

; 696  : 
; 697  : 	hwnd = GetParent(hwnd);

  02048	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0204b	51		 push	 ecx
  0204c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  02052	89 45 08	 mov	 DWORD PTR _hwnd$[ebp], eax

; 698  : 	ret = SendMessage(hwnd, WM_NOTIFY, 0, (LPARAM)&nmcd);

  02055	8d 55 cc	 lea	 edx, DWORD PTR _nmcd$[ebp]
  02058	52		 push	 edx
  02059	6a 00		 push	 0
  0205b	6a 4e		 push	 78			; 0000004eH
  0205d	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02060	50		 push	 eax
  02061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  02067	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 699  : 	return ret;

  0206a	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 700  : #else
; 701  : 	return 0;
; 702  : #endif
; 703  : }

  0206d	8b e5		 mov	 esp, ebp
  0206f	5d		 pop	 ebp
  02070	c3		 ret	 0
_PostCustomPrePostPaint0 ENDP
; Function compile flags: /Odt
_bptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_bytes$ = 12						; size = 4
_CoolSB_ZeroMemory PROC NEAR

; 98   : {

  02080	55		 push	 ebp
  02081	8b ec		 mov	 ebp, esp
  02083	51		 push	 ecx

; 99   : 	BYTE *bptr = (BYTE *)ptr;

  02084	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  02087	89 45 fc	 mov	 DWORD PTR _bptr$[ebp], eax
$L22453:

; 100  : 
; 101  : 	while(bytes--) *bptr++ = 0;

  0208a	8b 4d 0c	 mov	 ecx, DWORD PTR _bytes$[ebp]
  0208d	8b 55 0c	 mov	 edx, DWORD PTR _bytes$[ebp]
  02090	83 ea 01	 sub	 edx, 1
  02093	89 55 0c	 mov	 DWORD PTR _bytes$[ebp], edx
  02096	85 c9		 test	 ecx, ecx
  02098	74 11		 je	 SHORT $L22449
  0209a	8b 45 fc	 mov	 eax, DWORD PTR _bptr$[ebp]
  0209d	c6 00 00	 mov	 BYTE PTR [eax], 0
  020a0	8b 4d fc	 mov	 ecx, DWORD PTR _bptr$[ebp]
  020a3	83 c1 01	 add	 ecx, 1
  020a6	89 4d fc	 mov	 DWORD PTR _bptr$[ebp], ecx
  020a9	eb df		 jmp	 SHORT $L22453
$L22449:

; 102  : }

  020ab	8b e5		 mov	 esp, ebp
  020ad	5d		 pop	 ebp
  020ae	c3		 ret	 0
_CoolSB_ZeroMemory ENDP
; Function compile flags: /Odt
_ret$ = -20						; size = 4
_rc$ = -16						; size = 16
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_hdc$ = 16						; size = 4
_rect$ = 20						; size = 4
_uDrawFlags$ = 24					; size = 4
_NCDrawVScrollbar PROC NEAR

; 1074 : {

  020b0	55		 push	 ebp
  020b1	8b ec		 mov	 ebp, esp
  020b3	83 ec 14	 sub	 esp, 20			; 00000014H

; 1075 : 	LRESULT ret;
; 1076 : 	RECT rc;
; 1077 : 
; 1078 : 	rc = *rect;

  020b6	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  020b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  020bb	89 4d f0	 mov	 DWORD PTR _rc$[ebp], ecx
  020be	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  020c1	89 55 f4	 mov	 DWORD PTR _rc$[ebp+4], edx
  020c4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  020c7	89 4d f8	 mov	 DWORD PTR _rc$[ebp+8], ecx
  020ca	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  020cd	89 55 fc	 mov	 DWORD PTR _rc$[ebp+12], edx

; 1079 : 	RotateRect(&rc);

  020d0	8d 45 f0	 lea	 eax, DWORD PTR _rc$[ebp]
  020d3	50		 push	 eax
  020d4	e8 00 00 00 00	 call	 _RotateRect@4

; 1080 : 	ret = NCDrawHScrollbar(sb, hwnd, hdc, &rc, uDrawFlags);

  020d9	8b 4d 18	 mov	 ecx, DWORD PTR _uDrawFlags$[ebp]
  020dc	51		 push	 ecx
  020dd	8d 55 f0	 lea	 edx, DWORD PTR _rc$[ebp]
  020e0	52		 push	 edx
  020e1	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  020e4	50		 push	 eax
  020e5	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  020e8	51		 push	 ecx
  020e9	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  020ec	52		 push	 edx
  020ed	e8 00 00 00 00	 call	 _NCDrawHScrollbar
  020f2	83 c4 14	 add	 esp, 20			; 00000014H
  020f5	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 1081 : 	RotateRect(&rc);

  020f8	8d 45 f0	 lea	 eax, DWORD PTR _rc$[ebp]
  020fb	50		 push	 eax
  020fc	e8 00 00 00 00	 call	 _RotateRect@4

; 1082 : 	
; 1083 : 	return ret;

  02101	8b 45 ec	 mov	 eax, DWORD PTR _ret$[ebp]

; 1084 : }

  02104	8b e5		 mov	 esp, ebp
  02106	5d		 pop	 ebp
  02107	c3		 ret	 0
_NCDrawVScrollbar ENDP
; Function compile flags: /Odt
_butwidth$23020 = -40					; size = 4
_butwidth$23018 = -36					; size = 4
_xposl$ = -32						; size = 4
_ctrl$ = -28						; size = 16
_xposr$ = -12						; size = 4
_i$ = -8						; size = 4
_sbut$ = -4						; size = 4
_sbar$ = 8						; size = 4
_hdc$ = 12						; size = 4
_rect$ = 16						; size = 4
_leftright$ = 20					; size = 4
_DrawHorzButtons PROC NEAR

; 1336 : {

  02110	55		 push	 ebp
  02111	8b ec		 mov	 ebp, esp
  02113	83 ec 28	 sub	 esp, 40			; 00000028H

; 1337 : 	int i;
; 1338 : 	int xposl, xposr;
; 1339 : 	RECT ctrl;
; 1340 : 	SCROLLBUT *sbut = sbar->sbButtons;

  02116	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  02119	83 c0 2c	 add	 eax, 44			; 0000002cH
  0211c	89 45 fc	 mov	 DWORD PTR _sbut$[ebp], eax

; 1341 : 	
; 1342 : 	xposl = rect->left - sbar->nButSizeBefore;

  0211f	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  02122	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  02125	8b 01		 mov	 eax, DWORD PTR [ecx]
  02127	2b 82 30 03 00
	00		 sub	 eax, DWORD PTR [edx+816]
  0212d	89 45 e0	 mov	 DWORD PTR _xposl$[ebp], eax

; 1343 : 	xposr = rect->right;

  02130	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  02133	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  02136	89 55 f4	 mov	 DWORD PTR _xposr$[ebp], edx

; 1344 : 	
; 1345 : 	for(i = 0; i < sbar->nButtons; i++)

  02139	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  02140	eb 09		 jmp	 SHORT $L23014
$L23015:
  02142	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02145	83 c0 01	 add	 eax, 1
  02148	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L23014:
  0214b	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  0214e	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  02151	3b 91 2c 03 00
	00		 cmp	 edx, DWORD PTR [ecx+812]
  02157	0f 8d 11 01 00
	00		 jge	 $L23016

; 1346 : 	{
; 1347 : 		if((leftright & SBBP_LEFT) && sbut[i].uPlacement == SBBP_LEFT)

  0215d	8b 45 14	 mov	 eax, DWORD PTR _leftright$[ebp]
  02160	83 e0 01	 and	 eax, 1
  02163	74 7e		 je	 SHORT $L23017
  02165	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  02168	6b c9 30	 imul	 ecx, 48			; 00000030H
  0216b	8b 55 fc	 mov	 edx, DWORD PTR _sbut$[ebp]
  0216e	83 7c 0a 04 01	 cmp	 DWORD PTR [edx+ecx+4], 1
  02173	75 6e		 jne	 SHORT $L23017

; 1348 : 		{
; 1349 : 			int butwidth = GetSingleButSize(sbar, &sbut[i]);

  02175	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02178	6b c0 30	 imul	 eax, 48			; 00000030H
  0217b	03 45 fc	 add	 eax, DWORD PTR _sbut$[ebp]
  0217e	50		 push	 eax
  0217f	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  02182	51		 push	 ecx
  02183	e8 00 00 00 00	 call	 _GetSingleButSize
  02188	83 c4 08	 add	 esp, 8
  0218b	89 45 dc	 mov	 DWORD PTR _butwidth$23018[ebp], eax

; 1350 : 			SetRect(&ctrl, xposl, rect->top, xposl + butwidth, rect->bottom);

  0218e	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  02191	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  02194	50		 push	 eax
  02195	8b 4d e0	 mov	 ecx, DWORD PTR _xposl$[ebp]
  02198	03 4d dc	 add	 ecx, DWORD PTR _butwidth$23018[ebp]
  0219b	51		 push	 ecx
  0219c	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  0219f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  021a2	50		 push	 eax
  021a3	8b 4d e0	 mov	 ecx, DWORD PTR _xposl$[ebp]
  021a6	51		 push	 ecx
  021a7	8d 55 e4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  021aa	52		 push	 edx
  021ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 1351 : 			RotateRect0(sbar, &ctrl);

  021b1	8d 45 e4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  021b4	50		 push	 eax
  021b5	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  021b8	51		 push	 ecx
  021b9	e8 00 00 00 00	 call	 _RotateRect0@8

; 1352 : 			DrawScrollButton(&sbut[i], hdc, &ctrl, SBBS_NORMAL);

  021be	6a 00		 push	 0
  021c0	8d 55 e4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  021c3	52		 push	 edx
  021c4	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  021c7	50		 push	 eax
  021c8	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  021cb	6b c9 30	 imul	 ecx, 48			; 00000030H
  021ce	03 4d fc	 add	 ecx, DWORD PTR _sbut$[ebp]
  021d1	51		 push	 ecx
  021d2	e8 00 00 00 00	 call	 _DrawScrollButton
  021d7	83 c4 10	 add	 esp, 16			; 00000010H

; 1353 : 			
; 1354 : 			xposl += butwidth;

  021da	8b 55 e0	 mov	 edx, DWORD PTR _xposl$[ebp]
  021dd	03 55 dc	 add	 edx, DWORD PTR _butwidth$23018[ebp]
  021e0	89 55 e0	 mov	 DWORD PTR _xposl$[ebp], edx
$L23017:

; 1355 : 		}
; 1356 : 
; 1357 : 		if((leftright & SBBP_RIGHT) && sbut[i].uPlacement == SBBP_RIGHT)

  021e3	8b 45 14	 mov	 eax, DWORD PTR _leftright$[ebp]
  021e6	83 e0 02	 and	 eax, 2
  021e9	74 7e		 je	 SHORT $L23019
  021eb	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  021ee	6b c9 30	 imul	 ecx, 48			; 00000030H
  021f1	8b 55 fc	 mov	 edx, DWORD PTR _sbut$[ebp]
  021f4	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  021f9	75 6e		 jne	 SHORT $L23019

; 1358 : 		{
; 1359 : 			int butwidth = GetSingleButSize(sbar, &sbut[i]);

  021fb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  021fe	6b c0 30	 imul	 eax, 48			; 00000030H
  02201	03 45 fc	 add	 eax, DWORD PTR _sbut$[ebp]
  02204	50		 push	 eax
  02205	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  02208	51		 push	 ecx
  02209	e8 00 00 00 00	 call	 _GetSingleButSize
  0220e	83 c4 08	 add	 esp, 8
  02211	89 45 d8	 mov	 DWORD PTR _butwidth$23020[ebp], eax

; 1360 : 			SetRect(&ctrl, xposr, rect->top, xposr + butwidth, rect->bottom);

  02214	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  02217	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0221a	50		 push	 eax
  0221b	8b 4d f4	 mov	 ecx, DWORD PTR _xposr$[ebp]
  0221e	03 4d d8	 add	 ecx, DWORD PTR _butwidth$23020[ebp]
  02221	51		 push	 ecx
  02222	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  02225	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  02228	50		 push	 eax
  02229	8b 4d f4	 mov	 ecx, DWORD PTR _xposr$[ebp]
  0222c	51		 push	 ecx
  0222d	8d 55 e4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  02230	52		 push	 edx
  02231	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 1361 : 			RotateRect0(sbar, &ctrl);

  02237	8d 45 e4	 lea	 eax, DWORD PTR _ctrl$[ebp]
  0223a	50		 push	 eax
  0223b	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  0223e	51		 push	 ecx
  0223f	e8 00 00 00 00	 call	 _RotateRect0@8

; 1362 : 			DrawScrollButton(&sbut[i], hdc, &ctrl, SBBS_NORMAL);

  02244	6a 00		 push	 0
  02246	8d 55 e4	 lea	 edx, DWORD PTR _ctrl$[ebp]
  02249	52		 push	 edx
  0224a	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  0224d	50		 push	 eax
  0224e	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  02251	6b c9 30	 imul	 ecx, 48			; 00000030H
  02254	03 4d fc	 add	 ecx, DWORD PTR _sbut$[ebp]
  02257	51		 push	 ecx
  02258	e8 00 00 00 00	 call	 _DrawScrollButton
  0225d	83 c4 10	 add	 esp, 16			; 00000010H

; 1363 : 			xposr += butwidth;

  02260	8b 55 f4	 mov	 edx, DWORD PTR _xposr$[ebp]
  02263	03 55 d8	 add	 edx, DWORD PTR _butwidth$23020[ebp]
  02266	89 55 f4	 mov	 DWORD PTR _xposr$[ebp], edx
$L23019:

; 1364 : 		}
; 1365 : 	}

  02269	e9 d4 fe ff ff	 jmp	 $L23015
$L23016:

; 1366 : 	return 0;

  0226e	33 c0		 xor	 eax, eax

; 1367 : }

  02270	8b e5		 mov	 esp, ebp
  02272	5d		 pop	 ebp
  02273	c3		 ret	 0
_DrawHorzButtons ENDP
_TEXT	ENDS
EXTRN	__imp__FrameRect@12:NEAR
EXTRN	__imp__InflateRect@12:NEAR
EXTRN	__imp__IntersectClipRect@20:NEAR
EXTRN	__imp__SelectClipRgn@8:NEAR
EXTRN	__imp__WindowFromDC@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv67 = -76						; size = 4
_nmcd$ = -72						; size = 48
_hwnd$ = -24						; size = 4
_f$ = -20						; size = 4
_rect$ = -16						; size = 16
_sbut$ = 8						; size = 4
_hdc$ = 12						; size = 4
_pctrl$ = 16						; size = 4
_flags$ = 20						; size = 4
_DrawScrollButton PROC NEAR

; 1174 : {

  02280	55		 push	 ebp
  02281	8b ec		 mov	 ebp, esp
  02283	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 1175 : 	NMCSBCUSTOMDRAW	nmcd;
; 1176 : 	HWND hwnd;
; 1177 : 	RECT rect = *pctrl;

  02286	8b 45 10	 mov	 eax, DWORD PTR _pctrl$[ebp]
  02289	8b 08		 mov	 ecx, DWORD PTR [eax]
  0228b	89 4d f0	 mov	 DWORD PTR _rect$[ebp], ecx
  0228e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  02291	89 55 f4	 mov	 DWORD PTR _rect$[ebp+4], edx
  02294	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  02297	89 4d f8	 mov	 DWORD PTR _rect$[ebp+8], ecx
  0229a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0229d	89 55 fc	 mov	 DWORD PTR _rect$[ebp+12], edx

; 1178 : 	UINT f;
; 1179 : 
; 1180 : 	switch(sbut->uButType & SBBT_MASK)

  022a0	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  022a3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  022a6	83 e1 1f	 and	 ecx, 31			; 0000001fH
  022a9	89 4d b4	 mov	 DWORD PTR tv67[ebp], ecx
  022ac	8b 55 b4	 mov	 edx, DWORD PTR tv67[ebp]
  022af	83 ea 01	 sub	 edx, 1
  022b2	89 55 b4	 mov	 DWORD PTR tv67[ebp], edx
  022b5	83 7d b4 06	 cmp	 DWORD PTR tv67[ebp], 6
  022b9	0f 87 33 04 00
	00		 ja	 $L22964
  022bf	8b 45 b4	 mov	 eax, DWORD PTR tv67[ebp]
  022c2	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L23909[eax*4]
$L22967:

; 1181 : 	{
; 1182 : 	case SBBT_OWNERDRAW:
; 1183 : 
; 1184 : 		hwnd = WindowFromDC(hdc);

  022c9	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  022cc	51		 push	 ecx
  022cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WindowFromDC@4
  022d3	89 45 e8	 mov	 DWORD PTR _hwnd$[ebp], eax

; 1185 : 
; 1186 : 		//fill in the standard header
; 1187 : 		nmcd.hdr.hwndFrom = hwnd;

  022d6	8b 55 e8	 mov	 edx, DWORD PTR _hwnd$[ebp]
  022d9	89 55 b8	 mov	 DWORD PTR _nmcd$[ebp], edx

; 1188 : 		nmcd.hdr.idFrom   = GetWindowLong(hwnd, GWL_ID);

  022dc	6a f4		 push	 -12			; fffffff4H
  022de	8b 45 e8	 mov	 eax, DWORD PTR _hwnd$[ebp]
  022e1	50		 push	 eax
  022e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  022e8	89 45 bc	 mov	 DWORD PTR _nmcd$[ebp+4], eax

; 1189 : 		nmcd.hdr.code     = NM_COOLSB_CUSTOMDRAW;

  022eb	c7 45 c0 01 f0
	ff ff		 mov	 DWORD PTR _nmcd$[ebp+8], -4095 ; fffff001H

; 1190 : 
; 1191 : 		nmcd.dwDrawStage  = CDDS_ITEMPREPAINT;

  022f2	c7 45 c4 01 00
	01 00		 mov	 DWORD PTR _nmcd$[ebp+12], 65537 ; 00010001H

; 1192 : 		nmcd.nBar		  = SB_INSBUT;

  022f9	c7 45 e4 fe ff
	ff ff		 mov	 DWORD PTR _nmcd$[ebp+44], -2 ; fffffffeH

; 1193 : 		nmcd.rect		  = *pctrl;

  02300	8b 4d 10	 mov	 ecx, DWORD PTR _pctrl$[ebp]
  02303	8b 11		 mov	 edx, DWORD PTR [ecx]
  02305	89 55 cc	 mov	 DWORD PTR _nmcd$[ebp+20], edx
  02308	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0230b	89 45 d0	 mov	 DWORD PTR _nmcd$[ebp+24], eax
  0230e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  02311	89 55 d4	 mov	 DWORD PTR _nmcd$[ebp+28], edx
  02314	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  02317	89 45 d8	 mov	 DWORD PTR _nmcd$[ebp+32], eax

; 1194 : 		nmcd.uItem		  = sbut->uCmdId;

  0231a	8b 4d 08	 mov	 ecx, DWORD PTR _sbut$[ebp]
  0231d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  02320	89 55 dc	 mov	 DWORD PTR _nmcd$[ebp+36], edx

; 1195 : 		nmcd.hdc		  = hdc;

  02323	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02326	89 45 c8	 mov	 DWORD PTR _nmcd$[ebp+16], eax

; 1196 : 		nmcd.uState		  = flags;

  02329	8b 4d 14	 mov	 ecx, DWORD PTR _flags$[ebp]
  0232c	89 4d e0	 mov	 DWORD PTR _nmcd$[ebp+40], ecx

; 1197 : 
; 1198 : 		IntersectClipRect(hdc, rect.left, rect.top, rect.right, rect.bottom);

  0232f	8b 55 fc	 mov	 edx, DWORD PTR _rect$[ebp+12]
  02332	52		 push	 edx
  02333	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp+8]
  02336	50		 push	 eax
  02337	8b 4d f4	 mov	 ecx, DWORD PTR _rect$[ebp+4]
  0233a	51		 push	 ecx
  0233b	8b 55 f0	 mov	 edx, DWORD PTR _rect$[ebp]
  0233e	52		 push	 edx
  0233f	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02342	50		 push	 eax
  02343	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IntersectClipRect@20

; 1199 : 		SendMessage(GetParent(hwnd), WM_NOTIFY, nmcd.hdr.idFrom, (LPARAM)&nmcd);

  02349	8d 4d b8	 lea	 ecx, DWORD PTR _nmcd$[ebp]
  0234c	51		 push	 ecx
  0234d	8b 55 bc	 mov	 edx, DWORD PTR _nmcd$[ebp+4]
  02350	52		 push	 edx
  02351	6a 4e		 push	 78			; 0000004eH
  02353	8b 45 e8	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02356	50		 push	 eax
  02357	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0235d	50		 push	 eax
  0235e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 1200 : 		SelectClipRgn(hdc, NULL);

  02364	6a 00		 push	 0
  02366	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02369	51		 push	 ecx
  0236a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectClipRgn@8

; 1201 : 
; 1202 : 		break;

  02370	e9 7d 03 00 00	 jmp	 $L22964
$L22970:

; 1203 : 
; 1204 : 	case SBBT_FIXED:
; 1205 : 		flags &= ~SBBS_PUSHED;

  02375	8b 55 14	 mov	 edx, DWORD PTR _flags$[ebp]
  02378	83 e2 fe	 and	 edx, -2			; fffffffeH
  0237b	89 55 14	 mov	 DWORD PTR _flags$[ebp], edx
$L22971:

; 1206 : 
; 1207 : 	case SBBT_TOGGLEBUTTON:
; 1208 : 		if(sbut->uState != SBBS_NORMAL)

  0237e	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  02381	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  02385	74 09		 je	 SHORT $L22973

; 1209 : 			flags |= SBBS_PUSHED;

  02387	8b 4d 14	 mov	 ecx, DWORD PTR _flags$[ebp]
  0238a	83 c9 01	 or	 ecx, 1
  0238d	89 4d 14	 mov	 DWORD PTR _flags$[ebp], ecx
$L22973:

; 1210 : 
; 1211 : 		//intentionally fall through here...
; 1212 : 
; 1213 : 	case SBBT_PUSHBUTTON: 
; 1214 : 		
; 1215 : 		f = flags & SBBS_PUSHED ? DFCS_PUSHED | DFCS_FLAT : 0;

  02390	8b 55 14	 mov	 edx, DWORD PTR _flags$[ebp]
  02393	83 e2 01	 and	 edx, 1
  02396	f7 da		 neg	 edx
  02398	1b d2		 sbb	 edx, edx
  0239a	81 e2 00 42 00
	00		 and	 edx, 16896		; 00004200H
  023a0	89 55 ec	 mov	 DWORD PTR _f$[ebp], edx

; 1216 : 		if(sbut->uButType & SBBM_LEFTARROW)

  023a3	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  023a6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  023a9	83 e1 40	 and	 ecx, 64			; 00000040H
  023ac	74 1c		 je	 SHORT $L22974

; 1217 : 		{
; 1218 : 			DrawFrameControl(hdc, &rect, DFC_SCROLL, DFCS_SCROLLLEFT | f);

  023ae	8b 55 ec	 mov	 edx, DWORD PTR _f$[ebp]
  023b1	83 ca 02	 or	 edx, 2
  023b4	52		 push	 edx
  023b5	6a 03		 push	 3
  023b7	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  023ba	50		 push	 eax
  023bb	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  023be	51		 push	 ecx
  023bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16

; 1219 : 		}
; 1220 : 		else if(sbut->uButType & SBBM_RIGHTARROW)

  023c5	e9 db 02 00 00	 jmp	 $L22975
$L22974:
  023ca	8b 55 08	 mov	 edx, DWORD PTR _sbut$[ebp]
  023cd	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  023d0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  023d5	74 1c		 je	 SHORT $L22976

; 1221 : 		{
; 1222 : 			DrawFrameControl(hdc, &rect, DFC_SCROLL, DFCS_SCROLLRIGHT | f);

  023d7	8b 4d ec	 mov	 ecx, DWORD PTR _f$[ebp]
  023da	83 c9 03	 or	 ecx, 3
  023dd	51		 push	 ecx
  023de	6a 03		 push	 3
  023e0	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  023e3	52		 push	 edx
  023e4	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  023e7	50		 push	 eax
  023e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16

; 1223 : 		}
; 1224 : 		else if(sbut->uButType & SBBM_UPARROW)

  023ee	e9 b2 02 00 00	 jmp	 $L22975
$L22976:
  023f3	8b 4d 08	 mov	 ecx, DWORD PTR _sbut$[ebp]
  023f6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  023f9	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  023ff	74 19		 je	 SHORT $L22978

; 1225 : 		{
; 1226 : 			DrawFrameControl(hdc, &rect, DFC_SCROLL, DFCS_SCROLLUP | f);

  02401	8b 45 ec	 mov	 eax, DWORD PTR _f$[ebp]
  02404	50		 push	 eax
  02405	6a 03		 push	 3
  02407	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  0240a	51		 push	 ecx
  0240b	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  0240e	52		 push	 edx
  0240f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16

; 1227 : 		}
; 1228 : 		else if(sbut->uButType & SBBM_DOWNARROW)

  02415	e9 8b 02 00 00	 jmp	 $L22975
$L22978:
  0241a	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  0241d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02420	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  02426	74 1c		 je	 SHORT $L22980

; 1229 : 		{
; 1230 : 			DrawFrameControl(hdc, &rect, DFC_SCROLL, DFCS_SCROLLDOWN | f);

  02428	8b 55 ec	 mov	 edx, DWORD PTR _f$[ebp]
  0242b	83 ca 01	 or	 edx, 1
  0242e	52		 push	 edx
  0242f	6a 03		 push	 3
  02431	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  02434	50		 push	 eax
  02435	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02438	51		 push	 ecx
  02439	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16

; 1231 : 		}
; 1232 : 		else

  0243f	e9 61 02 00 00	 jmp	 $L22975
$L22980:

; 1233 : 		{
; 1234 : 			//
; 1235 : 			if(flags & SBBS_PUSHED)

  02444	8b 55 14	 mov	 edx, DWORD PTR _flags$[ebp]
  02447	83 e2 01	 and	 edx, 1
  0244a	0f 84 8b 00 00
	00		 je	 $L22982

; 1236 : 			{
; 1237 : 				if(sbut->uButType & SBBM_RECESSED)

  02450	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  02453	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02456	83 e1 20	 and	 ecx, 32			; 00000020H
  02459	74 58		 je	 SHORT $L22983

; 1238 : 				{
; 1239 : 					InflateRect(&rect, -1, -1);

  0245b	6a ff		 push	 -1
  0245d	6a ff		 push	 -1
  0245f	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  02462	52		 push	 edx
  02463	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12

; 1240 : 					DrawEdge(hdc, &rect, EDGE_SUNKEN, BF_RECT|BF_FLAT);

  02469	68 0f 40 00 00	 push	 16399			; 0000400fH
  0246e	6a 0a		 push	 10			; 0000000aH
  02470	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  02473	50		 push	 eax
  02474	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02477	51		 push	 ecx
  02478	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawEdge@16

; 1241 : 					InflateRect(&rect, 1, 1);

  0247e	6a 01		 push	 1
  02480	6a 01		 push	 1
  02482	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  02485	52		 push	 edx
  02486	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12

; 1242 : 
; 1243 : 					FrameRect(hdc, &rect, GetSysColorBrush(COLOR_3DDKSHADOW));

  0248c	6a 15		 push	 21			; 00000015H
  0248e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColorBrush@4
  02494	50		 push	 eax
  02495	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  02498	50		 push	 eax
  02499	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0249c	51		 push	 ecx
  0249d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FrameRect@12

; 1244 : 					InflateRect(&rect, -2, -2);

  024a3	6a fe		 push	 -2			; fffffffeH
  024a5	6a fe		 push	 -2			; fffffffeH
  024a7	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  024aa	52		 push	 edx
  024ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12

; 1245 : 				}
; 1246 : 				else

  024b1	eb 23		 jmp	 SHORT $L22984
$L22983:

; 1247 : 				{
; 1248 : 					DrawEdge(hdc, &rect, EDGE_SUNKEN, BF_RECT | BF_FLAT | BF_ADJUST);

  024b3	68 0f 60 00 00	 push	 24591			; 0000600fH
  024b8	6a 0a		 push	 10			; 0000000aH
  024ba	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  024bd	50		 push	 eax
  024be	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  024c1	51		 push	 ecx
  024c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawEdge@16

; 1249 : 					InflateRect(&rect, 1, 1);

  024c8	6a 01		 push	 1
  024ca	6a 01		 push	 1
  024cc	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  024cf	52		 push	 edx
  024d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12
$L22984:

; 1250 : 				}
; 1251 : 			}
; 1252 : 			else

  024d6	e9 a6 00 00 00	 jmp	 $L22985
$L22982:

; 1253 : 			{
; 1254 : 				// draw the button borders
; 1255 : 				if(sbut->uButType & SBBM_TYPE2)

  024db	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  024de	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  024e1	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  024e7	74 22		 je	 SHORT $L22986

; 1256 : 				{
; 1257 : 					DrawFrameControl(hdc, &rect, DFC_BUTTON, DFCS_BUTTONPUSH);

  024e9	6a 10		 push	 16			; 00000010H
  024eb	6a 04		 push	 4
  024ed	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  024f0	52		 push	 edx
  024f1	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  024f4	50		 push	 eax
  024f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16

; 1258 : 					InflateRect(&rect, -2, -2);

  024fb	6a fe		 push	 -2			; fffffffeH
  024fd	6a fe		 push	 -2			; fffffffeH
  024ff	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  02502	51		 push	 ecx
  02503	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12

; 1259 : 				}
; 1260 : 
; 1261 : 				else if(sbut->uButType & SBBM_TYPE3)

  02509	eb 56		 jmp	 SHORT $L22987
$L22986:
  0250b	8b 55 08	 mov	 edx, DWORD PTR _sbut$[ebp]
  0250e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  02511	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  02516	74 22		 je	 SHORT $L22988

; 1262 : 				{
; 1263 : 					DrawFrameControl(hdc, &rect, DFC_BUTTON, DFCS_BUTTONPUSH);

  02518	6a 10		 push	 16			; 00000010H
  0251a	6a 04		 push	 4
  0251c	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  0251f	51		 push	 ecx
  02520	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  02523	52		 push	 edx
  02524	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16

; 1264 : 					InflateRect(&rect, -1, -1);

  0252a	6a ff		 push	 -1
  0252c	6a ff		 push	 -1
  0252e	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  02531	50		 push	 eax
  02532	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12

; 1265 : 				}
; 1266 : 				else

  02538	eb 27		 jmp	 SHORT $L22987
$L22988:

; 1267 : 				{
; 1268 : 					DrawEdge(hdc, &rect, EDGE_RAISED, BF_RECT | BF_ADJUST);

  0253a	68 0f 20 00 00	 push	 8207			; 0000200fH
  0253f	6a 05		 push	 5
  02541	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  02544	51		 push	 ecx
  02545	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  02548	52		 push	 edx
  02549	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawEdge@16

; 1269 : 					rect.bottom++;

  0254f	8b 45 fc	 mov	 eax, DWORD PTR _rect$[ebp+12]
  02552	83 c0 01	 add	 eax, 1
  02555	89 45 fc	 mov	 DWORD PTR _rect$[ebp+12], eax

; 1270 : 					rect.right++;

  02558	8b 4d f8	 mov	 ecx, DWORD PTR _rect$[ebp+8]
  0255b	83 c1 01	 add	 ecx, 1
  0255e	89 4d f8	 mov	 DWORD PTR _rect$[ebp+8], ecx
$L22987:

; 1271 : 				}
; 1272 : 			
; 1273 : 				OffsetRect(&rect, -1, -1);

  02561	6a ff		 push	 -1
  02563	6a ff		 push	 -1
  02565	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  02568	52		 push	 edx
  02569	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 1274 : 				rect.top++;	rect.left++;

  0256f	8b 45 f4	 mov	 eax, DWORD PTR _rect$[ebp+4]
  02572	83 c0 01	 add	 eax, 1
  02575	89 45 f4	 mov	 DWORD PTR _rect$[ebp+4], eax
  02578	8b 4d f0	 mov	 ecx, DWORD PTR _rect$[ebp]
  0257b	83 c1 01	 add	 ecx, 1
  0257e	89 4d f0	 mov	 DWORD PTR _rect$[ebp], ecx
$L22985:

; 1275 : 			}
; 1276 : 
; 1277 : 			if(sbut->hBmp)

  02581	8b 55 08	 mov	 edx, DWORD PTR _sbut$[ebp]
  02584	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  02588	74 75		 je	 SHORT $L22990

; 1278 : 			{
; 1279 : 				PaintRect(hdc, &rect, GetSysColor(COLOR_3DFACE));

  0258a	6a 0f		 push	 15			; 0000000fH
  0258c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  02592	50		 push	 eax
  02593	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  02596	50		 push	 eax
  02597	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0259a	51		 push	 ecx
  0259b	e8 00 00 00 00	 call	 _PaintRect
  025a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1280 : 
; 1281 : 				if(flags & SBBS_PUSHED)	

  025a3	8b 55 14	 mov	 edx, DWORD PTR _flags$[ebp]
  025a6	83 e2 01	 and	 edx, 1
  025a9	74 12		 je	 SHORT $L22991

; 1282 : 				{
; 1283 : 					rect.top++; rect.left++;

  025ab	8b 45 f4	 mov	 eax, DWORD PTR _rect$[ebp+4]
  025ae	83 c0 01	 add	 eax, 1
  025b1	89 45 f4	 mov	 DWORD PTR _rect$[ebp+4], eax
  025b4	8b 4d f0	 mov	 ecx, DWORD PTR _rect$[ebp]
  025b7	83 c1 01	 add	 ecx, 1
  025ba	89 4d f0	 mov	 DWORD PTR _rect$[ebp], ecx
$L22991:

; 1284 : 				}
; 1285 : 
; 1286 : 				IntersectClipRect(hdc, rect.left, rect.top, rect.right,rect.bottom);

  025bd	8b 55 fc	 mov	 edx, DWORD PTR _rect$[ebp+12]
  025c0	52		 push	 edx
  025c1	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp+8]
  025c4	50		 push	 eax
  025c5	8b 4d f4	 mov	 ecx, DWORD PTR _rect$[ebp+4]
  025c8	51		 push	 ecx
  025c9	8b 55 f0	 mov	 edx, DWORD PTR _rect$[ebp]
  025cc	52		 push	 edx
  025cd	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  025d0	50		 push	 eax
  025d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IntersectClipRect@20

; 1287 : 				DrawImage(hdc, sbut->hBmp, &rect);

  025d7	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  025da	51		 push	 ecx
  025db	8b 55 08	 mov	 edx, DWORD PTR _sbut$[ebp]
  025de	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  025e1	50		 push	 eax
  025e2	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  025e5	51		 push	 ecx
  025e6	e8 00 00 00 00	 call	 _DrawImage
  025eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1288 : 				SelectClipRgn(hdc, 0);

  025ee	6a 00		 push	 0
  025f0	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  025f3	52		 push	 edx
  025f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectClipRgn@8

; 1289 : 			}
; 1290 : 			else if(sbut->hEmf)

  025fa	e9 a6 00 00 00	 jmp	 $L22975
$L22990:
  025ff	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  02602	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  02606	0f 84 80 00 00
	00		 je	 $L22993

; 1291 : 			{
; 1292 : 				PaintRect(hdc, &rect, GetSysColor(COLOR_3DFACE));

  0260c	6a 0f		 push	 15			; 0000000fH
  0260e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  02614	50		 push	 eax
  02615	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  02618	51		 push	 ecx
  02619	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  0261c	52		 push	 edx
  0261d	e8 00 00 00 00	 call	 _PaintRect
  02622	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1293 : 				InflateRect(&rect, -1, -1);		

  02625	6a ff		 push	 -1
  02627	6a ff		 push	 -1
  02629	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  0262c	50		 push	 eax
  0262d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12

; 1294 : 
; 1295 : 				if(flags & SBBS_PUSHED)	

  02633	8b 4d 14	 mov	 ecx, DWORD PTR _flags$[ebp]
  02636	83 e1 01	 and	 ecx, 1
  02639	74 12		 je	 SHORT $L22994

; 1296 : 				{
; 1297 : 					rect.top++; rect.left++;

  0263b	8b 55 f4	 mov	 edx, DWORD PTR _rect$[ebp+4]
  0263e	83 c2 01	 add	 edx, 1
  02641	89 55 f4	 mov	 DWORD PTR _rect$[ebp+4], edx
  02644	8b 45 f0	 mov	 eax, DWORD PTR _rect$[ebp]
  02647	83 c0 01	 add	 eax, 1
  0264a	89 45 f0	 mov	 DWORD PTR _rect$[ebp], eax
$L22994:

; 1298 : 				}
; 1299 : 
; 1300 : 				IntersectClipRect(hdc, rect.left, rect.top, rect.right,rect.bottom);

  0264d	8b 4d fc	 mov	 ecx, DWORD PTR _rect$[ebp+12]
  02650	51		 push	 ecx
  02651	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp+8]
  02654	52		 push	 edx
  02655	8b 45 f4	 mov	 eax, DWORD PTR _rect$[ebp+4]
  02658	50		 push	 eax
  02659	8b 4d f0	 mov	 ecx, DWORD PTR _rect$[ebp]
  0265c	51		 push	 ecx
  0265d	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  02660	52		 push	 edx
  02661	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IntersectClipRect@20

; 1301 : 				DrawMetaFile(hdc, sbut->hEmf, &rect);

  02667	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  0266a	50		 push	 eax
  0266b	8b 4d 08	 mov	 ecx, DWORD PTR _sbut$[ebp]
  0266e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  02671	52		 push	 edx
  02672	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02675	50		 push	 eax
  02676	e8 00 00 00 00	 call	 _DrawMetaFile
  0267b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1302 : 				SelectClipRgn(hdc, 0);

  0267e	6a 00		 push	 0
  02680	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02683	51		 push	 ecx
  02684	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectClipRgn@8

; 1303 : 			}
; 1304 : 			else

  0268a	eb 19		 jmp	 SHORT $L22975
$L22993:

; 1305 : 			{
; 1306 : 				PaintRect(hdc, &rect, GetSysColor(COLOR_3DFACE));

  0268c	6a 0f		 push	 15			; 0000000fH
  0268e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  02694	50		 push	 eax
  02695	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  02698	52		 push	 edx
  02699	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  0269c	50		 push	 eax
  0269d	e8 00 00 00 00	 call	 _PaintRect
  026a2	83 c4 0c	 add	 esp, 12			; 0000000cH
$L22975:

; 1307 : 			}
; 1308 : 		}
; 1309 : 			
; 1310 : 
; 1311 : 		break;

  026a5	eb 4b		 jmp	 SHORT $L22964
$L22996:

; 1312 : 
; 1313 : 	case SBBT_BLANK:
; 1314 : 		PaintRect(hdc, &rect, GetSysColor(COLOR_3DFACE));

  026a7	6a 0f		 push	 15			; 0000000fH
  026a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  026af	50		 push	 eax
  026b0	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  026b3	51		 push	 ecx
  026b4	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  026b7	52		 push	 edx
  026b8	e8 00 00 00 00	 call	 _PaintRect
  026bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1315 : 		break;

  026c0	eb 30		 jmp	 SHORT $L22964
$L22997:

; 1316 : 
; 1317 : 	case SBBT_FLAT:
; 1318 : 		DrawBlankButton(hdc, &rect, BF_FLAT);

  026c2	68 00 40 00 00	 push	 16384			; 00004000H
  026c7	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  026ca	50		 push	 eax
  026cb	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  026ce	51		 push	 ecx
  026cf	e8 00 00 00 00	 call	 _DrawBlankButton
  026d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1319 : 		break;

  026d7	eb 19		 jmp	 SHORT $L22964
$L22998:

; 1320 : 
; 1321 : 	case SBBT_DARK:
; 1322 : 		PaintRect(hdc, &rect, GetSysColor(COLOR_3DDKSHADOW));

  026d9	6a 15		 push	 21			; 00000015H
  026db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  026e1	50		 push	 eax
  026e2	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  026e5	52		 push	 edx
  026e6	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  026e9	50		 push	 eax
  026ea	e8 00 00 00 00	 call	 _PaintRect
  026ef	83 c4 0c	 add	 esp, 12			; 0000000cH
$L22964:

; 1323 : 		break;
; 1324 : 	}
; 1325 : 	
; 1326 : 	return 0;

  026f2	33 c0		 xor	 eax, eax

; 1327 : }

  026f4	8b e5		 mov	 esp, ebp
  026f6	5d		 pop	 ebp
  026f7	c3		 ret	 0
$L23909:
  026f8	00 00 00 00	 DD	 $L22973
  026fc	00 00 00 00	 DD	 $L22971
  02700	00 00 00 00	 DD	 $L22970
  02704	00 00 00 00	 DD	 $L22997
  02708	00 00 00 00	 DD	 $L22996
  0270c	00 00 00 00	 DD	 $L22998
  02710	00 00 00 00	 DD	 $L22967
_DrawScrollButton ENDP
_TEXT	ENDS
EXTRN	__imp__GetObjectA@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_bm$ = -76						; size = 24
_memdc$ = -52						; size = 4
_delta$ = -48						; size = 8
_cy$ = -40						; size = 4
_rcDest$ = -36						; size = 16
_colorOld$ = -20					; size = 4
_hOldBM$ = -16						; size = 4
_cx$ = -12						; size = 4
_p$ = -8						; size = 8
_hdc$ = 8						; size = 4
_hBitmap$ = 12						; size = 4
_rc$ = 16						; size = 4
_DrawImage PROC NEAR

; 1103 : {

  02720	55		 push	 ebp
  02721	8b ec		 mov	 ebp, esp
  02723	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 1104 : 	BITMAP bm;
; 1105 : 	int cx;
; 1106 : 	int cy;   
; 1107 : 	HDC memdc;
; 1108 : 	HBITMAP hOldBM;
; 1109 : 	RECT  rcDest = *rc;   

  02726	8b 45 10	 mov	 eax, DWORD PTR _rc$[ebp]
  02729	8b 08		 mov	 ecx, DWORD PTR [eax]
  0272b	89 4d dc	 mov	 DWORD PTR _rcDest$[ebp], ecx
  0272e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  02731	89 55 e0	 mov	 DWORD PTR _rcDest$[ebp+4], edx
  02734	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  02737	89 4d e4	 mov	 DWORD PTR _rcDest$[ebp+8], ecx
  0273a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0273d	89 55 e8	 mov	 DWORD PTR _rcDest$[ebp+12], edx

; 1110 : 	POINT p;
; 1111 : 	SIZE  delta;
; 1112 : 	COLORREF colorOld;
; 1113 : 
; 1114 : 	if(hBitmap == NULL) 

  02740	83 7d 0c 00	 cmp	 DWORD PTR _hBitmap$[ebp], 0
  02744	75 05		 jne	 SHORT $L22934

; 1115 : 		return;

  02746	e9 37 01 00 00	 jmp	 $L22923
$L22934:

; 1116 : 
; 1117 : 	// center bitmap in caller's rectangle   
; 1118 : 	GetObject(hBitmap, sizeof bm, &bm);   

  0274b	8d 45 b4	 lea	 eax, DWORD PTR _bm$[ebp]
  0274e	50		 push	 eax
  0274f	6a 18		 push	 24			; 00000018H
  02751	8b 4d 0c	 mov	 ecx, DWORD PTR _hBitmap$[ebp]
  02754	51		 push	 ecx
  02755	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetObjectA@12

; 1119 : 	
; 1120 : 	cx = bm.bmWidth;

  0275b	8b 55 b8	 mov	 edx, DWORD PTR _bm$[ebp+4]
  0275e	89 55 f4	 mov	 DWORD PTR _cx$[ebp], edx

; 1121 : 	cy = bm.bmHeight;

  02761	8b 45 bc	 mov	 eax, DWORD PTR _bm$[ebp+8]
  02764	89 45 d8	 mov	 DWORD PTR _cy$[ebp], eax

; 1122 : 
; 1123 : 	delta.cx = (rc->right-rc->left - cx) / 2;

  02767	8b 4d 10	 mov	 ecx, DWORD PTR _rc$[ebp]
  0276a	8b 55 10	 mov	 edx, DWORD PTR _rc$[ebp]
  0276d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  02770	2b 02		 sub	 eax, DWORD PTR [edx]
  02772	2b 45 f4	 sub	 eax, DWORD PTR _cx$[ebp]
  02775	99		 cdq
  02776	2b c2		 sub	 eax, edx
  02778	d1 f8		 sar	 eax, 1
  0277a	89 45 d0	 mov	 DWORD PTR _delta$[ebp], eax

; 1124 : 	delta.cy = (rc->bottom-rc->top - cy) / 2;

  0277d	8b 45 10	 mov	 eax, DWORD PTR _rc$[ebp]
  02780	8b 4d 10	 mov	 ecx, DWORD PTR _rc$[ebp]
  02783	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  02786	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  02789	2b 45 d8	 sub	 eax, DWORD PTR _cy$[ebp]
  0278c	99		 cdq
  0278d	2b c2		 sub	 eax, edx
  0278f	d1 f8		 sar	 eax, 1
  02791	89 45 d4	 mov	 DWORD PTR _delta$[ebp+4], eax

; 1125 : 	
; 1126 : 	if(rc->right-rc->left > cx)

  02794	8b 55 10	 mov	 edx, DWORD PTR _rc$[ebp]
  02797	8b 45 10	 mov	 eax, DWORD PTR _rc$[ebp]
  0279a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0279d	2b 08		 sub	 ecx, DWORD PTR [eax]
  0279f	3b 4d f4	 cmp	 ecx, DWORD PTR _cx$[ebp]
  027a2	7e 43		 jle	 SHORT $L22935

; 1127 : 	{
; 1128 : 		SetRect(&rcDest, rc->left+delta.cx, rc->top + delta.cy, 0, 0);   

  027a4	6a 00		 push	 0
  027a6	6a 00		 push	 0
  027a8	8b 55 10	 mov	 edx, DWORD PTR _rc$[ebp]
  027ab	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  027ae	03 45 d4	 add	 eax, DWORD PTR _delta$[ebp+4]
  027b1	50		 push	 eax
  027b2	8b 4d 10	 mov	 ecx, DWORD PTR _rc$[ebp]
  027b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  027b7	03 55 d0	 add	 edx, DWORD PTR _delta$[ebp]
  027ba	52		 push	 edx
  027bb	8d 45 dc	 lea	 eax, DWORD PTR _rcDest$[ebp]
  027be	50		 push	 eax
  027bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 1129 : 		rcDest.right = rcDest.left + cx;

  027c5	8b 4d dc	 mov	 ecx, DWORD PTR _rcDest$[ebp]
  027c8	03 4d f4	 add	 ecx, DWORD PTR _cx$[ebp]
  027cb	89 4d e4	 mov	 DWORD PTR _rcDest$[ebp+8], ecx

; 1130 : 		rcDest.bottom = rcDest.top + cy;

  027ce	8b 55 e0	 mov	 edx, DWORD PTR _rcDest$[ebp+4]
  027d1	03 55 d8	 add	 edx, DWORD PTR _cy$[ebp]
  027d4	89 55 e8	 mov	 DWORD PTR _rcDest$[ebp+12], edx

; 1131 : 		p.x = 0;

  027d7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0

; 1132 : 		p.y = 0;

  027de	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+4], 0

; 1133 : 	}
; 1134 : 	else

  027e5	eb 10		 jmp	 SHORT $L22936
$L22935:

; 1135 : 	{
; 1136 : 		p.x = -delta.cx;   

  027e7	8b 45 d0	 mov	 eax, DWORD PTR _delta$[ebp]
  027ea	f7 d8		 neg	 eax
  027ec	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 1137 : 		p.y = -delta.cy;

  027ef	8b 4d d4	 mov	 ecx, DWORD PTR _delta$[ebp+4]
  027f2	f7 d9		 neg	 ecx
  027f4	89 4d fc	 mov	 DWORD PTR _p$[ebp+4], ecx
$L22936:

; 1138 : 	}
; 1139 :    
; 1140 : 	// select checkmark into memory DC
; 1141 : 	memdc = CreateCompatibleDC(hdc);

  027f7	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  027fa	52		 push	 edx
  027fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  02801	89 45 cc	 mov	 DWORD PTR _memdc$[ebp], eax

; 1142 : 	hOldBM = (HBITMAP)SelectObject(memdc, hBitmap);

  02804	8b 45 0c	 mov	 eax, DWORD PTR _hBitmap$[ebp]
  02807	50		 push	 eax
  02808	8b 4d cc	 mov	 ecx, DWORD PTR _memdc$[ebp]
  0280b	51		 push	 ecx
  0280c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  02812	89 45 f0	 mov	 DWORD PTR _hOldBM$[ebp], eax

; 1143 :    
; 1144 : 	// set BG color based on selected state   
; 1145 : 	colorOld = SetBkColor(hdc, GetSysColor(COLOR_3DFACE));

  02815	6a 0f		 push	 15			; 0000000fH
  02817	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  0281d	50		 push	 eax
  0281e	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  02821	52		 push	 edx
  02822	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  02828	89 45 ec	 mov	 DWORD PTR _colorOld$[ebp], eax

; 1146 : 
; 1147 : 	BitBlt(hdc, rcDest.left, rcDest.top, rcDest.right-rcDest.left, rcDest.bottom-rcDest.top, memdc, p.x, p.y, SRCCOPY);

  0282b	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  02830	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp+4]
  02833	50		 push	 eax
  02834	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  02837	51		 push	 ecx
  02838	8b 55 cc	 mov	 edx, DWORD PTR _memdc$[ebp]
  0283b	52		 push	 edx
  0283c	8b 45 e8	 mov	 eax, DWORD PTR _rcDest$[ebp+12]
  0283f	2b 45 e0	 sub	 eax, DWORD PTR _rcDest$[ebp+4]
  02842	50		 push	 eax
  02843	8b 4d e4	 mov	 ecx, DWORD PTR _rcDest$[ebp+8]
  02846	2b 4d dc	 sub	 ecx, DWORD PTR _rcDest$[ebp]
  02849	51		 push	 ecx
  0284a	8b 55 e0	 mov	 edx, DWORD PTR _rcDest$[ebp+4]
  0284d	52		 push	 edx
  0284e	8b 45 dc	 mov	 eax, DWORD PTR _rcDest$[ebp]
  02851	50		 push	 eax
  02852	8b 4d 08	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02855	51		 push	 ecx
  02856	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 1148 : 
; 1149 : 	// restore
; 1150 : 	SetBkColor(hdc, colorOld);

  0285c	8b 55 ec	 mov	 edx, DWORD PTR _colorOld$[ebp]
  0285f	52		 push	 edx
  02860	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  02863	50		 push	 eax
  02864	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 1151 : 	SelectObject(memdc, hOldBM);

  0286a	8b 4d f0	 mov	 ecx, DWORD PTR _hOldBM$[ebp]
  0286d	51		 push	 ecx
  0286e	8b 55 cc	 mov	 edx, DWORD PTR _memdc$[ebp]
  02871	52		 push	 edx
  02872	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 1152 : 	DeleteDC(memdc);

  02878	8b 45 cc	 mov	 eax, DWORD PTR _memdc$[ebp]
  0287b	50		 push	 eax
  0287c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$L22923:

; 1153 : }

  02882	8b e5		 mov	 esp, ebp
  02884	5d		 pop	 ebp
  02885	c3		 ret	 0
_DrawImage ENDP
_TEXT	ENDS
EXTRN	__imp__PlayEnhMetaFile@12:NEAR
EXTRN	__imp__SetWindowOrgEx@16:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_pt$ = -24						; size = 8
_rc$ = -16						; size = 16
_hdc$ = 8						; size = 4
_hemf$ = 12						; size = 4
_rect$ = 16						; size = 4
_DrawMetaFile PROC NEAR

; 1159 : {

  02890	55		 push	 ebp
  02891	8b ec		 mov	 ebp, esp
  02893	83 ec 18	 sub	 esp, 24			; 00000018H

; 1160 : 	RECT rc;
; 1161 : 	POINT pt;
; 1162 : 
; 1163 : 	SetRect(&rc, 0, 0, rect->right-rect->left, rect->bottom-rect->top);

  02896	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  02899	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0289c	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0289f	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  028a2	52		 push	 edx
  028a3	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  028a6	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  028a9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  028ac	2b 11		 sub	 edx, DWORD PTR [ecx]
  028ae	52		 push	 edx
  028af	6a 00		 push	 0
  028b1	6a 00		 push	 0
  028b3	8d 45 f0	 lea	 eax, DWORD PTR _rc$[ebp]
  028b6	50		 push	 eax
  028b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 1164 : 	SetWindowOrgEx(hdc, -rect->left, -rect->top, &pt);

  028bd	8d 4d e8	 lea	 ecx, DWORD PTR _pt$[ebp]
  028c0	51		 push	 ecx
  028c1	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  028c4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  028c7	f7 d8		 neg	 eax
  028c9	50		 push	 eax
  028ca	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  028cd	8b 11		 mov	 edx, DWORD PTR [ecx]
  028cf	f7 da		 neg	 edx
  028d1	52		 push	 edx
  028d2	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  028d5	50		 push	 eax
  028d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowOrgEx@16

; 1165 : 	PlayEnhMetaFile(hdc, hemf, &rc);

  028dc	8d 4d f0	 lea	 ecx, DWORD PTR _rc$[ebp]
  028df	51		 push	 ecx
  028e0	8b 55 0c	 mov	 edx, DWORD PTR _hemf$[ebp]
  028e3	52		 push	 edx
  028e4	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  028e7	50		 push	 eax
  028e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PlayEnhMetaFile@12

; 1166 : 	SetWindowOrgEx(hdc, pt.x, pt.y, 0);

  028ee	6a 00		 push	 0
  028f0	8b 4d ec	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  028f3	51		 push	 ecx
  028f4	8b 55 e8	 mov	 edx, DWORD PTR _pt$[ebp]
  028f7	52		 push	 edx
  028f8	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  028fb	50		 push	 eax
  028fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowOrgEx@16

; 1167 : }

  02902	8b e5		 mov	 esp, ebp
  02904	5d		 pop	 ebp
  02905	c3		 ret	 0
_DrawMetaFile ENDP
; Function compile flags: /Odt
_rc$ = -16						; size = 16
_sbar$ = 8						; size = 4
_hdc$ = 12						; size = 4
_rect$ = 16						; size = 4
_leftright$ = 20					; size = 4
_DrawVertButtons PROC NEAR

; 1370 : {

  02910	55		 push	 ebp
  02911	8b ec		 mov	 ebp, esp
  02913	83 ec 10	 sub	 esp, 16			; 00000010H

; 1371 : 	RECT rc = *rect;

  02916	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  02919	8b 08		 mov	 ecx, DWORD PTR [eax]
  0291b	89 4d f0	 mov	 DWORD PTR _rc$[ebp], ecx
  0291e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  02921	89 55 f4	 mov	 DWORD PTR _rc$[ebp+4], edx
  02924	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  02927	89 4d f8	 mov	 DWORD PTR _rc$[ebp+8], ecx
  0292a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0292d	89 55 fc	 mov	 DWORD PTR _rc$[ebp+12], edx

; 1372 : 	RotateRect(&rc);

  02930	8d 45 f0	 lea	 eax, DWORD PTR _rc$[ebp]
  02933	50		 push	 eax
  02934	e8 00 00 00 00	 call	 _RotateRect@4

; 1373 : 	DrawHorzButtons(sbar, hdc, &rc, leftright);

  02939	8b 4d 14	 mov	 ecx, DWORD PTR _leftright$[ebp]
  0293c	51		 push	 ecx
  0293d	8d 55 f0	 lea	 edx, DWORD PTR _rc$[ebp]
  02940	52		 push	 edx
  02941	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02944	50		 push	 eax
  02945	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  02948	51		 push	 ecx
  02949	e8 00 00 00 00	 call	 _DrawHorzButtons
  0294e	83 c4 10	 add	 esp, 16			; 00000010H

; 1374 : 	return 0;

  02951	33 c0		 xor	 eax, eax

; 1375 : }

  02953	8b e5		 mov	 esp, ebp
  02955	5d		 pop	 ebp
  02956	c3		 ret	 0
_DrawVertButtons ENDP
_TEXT	ENDS
EXTRN	__imp__PtInRect@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_hrect$ = -40						; size = 16
_pt$ = -24						; size = 8
_vrect$ = -16						; size = 16
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_NCHitTest PROC NEAR

; 1627 : {

  02960	55		 push	 ebp
  02961	8b ec		 mov	 ebp, esp
  02963	83 ec 28	 sub	 esp, 40			; 00000028H

; 1628 : 	RECT hrect;
; 1629 : 	RECT vrect;
; 1630 : 	POINT pt;
; 1631 : 
; 1632 : 	pt.x = LOWORD(lParam);

  02966	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  02969	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0296e	0f b7 c8	 movzx	 ecx, ax
  02971	89 4d e8	 mov	 DWORD PTR _pt$[ebp], ecx

; 1633 : 	pt.y = HIWORD(lParam);

  02974	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  02977	c1 ea 10	 shr	 edx, 16			; 00000010H
  0297a	0f b7 c2	 movzx	 eax, dx
  0297d	89 45 ec	 mov	 DWORD PTR _pt$[ebp+4], eax

; 1634 : 	
; 1635 : 	//work out exactly where the Horizontal and Vertical scrollbars are
; 1636 : 	GetHScrollRect(sw, hwnd, &hrect);

  02980	8d 4d d8	 lea	 ecx, DWORD PTR _hrect$[ebp]
  02983	51		 push	 ecx
  02984	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02987	52		 push	 edx
  02988	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0298b	50		 push	 eax
  0298c	e8 00 00 00 00	 call	 _GetHScrollRect
  02991	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1637 : 	GetVScrollRect(sw, hwnd, &vrect);

  02994	8d 4d f0	 lea	 ecx, DWORD PTR _vrect$[ebp]
  02997	51		 push	 ecx
  02998	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0299b	52		 push	 edx
  0299c	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0299f	50		 push	 eax
  029a0	e8 00 00 00 00	 call	 _GetVScrollRect
  029a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1638 : 	
; 1639 : 	//Clicked in the horizontal scrollbar area
; 1640 : 	if(sw->sbarHorz.fScrollVisible && PtInRect(&hrect, pt))

  029a8	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  029ab	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  029af	74 1d		 je	 SHORT $L23114
  029b1	8b 55 ec	 mov	 edx, DWORD PTR _pt$[ebp+4]
  029b4	52		 push	 edx
  029b5	8b 45 e8	 mov	 eax, DWORD PTR _pt$[ebp]
  029b8	50		 push	 eax
  029b9	8d 4d d8	 lea	 ecx, DWORD PTR _hrect$[ebp]
  029bc	51		 push	 ecx
  029bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  029c3	85 c0		 test	 eax, eax
  029c5	74 07		 je	 SHORT $L23114

; 1641 : 	{
; 1642 : 		return HTHSCROLL;

  029c7	b8 06 00 00 00	 mov	 eax, 6
  029cc	eb 47		 jmp	 SHORT $L23106
$L23114:

; 1643 : 	}
; 1644 : 	//Clicked in the vertical scrollbar area
; 1645 : 	else if(sw->sbarVert.fScrollVisible && PtInRect(&vrect, pt))

  029ce	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  029d1	83 ba 58 03 00
	00 00		 cmp	 DWORD PTR [edx+856], 0
  029d8	74 1d		 je	 SHORT $L23116
  029da	8b 45 ec	 mov	 eax, DWORD PTR _pt$[ebp+4]
  029dd	50		 push	 eax
  029de	8b 4d e8	 mov	 ecx, DWORD PTR _pt$[ebp]
  029e1	51		 push	 ecx
  029e2	8d 55 f0	 lea	 edx, DWORD PTR _vrect$[ebp]
  029e5	52		 push	 edx
  029e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  029ec	85 c0		 test	 eax, eax
  029ee	74 07		 je	 SHORT $L23116

; 1646 : 	{
; 1647 : 		return HTVSCROLL;

  029f0	b8 07 00 00 00	 mov	 eax, 7
  029f5	eb 1e		 jmp	 SHORT $L23106
$L23116:

; 1648 : 	}
; 1649 : 	//clicked somewhere else
; 1650 : 	else
; 1651 : 	{
; 1652 : 		return CallWindowProc(sw->oldproc, hwnd, WM_NCHITTEST, wParam, lParam);

  029f7	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  029fa	50		 push	 eax
  029fb	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  029fe	51		 push	 ecx
  029ff	68 84 00 00 00	 push	 132			; 00000084H
  02a04	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02a07	52		 push	 edx
  02a08	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  02a0b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02a0e	51		 push	 ecx
  02a0f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
$L23106:

; 1653 : 	}
; 1654 : }

  02a15	8b e5		 mov	 esp, ebp
  02a17	5d		 pop	 ebp
  02a18	c3		 ret	 0
_NCHitTest ENDP
_TEXT	ENDS
EXTRN	__imp__SetCapture@4:NEAR
EXTRN	__imp__SetTimer@16:NEAR
EXTRN	__imp__KillTimer@8:NEAR
_BSS	SEGMENT
_rcThumbBounds DB 010H DUP (?)
_nThumbSize DD	01H DUP (?)
_nThumbPos DD	01H DUP (?)
_nThumbMouseOffset DD 01H DUP (?)
_nThumbPos0 DD	01H DUP (?)
; Function compile flags: /Odt
_BSS	ENDS
_TEXT	SEGMENT
tv143 = -56						; size = 4
_hdc$ = -52						; size = 4
_sb$ = -48						; size = 4
_pt$ = -44						; size = 8
_winrect$ = -36						; size = 16
_rect$ = -20						; size = 16
_sbut$ = -4						; size = 4
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_NCLButtonDown PROC NEAR

; 1928 : {

  02a20	55		 push	 ebp
  02a21	8b ec		 mov	 ebp, esp
  02a23	83 ec 38	 sub	 esp, 56			; 00000038H

; 1929 : 	RECT rect, winrect;
; 1930 : 	HDC hdc;
; 1931 : 	SCROLLBAR *sb;
; 1932 : 	SCROLLBUT *sbut = 0;

  02a26	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _sbut$[ebp], 0

; 1933 : 	POINT pt;
; 1934 : 
; 1935 : 	pt.x = LOWORD(lParam);

  02a2d	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  02a30	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  02a35	0f b7 c8	 movzx	 ecx, ax
  02a38	89 4d d4	 mov	 DWORD PTR _pt$[ebp], ecx

; 1936 : 	pt.y = HIWORD(lParam);

  02a3b	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  02a3e	c1 ea 10	 shr	 edx, 16			; 00000010H
  02a41	0f b7 c2	 movzx	 eax, dx
  02a44	89 45 d8	 mov	 DWORD PTR _pt$[ebp+4], eax

; 1937 : 
; 1938 : 	hwndCurCoolSB = hwnd;

  02a47	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  02a4a	89 0d 00 00 00
	00		 mov	 DWORD PTR _hwndCurCoolSB, ecx

; 1939 : 
; 1940 : 	//
; 1941 : 	//	HORIZONTAL SCROLLBAR PROCESSING
; 1942 : 	//
; 1943 : 	if(wParam == HTHSCROLL)

  02a50	83 7d 10 06	 cmp	 DWORD PTR _wParam$[ebp], 6
  02a54	75 66		 jne	 SHORT $L23302

; 1944 : 	{
; 1945 : 		uScrollTimerMsg = WM_HSCROLL;

  02a56	c7 05 00 00 00
	00 14 01 00 00	 mov	 DWORD PTR _uScrollTimerMsg, 276 ; 00000114H

; 1946 : 		uCurrentScrollbar = SB_HORZ;

  02a60	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uCurrentScrollbar, 0

; 1947 : 		sb = &sw->sbarHorz;

  02a6a	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  02a6d	83 c2 08	 add	 edx, 8
  02a70	89 55 d0	 mov	 DWORD PTR _sb$[ebp], edx

; 1948 : 
; 1949 : 		//get the total area of the normal Horz scrollbar area
; 1950 : 		GetHScrollRect(sw, hwnd, &rect);

  02a73	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  02a76	50		 push	 eax
  02a77	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  02a7a	51		 push	 ecx
  02a7b	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  02a7e	52		 push	 edx
  02a7f	e8 00 00 00 00	 call	 _GetHScrollRect
  02a84	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1951 : 		uCurrentScrollPortion = GetHorzPortion(sb, hwnd, &rect, LOWORD(lParam), HIWORD(lParam));

  02a87	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  02a8a	c1 e8 10	 shr	 eax, 16			; 00000010H
  02a8d	0f b7 c8	 movzx	 ecx, ax
  02a90	51		 push	 ecx
  02a91	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  02a94	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  02a9a	0f b7 c2	 movzx	 eax, dx
  02a9d	50		 push	 eax
  02a9e	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  02aa1	51		 push	 ecx
  02aa2	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02aa5	52		 push	 edx
  02aa6	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  02aa9	50		 push	 eax
  02aaa	e8 00 00 00 00	 call	 _GetHorzPortion
  02aaf	83 c4 14	 add	 esp, 20			; 00000014H
  02ab2	a3 00 00 00 00	 mov	 DWORD PTR _uCurrentScrollPortion, eax

; 1952 : 	}
; 1953 : 	//
; 1954 : 	//	VERTICAL SCROLLBAR PROCESSING
; 1955 : 	//
; 1956 : 	else if(wParam == HTVSCROLL)

  02ab7	e9 99 00 00 00	 jmp	 $L23307
$L23302:
  02abc	83 7d 10 07	 cmp	 DWORD PTR _wParam$[ebp], 7
  02ac0	75 66		 jne	 SHORT $L23308

; 1957 : 	{
; 1958 : 		uScrollTimerMsg = WM_VSCROLL;

  02ac2	c7 05 00 00 00
	00 15 01 00 00	 mov	 DWORD PTR _uScrollTimerMsg, 277 ; 00000115H

; 1959 : 		uCurrentScrollbar = SB_VERT;

  02acc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _uCurrentScrollbar, 1

; 1960 : 		sb = &sw->sbarVert;

  02ad6	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  02ad9	81 c1 54 03 00
	00		 add	 ecx, 852		; 00000354H
  02adf	89 4d d0	 mov	 DWORD PTR _sb$[ebp], ecx

; 1961 : 
; 1962 : 		//get the total area of the normal Horz scrollbar area
; 1963 : 		GetVScrollRect(sw, hwnd, &rect);

  02ae2	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  02ae5	52		 push	 edx
  02ae6	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02ae9	50		 push	 eax
  02aea	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  02aed	51		 push	 ecx
  02aee	e8 00 00 00 00	 call	 _GetVScrollRect
  02af3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1964 : 		uCurrentScrollPortion = GetVertPortion(sb, hwnd, &rect, LOWORD(lParam), HIWORD(lParam));

  02af6	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  02af9	c1 ea 10	 shr	 edx, 16			; 00000010H
  02afc	0f b7 c2	 movzx	 eax, dx
  02aff	50		 push	 eax
  02b00	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  02b03	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  02b09	0f b7 d1	 movzx	 edx, cx
  02b0c	52		 push	 edx
  02b0d	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  02b10	50		 push	 eax
  02b11	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  02b14	51		 push	 ecx
  02b15	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  02b18	52		 push	 edx
  02b19	e8 00 00 00 00	 call	 _GetVertPortion
  02b1e	83 c4 14	 add	 esp, 20			; 00000014H
  02b21	a3 00 00 00 00	 mov	 DWORD PTR _uCurrentScrollPortion, eax

; 1965 : 	}
; 1966 : 	//
; 1967 : 	//	NORMAL PROCESSING
; 1968 : 	//
; 1969 : 	else

  02b26	eb 2d		 jmp	 SHORT $L23307
$L23308:

; 1970 : 	{
; 1971 : 		uCurrentScrollPortion = HTSCROLL_NONE;

  02b28	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uCurrentScrollPortion, -1

; 1972 : 		return CallWindowProc(sw->oldproc, hwnd, WM_NCLBUTTONDOWN, wParam, lParam);

  02b32	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  02b35	50		 push	 eax
  02b36	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  02b39	51		 push	 ecx
  02b3a	68 a1 00 00 00	 push	 161			; 000000a1H
  02b3f	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02b42	52		 push	 edx
  02b43	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  02b46	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02b49	51		 push	 ecx
  02b4a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  02b50	e9 97 03 00 00	 jmp	 $L23291
$L23307:

; 1973 : 	}
; 1974 : 
; 1975 : 	//
; 1976 : 	// we can now share the same code for vertical
; 1977 : 	// and horizontal scrollbars
; 1978 : 	//
; 1979 : 	switch(uCurrentScrollPortion)

  02b55	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentScrollPortion
  02b5b	89 55 c8	 mov	 DWORD PTR tv143[ebp], edx
  02b5e	81 7d c8 80 00
	00 00		 cmp	 DWORD PTR tv143[ebp], 128 ; 00000080H
  02b65	0f 87 55 03 00
	00		 ja	 $L23334
  02b6b	8b 45 c8	 mov	 eax, DWORD PTR tv143[ebp]
  02b6e	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $L23915[eax]
  02b75	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L23916[ecx*4]
$L23318:

; 1980 : 	{
; 1981 : 	//inserted buttons to the left/right
; 1982 : #ifdef INCLUDE_BUTTONS
; 1983 : 	case HTSCROLL_INSERTED:  
; 1984 : 
; 1985 : #ifdef HOT_TRACKING
; 1986 : 		KillTimer(hwnd, uMouseOverId);

  02b7c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uMouseOverId
  02b82	52		 push	 edx
  02b83	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02b86	50		 push	 eax
  02b87	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 1987 : 		uMouseOverId = 0;

  02b8d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uMouseOverId, 0

; 1988 : 		uMouseOverScrollbar = COOLSB_NONE;

  02b97	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uMouseOverScrollbar, -1

; 1989 : #endif
; 1990 : 
; 1991 : 		//find the index of the button that has been clicked
; 1992 : 		//adjust the rectangle to give the button's rectangle
; 1993 : 		uCurrentButton = GetButtonFromPt(sb, &rect, pt, TRUE);

  02ba1	6a 01		 push	 1
  02ba3	8b 4d d8	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  02ba6	51		 push	 ecx
  02ba7	8b 55 d4	 mov	 edx, DWORD PTR _pt$[ebp]
  02baa	52		 push	 edx
  02bab	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  02bae	50		 push	 eax
  02baf	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  02bb2	51		 push	 ecx
  02bb3	e8 00 00 00 00	 call	 _GetButtonFromPt
  02bb8	83 c4 14	 add	 esp, 20			; 00000014H
  02bbb	a3 00 00 00 00	 mov	 DWORD PTR _uCurrentButton, eax

; 1994 : 
; 1995 : 		sbut = &sb->sbButtons[uCurrentButton];

  02bc0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  02bc6	6b d2 30	 imul	 edx, 48			; 00000030H
  02bc9	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  02bcc	8d 4c 10 2c	 lea	 ecx, DWORD PTR [eax+edx+44]
  02bd0	89 4d fc	 mov	 DWORD PTR _sbut$[ebp], ecx

; 1996 : 		
; 1997 : 		//post a notification message
; 1998 : 		PostMouseNotify(hwnd, NM_CLICK, sb->nBarType, &rect, sbut->uCmdId, pt);

  02bd3	8b 55 d8	 mov	 edx, DWORD PTR _pt$[ebp+4]
  02bd6	52		 push	 edx
  02bd7	8b 45 d4	 mov	 eax, DWORD PTR _pt$[ebp]
  02bda	50		 push	 eax
  02bdb	8b 4d fc	 mov	 ecx, DWORD PTR _sbut$[ebp]
  02bde	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  02be1	52		 push	 edx
  02be2	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  02be5	50		 push	 eax
  02be6	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  02be9	8b 91 40 03 00
	00		 mov	 edx, DWORD PTR [ecx+832]
  02bef	52		 push	 edx
  02bf0	6a fe		 push	 -2			; fffffffeH
  02bf2	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02bf5	50		 push	 eax
  02bf6	e8 00 00 00 00	 call	 _PostMouseNotify0
  02bfb	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1999 : 
; 2000 : 		GetWindowRect(hwnd, &winrect);

  02bfe	8d 4d dc	 lea	 ecx, DWORD PTR _winrect$[ebp]
  02c01	51		 push	 ecx
  02c02	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02c05	52		 push	 edx
  02c06	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 2001 : 		OffsetRect(&rect, -winrect.left, -winrect.top);

  02c0c	8b 45 e0	 mov	 eax, DWORD PTR _winrect$[ebp+4]
  02c0f	f7 d8		 neg	 eax
  02c11	50		 push	 eax
  02c12	8b 4d dc	 mov	 ecx, DWORD PTR _winrect$[ebp]
  02c15	f7 d9		 neg	 ecx
  02c17	51		 push	 ecx
  02c18	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  02c1b	52		 push	 edx
  02c1c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 2002 : 		hdc = GetWindowDC(hwnd);

  02c22	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02c25	50		 push	 eax
  02c26	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  02c2c	89 45 cc	 mov	 DWORD PTR _hdc$[ebp], eax

; 2003 : 			
; 2004 : 		DrawScrollButton(sbut, hdc, &rect, SBBS_PUSHED);

  02c2f	6a 01		 push	 1
  02c31	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  02c34	51		 push	 ecx
  02c35	8b 55 cc	 mov	 edx, DWORD PTR _hdc$[ebp]
  02c38	52		 push	 edx
  02c39	8b 45 fc	 mov	 eax, DWORD PTR _sbut$[ebp]
  02c3c	50		 push	 eax
  02c3d	e8 00 00 00 00	 call	 _DrawScrollButton
  02c42	83 c4 10	 add	 esp, 16			; 00000010H

; 2005 : 
; 2006 : 		ReleaseDC(hwnd, hdc);

  02c45	8b 4d cc	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02c48	51		 push	 ecx
  02c49	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02c4c	52		 push	 edx
  02c4d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 2007 : 	
; 2008 : 		break;

  02c53	e9 88 02 00 00	 jmp	 $L23315
$L23319:

; 2009 : #endif	//INCLUDE_BUTTONS
; 2010 : 
; 2011 : 	case HTSCROLL_THUMB: 
; 2012 : 
; 2013 : 		//if the scrollbar is disabled, then do no further processing
; 2014 : 		if(!IsScrollbarActive(sb))

  02c58	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  02c5b	50		 push	 eax
  02c5c	e8 00 00 00 00	 call	 _IsScrollbarActive
  02c61	83 c4 04	 add	 esp, 4
  02c64	85 c0		 test	 eax, eax
  02c66	75 07		 jne	 SHORT $L23320

; 2015 : 			return 0;

  02c68	33 c0		 xor	 eax, eax
  02c6a	e9 7d 02 00 00	 jmp	 $L23291
$L23320:

; 2016 : 		
; 2017 : 		GetRealScrollRect(sb, &rect);

  02c6f	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  02c72	51		 push	 ecx
  02c73	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  02c76	52		 push	 edx
  02c77	e8 00 00 00 00	 call	 _GetRealScrollRect
  02c7c	83 c4 08	 add	 esp, 8

; 2018 : 		RotateRect0(sb, &rect);

  02c7f	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  02c82	50		 push	 eax
  02c83	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  02c86	51		 push	 ecx
  02c87	e8 00 00 00 00	 call	 _RotateRect0@8

; 2019 : 		CalcThumbSize(sb, &rect, &nThumbSize, &nThumbPos);

  02c8c	68 00 00 00 00	 push	 OFFSET FLAT:_nThumbPos
  02c91	68 00 00 00 00	 push	 OFFSET FLAT:_nThumbSize
  02c96	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  02c99	52		 push	 edx
  02c9a	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  02c9d	50		 push	 eax
  02c9e	e8 00 00 00 00	 call	 _CalcThumbSize
  02ca3	83 c4 10	 add	 esp, 16			; 00000010H

; 2020 : 		RotateRect0(sb, &rect);

  02ca6	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  02ca9	51		 push	 ecx
  02caa	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  02cad	52		 push	 edx
  02cae	e8 00 00 00 00	 call	 _RotateRect0@8

; 2021 : 		
; 2022 : 		//remember the bounding rectangle of the scrollbar work area
; 2023 : 		rcThumbBounds = rect;

  02cb3	8b 45 ec	 mov	 eax, DWORD PTR _rect$[ebp]
  02cb6	a3 00 00 00 00	 mov	 DWORD PTR _rcThumbBounds, eax
  02cbb	8b 4d f0	 mov	 ecx, DWORD PTR _rect$[ebp+4]
  02cbe	89 0d 04 00 00
	00		 mov	 DWORD PTR _rcThumbBounds+4, ecx
  02cc4	8b 55 f4	 mov	 edx, DWORD PTR _rect$[ebp+8]
  02cc7	89 15 08 00 00
	00		 mov	 DWORD PTR _rcThumbBounds+8, edx
  02ccd	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp+12]
  02cd0	a3 0c 00 00 00	 mov	 DWORD PTR _rcThumbBounds+12, eax

; 2024 : 		
; 2025 : 		sw->fThumbTracking = TRUE;

  02cd5	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  02cd8	c7 81 a0 06 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+1696], 1

; 2026 : 		sb->scrollInfo.nTrackPos = sb->scrollInfo.nPos;

  02ce2	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  02ce5	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  02ce8	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02ceb	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 2027 : 		
; 2028 : 		if(wParam == HTVSCROLL) 

  02cee	83 7d 10 07	 cmp	 DWORD PTR _wParam$[ebp], 7
  02cf2	75 11		 jne	 SHORT $L23321

; 2029 : 			nThumbMouseOffset = pt.y - nThumbPos;

  02cf4	8b 55 d8	 mov	 edx, DWORD PTR _pt$[ebp+4]
  02cf7	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _nThumbPos
  02cfd	89 15 00 00 00
	00		 mov	 DWORD PTR _nThumbMouseOffset, edx

; 2030 : 		else

  02d03	eb 0e		 jmp	 SHORT $L23322
$L23321:

; 2031 : 			nThumbMouseOffset = pt.x - nThumbPos;

  02d05	8b 45 d4	 mov	 eax, DWORD PTR _pt$[ebp]
  02d08	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _nThumbPos
  02d0e	a3 00 00 00 00	 mov	 DWORD PTR _nThumbMouseOffset, eax
$L23322:

; 2032 : 
; 2033 : 		nLastPos = -sb->scrollInfo.nPos;

  02d13	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  02d16	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  02d19	f7 da		 neg	 edx
  02d1b	89 15 00 00 00
	00		 mov	 DWORD PTR _nLastPos, edx

; 2034 : 		nThumbPos0 = nThumbPos;

  02d21	a1 00 00 00 00	 mov	 eax, DWORD PTR _nThumbPos
  02d26	a3 00 00 00 00	 mov	 DWORD PTR _nThumbPos0, eax

; 2035 : 	
; 2036 : 		//if(sb->fFlatScrollbar)
; 2037 : 		//{
; 2038 : 			GetWindowRect(hwnd, &winrect);

  02d2b	8d 4d dc	 lea	 ecx, DWORD PTR _winrect$[ebp]
  02d2e	51		 push	 ecx
  02d2f	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02d32	52		 push	 edx
  02d33	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 2039 : 			OffsetRect(&rect, -winrect.left, -winrect.top);

  02d39	8b 45 e0	 mov	 eax, DWORD PTR _winrect$[ebp+4]
  02d3c	f7 d8		 neg	 eax
  02d3e	50		 push	 eax
  02d3f	8b 4d dc	 mov	 ecx, DWORD PTR _winrect$[ebp]
  02d42	f7 d9		 neg	 ecx
  02d44	51		 push	 ecx
  02d45	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  02d48	52		 push	 edx
  02d49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 2040 : 			hdc = GetWindowDC(hwnd);

  02d4f	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02d52	50		 push	 eax
  02d53	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  02d59	89 45 cc	 mov	 DWORD PTR _hdc$[ebp], eax

; 2041 : 			NCDrawScrollbar(sb, hwnd, hdc, &rect, HTSCROLL_THUMB);

  02d5c	6a 05		 push	 5
  02d5e	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  02d61	51		 push	 ecx
  02d62	8b 55 cc	 mov	 edx, DWORD PTR _hdc$[ebp]
  02d65	52		 push	 edx
  02d66	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02d69	50		 push	 eax
  02d6a	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  02d6d	51		 push	 ecx
  02d6e	e8 00 00 00 00	 call	 _NCDrawScrollbar
  02d73	83 c4 14	 add	 esp, 20			; 00000014H

; 2042 : 			ReleaseDC(hwnd, hdc);

  02d76	8b 55 cc	 mov	 edx, DWORD PTR _hdc$[ebp]
  02d79	52		 push	 edx
  02d7a	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02d7d	50		 push	 eax
  02d7e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 2043 : 		//}
; 2044 : 
; 2045 : 		break;

  02d84	e9 57 01 00 00	 jmp	 $L23315
$L23323:

; 2046 : 
; 2047 : 		//Any part of the scrollbar
; 2048 : 	case HTSCROLL_LEFT:  
; 2049 : 		if(sb->fScrollFlags & ESB_DISABLE_LEFT)		return 0;

  02d89	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  02d8c	8b 11		 mov	 edx, DWORD PTR [ecx]
  02d8e	83 e2 01	 and	 edx, 1
  02d91	74 07		 je	 SHORT $L23324
  02d93	33 c0		 xor	 eax, eax
  02d95	e9 52 01 00 00	 jmp	 $L23291
$L23324:

; 2050 : 		else										goto target1;

  02d9a	eb 11		 jmp	 SHORT $target1$23326
$L23327:

; 2051 : 	
; 2052 : 	case HTSCROLL_RIGHT: 
; 2053 : 		if(sb->fScrollFlags & ESB_DISABLE_RIGHT)	return 0;

  02d9c	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  02d9f	8b 08		 mov	 ecx, DWORD PTR [eax]
  02da1	83 e1 02	 and	 ecx, 2
  02da4	74 07		 je	 SHORT $target1$23326
  02da6	33 c0		 xor	 eax, eax
  02da8	e9 3f 01 00 00	 jmp	 $L23291
$target1$23326:

; 2054 : 		else										goto target1;
; 2055 : 
; 2056 : 		goto target1;	
; 2057 : 
; 2058 : 	case HTSCROLL_PAGELEFT:  case HTSCROLL_PAGERIGHT:
; 2059 : 
; 2060 : 		target1:
; 2061 : 
; 2062 : 		//if the scrollbar is disabled, then do no further processing
; 2063 : 		if(!IsScrollbarActive(sb))

  02dad	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  02db0	52		 push	 edx
  02db1	e8 00 00 00 00	 call	 _IsScrollbarActive
  02db6	83 c4 04	 add	 esp, 4
  02db9	85 c0		 test	 eax, eax
  02dbb	75 05		 jne	 SHORT $L23331

; 2064 : 			break;

  02dbd	e9 1e 01 00 00	 jmp	 $L23315
$L23331:

; 2065 : 
; 2066 : 		//ajust the horizontal rectangle to NOT include
; 2067 : 		//any inserted buttons
; 2068 : 		GetRealScrollRect(sb, &rect);

  02dc2	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  02dc5	50		 push	 eax
  02dc6	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  02dc9	51		 push	 ecx
  02dca	e8 00 00 00 00	 call	 _GetRealScrollRect
  02dcf	83 c4 08	 add	 esp, 8

; 2069 : 
; 2070 : 		SendScrollMessage(hwnd, uScrollTimerMsg, uCurrentScrollPortion, 0);

  02dd2	6a 00		 push	 0
  02dd4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentScrollPortion
  02dda	52		 push	 edx
  02ddb	a1 00 00 00 00	 mov	 eax, DWORD PTR _uScrollTimerMsg
  02de0	50		 push	 eax
  02de1	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  02de4	51		 push	 ecx
  02de5	e8 00 00 00 00	 call	 _SendScrollMessage
  02dea	83 c4 10	 add	 esp, 16			; 00000010H

; 2071 : 
; 2072 : 		// Check what area the mouse is now over :
; 2073 : 		// If the scroll thumb has moved under the mouse in response to 
; 2074 : 		// a call to SetScrollPos etc, then we don't hilight the scrollbar margin
; 2075 : 		if(uCurrentScrollbar == SB_HORZ)

  02ded	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  02df4	75 23		 jne	 SHORT $L23332

; 2076 : 			uScrollTimerPortion = GetHorzScrollPortion(sb, hwnd, &rect, pt.x, pt.y);

  02df6	8b 55 d8	 mov	 edx, DWORD PTR _pt$[ebp+4]
  02df9	52		 push	 edx
  02dfa	8b 45 d4	 mov	 eax, DWORD PTR _pt$[ebp]
  02dfd	50		 push	 eax
  02dfe	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  02e01	51		 push	 ecx
  02e02	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02e05	52		 push	 edx
  02e06	8b 45 d0	 mov	 eax, DWORD PTR _sb$[ebp]
  02e09	50		 push	 eax
  02e0a	e8 00 00 00 00	 call	 _GetHorzScrollPortion
  02e0f	83 c4 14	 add	 esp, 20			; 00000014H
  02e12	a3 00 00 00 00	 mov	 DWORD PTR _uScrollTimerPortion, eax

; 2077 : 		else

  02e17	eb 21		 jmp	 SHORT $L23333
$L23332:

; 2078 : 			uScrollTimerPortion = GetVertScrollPortion(sb, hwnd, &rect, pt.x, pt.y);

  02e19	8b 4d d8	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  02e1c	51		 push	 ecx
  02e1d	8b 55 d4	 mov	 edx, DWORD PTR _pt$[ebp]
  02e20	52		 push	 edx
  02e21	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  02e24	50		 push	 eax
  02e25	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  02e28	51		 push	 ecx
  02e29	8b 55 d0	 mov	 edx, DWORD PTR _sb$[ebp]
  02e2c	52		 push	 edx
  02e2d	e8 00 00 00 00	 call	 _GetVertScrollPortion
  02e32	83 c4 14	 add	 esp, 20			; 00000014H
  02e35	a3 00 00 00 00	 mov	 DWORD PTR _uScrollTimerPortion, eax
$L23333:

; 2079 : 
; 2080 : 		GetWindowRect(hwnd, &winrect);

  02e3a	8d 45 dc	 lea	 eax, DWORD PTR _winrect$[ebp]
  02e3d	50		 push	 eax
  02e3e	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  02e41	51		 push	 ecx
  02e42	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 2081 : 		OffsetRect(&rect, -winrect.left, -winrect.top);

  02e48	8b 55 e0	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  02e4b	f7 da		 neg	 edx
  02e4d	52		 push	 edx
  02e4e	8b 45 dc	 mov	 eax, DWORD PTR _winrect$[ebp]
  02e51	f7 d8		 neg	 eax
  02e53	50		 push	 eax
  02e54	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  02e57	51		 push	 ecx
  02e58	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 2082 : 		hdc = GetWindowDC(hwnd);

  02e5e	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02e61	52		 push	 edx
  02e62	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  02e68	89 45 cc	 mov	 DWORD PTR _hdc$[ebp], eax

; 2083 : 			
; 2084 : #ifndef HOT_TRACKING
; 2085 : 		//if we aren't hot-tracking, then don't highlight 
; 2086 : 		//the scrollbar thumb unless we click on it
; 2087 : 		if(uScrollTimerPortion == HTSCROLL_THUMB)
; 2088 : 			uScrollTimerPortion = HTSCROLL_NONE;
; 2089 : #endif
; 2090 : 		NCDrawScrollbar(sb, hwnd, hdc, &rect, uScrollTimerPortion);

  02e6b	a1 00 00 00 00	 mov	 eax, DWORD PTR _uScrollTimerPortion
  02e70	50		 push	 eax
  02e71	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  02e74	51		 push	 ecx
  02e75	8b 55 cc	 mov	 edx, DWORD PTR _hdc$[ebp]
  02e78	52		 push	 edx
  02e79	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02e7c	50		 push	 eax
  02e7d	8b 4d d0	 mov	 ecx, DWORD PTR _sb$[ebp]
  02e80	51		 push	 ecx
  02e81	e8 00 00 00 00	 call	 _NCDrawScrollbar
  02e86	83 c4 14	 add	 esp, 20			; 00000014H

; 2091 : 		ReleaseDC(hwnd, hdc);

  02e89	8b 55 cc	 mov	 edx, DWORD PTR _hdc$[ebp]
  02e8c	52		 push	 edx
  02e8d	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02e90	50		 push	 eax
  02e91	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 2092 : 
; 2093 : 		//Post the scroll message!!!!
; 2094 : 		uScrollTimerPortion = uCurrentScrollPortion;

  02e97	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uCurrentScrollPortion
  02e9d	89 0d 00 00 00
	00		 mov	 DWORD PTR _uScrollTimerPortion, ecx

; 2095 : 
; 2096 : 		//set a timer going on the first click.
; 2097 : 		//if this one expires, then we can start off a more regular timer
; 2098 : 		//to generate the auto-scroll behaviour
; 2099 : #pragma warning( disable: 4244)
; 2100 : 		uScrollTimerId = SetTimer(hwnd, COOLSB_TIMERID1, COOLSB_TIMERINTERVAL1, 0);

  02ea3	6a 00		 push	 0
  02ea5	68 2c 01 00 00	 push	 300			; 0000012cH
  02eaa	68 fd ff 00 00	 push	 65533			; 0000fffdH
  02eaf	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02eb2	52		 push	 edx
  02eb3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
  02eb9	a3 00 00 00 00	 mov	 DWORD PTR _uScrollTimerId, eax

; 2101 : #pragma warning( default: 4244)
; 2102 : 		break;

  02ebe	eb 20		 jmp	 SHORT $L23315
$L23334:

; 2103 : 	default:
; 2104 : 		return CallWindowProc(sw->oldproc, hwnd, WM_NCLBUTTONDOWN, wParam, lParam);

  02ec0	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  02ec3	50		 push	 eax
  02ec4	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  02ec7	51		 push	 ecx
  02ec8	68 a1 00 00 00	 push	 161			; 000000a1H
  02ecd	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02ed0	52		 push	 edx
  02ed1	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  02ed4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02ed7	51		 push	 ecx
  02ed8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  02ede	eb 0c		 jmp	 SHORT $L23291
$L23315:

; 2105 : 		//return 0;
; 2106 : 	}
; 2107 : 		
; 2108 : 	SetCapture(hwnd);

  02ee0	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02ee3	52		 push	 edx
  02ee4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCapture@4

; 2109 : 	return 0;

  02eea	33 c0		 xor	 eax, eax
$L23291:

; 2110 : }

  02eec	8b e5		 mov	 esp, ebp
  02eee	5d		 pop	 ebp
  02eef	c3		 ret	 0
$L23916:
  02ef0	00 00 00 00	 DD	 $L23323
  02ef4	00 00 00 00	 DD	 $L23327
  02ef8	00 00 00 00	 DD	 $target1$23326
  02efc	00 00 00 00	 DD	 $L23319
  02f00	00 00 00 00	 DD	 $L23318
  02f04	00 00 00 00	 DD	 $L23334
$L23915:
  02f08	00		 DB	 0
  02f09	01		 DB	 1
  02f0a	02		 DB	 2
  02f0b	02		 DB	 2
  02f0c	05		 DB	 5
  02f0d	03		 DB	 3
  02f0e	05		 DB	 5
  02f0f	05		 DB	 5
  02f10	05		 DB	 5
  02f11	05		 DB	 5
  02f12	05		 DB	 5
  02f13	05		 DB	 5
  02f14	05		 DB	 5
  02f15	05		 DB	 5
  02f16	05		 DB	 5
  02f17	05		 DB	 5
  02f18	05		 DB	 5
  02f19	05		 DB	 5
  02f1a	05		 DB	 5
  02f1b	05		 DB	 5
  02f1c	05		 DB	 5
  02f1d	05		 DB	 5
  02f1e	05		 DB	 5
  02f1f	05		 DB	 5
  02f20	05		 DB	 5
  02f21	05		 DB	 5
  02f22	05		 DB	 5
  02f23	05		 DB	 5
  02f24	05		 DB	 5
  02f25	05		 DB	 5
  02f26	05		 DB	 5
  02f27	05		 DB	 5
  02f28	05		 DB	 5
  02f29	05		 DB	 5
  02f2a	05		 DB	 5
  02f2b	05		 DB	 5
  02f2c	05		 DB	 5
  02f2d	05		 DB	 5
  02f2e	05		 DB	 5
  02f2f	05		 DB	 5
  02f30	05		 DB	 5
  02f31	05		 DB	 5
  02f32	05		 DB	 5
  02f33	05		 DB	 5
  02f34	05		 DB	 5
  02f35	05		 DB	 5
  02f36	05		 DB	 5
  02f37	05		 DB	 5
  02f38	05		 DB	 5
  02f39	05		 DB	 5
  02f3a	05		 DB	 5
  02f3b	05		 DB	 5
  02f3c	05		 DB	 5
  02f3d	05		 DB	 5
  02f3e	05		 DB	 5
  02f3f	05		 DB	 5
  02f40	05		 DB	 5
  02f41	05		 DB	 5
  02f42	05		 DB	 5
  02f43	05		 DB	 5
  02f44	05		 DB	 5
  02f45	05		 DB	 5
  02f46	05		 DB	 5
  02f47	05		 DB	 5
  02f48	05		 DB	 5
  02f49	05		 DB	 5
  02f4a	05		 DB	 5
  02f4b	05		 DB	 5
  02f4c	05		 DB	 5
  02f4d	05		 DB	 5
  02f4e	05		 DB	 5
  02f4f	05		 DB	 5
  02f50	05		 DB	 5
  02f51	05		 DB	 5
  02f52	05		 DB	 5
  02f53	05		 DB	 5
  02f54	05		 DB	 5
  02f55	05		 DB	 5
  02f56	05		 DB	 5
  02f57	05		 DB	 5
  02f58	05		 DB	 5
  02f59	05		 DB	 5
  02f5a	05		 DB	 5
  02f5b	05		 DB	 5
  02f5c	05		 DB	 5
  02f5d	05		 DB	 5
  02f5e	05		 DB	 5
  02f5f	05		 DB	 5
  02f60	05		 DB	 5
  02f61	05		 DB	 5
  02f62	05		 DB	 5
  02f63	05		 DB	 5
  02f64	05		 DB	 5
  02f65	05		 DB	 5
  02f66	05		 DB	 5
  02f67	05		 DB	 5
  02f68	05		 DB	 5
  02f69	05		 DB	 5
  02f6a	05		 DB	 5
  02f6b	05		 DB	 5
  02f6c	05		 DB	 5
  02f6d	05		 DB	 5
  02f6e	05		 DB	 5
  02f6f	05		 DB	 5
  02f70	05		 DB	 5
  02f71	05		 DB	 5
  02f72	05		 DB	 5
  02f73	05		 DB	 5
  02f74	05		 DB	 5
  02f75	05		 DB	 5
  02f76	05		 DB	 5
  02f77	05		 DB	 5
  02f78	05		 DB	 5
  02f79	05		 DB	 5
  02f7a	05		 DB	 5
  02f7b	05		 DB	 5
  02f7c	05		 DB	 5
  02f7d	05		 DB	 5
  02f7e	05		 DB	 5
  02f7f	05		 DB	 5
  02f80	05		 DB	 5
  02f81	05		 DB	 5
  02f82	05		 DB	 5
  02f83	05		 DB	 5
  02f84	05		 DB	 5
  02f85	05		 DB	 5
  02f86	05		 DB	 5
  02f87	05		 DB	 5
  02f88	04		 DB	 4
_NCLButtonDown ENDP
; Function compile flags: /Odt
_si$ = -4						; size = 4
_sb$ = 8						; size = 4
_IsScrollbarActive PROC NEAR

; 155  : {

  02f90	55		 push	 ebp
  02f91	8b ec		 mov	 ebp, esp
  02f93	51		 push	 ecx

; 156  : 	SCROLLINFO *si = &sb->scrollInfo;

  02f94	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  02f97	83 c0 08	 add	 eax, 8
  02f9a	89 45 fc	 mov	 DWORD PTR _si$[ebp], eax

; 157  : 	if(((sb->fScrollFlags & ESB_DISABLE_BOTH) == ESB_DISABLE_BOTH) ||
; 158  : 		!(sb->fScrollFlags & CSBS_THUMBALWAYS) && !IsScrollInfoActive(si))

  02f9d	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  02fa0	8b 11		 mov	 edx, DWORD PTR [ecx]
  02fa2	83 e2 03	 and	 edx, 3
  02fa5	83 fa 03	 cmp	 edx, 3
  02fa8	74 1a		 je	 SHORT $L22488
  02faa	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  02fad	8b 08		 mov	 ecx, DWORD PTR [eax]
  02faf	83 e1 04	 and	 ecx, 4
  02fb2	75 14		 jne	 SHORT $L22487
  02fb4	8b 55 fc	 mov	 edx, DWORD PTR _si$[ebp]
  02fb7	52		 push	 edx
  02fb8	e8 00 00 00 00	 call	 _IsScrollInfoActive
  02fbd	83 c4 04	 add	 esp, 4
  02fc0	85 c0		 test	 eax, eax
  02fc2	75 04		 jne	 SHORT $L22487
$L22488:

; 159  : 		return FALSE;

  02fc4	33 c0		 xor	 eax, eax
  02fc6	eb 05		 jmp	 SHORT $L22485
$L22487:

; 160  : 	else
; 161  : 		return TRUE;

  02fc8	b8 01 00 00 00	 mov	 eax, 1
$L22485:

; 162  : }

  02fcd	8b e5		 mov	 esp, ebp
  02fcf	5d		 pop	 ebp
  02fd0	c3		 ret	 0
_IsScrollbarActive ENDP
; Function compile flags: /Odt
_hwnd$ = 8						; size = 4
_scrMsg$ = 12						; size = 4
_scrId$ = 16						; size = 4
_pos$ = 20						; size = 4
_SendScrollMessage PROC NEAR

; 401  : {

  02fe0	55		 push	 ebp
  02fe1	8b ec		 mov	 ebp, esp

; 402  : 	SendMessage(hwnd, scrMsg, MAKEWPARAM(scrId, pos), 0);

  02fe3	6a 00		 push	 0
  02fe5	8b 45 10	 mov	 eax, DWORD PTR _scrId$[ebp]
  02fe8	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  02fed	0f b7 c8	 movzx	 ecx, ax
  02ff0	8b 55 14	 mov	 edx, DWORD PTR _pos$[ebp]
  02ff3	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  02ff9	0f b7 c2	 movzx	 eax, dx
  02ffc	c1 e0 10	 shl	 eax, 16			; 00000010H
  02fff	0b c8		 or	 ecx, eax
  03001	51		 push	 ecx
  03002	8b 4d 0c	 mov	 ecx, DWORD PTR _scrMsg$[ebp]
  03005	51		 push	 ecx
  03006	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03009	52		 push	 edx
  0300a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 403  : }

  03010	5d		 pop	 ebp
  03011	c3		 ret	 0
_SendScrollMessage ENDP
; Function compile flags: /Odt
_thumbpos$ = -20					; size = 4
_thumbwidth$ = -16					; size = 4
_scrollwidth$ = -12					; size = 4
_workingwidth$ = -8					; size = 4
_butwidth$ = -4						; size = 4
_sbar$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_GetHorzScrollPortion PROC NEAR

; 614  : {

  03020	55		 push	 ebp
  03021	8b ec		 mov	 ebp, esp
  03023	83 ec 14	 sub	 esp, 20			; 00000014H

; 615  : 	int thumbwidth, thumbpos;
; 616  : 	int butwidth = GetScrollMetric(sbar, SM_SCROLL_LENGTH);

  03026	6a 00		 push	 0
  03028	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  0302b	50		 push	 eax
  0302c	e8 00 00 00 00	 call	 _GetScrollMetric
  03031	83 c4 08	 add	 esp, 8
  03034	89 45 fc	 mov	 DWORD PTR _butwidth$[ebp], eax

; 617  : 	int scrollwidth  = rect->right-rect->left;

  03037	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0303a	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  0303d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  03040	2b 02		 sub	 eax, DWORD PTR [edx]
  03042	89 45 f4	 mov	 DWORD PTR _scrollwidth$[ebp], eax

; 618  : 	int workingwidth = scrollwidth - butwidth*2;

  03045	8b 4d fc	 mov	 ecx, DWORD PTR _butwidth$[ebp]
  03048	d1 e1		 shl	 ecx, 1
  0304a	8b 55 f4	 mov	 edx, DWORD PTR _scrollwidth$[ebp]
  0304d	2b d1		 sub	 edx, ecx
  0304f	89 55 f8	 mov	 DWORD PTR _workingwidth$[ebp], edx

; 619  : 
; 620  : 	if(y < rect->top || y >= rect->bottom)

  03052	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03055	8b 4d 18	 mov	 ecx, DWORD PTR _y$[ebp]
  03058	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0305b	7c 0b		 jl	 SHORT $L22725
  0305d	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  03060	8b 45 18	 mov	 eax, DWORD PTR _y$[ebp]
  03063	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  03066	7c 08		 jl	 SHORT $L22724
$L22725:

; 621  : 		return HTSCROLL_NONE;

  03068	83 c8 ff	 or	 eax, -1
  0306b	e9 d1 00 00 00	 jmp	 $L22718
$L22724:

; 622  : 
; 623  : 	CalcThumbSize(sbar, rect, &thumbwidth, &thumbpos);

  03070	8d 4d ec	 lea	 ecx, DWORD PTR _thumbpos$[ebp]
  03073	51		 push	 ecx
  03074	8d 55 f0	 lea	 edx, DWORD PTR _thumbwidth$[ebp]
  03077	52		 push	 edx
  03078	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  0307b	50		 push	 eax
  0307c	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  0307f	51		 push	 ecx
  03080	e8 00 00 00 00	 call	 _CalcThumbSize
  03085	83 c4 10	 add	 esp, 16			; 00000010H

; 624  : 
; 625  : 	//if we have had to scale the buttons to fit in the rect,
; 626  : 	//then adjust the button width accordingly
; 627  : 	if(scrollwidth <= butwidth * 2)

  03088	8b 55 fc	 mov	 edx, DWORD PTR _butwidth$[ebp]
  0308b	d1 e2		 shl	 edx, 1
  0308d	39 55 f4	 cmp	 DWORD PTR _scrollwidth$[ebp], edx
  03090	7f 0b		 jg	 SHORT $L22726

; 628  : 	{
; 629  : 		butwidth = scrollwidth / 2;	

  03092	8b 45 f4	 mov	 eax, DWORD PTR _scrollwidth$[ebp]
  03095	99		 cdq
  03096	2b c2		 sub	 eax, edx
  03098	d1 f8		 sar	 eax, 1
  0309a	89 45 fc	 mov	 DWORD PTR _butwidth$[ebp], eax
$L22726:

; 630  : 	}
; 631  : 
; 632  : 	//check for left button click
; 633  : 	if(x >= rect->left && x < rect->left + butwidth)

  0309d	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  030a0	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  030a3	3b 08		 cmp	 ecx, DWORD PTR [eax]
  030a5	7c 14		 jl	 SHORT $L22727
  030a7	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  030aa	8b 02		 mov	 eax, DWORD PTR [edx]
  030ac	03 45 fc	 add	 eax, DWORD PTR _butwidth$[ebp]
  030af	39 45 14	 cmp	 DWORD PTR _x$[ebp], eax
  030b2	7d 07		 jge	 SHORT $L22727

; 634  : 	{
; 635  : 		return HTSCROLL_LEFT;	

  030b4	33 c0		 xor	 eax, eax
  030b6	e9 86 00 00 00	 jmp	 $L22718
$L22727:

; 636  : 	}
; 637  : 	//check for right button click
; 638  : 	else if(x >= rect->right-butwidth && x < rect->right)

  030bb	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  030be	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  030c1	2b 55 fc	 sub	 edx, DWORD PTR _butwidth$[ebp]
  030c4	39 55 14	 cmp	 DWORD PTR _x$[ebp], edx
  030c7	7c 12		 jl	 SHORT $L22728
  030c9	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  030cc	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  030cf	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  030d2	7d 07		 jge	 SHORT $L22728

; 639  : 	{
; 640  : 		return HTSCROLL_RIGHT;

  030d4	b8 01 00 00 00	 mov	 eax, 1
  030d9	eb 66		 jmp	 SHORT $L22718
$L22728:

; 641  : 	}
; 642  : 	
; 643  : 	//if the thumb is too big to fit (i.e. it isn't visible)
; 644  : 	//then return a NULL scrollbar area
; 645  : 	if(thumbwidth >= workingwidth)

  030db	8b 55 f0	 mov	 edx, DWORD PTR _thumbwidth$[ebp]
  030de	3b 55 f8	 cmp	 edx, DWORD PTR _workingwidth$[ebp]
  030e1	7c 05		 jl	 SHORT $L22730

; 646  : 		return HTSCROLL_NONE;

  030e3	83 c8 ff	 or	 eax, -1
  030e6	eb 59		 jmp	 SHORT $L22718
$L22730:

; 647  : 	
; 648  : 	//check for point in the thumbbar
; 649  : 	if(x >= thumbpos && x < thumbpos+thumbwidth)

  030e8	8b 45 14	 mov	 eax, DWORD PTR _x$[ebp]
  030eb	3b 45 ec	 cmp	 eax, DWORD PTR _thumbpos$[ebp]
  030ee	7c 12		 jl	 SHORT $L22731
  030f0	8b 4d ec	 mov	 ecx, DWORD PTR _thumbpos$[ebp]
  030f3	03 4d f0	 add	 ecx, DWORD PTR _thumbwidth$[ebp]
  030f6	39 4d 14	 cmp	 DWORD PTR _x$[ebp], ecx
  030f9	7d 07		 jge	 SHORT $L22731

; 650  : 	{
; 651  : 		return HTSCROLL_THUMB;

  030fb	b8 05 00 00 00	 mov	 eax, 5
  03100	eb 3f		 jmp	 SHORT $L22718
$L22731:

; 652  : 	}	
; 653  : 	//check for left margin
; 654  : 	else if(x >= rect->left+butwidth && x < thumbpos)

  03102	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  03105	8b 02		 mov	 eax, DWORD PTR [edx]
  03107	03 45 fc	 add	 eax, DWORD PTR _butwidth$[ebp]
  0310a	39 45 14	 cmp	 DWORD PTR _x$[ebp], eax
  0310d	7c 0f		 jl	 SHORT $L22733
  0310f	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  03112	3b 4d ec	 cmp	 ecx, DWORD PTR _thumbpos$[ebp]
  03115	7d 07		 jge	 SHORT $L22733

; 655  : 	{
; 656  : 		return HTSCROLL_PAGELEFT;

  03117	b8 02 00 00 00	 mov	 eax, 2
  0311c	eb 23		 jmp	 SHORT $L22718
$L22733:

; 657  : 	}
; 658  : 	else if(x >= thumbpos+thumbwidth && x < rect->right-butwidth)

  0311e	8b 55 ec	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  03121	03 55 f0	 add	 edx, DWORD PTR _thumbwidth$[ebp]
  03124	39 55 14	 cmp	 DWORD PTR _x$[ebp], edx
  03127	7c 15		 jl	 SHORT $L22732
  03129	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  0312c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0312f	2b 4d fc	 sub	 ecx, DWORD PTR _butwidth$[ebp]
  03132	39 4d 14	 cmp	 DWORD PTR _x$[ebp], ecx
  03135	7d 07		 jge	 SHORT $L22732

; 659  : 	{
; 660  : 		return HTSCROLL_PAGERIGHT;

  03137	b8 03 00 00 00	 mov	 eax, 3
  0313c	eb 03		 jmp	 SHORT $L22718
$L22732:

; 661  : 	}
; 662  : 	
; 663  : 	return HTSCROLL_NONE;

  0313e	83 c8 ff	 or	 eax, -1
$L22718:

; 664  : }

  03141	8b e5		 mov	 esp, ebp
  03143	5d		 pop	 ebp
  03144	c3		 ret	 0
_GetHorzScrollPortion ENDP
; Function compile flags: /Odt
_r$ = -4						; size = 4
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_GetVertScrollPortion PROC NEAR

; 671  : {

  03150	55		 push	 ebp
  03151	8b ec		 mov	 ebp, esp
  03153	51		 push	 ecx

; 672  : 	UINT r;
; 673  : 	
; 674  : 	RotateRect(rect);

  03154	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03157	50		 push	 eax
  03158	e8 00 00 00 00	 call	 _RotateRect@4

; 675  : 	r = GetHorzScrollPortion(sb, hwnd, rect, y, x);

  0315d	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  03160	51		 push	 ecx
  03161	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  03164	52		 push	 edx
  03165	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03168	50		 push	 eax
  03169	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0316c	51		 push	 ecx
  0316d	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  03170	52		 push	 edx
  03171	e8 00 00 00 00	 call	 _GetHorzScrollPortion
  03176	83 c4 14	 add	 esp, 20			; 00000014H
  03179	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 676  : 	RotateRect(rect);

  0317c	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  0317f	50		 push	 eax
  03180	e8 00 00 00 00	 call	 _RotateRect@4

; 677  : 	return r;

  03185	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]

; 678  : }

  03188	8b e5		 mov	 esp, ebp
  0318a	5d		 pop	 ebp
  0318b	c3		 ret	 0
_GetVertScrollPortion ENDP
; Function compile flags: /Odt
_nmcb$ = -48						; size = 48
_hwnd$ = 8						; size = 4
_msg$ = 12						; size = 4
_nBar$ = 16						; size = 4
_prect$ = 20						; size = 4
_nCmdId$ = 24						; size = 4
_pt$ = 28						; size = 8
_PostMouseNotify0 PROC NEAR

; 751  : {

  03190	55		 push	 ebp
  03191	8b ec		 mov	 ebp, esp
  03193	83 ec 30	 sub	 esp, 48			; 00000030H

; 752  : #ifdef NOTIFY_MOUSE
; 753  : 	NMCOOLBUTMSG	nmcb;
; 754  : 
; 755  : 	//fill in the standard header
; 756  : 	nmcb.hdr.hwndFrom	= hwnd;

  03196	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03199	89 45 d0	 mov	 DWORD PTR _nmcb$[ebp], eax

; 757  : 	nmcb.hdr.idFrom		= GetWindowLong(hwnd, GWL_ID);

  0319c	6a f4		 push	 -12			; fffffff4H
  0319e	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  031a1	51		 push	 ecx
  031a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  031a8	89 45 d4	 mov	 DWORD PTR _nmcb$[ebp+4], eax

; 758  : 	nmcb.hdr.code		= NM_CLICK;

  031ab	c7 45 d8 fe ff
	ff ff		 mov	 DWORD PTR _nmcb$[ebp+8], -2 ; fffffffeH

; 759  : 
; 760  : 	nmcb.nBar			= nBar;

  031b2	8b 55 10	 mov	 edx, DWORD PTR _nBar$[ebp]
  031b5	89 55 fc	 mov	 DWORD PTR _nmcb$[ebp+44], edx

; 761  : 	nmcb.uCmdId			= nCmdId;

  031b8	8b 45 18	 mov	 eax, DWORD PTR _nCmdId$[ebp]
  031bb	89 45 f4	 mov	 DWORD PTR _nmcb$[ebp+36], eax

; 762  : 	nmcb.uState			= 0;

  031be	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nmcb$[ebp+40], 0

; 763  : 	nmcb.rect			= *prect;

  031c5	8b 4d 14	 mov	 ecx, DWORD PTR _prect$[ebp]
  031c8	8b 11		 mov	 edx, DWORD PTR [ecx]
  031ca	89 55 dc	 mov	 DWORD PTR _nmcb$[ebp+12], edx
  031cd	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  031d0	89 45 e0	 mov	 DWORD PTR _nmcb$[ebp+16], eax
  031d3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  031d6	89 55 e4	 mov	 DWORD PTR _nmcb$[ebp+20], edx
  031d9	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  031dc	89 45 e8	 mov	 DWORD PTR _nmcb$[ebp+24], eax

; 764  : 	nmcb.pt				= pt;

  031df	8b 4d 1c	 mov	 ecx, DWORD PTR _pt$[ebp]
  031e2	89 4d ec	 mov	 DWORD PTR _nmcb$[ebp+28], ecx
  031e5	8b 55 20	 mov	 edx, DWORD PTR _pt$[ebp+4]
  031e8	89 55 f0	 mov	 DWORD PTR _nmcb$[ebp+32], edx

; 765  : 
; 766  : 	hwnd = GetParent(hwnd);

  031eb	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  031ee	50		 push	 eax
  031ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  031f5	89 45 08	 mov	 DWORD PTR _hwnd$[ebp], eax

; 767  : 	return SendMessage(hwnd, WM_NOTIFY, nmcb.hdr.idFrom, (LPARAM)&nmcb);

  031f8	8d 4d d0	 lea	 ecx, DWORD PTR _nmcb$[ebp]
  031fb	51		 push	 ecx
  031fc	8b 55 d4	 mov	 edx, DWORD PTR _nmcb$[ebp+4]
  031ff	52		 push	 edx
  03200	6a 4e		 push	 78			; 0000004eH
  03202	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03205	50		 push	 eax
  03206	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 768  : #else
; 769  : 	return 0;
; 770  : #endif
; 771  : }

  0320c	8b e5		 mov	 esp, ebp
  0320e	5d		 pop	 ebp
  0320f	c3		 ret	 0
_PostMouseNotify0 ENDP
; Function compile flags: /Odt
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_hdc$ = 16						; size = 4
_rect$ = 20						; size = 4
_uDrawFlags$ = 24					; size = 4
_NCDrawScrollbar PROC NEAR

; 1090 : {

  03210	55		 push	 ebp
  03211	8b ec		 mov	 ebp, esp

; 1091 : 	if(sb->nBarType == SB_HORZ)

  03213	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03216	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  0321d	75 1e		 jne	 SHORT $L22914

; 1092 : 		return NCDrawHScrollbar(sb, hwnd, hdc, rect, uDrawFlags);

  0321f	8b 4d 18	 mov	 ecx, DWORD PTR _uDrawFlags$[ebp]
  03222	51		 push	 ecx
  03223	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  03226	52		 push	 edx
  03227	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  0322a	50		 push	 eax
  0322b	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0322e	51		 push	 ecx
  0322f	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  03232	52		 push	 edx
  03233	e8 00 00 00 00	 call	 _NCDrawHScrollbar
  03238	83 c4 14	 add	 esp, 20			; 00000014H
  0323b	eb 1c		 jmp	 SHORT $L22913
$L22914:

; 1093 : 	else
; 1094 : 		return NCDrawVScrollbar(sb, hwnd, hdc, rect, uDrawFlags);

  0323d	8b 45 18	 mov	 eax, DWORD PTR _uDrawFlags$[ebp]
  03240	50		 push	 eax
  03241	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  03244	51		 push	 ecx
  03245	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  03248	52		 push	 edx
  03249	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0324c	50		 push	 eax
  0324d	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  03250	51		 push	 ecx
  03251	e8 00 00 00 00	 call	 _NCDrawVScrollbar
  03256	83 c4 14	 add	 esp, 20			; 00000014H
$L22913:

; 1095 : }

  03259	5d		 pop	 ebp
  0325a	c3		 ret	 0
_NCDrawScrollbar ENDP
; Function compile flags: /Odt
_rc$ = -16						; size = 16
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_GetHorzPortion PROC NEAR

; 1661 : {

  03260	55		 push	 ebp
  03261	8b ec		 mov	 ebp, esp
  03263	83 ec 10	 sub	 esp, 16			; 00000010H

; 1662 : 	RECT rc = *rect;

  03266	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03269	8b 08		 mov	 ecx, DWORD PTR [eax]
  0326b	89 4d f0	 mov	 DWORD PTR _rc$[ebp], ecx
  0326e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  03271	89 55 f4	 mov	 DWORD PTR _rc$[ebp+4], edx
  03274	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  03277	89 4d f8	 mov	 DWORD PTR _rc$[ebp+8], ecx
  0327a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0327d	89 55 fc	 mov	 DWORD PTR _rc$[ebp+12], edx

; 1663 : 
; 1664 : 	if(y < rc.top || y >= rc.bottom) return HTSCROLL_NONE;

  03280	8b 45 18	 mov	 eax, DWORD PTR _y$[ebp]
  03283	3b 45 f4	 cmp	 eax, DWORD PTR _rc$[ebp+4]
  03286	7c 08		 jl	 SHORT $L23132
  03288	8b 4d 18	 mov	 ecx, DWORD PTR _y$[ebp]
  0328b	3b 4d fc	 cmp	 ecx, DWORD PTR _rc$[ebp+12]
  0328e	7c 08		 jl	 SHORT $L23131
$L23132:
  03290	83 c8 ff	 or	 eax, -1
  03293	e9 92 00 00 00	 jmp	 $L23129
$L23131:

; 1665 : 
; 1666 : #ifdef INCLUDE_BUTTONS
; 1667 : 
; 1668 : 	if(sb->fButVisibleBefore) 

  03298	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  0329b	83 ba 38 03 00
	00 00		 cmp	 DWORD PTR [edx+824], 0
  032a2	74 2f		 je	 SHORT $L23133

; 1669 : 	{
; 1670 : 		//clicked on the buttons to the left of the scrollbar
; 1671 : 		if(x >= rc.left && x < rc.left + sb->nButSizeBefore)

  032a4	8b 45 14	 mov	 eax, DWORD PTR _x$[ebp]
  032a7	3b 45 f0	 cmp	 eax, DWORD PTR _rc$[ebp]
  032aa	7c 18		 jl	 SHORT $L23134
  032ac	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  032af	8b 55 f0	 mov	 edx, DWORD PTR _rc$[ebp]
  032b2	03 91 30 03 00
	00		 add	 edx, DWORD PTR [ecx+816]
  032b8	39 55 14	 cmp	 DWORD PTR _x$[ebp], edx
  032bb	7d 07		 jge	 SHORT $L23134

; 1672 : 			return HTSCROLL_INSERTED;

  032bd	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  032c2	eb 66		 jmp	 SHORT $L23129
$L23134:

; 1673 : 
; 1674 : 		//adjust the rectangle to exclude the left-side buttons, now that we
; 1675 : 		//know we havn't clicked on them
; 1676 : 		rc.left  += sb->nButSizeBefore;

  032c4	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  032c7	8b 4d f0	 mov	 ecx, DWORD PTR _rc$[ebp]
  032ca	03 88 30 03 00
	00		 add	 ecx, DWORD PTR [eax+816]
  032d0	89 4d f0	 mov	 DWORD PTR _rc$[ebp], ecx
$L23133:

; 1677 : 	}
; 1678 : 
; 1679 : 	if(sb->fButVisibleAfter)

  032d3	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  032d6	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  032dd	74 2f		 je	 SHORT $L23135

; 1680 : 	{
; 1681 : 		//clicked on the buttons to the right of the scrollbar
; 1682 : 		if(x >= rc.right - sb->nButSizeAfter && x < rc.right)

  032df	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  032e2	8b 4d f8	 mov	 ecx, DWORD PTR _rc$[ebp+8]
  032e5	2b 88 34 03 00
	00		 sub	 ecx, DWORD PTR [eax+820]
  032eb	39 4d 14	 cmp	 DWORD PTR _x$[ebp], ecx
  032ee	7c 0f		 jl	 SHORT $L23136
  032f0	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  032f3	3b 55 f8	 cmp	 edx, DWORD PTR _rc$[ebp+8]
  032f6	7d 07		 jge	 SHORT $L23136

; 1683 : 			return HTSCROLL_INSERTED;

  032f8	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  032fd	eb 2b		 jmp	 SHORT $L23129
$L23136:

; 1684 : 
; 1685 : 		//adjust the rectangle to exclude the right-side buttons, now that we
; 1686 : 		//know we havn't clicked on them
; 1687 : 		rc.right -= sb->nButSizeAfter;

  032ff	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03302	8b 4d f8	 mov	 ecx, DWORD PTR _rc$[ebp+8]
  03305	2b 88 34 03 00
	00		 sub	 ecx, DWORD PTR [eax+820]
  0330b	89 4d f8	 mov	 DWORD PTR _rc$[ebp+8], ecx
$L23135:

; 1688 : 	}
; 1689 : 
; 1690 : #endif INCLUDE_BUTTONS
; 1691 : 
; 1692 : 	//Now we have the rectangle for the scrollbar itself, so work out
; 1693 : 	//what part we clicked on.
; 1694 : 	return GetHorzScrollPortion(sb, hwnd, &rc, x, y);

  0330e	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  03311	52		 push	 edx
  03312	8b 45 14	 mov	 eax, DWORD PTR _x$[ebp]
  03315	50		 push	 eax
  03316	8d 4d f0	 lea	 ecx, DWORD PTR _rc$[ebp]
  03319	51		 push	 ecx
  0331a	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0331d	52		 push	 edx
  0331e	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03321	50		 push	 eax
  03322	e8 00 00 00 00	 call	 _GetHorzScrollPortion
  03327	83 c4 14	 add	 esp, 20			; 00000014H
$L23129:

; 1695 : }

  0332a	8b e5		 mov	 esp, ebp
  0332c	5d		 pop	 ebp
  0332d	c3		 ret	 0
_GetHorzPortion ENDP
; Function compile flags: /Odt
_ret$ = -4						; size = 4
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_GetVertPortion PROC NEAR

; 1701 : {

  03330	55		 push	 ebp
  03331	8b ec		 mov	 ebp, esp
  03333	51		 push	 ecx

; 1702 : 	UINT ret;
; 1703 : 	RotateRect(rect);

  03334	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03337	50		 push	 eax
  03338	e8 00 00 00 00	 call	 _RotateRect@4

; 1704 : 	ret = GetHorzPortion(sb, hwnd, rect, y, x);

  0333d	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  03340	51		 push	 ecx
  03341	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  03344	52		 push	 edx
  03345	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03348	50		 push	 eax
  03349	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0334c	51		 push	 ecx
  0334d	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  03350	52		 push	 edx
  03351	e8 00 00 00 00	 call	 _GetHorzPortion
  03356	83 c4 14	 add	 esp, 20			; 00000014H
  03359	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 1705 : 	RotateRect(rect);

  0335c	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  0335f	50		 push	 eax
  03360	e8 00 00 00 00	 call	 _RotateRect@4

; 1706 : 	return ret;

  03365	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 1707 : }

  03368	8b e5		 mov	 esp, ebp
  0336a	5d		 pop	 ebp
  0336b	c3		 ret	 0
_GetVertPortion ENDP
; Function compile flags: /Odt
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_GetRealScrollRect PROC NEAR

; 1747 : {

  03370	55		 push	 ebp
  03371	8b ec		 mov	 ebp, esp

; 1748 : 	if(sb->nBarType == SB_HORZ)

  03373	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03376	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  0337d	75 12		 jne	 SHORT $L23188

; 1749 : 	{
; 1750 : 		GetRealHorzScrollRect(sb, rect);

  0337f	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  03382	51		 push	 ecx
  03383	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  03386	52		 push	 edx
  03387	e8 00 00 00 00	 call	 _GetRealHorzScrollRect
  0338c	83 c4 08	 add	 esp, 8

; 1751 : 	}
; 1752 : 	else if(sb->nBarType == SB_VERT)

  0338f	eb 1c		 jmp	 SHORT $L23187
$L23188:
  03391	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03394	83 b8 40 03 00
	00 01		 cmp	 DWORD PTR [eax+832], 1
  0339b	75 10		 jne	 SHORT $L23187

; 1753 : 	{
; 1754 : 		GetRealVertScrollRect(sb, rect);

  0339d	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  033a0	51		 push	 ecx
  033a1	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  033a4	52		 push	 edx
  033a5	e8 00 00 00 00	 call	 _GetRealVertScrollRect
  033aa	83 c4 08	 add	 esp, 8
$L23187:

; 1755 : 	}
; 1756 : }

  033ad	5d		 pop	 ebp
  033ae	c3		 ret	 0
_GetRealScrollRect ENDP
; Function compile flags: /Odt
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_GetRealHorzScrollRect PROC NEAR

; 1727 : {

  033b0	55		 push	 ebp
  033b1	8b ec		 mov	 ebp, esp

; 1728 : 	if(sb->fButVisibleBefore) rect->left += sb->nButSizeBefore;

  033b3	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  033b6	83 b8 38 03 00
	00 00		 cmp	 DWORD PTR [eax+824], 0
  033bd	74 13		 je	 SHORT $L23172
  033bf	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  033c2	8b 11		 mov	 edx, DWORD PTR [ecx]
  033c4	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  033c7	03 90 30 03 00
	00		 add	 edx, DWORD PTR [eax+816]
  033cd	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  033d0	89 11		 mov	 DWORD PTR [ecx], edx
$L23172:

; 1729 : 	if(sb->fButVisibleAfter)  rect->right -= sb->nButSizeAfter;

  033d2	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  033d5	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  033dc	74 15		 je	 SHORT $L23171
  033de	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  033e1	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  033e4	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  033e7	2b 91 34 03 00
	00		 sub	 edx, DWORD PTR [ecx+820]
  033ed	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  033f0	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L23171:

; 1730 : }

  033f3	5d		 pop	 ebp
  033f4	c3		 ret	 0
_GetRealHorzScrollRect ENDP
; Function compile flags: /Odt
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_GetRealVertScrollRect PROC NEAR

; 1737 : {

  03400	55		 push	 ebp
  03401	8b ec		 mov	 ebp, esp

; 1738 : 	if(sb->fButVisibleBefore) rect->top += sb->nButSizeBefore;

  03403	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03406	83 b8 38 03 00
	00 00		 cmp	 DWORD PTR [eax+824], 0
  0340d	74 15		 je	 SHORT $L23180
  0340f	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  03412	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  03415	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03418	03 90 30 03 00
	00		 add	 edx, DWORD PTR [eax+816]
  0341e	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  03421	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$L23180:

; 1739 : 	if(sb->fButVisibleAfter)  rect->bottom -= sb->nButSizeAfter;

  03424	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  03427	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  0342e	74 15		 je	 SHORT $L23179
  03430	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  03433	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  03436	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  03439	2b 91 34 03 00
	00		 sub	 edx, DWORD PTR [ecx+820]
  0343f	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  03442	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L23179:

; 1740 : }

  03445	5d		 pop	 ebp
  03446	c3		 ret	 0
_GetRealVertScrollRect ENDP
; Function compile flags: /Odt
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_pt$ = 16						; size = 8
_fReturnRect$ = 24					; size = 4
_GetButtonFromPt PROC NEAR

; 1851 : {

  03450	55		 push	 ebp
  03451	8b ec		 mov	 ebp, esp

; 1852 : 	if(sb->nBarType == SB_HORZ)

  03453	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03456	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  0345d	75 1e		 jne	 SHORT $L23240

; 1853 : 	{
; 1854 : 		return GetHorzButtonFromPt(sb, rect, pt, fReturnRect);

  0345f	8b 4d 18	 mov	 ecx, DWORD PTR _fReturnRect$[ebp]
  03462	51		 push	 ecx
  03463	8b 55 14	 mov	 edx, DWORD PTR _pt$[ebp+4]
  03466	52		 push	 edx
  03467	8b 45 10	 mov	 eax, DWORD PTR _pt$[ebp]
  0346a	50		 push	 eax
  0346b	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  0346e	51		 push	 ecx
  0346f	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  03472	52		 push	 edx
  03473	e8 00 00 00 00	 call	 _GetHorzButtonFromPt
  03478	83 c4 14	 add	 esp, 20			; 00000014H
  0347b	eb 1c		 jmp	 SHORT $L23239
$L23240:

; 1855 : 	}
; 1856 : 	else
; 1857 : 	{
; 1858 : 		return GetVertButtonFromPt(sb, rect, pt, fReturnRect);

  0347d	8b 45 18	 mov	 eax, DWORD PTR _fReturnRect$[ebp]
  03480	50		 push	 eax
  03481	8b 4d 14	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  03484	51		 push	 ecx
  03485	8b 55 10	 mov	 edx, DWORD PTR _pt$[ebp]
  03488	52		 push	 edx
  03489	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0348c	50		 push	 eax
  0348d	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  03490	51		 push	 ecx
  03491	e8 00 00 00 00	 call	 _GetVertButtonFromPt
  03496	83 c4 14	 add	 esp, 20			; 00000014H
$L23239:

; 1859 : 	}
; 1860 : }

  03499	5d		 pop	 ebp
  0349a	c3		 ret	 0
_GetButtonFromPt ENDP
; Function compile flags: /Odt
_rightpos$ = -20					; size = 4
_leftpos$ = -16						; size = 4
_i$ = -12						; size = 4
_butwidth$ = -8						; size = 4
_sbut$ = -4						; size = 4
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_pt$ = 16						; size = 8
_fReturnRect$ = 24					; size = 4
_GetHorzButtonFromPt PROC NEAR

; 1771 : {

  034a0	55		 push	 ebp
  034a1	8b ec		 mov	 ebp, esp
  034a3	83 ec 14	 sub	 esp, 20			; 00000014H

; 1772 : 	int leftpos = rect->left, rightpos = rect->right;

  034a6	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  034a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  034ab	89 4d f0	 mov	 DWORD PTR _leftpos$[ebp], ecx
  034ae	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  034b1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  034b4	89 45 ec	 mov	 DWORD PTR _rightpos$[ebp], eax

; 1773 : 	int i;
; 1774 : 	int butwidth;
; 1775 : 	SCROLLBUT *sbut = sb->sbButtons;

  034b7	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  034ba	83 c1 2c	 add	 ecx, 44			; 0000002cH
  034bd	89 4d fc	 mov	 DWORD PTR _sbut$[ebp], ecx

; 1776 : 
; 1777 : 	if(!PtInRect(rect, pt))

  034c0	8b 55 14	 mov	 edx, DWORD PTR _pt$[ebp+4]
  034c3	52		 push	 edx
  034c4	8b 45 10	 mov	 eax, DWORD PTR _pt$[ebp]
  034c7	50		 push	 eax
  034c8	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  034cb	51		 push	 ecx
  034cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  034d2	85 c0		 test	 eax, eax
  034d4	75 08		 jne	 SHORT $L23206

; 1778 : 		return -1;

  034d6	83 c8 ff	 or	 eax, -1
  034d9	e9 2c 01 00 00	 jmp	 $L23200
$L23206:

; 1779 : 
; 1780 : 	if(sb->fButVisibleAfter)

  034de	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  034e1	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  034e8	74 0f		 je	 SHORT $L23207

; 1781 : 		rightpos -= sb->nButSizeAfter;

  034ea	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  034ed	8b 4d ec	 mov	 ecx, DWORD PTR _rightpos$[ebp]
  034f0	2b 88 34 03 00
	00		 sub	 ecx, DWORD PTR [eax+820]
  034f6	89 4d ec	 mov	 DWORD PTR _rightpos$[ebp], ecx
$L23207:

; 1782 : 
; 1783 : 	for(i = 0; i < sb->nButtons; i++)

  034f9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  03500	eb 09		 jmp	 SHORT $L23208
$L23209:
  03502	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  03505	83 c2 01	 add	 edx, 1
  03508	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$L23208:
  0350b	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0350e	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  03511	3b 88 2c 03 00
	00		 cmp	 ecx, DWORD PTR [eax+812]
  03517	0f 8d ea 00 00
	00		 jge	 $L23210

; 1784 : 	{
; 1785 : 		if(sb->fButVisibleBefore && sbut[i].uPlacement == SBBP_LEFT)

  0351d	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  03520	83 ba 38 03 00
	00 00		 cmp	 DWORD PTR [edx+824], 0
  03527	74 69		 je	 SHORT $L23211
  03529	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0352c	6b c0 30	 imul	 eax, 48			; 00000030H
  0352f	8b 4d fc	 mov	 ecx, DWORD PTR _sbut$[ebp]
  03532	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  03537	75 59		 jne	 SHORT $L23211

; 1786 : 		{
; 1787 : 			butwidth = GetSingleButSize(sb, &sbut[i]);

  03539	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0353c	6b d2 30	 imul	 edx, 48			; 00000030H
  0353f	03 55 fc	 add	 edx, DWORD PTR _sbut$[ebp]
  03542	52		 push	 edx
  03543	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03546	50		 push	 eax
  03547	e8 00 00 00 00	 call	 _GetSingleButSize
  0354c	83 c4 08	 add	 esp, 8
  0354f	89 45 f8	 mov	 DWORD PTR _butwidth$[ebp], eax

; 1788 : 			
; 1789 : 			//if the current button is under the specified point
; 1790 : 			if(pt.x >= leftpos && pt.x < leftpos + butwidth)

  03552	8b 4d 10	 mov	 ecx, DWORD PTR _pt$[ebp]
  03555	3b 4d f0	 cmp	 ecx, DWORD PTR _leftpos$[ebp]
  03558	7c 2d		 jl	 SHORT $L23212
  0355a	8b 55 f0	 mov	 edx, DWORD PTR _leftpos$[ebp]
  0355d	03 55 f8	 add	 edx, DWORD PTR _butwidth$[ebp]
  03560	39 55 10	 cmp	 DWORD PTR _pt$[ebp], edx
  03563	7d 22		 jge	 SHORT $L23212

; 1791 : 			{
; 1792 : 				//if the caller wants us to return the rectangle of the button
; 1793 : 				if(fReturnRect)

  03565	83 7d 18 00	 cmp	 DWORD PTR _fReturnRect$[ebp], 0
  03569	74 14		 je	 SHORT $L23213

; 1794 : 				{
; 1795 : 					rect->left  = leftpos;

  0356b	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0356e	8b 4d f0	 mov	 ecx, DWORD PTR _leftpos$[ebp]
  03571	89 08		 mov	 DWORD PTR [eax], ecx

; 1796 : 					rect->right = leftpos + butwidth;

  03573	8b 55 f0	 mov	 edx, DWORD PTR _leftpos$[ebp]
  03576	03 55 f8	 add	 edx, DWORD PTR _butwidth$[ebp]
  03579	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0357c	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L23213:

; 1797 : 				}
; 1798 : 
; 1799 : 				return i;

  0357f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  03582	e9 83 00 00 00	 jmp	 $L23200
$L23212:

; 1800 : 			}
; 1801 : 
; 1802 : 			leftpos += butwidth;

  03587	8b 4d f0	 mov	 ecx, DWORD PTR _leftpos$[ebp]
  0358a	03 4d f8	 add	 ecx, DWORD PTR _butwidth$[ebp]
  0358d	89 4d f0	 mov	 DWORD PTR _leftpos$[ebp], ecx

; 1803 : 		}
; 1804 : 		else if(sb->fButVisibleAfter && sbut[i].uPlacement == SBBP_RIGHT)

  03590	eb 70		 jmp	 SHORT $L23214
$L23211:
  03592	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  03595	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  0359c	74 64		 je	 SHORT $L23214
  0359e	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  035a1	6b c0 30	 imul	 eax, 48			; 00000030H
  035a4	8b 4d fc	 mov	 ecx, DWORD PTR _sbut$[ebp]
  035a7	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  035ac	75 54		 jne	 SHORT $L23214

; 1805 : 		{
; 1806 : 			butwidth = GetSingleButSize(sb, &sbut[i]);

  035ae	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  035b1	6b d2 30	 imul	 edx, 48			; 00000030H
  035b4	03 55 fc	 add	 edx, DWORD PTR _sbut$[ebp]
  035b7	52		 push	 edx
  035b8	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  035bb	50		 push	 eax
  035bc	e8 00 00 00 00	 call	 _GetSingleButSize
  035c1	83 c4 08	 add	 esp, 8
  035c4	89 45 f8	 mov	 DWORD PTR _butwidth$[ebp], eax

; 1807 : 
; 1808 : 			//if the current button is under the specified point
; 1809 : 			if(pt.x >= rightpos && pt.x < rightpos + butwidth)

  035c7	8b 4d 10	 mov	 ecx, DWORD PTR _pt$[ebp]
  035ca	3b 4d ec	 cmp	 ecx, DWORD PTR _rightpos$[ebp]
  035cd	7c 2a		 jl	 SHORT $L23216
  035cf	8b 55 ec	 mov	 edx, DWORD PTR _rightpos$[ebp]
  035d2	03 55 f8	 add	 edx, DWORD PTR _butwidth$[ebp]
  035d5	39 55 10	 cmp	 DWORD PTR _pt$[ebp], edx
  035d8	7d 1f		 jge	 SHORT $L23216

; 1810 : 			{
; 1811 : 				//if the caller wants us to return the rectangle of the button
; 1812 : 				if(fReturnRect)

  035da	83 7d 18 00	 cmp	 DWORD PTR _fReturnRect$[ebp], 0
  035de	74 14		 je	 SHORT $L23217

; 1813 : 				{
; 1814 : 					rect->left  = rightpos;

  035e0	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  035e3	8b 4d ec	 mov	 ecx, DWORD PTR _rightpos$[ebp]
  035e6	89 08		 mov	 DWORD PTR [eax], ecx

; 1815 : 					rect->right = rightpos + butwidth;

  035e8	8b 55 ec	 mov	 edx, DWORD PTR _rightpos$[ebp]
  035eb	03 55 f8	 add	 edx, DWORD PTR _butwidth$[ebp]
  035ee	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  035f1	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L23217:

; 1816 : 				}
; 1817 : 				return i;

  035f4	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  035f7	eb 11		 jmp	 SHORT $L23200
$L23216:

; 1818 : 			}
; 1819 : 
; 1820 : 			rightpos += butwidth;

  035f9	8b 4d ec	 mov	 ecx, DWORD PTR _rightpos$[ebp]
  035fc	03 4d f8	 add	 ecx, DWORD PTR _butwidth$[ebp]
  035ff	89 4d ec	 mov	 DWORD PTR _rightpos$[ebp], ecx
$L23214:

; 1821 : 		}
; 1822 : 	}

  03602	e9 fb fe ff ff	 jmp	 $L23209
$L23210:

; 1823 : 
; 1824 : 	return -1;

  03607	83 c8 ff	 or	 eax, -1
$L23200:

; 1825 : }

  0360a	8b e5		 mov	 esp, ebp
  0360c	5d		 pop	 ebp
  0360d	c3		 ret	 0
_GetHorzButtonFromPt ENDP
; Function compile flags: /Odt
_ret$ = -8						; size = 4
_temp$ = -4						; size = 4
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_pt$ = 16						; size = 8
_fReturnRect$ = 24					; size = 4
_GetVertButtonFromPt PROC NEAR

; 1829 : {

  03610	55		 push	 ebp
  03611	8b ec		 mov	 ebp, esp
  03613	83 ec 08	 sub	 esp, 8

; 1830 : 	UINT ret;
; 1831 : 	int temp;
; 1832 : 	
; 1833 : 	//swap the X/Y coords
; 1834 : 	temp = pt.x;

  03616	8b 45 10	 mov	 eax, DWORD PTR _pt$[ebp]
  03619	89 45 fc	 mov	 DWORD PTR _temp$[ebp], eax

; 1835 : 	pt.x = pt.y;

  0361c	8b 4d 14	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  0361f	89 4d 10	 mov	 DWORD PTR _pt$[ebp], ecx

; 1836 : 	pt.y = temp;

  03622	8b 55 fc	 mov	 edx, DWORD PTR _temp$[ebp]
  03625	89 55 14	 mov	 DWORD PTR _pt$[ebp+4], edx

; 1837 : 
; 1838 : 	//swap the rectangle
; 1839 : 	RotateRect(rect);

  03628	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0362b	50		 push	 eax
  0362c	e8 00 00 00 00	 call	 _RotateRect@4

; 1840 : 	
; 1841 : 	ret = GetHorzButtonFromPt(sb, rect, pt, fReturnRect);

  03631	8b 4d 18	 mov	 ecx, DWORD PTR _fReturnRect$[ebp]
  03634	51		 push	 ecx
  03635	8b 55 14	 mov	 edx, DWORD PTR _pt$[ebp+4]
  03638	52		 push	 edx
  03639	8b 45 10	 mov	 eax, DWORD PTR _pt$[ebp]
  0363c	50		 push	 eax
  0363d	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  03640	51		 push	 ecx
  03641	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  03644	52		 push	 edx
  03645	e8 00 00 00 00	 call	 _GetHorzButtonFromPt
  0364a	83 c4 14	 add	 esp, 20			; 00000014H
  0364d	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 1842 : 
; 1843 : 	RotateRect(rect);

  03650	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  03653	50		 push	 eax
  03654	e8 00 00 00 00	 call	 _RotateRect@4

; 1844 : 	return ret;

  03659	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 1845 : }

  0365c	8b e5		 mov	 esp, ebp
  0365e	5d		 pop	 ebp
  0365f	c3		 ret	 0
_GetVertButtonFromPt ENDP
_TEXT	ENDS
EXTRN	__imp__GetMessagePos@0:NEAR
EXTRN	__imp__ReleaseCapture@0:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv82 = -64						; size = 4
_cmdid$23366 = -60					; size = 4
_sbut$23365 = -56					; size = 4
_sb$23351 = -52						; size = 4
_hdc$ = -48						; size = 4
_buttonIdx$ = -44					; size = 4
_pt$ = -40						; size = 8
_winrect$ = -32						; size = 16
_rect$ = -16						; size = 16
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_LButtonUp PROC NEAR

; 2116 : {

  03660	55		 push	 ebp
  03661	8b ec		 mov	 ebp, esp
  03663	83 ec 40	 sub	 esp, 64			; 00000040H

; 2117 : 	RECT rect;
; 2118 : 	//UINT thisportion;
; 2119 : 	HDC hdc;
; 2120 : 	POINT pt;
; 2121 : 	RECT winrect;
; 2122 : 	UINT buttonIdx = 0;

  03666	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _buttonIdx$[ebp], 0

; 2123 : 	
; 2124 : 	//current scrollportion is the button that we clicked down on
; 2125 : 	if(uCurrentScrollPortion != HTSCROLL_NONE)

  0366d	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _uCurrentScrollPortion, -1
  03674	0f 84 dc 02 00
	00		 je	 $L23381

; 2126 : 	{
; 2127 : 		SCROLLBAR *sb = &sw->sbarHorz;

  0367a	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0367d	83 c0 08	 add	 eax, 8
  03680	89 45 cc	 mov	 DWORD PTR _sb$23351[ebp], eax

; 2128 : 		lParam = GetMessagePos();

  03683	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  03689	89 45 14	 mov	 DWORD PTR _lParam$[ebp], eax

; 2129 : 		ReleaseCapture();

  0368c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseCapture@0

; 2130 : 
; 2131 : 		GetWindowRect(hwnd, &winrect);

  03692	8d 4d e0	 lea	 ecx, DWORD PTR _winrect$[ebp]
  03695	51		 push	 ecx
  03696	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03699	52		 push	 edx
  0369a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 2132 : 		pt.x = LOWORD(lParam);

  036a0	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  036a3	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  036a8	0f b7 c8	 movzx	 ecx, ax
  036ab	89 4d d8	 mov	 DWORD PTR _pt$[ebp], ecx

; 2133 : 		pt.y = HIWORD(lParam);

  036ae	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  036b1	c1 ea 10	 shr	 edx, 16			; 00000010H
  036b4	0f b7 c2	 movzx	 eax, dx
  036b7	89 45 dc	 mov	 DWORD PTR _pt$[ebp+4], eax

; 2134 : 
; 2135 : 		//emulate the mouse input on a scrollbar here...
; 2136 : 		if(uCurrentScrollbar == SB_HORZ)

  036ba	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  036c1	75 1f		 jne	 SHORT $L23356

; 2137 : 		{
; 2138 : 			//get the total area of the normal Horz scrollbar area
; 2139 : 			sb = &sw->sbarHorz;

  036c3	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  036c6	83 c1 08	 add	 ecx, 8
  036c9	89 4d cc	 mov	 DWORD PTR _sb$23351[ebp], ecx

; 2140 : 			GetHScrollRect(sw, hwnd, &rect);

  036cc	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  036cf	52		 push	 edx
  036d0	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  036d3	50		 push	 eax
  036d4	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  036d7	51		 push	 ecx
  036d8	e8 00 00 00 00	 call	 _GetHScrollRect
  036dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2141 : 		}
; 2142 : 		else if(uCurrentScrollbar == SB_VERT)

  036e0	eb 29		 jmp	 SHORT $L23357
$L23356:
  036e2	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uCurrentScrollbar, 1
  036e9	75 20		 jne	 SHORT $L23357

; 2143 : 		{
; 2144 : 			//get the total area of the normal Horz scrollbar area
; 2145 : 			sb = &sw->sbarVert;

  036eb	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  036ee	81 c2 54 03 00
	00		 add	 edx, 852		; 00000354H
  036f4	89 55 cc	 mov	 DWORD PTR _sb$23351[ebp], edx

; 2146 : 			GetVScrollRect(sw, hwnd, &rect);

  036f7	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  036fa	50		 push	 eax
  036fb	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  036fe	51		 push	 ecx
  036ff	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  03702	52		 push	 edx
  03703	e8 00 00 00 00	 call	 _GetVScrollRect
  03708	83 c4 0c	 add	 esp, 12			; 0000000cH
$L23357:

; 2147 : 		}
; 2148 : 
; 2149 : 		//we need to do different things depending on if the
; 2150 : 		//user is activating the scrollbar itself, or one of
; 2151 : 		//the inserted buttons
; 2152 : 		switch(uCurrentScrollPortion)

  0370b	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentScrollPortion
  03710	89 45 c0	 mov	 DWORD PTR tv82[ebp], eax
  03713	81 7d c0 80 00
	00 00		 cmp	 DWORD PTR tv82[ebp], 128 ; 00000080H
  0371a	77 2c		 ja	 SHORT $L23932
  0371c	81 7d c0 80 00
	00 00		 cmp	 DWORD PTR tv82[ebp], 128 ; 00000080H
  03723	74 32		 je	 SHORT $L23363
  03725	83 7d c0 00	 cmp	 DWORD PTR tv82[ebp], 0
  03729	0f 82 f1 01 00
	00		 jb	 $L23360
  0372f	83 7d c0 03	 cmp	 DWORD PTR tv82[ebp], 3
  03733	0f 86 31 01 00
	00		 jbe	 $L23378
  03739	83 7d c0 05	 cmp	 DWORD PTR tv82[ebp], 5
  0373d	0f 84 38 01 00
	00		 je	 $L23379
  03743	e9 d8 01 00 00	 jmp	 $L23360
$L23932:
  03748	83 7d c0 ff	 cmp	 DWORD PTR tv82[ebp], -1
  0374c	0f 84 18 01 00
	00		 je	 $L23378
  03752	e9 c9 01 00 00	 jmp	 $L23360
$L23363:

; 2153 : 		{
; 2154 : #ifdef INCLUDE_BUTTONS
; 2155 : 		//inserted buttons are being clicked
; 2156 : 		case HTSCROLL_INSERTED:
; 2157 : 			
; 2158 : 			//get the rectangle of the ACTIVE button 
; 2159 : 			buttonIdx = GetButtonFromPt(sb, &rect, pt, FALSE);

  03757	6a 00		 push	 0
  03759	8b 4d dc	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  0375c	51		 push	 ecx
  0375d	8b 55 d8	 mov	 edx, DWORD PTR _pt$[ebp]
  03760	52		 push	 edx
  03761	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  03764	50		 push	 eax
  03765	8b 4d cc	 mov	 ecx, DWORD PTR _sb$23351[ebp]
  03768	51		 push	 ecx
  03769	e8 00 00 00 00	 call	 _GetButtonFromPt
  0376e	83 c4 14	 add	 esp, 20			; 00000014H
  03771	89 45 d4	 mov	 DWORD PTR _buttonIdx$[ebp], eax

; 2160 : 			GetButtonRectFromId(sb, &rect, uCurrentButton);

  03774	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  0377a	52		 push	 edx
  0377b	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  0377e	50		 push	 eax
  0377f	8b 4d cc	 mov	 ecx, DWORD PTR _sb$23351[ebp]
  03782	51		 push	 ecx
  03783	e8 00 00 00 00	 call	 _GetButtonRectFromId
  03788	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2161 : 	
; 2162 : 			OffsetRect(&rect, -winrect.left, -winrect.top);

  0378b	8b 55 e4	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  0378e	f7 da		 neg	 edx
  03790	52		 push	 edx
  03791	8b 45 e0	 mov	 eax, DWORD PTR _winrect$[ebp]
  03794	f7 d8		 neg	 eax
  03796	50		 push	 eax
  03797	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  0379a	51		 push	 ecx
  0379b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 2163 : 
; 2164 : 			//Send the notification BEFORE we redraw, so the
; 2165 : 			//bitmap can be changed smoothly by the user if they require
; 2166 : 			if(uCurrentButton == buttonIdx)

  037a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  037a7	3b 55 d4	 cmp	 edx, DWORD PTR _buttonIdx$[ebp]
  037aa	75 7c		 jne	 SHORT $L23364

; 2167 : 			{
; 2168 : 				SCROLLBUT *sbut = &sb->sbButtons[buttonIdx];

  037ac	8b 45 d4	 mov	 eax, DWORD PTR _buttonIdx$[ebp]
  037af	6b c0 30	 imul	 eax, 48			; 00000030H
  037b2	8b 4d cc	 mov	 ecx, DWORD PTR _sb$23351[ebp]
  037b5	8d 54 01 2c	 lea	 edx, DWORD PTR [ecx+eax+44]
  037b9	89 55 c8	 mov	 DWORD PTR _sbut$23365[ebp], edx

; 2169 : 				UINT cmdid = sbut->uCmdId;

  037bc	8b 45 c8	 mov	 eax, DWORD PTR _sbut$23365[ebp]
  037bf	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  037c2	89 4d c4	 mov	 DWORD PTR _cmdid$23366[ebp], ecx

; 2170 : 				
; 2171 : 				if((sbut->uButType & SBBT_MASK) == SBBT_TOGGLEBUTTON)

  037c5	8b 55 c8	 mov	 edx, DWORD PTR _sbut$23365[ebp]
  037c8	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  037cb	83 e0 1f	 and	 eax, 31			; 0000001fH
  037ce	83 f8 02	 cmp	 eax, 2
  037d1	75 0f		 jne	 SHORT $L23367

; 2172 : 					sbut->uState ^= 1;

  037d3	8b 4d c8	 mov	 ecx, DWORD PTR _sbut$23365[ebp]
  037d6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  037d9	83 f2 01	 xor	 edx, 1
  037dc	8b 45 c8	 mov	 eax, DWORD PTR _sbut$23365[ebp]
  037df	89 50 10	 mov	 DWORD PTR [eax+16], edx
$L23367:

; 2173 : 
; 2174 : 				//send a notify??				
; 2175 : 				//only post a message if the command id is valid
; 2176 : 				if(cmdid != -1 && cmdid > 0)

  037e2	83 7d c4 ff	 cmp	 DWORD PTR _cmdid$23366[ebp], -1
  037e6	74 2a		 je	 SHORT $L23368
  037e8	83 7d c4 00	 cmp	 DWORD PTR _cmdid$23366[ebp], 0
  037ec	76 24		 jbe	 SHORT $L23368

; 2177 : 					SendMessage(hwnd, WM_COMMAND, MAKEWPARAM(cmdid, CSBN_CLICKED), 0);

  037ee	6a 00		 push	 0
  037f0	8b 4d c4	 mov	 ecx, DWORD PTR _cmdid$23366[ebp]
  037f3	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  037f9	0f b7 d1	 movzx	 edx, cx
  037fc	81 ca 00 00 01
	00		 or	 edx, 65536		; 00010000H
  03802	52		 push	 edx
  03803	68 11 01 00 00	 push	 273			; 00000111H
  03808	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0380b	50		 push	 eax
  0380c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$L23368:

; 2178 : 			
; 2179 : 				//user might have deleted this button, so redraw whole area
; 2180 : 				NCPaint(sw, hwnd, 1, 0);

  03812	6a 00		 push	 0
  03814	6a 01		 push	 1
  03816	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03819	51		 push	 ecx
  0381a	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0381d	52		 push	 edx
  0381e	e8 00 00 00 00	 call	 _NCPaint
  03823	83 c4 10	 add	 esp, 16			; 00000010H

; 2181 : 			}
; 2182 : 			else

  03826	eb 3d		 jmp	 SHORT $L23377
$L23364:

; 2183 : 			{
; 2184 : 				//otherwise, just redraw the button in its new state
; 2185 : 				hdc = GetWindowDC(hwnd);

  03828	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0382b	50		 push	 eax
  0382c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  03832	89 45 d0	 mov	 DWORD PTR _hdc$[ebp], eax

; 2186 : 				DrawScrollButton(&sb->sbButtons[uCurrentButton], hdc, &rect, SBBS_NORMAL);

  03835	6a 00		 push	 0
  03837	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  0383a	51		 push	 ecx
  0383b	8b 55 d0	 mov	 edx, DWORD PTR _hdc$[ebp]
  0383e	52		 push	 edx
  0383f	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentButton
  03844	6b c0 30	 imul	 eax, 48			; 00000030H
  03847	8b 4d cc	 mov	 ecx, DWORD PTR _sb$23351[ebp]
  0384a	8d 54 01 2c	 lea	 edx, DWORD PTR [ecx+eax+44]
  0384e	52		 push	 edx
  0384f	e8 00 00 00 00	 call	 _DrawScrollButton
  03854	83 c4 10	 add	 esp, 16			; 00000010H

; 2187 : 				ReleaseDC(hwnd, hdc);

  03857	8b 45 d0	 mov	 eax, DWORD PTR _hdc$[ebp]
  0385a	50		 push	 eax
  0385b	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0385e	51		 push	 ecx
  0385f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
$L23377:

; 2188 : 			}
; 2189 : 	
; 2190 : 			break;

  03865	e9 b6 00 00 00	 jmp	 $L23360
$L23378:

; 2191 : #endif	// INCLUDE_BUTTONS
; 2192 : 
; 2193 : 		//The scrollbar is active
; 2194 : 		case HTSCROLL_LEFT:  case HTSCROLL_RIGHT: 
; 2195 : 		case HTSCROLL_PAGELEFT:  case HTSCROLL_PAGERIGHT: 
; 2196 : 		case HTSCROLL_NONE:
; 2197 : 			
; 2198 : 			KillTimer(hwnd, uScrollTimerId);

  0386a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uScrollTimerId
  03870	52		 push	 edx
  03871	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03874	50		 push	 eax
  03875	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8
$L23379:

; 2199 : 
; 2200 : 		case HTSCROLL_THUMB: 
; 2201 : 	
; 2202 : 			//In case we were thumb tracking, make sure we stop NOW
; 2203 : 			if(sw->fThumbTracking == TRUE)

  0387b	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0387e	83 b9 a0 06 00
	00 01		 cmp	 DWORD PTR [ecx+1696], 1
  03885	75 28		 jne	 SHORT $L23380

; 2204 : 			{
; 2205 : 				SendScrollMessage(hwnd, uScrollTimerMsg, SB_THUMBPOSITION, nLastPos);

  03887	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nLastPos
  0388d	52		 push	 edx
  0388e	6a 04		 push	 4
  03890	a1 00 00 00 00	 mov	 eax, DWORD PTR _uScrollTimerMsg
  03895	50		 push	 eax
  03896	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03899	51		 push	 ecx
  0389a	e8 00 00 00 00	 call	 _SendScrollMessage
  0389f	83 c4 10	 add	 esp, 16			; 00000010H

; 2206 : 				sw->fThumbTracking = FALSE;

  038a2	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  038a5	c7 82 a0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1696], 0
$L23380:

; 2207 : 			}
; 2208 : 
; 2209 : 			//send the SB_ENDSCROLL message now that scrolling has finished
; 2210 : 			SendScrollMessage(hwnd, uScrollTimerMsg, SB_ENDSCROLL, 0);

  038af	6a 00		 push	 0
  038b1	6a 08		 push	 8
  038b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _uScrollTimerMsg
  038b8	50		 push	 eax
  038b9	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  038bc	51		 push	 ecx
  038bd	e8 00 00 00 00	 call	 _SendScrollMessage
  038c2	83 c4 10	 add	 esp, 16			; 00000010H

; 2211 : 
; 2212 : 			//adjust the total scroll area to become where the scrollbar
; 2213 : 			//really is (take into account the inserted buttons)
; 2214 : 			GetRealScrollRect(sb, &rect);

  038c5	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  038c8	52		 push	 edx
  038c9	8b 45 cc	 mov	 eax, DWORD PTR _sb$23351[ebp]
  038cc	50		 push	 eax
  038cd	e8 00 00 00 00	 call	 _GetRealScrollRect
  038d2	83 c4 08	 add	 esp, 8

; 2215 : 			OffsetRect(&rect, -winrect.left, -winrect.top);

  038d5	8b 4d e4	 mov	 ecx, DWORD PTR _winrect$[ebp+4]
  038d8	f7 d9		 neg	 ecx
  038da	51		 push	 ecx
  038db	8b 55 e0	 mov	 edx, DWORD PTR _winrect$[ebp]
  038de	f7 da		 neg	 edx
  038e0	52		 push	 edx
  038e1	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  038e4	50		 push	 eax
  038e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 2216 : 			hdc = GetWindowDC(hwnd);

  038eb	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  038ee	51		 push	 ecx
  038ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  038f5	89 45 d0	 mov	 DWORD PTR _hdc$[ebp], eax

; 2217 : 			
; 2218 : 			//draw whichever scrollbar sb is
; 2219 : 			NCDrawScrollbar(sb, hwnd, hdc, &rect, HTSCROLL_NORMAL);

  038f8	6a ff		 push	 -1
  038fa	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  038fd	52		 push	 edx
  038fe	8b 45 d0	 mov	 eax, DWORD PTR _hdc$[ebp]
  03901	50		 push	 eax
  03902	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03905	51		 push	 ecx
  03906	8b 55 cc	 mov	 edx, DWORD PTR _sb$23351[ebp]
  03909	52		 push	 edx
  0390a	e8 00 00 00 00	 call	 _NCDrawScrollbar
  0390f	83 c4 14	 add	 esp, 20			; 00000014H

; 2220 : 
; 2221 : 			ReleaseDC(hwnd, hdc);

  03912	8b 45 d0	 mov	 eax, DWORD PTR _hdc$[ebp]
  03915	50		 push	 eax
  03916	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03919	51		 push	 ecx
  0391a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
$L23360:

; 2222 : 			break;
; 2223 : 		}
; 2224 : 
; 2225 : 		//reset our state to default
; 2226 : 		uCurrentScrollPortion = HTSCROLL_NONE;

  03920	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uCurrentScrollPortion, -1

; 2227 : 		uScrollTimerPortion	  = HTSCROLL_NONE;

  0392a	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uScrollTimerPortion, -1

; 2228 : 		uScrollTimerId		  = 0;

  03934	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uScrollTimerId, 0

; 2229 : 
; 2230 : 		uScrollTimerMsg       = 0;

  0393e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uScrollTimerMsg, 0

; 2231 : 		uCurrentScrollbar     = COOLSB_NONE;

  03948	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uCurrentScrollbar, -1

; 2232 : 
; 2233 : 		return 0;

  03952	33 c0		 xor	 eax, eax
  03954	eb 1e		 jmp	 SHORT $L23344
$L23381:

; 2234 : 	}
; 2235 : 	else
; 2236 : 	{
; 2237 : 		/*
; 2238 : 		// Can't remember why I did this!
; 2239 : 		if(GetCapture() == hwnd)
; 2240 : 		{
; 2241 : 			ReleaseCapture();
; 2242 : 		}*/
; 2243 : 	}
; 2244 : 
; 2245 : 	return CallWindowProc(sw->oldproc, hwnd, WM_LBUTTONUP, wParam, lParam);

  03956	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  03959	52		 push	 edx
  0395a	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0395d	50		 push	 eax
  0395e	68 02 02 00 00	 push	 514			; 00000202H
  03963	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03966	51		 push	 ecx
  03967	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0396a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0396d	50		 push	 eax
  0396e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
$L23344:

; 2246 : }

  03974	8b e5		 mov	 esp, ebp
  03976	5d		 pop	 ebp
  03977	c3		 ret	 0
_LButtonUp ENDP
; Function compile flags: /Odt
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_index$ = 16						; size = 4
_GetButtonRectFromId PROC NEAR

; 1912 : {

  03980	55		 push	 ebp
  03981	8b ec		 mov	 ebp, esp

; 1913 : 	if(sb->nBarType == SB_HORZ)

  03983	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03986	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  0398d	75 16		 jne	 SHORT $L23280

; 1914 : 	{
; 1915 : 		return GetHorzButtonRectFromId(sb, rect, index);

  0398f	8b 4d 10	 mov	 ecx, DWORD PTR _index$[ebp]
  03992	51		 push	 ecx
  03993	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  03996	52		 push	 edx
  03997	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0399a	50		 push	 eax
  0399b	e8 00 00 00 00	 call	 _GetHorzButtonRectFromId
  039a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  039a3	eb 14		 jmp	 SHORT $L23279
$L23280:

; 1916 : 	}
; 1917 : 	else
; 1918 : 	{
; 1919 : 		return GetVertButtonRectFromId(sb, rect, index);

  039a5	8b 4d 10	 mov	 ecx, DWORD PTR _index$[ebp]
  039a8	51		 push	 ecx
  039a9	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  039ac	52		 push	 edx
  039ad	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  039b0	50		 push	 eax
  039b1	e8 00 00 00 00	 call	 _GetVertButtonRectFromId
  039b6	83 c4 0c	 add	 esp, 12			; 0000000cH
$L23279:

; 1920 : 	}
; 1921 : }

  039b9	5d		 pop	 ebp
  039ba	c3		 ret	 0
_GetButtonRectFromId ENDP
; Function compile flags: /Odt
_rightpos$ = -16					; size = 4
_leftpos$ = -12						; size = 4
_i$ = -8						; size = 4
_sbut$ = -4						; size = 4
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_index$ = 16						; size = 4
_GetHorzButtonRectFromId PROC NEAR

; 1866 : {

  039c0	55		 push	 ebp
  039c1	8b ec		 mov	 ebp, esp
  039c3	83 ec 10	 sub	 esp, 16			; 00000010H

; 1867 : 	UINT i;
; 1868 : 	SCROLLBUT *sbut = sb->sbButtons;

  039c6	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  039c9	83 c0 2c	 add	 eax, 44			; 0000002cH
  039cc	89 45 fc	 mov	 DWORD PTR _sbut$[ebp], eax

; 1869 : 	int leftpos = rect->left, rightpos = rect->right;

  039cf	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  039d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  039d4	89 55 f4	 mov	 DWORD PTR _leftpos$[ebp], edx
  039d7	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  039da	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  039dd	89 4d f0	 mov	 DWORD PTR _rightpos$[ebp], ecx

; 1870 : 
; 1871 : 	if(sb->fButVisibleAfter)

  039e0	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  039e3	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  039ea	74 0f		 je	 SHORT $L23254

; 1872 : 		rightpos -= sb->nButSizeAfter;

  039ec	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  039ef	8b 4d f0	 mov	 ecx, DWORD PTR _rightpos$[ebp]
  039f2	2b 88 34 03 00
	00		 sub	 ecx, DWORD PTR [eax+820]
  039f8	89 4d f0	 mov	 DWORD PTR _rightpos$[ebp], ecx
$L23254:

; 1873 : 
; 1874 : 	//find the particular button in question
; 1875 : 	for(i = 0; i < index; i++)

  039fb	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  03a02	eb 09		 jmp	 SHORT $L23255
$L23256:
  03a04	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  03a07	83 c2 01	 add	 edx, 1
  03a0a	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L23255:
  03a0d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  03a10	3b 45 10	 cmp	 eax, DWORD PTR _index$[ebp]
  03a13	73 77		 jae	 SHORT $L23257

; 1876 : 	{
; 1877 : 		if(sb->fButVisibleBefore && sbut[i].uPlacement == SBBP_LEFT)

  03a15	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  03a18	83 b9 38 03 00
	00 00		 cmp	 DWORD PTR [ecx+824], 0
  03a1f	74 2e		 je	 SHORT $L23258
  03a21	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  03a24	6b d2 30	 imul	 edx, 48			; 00000030H
  03a27	8b 45 fc	 mov	 eax, DWORD PTR _sbut$[ebp]
  03a2a	83 7c 10 04 01	 cmp	 DWORD PTR [eax+edx+4], 1
  03a2f	75 1e		 jne	 SHORT $L23258

; 1878 : 		{
; 1879 : 			leftpos += GetSingleButSize(sb, &sbut[i]);

  03a31	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  03a34	6b c9 30	 imul	 ecx, 48			; 00000030H
  03a37	03 4d fc	 add	 ecx, DWORD PTR _sbut$[ebp]
  03a3a	51		 push	 ecx
  03a3b	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  03a3e	52		 push	 edx
  03a3f	e8 00 00 00 00	 call	 _GetSingleButSize
  03a44	83 c4 08	 add	 esp, 8
  03a47	03 45 f4	 add	 eax, DWORD PTR _leftpos$[ebp]
  03a4a	89 45 f4	 mov	 DWORD PTR _leftpos$[ebp], eax

; 1880 : 		}
; 1881 : 		else if(sb->fButVisibleAfter && sbut[i].uPlacement == SBBP_RIGHT)

  03a4d	eb 38		 jmp	 SHORT $L23259
$L23258:
  03a4f	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03a52	83 b8 3c 03 00
	00 00		 cmp	 DWORD PTR [eax+828], 0
  03a59	74 2c		 je	 SHORT $L23259
  03a5b	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  03a5e	6b c9 30	 imul	 ecx, 48			; 00000030H
  03a61	8b 55 fc	 mov	 edx, DWORD PTR _sbut$[ebp]
  03a64	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  03a69	75 1c		 jne	 SHORT $L23259

; 1882 : 		{
; 1883 : 			rightpos += GetSingleButSize(sb, &sbut[i]);

  03a6b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  03a6e	6b c0 30	 imul	 eax, 48			; 00000030H
  03a71	03 45 fc	 add	 eax, DWORD PTR _sbut$[ebp]
  03a74	50		 push	 eax
  03a75	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  03a78	51		 push	 ecx
  03a79	e8 00 00 00 00	 call	 _GetSingleButSize
  03a7e	83 c4 08	 add	 esp, 8
  03a81	03 45 f0	 add	 eax, DWORD PTR _rightpos$[ebp]
  03a84	89 45 f0	 mov	 DWORD PTR _rightpos$[ebp], eax
$L23259:

; 1884 : 		}
; 1885 : 	}

  03a87	e9 78 ff ff ff	 jmp	 $L23256
$L23257:

; 1886 : 
; 1887 : 	//now return the rectangle
; 1888 : 	if(sbut[i].uPlacement == SBBP_LEFT)

  03a8c	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  03a8f	6b d2 30	 imul	 edx, 48			; 00000030H
  03a92	8b 45 fc	 mov	 eax, DWORD PTR _sbut$[ebp]
  03a95	83 7c 10 04 01	 cmp	 DWORD PTR [eax+edx+4], 1
  03a9a	75 29		 jne	 SHORT $L23261

; 1889 : 	{
; 1890 : 		rect->left  = leftpos;

  03a9c	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  03a9f	8b 55 f4	 mov	 edx, DWORD PTR _leftpos$[ebp]
  03aa2	89 11		 mov	 DWORD PTR [ecx], edx

; 1891 : 		rect->right = leftpos + GetSingleButSize(sb, &sbut[i]);

  03aa4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  03aa7	6b c0 30	 imul	 eax, 48			; 00000030H
  03aaa	03 45 fc	 add	 eax, DWORD PTR _sbut$[ebp]
  03aad	50		 push	 eax
  03aae	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  03ab1	51		 push	 ecx
  03ab2	e8 00 00 00 00	 call	 _GetSingleButSize
  03ab7	83 c4 08	 add	 esp, 8
  03aba	03 45 f4	 add	 eax, DWORD PTR _leftpos$[ebp]
  03abd	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  03ac0	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1892 : 	}
; 1893 : 	else

  03ac3	eb 27		 jmp	 SHORT $L23262
$L23261:

; 1894 : 	{
; 1895 : 		rect->left  = rightpos;

  03ac5	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  03ac8	8b 4d f0	 mov	 ecx, DWORD PTR _rightpos$[ebp]
  03acb	89 08		 mov	 DWORD PTR [eax], ecx

; 1896 : 		rect->right = rightpos + GetSingleButSize(sb, &sbut[i]);

  03acd	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  03ad0	6b d2 30	 imul	 edx, 48			; 00000030H
  03ad3	03 55 fc	 add	 edx, DWORD PTR _sbut$[ebp]
  03ad6	52		 push	 edx
  03ad7	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03ada	50		 push	 eax
  03adb	e8 00 00 00 00	 call	 _GetSingleButSize
  03ae0	83 c4 08	 add	 esp, 8
  03ae3	03 45 f0	 add	 eax, DWORD PTR _rightpos$[ebp]
  03ae6	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  03ae9	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L23262:

; 1897 : 	}
; 1898 : 
; 1899 : 	return 0;

  03aec	33 c0		 xor	 eax, eax

; 1900 : }

  03aee	8b e5		 mov	 esp, ebp
  03af0	5d		 pop	 ebp
  03af1	c3		 ret	 0
_GetHorzButtonRectFromId ENDP
; Function compile flags: /Odt
_ret$ = -4						; size = 4
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_index$ = 16						; size = 4
_GetVertButtonRectFromId PROC NEAR

; 1903 : {

  03b00	55		 push	 ebp
  03b01	8b ec		 mov	 ebp, esp
  03b03	51		 push	 ecx

; 1904 : 	UINT ret;
; 1905 : 	RotateRect(rect);

  03b04	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  03b07	50		 push	 eax
  03b08	e8 00 00 00 00	 call	 _RotateRect@4

; 1906 : 	ret = GetHorzButtonRectFromId(sb, rect, index);

  03b0d	8b 4d 10	 mov	 ecx, DWORD PTR _index$[ebp]
  03b10	51		 push	 ecx
  03b11	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  03b14	52		 push	 edx
  03b15	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03b18	50		 push	 eax
  03b19	e8 00 00 00 00	 call	 _GetHorzButtonRectFromId
  03b1e	83 c4 0c	 add	 esp, 12			; 0000000cH
  03b21	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 1907 : 	RotateRect(rect);

  03b24	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  03b27	51		 push	 ecx
  03b28	e8 00 00 00 00	 call	 _RotateRect@4

; 1908 : 	return ret;

  03b2d	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 1909 : }

  03b30	8b e5		 mov	 esp, ebp
  03b32	5d		 pop	 ebp
  03b33	c3		 ret	 0
_GetVertButtonRectFromId ENDP
; Function compile flags: /Odt
tv152 = -108						; size = 4
_rect2$23483 = -104					; size = 16
_scrollsize$23484 = -88					; size = 4
_butsize1$23481 = -84					; size = 4
_butsize2$23482 = -80					; size = 4
_oldsize$23480 = -76					; size = 4
_sb$23464 = -72						; size = 4
_nlParam$23463 = -68					; size = 4
_sbut$23465 = -64					; size = 4
_x$23452 = -60						; size = 4
_y$23453 = -56						; size = 4
_hdc$ = -52						; size = 4
_buttonIdx$ = -48					; size = 4
_pt$ = -44						; size = 8
_thisportion$ = -36					; size = 4
_winrect$ = -32						; size = 16
_rect$ = -16						; size = 16
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_MouseMove PROC NEAR

; 2398 : {

  03b40	55		 push	 ebp
  03b41	8b ec		 mov	 ebp, esp
  03b43	83 ec 6c	 sub	 esp, 108		; 0000006cH

; 2399 : 	RECT rect;
; 2400 : 	UINT thisportion;
; 2401 : 	HDC hdc;
; 2402 : 	static UINT lastportion = 0;
; 2403 : 	static UINT lastbutton = 0;
; 2404 : 	POINT pt;
; 2405 : 	RECT winrect;
; 2406 : 	UINT buttonIdx = 0;

  03b46	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _buttonIdx$[ebp], 0

; 2407 : 
; 2408 : 	if(sw->fThumbTracking == TRUE)

  03b4d	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  03b50	83 b8 a0 06 00
	00 01		 cmp	 DWORD PTR [eax+1696], 1
  03b57	75 78		 jne	 SHORT $L23451

; 2409 : 	{
; 2410 : 		int x, y;
; 2411 : 		lParam = GetMessagePos();

  03b59	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  03b5f	89 45 14	 mov	 DWORD PTR _lParam$[ebp], eax

; 2412 : 		x = LOWORD(lParam);

  03b62	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  03b65	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  03b6b	0f b7 d1	 movzx	 edx, cx
  03b6e	89 55 c4	 mov	 DWORD PTR _x$23452[ebp], edx

; 2413 : 		y = HIWORD(lParam);

  03b71	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  03b74	c1 e8 10	 shr	 eax, 16			; 00000010H
  03b77	0f b7 c8	 movzx	 ecx, ax
  03b7a	89 4d c8	 mov	 DWORD PTR _y$23453[ebp], ecx

; 2414 : 
; 2415 : 		if(uCurrentScrollbar == SB_HORZ)

  03b7d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  03b84	75 20		 jne	 SHORT $L23458

; 2416 : 			return ThumbTrackHorz(&sw->sbarHorz, hwnd, x,y);

  03b86	8b 55 c8	 mov	 edx, DWORD PTR _y$23453[ebp]
  03b89	52		 push	 edx
  03b8a	8b 45 c4	 mov	 eax, DWORD PTR _x$23452[ebp]
  03b8d	50		 push	 eax
  03b8e	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03b91	51		 push	 ecx
  03b92	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  03b95	83 c2 08	 add	 edx, 8
  03b98	52		 push	 edx
  03b99	e8 00 00 00 00	 call	 _ThumbTrackHorz
  03b9e	83 c4 10	 add	 esp, 16			; 00000010H
  03ba1	e9 9e 04 00 00	 jmp	 $L23440
$L23458:

; 2417 : 
; 2418 : 
; 2419 : 		else if(uCurrentScrollbar == SB_VERT)

  03ba6	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uCurrentScrollbar, 1
  03bad	75 22		 jne	 SHORT $L23451

; 2420 : 			return ThumbTrackVert(&sw->sbarVert, hwnd, x,y);

  03baf	8b 45 c8	 mov	 eax, DWORD PTR _y$23453[ebp]
  03bb2	50		 push	 eax
  03bb3	8b 4d c4	 mov	 ecx, DWORD PTR _x$23452[ebp]
  03bb6	51		 push	 ecx
  03bb7	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03bba	52		 push	 edx
  03bbb	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  03bbe	05 54 03 00 00	 add	 eax, 852		; 00000354H
  03bc3	50		 push	 eax
  03bc4	e8 00 00 00 00	 call	 _ThumbTrackVert
  03bc9	83 c4 10	 add	 esp, 16			; 00000010H
  03bcc	e9 73 04 00 00	 jmp	 $L23440
$L23451:

; 2421 : 	}
; 2422 : 
; 2423 : 	if(uCurrentScrollPortion == HTSCROLL_NONE)

  03bd1	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _uCurrentScrollPortion, -1
  03bd8	75 23		 jne	 SHORT $L23461

; 2424 : 	{
; 2425 : 		return CallWindowProc(sw->oldproc, hwnd, WM_MOUSEMOVE, wParam, lParam);

  03bda	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  03bdd	51		 push	 ecx
  03bde	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  03be1	52		 push	 edx
  03be2	68 00 02 00 00	 push	 512			; 00000200H
  03be7	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03bea	50		 push	 eax
  03beb	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  03bee	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  03bf1	52		 push	 edx
  03bf2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  03bf8	e9 47 04 00 00	 jmp	 $L23440
$L23461:

; 2426 : 	}
; 2427 : 	else
; 2428 : 	{
; 2429 : 		LPARAM nlParam;
; 2430 : 		SCROLLBAR *sb = &sw->sbarHorz;

  03bfd	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  03c00	83 c0 08	 add	 eax, 8
  03c03	89 45 b8	 mov	 DWORD PTR _sb$23464[ebp], eax

; 2431 : 		SCROLLBUT *sbut = 0;

  03c06	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _sbut$23465[ebp], 0

; 2432 : 
; 2433 : 		nlParam = GetMessagePos();

  03c0d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  03c13	89 45 bc	 mov	 DWORD PTR _nlParam$23463[ebp], eax

; 2434 : 
; 2435 : 		GetWindowRect(hwnd, &winrect);

  03c16	8d 4d e0	 lea	 ecx, DWORD PTR _winrect$[ebp]
  03c19	51		 push	 ecx
  03c1a	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03c1d	52		 push	 edx
  03c1e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 2436 : 
; 2437 : 		pt.x = LOWORD(nlParam);

  03c24	8b 45 bc	 mov	 eax, DWORD PTR _nlParam$23463[ebp]
  03c27	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  03c2c	0f b7 c8	 movzx	 ecx, ax
  03c2f	89 4d d4	 mov	 DWORD PTR _pt$[ebp], ecx

; 2438 : 		pt.y = HIWORD(nlParam);

  03c32	8b 55 bc	 mov	 edx, DWORD PTR _nlParam$23463[ebp]
  03c35	c1 ea 10	 shr	 edx, 16			; 00000010H
  03c38	0f b7 c2	 movzx	 eax, dx
  03c3b	89 45 d8	 mov	 DWORD PTR _pt$[ebp+4], eax

; 2439 : 
; 2440 : 		//emulate the mouse input on a scrollbar here...
; 2441 : 		if(uCurrentScrollbar == SB_HORZ)

  03c3e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  03c45	75 0b		 jne	 SHORT $L23470

; 2442 : 		{
; 2443 : 			sb = &sw->sbarHorz;

  03c47	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  03c4a	83 c1 08	 add	 ecx, 8
  03c4d	89 4d b8	 mov	 DWORD PTR _sb$23464[ebp], ecx

; 2444 : 		}
; 2445 : 		else if(uCurrentScrollbar == SB_VERT)

  03c50	eb 15		 jmp	 SHORT $L23471
$L23470:
  03c52	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uCurrentScrollbar, 1
  03c59	75 0c		 jne	 SHORT $L23471

; 2446 : 		{
; 2447 : 			sb = &sw->sbarVert;

  03c5b	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  03c5e	81 c2 54 03 00
	00		 add	 edx, 852		; 00000354H
  03c64	89 55 b8	 mov	 DWORD PTR _sb$23464[ebp], edx
$L23471:

; 2448 : 		}
; 2449 : 
; 2450 : 		//get the total area of the normal scrollbar area
; 2451 : 		GetScrollRect(sw, sb->nBarType, hwnd, &rect);

  03c67	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  03c6a	50		 push	 eax
  03c6b	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03c6e	51		 push	 ecx
  03c6f	8b 55 b8	 mov	 edx, DWORD PTR _sb$23464[ebp]
  03c72	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  03c78	50		 push	 eax
  03c79	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  03c7c	51		 push	 ecx
  03c7d	e8 00 00 00 00	 call	 _GetScrollRect
  03c82	83 c4 10	 add	 esp, 16			; 00000010H

; 2452 : 		
; 2453 : 		//see if we clicked in the inserted buttons / normal scrollbar
; 2454 : 		//thisportion = GetPortion(sb, hwnd, &rect, LOWORD(lParam), HIWORD(lParam));
; 2455 : 		thisportion = GetPortion(sb, hwnd, &rect, pt.x, pt.y);

  03c85	8b 55 d8	 mov	 edx, DWORD PTR _pt$[ebp+4]
  03c88	52		 push	 edx
  03c89	8b 45 d4	 mov	 eax, DWORD PTR _pt$[ebp]
  03c8c	50		 push	 eax
  03c8d	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  03c90	51		 push	 ecx
  03c91	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03c94	52		 push	 edx
  03c95	8b 45 b8	 mov	 eax, DWORD PTR _sb$23464[ebp]
  03c98	50		 push	 eax
  03c99	e8 00 00 00 00	 call	 _GetPortion
  03c9e	83 c4 14	 add	 esp, 20			; 00000014H
  03ca1	89 45 dc	 mov	 DWORD PTR _thisportion$[ebp], eax

; 2456 : 		
; 2457 : 		//we need to do different things depending on if the
; 2458 : 		//user is activating the scrollbar itself, or one of
; 2459 : 		//the inserted buttons
; 2460 : 		switch(uCurrentScrollPortion)

  03ca4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uCurrentScrollPortion
  03caa	89 4d 94	 mov	 DWORD PTR tv152[ebp], ecx
  03cad	81 7d 94 80 00
	00 00		 cmp	 DWORD PTR tv152[ebp], 128 ; 00000080H
  03cb4	77 2c		 ja	 SHORT $L23937
  03cb6	81 7d 94 80 00
	00 00		 cmp	 DWORD PTR tv152[ebp], 128 ; 00000080H
  03cbd	74 32		 je	 SHORT $L23477
  03cbf	83 7d 94 00	 cmp	 DWORD PTR tv152[ebp], 0
  03cc3	0f 82 68 03 00
	00		 jb	 $L23474
  03cc9	83 7d 94 03	 cmp	 DWORD PTR tv152[ebp], 3
  03ccd	0f 86 b0 02 00
	00		 jbe	 $L23501
  03cd3	83 7d 94 05	 cmp	 DWORD PTR tv152[ebp], 5
  03cd7	0f 84 a6 02 00
	00		 je	 $L23501
  03cdd	e9 4f 03 00 00	 jmp	 $L23474
$L23937:
  03ce2	83 7d 94 ff	 cmp	 DWORD PTR tv152[ebp], -1
  03ce6	0f 84 97 02 00
	00		 je	 $L23501
  03cec	e9 40 03 00 00	 jmp	 $L23474
$L23477:

; 2461 : 		{
; 2462 : #ifdef INCLUDE_BUTTONS
; 2463 : 		//inserted buttons are being clicked
; 2464 : 		case HTSCROLL_INSERTED:
; 2465 : 			
; 2466 : 			//find the index of the button that has been clicked
; 2467 : 			//Don't adjust the rectangle though
; 2468 : 			buttonIdx = GetButtonFromPt(sb, &rect, pt, FALSE);

  03cf1	6a 00		 push	 0
  03cf3	8b 55 d8	 mov	 edx, DWORD PTR _pt$[ebp+4]
  03cf6	52		 push	 edx
  03cf7	8b 45 d4	 mov	 eax, DWORD PTR _pt$[ebp]
  03cfa	50		 push	 eax
  03cfb	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  03cfe	51		 push	 ecx
  03cff	8b 55 b8	 mov	 edx, DWORD PTR _sb$23464[ebp]
  03d02	52		 push	 edx
  03d03	e8 00 00 00 00	 call	 _GetButtonFromPt
  03d08	83 c4 14	 add	 esp, 20			; 00000014H
  03d0b	89 45 d0	 mov	 DWORD PTR _buttonIdx$[ebp], eax

; 2469 : 						
; 2470 : 			//Get the rectangle of the active button
; 2471 : 			GetButtonRectFromId(sb, &rect, uCurrentButton);

  03d0e	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentButton
  03d13	50		 push	 eax
  03d14	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  03d17	51		 push	 ecx
  03d18	8b 55 b8	 mov	 edx, DWORD PTR _sb$23464[ebp]
  03d1b	52		 push	 edx
  03d1c	e8 00 00 00 00	 call	 _GetButtonRectFromId
  03d21	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2472 : 
; 2473 : 			//if the button to the LEFT of the current 
; 2474 : 			//button is resizable, then resize it
; 2475 : #ifdef RESIZABLE_BUTTONS
; 2476 : 			if(uCurrentButton > 0)

  03d24	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentButton, 0
  03d2b	0f 86 7d 01 00
	00		 jbe	 $L23478

; 2477 : 			{
; 2478 : 				sbut = &sb->sbButtons[uCurrentButton - 1];

  03d31	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentButton
  03d36	83 e8 01	 sub	 eax, 1
  03d39	6b c0 30	 imul	 eax, 48			; 00000030H
  03d3c	8b 4d b8	 mov	 ecx, DWORD PTR _sb$23464[ebp]
  03d3f	8d 54 01 2c	 lea	 edx, DWORD PTR [ecx+eax+44]
  03d43	89 55 c0	 mov	 DWORD PTR _sbut$23465[ebp], edx

; 2479 : 			
; 2480 : 				//only resize if BOTH buttons are on same side of scrollbar
; 2481 : 				if(sbut->uPlacement == (sbut+1)->uPlacement && (sbut->uButType & SBBM_RESIZABLE))

  03d46	8b 45 c0	 mov	 eax, DWORD PTR _sbut$23465[ebp]
  03d49	8b 4d c0	 mov	 ecx, DWORD PTR _sbut$23465[ebp]
  03d4c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  03d4f	3b 51 34	 cmp	 edx, DWORD PTR [ecx+52]
  03d52	0f 85 56 01 00
	00		 jne	 $L23478
  03d58	8b 45 c0	 mov	 eax, DWORD PTR _sbut$23465[ebp]
  03d5b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  03d5e	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  03d64	0f 84 44 01 00
	00		 je	 $L23478

; 2482 : 				{
; 2483 : 					int oldsize = sbut->nSize;

  03d6a	8b 55 c0	 mov	 edx, DWORD PTR _sbut$23465[ebp]
  03d6d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  03d70	89 45 b4	 mov	 DWORD PTR _oldsize$23480[ebp], eax

; 2484 : 					int butsize1, butsize2;
; 2485 : 					RECT rect2;
; 2486 : 					int scrollsize;
; 2487 : 
; 2488 : 					if(uCurrentScrollbar == SB_HORZ)

  03d73	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  03d7a	75 26		 jne	 SHORT $L23485

; 2489 : 					{
; 2490 : 						rect.left -= GetSingleButSize(sb, sbut);

  03d7c	8b 4d c0	 mov	 ecx, DWORD PTR _sbut$23465[ebp]
  03d7f	51		 push	 ecx
  03d80	8b 55 b8	 mov	 edx, DWORD PTR _sb$23464[ebp]
  03d83	52		 push	 edx
  03d84	e8 00 00 00 00	 call	 _GetSingleButSize
  03d89	83 c4 08	 add	 esp, 8
  03d8c	8b 4d f0	 mov	 ecx, DWORD PTR _rect$[ebp]
  03d8f	2b c8		 sub	 ecx, eax
  03d91	89 4d f0	 mov	 DWORD PTR _rect$[ebp], ecx

; 2491 : 						sbut->nSize = pt.x - rect.left;

  03d94	8b 55 d4	 mov	 edx, DWORD PTR _pt$[ebp]
  03d97	2b 55 f0	 sub	 edx, DWORD PTR _rect$[ebp]
  03d9a	8b 45 c0	 mov	 eax, DWORD PTR _sbut$23465[ebp]
  03d9d	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2492 : 					}
; 2493 : 					else

  03da0	eb 24		 jmp	 SHORT $L23486
$L23485:

; 2494 : 					{
; 2495 : 						rect.top -= GetSingleButSize(sb, sbut);

  03da2	8b 4d c0	 mov	 ecx, DWORD PTR _sbut$23465[ebp]
  03da5	51		 push	 ecx
  03da6	8b 55 b8	 mov	 edx, DWORD PTR _sb$23464[ebp]
  03da9	52		 push	 edx
  03daa	e8 00 00 00 00	 call	 _GetSingleButSize
  03daf	83 c4 08	 add	 esp, 8
  03db2	8b 4d f4	 mov	 ecx, DWORD PTR _rect$[ebp+4]
  03db5	2b c8		 sub	 ecx, eax
  03db7	89 4d f4	 mov	 DWORD PTR _rect$[ebp+4], ecx

; 2496 : 						sbut->nSize = pt.y - rect.top;

  03dba	8b 55 d8	 mov	 edx, DWORD PTR _pt$[ebp+4]
  03dbd	2b 55 f4	 sub	 edx, DWORD PTR _rect$[ebp+4]
  03dc0	8b 45 c0	 mov	 eax, DWORD PTR _sbut$23465[ebp]
  03dc3	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L23486:

; 2497 : 					}
; 2498 : 
; 2499 : 					//if(sbut->nSize < 0)	sbut->nSize = 0;
; 2500 : 					if(sbut->nSize < (int)sbut->nMinSize)

  03dc6	8b 4d c0	 mov	 ecx, DWORD PTR _sbut$23465[ebp]
  03dc9	8b 55 c0	 mov	 edx, DWORD PTR _sbut$23465[ebp]
  03dcc	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  03dcf	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  03dd2	7d 0c		 jge	 SHORT $L23488

; 2501 : 						sbut->nSize = sbut->nMinSize;

  03dd4	8b 4d c0	 mov	 ecx, DWORD PTR _sbut$23465[ebp]
  03dd7	8b 55 c0	 mov	 edx, DWORD PTR _sbut$23465[ebp]
  03dda	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  03ddd	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L23488:

; 2502 : 
; 2503 : 					if((UINT)sbut->nSize > (UINT)sbut->nMaxSize)

  03de0	8b 4d c0	 mov	 ecx, DWORD PTR _sbut$23465[ebp]
  03de3	8b 55 c0	 mov	 edx, DWORD PTR _sbut$23465[ebp]
  03de6	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  03de9	3b 42 2c	 cmp	 eax, DWORD PTR [edx+44]
  03dec	76 0c		 jbe	 SHORT $L23491

; 2504 : 						sbut->nSize = sbut->nMaxSize;

  03dee	8b 4d c0	 mov	 ecx, DWORD PTR _sbut$23465[ebp]
  03df1	8b 55 c0	 mov	 edx, DWORD PTR _sbut$23465[ebp]
  03df4	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  03df7	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L23491:

; 2505 : 					
; 2506 : 					GetScrollRect(sw, uCurrentScrollbar, hwnd, &rect2);

  03dfa	8d 4d 98	 lea	 ecx, DWORD PTR _rect2$23483[ebp]
  03dfd	51		 push	 ecx
  03dfe	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03e01	52		 push	 edx
  03e02	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentScrollbar
  03e07	50		 push	 eax
  03e08	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  03e0b	51		 push	 ecx
  03e0c	e8 00 00 00 00	 call	 _GetScrollRect
  03e11	83 c4 10	 add	 esp, 16			; 00000010H

; 2507 : 					
; 2508 : 					if(uCurrentScrollbar == SB_HORZ)

  03e14	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  03e1b	75 0b		 jne	 SHORT $L23492

; 2509 : 						scrollsize = rect2.right-rect2.left;

  03e1d	8b 55 a0	 mov	 edx, DWORD PTR _rect2$23483[ebp+8]
  03e20	2b 55 98	 sub	 edx, DWORD PTR _rect2$23483[ebp]
  03e23	89 55 a8	 mov	 DWORD PTR _scrollsize$23484[ebp], edx

; 2510 : 					else

  03e26	eb 09		 jmp	 SHORT $L23493
$L23492:

; 2511 : 						scrollsize = rect2.bottom-rect2.top;

  03e28	8b 45 a4	 mov	 eax, DWORD PTR _rect2$23483[ebp+12]
  03e2b	2b 45 9c	 sub	 eax, DWORD PTR _rect2$23483[ebp+4]
  03e2e	89 45 a8	 mov	 DWORD PTR _scrollsize$23484[ebp], eax
$L23493:

; 2512 : 
; 2513 : 					butsize1 = GetButtonSize(sb, hwnd, SBBP_LEFT);

  03e31	6a 01		 push	 1
  03e33	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03e36	51		 push	 ecx
  03e37	8b 55 b8	 mov	 edx, DWORD PTR _sb$23464[ebp]
  03e3a	52		 push	 edx
  03e3b	e8 00 00 00 00	 call	 _GetButtonSize
  03e40	83 c4 0c	 add	 esp, 12			; 0000000cH
  03e43	89 45 ac	 mov	 DWORD PTR _butsize1$23481[ebp], eax

; 2514 : 					butsize2 = GetButtonSize(sb, hwnd, SBBP_RIGHT);

  03e46	6a 02		 push	 2
  03e48	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03e4b	50		 push	 eax
  03e4c	8b 4d b8	 mov	 ecx, DWORD PTR _sb$23464[ebp]
  03e4f	51		 push	 ecx
  03e50	e8 00 00 00 00	 call	 _GetButtonSize
  03e55	83 c4 0c	 add	 esp, 12			; 0000000cH
  03e58	89 45 b0	 mov	 DWORD PTR _butsize2$23482[ebp], eax

; 2515 : 
; 2516 : 					//adjust the button size if it gets too big
; 2517 : 					if(butsize1 + butsize2 > scrollsize  - MINSCROLLSIZE)

  03e5b	8b 55 ac	 mov	 edx, DWORD PTR _butsize1$23481[ebp]
  03e5e	03 55 b0	 add	 edx, DWORD PTR _butsize2$23482[ebp]
  03e61	8b 45 a8	 mov	 eax, DWORD PTR _scrollsize$23484[ebp]
  03e64	83 e8 32	 sub	 eax, 50			; 00000032H
  03e67	3b d0		 cmp	 edx, eax
  03e69	7e 1c		 jle	 SHORT $L23494

; 2518 : 					{
; 2519 : 						sbut->nSize -= (butsize1+butsize2) - (scrollsize - MINSCROLLSIZE);

  03e6b	8b 4d ac	 mov	 ecx, DWORD PTR _butsize1$23481[ebp]
  03e6e	03 4d b0	 add	 ecx, DWORD PTR _butsize2$23482[ebp]
  03e71	8b 55 a8	 mov	 edx, DWORD PTR _scrollsize$23484[ebp]
  03e74	83 ea 32	 sub	 edx, 50			; 00000032H
  03e77	2b ca		 sub	 ecx, edx
  03e79	8b 45 c0	 mov	 eax, DWORD PTR _sbut$23465[ebp]
  03e7c	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  03e7f	2b d1		 sub	 edx, ecx
  03e81	8b 45 c0	 mov	 eax, DWORD PTR _sbut$23465[ebp]
  03e84	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L23494:

; 2520 : 					}
; 2521 : 					
; 2522 : 					//remember what size the USER set the button to
; 2523 : 					sbut->nSizeReserved = sbut->nSize;

  03e87	8b 4d c0	 mov	 ecx, DWORD PTR _sbut$23465[ebp]
  03e8a	8b 55 c0	 mov	 edx, DWORD PTR _sbut$23465[ebp]
  03e8d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  03e90	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 2524 : 					NCPaint(sw, hwnd, (WPARAM)1, (LPARAM)0);

  03e93	6a 00		 push	 0
  03e95	6a 01		 push	 1
  03e97	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03e9a	51		 push	 ecx
  03e9b	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  03e9e	52		 push	 edx
  03e9f	e8 00 00 00 00	 call	 _NCPaint
  03ea4	83 c4 10	 add	 esp, 16			; 00000010H

; 2525 : 					return 0;

  03ea7	33 c0		 xor	 eax, eax
  03ea9	e9 96 01 00 00	 jmp	 $L23440
$L23478:

; 2526 : 				}
; 2527 : 			}
; 2528 : #endif	//RESIZABLE_BUTTONS			
; 2529 : 			
; 2530 : 			OffsetRect(&rect, -winrect.left, -winrect.top);

  03eae	8b 45 e4	 mov	 eax, DWORD PTR _winrect$[ebp+4]
  03eb1	f7 d8		 neg	 eax
  03eb3	50		 push	 eax
  03eb4	8b 4d e0	 mov	 ecx, DWORD PTR _winrect$[ebp]
  03eb7	f7 d9		 neg	 ecx
  03eb9	51		 push	 ecx
  03eba	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  03ebd	52		 push	 edx
  03ebe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 2531 : 
; 2532 : 			hdc = GetWindowDC(hwnd);

  03ec4	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03ec7	50		 push	 eax
  03ec8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  03ece	89 45 cc	 mov	 DWORD PTR _hdc$[ebp], eax

; 2533 : 			
; 2534 : 			//if the button under the mouse is not the active button,
; 2535 : 			//then display the active button in its normal state
; 2536 : 			if(buttonIdx != uCurrentButton 
; 2537 : 				//include this if toggle buttons always stay depressed
; 2538 : 				//if they are being activated
; 2539 : 				&& (sb->sbButtons[uCurrentButton].uButType & SBBT_MASK) != SBBT_TOGGLEBUTTON)

  03ed1	8b 4d d0	 mov	 ecx, DWORD PTR _buttonIdx$[ebp]
  03ed4	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _uCurrentButton
  03eda	74 48		 je	 SHORT $L23497
  03edc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  03ee2	6b d2 30	 imul	 edx, 48			; 00000030H
  03ee5	8b 45 b8	 mov	 eax, DWORD PTR _sb$23464[ebp]
  03ee8	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  03eec	83 e1 1f	 and	 ecx, 31			; 0000001fH
  03eef	83 f9 02	 cmp	 ecx, 2
  03ef2	74 30		 je	 SHORT $L23497

; 2540 : 			{
; 2541 : 				if(lastbutton != buttonIdx)

  03ef4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?lastbutton@?1??MouseMove@@9@9
  03efa	3b 55 d0	 cmp	 edx, DWORD PTR _buttonIdx$[ebp]
  03efd	74 23		 je	 SHORT $L23498

; 2542 : 					DrawScrollButton(&sb->sbButtons[uCurrentButton], hdc, &rect, SBBS_NORMAL);

  03eff	6a 00		 push	 0
  03f01	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  03f04	50		 push	 eax
  03f05	8b 4d cc	 mov	 ecx, DWORD PTR _hdc$[ebp]
  03f08	51		 push	 ecx
  03f09	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  03f0f	6b d2 30	 imul	 edx, 48			; 00000030H
  03f12	8b 45 b8	 mov	 eax, DWORD PTR _sb$23464[ebp]
  03f15	8d 4c 10 2c	 lea	 ecx, DWORD PTR [eax+edx+44]
  03f19	51		 push	 ecx
  03f1a	e8 00 00 00 00	 call	 _DrawScrollButton
  03f1f	83 c4 10	 add	 esp, 16			; 00000010H
$L23498:

; 2543 : 			}
; 2544 : 			//otherwise, depress the active button if the mouse is over
; 2545 : 			//it (just like a normal scroll button works)
; 2546 : 			else

  03f22	eb 2e		 jmp	 SHORT $L23499
$L23497:

; 2547 : 			{
; 2548 : 				if(lastbutton != buttonIdx)

  03f24	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?lastbutton@?1??MouseMove@@9@9
  03f2a	3b 55 d0	 cmp	 edx, DWORD PTR _buttonIdx$[ebp]
  03f2d	74 23		 je	 SHORT $L23499

; 2549 : 					DrawScrollButton(&sb->sbButtons[uCurrentButton], hdc, &rect, SBBS_PUSHED);

  03f2f	6a 01		 push	 1
  03f31	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  03f34	50		 push	 eax
  03f35	8b 4d cc	 mov	 ecx, DWORD PTR _hdc$[ebp]
  03f38	51		 push	 ecx
  03f39	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  03f3f	6b d2 30	 imul	 edx, 48			; 00000030H
  03f42	8b 45 b8	 mov	 eax, DWORD PTR _sb$23464[ebp]
  03f45	8d 4c 10 2c	 lea	 ecx, DWORD PTR [eax+edx+44]
  03f49	51		 push	 ecx
  03f4a	e8 00 00 00 00	 call	 _DrawScrollButton
  03f4f	83 c4 10	 add	 esp, 16			; 00000010H
$L23499:

; 2550 : 			}
; 2551 : 
; 2552 : 			ReleaseDC(hwnd, hdc);

  03f52	8b 55 cc	 mov	 edx, DWORD PTR _hdc$[ebp]
  03f55	52		 push	 edx
  03f56	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03f59	50		 push	 eax
  03f5a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 2553 : 			return CallWindowProc(sw->oldproc, hwnd, WM_MOUSEMOVE, wParam, lParam);

  03f60	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  03f63	51		 push	 ecx
  03f64	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  03f67	52		 push	 edx
  03f68	68 00 02 00 00	 push	 512			; 00000200H
  03f6d	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03f70	50		 push	 eax
  03f71	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  03f74	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  03f77	52		 push	 edx
  03f78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  03f7e	e9 c1 00 00 00	 jmp	 $L23440
$L23501:

; 2554 : 			//break;
; 2555 : 
; 2556 : #endif	//INCLUDE_BUTTONS
; 2557 : 
; 2558 : 		//The scrollbar is active
; 2559 : 		case HTSCROLL_LEFT:		 case HTSCROLL_RIGHT:case HTSCROLL_THUMB: 
; 2560 : 		case HTSCROLL_PAGELEFT:  case HTSCROLL_PAGERIGHT: 
; 2561 : 		case HTSCROLL_NONE:
; 2562 : 			
; 2563 : 			//adjust the total scroll area to become where the scrollbar
; 2564 : 			//really is (take into account the inserted buttons)
; 2565 : 			GetRealScrollRect(sb, &rect);

  03f83	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  03f86	50		 push	 eax
  03f87	8b 4d b8	 mov	 ecx, DWORD PTR _sb$23464[ebp]
  03f8a	51		 push	 ecx
  03f8b	e8 00 00 00 00	 call	 _GetRealScrollRect
  03f90	83 c4 08	 add	 esp, 8

; 2566 : 
; 2567 : 			OffsetRect(&rect, -winrect.left, -winrect.top);

  03f93	8b 55 e4	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  03f96	f7 da		 neg	 edx
  03f98	52		 push	 edx
  03f99	8b 45 e0	 mov	 eax, DWORD PTR _winrect$[ebp]
  03f9c	f7 d8		 neg	 eax
  03f9e	50		 push	 eax
  03f9f	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  03fa2	51		 push	 ecx
  03fa3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 2568 : 			hdc = GetWindowDC(hwnd);

  03fa9	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03fac	52		 push	 edx
  03fad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  03fb3	89 45 cc	 mov	 DWORD PTR _hdc$[ebp], eax

; 2569 : 		
; 2570 : 			if(thisportion != uCurrentScrollPortion)

  03fb6	8b 45 dc	 mov	 eax, DWORD PTR _thisportion$[ebp]
  03fb9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _uCurrentScrollPortion
  03fbf	74 31		 je	 SHORT $L23502

; 2571 : 			{
; 2572 : 				uScrollTimerPortion = HTSCROLL_NONE;

  03fc1	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uScrollTimerPortion, -1

; 2573 : 
; 2574 : 				if(lastportion != thisportion)

  03fcb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lastportion@?1??MouseMove@@9@9
  03fd1	3b 4d dc	 cmp	 ecx, DWORD PTR _thisportion$[ebp]
  03fd4	74 1a		 je	 SHORT $L23503

; 2575 : 					NCDrawScrollbar(sb, hwnd, hdc, &rect, HTSCROLL_NORMAL);

  03fd6	6a ff		 push	 -1
  03fd8	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  03fdb	52		 push	 edx
  03fdc	8b 45 cc	 mov	 eax, DWORD PTR _hdc$[ebp]
  03fdf	50		 push	 eax
  03fe0	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03fe3	51		 push	 ecx
  03fe4	8b 55 b8	 mov	 edx, DWORD PTR _sb$23464[ebp]
  03fe7	52		 push	 edx
  03fe8	e8 00 00 00 00	 call	 _NCDrawScrollbar
  03fed	83 c4 14	 add	 esp, 20			; 00000014H
$L23503:

; 2576 : 			}
; 2577 : 			//otherwise, draw the button in its depressed / clicked state
; 2578 : 			else

  03ff0	eb 31		 jmp	 SHORT $L23504
$L23502:

; 2579 : 			{
; 2580 : 				uScrollTimerPortion = uCurrentScrollPortion;

  03ff2	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentScrollPortion
  03ff7	a3 00 00 00 00	 mov	 DWORD PTR _uScrollTimerPortion, eax

; 2581 : 
; 2582 : 				if(lastportion != thisportion)

  03ffc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lastportion@?1??MouseMove@@9@9
  04002	3b 4d dc	 cmp	 ecx, DWORD PTR _thisportion$[ebp]
  04005	74 1c		 je	 SHORT $L23504

; 2583 : 					NCDrawScrollbar(sb, hwnd, hdc, &rect, thisportion);

  04007	8b 55 dc	 mov	 edx, DWORD PTR _thisportion$[ebp]
  0400a	52		 push	 edx
  0400b	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  0400e	50		 push	 eax
  0400f	8b 4d cc	 mov	 ecx, DWORD PTR _hdc$[ebp]
  04012	51		 push	 ecx
  04013	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04016	52		 push	 edx
  04017	8b 45 b8	 mov	 eax, DWORD PTR _sb$23464[ebp]
  0401a	50		 push	 eax
  0401b	e8 00 00 00 00	 call	 _NCDrawScrollbar
  04020	83 c4 14	 add	 esp, 20			; 00000014H
$L23504:

; 2584 : 			}
; 2585 : 
; 2586 : 			ReleaseDC(hwnd, hdc);

  04023	8b 4d cc	 mov	 ecx, DWORD PTR _hdc$[ebp]
  04026	51		 push	 ecx
  04027	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0402a	52		 push	 edx
  0402b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
$L23474:

; 2587 : 
; 2588 : 			break;
; 2589 : 		}
; 2590 : 
; 2591 : 
; 2592 : 		lastportion = thisportion;

  04031	8b 45 dc	 mov	 eax, DWORD PTR _thisportion$[ebp]
  04034	a3 00 00 00 00	 mov	 DWORD PTR ?lastportion@?1??MouseMove@@9@9, eax

; 2593 : 		lastbutton  = buttonIdx;

  04039	8b 4d d0	 mov	 ecx, DWORD PTR _buttonIdx$[ebp]
  0403c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?lastbutton@?1??MouseMove@@9@9, ecx

; 2594 : 
; 2595 : 		//must return zero here, because we might get cursor anomilies
; 2596 : 		//CallWindowProc(sw->oldproc, hwnd, WM_MOUSEMOVE, wParam, lParam);
; 2597 : 		return 0;

  04042	33 c0		 xor	 eax, eax
$L23440:

; 2598 : 		
; 2599 : 	}
; 2600 : }

  04044	8b e5		 mov	 esp, ebp
  04046	5d		 pop	 ebp
  04047	c3		 ret	 0
_MouseMove ENDP
; Function compile flags: /Odt
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_GetPortion PROC NEAR

; 1713 : {

  04050	55		 push	 ebp
  04051	8b ec		 mov	 ebp, esp

; 1714 : 	if(sb->nBarType == SB_HORZ)

  04053	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04056	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  0405d	75 1e		 jne	 SHORT $L23162

; 1715 : 		return GetHorzPortion(sb, hwnd, rect, x, y);

  0405f	8b 4d 18	 mov	 ecx, DWORD PTR _y$[ebp]
  04062	51		 push	 ecx
  04063	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  04066	52		 push	 edx
  04067	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  0406a	50		 push	 eax
  0406b	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0406e	51		 push	 ecx
  0406f	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  04072	52		 push	 edx
  04073	e8 00 00 00 00	 call	 _GetHorzPortion
  04078	83 c4 14	 add	 esp, 20			; 00000014H
  0407b	eb 2d		 jmp	 SHORT $L23161
$L23162:

; 1716 : 	else if(sb->nBarType == SB_VERT)

  0407d	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04080	83 b8 40 03 00
	00 01		 cmp	 DWORD PTR [eax+832], 1
  04087	75 1e		 jne	 SHORT $L23164

; 1717 : 		return GetVertPortion(sb, hwnd, rect, x, y);

  04089	8b 4d 18	 mov	 ecx, DWORD PTR _y$[ebp]
  0408c	51		 push	 ecx
  0408d	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  04090	52		 push	 edx
  04091	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  04094	50		 push	 eax
  04095	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04098	51		 push	 ecx
  04099	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  0409c	52		 push	 edx
  0409d	e8 00 00 00 00	 call	 _GetVertPortion
  040a2	83 c4 14	 add	 esp, 20			; 00000014H
  040a5	eb 03		 jmp	 SHORT $L23161
$L23164:

; 1718 : 	else
; 1719 : 		return HTSCROLL_NONE;

  040a7	83 c8 ff	 or	 eax, -1
$L23161:

; 1720 : }

  040aa	5d		 pop	 ebp
  040ab	c3		 ret	 0
_GetPortion ENDP
; Function compile flags: /Odt
_hdc$ = -92						; size = 4
_pos$ = -88						; size = 4
_rc2$ = -84						; size = 16
_si$ = -68						; size = 4
_crCheck2$ = -64					; size = 4
_siMaxMin$ = -60					; size = 4
_thumbpos$ = -56					; size = 4
_crCheck1$ = -52					; size = 4
_pt$ = -48						; size = 8
_fCustomDraw$ = -40					; size = 4
_winrect$ = -36						; size = 16
_flatflag$ = -20					; size = 4
_rc$ = -16						; size = 16
_sbar$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_ThumbTrackHorz PROC NEAR

; 2253 : {

  040b0	55		 push	 ebp
  040b1	8b ec		 mov	 ebp, esp
  040b3	83 ec 5c	 sub	 esp, 92			; 0000005cH

; 2254 : 	POINT pt;
; 2255 : 	RECT rc, winrect, rc2;
; 2256 : 	COLORREF crCheck1 = GetSBForeColor();

  040b6	e8 00 00 00 00	 call	 _GetSBForeColor
  040bb	89 45 cc	 mov	 DWORD PTR _crCheck1$[ebp], eax

; 2257 : 	COLORREF crCheck2 = GetSBBackColor();

  040be	e8 00 00 00 00	 call	 _GetSBBackColor
  040c3	89 45 c0	 mov	 DWORD PTR _crCheck2$[ebp], eax

; 2258 : 	HDC hdc;
; 2259 : 	int thumbpos = nThumbPos;

  040c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _nThumbPos
  040cb	89 45 c8	 mov	 DWORD PTR _thumbpos$[ebp], eax

; 2260 : 	int pos;
; 2261 : 	int siMaxMin = 0;

  040ce	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _siMaxMin$[ebp], 0

; 2262 : 	UINT flatflag = sbar->fFlatScrollbar ? BF_FLAT : 0;

  040d5	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  040d8	8b 91 44 03 00
	00		 mov	 edx, DWORD PTR [ecx+836]
  040de	f7 da		 neg	 edx
  040e0	1b d2		 sbb	 edx, edx
  040e2	81 e2 00 40 00
	00		 and	 edx, 16384		; 00004000H
  040e8	89 55 ec	 mov	 DWORD PTR _flatflag$[ebp], edx

; 2263 : 	BOOL fCustomDraw = FALSE;

  040eb	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _fCustomDraw$[ebp], 0

; 2264 : 
; 2265 : 	SCROLLINFO *si;
; 2266 : 	si = &sbar->scrollInfo;

  040f2	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  040f5	83 c0 08	 add	 eax, 8
  040f8	89 45 bc	 mov	 DWORD PTR _si$[ebp], eax

; 2267 : 
; 2268 : 	pt.x = x;

  040fb	8b 4d 10	 mov	 ecx, DWORD PTR _x$[ebp]
  040fe	89 4d d0	 mov	 DWORD PTR _pt$[ebp], ecx

; 2269 : 	pt.y = y;

  04101	8b 55 14	 mov	 edx, DWORD PTR _y$[ebp]
  04104	89 55 d4	 mov	 DWORD PTR _pt$[ebp+4], edx

; 2270 : 
; 2271 : 	//draw the thumb at whatever position
; 2272 : 	rc = rcThumbBounds;

  04107	a1 00 00 00 00	 mov	 eax, DWORD PTR _rcThumbBounds
  0410c	89 45 f0	 mov	 DWORD PTR _rc$[ebp], eax
  0410f	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _rcThumbBounds+4
  04115	89 4d f4	 mov	 DWORD PTR _rc$[ebp+4], ecx
  04118	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _rcThumbBounds+8
  0411e	89 55 f8	 mov	 DWORD PTR _rc$[ebp+8], edx
  04121	a1 0c 00 00 00	 mov	 eax, DWORD PTR _rcThumbBounds+12
  04126	89 45 fc	 mov	 DWORD PTR _rc$[ebp+12], eax

; 2273 : 
; 2274 : 	SetRect(&rc2, rc.left -  THUMBTRACK_SNAPDIST*2, rc.top -    THUMBTRACK_SNAPDIST, 
; 2275 : 				  rc.right + THUMBTRACK_SNAPDIST*2, rc.bottom + THUMBTRACK_SNAPDIST);

  04129	8b 4d fc	 mov	 ecx, DWORD PTR _rc$[ebp+12]
  0412c	83 c1 18	 add	 ecx, 24			; 00000018H
  0412f	51		 push	 ecx
  04130	8b 55 f8	 mov	 edx, DWORD PTR _rc$[ebp+8]
  04133	83 c2 30	 add	 edx, 48			; 00000030H
  04136	52		 push	 edx
  04137	8b 45 f4	 mov	 eax, DWORD PTR _rc$[ebp+4]
  0413a	83 e8 18	 sub	 eax, 24			; 00000018H
  0413d	50		 push	 eax
  0413e	8b 4d f0	 mov	 ecx, DWORD PTR _rc$[ebp]
  04141	83 e9 30	 sub	 ecx, 48			; 00000030H
  04144	51		 push	 ecx
  04145	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  04148	52		 push	 edx
  04149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 2276 : 
; 2277 : 	rc.left +=  GetScrollMetric(sbar, SM_CXHORZSB);

  0414f	6a 00		 push	 0
  04151	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  04154	50		 push	 eax
  04155	e8 00 00 00 00	 call	 _GetScrollMetric
  0415a	83 c4 08	 add	 esp, 8
  0415d	03 45 f0	 add	 eax, DWORD PTR _rc$[ebp]
  04160	89 45 f0	 mov	 DWORD PTR _rc$[ebp], eax

; 2278 : 	rc.right -= GetScrollMetric(sbar, SM_CXHORZSB);

  04163	6a 00		 push	 0
  04165	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  04168	51		 push	 ecx
  04169	e8 00 00 00 00	 call	 _GetScrollMetric
  0416e	83 c4 08	 add	 esp, 8
  04171	8b 55 f8	 mov	 edx, DWORD PTR _rc$[ebp+8]
  04174	2b d0		 sub	 edx, eax
  04176	89 55 f8	 mov	 DWORD PTR _rc$[ebp+8], edx

; 2279 : 
; 2280 : 	//if the mouse is not in a suitable distance of the scrollbar,
; 2281 : 	//then "snap" the thumb back to its initial position
; 2282 : #ifdef SNAP_THUMB_BACK
; 2283 : 	if(!PtInRect(&rc2, pt))

  04179	8b 45 d4	 mov	 eax, DWORD PTR _pt$[ebp+4]
  0417c	50		 push	 eax
  0417d	8b 4d d0	 mov	 ecx, DWORD PTR _pt$[ebp]
  04180	51		 push	 ecx
  04181	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  04184	52		 push	 edx
  04185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  0418b	85 c0		 test	 eax, eax
  0418d	75 0a		 jne	 SHORT $L23405

; 2284 : 	{
; 2285 : 		thumbpos = nThumbPos0;

  0418f	a1 00 00 00 00	 mov	 eax, DWORD PTR _nThumbPos0
  04194	89 45 c8	 mov	 DWORD PTR _thumbpos$[ebp], eax

; 2286 : 	}
; 2287 : 	//otherwise, move the thumb to where the mouse is
; 2288 : 	else

  04197	eb 34		 jmp	 SHORT $L23406
$L23405:

; 2289 : #endif //SNAP_THUMB_BACK
; 2290 : 	{
; 2291 : 		//keep the thumb within the scrollbar limits
; 2292 : 		thumbpos = pt.x - nThumbMouseOffset;

  04199	8b 4d d0	 mov	 ecx, DWORD PTR _pt$[ebp]
  0419c	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _nThumbMouseOffset
  041a2	89 4d c8	 mov	 DWORD PTR _thumbpos$[ebp], ecx

; 2293 : 		if(thumbpos < rc.left) thumbpos = rc.left;

  041a5	8b 55 c8	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  041a8	3b 55 f0	 cmp	 edx, DWORD PTR _rc$[ebp]
  041ab	7d 06		 jge	 SHORT $L23407
  041ad	8b 45 f0	 mov	 eax, DWORD PTR _rc$[ebp]
  041b0	89 45 c8	 mov	 DWORD PTR _thumbpos$[ebp], eax
$L23407:

; 2294 : 		if(thumbpos > rc.right - nThumbSize) thumbpos = rc.right - nThumbSize;

  041b3	8b 4d f8	 mov	 ecx, DWORD PTR _rc$[ebp+8]
  041b6	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _nThumbSize
  041bc	39 4d c8	 cmp	 DWORD PTR _thumbpos$[ebp], ecx
  041bf	7e 0c		 jle	 SHORT $L23406
  041c1	8b 55 f8	 mov	 edx, DWORD PTR _rc$[ebp+8]
  041c4	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _nThumbSize
  041ca	89 55 c8	 mov	 DWORD PTR _thumbpos$[ebp], edx
$L23406:

; 2295 : 	}
; 2296 : 
; 2297 : 	GetWindowRect(hwnd, &winrect);

  041cd	8d 45 dc	 lea	 eax, DWORD PTR _winrect$[ebp]
  041d0	50		 push	 eax
  041d1	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  041d4	51		 push	 ecx
  041d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 2298 : 
; 2299 : 	if(sbar->nBarType == SB_VERT)

  041db	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  041de	83 ba 40 03 00
	00 01		 cmp	 DWORD PTR [edx+832], 1
  041e5	75 09		 jne	 SHORT $L23409

; 2300 : 		RotateRect(&winrect);

  041e7	8d 45 dc	 lea	 eax, DWORD PTR _winrect$[ebp]
  041ea	50		 push	 eax
  041eb	e8 00 00 00 00	 call	 _RotateRect@4
$L23409:

; 2301 : 	
; 2302 : 	hdc = GetWindowDC(hwnd);

  041f0	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  041f3	51		 push	 ecx
  041f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  041fa	89 45 a4	 mov	 DWORD PTR _hdc$[ebp], eax

; 2303 : 		
; 2304 : #ifdef CUSTOM_DRAW
; 2305 : 	fCustomDraw = PostCustomPrePostPaint(hwnd, hdc, sbar, CDDS_PREPAINT) == CDRF_SKIPDEFAULT;

  041fd	6a 01		 push	 1
  041ff	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  04202	52		 push	 edx
  04203	8b 45 a4	 mov	 eax, DWORD PTR _hdc$[ebp]
  04206	50		 push	 eax
  04207	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0420a	51		 push	 ecx
  0420b	e8 00 00 00 00	 call	 _PostCustomPrePostPaint0
  04210	83 c4 10	 add	 esp, 16			; 00000010H
  04213	83 e8 04	 sub	 eax, 4
  04216	f7 d8		 neg	 eax
  04218	1b c0		 sbb	 eax, eax
  0421a	40		 inc	 eax
  0421b	89 45 d8	 mov	 DWORD PTR _fCustomDraw$[ebp], eax

; 2306 : #endif
; 2307 : 
; 2308 : 	OffsetRect(&rc, -winrect.left, -winrect.top);

  0421e	8b 55 e0	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  04221	f7 da		 neg	 edx
  04223	52		 push	 edx
  04224	8b 45 dc	 mov	 eax, DWORD PTR _winrect$[ebp]
  04227	f7 d8		 neg	 eax
  04229	50		 push	 eax
  0422a	8d 4d f0	 lea	 ecx, DWORD PTR _rc$[ebp]
  0422d	51		 push	 ecx
  0422e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 2309 : 	thumbpos -= winrect.left;

  04234	8b 55 c8	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  04237	2b 55 dc	 sub	 edx, DWORD PTR _winrect$[ebp]
  0423a	89 55 c8	 mov	 DWORD PTR _thumbpos$[ebp], edx

; 2310 : 
; 2311 : 	//draw the margin before the thumb
; 2312 : 	SetRect(&rc2, rc.left, rc.top, thumbpos, rc.bottom);

  0423d	8b 45 fc	 mov	 eax, DWORD PTR _rc$[ebp+12]
  04240	50		 push	 eax
  04241	8b 4d c8	 mov	 ecx, DWORD PTR _thumbpos$[ebp]
  04244	51		 push	 ecx
  04245	8b 55 f4	 mov	 edx, DWORD PTR _rc$[ebp+4]
  04248	52		 push	 edx
  04249	8b 45 f0	 mov	 eax, DWORD PTR _rc$[ebp]
  0424c	50		 push	 eax
  0424d	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  04250	51		 push	 ecx
  04251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 2313 : 	RotateRect0(sbar, &rc2);

  04257	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  0425a	52		 push	 edx
  0425b	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  0425e	50		 push	 eax
  0425f	e8 00 00 00 00	 call	 _RotateRect0@8

; 2314 : 
; 2315 : 	if(fCustomDraw)

  04264	83 7d d8 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  04268	74 28		 je	 SHORT $L23410

; 2316 : 		PostCustomDrawNotify(hwnd, hdc, sbar->nBarType, &rc2, SB_PAGELEFT, 0, 0, 0);

  0426a	6a 00		 push	 0
  0426c	6a 00		 push	 0
  0426e	6a 00		 push	 0
  04270	6a 02		 push	 2
  04272	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  04275	51		 push	 ecx
  04276	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  04279	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  0427f	50		 push	 eax
  04280	8b 4d a4	 mov	 ecx, DWORD PTR _hdc$[ebp]
  04283	51		 push	 ecx
  04284	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04287	52		 push	 edx
  04288	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  0428d	83 c4 20	 add	 esp, 32			; 00000020H

; 2317 : 	else

  04290	eb 18		 jmp	 SHORT $L23411
$L23410:

; 2318 : 		DrawCheckedRect(hdc, &rc2, crCheck1, crCheck2);

  04292	8b 45 c0	 mov	 eax, DWORD PTR _crCheck2$[ebp]
  04295	50		 push	 eax
  04296	8b 4d cc	 mov	 ecx, DWORD PTR _crCheck1$[ebp]
  04299	51		 push	 ecx
  0429a	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  0429d	52		 push	 edx
  0429e	8b 45 a4	 mov	 eax, DWORD PTR _hdc$[ebp]
  042a1	50		 push	 eax
  042a2	e8 00 00 00 00	 call	 _DrawCheckedRect
  042a7	83 c4 10	 add	 esp, 16			; 00000010H
$L23411:

; 2319 : 	
; 2320 : 	RotateRect0(sbar, &rc2);

  042aa	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  042ad	51		 push	 ecx
  042ae	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  042b1	52		 push	 edx
  042b2	e8 00 00 00 00	 call	 _RotateRect0@8

; 2321 : 
; 2322 : 	//draw the margin after the thumb 
; 2323 : 	SetRect(&rc2, thumbpos+nThumbSize, rc.top, rc.right, rc.bottom);

  042b7	8b 45 fc	 mov	 eax, DWORD PTR _rc$[ebp+12]
  042ba	50		 push	 eax
  042bb	8b 4d f8	 mov	 ecx, DWORD PTR _rc$[ebp+8]
  042be	51		 push	 ecx
  042bf	8b 55 f4	 mov	 edx, DWORD PTR _rc$[ebp+4]
  042c2	52		 push	 edx
  042c3	8b 45 c8	 mov	 eax, DWORD PTR _thumbpos$[ebp]
  042c6	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nThumbSize
  042cc	50		 push	 eax
  042cd	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  042d0	51		 push	 ecx
  042d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 2324 : 	
; 2325 : 	RotateRect0(sbar, &rc2);

  042d7	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  042da	52		 push	 edx
  042db	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  042de	50		 push	 eax
  042df	e8 00 00 00 00	 call	 _RotateRect0@8

; 2326 : 	
; 2327 : 	if(fCustomDraw)

  042e4	83 7d d8 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  042e8	74 28		 je	 SHORT $L23412

; 2328 : 		PostCustomDrawNotify(hwnd, hdc, sbar->nBarType, &rc2, SB_PAGERIGHT, 0, 0, 0);

  042ea	6a 00		 push	 0
  042ec	6a 00		 push	 0
  042ee	6a 00		 push	 0
  042f0	6a 03		 push	 3
  042f2	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  042f5	51		 push	 ecx
  042f6	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  042f9	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  042ff	50		 push	 eax
  04300	8b 4d a4	 mov	 ecx, DWORD PTR _hdc$[ebp]
  04303	51		 push	 ecx
  04304	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04307	52		 push	 edx
  04308	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  0430d	83 c4 20	 add	 esp, 32			; 00000020H

; 2329 : 	else

  04310	eb 18		 jmp	 SHORT $L23413
$L23412:

; 2330 : 		DrawCheckedRect(hdc, &rc2, crCheck1, crCheck2);

  04312	8b 45 c0	 mov	 eax, DWORD PTR _crCheck2$[ebp]
  04315	50		 push	 eax
  04316	8b 4d cc	 mov	 ecx, DWORD PTR _crCheck1$[ebp]
  04319	51		 push	 ecx
  0431a	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  0431d	52		 push	 edx
  0431e	8b 45 a4	 mov	 eax, DWORD PTR _hdc$[ebp]
  04321	50		 push	 eax
  04322	e8 00 00 00 00	 call	 _DrawCheckedRect
  04327	83 c4 10	 add	 esp, 16			; 00000010H
$L23413:

; 2331 : 	
; 2332 : 	RotateRect0(sbar, &rc2);

  0432a	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  0432d	51		 push	 ecx
  0432e	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  04331	52		 push	 edx
  04332	e8 00 00 00 00	 call	 _RotateRect0@8

; 2333 : 	
; 2334 : 	//finally draw the thumb itelf. This is how it looks on win2000, anyway
; 2335 : 	SetRect(&rc2, thumbpos, rc.top, thumbpos+nThumbSize, rc.bottom);

  04337	8b 45 fc	 mov	 eax, DWORD PTR _rc$[ebp+12]
  0433a	50		 push	 eax
  0433b	8b 4d c8	 mov	 ecx, DWORD PTR _thumbpos$[ebp]
  0433e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _nThumbSize
  04344	51		 push	 ecx
  04345	8b 55 f4	 mov	 edx, DWORD PTR _rc$[ebp+4]
  04348	52		 push	 edx
  04349	8b 45 c8	 mov	 eax, DWORD PTR _thumbpos$[ebp]
  0434c	50		 push	 eax
  0434d	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  04350	51		 push	 ecx
  04351	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 2336 : 	
; 2337 : 	RotateRect0(sbar, &rc2);

  04357	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  0435a	52		 push	 edx
  0435b	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  0435e	50		 push	 eax
  0435f	e8 00 00 00 00	 call	 _RotateRect0@8

; 2338 : 
; 2339 : 	if(fCustomDraw)

  04364	83 7d d8 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  04368	74 28		 je	 SHORT $L23414

; 2340 : 		PostCustomDrawNotify(hwnd, hdc, sbar->nBarType, &rc2, SB_THUMBTRACK, TRUE, TRUE, FALSE);

  0436a	6a 00		 push	 0
  0436c	6a 01		 push	 1
  0436e	6a 01		 push	 1
  04370	6a 05		 push	 5
  04372	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  04375	51		 push	 ecx
  04376	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  04379	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  0437f	50		 push	 eax
  04380	8b 4d a4	 mov	 ecx, DWORD PTR _hdc$[ebp]
  04383	51		 push	 ecx
  04384	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04387	52		 push	 edx
  04388	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  0438d	83 c4 20	 add	 esp, 32			; 00000020H

; 2341 : 	else

  04390	eb 3b		 jmp	 SHORT $L23415
$L23414:

; 2342 : 	{
; 2343 : 
; 2344 : #ifdef FLAT_SCROLLBARS	
; 2345 : 		if(sbar->fFlatScrollbar)

  04392	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  04395	83 b8 44 03 00
	00 00		 cmp	 DWORD PTR [eax+836], 0
  0439c	74 1b		 je	 SHORT $L23416

; 2346 : 			PaintRect(hdc, &rc2, GetSysColor(COLOR_3DSHADOW));

  0439e	6a 10		 push	 16			; 00000010H
  043a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  043a6	50		 push	 eax
  043a7	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  043aa	51		 push	 ecx
  043ab	8b 55 a4	 mov	 edx, DWORD PTR _hdc$[ebp]
  043ae	52		 push	 edx
  043af	e8 00 00 00 00	 call	 _PaintRect
  043b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2347 : 		else

  043b7	eb 14		 jmp	 SHORT $L23415
$L23416:

; 2348 : #endif
; 2349 : 		{
; 2350 : 				DrawBlankButton(hdc, &rc2, flatflag);

  043b9	8b 45 ec	 mov	 eax, DWORD PTR _flatflag$[ebp]
  043bc	50		 push	 eax
  043bd	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  043c0	51		 push	 ecx
  043c1	8b 55 a4	 mov	 edx, DWORD PTR _hdc$[ebp]
  043c4	52		 push	 edx
  043c5	e8 00 00 00 00	 call	 _DrawBlankButton
  043ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$L23415:

; 2351 : 		}
; 2352 : 	}
; 2353 : 
; 2354 : 	RotateRect0(sbar, &rc2);

  043cd	8d 45 ac	 lea	 eax, DWORD PTR _rc2$[ebp]
  043d0	50		 push	 eax
  043d1	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  043d4	51		 push	 ecx
  043d5	e8 00 00 00 00	 call	 _RotateRect0@8

; 2355 : 	ReleaseDC(hwnd, hdc);

  043da	8b 55 a4	 mov	 edx, DWORD PTR _hdc$[ebp]
  043dd	52		 push	 edx
  043de	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  043e1	50		 push	 eax
  043e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 2356 : 
; 2357 : 	//post a SB_TRACKPOS message!!!
; 2358 : 	siMaxMin = si->nMax - si->nMin;

  043e8	8b 4d bc	 mov	 ecx, DWORD PTR _si$[ebp]
  043eb	8b 55 bc	 mov	 edx, DWORD PTR _si$[ebp]
  043ee	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  043f1	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  043f4	89 45 c4	 mov	 DWORD PTR _siMaxMin$[ebp], eax

; 2359 : 
; 2360 : 	if(siMaxMin > 0)

  043f7	83 7d c4 00	 cmp	 DWORD PTR _siMaxMin$[ebp], 0
  043fb	7e 2c		 jle	 SHORT $L23418

; 2361 : 		pos = MulDiv(thumbpos-rc.left, siMaxMin-si->nPage + 1, rc.right-rc.left-nThumbSize);

  043fd	8b 4d f8	 mov	 ecx, DWORD PTR _rc$[ebp+8]
  04400	2b 4d f0	 sub	 ecx, DWORD PTR _rc$[ebp]
  04403	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _nThumbSize
  04409	51		 push	 ecx
  0440a	8b 55 bc	 mov	 edx, DWORD PTR _si$[ebp]
  0440d	8b 45 c4	 mov	 eax, DWORD PTR _siMaxMin$[ebp]
  04410	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  04413	83 c0 01	 add	 eax, 1
  04416	50		 push	 eax
  04417	8b 4d c8	 mov	 ecx, DWORD PTR _thumbpos$[ebp]
  0441a	2b 4d f0	 sub	 ecx, DWORD PTR _rc$[ebp]
  0441d	51		 push	 ecx
  0441e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  04424	89 45 a8	 mov	 DWORD PTR _pos$[ebp], eax

; 2362 : 	else

  04427	eb 09		 jmp	 SHORT $L23419
$L23418:

; 2363 : 		pos = thumbpos - rc.left;

  04429	8b 55 c8	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  0442c	2b 55 f0	 sub	 edx, DWORD PTR _rc$[ebp]
  0442f	89 55 a8	 mov	 DWORD PTR _pos$[ebp], edx
$L23419:

; 2364 : 
; 2365 : 	if(pos != nLastPos)

  04432	8b 45 a8	 mov	 eax, DWORD PTR _pos$[ebp]
  04435	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nLastPos
  0443b	74 22		 je	 SHORT $L23420

; 2366 : 	{
; 2367 : 		si->nTrackPos = pos;	

  0443d	8b 4d bc	 mov	 ecx, DWORD PTR _si$[ebp]
  04440	8b 55 a8	 mov	 edx, DWORD PTR _pos$[ebp]
  04443	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 2368 : 		SendScrollMessage(hwnd, uScrollTimerMsg, SB_THUMBTRACK, pos);

  04446	8b 45 a8	 mov	 eax, DWORD PTR _pos$[ebp]
  04449	50		 push	 eax
  0444a	6a 05		 push	 5
  0444c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uScrollTimerMsg
  04452	51		 push	 ecx
  04453	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04456	52		 push	 edx
  04457	e8 00 00 00 00	 call	 _SendScrollMessage
  0445c	83 c4 10	 add	 esp, 16			; 00000010H
$L23420:

; 2369 : 	}
; 2370 : 
; 2371 : 	nLastPos = pos;

  0445f	8b 45 a8	 mov	 eax, DWORD PTR _pos$[ebp]
  04462	a3 00 00 00 00	 mov	 DWORD PTR _nLastPos, eax

; 2372 : 
; 2373 : #ifdef CUSTOM_DRAW
; 2374 : 	PostCustomPrePostPaint(hwnd, hdc, sbar, CDDS_POSTPAINT);

  04467	6a 02		 push	 2
  04469	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  0446c	51		 push	 ecx
  0446d	8b 55 a4	 mov	 edx, DWORD PTR _hdc$[ebp]
  04470	52		 push	 edx
  04471	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04474	50		 push	 eax
  04475	e8 00 00 00 00	 call	 _PostCustomPrePostPaint0
  0447a	83 c4 10	 add	 esp, 16			; 00000010H

; 2375 : #endif
; 2376 : 	
; 2377 : 	return 0;

  0447d	33 c0		 xor	 eax, eax

; 2378 : }

  0447f	8b e5		 mov	 esp, ebp
  04481	5d		 pop	 ebp
  04482	c3		 ret	 0
_ThumbTrackHorz ENDP
; Function compile flags: /Odt
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_ThumbTrackVert PROC NEAR

; 2384 : {

  04490	55		 push	 ebp
  04491	8b ec		 mov	 ebp, esp

; 2385 : 	//sw->swapcoords = TRUE;
; 2386 : 	RotateRect(&rcThumbBounds);

  04493	68 00 00 00 00	 push	 OFFSET FLAT:_rcThumbBounds
  04498	e8 00 00 00 00	 call	 _RotateRect@4

; 2387 : 	ThumbTrackHorz(sb, hwnd, y, x);

  0449d	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  044a0	50		 push	 eax
  044a1	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  044a4	51		 push	 ecx
  044a5	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  044a8	52		 push	 edx
  044a9	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  044ac	50		 push	 eax
  044ad	e8 00 00 00 00	 call	 _ThumbTrackHorz
  044b2	83 c4 10	 add	 esp, 16			; 00000010H

; 2388 : 	RotateRect(&rcThumbBounds);

  044b5	68 00 00 00 00	 push	 OFFSET FLAT:_rcThumbBounds
  044ba	e8 00 00 00 00	 call	 _RotateRect@4

; 2389 : 	//sw->swapcoords = FALSE;
; 2390 : 
; 2391 : 	return 0;

  044bf	33 c0		 xor	 eax, eax

; 2392 : }

  044c1	5d		 pop	 ebp
  044c2	c3		 ret	 0
_ThumbTrackVert ENDP
; Function compile flags: /Odt
_ret$ = -40						; size = 4
_dwStyle$ = -36						; size = 4
_oldrect$ = -32						; size = 16
_nccsp$ = -16						; size = 4
_fCalcValidRects$ = -12					; size = 4
_sb$ = -8						; size = 4
_rect$ = -4						; size = 4
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_NCCalcSize PROC NEAR

; 2674 : {

  044d0	55		 push	 ebp
  044d1	8b ec		 mov	 ebp, esp
  044d3	83 ec 28	 sub	 esp, 40			; 00000028H
  044d6	56		 push	 esi

; 2675 : 	NCCALCSIZE_PARAMS *nccsp;
; 2676 : 	RECT *rect;
; 2677 : 	RECT oldrect;
; 2678 : 	BOOL fCalcValidRects = (wParam == TRUE);

  044d7	33 c0		 xor	 eax, eax
  044d9	83 7d 10 01	 cmp	 DWORD PTR _wParam$[ebp], 1
  044dd	0f 94 c0	 sete	 al
  044e0	89 45 f4	 mov	 DWORD PTR _fCalcValidRects$[ebp], eax

; 2679 : 	SCROLLBAR *sb;
; 2680 : 	LRESULT ret;
; 2681 : 	DWORD dwStyle;
; 2682 : 
; 2683 : 	//Regardless of the value of fCalcValidRects, the first rectangle 
; 2684 : 	//in the array specified by the rgrc structure member of the 
; 2685 : 	//NCCALCSIZE_PARAMS structure contains the coordinates of the window,
; 2686 : 	//so we can use the exact same code to modify this rectangle, when
; 2687 : 	//wParam is TRUE and when it is FALSE.
; 2688 : 	nccsp = (NCCALCSIZE_PARAMS *)lParam;

  044e3	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  044e6	89 4d f0	 mov	 DWORD PTR _nccsp$[ebp], ecx

; 2689 : 	rect = &nccsp->rgrc[0];

  044e9	8b 55 f0	 mov	 edx, DWORD PTR _nccsp$[ebp]
  044ec	89 55 fc	 mov	 DWORD PTR _rect$[ebp], edx

; 2690 : 	oldrect = *rect;

  044ef	8b 45 fc	 mov	 eax, DWORD PTR _rect$[ebp]
  044f2	8b 08		 mov	 ecx, DWORD PTR [eax]
  044f4	89 4d e0	 mov	 DWORD PTR _oldrect$[ebp], ecx
  044f7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  044fa	89 55 e4	 mov	 DWORD PTR _oldrect$[ebp+4], edx
  044fd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  04500	89 4d e8	 mov	 DWORD PTR _oldrect$[ebp+8], ecx
  04503	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  04506	89 55 ec	 mov	 DWORD PTR _oldrect$[ebp+12], edx

; 2691 : 
; 2692 : 	dwStyle = GetWindowLong(hwnd, GWL_STYLE);

  04509	6a f0		 push	 -16			; fffffff0H
  0450b	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0450e	50		 push	 eax
  0450f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  04515	89 45 dc	 mov	 DWORD PTR _dwStyle$[ebp], eax

; 2693 : 
; 2694 : 	// TURN OFF SCROLL-STYLES.
; 2695 :     if ( dwStyle & (WS_VSCROLL|WS_HSCROLL) )

  04518	8b 4d dc	 mov	 ecx, DWORD PTR _dwStyle$[ebp]
  0451b	81 e1 00 00 30
	00		 and	 ecx, 3145728		; 00300000H
  04521	74 22		 je	 SHORT $L23555

; 2696 :     {
; 2697 :         sw->bPreventStyleChange = TRUE;

  04523	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  04526	c7 82 bc 06 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+1724], 1

; 2698 :         SetWindowLong(hwnd, GWL_STYLE, dwStyle & ~(WS_VSCROLL|WS_HSCROLL));

  04530	8b 45 dc	 mov	 eax, DWORD PTR _dwStyle$[ebp]
  04533	25 ff ff cf ff	 and	 eax, -3145729		; ffcfffffH
  04538	50		 push	 eax
  04539	6a f0		 push	 -16			; fffffff0H
  0453b	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0453e	51		 push	 ecx
  0453f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12
$L23555:

; 2699 :     }
; 2700 : 	
; 2701 : 	//call the default procedure to get the borders allocated
; 2702 : 	ret = CallWindowProc(sw->oldproc, hwnd, WM_NCCALCSIZE, wParam, lParam);

  04545	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  04548	52		 push	 edx
  04549	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0454c	50		 push	 eax
  0454d	68 83 00 00 00	 push	 131			; 00000083H
  04552	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04555	51		 push	 ecx
  04556	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  04559	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0455c	50		 push	 eax
  0455d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  04563	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 2703 : 
; 2704 : 	// RESTORE PREVIOUS STYLES (if present at all)
; 2705 :     if ( dwStyle & (WS_VSCROLL|WS_HSCROLL) )

  04566	8b 4d dc	 mov	 ecx, DWORD PTR _dwStyle$[ebp]
  04569	81 e1 00 00 30
	00		 and	 ecx, 3145728		; 00300000H
  0456f	74 1d		 je	 SHORT $L23556

; 2706 :     {
; 2707 :         SetWindowLong(hwnd, GWL_STYLE, dwStyle);

  04571	8b 55 dc	 mov	 edx, DWORD PTR _dwStyle$[ebp]
  04574	52		 push	 edx
  04575	6a f0		 push	 -16			; fffffff0H
  04577	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0457a	50		 push	 eax
  0457b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 2708 :         sw->bPreventStyleChange = FALSE;

  04581	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  04584	c7 81 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1724], 0
$L23556:

; 2709 :     }
; 2710 : 
; 2711 : 	// calculate what the size of each window border is,
; 2712 : 	sw->cxLeftEdge   = rect->left     - oldrect.left;

  0458e	8b 55 fc	 mov	 edx, DWORD PTR _rect$[ebp]
  04591	8b 02		 mov	 eax, DWORD PTR [edx]
  04593	2b 45 e0	 sub	 eax, DWORD PTR _oldrect$[ebp]
  04596	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  04599	89 81 ac 06 00
	00		 mov	 DWORD PTR [ecx+1708], eax

; 2713 : 	sw->cxRightEdge  = oldrect.right  - rect->right;

  0459f	8b 55 fc	 mov	 edx, DWORD PTR _rect$[ebp]
  045a2	8b 45 e8	 mov	 eax, DWORD PTR _oldrect$[ebp+8]
  045a5	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  045a8	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  045ab	89 81 b0 06 00
	00		 mov	 DWORD PTR [ecx+1712], eax

; 2714 : 	sw->cyTopEdge    = rect->top      - oldrect.top;

  045b1	8b 55 fc	 mov	 edx, DWORD PTR _rect$[ebp]
  045b4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  045b7	2b 45 e4	 sub	 eax, DWORD PTR _oldrect$[ebp+4]
  045ba	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  045bd	89 81 b4 06 00
	00		 mov	 DWORD PTR [ecx+1716], eax

; 2715 : 	sw->cyBottomEdge = oldrect.bottom - rect->bottom;

  045c3	8b 55 fc	 mov	 edx, DWORD PTR _rect$[ebp]
  045c6	8b 45 ec	 mov	 eax, DWORD PTR _oldrect$[ebp+12]
  045c9	2b 42 0c	 sub	 eax, DWORD PTR [edx+12]
  045cc	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  045cf	89 81 b8 06 00
	00		 mov	 DWORD PTR [ecx+1720], eax

; 2716 : 
; 2717 : 	sb = &sw->sbarHorz;

  045d5	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  045d8	83 c2 08	 add	 edx, 8
  045db	89 55 f8	 mov	 DWORD PTR _sb$[ebp], edx

; 2718 : 
; 2719 : 	//if there is room, allocate some space for the horizontal scrollbar
; 2720 : 	//NOTE: Change the ">" to a ">=" to make the horz bar totally fill the
; 2721 : 	//window before disappearing
; 2722 : 	if((sb->fScrollFlags & CSBS_VISIBLE) && 
; 2723 : #ifdef COOLSB_FILLWINDOW
; 2724 : 		rect->bottom - rect->top >= GetScrollMetric(sb, SM_CYHORZSB))
; 2725 : #else
; 2726 : 		rect->bottom - rect->top > GetScrollMetric(sb, SM_CYHORZSB))

  045de	8b 45 f8	 mov	 eax, DWORD PTR _sb$[ebp]
  045e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  045e3	83 e1 08	 and	 ecx, 8
  045e6	74 46		 je	 SHORT $L23557
  045e8	8b 55 fc	 mov	 edx, DWORD PTR _rect$[ebp]
  045eb	8b 45 fc	 mov	 eax, DWORD PTR _rect$[ebp]
  045ee	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]
  045f1	2b 70 04	 sub	 esi, DWORD PTR [eax+4]
  045f4	6a 01		 push	 1
  045f6	8b 4d f8	 mov	 ecx, DWORD PTR _sb$[ebp]
  045f9	51		 push	 ecx
  045fa	e8 00 00 00 00	 call	 _GetScrollMetric
  045ff	83 c4 08	 add	 esp, 8
  04602	3b f0		 cmp	 esi, eax
  04604	7e 28		 jle	 SHORT $L23557

; 2727 : #endif
; 2728 : 	{
; 2729 : 		rect->bottom -= GetScrollMetric(sb, SM_CYHORZSB);

  04606	6a 01		 push	 1
  04608	8b 55 f8	 mov	 edx, DWORD PTR _sb$[ebp]
  0460b	52		 push	 edx
  0460c	e8 00 00 00 00	 call	 _GetScrollMetric
  04611	83 c4 08	 add	 esp, 8
  04614	8b 4d fc	 mov	 ecx, DWORD PTR _rect$[ebp]
  04617	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0461a	2b d0		 sub	 edx, eax
  0461c	8b 45 fc	 mov	 eax, DWORD PTR _rect$[ebp]
  0461f	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 2730 : 		sb->fScrollVisible = TRUE;

  04622	8b 4d f8	 mov	 ecx, DWORD PTR _sb$[ebp]
  04625	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 2731 : 	}
; 2732 : 	else

  0462c	eb 0a		 jmp	 SHORT $L23558
$L23557:

; 2733 : 		sb->fScrollVisible = FALSE;

  0462e	8b 55 f8	 mov	 edx, DWORD PTR _sb$[ebp]
  04631	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L23558:

; 2734 : 
; 2735 : 	sb = &sw->sbarVert;

  04638	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0463b	05 54 03 00 00	 add	 eax, 852		; 00000354H
  04640	89 45 f8	 mov	 DWORD PTR _sb$[ebp], eax

; 2736 : 
; 2737 : 	//if there is room, allocate some space for the vertical scrollbar
; 2738 : 	if((sb->fScrollFlags & CSBS_VISIBLE) && 
; 2739 : 		rect->right - rect->left >= GetScrollMetric(sb, SM_CXVERTSB))

  04643	8b 4d f8	 mov	 ecx, DWORD PTR _sb$[ebp]
  04646	8b 11		 mov	 edx, DWORD PTR [ecx]
  04648	83 e2 08	 and	 edx, 8
  0464b	74 6b		 je	 SHORT $L23559
  0464d	8b 45 fc	 mov	 eax, DWORD PTR _rect$[ebp]
  04650	8b 4d fc	 mov	 ecx, DWORD PTR _rect$[ebp]
  04653	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  04656	2b 31		 sub	 esi, DWORD PTR [ecx]
  04658	6a 01		 push	 1
  0465a	8b 55 f8	 mov	 edx, DWORD PTR _sb$[ebp]
  0465d	52		 push	 edx
  0465e	e8 00 00 00 00	 call	 _GetScrollMetric
  04663	83 c4 08	 add	 esp, 8
  04666	3b f0		 cmp	 esi, eax
  04668	7c 4e		 jl	 SHORT $L23559

; 2740 : 	{
; 2741 : 		if(sw->fLeftScrollbar)

  0466a	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0466d	83 b8 a4 06 00
	00 00		 cmp	 DWORD PTR [eax+1700], 0
  04674	74 1a		 je	 SHORT $L23560

; 2742 : 			rect->left  += GetScrollMetric(sb, SM_CXVERTSB);

  04676	6a 01		 push	 1
  04678	8b 4d f8	 mov	 ecx, DWORD PTR _sb$[ebp]
  0467b	51		 push	 ecx
  0467c	e8 00 00 00 00	 call	 _GetScrollMetric
  04681	83 c4 08	 add	 esp, 8
  04684	8b 55 fc	 mov	 edx, DWORD PTR _rect$[ebp]
  04687	03 02		 add	 eax, DWORD PTR [edx]
  04689	8b 4d fc	 mov	 ecx, DWORD PTR _rect$[ebp]
  0468c	89 01		 mov	 DWORD PTR [ecx], eax

; 2743 : 		else

  0468e	eb 1c		 jmp	 SHORT $L23561
$L23560:

; 2744 : 			rect->right -= GetScrollMetric(sb, SM_CXVERTSB);

  04690	6a 01		 push	 1
  04692	8b 55 f8	 mov	 edx, DWORD PTR _sb$[ebp]
  04695	52		 push	 edx
  04696	e8 00 00 00 00	 call	 _GetScrollMetric
  0469b	83 c4 08	 add	 esp, 8
  0469e	8b 4d fc	 mov	 ecx, DWORD PTR _rect$[ebp]
  046a1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  046a4	2b d0		 sub	 edx, eax
  046a6	8b 45 fc	 mov	 eax, DWORD PTR _rect$[ebp]
  046a9	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L23561:

; 2745 : 
; 2746 : 		sb->fScrollVisible = TRUE;

  046ac	8b 4d f8	 mov	 ecx, DWORD PTR _sb$[ebp]
  046af	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 2747 : 	}
; 2748 : 	else

  046b6	eb 0a		 jmp	 SHORT $L23562
$L23559:

; 2749 : 		sb->fScrollVisible = FALSE;

  046b8	8b 55 f8	 mov	 edx, DWORD PTR _sb$[ebp]
  046bb	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L23562:

; 2750 : 
; 2751 : #ifdef INCLUDE_BUTTONS
; 2752 : #ifdef RESIZABLE_BUTTONS
; 2753 : 	ResizeButtonsToFit(sw, &sw->sbarHorz, hwnd);

  046c2	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  046c5	50		 push	 eax
  046c6	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  046c9	83 c1 08	 add	 ecx, 8
  046cc	51		 push	 ecx
  046cd	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  046d0	52		 push	 edx
  046d1	e8 00 00 00 00	 call	 _ResizeButtonsToFit
  046d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2754 : 	ResizeButtonsToFit(sw, &sw->sbarVert, hwnd);

  046d9	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  046dc	50		 push	 eax
  046dd	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  046e0	81 c1 54 03 00
	00		 add	 ecx, 852		; 00000354H
  046e6	51		 push	 ecx
  046e7	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  046ea	52		 push	 edx
  046eb	e8 00 00 00 00	 call	 _ResizeButtonsToFit
  046f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2755 : #endif
; 2756 : #endif
; 2757 : 
; 2758 : 	//don't return a value unless we actually modify the other rectangles
; 2759 : 	//in the NCCALCSIZE_PARAMS structure. In this case, we return 0
; 2760 : 	//no matter what the value of fCalcValidRects is
; 2761 : 	return ret;//FALSE;

  046f3	8b 45 d8	 mov	 eax, DWORD PTR _ret$[ebp]

; 2762 : }

  046f6	5e		 pop	 esi
  046f7	8b e5		 mov	 esp, ebp
  046f9	5d		 pop	 ebp
  046fa	c3		 ret	 0
_NCCalcSize ENDP
; Function compile flags: /Odt
_oldsize$23531 = -40					; size = 4
_scrollsize$ = -36					; size = 4
_butsize1$ = -32					; size = 4
_butsize2$ = -28					; size = 4
_i$ = -24						; size = 4
_rc$ = -20						; size = 16
_sbut$ = -4						; size = 4
_sw$ = 8						; size = 4
_sbar$ = 12						; size = 4
_hwnd$ = 16						; size = 4
_ResizeButtonsToFit PROC NEAR

; 2608 : {

  04700	55		 push	 ebp
  04701	8b ec		 mov	 ebp, esp
  04703	83 ec 28	 sub	 esp, 40			; 00000028H

; 2609 : 	int butsize1, butsize2;
; 2610 : 	RECT rc;
; 2611 : 	int scrollsize;
; 2612 : 	int i;
; 2613 : 	SCROLLBUT *sbut;
; 2614 : 
; 2615 : 	//make sure that the scrollbar can fit into space, by
; 2616 : 	//shrinking any resizable buttons
; 2617 : 	GetScrollRect(sw, sbar->nBarType, hwnd, &rc);

  04706	8d 45 ec	 lea	 eax, DWORD PTR _rc$[ebp]
  04709	50		 push	 eax
  0470a	8b 4d 10	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0470d	51		 push	 ecx
  0470e	8b 55 0c	 mov	 edx, DWORD PTR _sbar$[ebp]
  04711	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  04717	50		 push	 eax
  04718	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0471b	51		 push	 ecx
  0471c	e8 00 00 00 00	 call	 _GetScrollRect
  04721	83 c4 10	 add	 esp, 16			; 00000010H

; 2618 : 
; 2619 : 	if(sbar->nBarType == SB_HORZ)

  04724	8b 55 0c	 mov	 edx, DWORD PTR _sbar$[ebp]
  04727	83 ba 40 03 00
	00 00		 cmp	 DWORD PTR [edx+832], 0
  0472e	75 0b		 jne	 SHORT $L23520

; 2620 : 		scrollsize = rc.right-rc.left;

  04730	8b 45 f4	 mov	 eax, DWORD PTR _rc$[ebp+8]
  04733	2b 45 ec	 sub	 eax, DWORD PTR _rc$[ebp]
  04736	89 45 dc	 mov	 DWORD PTR _scrollsize$[ebp], eax

; 2621 : 	else

  04739	eb 09		 jmp	 SHORT $L23521
$L23520:

; 2622 : 		scrollsize = rc.bottom-rc.top;

  0473b	8b 4d f8	 mov	 ecx, DWORD PTR _rc$[ebp+12]
  0473e	2b 4d f0	 sub	 ecx, DWORD PTR _rc$[ebp+4]
  04741	89 4d dc	 mov	 DWORD PTR _scrollsize$[ebp], ecx
$L23521:

; 2623 : 
; 2624 : 	//restore any resizable buttons to their user-defined sizes,
; 2625 : 	//before shrinking them to fit. This means when we make the window
; 2626 : 	//bigger, the buttons will restore to their initial sizes
; 2627 : 	for(i = 0; i < sbar->nButtons; i++)

  04744	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0474b	eb 09		 jmp	 SHORT $L23522
$L23523:
  0474d	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  04750	83 c2 01	 add	 edx, 1
  04753	89 55 e8	 mov	 DWORD PTR _i$[ebp], edx
$L23522:
  04756	8b 45 0c	 mov	 eax, DWORD PTR _sbar$[ebp]
  04759	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  0475c	3b 88 2c 03 00
	00		 cmp	 ecx, DWORD PTR [eax+812]
  04762	7d 2b		 jge	 SHORT $L23524

; 2628 : 	{
; 2629 : 		sbut = &sbar->sbButtons[i];

  04764	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  04767	6b d2 30	 imul	 edx, 48			; 00000030H
  0476a	8b 45 0c	 mov	 eax, DWORD PTR _sbar$[ebp]
  0476d	8d 4c 10 2c	 lea	 ecx, DWORD PTR [eax+edx+44]
  04771	89 4d fc	 mov	 DWORD PTR _sbut$[ebp], ecx

; 2630 : 		if(sbut->uButType & SBBM_RESIZABLE)

  04774	8b 55 fc	 mov	 edx, DWORD PTR _sbut$[ebp]
  04777	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0477a	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0477f	74 0c		 je	 SHORT $L23525

; 2631 : 		{
; 2632 : 			sbut->nSize = sbut->nSizeReserved;

  04781	8b 4d fc	 mov	 ecx, DWORD PTR _sbut$[ebp]
  04784	8b 55 fc	 mov	 edx, DWORD PTR _sbut$[ebp]
  04787	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0478a	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L23525:

; 2633 : 		}
; 2634 : 	}

  0478d	eb be		 jmp	 SHORT $L23523
$L23524:

; 2635 : 	
; 2636 : 	butsize1 = GetButtonSize(sbar, hwnd, SBBP_LEFT);

  0478f	6a 01		 push	 1
  04791	8b 4d 10	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04794	51		 push	 ecx
  04795	8b 55 0c	 mov	 edx, DWORD PTR _sbar$[ebp]
  04798	52		 push	 edx
  04799	e8 00 00 00 00	 call	 _GetButtonSize
  0479e	83 c4 0c	 add	 esp, 12			; 0000000cH
  047a1	89 45 e0	 mov	 DWORD PTR _butsize1$[ebp], eax

; 2637 : 	butsize2 = GetButtonSize(sbar, hwnd, SBBP_RIGHT);

  047a4	6a 02		 push	 2
  047a6	8b 45 10	 mov	 eax, DWORD PTR _hwnd$[ebp]
  047a9	50		 push	 eax
  047aa	8b 4d 0c	 mov	 ecx, DWORD PTR _sbar$[ebp]
  047ad	51		 push	 ecx
  047ae	e8 00 00 00 00	 call	 _GetButtonSize
  047b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  047b6	89 45 e4	 mov	 DWORD PTR _butsize2$[ebp], eax

; 2638 : 
; 2639 : 	if(butsize1 + butsize2 > scrollsize - MINSCROLLSIZE)

  047b9	8b 55 e0	 mov	 edx, DWORD PTR _butsize1$[ebp]
  047bc	03 55 e4	 add	 edx, DWORD PTR _butsize2$[ebp]
  047bf	8b 45 dc	 mov	 eax, DWORD PTR _scrollsize$[ebp]
  047c2	83 e8 32	 sub	 eax, 50			; 00000032H
  047c5	3b d0		 cmp	 edx, eax
  047c7	0f 8e c3 00 00
	00		 jle	 $L23513

; 2640 : 	{
; 2641 : 		i = 0;

  047cd	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$L23528:

; 2642 : 		while(i < sbar->nButtons && 
; 2643 : 			butsize1 + butsize2 > scrollsize - MINSCROLLSIZE)

  047d4	8b 4d 0c	 mov	 ecx, DWORD PTR _sbar$[ebp]
  047d7	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  047da	3b 91 2c 03 00
	00		 cmp	 edx, DWORD PTR [ecx+812]
  047e0	0f 8d aa 00 00
	00		 jge	 $L23513
  047e6	8b 45 e0	 mov	 eax, DWORD PTR _butsize1$[ebp]
  047e9	03 45 e4	 add	 eax, DWORD PTR _butsize2$[ebp]
  047ec	8b 4d dc	 mov	 ecx, DWORD PTR _scrollsize$[ebp]
  047ef	83 e9 32	 sub	 ecx, 50			; 00000032H
  047f2	3b c1		 cmp	 eax, ecx
  047f4	0f 8e 96 00 00
	00		 jle	 $L23513

; 2644 : 		{
; 2645 : 			sbut = &sbar->sbButtons[i++];

  047fa	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  047fd	6b d2 30	 imul	 edx, 48			; 00000030H
  04800	8b 45 0c	 mov	 eax, DWORD PTR _sbar$[ebp]
  04803	8d 4c 10 2c	 lea	 ecx, DWORD PTR [eax+edx+44]
  04807	89 4d fc	 mov	 DWORD PTR _sbut$[ebp], ecx
  0480a	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  0480d	83 c2 01	 add	 edx, 1
  04810	89 55 e8	 mov	 DWORD PTR _i$[ebp], edx

; 2646 : 			if(sbut->uButType & SBBM_RESIZABLE)

  04813	8b 45 fc	 mov	 eax, DWORD PTR _sbut$[ebp]
  04816	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  04819	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  0481f	74 6a		 je	 SHORT $L23530

; 2647 : 			{
; 2648 : 				int oldsize = sbut->nSize;

  04821	8b 55 fc	 mov	 edx, DWORD PTR _sbut$[ebp]
  04824	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  04827	89 45 d8	 mov	 DWORD PTR _oldsize$23531[ebp], eax

; 2649 : 				sbut->nSize -= (butsize1+butsize2) - (scrollsize-MINSCROLLSIZE);

  0482a	8b 4d e0	 mov	 ecx, DWORD PTR _butsize1$[ebp]
  0482d	03 4d e4	 add	 ecx, DWORD PTR _butsize2$[ebp]
  04830	8b 55 dc	 mov	 edx, DWORD PTR _scrollsize$[ebp]
  04833	83 ea 32	 sub	 edx, 50			; 00000032H
  04836	2b ca		 sub	 ecx, edx
  04838	8b 45 fc	 mov	 eax, DWORD PTR _sbut$[ebp]
  0483b	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0483e	2b d1		 sub	 edx, ecx
  04840	8b 45 fc	 mov	 eax, DWORD PTR _sbut$[ebp]
  04843	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2650 : 
; 2651 : 				if(sbut->nSize < (int)sbut->nMinSize)

  04846	8b 4d fc	 mov	 ecx, DWORD PTR _sbut$[ebp]
  04849	8b 55 fc	 mov	 edx, DWORD PTR _sbut$[ebp]
  0484c	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0484f	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  04852	7d 0c		 jge	 SHORT $L23533

; 2652 : 					sbut->nSize = sbut->nMinSize;

  04854	8b 4d fc	 mov	 ecx, DWORD PTR _sbut$[ebp]
  04857	8b 55 fc	 mov	 edx, DWORD PTR _sbut$[ebp]
  0485a	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0485d	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L23533:

; 2653 : 
; 2654 : 				if((UINT)sbut->nSize > (UINT)sbut->nMaxSize)

  04860	8b 4d fc	 mov	 ecx, DWORD PTR _sbut$[ebp]
  04863	8b 55 fc	 mov	 edx, DWORD PTR _sbut$[ebp]
  04866	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  04869	3b 42 2c	 cmp	 eax, DWORD PTR [edx+44]
  0486c	76 0c		 jbe	 SHORT $L23536

; 2655 : 					sbut->nSize = sbut->nMaxSize;

  0486e	8b 4d fc	 mov	 ecx, DWORD PTR _sbut$[ebp]
  04871	8b 55 fc	 mov	 edx, DWORD PTR _sbut$[ebp]
  04874	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  04877	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L23536:

; 2656 : 
; 2657 : 				
; 2658 : 				butsize1 -= (oldsize - sbut->nSize);

  0487a	8b 4d fc	 mov	 ecx, DWORD PTR _sbut$[ebp]
  0487d	8b 55 d8	 mov	 edx, DWORD PTR _oldsize$23531[ebp]
  04880	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  04883	8b 45 e0	 mov	 eax, DWORD PTR _butsize1$[ebp]
  04886	2b c2		 sub	 eax, edx
  04888	89 45 e0	 mov	 DWORD PTR _butsize1$[ebp], eax
$L23530:

; 2659 : 			}
; 2660 : 		}

  0488b	e9 44 ff ff ff	 jmp	 $L23528
$L23513:

; 2661 : 	}
; 2662 : 
; 2663 : }

  04890	8b e5		 mov	 esp, ebp
  04892	5d		 pop	 ebp
  04893	c3		 ret	 0
_ResizeButtonsToFit ENDP
_TEXT	ENDS
_BSS	SEGMENT
_MouseOverRect DB 010H DUP (?)
; Function compile flags: /Odt
_BSS	ENDS
_TEXT	SEGMENT
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wHitTest$ = 16						; size = 4
_lParam$ = 20						; size = 4
_NCMouseMove PROC NEAR

; 2768 : {

  048a0	55		 push	 ebp
  048a1	8b ec		 mov	 ebp, esp

; 2769 : 	//install a timer for the mouse-over events, if the mouse moves
; 2770 : 	//over one of the scrollbars
; 2771 : #ifdef HOT_TRACKING
; 2772 : 	hwndCurCoolSB = hwnd;

  048a3	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  048a6	a3 00 00 00 00	 mov	 DWORD PTR _hwndCurCoolSB, eax

; 2773 : 	if(wHitTest == HTHSCROLL)

  048ab	83 7d 10 06	 cmp	 DWORD PTR _wHitTest$[ebp], 6
  048af	0f 85 8f 00 00
	00		 jne	 $L23573

; 2774 : 	{
; 2775 : 		if(uMouseOverScrollbar == SB_HORZ)

  048b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uMouseOverScrollbar, 0
  048bc	75 23		 jne	 SHORT $L23574

; 2776 : 			return CallWindowProc(sw->oldproc, hwnd, WM_NCMOUSEMOVE, wHitTest, lParam);

  048be	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  048c1	51		 push	 ecx
  048c2	8b 55 10	 mov	 edx, DWORD PTR _wHitTest$[ebp]
  048c5	52		 push	 edx
  048c6	68 a0 00 00 00	 push	 160			; 000000a0H
  048cb	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  048ce	50		 push	 eax
  048cf	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  048d2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  048d5	52		 push	 edx
  048d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  048dc	e9 12 01 00 00	 jmp	 $L23572
$L23574:

; 2777 : 
; 2778 : 		uLastHitTestPortion = HTSCROLL_NONE;

  048e1	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uLastHitTestPortion, -1

; 2779 : 		uHitTestPortion     = HTSCROLL_NONE;

  048eb	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uHitTestPortion, -1

; 2780 : 		GetScrollRect(sw, SB_HORZ, hwnd, &MouseOverRect);

  048f5	68 00 00 00 00	 push	 OFFSET FLAT:_MouseOverRect
  048fa	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  048fd	50		 push	 eax
  048fe	6a 00		 push	 0
  04900	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  04903	51		 push	 ecx
  04904	e8 00 00 00 00	 call	 _GetScrollRect
  04909	83 c4 10	 add	 esp, 16			; 00000010H

; 2781 : 		uMouseOverScrollbar = SB_HORZ;

  0490c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uMouseOverScrollbar, 0

; 2782 : #pragma warning( disable: 4244)		
; 2783 : 		uMouseOverId = SetTimer(hwnd, COOLSB_TIMERID3, COOLSB_TIMERINTERVAL3, 0);

  04916	6a 00		 push	 0
  04918	6a 14		 push	 20			; 00000014H
  0491a	6a f2		 push	 -14			; fffffff2H
  0491c	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0491f	52		 push	 edx
  04920	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
  04926	a3 00 00 00 00	 mov	 DWORD PTR _uMouseOverId, eax

; 2784 : 	
; 2785 : 		NCPaint(sw, hwnd, 1, 0);

  0492b	6a 00		 push	 0
  0492d	6a 01		 push	 1
  0492f	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04932	50		 push	 eax
  04933	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  04936	51		 push	 ecx
  04937	e8 00 00 00 00	 call	 _NCPaint
  0493c	83 c4 10	 add	 esp, 16			; 00000010H

; 2786 : 	}
; 2787 : 	else if(wHitTest == HTVSCROLL)

  0493f	e9 91 00 00 00	 jmp	 $L23575
$L23573:
  04944	83 7d 10 07	 cmp	 DWORD PTR _wHitTest$[ebp], 7
  04948	0f 85 87 00 00
	00		 jne	 $L23575

; 2788 : 	{
; 2789 : 		if(uMouseOverScrollbar == SB_VERT)

  0494e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uMouseOverScrollbar, 1
  04955	75 20		 jne	 SHORT $L23577

; 2790 : 			return CallWindowProc(sw->oldproc, hwnd, WM_NCMOUSEMOVE, wHitTest, lParam);

  04957	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  0495a	52		 push	 edx
  0495b	8b 45 10	 mov	 eax, DWORD PTR _wHitTest$[ebp]
  0495e	50		 push	 eax
  0495f	68 a0 00 00 00	 push	 160			; 000000a0H
  04964	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04967	51		 push	 ecx
  04968	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0496b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0496e	50		 push	 eax
  0496f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  04975	eb 7c		 jmp	 SHORT $L23572
$L23577:

; 2791 : 
; 2792 : 		uLastHitTestPortion = HTSCROLL_NONE;

  04977	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uLastHitTestPortion, -1

; 2793 : 		uHitTestPortion     = HTSCROLL_NONE;

  04981	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uHitTestPortion, -1

; 2794 : 		GetScrollRect(sw, SB_VERT, hwnd, &MouseOverRect);

  0498b	68 00 00 00 00	 push	 OFFSET FLAT:_MouseOverRect
  04990	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04993	51		 push	 ecx
  04994	6a 01		 push	 1
  04996	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  04999	52		 push	 edx
  0499a	e8 00 00 00 00	 call	 _GetScrollRect
  0499f	83 c4 10	 add	 esp, 16			; 00000010H

; 2795 : 		uMouseOverScrollbar = SB_VERT;

  049a2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _uMouseOverScrollbar, 1

; 2796 : 		uMouseOverId = SetTimer(hwnd, COOLSB_TIMERID3, COOLSB_TIMERINTERVAL3, 0);

  049ac	6a 00		 push	 0
  049ae	6a 14		 push	 20			; 00000014H
  049b0	6a f2		 push	 -14			; fffffff2H
  049b2	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  049b5	50		 push	 eax
  049b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
  049bc	a3 00 00 00 00	 mov	 DWORD PTR _uMouseOverId, eax

; 2797 : #pragma warning( default: 4244)	
; 2798 : 		NCPaint(sw, hwnd, 1, 0);

  049c1	6a 00		 push	 0
  049c3	6a 01		 push	 1
  049c5	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  049c8	51		 push	 ecx
  049c9	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  049cc	52		 push	 edx
  049cd	e8 00 00 00 00	 call	 _NCPaint
  049d2	83 c4 10	 add	 esp, 16			; 00000010H
$L23575:

; 2799 : 	}
; 2800 : 
; 2801 : #endif //HOT_TRACKING
; 2802 : 	return CallWindowProc(sw->oldproc, hwnd, WM_NCMOUSEMOVE, wHitTest, lParam);

  049d5	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  049d8	50		 push	 eax
  049d9	8b 4d 10	 mov	 ecx, DWORD PTR _wHitTest$[ebp]
  049dc	51		 push	 ecx
  049dd	68 a0 00 00 00	 push	 160			; 000000a0H
  049e2	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  049e5	52		 push	 edx
  049e6	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  049e9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  049ec	51		 push	 ecx
  049ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
$L23572:

; 2803 : }

  049f3	5d		 pop	 ebp
  049f4	c3		 ret	 0
_NCMouseMove ENDP
_TEXT	ENDS
EXTRN	__imp__GetCursorPos@4:NEAR
EXTRN	__imp__ScreenToClient@8:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_pt$23604 = -56						; size = 8
_hdc$23593 = -48					; size = 4
_pt$23590 = -44						; size = 8
_winrect$23592 = -36					; size = 16
_rect$23591 = -20					; size = 16
_sbar$23594 = -4					; size = 4
_swnd$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wTimerId$ = 16						; size = 4
_lParam$ = 20						; size = 4
_CoolSB_Timer PROC NEAR

; 2809 : {

  04a00	55		 push	 ebp
  04a01	8b ec		 mov	 ebp, esp
  04a03	83 ec 38	 sub	 esp, 56			; 00000038H

; 2810 : 	//let all timer messages go past if we don't have a timer installed ourselves
; 2811 : 	if(uScrollTimerId == 0 && uMouseOverId == 0)

  04a06	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uScrollTimerId, 0
  04a0d	75 2c		 jne	 SHORT $L23588
  04a0f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uMouseOverId, 0
  04a16	75 23		 jne	 SHORT $L23588

; 2812 : 	{
; 2813 : 		return CallWindowProc(swnd->oldproc, hwnd, WM_TIMER, wTimerId, lParam);

  04a18	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  04a1b	50		 push	 eax
  04a1c	8b 4d 10	 mov	 ecx, DWORD PTR _wTimerId$[ebp]
  04a1f	51		 push	 ecx
  04a20	68 13 01 00 00	 push	 275			; 00000113H
  04a25	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04a28	52		 push	 edx
  04a29	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  04a2c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  04a2f	51		 push	 ecx
  04a30	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  04a36	e9 70 02 00 00	 jmp	 $L23587
$L23588:

; 2814 : 	}
; 2815 : 
; 2816 : #ifdef HOT_TRACKING
; 2817 : 	//mouse-over timer
; 2818 : 	if(wTimerId == COOLSB_TIMERID3)

  04a3b	83 7d 10 f2	 cmp	 DWORD PTR _wTimerId$[ebp], -14 ; fffffff2H
  04a3f	0f 85 96 01 00
	00		 jne	 $L23589

; 2819 : 	{
; 2820 : 		POINT pt;
; 2821 : 		RECT rect, winrect;
; 2822 : 		HDC hdc;
; 2823 : 		SCROLLBAR *sbar;
; 2824 : 
; 2825 : 		if(swnd->fThumbTracking)

  04a45	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  04a48	83 ba a0 06 00
	00 00		 cmp	 DWORD PTR [edx+1696], 0
  04a4f	74 07		 je	 SHORT $L23595

; 2826 : 			return 0;

  04a51	33 c0		 xor	 eax, eax
  04a53	e9 53 02 00 00	 jmp	 $L23587
$L23595:

; 2827 : 
; 2828 : 		//if the mouse moves outside the current scrollbar,
; 2829 : 		//then kill the timer..
; 2830 : 		GetCursorPos(&pt);

  04a58	8d 45 d4	 lea	 eax, DWORD PTR _pt$23590[ebp]
  04a5b	50		 push	 eax
  04a5c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4

; 2831 : 
; 2832 : 		if(!PtInRect(&MouseOverRect, pt))

  04a62	8b 4d d8	 mov	 ecx, DWORD PTR _pt$23590[ebp+4]
  04a65	51		 push	 ecx
  04a66	8b 55 d4	 mov	 edx, DWORD PTR _pt$23590[ebp]
  04a69	52		 push	 edx
  04a6a	68 00 00 00 00	 push	 OFFSET FLAT:_MouseOverRect
  04a6f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  04a75	85 c0		 test	 eax, eax
  04a77	75 51		 jne	 SHORT $L23596

; 2833 : 		{
; 2834 : 			KillTimer(hwnd, uMouseOverId);

  04a79	a1 00 00 00 00	 mov	 eax, DWORD PTR _uMouseOverId
  04a7e	50		 push	 eax
  04a7f	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04a82	51		 push	 ecx
  04a83	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 2835 : 			uMouseOverId = 0;

  04a89	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uMouseOverId, 0

; 2836 : 			uMouseOverScrollbar = COOLSB_NONE;

  04a93	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uMouseOverScrollbar, -1

; 2837 : 			uLastHitTestPortion = HTSCROLL_NONE;

  04a9d	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uLastHitTestPortion, -1

; 2838 : 
; 2839 : 			uHitTestPortion = HTSCROLL_NONE;

  04aa7	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uHitTestPortion, -1

; 2840 : 			NCPaint(swnd, hwnd, 1, 0);

  04ab1	6a 00		 push	 0
  04ab3	6a 01		 push	 1
  04ab5	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04ab8	52		 push	 edx
  04ab9	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  04abc	50		 push	 eax
  04abd	e8 00 00 00 00	 call	 _NCPaint
  04ac2	83 c4 10	 add	 esp, 16			; 00000010H

; 2841 : 		}
; 2842 : 		else

  04ac5	e9 0a 01 00 00	 jmp	 $L23597
$L23596:

; 2843 : 		{
; 2844 : 			if(uMouseOverScrollbar == SB_HORZ)

  04aca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uMouseOverScrollbar, 0
  04ad1	75 2d		 jne	 SHORT $L23598

; 2845 : 			{
; 2846 : 				sbar = &swnd->sbarHorz;

  04ad3	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  04ad6	83 c1 08	 add	 ecx, 8
  04ad9	89 4d fc	 mov	 DWORD PTR _sbar$23594[ebp], ecx

; 2847 : 				uHitTestPortion = GetHorzPortion(sbar, hwnd, &MouseOverRect, pt.x, pt.y);

  04adc	8b 55 d8	 mov	 edx, DWORD PTR _pt$23590[ebp+4]
  04adf	52		 push	 edx
  04ae0	8b 45 d4	 mov	 eax, DWORD PTR _pt$23590[ebp]
  04ae3	50		 push	 eax
  04ae4	68 00 00 00 00	 push	 OFFSET FLAT:_MouseOverRect
  04ae9	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04aec	51		 push	 ecx
  04aed	8b 55 fc	 mov	 edx, DWORD PTR _sbar$23594[ebp]
  04af0	52		 push	 edx
  04af1	e8 00 00 00 00	 call	 _GetHorzPortion
  04af6	83 c4 14	 add	 esp, 20			; 00000014H
  04af9	a3 00 00 00 00	 mov	 DWORD PTR _uHitTestPortion, eax

; 2848 : 			}
; 2849 : 			else

  04afe	eb 2d		 jmp	 SHORT $L23599
$L23598:

; 2850 : 			{
; 2851 : 				sbar = &swnd->sbarVert;

  04b00	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  04b03	05 54 03 00 00	 add	 eax, 852		; 00000354H
  04b08	89 45 fc	 mov	 DWORD PTR _sbar$23594[ebp], eax

; 2852 : 				uHitTestPortion = GetVertPortion(sbar, hwnd, &MouseOverRect, pt.x, pt.y);

  04b0b	8b 4d d8	 mov	 ecx, DWORD PTR _pt$23590[ebp+4]
  04b0e	51		 push	 ecx
  04b0f	8b 55 d4	 mov	 edx, DWORD PTR _pt$23590[ebp]
  04b12	52		 push	 edx
  04b13	68 00 00 00 00	 push	 OFFSET FLAT:_MouseOverRect
  04b18	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04b1b	50		 push	 eax
  04b1c	8b 4d fc	 mov	 ecx, DWORD PTR _sbar$23594[ebp]
  04b1f	51		 push	 ecx
  04b20	e8 00 00 00 00	 call	 _GetVertPortion
  04b25	83 c4 14	 add	 esp, 20			; 00000014H
  04b28	a3 00 00 00 00	 mov	 DWORD PTR _uHitTestPortion, eax
$L23599:

; 2853 : 			}
; 2854 : 
; 2855 : 			if(uLastHitTestPortion != uHitTestPortion)

  04b2d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uLastHitTestPortion
  04b33	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _uHitTestPortion
  04b39	0f 84 8b 00 00
	00		 je	 $L23600

; 2856 : 			{
; 2857 : 				rect = MouseOverRect;

  04b3f	a1 00 00 00 00	 mov	 eax, DWORD PTR _MouseOverRect
  04b44	89 45 ec	 mov	 DWORD PTR _rect$23591[ebp], eax
  04b47	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _MouseOverRect+4
  04b4d	89 4d f0	 mov	 DWORD PTR _rect$23591[ebp+4], ecx
  04b50	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _MouseOverRect+8
  04b56	89 55 f4	 mov	 DWORD PTR _rect$23591[ebp+8], edx
  04b59	a1 0c 00 00 00	 mov	 eax, DWORD PTR _MouseOverRect+12
  04b5e	89 45 f8	 mov	 DWORD PTR _rect$23591[ebp+12], eax

; 2858 : 				GetRealScrollRect(sbar, &rect);

  04b61	8d 4d ec	 lea	 ecx, DWORD PTR _rect$23591[ebp]
  04b64	51		 push	 ecx
  04b65	8b 55 fc	 mov	 edx, DWORD PTR _sbar$23594[ebp]
  04b68	52		 push	 edx
  04b69	e8 00 00 00 00	 call	 _GetRealScrollRect
  04b6e	83 c4 08	 add	 esp, 8

; 2859 : 
; 2860 : 				GetWindowRect(hwnd, &winrect);

  04b71	8d 45 dc	 lea	 eax, DWORD PTR _winrect$23592[ebp]
  04b74	50		 push	 eax
  04b75	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04b78	51		 push	 ecx
  04b79	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 2861 : 				OffsetRect(&rect, -winrect.left, -winrect.top);

  04b7f	8b 55 e0	 mov	 edx, DWORD PTR _winrect$23592[ebp+4]
  04b82	f7 da		 neg	 edx
  04b84	52		 push	 edx
  04b85	8b 45 dc	 mov	 eax, DWORD PTR _winrect$23592[ebp]
  04b88	f7 d8		 neg	 eax
  04b8a	50		 push	 eax
  04b8b	8d 4d ec	 lea	 ecx, DWORD PTR _rect$23591[ebp]
  04b8e	51		 push	 ecx
  04b8f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 2862 : 
; 2863 : 				hdc = GetWindowDC(hwnd);

  04b95	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04b98	52		 push	 edx
  04b99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  04b9f	89 45 d0	 mov	 DWORD PTR _hdc$23593[ebp], eax

; 2864 : 				NCDrawScrollbar(sbar, hwnd, hdc, &rect, HTSCROLL_NONE);

  04ba2	6a ff		 push	 -1
  04ba4	8d 45 ec	 lea	 eax, DWORD PTR _rect$23591[ebp]
  04ba7	50		 push	 eax
  04ba8	8b 4d d0	 mov	 ecx, DWORD PTR _hdc$23593[ebp]
  04bab	51		 push	 ecx
  04bac	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04baf	52		 push	 edx
  04bb0	8b 45 fc	 mov	 eax, DWORD PTR _sbar$23594[ebp]
  04bb3	50		 push	 eax
  04bb4	e8 00 00 00 00	 call	 _NCDrawScrollbar
  04bb9	83 c4 14	 add	 esp, 20			; 00000014H

; 2865 : 				ReleaseDC(hwnd, hdc);

  04bbc	8b 4d d0	 mov	 ecx, DWORD PTR _hdc$23593[ebp]
  04bbf	51		 push	 ecx
  04bc0	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04bc3	52		 push	 edx
  04bc4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
$L23600:

; 2866 : 			}
; 2867 : 			
; 2868 : 			uLastHitTestPortion = uHitTestPortion;

  04bca	a1 00 00 00 00	 mov	 eax, DWORD PTR _uHitTestPortion
  04bcf	a3 00 00 00 00	 mov	 DWORD PTR _uLastHitTestPortion, eax
$L23597:

; 2869 : 		}
; 2870 : 
; 2871 : 		return 0;

  04bd4	33 c0		 xor	 eax, eax
  04bd6	e9 d0 00 00 00	 jmp	 $L23587
$L23589:

; 2872 : 	}
; 2873 : #endif // HOT_TRACKING
; 2874 : 
; 2875 : 	//if the first timer goes off, then we can start a more
; 2876 : 	//regular timer interval to auto-generate scroll messages
; 2877 : 	//this gives a slight pause between first pressing the scroll arrow, and the
; 2878 : 	//actual scroll starting
; 2879 : 	if(wTimerId == COOLSB_TIMERID1)

  04bdb	81 7d 10 fd ff
	00 00		 cmp	 DWORD PTR _wTimerId$[ebp], 65533 ; 0000fffdH
  04be2	75 30		 jne	 SHORT $L23601

; 2880 : 	{
; 2881 : 		KillTimer(hwnd, uScrollTimerId);

  04be4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uScrollTimerId
  04bea	51		 push	 ecx
  04beb	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04bee	52		 push	 edx
  04bef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 2882 : #pragma warning( disable: 4244)	
; 2883 : 		uScrollTimerId = SetTimer(hwnd, COOLSB_TIMERID2, COOLSB_TIMERINTERVAL2, 0);

  04bf5	6a 00		 push	 0
  04bf7	6a 37		 push	 55			; 00000037H
  04bf9	68 fe ff 00 00	 push	 65534			; 0000fffeH
  04bfe	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04c01	50		 push	 eax
  04c02	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
  04c08	a3 00 00 00 00	 mov	 DWORD PTR _uScrollTimerId, eax

; 2884 : #pragma warning( default: 4244)	
; 2885 : 		return 0;

  04c0d	33 c0		 xor	 eax, eax
  04c0f	e9 97 00 00 00	 jmp	 $L23587
$L23601:

; 2886 : 	}
; 2887 : 	//send the scrollbar message repeatedly
; 2888 : 	else if(wTimerId == COOLSB_TIMERID2)

  04c14	81 7d 10 fe ff
	00 00		 cmp	 DWORD PTR _wTimerId$[ebp], 65534 ; 0000fffeH
  04c1b	75 70		 jne	 SHORT $L23603

; 2889 : 	{
; 2890 : 		//need to process a spoof WM_MOUSEMOVE, so that
; 2891 : 		//we know where the mouse is each time the scroll timer goes off.
; 2892 : 		//This is so we can stop sending scroll messages if the thumb moves
; 2893 : 		//under the mouse.
; 2894 : 		POINT pt;
; 2895 : 		GetCursorPos(&pt);

  04c1d	8d 4d c8	 lea	 ecx, DWORD PTR _pt$23604[ebp]
  04c20	51		 push	 ecx
  04c21	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4

; 2896 : 		ScreenToClient(hwnd, &pt);

  04c27	8d 55 c8	 lea	 edx, DWORD PTR _pt$23604[ebp]
  04c2a	52		 push	 edx
  04c2b	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04c2e	50		 push	 eax
  04c2f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ScreenToClient@8

; 2897 : 		
; 2898 : 		MouseMove(swnd, hwnd, MK_LBUTTON, MAKELPARAM(pt.x, pt.y));

  04c35	8b 4d c8	 mov	 ecx, DWORD PTR _pt$23604[ebp]
  04c38	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  04c3e	0f b7 d1	 movzx	 edx, cx
  04c41	8b 45 cc	 mov	 eax, DWORD PTR _pt$23604[ebp+4]
  04c44	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  04c49	0f b7 c8	 movzx	 ecx, ax
  04c4c	c1 e1 10	 shl	 ecx, 16			; 00000010H
  04c4f	0b d1		 or	 edx, ecx
  04c51	52		 push	 edx
  04c52	6a 01		 push	 1
  04c54	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04c57	52		 push	 edx
  04c58	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  04c5b	50		 push	 eax
  04c5c	e8 00 00 00 00	 call	 _MouseMove
  04c61	83 c4 10	 add	 esp, 16			; 00000010H

; 2899 : 
; 2900 : 		if(uScrollTimerPortion != HTSCROLL_NONE)

  04c64	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _uScrollTimerPortion, -1
  04c6b	74 1c		 je	 SHORT $L23613

; 2901 : 			SendScrollMessage(hwnd, uScrollTimerMsg, uScrollTimerPortion, 0);

  04c6d	6a 00		 push	 0
  04c6f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uScrollTimerPortion
  04c75	51		 push	 ecx
  04c76	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uScrollTimerMsg
  04c7c	52		 push	 edx
  04c7d	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04c80	50		 push	 eax
  04c81	e8 00 00 00 00	 call	 _SendScrollMessage
  04c86	83 c4 10	 add	 esp, 16			; 00000010H
$L23613:

; 2902 : 		
; 2903 : 		return 0;

  04c89	33 c0		 xor	 eax, eax
  04c8b	eb 1e		 jmp	 SHORT $L23587
$L23603:

; 2904 : 	}
; 2905 : 	else
; 2906 : 	{
; 2907 : 		return CallWindowProc(swnd->oldproc, hwnd, WM_TIMER, wTimerId, lParam);

  04c8d	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  04c90	51		 push	 ecx
  04c91	8b 55 10	 mov	 edx, DWORD PTR _wTimerId$[ebp]
  04c94	52		 push	 edx
  04c95	68 13 01 00 00	 push	 275			; 00000113H
  04c9a	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04c9d	50		 push	 eax
  04c9e	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  04ca1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  04ca4	52		 push	 edx
  04ca5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
$L23587:

; 2908 : 	}
; 2909 : }

  04cab	8b e5		 mov	 esp, ebp
  04cad	5d		 pop	 ebp
  04cae	c3		 ret	 0
_CoolSB_Timer ENDP
; Function compile flags: /Odt
_ss$ = -4						; size = 4
_swnd$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_msg$ = 16						; size = 4
_wParam$ = 20						; size = 4
_lParam$ = 24						; size = 4
_CoolSB_StyleChange PROC NEAR

; 2916 : {

  04cb0	55		 push	 ebp
  04cb1	8b ec		 mov	 ebp, esp
  04cb3	51		 push	 ecx

; 2917 : 	STYLESTRUCT *ss = (STYLESTRUCT *)lParam;

  04cb4	8b 45 18	 mov	 eax, DWORD PTR _lParam$[ebp]
  04cb7	89 45 fc	 mov	 DWORD PTR _ss$[ebp], eax

; 2918 : 
; 2919 : 	if(wParam == GWL_EXSTYLE)

  04cba	83 7d 14 ec	 cmp	 DWORD PTR _wParam$[ebp], -20 ; ffffffecH
  04cbe	75 2a		 jne	 SHORT $L23629

; 2920 : 	{
; 2921 : 		if(ss->styleNew & WS_EX_LEFTSCROLLBAR)

  04cc0	8b 4d fc	 mov	 ecx, DWORD PTR _ss$[ebp]
  04cc3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  04cc6	81 e2 00 40 00
	00		 and	 edx, 16384		; 00004000H
  04ccc	74 0f		 je	 SHORT $L23630

; 2922 : 			swnd->fLeftScrollbar = TRUE;

  04cce	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  04cd1	c7 80 a4 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1700], 1

; 2923 : 		else

  04cdb	eb 0d		 jmp	 SHORT $L23629
$L23630:

; 2924 : 			swnd->fLeftScrollbar = FALSE;

  04cdd	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  04ce0	c7 81 a4 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1700], 0
$L23629:

; 2925 : 	}
; 2926 : 
; 2927 : 	return CallWindowProc(swnd->oldproc, hwnd, msg, wParam, lParam);

  04cea	8b 55 18	 mov	 edx, DWORD PTR _lParam$[ebp]
  04ced	52		 push	 edx
  04cee	8b 45 14	 mov	 eax, DWORD PTR _wParam$[ebp]
  04cf1	50		 push	 eax
  04cf2	8b 4d 10	 mov	 ecx, DWORD PTR _msg$[ebp]
  04cf5	51		 push	 ecx
  04cf6	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04cf9	52		 push	 edx
  04cfa	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  04cfd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  04d00	51		 push	 ecx
  04d01	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20

; 2928 : }

  04d07	8b e5		 mov	 esp, ebp
  04d09	5d		 pop	 ebp
  04d0a	c3		 ret	 0
_CoolSB_StyleChange ENDP
_TEXT	ENDS
EXTRN	__imp__GetModuleHandleA@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_nmdi$ = -4						; size = 4
_swnd$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_CoolSB_Notify PROC NEAR

; 2932 : {

  04d10	55		 push	 ebp
  04d11	8b ec		 mov	 ebp, esp
  04d13	51		 push	 ecx

; 2933 : #ifdef COOLSB_TOOLTIPS
; 2934 : 
; 2935 : 	NMTTDISPINFO *nmdi = (NMTTDISPINFO *)lParam;

  04d14	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  04d17	89 45 fc	 mov	 DWORD PTR _nmdi$[ebp], eax

; 2936 : 
; 2937 : 	if(nmdi->hdr.hwndFrom == swnd->hwndToolTip &&
; 2938 : 		nmdi->hdr.code == TTN_GETDISPINFO)

  04d1a	8b 4d fc	 mov	 ecx, DWORD PTR _nmdi$[ebp]
  04d1d	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  04d20	8b 01		 mov	 eax, DWORD PTR [ecx]
  04d22	3b 82 a8 06 00
	00		 cmp	 eax, DWORD PTR [edx+1704]
  04d28	75 34		 jne	 SHORT $L23645
  04d2a	8b 4d fc	 mov	 ecx, DWORD PTR _nmdi$[ebp]
  04d2d	81 79 08 f8 fd
	ff ff		 cmp	 DWORD PTR [ecx+8], -520	; fffffdf8H
  04d34	75 28		 jne	 SHORT $L23645

; 2939 : 	{
; 2940 : 		//convert the tooltip notify from a "ISHWND" style
; 2941 : 		//request to an id-based request. 
; 2942 : 		//We do this because our tooltip is a window-style
; 2943 : 		//tip, with no tools, and the GETDISPINFO request must
; 2944 : 		//indicate which button to retrieve the text for
; 2945 : 		//nmdi->hdr.idFrom = curTool;
; 2946 : 		nmdi->hdr.idFrom = curTool;

  04d36	8b 55 fc	 mov	 edx, DWORD PTR _nmdi$[ebp]
  04d39	a1 00 00 00 00	 mov	 eax, DWORD PTR _curTool
  04d3e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 2947 : 		nmdi->hinst = GetModuleHandle(0);

  04d41	6a 00		 push	 0
  04d43	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  04d49	8b 4d fc	 mov	 ecx, DWORD PTR _nmdi$[ebp]
  04d4c	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 2948 : 		nmdi->uFlags &= ~TTF_IDISHWND;

  04d4f	8b 55 fc	 mov	 edx, DWORD PTR _nmdi$[ebp]
  04d52	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  04d55	83 e0 fe	 and	 eax, -2			; fffffffeH
  04d58	8b 4d fc	 mov	 ecx, DWORD PTR _nmdi$[ebp]
  04d5b	89 41 64	 mov	 DWORD PTR [ecx+100], eax
$L23645:

; 2949 : 	}
; 2950 : #endif	//COOLSB_TOOLTIPS
; 2951 : 
; 2952 : 	return CallWindowProc(swnd->oldproc, hwnd, WM_NOTIFY, wParam, lParam);	

  04d5e	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  04d61	52		 push	 edx
  04d62	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  04d65	50		 push	 eax
  04d66	6a 4e		 push	 78			; 0000004eH
  04d68	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04d6b	51		 push	 ecx
  04d6c	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  04d6f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  04d72	50		 push	 eax
  04d73	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20

; 2953 : }

  04d79	8b e5		 mov	 esp, ebp
  04d7b	5d		 pop	 ebp
  04d7c	c3		 ret	 0
_CoolSB_Notify ENDP
_TEXT	ENDS
EXTRN	__imp__SetCursor@4:NEAR
EXTRN	__imp__IsWindowVisible@4:NEAR
_BSS	SEGMENT
?lastid@?1??CoolSB_SetCursor@@9@9 DD 01H DUP (?)	; `CoolSB_SetCursor'::`2'::lastid
; Function compile flags: /Odt
_BSS	ENDS
_TEXT	SEGMENT
_hi$ = -48						; size = 4
_xy$ = -44						; size = 4
_pt$ = -40						; size = 8
_rect$ = -32						; size = 16
_sbar$ = -16						; size = 4
_lo$ = -12						; size = 4
_sbut$ = -8						; size = 4
_id$ = -4						; size = 4
_swnd$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_CoolSB_SetCursor PROC NEAR

; 2972 : {

  04d80	55		 push	 ebp
  04d81	8b ec		 mov	 ebp, esp
  04d83	83 ec 30	 sub	 esp, 48			; 00000030H

; 2973 : #ifdef INCLUDE_BUTTONS
; 2974 : 	UINT lo = LOWORD(lParam);

  04d86	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  04d89	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  04d8e	0f b7 c8	 movzx	 ecx, ax
  04d91	89 4d f4	 mov	 DWORD PTR _lo$[ebp], ecx

; 2975 : 	UINT hi = HIWORD(lParam);

  04d94	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  04d97	c1 ea 10	 shr	 edx, 16			; 00000010H
  04d9a	0f b7 c2	 movzx	 eax, dx
  04d9d	89 45 d0	 mov	 DWORD PTR _hi$[ebp], eax

; 2976 : 	UINT xy;
; 2977 : 	RECT rect;
; 2978 : 	SCROLLBAR *sbar;
; 2979 : 	SCROLLBUT *sbut;
; 2980 : 	POINT pt;
; 2981 : 	UINT id;
; 2982 : 	static UINT lastid;
; 2983 : 
; 2984 : #ifdef HIDE_CURSOR_AFTER_MOUSEUP
; 2985 : 	static UINT lastmsg;
; 2986 : 	if(lastmsg == WM_LBUTTONDOWN)
; 2987 : 	{
; 2988 : 		lastmsg =  hi;
; 2989 : 		return CallWindowProc(swnd->oldproc, hwnd, WM_SETCURSOR, wParam, lParam);	
; 2990 : 	}
; 2991 : 	else
; 2992 : 		lastmsg =  hi;
; 2993 : #endif
; 2994 : 	
; 2995 : 	//if we are over either or our scrollbars
; 2996 : 	if(lo == HTHSCROLL || lo == HTVSCROLL)

  04da0	83 7d f4 06	 cmp	 DWORD PTR _lo$[ebp], 6
  04da4	74 0a		 je	 SHORT $L23681
  04da6	83 7d f4 07	 cmp	 DWORD PTR _lo$[ebp], 7
  04daa	0f 85 ff 01 00
	00		 jne	 $L23680
$L23681:

; 2997 : 	{
; 2998 : 		xy = GetMessagePos();

  04db0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  04db6	89 45 d4	 mov	 DWORD PTR _xy$[ebp], eax

; 2999 : 		pt.x = LOWORD(xy);

  04db9	8b 4d d4	 mov	 ecx, DWORD PTR _xy$[ebp]
  04dbc	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  04dc2	0f b7 d1	 movzx	 edx, cx
  04dc5	89 55 d8	 mov	 DWORD PTR _pt$[ebp], edx

; 3000 : 		pt.y = HIWORD(xy);

  04dc8	8b 45 d4	 mov	 eax, DWORD PTR _xy$[ebp]
  04dcb	c1 e8 10	 shr	 eax, 16			; 00000010H
  04dce	0f b7 c8	 movzx	 ecx, ax
  04dd1	89 4d dc	 mov	 DWORD PTR _pt$[ebp+4], ecx

; 3001 : 
; 3002 : 		if(lo == HTHSCROLL)

  04dd4	83 7d f4 06	 cmp	 DWORD PTR _lo$[ebp], 6
  04dd8	75 40		 jne	 SHORT $L23686

; 3003 : 		{
; 3004 : 			sbar = &swnd->sbarHorz;

  04dda	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  04ddd	83 c2 08	 add	 edx, 8
  04de0	89 55 f0	 mov	 DWORD PTR _sbar$[ebp], edx

; 3005 : 			GetScrollRect(swnd, SB_HORZ, hwnd, &rect);

  04de3	8d 45 e0	 lea	 eax, DWORD PTR _rect$[ebp]
  04de6	50		 push	 eax
  04de7	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04dea	51		 push	 ecx
  04deb	6a 00		 push	 0
  04ded	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  04df0	52		 push	 edx
  04df1	e8 00 00 00 00	 call	 _GetScrollRect
  04df6	83 c4 10	 add	 esp, 16			; 00000010H

; 3006 : 			id = GetHorzPortion(sbar, hwnd, &rect, pt.x, pt.y);

  04df9	8b 45 dc	 mov	 eax, DWORD PTR _pt$[ebp+4]
  04dfc	50		 push	 eax
  04dfd	8b 4d d8	 mov	 ecx, DWORD PTR _pt$[ebp]
  04e00	51		 push	 ecx
  04e01	8d 55 e0	 lea	 edx, DWORD PTR _rect$[ebp]
  04e04	52		 push	 edx
  04e05	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04e08	50		 push	 eax
  04e09	8b 4d f0	 mov	 ecx, DWORD PTR _sbar$[ebp]
  04e0c	51		 push	 ecx
  04e0d	e8 00 00 00 00	 call	 _GetHorzPortion
  04e12	83 c4 14	 add	 esp, 20			; 00000014H
  04e15	89 45 fc	 mov	 DWORD PTR _id$[ebp], eax

; 3007 : 		}
; 3008 : 		else

  04e18	eb 41		 jmp	 SHORT $L23687
$L23686:

; 3009 : 		{
; 3010 : 			sbar = &swnd->sbarVert;

  04e1a	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  04e1d	81 c2 54 03 00
	00		 add	 edx, 852		; 00000354H
  04e23	89 55 f0	 mov	 DWORD PTR _sbar$[ebp], edx

; 3011 : 			GetScrollRect(swnd, SB_VERT, hwnd, &rect);

  04e26	8d 45 e0	 lea	 eax, DWORD PTR _rect$[ebp]
  04e29	50		 push	 eax
  04e2a	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04e2d	51		 push	 ecx
  04e2e	6a 01		 push	 1
  04e30	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  04e33	52		 push	 edx
  04e34	e8 00 00 00 00	 call	 _GetScrollRect
  04e39	83 c4 10	 add	 esp, 16			; 00000010H

; 3012 : 			id = GetVertPortion(sbar, hwnd, &rect, pt.x, pt.y);

  04e3c	8b 45 dc	 mov	 eax, DWORD PTR _pt$[ebp+4]
  04e3f	50		 push	 eax
  04e40	8b 4d d8	 mov	 ecx, DWORD PTR _pt$[ebp]
  04e43	51		 push	 ecx
  04e44	8d 55 e0	 lea	 edx, DWORD PTR _rect$[ebp]
  04e47	52		 push	 edx
  04e48	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04e4b	50		 push	 eax
  04e4c	8b 4d f0	 mov	 ecx, DWORD PTR _sbar$[ebp]
  04e4f	51		 push	 ecx
  04e50	e8 00 00 00 00	 call	 _GetVertPortion
  04e55	83 c4 14	 add	 esp, 20			; 00000014H
  04e58	89 45 fc	 mov	 DWORD PTR _id$[ebp], eax
$L23687:

; 3013 : 		}
; 3014 : 
; 3015 : 		if(id != HTSCROLL_INSERTED)

  04e5b	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _id$[ebp], 128 ; 00000080H
  04e62	74 62		 je	 SHORT $L23688

; 3016 : 		{
; 3017 : 			if(swnd->hwndToolTip != 0)

  04e64	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  04e67	83 ba a8 06 00
	00 00		 cmp	 DWORD PTR [edx+1704], 0
  04e6e	74 36		 je	 SHORT $L23689

; 3018 : 			{
; 3019 : 				SendToolTipMessage(swnd->hwndToolTip, TTM_ACTIVATE, FALSE, 0);

  04e70	6a 00		 push	 0
  04e72	6a 00		 push	 0
  04e74	68 01 04 00 00	 push	 1025			; 00000401H
  04e79	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  04e7c	8b 88 a8 06 00
	00		 mov	 ecx, DWORD PTR [eax+1704]
  04e82	51		 push	 ecx
  04e83	e8 00 00 00 00	 call	 _SendToolTipMessage0
  04e88	83 c4 10	 add	 esp, 16			; 00000010H

; 3020 : 				SendToolTipMessage(swnd->hwndToolTip, TTM_POP, 0, 0);

  04e8b	6a 00		 push	 0
  04e8d	6a 00		 push	 0
  04e8f	68 1c 04 00 00	 push	 1052			; 0000041cH
  04e94	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  04e97	8b 82 a8 06 00
	00		 mov	 eax, DWORD PTR [edx+1704]
  04e9d	50		 push	 eax
  04e9e	e8 00 00 00 00	 call	 _SendToolTipMessage0
  04ea3	83 c4 10	 add	 esp, 16			; 00000010H
$L23689:

; 3021 : 			}
; 3022 : 
; 3023 : 			return CallWindowProc(swnd->oldproc, hwnd, WM_SETCURSOR, wParam, lParam);

  04ea6	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  04ea9	51		 push	 ecx
  04eaa	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  04ead	52		 push	 edx
  04eae	6a 20		 push	 32			; 00000020H
  04eb0	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04eb3	50		 push	 eax
  04eb4	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  04eb7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  04eba	52		 push	 edx
  04ebb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  04ec1	e9 46 01 00 00	 jmp	 $L23665
$L23688:

; 3024 : 		}
; 3025 : 		
; 3026 : 		if(swnd->hwndToolTip != 0)

  04ec6	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  04ec9	83 b8 a8 06 00
	00 00		 cmp	 DWORD PTR [eax+1704], 0
  04ed0	74 1b		 je	 SHORT $L23690

; 3027 : 		{
; 3028 : 			SendToolTipMessage(swnd->hwndToolTip, TTM_ACTIVATE, TRUE, 0);

  04ed2	6a 00		 push	 0
  04ed4	6a 01		 push	 1
  04ed6	68 01 04 00 00	 push	 1025			; 00000401H
  04edb	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  04ede	8b 91 a8 06 00
	00		 mov	 edx, DWORD PTR [ecx+1704]
  04ee4	52		 push	 edx
  04ee5	e8 00 00 00 00	 call	 _SendToolTipMessage0
  04eea	83 c4 10	 add	 esp, 16			; 00000010H
$L23690:

; 3029 : 		}
; 3030 : 
; 3031 : 		//set the cursor if one has been specified
; 3032 : 		if((id = GetButtonFromPt(sbar, &rect, pt, TRUE)) != -1)

  04eed	6a 01		 push	 1
  04eef	8b 45 dc	 mov	 eax, DWORD PTR _pt$[ebp+4]
  04ef2	50		 push	 eax
  04ef3	8b 4d d8	 mov	 ecx, DWORD PTR _pt$[ebp]
  04ef6	51		 push	 ecx
  04ef7	8d 55 e0	 lea	 edx, DWORD PTR _rect$[ebp]
  04efa	52		 push	 edx
  04efb	8b 45 f0	 mov	 eax, DWORD PTR _sbar$[ebp]
  04efe	50		 push	 eax
  04eff	e8 00 00 00 00	 call	 _GetButtonFromPt
  04f04	83 c4 14	 add	 esp, 20			; 00000014H
  04f07	89 45 fc	 mov	 DWORD PTR _id$[ebp], eax
  04f0a	83 7d fc ff	 cmp	 DWORD PTR _id$[ebp], -1
  04f0e	0f 84 85 00 00
	00		 je	 $L23691

; 3033 : 		{
; 3034 : 			sbut = &sbar->sbButtons[id];

  04f14	8b 4d fc	 mov	 ecx, DWORD PTR _id$[ebp]
  04f17	6b c9 30	 imul	 ecx, 48			; 00000030H
  04f1a	8b 55 f0	 mov	 edx, DWORD PTR _sbar$[ebp]
  04f1d	8d 44 0a 2c	 lea	 eax, DWORD PTR [edx+ecx+44]
  04f21	89 45 f8	 mov	 DWORD PTR _sbut$[ebp], eax

; 3035 : 			curTool = sbut->uCmdId;

  04f24	8b 4d f8	 mov	 ecx, DWORD PTR _sbut$[ebp]
  04f27	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  04f2a	89 15 00 00 00
	00		 mov	 DWORD PTR _curTool, edx

; 3036 : 
; 3037 : 			if(lastid != id && swnd->hwndToolTip != 0)

  04f30	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lastid@?1??CoolSB_SetCursor@@9@9
  04f35	3b 45 fc	 cmp	 eax, DWORD PTR _id$[ebp]
  04f38	74 3b		 je	 SHORT $L23692
  04f3a	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  04f3d	83 b9 a8 06 00
	00 00		 cmp	 DWORD PTR [ecx+1704], 0
  04f44	74 2f		 je	 SHORT $L23692

; 3038 : 			{
; 3039 : 				if(IsWindowVisible(swnd->hwndToolTip))

  04f46	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  04f49	8b 82 a8 06 00
	00		 mov	 eax, DWORD PTR [edx+1704]
  04f4f	50		 push	 eax
  04f50	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsWindowVisible@4
  04f56	85 c0		 test	 eax, eax
  04f58	74 1b		 je	 SHORT $L23692

; 3040 : 					SendToolTipMessage(swnd->hwndToolTip, TTM_UPDATE, TRUE, 0);

  04f5a	6a 00		 push	 0
  04f5c	6a 01		 push	 1
  04f5e	68 1d 04 00 00	 push	 1053			; 0000041dH
  04f63	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  04f66	8b 91 a8 06 00
	00		 mov	 edx, DWORD PTR [ecx+1704]
  04f6c	52		 push	 edx
  04f6d	e8 00 00 00 00	 call	 _SendToolTipMessage0
  04f72	83 c4 10	 add	 esp, 16			; 00000010H
$L23692:

; 3041 : 			}
; 3042 : 
; 3043 : 			lastid = id;

  04f75	8b 45 fc	 mov	 eax, DWORD PTR _id$[ebp]
  04f78	a3 00 00 00 00	 mov	 DWORD PTR ?lastid@?1??CoolSB_SetCursor@@9@9, eax

; 3044 : 
; 3045 : 			if(sbut->hCurs != 0)

  04f7d	8b 4d f8	 mov	 ecx, DWORD PTR _sbut$[ebp]
  04f80	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  04f84	74 11		 je	 SHORT $L23694

; 3046 : 			{
; 3047 : 				SetCursor(sbut->hCurs);

  04f86	8b 55 f8	 mov	 edx, DWORD PTR _sbut$[ebp]
  04f89	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  04f8c	50		 push	 eax
  04f8d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4

; 3048 : 				return 0;

  04f93	33 c0		 xor	 eax, eax
  04f95	eb 75		 jmp	 SHORT $L23665
$L23694:

; 3049 : 			}
; 3050 : 		}
; 3051 : 		else

  04f97	eb 14		 jmp	 SHORT $L23695
$L23691:

; 3052 : 		{
; 3053 : 			curTool = -1;

  04f99	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _curTool, -1

; 3054 : 			lastid = -1;

  04fa3	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?lastid@?1??CoolSB_SetCursor@@9@9, -1
$L23695:

; 3055 : 		}
; 3056 : 	}
; 3057 : 	else if(swnd->hwndToolTip != 0)

  04fad	eb 42		 jmp	 SHORT $L23696
$L23680:
  04faf	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  04fb2	83 b9 a8 06 00
	00 00		 cmp	 DWORD PTR [ecx+1704], 0
  04fb9	74 36		 je	 SHORT $L23696

; 3058 : 	{
; 3059 : 		SendToolTipMessage(swnd->hwndToolTip, TTM_ACTIVATE, FALSE, 0);

  04fbb	6a 00		 push	 0
  04fbd	6a 00		 push	 0
  04fbf	68 01 04 00 00	 push	 1025			; 00000401H
  04fc4	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  04fc7	8b 82 a8 06 00
	00		 mov	 eax, DWORD PTR [edx+1704]
  04fcd	50		 push	 eax
  04fce	e8 00 00 00 00	 call	 _SendToolTipMessage0
  04fd3	83 c4 10	 add	 esp, 16			; 00000010H

; 3060 : 		SendToolTipMessage(swnd->hwndToolTip, TTM_POP, 0, 0);

  04fd6	6a 00		 push	 0
  04fd8	6a 00		 push	 0
  04fda	68 1c 04 00 00	 push	 1052			; 0000041cH
  04fdf	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  04fe2	8b 91 a8 06 00
	00		 mov	 edx, DWORD PTR [ecx+1704]
  04fe8	52		 push	 edx
  04fe9	e8 00 00 00 00	 call	 _SendToolTipMessage0
  04fee	83 c4 10	 add	 esp, 16			; 00000010H
$L23696:

; 3061 : 	}
; 3062 : 
; 3063 : #endif	//INCLUDE_BUTTONS
; 3064 : 	return CallWindowProc(swnd->oldproc, hwnd, WM_SETCURSOR, wParam, lParam);

  04ff1	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  04ff4	50		 push	 eax
  04ff5	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  04ff8	51		 push	 ecx
  04ff9	6a 20		 push	 32			; 00000020H
  04ffb	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04ffe	52		 push	 edx
  04fff	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  05002	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  05005	51		 push	 ecx
  05006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
$L23665:

; 3065 : }

  0500c	8b e5		 mov	 esp, ebp
  0500e	5d		 pop	 ebp
  0500f	c3		 ret	 0
_CoolSB_SetCursor ENDP
; Function compile flags: /Odt
_hwndTT$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_SendToolTipMessage0 PROC NEAR

; 2956 : {

  05010	55		 push	 ebp
  05011	8b ec		 mov	 ebp, esp

; 2957 : 	return SendMessage(hwndTT, message, wParam, lParam);

  05013	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  05016	50		 push	 eax
  05017	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0501a	51		 push	 ecx
  0501b	8b 55 0c	 mov	 edx, DWORD PTR _message$[ebp]
  0501e	52		 push	 edx
  0501f	8b 45 08	 mov	 eax, DWORD PTR _hwndTT$[ebp]
  05022	50		 push	 eax
  05023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 2958 : }

  05029	5d		 pop	 ebp
  0502a	c3		 ret	 0
_SendToolTipMessage0 ENDP
; Function compile flags: /Odt
_msg$ = -28						; size = 28
_hwnd$ = 8						; size = 4
_hwndToolTip$ = 12					; size = 4
_event$ = 16						; size = 4
_RelayMouseEvent@12 PROC NEAR

; 3072 : {

  05030	55		 push	 ebp
  05031	8b ec		 mov	 ebp, esp
  05033	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 3073 : #ifdef COOLSB_TOOLTIPS
; 3074 : 	MSG msg;
; 3075 : 
; 3076 : 	CoolSB_ZeroMemory(&msg, sizeof(MSG));

  05036	6a 1c		 push	 28			; 0000001cH
  05038	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  0503b	50		 push	 eax
  0503c	e8 00 00 00 00	 call	 _CoolSB_ZeroMemory
  05041	83 c4 08	 add	 esp, 8

; 3077 : 	msg.hwnd = hwnd;

  05044	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05047	89 4d e4	 mov	 DWORD PTR _msg$[ebp], ecx

; 3078 : 	msg.message = event;

  0504a	8b 55 10	 mov	 edx, DWORD PTR _event$[ebp]
  0504d	89 55 e8	 mov	 DWORD PTR _msg$[ebp+4], edx

; 3079 : #pragma warning( disable: 4311)	
; 3080 : 	SendMessage(hwndToolTip, TTM_RELAYEVENT, 0, (LONG)&msg);

  05050	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  05053	50		 push	 eax
  05054	6a 00		 push	 0
  05056	68 07 04 00 00	 push	 1031			; 00000407H
  0505b	8b 4d 0c	 mov	 ecx, DWORD PTR _hwndToolTip$[ebp]
  0505e	51		 push	 ecx
  0505f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 3081 : #pragma warning( default: 4311)	
; 3082 : #else
; 3083 : 	UNREFERENCED_PARAMETER(hwnd);
; 3084 : 	UNREFERENCED_PARAMETER(hwndToolTip);
; 3085 : 	UNREFERENCED_PARAMETER(event);
; 3086 : #endif
; 3087 : }

  05065	8b e5		 mov	 esp, ebp
  05067	5d		 pop	 ebp
  05068	c2 0c 00	 ret	 12			; 0000000cH
_RelayMouseEvent@12 ENDP
_TEXT	ENDS
END
