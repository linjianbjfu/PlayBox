; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\boxgit\PlayBox\CommonLib\common\YL_StringUtil.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@HHDGIIFB@0123456789abcdefABCDEF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@_W@std@@YAD_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@_WDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0IPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@D@std@@YADDABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVdomain_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVrange_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@codecvt_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@_WDH@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4underflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4overflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVunderflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4domain_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_exception@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4invalid_argument@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$codecvt@_WDH@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4range_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_exception@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$codecvt@_WDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R2invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVinvalid_argument@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVoverflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
CONST	SEGMENT
$SG11099 DB	0a1H, 0a1H, 00H
	ORG $+1
$SG11510 DB	'\', 00H
	ORG $+2
$SG11516 DB	'\', 00H
	ORG $+2
$SG11521 DB	'\', 00H
CONST	ENDS
PUBLIC	?Trim@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_StringUtil::Trim
EXTRN	__imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z:NEAR
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
EXTRN	__imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp__strncmp:NEAR
EXTRN	__imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:NEAR
xdata$x	SEGMENT
$T15993	DD	0ffffffffH
	DD	FLAT:$L15986
$T15990	DD	019930520H
	DD	01H
	DD	FLAT:$T15993
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\commonlib\common\yl_stringutil.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv140 = -56						; size = 4
tv141 = -52						; size = 4
$T15985 = -48						; size = 28
_end$ = -20						; size = 4
_begin$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_str$ = 8						; size = 4
?Trim@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; YL_StringUtil::Trim

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Trim@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 7    : 	size_t begin = 0;

  0001b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _begin$[ebp], 0

; 8    : 	for (; begin < str.length(); begin++)

  00022	eb 09		 jmp	 SHORT $L11095
$L11096:
  00024	8b 45 f0	 mov	 eax, DWORD PTR _begin$[ebp]
  00027	83 c0 01	 add	 eax, 1
  0002a	89 45 f0	 mov	 DWORD PTR _begin$[ebp], eax
$L11095:
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00036	39 45 f0	 cmp	 DWORD PTR _begin$[ebp], eax
  00039	73 45		 jae	 SHORT $L11097

; 9    : 	{
; 10   : 		if (strncmp(str.c_str()+begin, "", 2)==0)

  0003b	6a 02		 push	 2
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:$SG11099
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0004b	03 45 f0	 add	 eax, DWORD PTR _begin$[ebp]
  0004e	50		 push	 eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	85 c0		 test	 eax, eax
  0005a	75 0b		 jne	 SHORT $L11098

; 11   : 		{
; 12   : 			begin++;

  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _begin$[ebp]
  0005f	83 c1 01	 add	 ecx, 1
  00062	89 4d f0	 mov	 DWORD PTR _begin$[ebp], ecx

; 13   : 			continue;

  00065	eb bd		 jmp	 SHORT $L11096
$L11098:

; 14   : 		}
; 15   : 		if( str[begin] != ' ' )

  00067	8b 55 f0	 mov	 edx, DWORD PTR _begin$[ebp]
  0006a	52		 push	 edx
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
  00074	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00077	83 f8 20	 cmp	 eax, 32			; 00000020H
  0007a	74 02		 je	 SHORT $L11100

; 16   : 			break;

  0007c	eb 02		 jmp	 SHORT $L11097
$L11100:

; 17   : 	}

  0007e	eb a4		 jmp	 SHORT $L11096
$L11097:

; 18   : 
; 19   : 	if (begin == str.length())

  00080	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00089	39 45 f0	 cmp	 DWORD PTR _begin$[ebp], eax
  0008c	75 0e		 jne	 SHORT $L11101

; 20   : 	{
; 21   : 		str.clear();

  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 22   : 		return ;

  00097	e9 83 00 00 00	 jmp	 $L11093
$L11101:

; 23   : 	}
; 24   : 
; 25   : 	size_t end = str.length()-1;

  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  000a5	83 e8 01	 sub	 eax, 1
  000a8	89 45 ec	 mov	 DWORD PTR _end$[ebp], eax

; 26   : 	for (; end > begin; end--)

  000ab	eb 09		 jmp	 SHORT $L11103
$L11104:
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR _end$[ebp]
  000b0	83 e9 01	 sub	 ecx, 1
  000b3	89 4d ec	 mov	 DWORD PTR _end$[ebp], ecx
$L11103:
  000b6	8b 55 ec	 mov	 edx, DWORD PTR _end$[ebp]
  000b9	3b 55 f0	 cmp	 edx, DWORD PTR _begin$[ebp]
  000bc	76 19		 jbe	 SHORT $L11105

; 27   : 	{
; 28   : 		if( str[end] != ' ')		

  000be	8b 45 ec	 mov	 eax, DWORD PTR _end$[ebp]
  000c1	50		 push	 eax
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
  000cb	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ce	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000d1	74 02		 je	 SHORT $L11106

; 29   : 			break;

  000d3	eb 02		 jmp	 SHORT $L11105
$L11106:

; 30   : 	}

  000d5	eb d6		 jmp	 SHORT $L11104
$L11105:

; 31   : 
; 32   : 	str = str.substr(begin, end-begin+1);

  000d7	8b 55 ec	 mov	 edx, DWORD PTR _end$[ebp]
  000da	2b 55 f0	 sub	 edx, DWORD PTR _begin$[ebp]
  000dd	83 c2 01	 add	 edx, 1
  000e0	52		 push	 edx
  000e1	8b 45 f0	 mov	 eax, DWORD PTR _begin$[ebp]
  000e4	50		 push	 eax
  000e5	8d 4d d0	 lea	 ecx, DWORD PTR $T15985[ebp]
  000e8	51		 push	 ecx
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  000f2	89 45 cc	 mov	 DWORD PTR tv141[ebp], eax
  000f5	8b 55 cc	 mov	 edx, DWORD PTR tv141[ebp]
  000f8	89 55 c8	 mov	 DWORD PTR tv140[ebp], edx
  000fb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00102	8b 45 c8	 mov	 eax, DWORD PTR tv140[ebp]
  00105	50		 push	 eax
  00106	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0010f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00116	8d 4d d0	 lea	 ecx, DWORD PTR $T15985[ebp]
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L11093:

; 33   : 
; 34   : 	return ;
; 35   : }

  0011f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00122	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L15986:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR $T15985[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Trim@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T15990
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Trim@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; YL_StringUtil::Trim
PUBLIC	?isChineseChar@@YA_NDD@Z			; isChineseChar
; Function compile flags: /Odt
_TEXT	SEGMENT
tv72 = -4						; size = 4
_c1$ = 8						; size = 1
_c2$ = 12						; size = 1
?isChineseChar@@YA_NDD@Z PROC NEAR			; isChineseChar

; 38   : {

  00130	55		 push	 ebp
  00131	8b ec		 mov	 ebp, esp
  00133	51		 push	 ecx

; 39   : 	return (unsigned char)c1>=0x80&&(unsigned char)c1<=0xFE&&(unsigned char)
; 40   : 		c2>=0x40&&(unsigned char)c2<=0xFE;

  00134	0f b6 45 08	 movzx	 eax, BYTE PTR _c1$[ebp]
  00138	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0013d	7c 29		 jl	 SHORT $L15996
  0013f	0f b6 4d 08	 movzx	 ecx, BYTE PTR _c1$[ebp]
  00143	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  00149	7f 1d		 jg	 SHORT $L15996
  0014b	0f b6 55 0c	 movzx	 edx, BYTE PTR _c2$[ebp]
  0014f	83 fa 40	 cmp	 edx, 64			; 00000040H
  00152	7c 14		 jl	 SHORT $L15996
  00154	0f b6 45 0c	 movzx	 eax, BYTE PTR _c2$[ebp]
  00158	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  0015d	7f 09		 jg	 SHORT $L15996
  0015f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00166	eb 07		 jmp	 SHORT $L15997
$L15996:
  00168	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L15997:
  0016f	8a 45 fc	 mov	 al, BYTE PTR tv72[ebp]

; 41   : }

  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
?isChineseChar@@YA_NDD@Z ENDP				; isChineseChar
_TEXT	ENDS
PUBLIC	?Str2Lower@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_StringUtil::Str2Lower
EXTRN	__imp_?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:NEAR
EXTRN	__imp__tolower:NEAR
xdata$x	SEGMENT
$T16007	DD	0ffffffffH
	DD	FLAT:$L16000
$T16002	DD	019930520H
	DD	01H
	DD	FLAT:$T16007
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
__lower$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_pChar$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_str$ = 8						; size = 4
?Str2Lower@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; YL_StringUtil::Str2Lower

; 44   : {

  00180	55		 push	 ebp
  00181	8b ec		 mov	 ebp, esp
  00183	6a ff		 push	 -1
  00185	68 00 00 00 00	 push	 __ehhandler$?Str2Lower@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0018a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00190	50		 push	 eax
  00191	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00198	83 ec 24	 sub	 esp, 36			; 00000024H
  0019b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  001a0	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 45   : 	const char* pChar = str.c_str();

  001a3	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  001ac	89 45 f0	 mov	 DWORD PTR _pChar$[ebp], eax

; 46   : 	string _lower;

  001af	8d 4d d0	 lea	 ecx, DWORD PTR __lower$[ebp]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001b8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
$L11122:

; 47   : 	while (*pChar != '\0')

  001bf	8b 45 f0	 mov	 eax, DWORD PTR _pChar$[ebp]
  001c2	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001c5	85 c9		 test	 ecx, ecx
  001c7	74 5b		 je	 SHORT $L11123

; 48   : 	{
; 49   : 		if (isChineseChar(*pChar, *(pChar+1)))

  001c9	8b 55 f0	 mov	 edx, DWORD PTR _pChar$[ebp]
  001cc	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  001cf	50		 push	 eax
  001d0	8b 4d f0	 mov	 ecx, DWORD PTR _pChar$[ebp]
  001d3	8a 11		 mov	 dl, BYTE PTR [ecx]
  001d5	52		 push	 edx
  001d6	e8 00 00 00 00	 call	 ?isChineseChar@@YA_NDD@Z ; isChineseChar
  001db	83 c4 08	 add	 esp, 8
  001de	0f b6 c0	 movzx	 eax, al
  001e1	85 c0		 test	 eax, eax
  001e3	74 1a		 je	 SHORT $L11124

; 50   : 		{
; 51   : 			_lower.append(pChar, 2);

  001e5	6a 02		 push	 2
  001e7	8b 4d f0	 mov	 ecx, DWORD PTR _pChar$[ebp]
  001ea	51		 push	 ecx
  001eb	8d 4d d0	 lea	 ecx, DWORD PTR __lower$[ebp]
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 52   : 			pChar += 2;

  001f4	8b 55 f0	 mov	 edx, DWORD PTR _pChar$[ebp]
  001f7	83 c2 02	 add	 edx, 2
  001fa	89 55 f0	 mov	 DWORD PTR _pChar$[ebp], edx

; 53   : 		}
; 54   : 		else

  001fd	eb 23		 jmp	 SHORT $L11204
$L11124:

; 55   : 		{
; 56   : 			_lower.push_back(tolower(*pChar));

  001ff	8b 45 f0	 mov	 eax, DWORD PTR _pChar$[ebp]
  00202	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00205	51		 push	 ecx
  00206	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__tolower
  0020c	83 c4 04	 add	 esp, 4
  0020f	50		 push	 eax
  00210	8d 4d d0	 lea	 ecx, DWORD PTR __lower$[ebp]
  00213	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z

; 57   : 			pChar++;

  00219	8b 55 f0	 mov	 edx, DWORD PTR _pChar$[ebp]
  0021c	83 c2 01	 add	 edx, 1
  0021f	89 55 f0	 mov	 DWORD PTR _pChar$[ebp], edx
$L11204:

; 58   : 		}
; 59   : 	}

  00222	eb 9b		 jmp	 SHORT $L11122
$L11123:

; 60   : 	str = _lower;

  00224	8d 45 d0	 lea	 eax, DWORD PTR __lower$[ebp]
  00227	50		 push	 eax
  00228	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0022b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 61   : 
; 62   : 	return ;

  00231	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00238	8d 4d d0	 lea	 ecx, DWORD PTR __lower$[ebp]
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 63   : }

  00241	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00244	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0024b	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00253	8b e5		 mov	 esp, ebp
  00255	5d		 pop	 ebp
  00256	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L16000:
  00013	8d 4d d0	 lea	 ecx, DWORD PTR __lower$[ebp]
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Str2Lower@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16002
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Str2Lower@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; YL_StringUtil::Str2Lower
PUBLIC	?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; YL_StringUtil::Format
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	__imp__vsprintf:NEAR
EXTRN	__imp___vscprintf:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z:NEAR
xdata$x	SEGMENT
$T16016	DD	0ffffffffH
	DD	FLAT:$L16012
$T16014	DD	019930520H
	DD	01H
	DD	FLAT:$T16016
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv87 = -68						; size = 4
tv88 = -64						; size = 4
$T16011 = -60						; size = 4
$T16010 = -56						; size = 28
$T16009 = -28						; size = 4
_argList$ = -24						; size = 4
_buf$ = -20						; size = 4
_len$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_str$ = 8						; size = 4
_szFmt$ = 12						; size = 4
?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ PROC NEAR ; YL_StringUtil::Format

; 66   : {

  00260	55		 push	 ebp
  00261	8b ec		 mov	 ebp, esp
  00263	6a ff		 push	 -1
  00265	68 00 00 00 00	 push	 __ehhandler$?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ
  0026a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00270	50		 push	 eax
  00271	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00278	83 ec 38	 sub	 esp, 56			; 00000038H

; 67   : 	va_list argList;
; 68   : 	int len;
; 69   : 	char* buf;
; 70   : 
; 71   : 	va_start( argList, szFmt );

  0027b	8d 45 10	 lea	 eax, DWORD PTR _szFmt$[ebp+4]
  0027e	89 45 e8	 mov	 DWORD PTR _argList$[ebp], eax

; 72   : 	len = _vscprintf(szFmt, argList) + 1;

  00281	8b 4d e8	 mov	 ecx, DWORD PTR _argList$[ebp]
  00284	51		 push	 ecx
  00285	8b 55 0c	 mov	 edx, DWORD PTR _szFmt$[ebp]
  00288	52		 push	 edx
  00289	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vscprintf
  0028f	83 c4 08	 add	 esp, 8
  00292	83 c0 01	 add	 eax, 1
  00295	89 45 f0	 mov	 DWORD PTR _len$[ebp], eax

; 73   : 
; 74   : 	buf = new char[len];

  00298	8b 45 f0	 mov	 eax, DWORD PTR _len$[ebp]
  0029b	50		 push	 eax
  0029c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002a1	83 c4 04	 add	 esp, 4
  002a4	89 45 e4	 mov	 DWORD PTR $T16009[ebp], eax
  002a7	8b 4d e4	 mov	 ecx, DWORD PTR $T16009[ebp]
  002aa	89 4d ec	 mov	 DWORD PTR _buf$[ebp], ecx

; 75   : 
; 76   : 	if(vsprintf(buf, szFmt, argList) < 0)

  002ad	8b 55 e8	 mov	 edx, DWORD PTR _argList$[ebp]
  002b0	52		 push	 edx
  002b1	8b 45 0c	 mov	 eax, DWORD PTR _szFmt$[ebp]
  002b4	50		 push	 eax
  002b5	8b 4d ec	 mov	 ecx, DWORD PTR _buf$[ebp]
  002b8	51		 push	 ecx
  002b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  002bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c2	85 c0		 test	 eax, eax
  002c4	7d 04		 jge	 SHORT $L11218

; 77   : 	{
; 78   : 		return false;

  002c6	32 c0		 xor	 al, al
  002c8	eb 5c		 jmp	 SHORT $L11208
$L11218:

; 79   : 	}
; 80   : 
; 81   : 	str = string(buf, len - 1);

  002ca	8b 55 f0	 mov	 edx, DWORD PTR _len$[ebp]
  002cd	83 ea 01	 sub	 edx, 1
  002d0	52		 push	 edx
  002d1	8b 45 ec	 mov	 eax, DWORD PTR _buf$[ebp]
  002d4	50		 push	 eax
  002d5	8d 4d c8	 lea	 ecx, DWORD PTR $T16010[ebp]
  002d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
  002de	89 45 c0	 mov	 DWORD PTR tv88[ebp], eax
  002e1	8b 4d c0	 mov	 ecx, DWORD PTR tv88[ebp]
  002e4	89 4d bc	 mov	 DWORD PTR tv87[ebp], ecx
  002e7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  002ee	8b 55 bc	 mov	 edx, DWORD PTR tv87[ebp]
  002f1	52		 push	 edx
  002f2	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  002f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  002fb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00302	8d 4d c8	 lea	 ecx, DWORD PTR $T16010[ebp]
  00305	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 82   : 	delete[] buf;

  0030b	8b 45 ec	 mov	 eax, DWORD PTR _buf$[ebp]
  0030e	89 45 c4	 mov	 DWORD PTR $T16011[ebp], eax
  00311	8b 4d c4	 mov	 ecx, DWORD PTR $T16011[ebp]
  00314	51		 push	 ecx
  00315	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0031a	83 c4 04	 add	 esp, 4

; 83   : 	va_end( argList );

  0031d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _argList$[ebp], 0

; 84   : 	return true;

  00324	b0 01		 mov	 al, 1
$L11208:

; 85   : }

  00326	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00329	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00330	8b e5		 mov	 esp, ebp
  00332	5d		 pop	 ebp
  00333	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L16012:
  00026	8d 4d c8	 lea	 ecx, DWORD PTR $T16010[ebp]
  00029	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ:
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16014
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ENDP ; YL_StringUtil::Format
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
PUBLIC	?Tokenize@YL_StringUtil@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@0@Z ; YL_StringUtil::Tokenize
EXTRN	__imp_?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z:NEAR
EXTRN	__imp_?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z:NEAR
EXTRN	__imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB:DWORD
xdata$x	SEGMENT
$T16024	DD	0ffffffffH
	DD	FLAT:$L16019
$T16021	DD	019930520H
	DD	01H
	DD	FLAT:$T16024
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_token$11475 = -52					; size = 28
__$ArrayPad$ = -24					; size = 4
_pos$ = -20						; size = 4
_last_pos$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_str$ = 8						; size = 4
_tokens$ = 12						; size = 4
_delims$ = 16						; size = 4
?Tokenize@YL_StringUtil@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@0@Z PROC NEAR ; YL_StringUtil::Tokenize

; 88   : {

  00340	55		 push	 ebp
  00341	8b ec		 mov	 ebp, esp
  00343	6a ff		 push	 -1
  00345	68 00 00 00 00	 push	 __ehhandler$?Tokenize@YL_StringUtil@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@0@Z
  0034a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00350	50		 push	 eax
  00351	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00358	83 ec 28	 sub	 esp, 40			; 00000028H
  0035b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00360	89 45 e8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 89   : 	//ensure the tokens vector is empty.
; 90   : 	tokens.clear();

  00363	8b 4d 0c	 mov	 ecx, DWORD PTR _tokens$[ebp]
  00366	e8 00 00 00 00	 call	 ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear

; 91   : 	string::size_type last_pos,pos;	
; 92   : 	pos = last_pos = 0;	

  0036b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _last_pos$[ebp], 0
  00372	8b 45 f0	 mov	 eax, DWORD PTR _last_pos$[ebp]
  00375	89 45 ec	 mov	 DWORD PTR _pos$[ebp], eax
$L11471:

; 93   : 
; 94   : 	do{
; 95   : 		last_pos = pos;

  00378	8b 4d ec	 mov	 ecx, DWORD PTR _pos$[ebp]
  0037b	89 4d f0	 mov	 DWORD PTR _last_pos$[ebp], ecx

; 96   : 		last_pos = str.find_first_not_of(delims,last_pos);

  0037e	8b 55 f0	 mov	 edx, DWORD PTR _last_pos$[ebp]
  00381	52		 push	 edx
  00382	8b 45 10	 mov	 eax, DWORD PTR _delims$[ebp]
  00385	50		 push	 eax
  00386	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00389	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z
  0038f	89 45 f0	 mov	 DWORD PTR _last_pos$[ebp], eax

; 97   : 		if(last_pos == string::npos){

  00392	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  00398	8b 55 f0	 mov	 edx, DWORD PTR _last_pos$[ebp]
  0039b	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0039d	75 02		 jne	 SHORT $L11474

; 98   : 			////WriteLog(Warnning, "YLString", "No token delims");
; 99   : 			break;

  0039f	eb 5f		 jmp	 SHORT $L11227
$L11474:

; 100  : 		}
; 101  : 		pos = str.find_first_of(delims, last_pos);

  003a1	8b 45 f0	 mov	 eax, DWORD PTR _last_pos$[ebp]
  003a4	50		 push	 eax
  003a5	8b 4d 10	 mov	 ecx, DWORD PTR _delims$[ebp]
  003a8	51		 push	 ecx
  003a9	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  003ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z
  003b2	89 45 ec	 mov	 DWORD PTR _pos$[ebp], eax

; 102  : 
; 103  : 		string token = str.substr(last_pos, pos-last_pos);

  003b5	8b 55 ec	 mov	 edx, DWORD PTR _pos$[ebp]
  003b8	2b 55 f0	 sub	 edx, DWORD PTR _last_pos$[ebp]
  003bb	52		 push	 edx
  003bc	8b 45 f0	 mov	 eax, DWORD PTR _last_pos$[ebp]
  003bf	50		 push	 eax
  003c0	8d 4d cc	 lea	 ecx, DWORD PTR _token$11475[ebp]
  003c3	51		 push	 ecx
  003c4	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  003c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  003cd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 104  : 		tokens.push_back(token);

  003d4	8d 55 cc	 lea	 edx, DWORD PTR _token$11475[ebp]
  003d7	52		 push	 edx
  003d8	8b 4d 0c	 mov	 ecx, DWORD PTR _tokens$[ebp]
  003db	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 105  : 	}while(pos != string::npos);

  003e0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003e7	8d 4d cc	 lea	 ecx, DWORD PTR _token$11475[ebp]
  003ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  003f0	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  003f5	8b 4d ec	 mov	 ecx, DWORD PTR _pos$[ebp]
  003f8	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003fa	0f 85 78 ff ff
	ff		 jne	 $L11471
$L11227:

; 106  : }

  00400	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00403	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0040a	8b 4d e8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00412	8b e5		 mov	 esp, ebp
  00414	5d		 pop	 ebp
  00415	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L16019:
  00039	8d 4d cc	 lea	 ecx, DWORD PTR _token$11475[ebp]
  0003c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Tokenize@YL_StringUtil@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@0@Z:
  00042	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16021
  00047	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Tokenize@YL_StringUtil@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@0@Z ENDP ; YL_StringUtil::Tokenize
PUBLIC	?EndsWith@YL_StringUtil@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; YL_StringUtil::EndsWith
EXTRN	__imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_pos$ = -4						; size = 4
_str$ = 8						; size = 4
_endStr$ = 12						; size = 4
?EndsWith@YL_StringUtil@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC NEAR ; YL_StringUtil::EndsWith

; 109  : {

  00420	55		 push	 ebp
  00421	8b ec		 mov	 ebp, esp
  00423	51		 push	 ecx
  00424	56		 push	 esi

; 110  : 	string::size_type pos = str.find(endStr,str.length() - endStr.length());

  00425	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00428	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  0042e	8b f0		 mov	 esi, eax
  00430	8b 4d 0c	 mov	 ecx, DWORD PTR _endStr$[ebp]
  00433	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00439	2b f0		 sub	 esi, eax
  0043b	56		 push	 esi
  0043c	8b 45 0c	 mov	 eax, DWORD PTR _endStr$[ebp]
  0043f	50		 push	 eax
  00440	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00443	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z
  00449	89 45 fc	 mov	 DWORD PTR _pos$[ebp], eax

; 111  : 	return pos != string::npos;

  0044c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  00452	8b 55 fc	 mov	 edx, DWORD PTR _pos$[ebp]
  00455	33 c0		 xor	 eax, eax
  00457	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00459	0f 95 c0	 setne	 al

; 112  : }

  0045c	5e		 pop	 esi
  0045d	8b e5		 mov	 esp, ebp
  0045f	5d		 pop	 ebp
  00460	c3		 ret	 0
?EndsWith@YL_StringUtil@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; YL_StringUtil::EndsWith
_TEXT	ENDS
PUBLIC	?StartsWith@YL_StringUtil@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; YL_StringUtil::StartsWith
; Function compile flags: /Odt
_TEXT	SEGMENT
_pos$ = -4						; size = 4
_str$ = 8						; size = 4
_startStr$ = 12						; size = 4
?StartsWith@YL_StringUtil@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC NEAR ; YL_StringUtil::StartsWith

; 115  : {

  00470	55		 push	 ebp
  00471	8b ec		 mov	 ebp, esp
  00473	51		 push	 ecx

; 116  : 	string::size_type pos = str.find(startStr);

  00474	6a 00		 push	 0
  00476	8b 45 0c	 mov	 eax, DWORD PTR _startStr$[ebp]
  00479	50		 push	 eax
  0047a	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0047d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z
  00483	89 45 fc	 mov	 DWORD PTR _pos$[ebp], eax

; 117  : 	return pos == 0;

  00486	33 c0		 xor	 eax, eax
  00488	83 7d fc 00	 cmp	 DWORD PTR _pos$[ebp], 0
  0048c	0f 94 c0	 sete	 al

; 118  : }

  0048f	8b e5		 mov	 esp, ebp
  00491	5d		 pop	 ebp
  00492	c3		 ret	 0
?StartsWith@YL_StringUtil@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; YL_StringUtil::StartsWith
_TEXT	ENDS
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?ReplaceAll@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@1@Z ; YL_StringUtil::ReplaceAll
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
xdata$x	SEGMENT
$T16040	DD	0ffffffffH
	DD	FLAT:$L16032
	DD	00H
	DD	FLAT:$L16033
	DD	01H
	DD	FLAT:$L16034
	DD	00H
	DD	FLAT:$L16035
$T16037	DD	019930520H
	DD	04H
	DD	FLAT:$T16040
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv144 = -160						; size = 4
tv146 = -156						; size = 4
tv142 = -152						; size = 4
tv145 = -148						; size = 4
tv140 = -144						; size = 4
tv65 = -140						; size = 4
$T16031 = -136						; size = 28
$T16030 = -108						; size = 28
$T16029 = -80						; size = 28
_pos$ = -52						; size = 4
_tpos$ = -48						; size = 4
_strTemp$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_str$ = 8						; size = 4
_strToReplaced$ = 12					; size = 4
_strReplaced$ = 16					; size = 4
?ReplaceAll@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@1@Z PROC NEAR ; YL_StringUtil::ReplaceAll

; 121  : {

  004a0	55		 push	 ebp
  004a1	8b ec		 mov	 ebp, esp
  004a3	6a ff		 push	 -1
  004a5	68 00 00 00 00	 push	 __ehhandler$?ReplaceAll@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@1@Z
  004aa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  004b0	50		 push	 eax
  004b1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  004b8	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  004be	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  004c3	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 122  : 	string strTemp;

  004c6	8d 4d d4	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  004c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  004cf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 123  : 	string::size_type pos, tpos;
; 124  : 	tpos = 0;

  004d6	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _tpos$[ebp], 0

; 125  : 	pos = str.find(strToReplaced);

  004dd	6a 00		 push	 0
  004df	8b 45 0c	 mov	 eax, DWORD PTR _strToReplaced$[ebp]
  004e2	50		 push	 eax
  004e3	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  004e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z
  004ec	89 45 cc	 mov	 DWORD PTR _pos$[ebp], eax
$L11496:

; 126  : 	while(pos != string::npos)

  004ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  004f5	8b 55 cc	 mov	 edx, DWORD PTR _pos$[ebp]
  004f8	3b 11		 cmp	 edx, DWORD PTR [ecx]
  004fa	0f 84 ad 00 00
	00		 je	 $L11497

; 127  : 	{
; 128  : 		strTemp += str.substr(tpos, pos - tpos) + strReplaced;		

  00500	8b 45 cc	 mov	 eax, DWORD PTR _pos$[ebp]
  00503	2b 45 d0	 sub	 eax, DWORD PTR _tpos$[ebp]
  00506	50		 push	 eax
  00507	8b 4d d0	 mov	 ecx, DWORD PTR _tpos$[ebp]
  0050a	51		 push	 ecx
  0050b	8d 55 b0	 lea	 edx, DWORD PTR $T16029[ebp]
  0050e	52		 push	 edx
  0050f	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00512	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  00518	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0051e	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  00524	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv140[ebp], eax
  0052a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0052e	8b 4d 10	 mov	 ecx, DWORD PTR _strReplaced$[ebp]
  00531	51		 push	 ecx
  00532	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR tv140[ebp]
  00538	52		 push	 edx
  00539	8d 45 94	 lea	 eax, DWORD PTR $T16030[ebp]
  0053c	50		 push	 eax
  0053d	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00542	83 c4 0c	 add	 esp, 12			; 0000000cH
  00545	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv145[ebp], eax
  0054b	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv145[ebp]
  00551	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv142[ebp], ecx
  00557	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0055b	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv142[ebp]
  00561	52		 push	 edx
  00562	8d 4d d4	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  00565	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0056b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0056f	8d 4d 94	 lea	 ecx, DWORD PTR $T16030[ebp]
  00572	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00578	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0057c	8d 4d b0	 lea	 ecx, DWORD PTR $T16029[ebp]
  0057f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 129  : 		tpos = pos + strToReplaced.length();

  00585	8b 4d 0c	 mov	 ecx, DWORD PTR _strToReplaced$[ebp]
  00588	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  0058e	03 45 cc	 add	 eax, DWORD PTR _pos$[ebp]
  00591	89 45 d0	 mov	 DWORD PTR _tpos$[ebp], eax

; 130  : 		pos = str.find(strToReplaced, tpos);

  00594	8b 45 d0	 mov	 eax, DWORD PTR _tpos$[ebp]
  00597	50		 push	 eax
  00598	8b 4d 0c	 mov	 ecx, DWORD PTR _strToReplaced$[ebp]
  0059b	51		 push	 ecx
  0059c	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0059f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z
  005a5	89 45 cc	 mov	 DWORD PTR _pos$[ebp], eax

; 131  : 	}

  005a8	e9 42 ff ff ff	 jmp	 $L11496
$L11497:

; 132  : 	strTemp += str.substr(tpos);

  005ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  005b3	8b 02		 mov	 eax, DWORD PTR [edx]
  005b5	50		 push	 eax
  005b6	8b 4d d0	 mov	 ecx, DWORD PTR _tpos$[ebp]
  005b9	51		 push	 ecx
  005ba	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR $T16031[ebp]
  005c0	52		 push	 edx
  005c1	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  005c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  005ca	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv146[ebp], eax
  005d0	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv146[ebp]
  005d6	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv144[ebp], eax
  005dc	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  005e0	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv144[ebp]
  005e6	51		 push	 ecx
  005e7	8d 4d d4	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  005ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  005f0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  005f4	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T16031[ebp]
  005fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 133  : 	str = strTemp;

  00600	8d 55 d4	 lea	 edx, DWORD PTR _strTemp$[ebp]
  00603	52		 push	 edx
  00604	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00607	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 134  : }

  0060d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00614	8d 4d d4	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  00617	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0061d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00620	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00627	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0062a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0062f	8b e5		 mov	 esp, ebp
  00631	5d		 pop	 ebp
  00632	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L16032:
  0004c	8d 4d d4	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  0004f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16033:
  00055	8d 4d b0	 lea	 ecx, DWORD PTR $T16029[ebp]
  00058	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16034:
  0005e	8d 4d 94	 lea	 ecx, DWORD PTR $T16030[ebp]
  00061	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16035:
  00067	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T16031[ebp]
  0006d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?ReplaceAll@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@1@Z:
  00073	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16037
  00078	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ReplaceAll@YL_StringUtil@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@1@Z ENDP ; YL_StringUtil::ReplaceAll
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?ComposeDirPath@YL_StringUtil@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@0@Z ; YL_StringUtil::ComposeDirPath
EXTRN	__imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
xdata$x	SEGMENT
$T16059	DD	0ffffffffH
	DD	FLAT:$L16052
	DD	00H
	DD	FLAT:$L16046
	DD	01H
	DD	FLAT:$L16047
	DD	01H
	DD	FLAT:$L16048
	DD	03H
	DD	FLAT:$L16049
	DD	03H
	DD	FLAT:$L16050
	DD	05H
	DD	FLAT:$L16051
	DD	03H
	DD	FLAT:$L16051
$T16056	DD	019930520H
	DD	08H
	DD	FLAT:$T16059
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv160 = -212						; size = 4
tv169 = -208						; size = 4
tv158 = -204						; size = 4
tv83 = -200						; size = 4
tv155 = -196						; size = 4
tv65 = -192						; size = 4
$T16053 = -188						; size = 4
$T16045 = -184						; size = 28
$T16044 = -156						; size = 28
$T16043 = -128						; size = 28
_strSrc2$ = -100					; size = 28
_strSrc1$ = -72						; size = 28
_strDes$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_strFront$ = 12						; size = 4
_strBehind$ = 16					; size = 4
?ComposeDirPath@YL_StringUtil@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@0@Z PROC NEAR ; YL_StringUtil::ComposeDirPath

; 137  : {

  00640	55		 push	 ebp
  00641	8b ec		 mov	 ebp, esp
  00643	6a ff		 push	 -1
  00645	68 00 00 00 00	 push	 __ehhandler$?ComposeDirPath@YL_StringUtil@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@0@Z
  0064a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00650	50		 push	 eax
  00651	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00658	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0065e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00663	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00666	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16053[ebp], 0

; 138  : 	string strSrc1 = strBehind;

  00670	8b 45 10	 mov	 eax, DWORD PTR _strBehind$[ebp]
  00673	50		 push	 eax
  00674	8d 4d b8	 lea	 ecx, DWORD PTR _strSrc1$[ebp]
  00677	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0067d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
$L11508:

; 139  : 	while( strSrc1.find("\\") == 0 )

  00684	6a 00		 push	 0
  00686	68 00 00 00 00	 push	 OFFSET FLAT:$SG11510
  0068b	8d 4d b8	 lea	 ecx, DWORD PTR _strSrc1$[ebp]
  0068e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
  00694	85 c0		 test	 eax, eax
  00696	75 4d		 jne	 SHORT $L11509

; 140  : 	{
; 141  : 		strSrc1 = strSrc1.substr( 1 );

  00698	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0069e	8b 11		 mov	 edx, DWORD PTR [ecx]
  006a0	52		 push	 edx
  006a1	6a 01		 push	 1
  006a3	8d 45 80	 lea	 eax, DWORD PTR $T16043[ebp]
  006a6	50		 push	 eax
  006a7	8d 4d b8	 lea	 ecx, DWORD PTR _strSrc1$[ebp]
  006aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  006b0	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  006b6	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  006bc	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv155[ebp], ecx
  006c2	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  006c6	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv155[ebp]
  006cc	52		 push	 edx
  006cd	8d 4d b8	 lea	 ecx, DWORD PTR _strSrc1$[ebp]
  006d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  006d6	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  006da	8d 4d 80	 lea	 ecx, DWORD PTR $T16043[ebp]
  006dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 142  : 	}

  006e3	eb 9f		 jmp	 SHORT $L11508
$L11509:

; 143  : 
; 144  : 	string strSrc2 = strFront;

  006e5	8b 45 0c	 mov	 eax, DWORD PTR _strFront$[ebp]
  006e8	50		 push	 eax
  006e9	8d 4d 9c	 lea	 ecx, DWORD PTR _strSrc2$[ebp]
  006ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  006f2	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
$L11514:

; 145  : 	while( strSrc2.find("\\",strSrc2.length() - 1) != string::npos )

  006f6	8d 4d 9c	 lea	 ecx, DWORD PTR _strSrc2$[ebp]
  006f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  006ff	83 e8 01	 sub	 eax, 1
  00702	50		 push	 eax
  00703	68 00 00 00 00	 push	 OFFSET FLAT:$SG11516
  00708	8d 4d 9c	 lea	 ecx, DWORD PTR _strSrc2$[ebp]
  0070b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
  00711	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  00717	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00719	74 57		 je	 SHORT $L11515

; 146  : 	{
; 147  : 		strSrc2 = strSrc2.substr( 0, strSrc2.length()-1 );

  0071b	8d 4d 9c	 lea	 ecx, DWORD PTR _strSrc2$[ebp]
  0071e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00724	83 e8 01	 sub	 eax, 1
  00727	50		 push	 eax
  00728	6a 00		 push	 0
  0072a	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T16044[ebp]
  00730	52		 push	 edx
  00731	8d 4d 9c	 lea	 ecx, DWORD PTR _strSrc2$[ebp]
  00734	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  0073a	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv83[ebp], eax
  00740	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv83[ebp]
  00746	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv158[ebp], eax
  0074c	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00750	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv158[ebp]
  00756	51		 push	 ecx
  00757	8d 4d 9c	 lea	 ecx, DWORD PTR _strSrc2$[ebp]
  0075a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00760	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00764	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T16044[ebp]
  0076a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 148  : 	}

  00770	eb 84		 jmp	 SHORT $L11514
$L11515:

; 149  : 
; 150  : 	string strDes = strSrc2 + "\\" + strSrc1;

  00772	68 00 00 00 00	 push	 OFFSET FLAT:$SG11521
  00777	8d 55 9c	 lea	 edx, DWORD PTR _strSrc2$[ebp]
  0077a	52		 push	 edx
  0077b	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T16045[ebp]
  00781	50		 push	 eax
  00782	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00787	83 c4 0c	 add	 esp, 12			; 0000000cH
  0078a	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv169[ebp], eax
  00790	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv169[ebp]
  00796	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv160[ebp], ecx
  0079c	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  007a0	8d 55 b8	 lea	 edx, DWORD PTR _strSrc1$[ebp]
  007a3	52		 push	 edx
  007a4	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv160[ebp]
  007aa	50		 push	 eax
  007ab	8d 4d d4	 lea	 ecx, DWORD PTR _strDes$[ebp]
  007ae	51		 push	 ecx
  007af	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  007b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  007b7	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  007bb	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T16045[ebp]
  007c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 151  : 	return strDes;

  007c7	8d 55 d4	 lea	 edx, DWORD PTR _strDes$[ebp]
  007ca	52		 push	 edx
  007cb	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  007ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  007d4	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR $T16053[ebp]
  007da	83 c8 01	 or	 eax, 1
  007dd	89 85 44 ff ff
	ff		 mov	 DWORD PTR $T16053[ebp], eax
  007e3	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  007e7	8d 4d d4	 lea	 ecx, DWORD PTR _strDes$[ebp]
  007ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  007f0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  007f4	8d 4d 9c	 lea	 ecx, DWORD PTR _strSrc2$[ebp]
  007f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  007fd	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00801	8d 4d b8	 lea	 ecx, DWORD PTR _strSrc1$[ebp]
  00804	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0080a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 152  : }

  0080d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00810	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00817	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0081f	8b e5		 mov	 esp, ebp
  00821	5d		 pop	 ebp
  00822	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L16046:
  0007d	8d 4d b8	 lea	 ecx, DWORD PTR _strSrc1$[ebp]
  00080	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16047:
  00086	8d 4d 80	 lea	 ecx, DWORD PTR $T16043[ebp]
  00089	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16048:
  0008f	8d 4d 9c	 lea	 ecx, DWORD PTR _strSrc2$[ebp]
  00092	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16049:
  00098	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T16044[ebp]
  0009e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16050:
  000a4	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T16045[ebp]
  000aa	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16051:
  000b0	8d 4d d4	 lea	 ecx, DWORD PTR _strDes$[ebp]
  000b3	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16052:
  000b9	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR $T16053[ebp]
  000bf	83 e0 01	 and	 eax, 1
  000c2	0f 84 10 00 00
	00		 je	 $L16054
  000c8	83 a5 44 ff ff
	ff fe		 and	 DWORD PTR $T16053[ebp], -2 ; fffffffeH
  000cf	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000d2	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16054:
  000d8	c3		 ret	 0
__ehhandler$?ComposeDirPath@YL_StringUtil@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@0@Z:
  000d9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16056
  000de	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ComposeDirPath@YL_StringUtil@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@0@Z ENDP ; YL_StringUtil::ComposeDirPath
PUBLIC	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
PUBLIC	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
PUBLIC	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
PUBLIC	?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
PUBLIC	?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T16062 = -8						; size = 4
$T16061 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0000a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
  00012	8b f0		 mov	 esi, eax
  00014	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
  0001c	3b f0		 cmp	 esi, eax
  0001e	73 1d		 jae	 SHORT $L12718

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	50		 push	 eax
  00024	6a 01		 push	 1
  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	52		 push	 edx
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  0003b	eb 1f		 jmp	 SHORT $L12717
$L12718:

; 583  : 			insert(end(), _Val);

  0003d	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00040	52		 push	 edx
  00041	8d 45 fc	 lea	 eax, DWORD PTR $T16061[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	51		 push	 ecx
  00050	8d 55 f8	 lea	 edx, DWORD PTR $T16062[ebp]
  00053	52		 push	 edx
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
$L12717:

; 584  : 		}

  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; Function compile flags: /Odt
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 745  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L16067
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L16068
$L16067:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L16068:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L16073
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L16074
$L16073:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L16074:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
PUBLIC	?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
PUBLIC	??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+
PUBLIC	??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator-
; Function compile flags: /Odt
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
_this$ = -16						; size = 4
$T16080 = -12						; size = 4
$T16077 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
  00011	85 c0		 test	 eax, eax
  00013	75 09		 jne	 SHORT $L16078
  00015	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0001c	eb 18		 jmp	 SHORT $L16079
$L16078:
  0001e	8d 45 f8	 lea	 eax, DWORD PTR $T16077[ebp]
  00021	50		 push	 eax
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
  0002a	50		 push	 eax
  0002b	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002e	e8 00 00 00 00	 call	 ??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator-
  00033	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$L16079:
  00036	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00039	89 4d fc	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0003c	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0003f	52		 push	 edx
  00040	6a 01		 push	 1
  00042	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00045	50		 push	 eax
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n

; 623  : 		return (begin() + _Off);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	52		 push	 edx
  00056	8d 45 f4	 lea	 eax, DWORD PTR $T16080[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+
  00069	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 3c		 je	 SHORT $L13791

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	8b c1		 mov	 eax, ecx
  00034	99		 cdq
  00035	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0003a	f7 f9		 idiv	 ecx
  0003c	50		 push	 eax
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
$L13791:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
;	COMDAT ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00025	03 45 08	 add	 eax, DWORD PTR __Ptr$[ebp]

; 880  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ; std::copy_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16104	DD	0ffffffffH
	DD	FLAT:$L16099
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T16106	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L16096
$T16107	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L16098
$T16105	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T16106
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T16107
$T16101	DD	019930520H
	DD	05H
	DD	FLAT:$T16104
	DD	02H
	DD	FLAT:$T16105
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
tv244 = -80						; size = 4
tv65 = -76						; size = 4
tv89 = -72						; size = 4
_this$ = -68						; size = 4
__Oldend$14047 = -64					; size = 4
__Newvec$14026 = -60					; size = 4
__Ptr$14027 = -56					; size = 4
__Capacity$ = -52					; size = 4
__Tmp$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 40	 sub	 esp, 64			; 00000040H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00024	53		 push	 ebx
  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002a	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0002d	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00030	50		 push	 eax
  00031	8d 4d d0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 811  : 		size_type _Capacity = capacity();

  00041	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
  00049	89 45 cc	 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  0004c	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00050	75 05		 jne	 SHORT $L14020

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00052	e9 cf 02 00 00	 jmp	 $L14021
$L14020:
  00057	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
  0005f	8b f0		 mov	 esi, eax
  00061	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
  00069	2b c6		 sub	 eax, esi
  0006b	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0006e	73 0d		 jae	 SHORT $L14022

; 816  : 			_Xlen();	// result too long

  00070	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  00078	e9 a9 02 00 00	 jmp	 $L14021
$L14022:
  0007d	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
  00085	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00088	39 45 cc	 cmp	 DWORD PTR __Capacity$[ebp], eax
  0008b	0f 83 68 01 00
	00		 jae	 $L14024

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00091	8b 75 cc	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00094	d1 ee		 shr	 esi, 1
  00096	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
  0009e	2b c6		 sub	 eax, esi
  000a0	3b 45 cc	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  000a3	73 09		 jae	 SHORT $L16092
  000a5	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  000ac	eb 0b		 jmp	 SHORT $L16093
$L16092:
  000ae	8b 4d cc	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  000b1	d1 e9		 shr	 ecx, 1
  000b3	03 4d cc	 add	 ecx, DWORD PTR __Capacity$[ebp]
  000b6	89 4d b8	 mov	 DWORD PTR tv89[ebp], ecx
$L16093:
  000b9	8b 55 b8	 mov	 edx, DWORD PTR tv89[ebp]
  000bc	89 55 cc	 mov	 DWORD PTR __Capacity$[ebp], edx

; 821  : 			if (_Capacity < size() + _Count)

  000bf	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	e8 00 00 00 00	 call	 ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
  000c7	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000ca	39 45 cc	 cmp	 DWORD PTR __Capacity$[ebp], eax
  000cd	73 0e		 jae	 SHORT $L14025

; 822  : 				_Capacity = size() + _Count;

  000cf	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	e8 00 00 00 00	 call	 ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
  000d7	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000da	89 45 cc	 mov	 DWORD PTR __Capacity$[ebp], eax
$L14025:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000dd	8b 45 cc	 mov	 eax, DWORD PTR __Capacity$[ebp]
  000e0	50		 push	 eax
  000e1	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
  000e9	89 45 c4	 mov	 DWORD PTR __Newvec$14026[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  000ec	8b 4d c4	 mov	 ecx, DWORD PTR __Newvec$14026[ebp]
  000ef	89 4d c8	 mov	 DWORD PTR __Ptr$14027[ebp], ecx

; 825  : 
; 826  : 			_TRY_BEGIN

  000f2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000f6	8b 55 c4	 mov	 edx, DWORD PTR __Newvec$14026[ebp]
  000f9	52		 push	 edx
  000fa	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  000fd	50		 push	 eax
  000fe	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00104	52		 push	 edx
  00105	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	e8 00 00 00 00	 call	 ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  0010d	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  00110	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]
  00113	89 45 c8	 mov	 DWORD PTR __Ptr$14027[ebp], eax

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00116	8d 4d d0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00119	51		 push	 ecx
  0011a	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0011d	52		 push	 edx
  0011e	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$14027[ebp]
  00121	50		 push	 eax
  00122	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	e8 00 00 00 00	 call	 ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
  0012a	89 45 b0	 mov	 DWORD PTR tv244[ebp], eax
  0012d	8b 4d b0	 mov	 ecx, DWORD PTR tv244[ebp]
  00130	89 4d c8	 mov	 DWORD PTR __Ptr$14027[ebp], ecx

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00133	8b 55 c8	 mov	 edx, DWORD PTR __Ptr$14027[ebp]
  00136	52		 push	 edx
  00137	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0013a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0013d	51		 push	 ecx
  0013e	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00141	52		 push	 edx
  00142	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00145	e8 00 00 00 00	 call	 ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  0014a	eb 29		 jmp	 SHORT $L16095
$L16096:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  0014c	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$14027[ebp]
  0014f	50		 push	 eax
  00150	8b 4d c4	 mov	 ecx, DWORD PTR __Newvec$14026[ebp]
  00153	51		 push	 ecx
  00154	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00157	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  0015c	8b 55 cc	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0015f	52		 push	 edx
  00160	8b 45 c4	 mov	 eax, DWORD PTR __Newvec$14026[ebp]
  00163	50		 push	 eax
  00164	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 834  : 			_RERAISE;

  0016c	6a 00		 push	 0
  0016e	6a 00		 push	 0
  00170	e8 00 00 00 00	 call	 __CxxThrowException@8
$L16095:

; 835  : 			_CATCH_END

  00175	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 836  : 
; 837  : 			_Count += size();

  0017c	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0017f	e8 00 00 00 00	 call	 ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
  00184	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00187	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  0018a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0018d	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00191	74 3a		 je	 SHORT $L14034

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  00193	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00196	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00199	50		 push	 eax
  0019a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0019d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001a0	52		 push	 edx
  001a1	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  001a9	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  001ac	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001b2	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  001b5	99		 cdq
  001b6	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  001bb	f7 f9		 idiv	 ecx
  001bd	50		 push	 eax
  001be	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  001c1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001c4	50		 push	 eax
  001c5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c8	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
$L14034:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001cd	8b 4d cc	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  001d0	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  001d3	03 4d c4	 add	 ecx, DWORD PTR __Newvec$14026[ebp]
  001d6	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  001d9	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 844  : 			_Mylast = _Newvec + _Count;

  001dc	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001df	6b c0 1c	 imul	 eax, 28			; 0000001cH
  001e2	03 45 c4	 add	 eax, DWORD PTR __Newvec$14026[ebp]
  001e5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e8	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

  001eb	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  001ee	8b 45 c4	 mov	 eax, DWORD PTR __Newvec$14026[ebp]
  001f1	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001f4	e9 2d 01 00 00	 jmp	 $L14021
$L14024:
  001f9	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  001fc	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001ff	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  00202	99		 cdq
  00203	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00208	f7 f9		 idiv	 ecx
  0020a	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0020d	0f 83 af 00 00
	00		 jae	 $L14037

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00213	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00216	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00219	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  0021c	52		 push	 edx
  0021d	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00220	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00223	51		 push	 ecx
  00224	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00227	52		 push	 edx
  00228	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022b	e8 00 00 00 00	 call	 ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 851  : 
; 852  : 			_TRY_BEGIN

  00230	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  00234	8d 45 d0	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00237	50		 push	 eax
  00238	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0023e	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  00241	99		 cdq
  00242	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00247	f7 f9		 idiv	 ecx
  00249	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0024c	2b d0		 sub	 edx, eax
  0024e	52		 push	 edx
  0024f	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00252	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00255	51		 push	 ecx
  00256	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00259	e8 00 00 00 00	 call	 ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
  0025e	eb 28		 jmp	 SHORT $L16097
$L16098:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  00260	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00263	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00266	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00269	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0026c	52		 push	 edx
  0026d	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00270	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00273	03 4d 08	 add	 ecx, DWORD PTR __Where$[ebp]
  00276	51		 push	 ecx
  00277	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0027a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 857  : 			_RERAISE;

  0027f	6a 00		 push	 0
  00281	6a 00		 push	 0
  00283	e8 00 00 00 00	 call	 __CxxThrowException@8
$L16097:

; 858  : 			_CATCH_END

  00288	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 859  : 
; 860  : 			_Mylast += _Count;

  0028f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00292	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00295	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00298	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0029b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  002a1	8d 55 d0	 lea	 edx, DWORD PTR __Tmp$[ebp]
  002a4	52		 push	 edx
  002a5	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002a8	6b c0 1c	 imul	 eax, 28			; 0000001cH
  002ab	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ae	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002b1	2b d0		 sub	 edx, eax
  002b3	52		 push	 edx
  002b4	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  002b7	50		 push	 eax
  002b8	e8 00 00 00 00	 call	 ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  002bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002c0	eb 64		 jmp	 SHORT $L14021
$L14037:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  002c2	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002c8	89 55 c0	 mov	 DWORD PTR __Oldend$14047[ebp], edx

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002cb	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  002ce	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002d1	51		 push	 ecx
  002d2	8b 55 c0	 mov	 edx, DWORD PTR __Oldend$14047[ebp]
  002d5	52		 push	 edx
  002d6	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002d9	6b c0 1c	 imul	 eax, 28			; 0000001cH
  002dc	8b 4d c0	 mov	 ecx, DWORD PTR __Oldend$14047[ebp]
  002df	2b c8		 sub	 ecx, eax
  002e1	51		 push	 ecx
  002e2	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002e5	e8 00 00 00 00	 call	 ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  002ea	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  002ed	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  002f0	8b 45 c0	 mov	 eax, DWORD PTR __Oldend$14047[ebp]
  002f3	50		 push	 eax
  002f4	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002f7	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  002fa	8b 55 c0	 mov	 edx, DWORD PTR __Oldend$14047[ebp]
  002fd	2b d1		 sub	 edx, ecx
  002ff	52		 push	 edx
  00300	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 ??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ; std::copy_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00309	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  0030c	8d 4d d0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0030f	51		 push	 ecx
  00310	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00313	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00316	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  00319	52		 push	 edx
  0031a	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0031d	50		 push	 eax
  0031e	e8 00 00 00 00	 call	 ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00323	83 c4 0c	 add	 esp, 12			; 0000000cH
$L14021:

; 873  : 			}
; 874  : 		}

  00326	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0032d	8d 4d d0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00330	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16091:
  00336	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00339	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00340	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00343	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00348	5f		 pop	 edi
  00349	5e		 pop	 esi
  0034a	5b		 pop	 ebx
  0034b	8b e5		 mov	 esp, ebp
  0034d	5d		 pop	 ebp
  0034e	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16099:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16101
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+=
; Function compile flags: /Odt
;	COMDAT ??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator-
; Function compile flags: /Odt
;	COMDAT ??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T16118 = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR $T16118[ebp], ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR $T16118[ebp]
  00018	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator-

; 280  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
; Function compile flags: /Odt
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16129	DD	0ffffffffH
	DD	FLAT:$L16125
$T16127	DD	019930520H
	DD	01H
	DD	FLAT:$T16129
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T16124 = -80						; size = 28
$T16123 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T16124[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T16124[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T16123[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T16123[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L16122:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16125:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T16124[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16127
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16142	DD	0ffffffffH
	DD	FLAT:$L16137
$T16140	DD	019930520H
	DD	01H
	DD	FLAT:$T16142
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 20   : 		}

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16137:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16140
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odt
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 28   : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L4925
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L4925:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16156	DD	0ffffffffH
	DD	FLAT:$L16151
$T16154	DD	019930520H
	DD	01H
	DD	FLAT:$T16156
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16151:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16154
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L4991
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L4991:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 01		 add	 eax, DWORD PTR [ecx]
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	89 02		 mov	 DWORD PTR [edx], eax

; 257  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	99		 cdq
  00012	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00017	f7 f9		 idiv	 ecx

; 144  : 			}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator-
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16182	DD	0ffffffffH
	DD	FLAT:$L16177
$T16180	DD	019930520H
	DD	01H
	DD	FLAT:$T16182
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0003f	52		 push	 edx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16177:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16180
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc 49 92
	24 09		 mov	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L16187
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L16188
$L16187:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L16188:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T16199	DD	0ffffffffH
	DD	FLAT:$L16193
	DD	00H
	DD	FLAT:$L16192
$T16197	DD	019930520H
	DD	02H
	DD	FLAT:$T16199
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T16194 = -44						; size = 4
$T16191 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T16194[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T16191[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T16194[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T16194[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T16191[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16192:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T16191[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16193:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T16194[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L16195
  00015	83 65 d4 fe	 and	 DWORD PTR $T16194[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16195:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16197
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16212	DD	0ffffffffH
	DD	FLAT:$L16206
	DD	00H
	DD	FLAT:$L16205
$T16210	DD	019930520H
	DD	02H
	DD	FLAT:$T16212
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T16207 = -44						; size = 4
$T16204 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T16207[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T16204[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T16207[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T16207[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T16204[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16205:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T16204[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16206:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T16207[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L16208
  00015	83 65 d4 fe	 and	 DWORD PTR $T16207[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16208:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16210
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16225	DD	0ffffffffH
	DD	FLAT:$L16219
	DD	00H
	DD	FLAT:$L16218
$T16223	DD	019930520H
	DD	02H
	DD	FLAT:$T16225
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T16220 = -44						; size = 4
$T16217 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 1
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T16220[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00022	8a 45 0c	 mov	 al, BYTE PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	6a 01		 push	 1
  00028	8d 4d d8	 lea	 ecx, DWORD PTR $T16217[ebp]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
  00031	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  00034	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00037	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  0003a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00041	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00044	52		 push	 edx
  00045	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00058	8b 45 d4	 mov	 eax, DWORD PTR $T16220[ebp]
  0005b	83 c8 01	 or	 eax, 1
  0005e	89 45 d4	 mov	 DWORD PTR $T16220[ebp], eax
  00061	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00065	8d 4d d8	 lea	 ecx, DWORD PTR $T16217[ebp]
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16218:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T16217[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16219:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T16220[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L16221
  00015	83 65 d4 fe	 and	 DWORD PTR $T16220[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16221:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16223
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16238	DD	0ffffffffH
	DD	FLAT:$L16232
	DD	00H
	DD	FLAT:$L16231
$T16236	DD	019930520H
	DD	02H
	DD	FLAT:$T16238
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T16233 = -44						; size = 4
$T16230 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T16233[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T16230[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T16233[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T16233[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T16230[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16231:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T16230[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16232:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T16233[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L16234
  00015	83 65 d4 fe	 and	 DWORD PTR $T16233[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16234:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16236
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16251	DD	0ffffffffH
	DD	FLAT:$L16245
	DD	00H
	DD	FLAT:$L16244
$T16249	DD	019930520H
	DD	02H
	DD	FLAT:$T16251
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T16246 = -44						; size = 4
$T16243 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T16246[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T16243[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8a 55 10	 mov	 dl, BYTE PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T16246[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T16246[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T16243[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16244:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T16243[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16245:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T16246[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L16247
  00015	83 65 d4 fe	 and	 DWORD PTR $T16246[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L16247:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16249
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16264	DD	0ffffffffH
	DD	FLAT:$L16258
	DD	00H
	DD	FLAT:$L16257
$T16262	DD	019930520H
	DD	02H
	DD	FLAT:$T16264
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T16259 = -44						; size = 4
$T16256 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T16259[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T16256[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T16259[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T16259[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T16256[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16257:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T16256[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L16258:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T16259[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L16260
  00015	83 65 d4 fe	 and	 DWORD PTR $T16259[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L16260:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16262
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16277	DD	0ffffffffH
	DD	FLAT:$L16271
	DD	00H
	DD	FLAT:$L16270
$T16275	DD	019930520H
	DD	02H
	DD	FLAT:$T16277
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T16272 = -44						; size = 4
$T16269 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T16272[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T16269[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T16272[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T16272[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T16269[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16270:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T16269[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L16271:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T16272[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L16273
  00015	83 65 d4 fe	 and	 DWORD PTR $T16272[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L16273:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16275
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16290	DD	0ffffffffH
	DD	FLAT:$L16284
	DD	00H
	DD	FLAT:$L16283
$T16288	DD	019930520H
	DD	02H
	DD	FLAT:$T16290
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T16285 = -44						; size = 4
$T16282 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 2
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T16285[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00022	66 8b 45 0c	 mov	 ax, WORD PTR __Left$[ebp]
  00026	50		 push	 eax
  00027	6a 01		 push	 1
  00029	8d 4d d8	 lea	 ecx, DWORD PTR $T16282[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
  00032	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  00035	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00038	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  0003b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00042	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00045	52		 push	 edx
  00046	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00059	8b 45 d4	 mov	 eax, DWORD PTR $T16285[ebp]
  0005c	83 c8 01	 or	 eax, 1
  0005f	89 45 d4	 mov	 DWORD PTR $T16285[ebp], eax
  00062	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00066	8d 4d d8	 lea	 ecx, DWORD PTR $T16282[ebp]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16283:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T16282[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L16284:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T16285[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L16286
  00015	83 65 d4 fe	 and	 DWORD PTR $T16285[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L16286:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16288
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16303	DD	0ffffffffH
	DD	FLAT:$L16297
	DD	00H
	DD	FLAT:$L16296
$T16301	DD	019930520H
	DD	02H
	DD	FLAT:$T16303
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T16298 = -44						; size = 4
$T16295 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T16298[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T16295[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T16298[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T16298[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T16295[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16296:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T16295[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L16297:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T16298[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L16299
  00015	83 65 d4 fe	 and	 DWORD PTR $T16298[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L16299:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16301
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16316	DD	0ffffffffH
	DD	FLAT:$L16310
	DD	00H
	DD	FLAT:$L16309
$T16314	DD	019930520H
	DD	02H
	DD	FLAT:$T16316
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T16311 = -44						; size = 4
$T16308 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 2
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T16311[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T16308[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	66 8b 55 10	 mov	 dx, WORD PTR __Right$[ebp]
  00043	52		 push	 edx
  00044	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00057	8b 45 d4	 mov	 eax, DWORD PTR $T16311[ebp]
  0005a	83 c8 01	 or	 eax, 1
  0005d	89 45 d4	 mov	 DWORD PTR $T16311[ebp], eax
  00060	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00064	8d 4d d8	 lea	 ecx, DWORD PTR $T16308[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16309:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T16308[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L16310:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T16311[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L16312
  00015	83 65 d4 fe	 and	 DWORD PTR $T16311[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L16312:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16314
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?to_char_type@?$char_traits@D@std@@SADABH@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@D@std@@SAHXZ:NEAR
EXTRN	__imp_?is@?$ctype@D@std@@QBE_NFD@Z:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_??1locale@std@@QAE@XZ:NEAR
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z:NEAR
EXTRN	__imp_?width@ios_base@std@@QBEHXZ:NEAR
EXTRN	__imp_?width@ios_base@std@@QAEHH@Z:NEAR
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:NEAR
EXTRN	__imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16333	DD	0ffffffffH
	DD	FLAT:$L16328
	DD	00H
	DD	FLAT:$L16329
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T16335	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L16327
$T16334	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T16335
$T16331	DD	019930520H
	DD	04H
	DD	FLAT:$T16333
	DD	01H
	DD	FLAT:$T16334
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv205 = -112						; size = 1
tv204 = -111						; size = 1
tv203 = -110						; size = 1
tv202 = -109						; size = 1
tv201 = -108						; size = 4
tv200 = -104						; size = 4
tv199 = -100						; size = 4
tv198 = -96						; size = 4
tv197 = -92						; size = 4
tv196 = -88						; size = 4
tv135 = -84						; size = 4
tv195 = -80						; size = 4
tv194 = -76						; size = 4
tv193 = -72						; size = 4
tv192 = -68						; size = 4
tv189 = -64						; size = 4
tv65 = -60						; size = 4
$T16325 = -56						; size = 4
$T16324 = -52						; size = 4
$T16321 = -48						; size = 4
__Meta$14467 = -44					; size = 4
__Size$14464 = -40					; size = 4
__Ctype_fac$14461 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 dc 01 00
	00		 je	 $L16326

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00055	8d 55 d0	 lea	 edx, DWORD PTR $T16321[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00061	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00064	8b ca		 mov	 ecx, edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0006c	89 45 c4	 mov	 DWORD PTR tv65[ebp], eax
  0006f	8b 45 c4	 mov	 eax, DWORD PTR tv65[ebp]
  00072	89 45 c0	 mov	 DWORD PTR tv189[ebp], eax
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00079	8b 4d c0	 mov	 ecx, DWORD PTR tv189[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 dc	 mov	 DWORD PTR __Ctype_fac$14461[ebp], eax
  00088	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0008c	8d 4d d0	 lea	 ecx, DWORD PTR $T16321[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	50		 push	 eax
  0009e	6a 00		 push	 0
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000a9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000be	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  000c1	83 7d bc 00	 cmp	 DWORD PTR tv192[ebp], 0
  000c5	7e 46		 jle	 SHORT $L16322
  000c7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000d2	8b ca		 mov	 ecx, edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000da	89 45 b8	 mov	 DWORD PTR tv193[ebp], eax
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  000e6	89 45 b4	 mov	 DWORD PTR tv194[ebp], eax
  000e9	8b 45 b8	 mov	 eax, DWORD PTR tv193[ebp]
  000ec	3b 45 b4	 cmp	 eax, DWORD PTR tv194[ebp]
  000ef	73 1c		 jae	 SHORT $L16322
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f9	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00102	89 45 b0	 mov	 DWORD PTR tv195[ebp], eax
  00105	8b 45 b0	 mov	 eax, DWORD PTR tv195[ebp]
  00108	89 45 ac	 mov	 DWORD PTR tv135[ebp], eax
  0010b	eb 12		 jmp	 SHORT $L16323
$L16322:
  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00116	89 45 a8	 mov	 DWORD PTR tv196[ebp], eax
  00119	8b 4d a8	 mov	 ecx, DWORD PTR tv196[ebp]
  0011c	89 4d ac	 mov	 DWORD PTR tv135[ebp], ecx
$L16323:
  0011f	8b 55 ac	 mov	 edx, DWORD PTR tv135[ebp]
  00122	89 55 d8	 mov	 DWORD PTR __Size$14464[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00125	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0012d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00130	8b ca		 mov	 ecx, edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00138	89 45 a4	 mov	 DWORD PTR tv197[ebp], eax
  0013b	8b 4d a4	 mov	 ecx, DWORD PTR tv197[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00144	89 45 a0	 mov	 DWORD PTR tv198[ebp], eax
  00147	8b 45 a0	 mov	 eax, DWORD PTR tv198[ebp]
  0014a	89 45 d4	 mov	 DWORD PTR __Meta$14467[ebp], eax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  0014d	eb 2f		 jmp	 SHORT $L14468
$L14469:
  0014f	8b 4d d8	 mov	 ecx, DWORD PTR __Size$14464[ebp]
  00152	83 e9 01	 sub	 ecx, 1
  00155	89 4d d8	 mov	 DWORD PTR __Size$14464[ebp], ecx
  00158	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0015b	8b 02		 mov	 eax, DWORD PTR [edx]
  0015d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00160	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00169	89 45 9c	 mov	 DWORD PTR tv199[ebp], eax
  0016c	8b 4d 9c	 mov	 ecx, DWORD PTR tv199[ebp]
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00175	89 45 98	 mov	 DWORD PTR tv200[ebp], eax
  00178	8b 4d 98	 mov	 ecx, DWORD PTR tv200[ebp]
  0017b	89 4d d4	 mov	 DWORD PTR __Meta$14467[ebp], ecx
$L14468:
  0017e	83 7d d8 00	 cmp	 DWORD PTR __Size$14464[ebp], 0
  00182	0f 86 8a 00 00
	00		 jbe	 $L14470

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0018e	89 45 94	 mov	 DWORD PTR tv201[ebp], eax
  00191	8b 55 94	 mov	 edx, DWORD PTR tv201[ebp]
  00194	89 55 cc	 mov	 DWORD PTR $T16324[ebp], edx
  00197	8d 45 d4	 lea	 eax, DWORD PTR __Meta$14467[ebp]
  0019a	50		 push	 eax
  0019b	8d 4d cc	 lea	 ecx, DWORD PTR $T16324[ebp]
  0019e	51		 push	 ecx
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  001a5	83 c4 08	 add	 esp, 8
  001a8	88 45 93	 mov	 BYTE PTR tv202[ebp], al
  001ab	0f b6 55 93	 movzx	 edx, BYTE PTR tv202[ebp]
  001af	85 d2		 test	 edx, edx
  001b1	74 0b		 je	 SHORT $L14472

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  001b3	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001b6	83 c8 01	 or	 eax, 1
  001b9	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  001bc	eb 54		 jmp	 SHORT $L14470
$L14472:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  001be	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$14467[ebp]
  001c1	51		 push	 ecx
  001c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  001c8	83 c4 04	 add	 esp, 4
  001cb	88 45 92	 mov	 BYTE PTR tv203[ebp], al
  001ce	8a 55 92	 mov	 dl, BYTE PTR tv203[ebp]
  001d1	52		 push	 edx
  001d2	6a 48		 push	 72			; 00000048H
  001d4	8b 4d dc	 mov	 ecx, DWORD PTR __Ctype_fac$14461[ebp]
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@D@std@@QBE_NFD@Z
  001dd	88 45 91	 mov	 BYTE PTR tv204[ebp], al
  001e0	0f b6 45 91	 movzx	 eax, BYTE PTR tv204[ebp]
  001e4	85 c0		 test	 eax, eax
  001e6	74 02		 je	 SHORT $L14474

; 454  : 				break;	// whitespace, quit

  001e8	eb 28		 jmp	 SHORT $L14470
$L14474:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  001ea	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$14467[ebp]
  001ed	51		 push	 ecx
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  001f4	83 c4 04	 add	 esp, 4
  001f7	88 45 90	 mov	 BYTE PTR tv205[ebp], al
  001fa	8a 55 90	 mov	 dl, BYTE PTR tv205[ebp]
  001fd	52		 push	 edx
  001fe	6a 01		 push	 1
  00200	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z

; 458  : 				_Changed = true;

  00209	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  0020d	e9 3d ff ff ff	 jmp	 $L14469
$L14470:
  00212	eb 1d		 jmp	 SHORT $L16326
$L16327:

; 460  : 		_CATCH_IO_(_Istr)

  00214	6a 01		 push	 1
  00216	6a 04		 push	 4
  00218	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0021b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00220	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00223	8b ca		 mov	 ecx, edx
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0022b	b8 00 00 00 00	 mov	 eax, $L16326
  00230	c3		 ret	 0
$L16326:
  00231	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  00238	6a 00		 push	 0
  0023a	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0023d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023f	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00242	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00245	8b ca		 mov	 ecx, edx
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z

; 464  : 	if (!_Changed)

  0024d	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  00251	85 c0		 test	 eax, eax
  00253	75 09		 jne	 SHORT $L14476

; 465  : 		_State |= ios_base::failbit;

  00255	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00258	83 c9 02	 or	 ecx, 2
  0025b	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L14476:

; 466  : 	_Istr.setstate(_State);

  0025e	6a 00		 push	 0
  00260	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00263	52		 push	 edx
  00264	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00267	8b 08		 mov	 ecx, DWORD PTR [eax]
  00269	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0026c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0026f	8b ca		 mov	 ecx, edx
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 467  : 	return (_Istr);

  00277	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0027a	89 45 c8	 mov	 DWORD PTR $T16325[ebp], eax
  0027d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00284	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00287	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0028c	8b 45 c8	 mov	 eax, DWORD PTR $T16325[ebp]

; 468  : 	}

  0028f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00292	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00299	5f		 pop	 edi
  0029a	5e		 pop	 esi
  0029b	5b		 pop	 ebx
  0029c	8b e5		 mov	 esp, ebp
  0029e	5d		 pop	 ebp
  0029f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16328:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
$L16329:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T16321[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16331
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T16347	DD	0ffffffffH
	DD	FLAT:$L16343
$T16345	DD	019930520H
	DD	01H
	DD	FLAT:$T16347
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0002f	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16343:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16345
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L12707

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L12707:

; 61   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L13768

; 54   : 				_Myistr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L13768:

; 55   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@@
PUBLIC	__CTA2?AVbad_cast@@
PUBLIC	??_R0?AVbad_cast@@@8				; bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
EXTRN	__imp_??0bad_cast@@QAE@PBD@Z:NEAR
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:NEAR
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:NEAR
EXTRN	??0bad_cast@@QAE@ABV0@@Z:NEAR			; bad_cast::bad_cast
EXTRN	??1bad_cast@@UAE@XZ:NEAR			; bad_cast::~bad_cast
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:NEAR
EXTRN	__imp_?_Incref@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Register@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16364	DD	0ffffffffH
	DD	FLAT:$L16360
$T16362	DD	019930520H
	DD	01H
	DD	FLAT:$T16364
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT
__TI2?AVbad_cast@@ DD 00H
	DD	FLAT:??1bad_cast@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@@@8 DD FLAT:??_7type_info@@6B@		; bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T16359 = -48						; size = 4
$T16358 = -44						; size = 12
__Pfmod$14390 = -32					; size = 4
__Psave$ = -28						; size = 4
__Lock$ = -24						; size = 4
__Id$ = -20						; size = 4
__Pf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<char> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 24	 sub	 esp, 36			; 00000024H

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	6a 00		 push	 0
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  00032	89 45 e4	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00041	89 45 ec	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00044	8b 4d ec	 mov	 ecx, DWORD PTR __Id$[ebp]
  00047	51		 push	 ecx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00051	89 45 f0	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00054	83 7d f0 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00058	74 02		 je	 SHORT $L14376

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  0005a	eb 62		 jmp	 SHORT $L14377
$L14376:
  0005c	83 7d e4 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  00060	74 08		 je	 SHORT $L14378

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00062	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  00065	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00068	eb 54		 jmp	 SHORT $L14377
$L14378:
  0006a	8d 45 e4	 lea	 eax, DWORD PTR __Psave$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
  00074	83 c4 04	 add	 esp, 4
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	75 1c		 jne	 SHORT $L14381

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  00081	8d 4d d4	 lea	 ecx, DWORD PTR $T16358[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  0008f	8d 4d d4	 lea	 ecx, DWORD PTR $T16358[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 __CxxThrowException@8
$L14381:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  00098	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  0009b	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Psave$[ebp]
  000a1	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000a6	8b 4d e4	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000a9	89 4d e0	 mov	 DWORD PTR __Pfmod$14390[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ac	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$14390[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$14390[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L14377:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000be	8b 55 f0	 mov	 edx, DWORD PTR __Pf$[ebp]
  000c1	89 55 d0	 mov	 DWORD PTR $T16359[ebp], edx
  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d4	8b 45 d0	 mov	 eax, DWORD PTR $T16359[ebp]
$L16357:

; 347  : 	}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16360:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16362
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00003	6a 0a		 push	 10			; 0000000aH
  00005	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0000d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00010	8b ca		 mov	 ecx, edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00018	50		 push	 eax
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z:NEAR
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16380	DD	0ffffffffH
	DD	FLAT:$L16376
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T16382	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L16375
$T16381	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T16382
$T16378	DD	019930520H
	DD	03H
	DD	FLAT:$T16380
	DD	01H
	DD	FLAT:$T16381
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
tv175 = -89						; size = 1
tv174 = -88						; size = 4
tv173 = -84						; size = 4
tv172 = -80						; size = 4
tv171 = -74						; size = 1
tv170 = -73						; size = 1
tv169 = -72						; size = 4
tv168 = -68						; size = 4
tv167 = -64						; size = 4
tv166 = -60						; size = 4
tv165 = -56						; size = 4
tv65 = -52						; size = 4
$T16373 = -48						; size = 4
$T16372 = -44						; size = 4
__Meta$14487 = -40					; size = 4
__Metadelim$14486 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 66 01 00
	00		 je	 $L16374

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  0006d	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z
  00077	83 c4 04	 add	 esp, 4
  0007a	89 45 cc	 mov	 DWORD PTR tv65[ebp], eax
  0007d	8b 55 cc	 mov	 edx, DWORD PTR tv65[ebp]
  00080	89 55 dc	 mov	 DWORD PTR __Metadelim$14486[ebp], edx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00083	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0008b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0008e	8b ca		 mov	 ecx, edx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00096	89 45 c8	 mov	 DWORD PTR tv165[ebp], eax
  00099	8b 4d c8	 mov	 ecx, DWORD PTR tv165[ebp]
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000a2	89 45 c4	 mov	 DWORD PTR tv166[ebp], eax
  000a5	8b 45 c4	 mov	 eax, DWORD PTR tv166[ebp]
  000a8	89 45 d8	 mov	 DWORD PTR __Meta$14487[ebp], eax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000ab	eb 26		 jmp	 SHORT $L14488
$L14489:
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000be	89 45 c0	 mov	 DWORD PTR tv167[ebp], eax
  000c1	8b 4d c0	 mov	 ecx, DWORD PTR tv167[ebp]
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000ca	89 45 bc	 mov	 DWORD PTR tv168[ebp], eax
  000cd	8b 45 bc	 mov	 eax, DWORD PTR tv168[ebp]
  000d0	89 45 d8	 mov	 DWORD PTR __Meta$14487[ebp], eax
$L14488:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  000d9	89 45 b8	 mov	 DWORD PTR tv169[ebp], eax
  000dc	8b 4d b8	 mov	 ecx, DWORD PTR tv169[ebp]
  000df	89 4d d4	 mov	 DWORD PTR $T16372[ebp], ecx
  000e2	8d 55 d8	 lea	 edx, DWORD PTR __Meta$14487[ebp]
  000e5	52		 push	 edx
  000e6	8d 45 d4	 lea	 eax, DWORD PTR $T16372[ebp]
  000e9	50		 push	 eax
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  000f0	83 c4 08	 add	 esp, 8
  000f3	88 45 b7	 mov	 BYTE PTR tv170[ebp], al
  000f6	0f b6 4d b7	 movzx	 ecx, BYTE PTR tv170[ebp]
  000fa	85 c9		 test	 ecx, ecx
  000fc	74 0e		 je	 SHORT $L14492

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  000fe	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00101	83 ca 01	 or	 edx, 1
  00104	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  00107	e9 92 00 00 00	 jmp	 $L14490
$L14492:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  0010c	8d 45 dc	 lea	 eax, DWORD PTR __Metadelim$14486[ebp]
  0010f	50		 push	 eax
  00110	8d 4d d8	 lea	 ecx, DWORD PTR __Meta$14487[ebp]
  00113	51		 push	 ecx
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  0011a	83 c4 08	 add	 esp, 8
  0011d	88 45 b6	 mov	 BYTE PTR tv171[ebp], al
  00120	0f b6 55 b6	 movzx	 edx, BYTE PTR tv171[ebp]
  00124	85 d2		 test	 edx, edx
  00126	74 25		 je	 SHORT $L14494

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00128	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  0012c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00134	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00137	8b ca		 mov	 ecx, edx
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0013f	89 45 b0	 mov	 DWORD PTR tv172[ebp], eax
  00142	8b 4d b0	 mov	 ecx, DWORD PTR tv172[ebp]
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ

; 501  : 				break;

  0014b	eb 51		 jmp	 SHORT $L14490
$L14494:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  0014d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00156	89 45 ac	 mov	 DWORD PTR tv173[ebp], eax
  00159	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00162	89 45 a8	 mov	 DWORD PTR tv174[ebp], eax
  00165	8b 45 ac	 mov	 eax, DWORD PTR tv173[ebp]
  00168	3b 45 a8	 cmp	 eax, DWORD PTR tv174[ebp]
  0016b	77 0b		 ja	 SHORT $L14496

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  0016d	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00170	83 c9 02	 or	 ecx, 2
  00173	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  00176	eb 26		 jmp	 SHORT $L14490
$L14496:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  00178	8d 55 d8	 lea	 edx, DWORD PTR __Meta$14487[ebp]
  0017b	52		 push	 edx
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  00182	83 c4 04	 add	 esp, 4
  00185	88 45 a7	 mov	 BYTE PTR tv175[ebp], al
  00188	8a 45 a7	 mov	 al, BYTE PTR tv175[ebp]
  0018b	50		 push	 eax
  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z

; 511  : 				_Changed = true;

  00195	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  00199	e9 0f ff ff ff	 jmp	 $L14489
$L14490:
  0019e	eb 1b		 jmp	 SHORT $L16374
$L16375:

; 513  : 		_CATCH_IO_(_Istr)

  001a0	6a 01		 push	 1
  001a2	6a 04		 push	 4
  001a4	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a9	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001ac	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001b5	b8 00 00 00 00	 mov	 eax, $L16374
  001ba	c3		 ret	 0
$L16374:
  001bb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  001c2	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $L14498

; 517  : 		_State |= ios_base::failbit;

  001ca	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001cd	83 c9 02	 or	 ecx, 2
  001d0	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L14498:

; 518  : 	_Istr.setstate(_State);

  001d3	6a 00		 push	 0
  001d5	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001d8	52		 push	 edx
  001d9	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001de	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001e1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001e4	8b ca		 mov	 ecx, edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 519  : 	return (_Istr);

  001ec	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001ef	89 45 d0	 mov	 DWORD PTR $T16373[ebp], eax
  001f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001f9	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  001fc	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00201	8b 45 d0	 mov	 eax, DWORD PTR $T16373[ebp]

; 520  : 	}

  00204	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00207	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	5b		 pop	 ebx
  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16376:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16378
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z:NEAR
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:NEAR
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:NEAR
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16402	DD	0ffffffffH
	DD	FLAT:$L16398
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T16404	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L16397
$T16403	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T16404
$T16400	DD	019930520H
	DD	03H
	DD	FLAT:$T16402
	DD	01H
	DD	FLAT:$T16403
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv221 = -129						; size = 1
tv220 = -128						; size = 4
tv219 = -124						; size = 4
tv218 = -120						; size = 4
tv217 = -114						; size = 1
tv216 = -113						; size = 1
tv215 = -112						; size = 4
tv214 = -108						; size = 4
tv213 = -104						; size = 4
tv212 = -100						; size = 4
tv211 = -93						; size = 1
tv210 = -92						; size = 4
tv209 = -88						; size = 4
tv208 = -84						; size = 4
tv207 = -77						; size = 1
tv83 = -76						; size = 4
tv81 = -72						; size = 4
$T16395 = -68						; size = 4
$T16394 = -64						; size = 4
$T16393 = -60						; size = 4
$T16392 = -56						; size = 4
$T16391 = -52						; size = 4
$T16390 = -48						; size = 4
$T16389 = -44						; size = 4
__Count$14521 = -40					; size = 4
__Size$ = -36						; size = 4
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 74	 sub	 esp, 116		; 00000074H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00032	89 45 dc	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0003d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00040	8b ca		 mov	 ecx, edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00048	85 c0		 test	 eax, eax
  0004a	7e 33		 jle	 SHORT $L16387
  0004c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00054	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00057	8b ca		 mov	 ecx, edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0005f	3b 45 dc	 cmp	 eax, DWORD PTR __Size$[ebp]
  00062	76 1b		 jbe	 SHORT $L16387
  00064	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00077	2b 45 dc	 sub	 eax, DWORD PTR __Size$[ebp]
  0007a	89 45 b8	 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 07		 jmp	 SHORT $L16388
$L16387:
  0007f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L16388:
  00086	8b 45 b8	 mov	 eax, DWORD PTR tv81[ebp]
  00089	89 45 e8	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008f	51		 push	 ecx
  00090	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00093	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  0009f	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000a2	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000a7	0f b6 d0	 movzx	 edx, al
  000aa	85 d2		 test	 edx, edx
  000ac	75 0e		 jne	 SHORT $L14510

; 550  : 		_State |= ios_base::badbit;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000b1	83 c8 04	 or	 eax, 4
  000b4	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000b7	e9 22 02 00 00	 jmp	 $L16396
$L14510:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  000d1	89 45 b4	 mov	 DWORD PTR tv83[ebp], eax
  000d4	8b 45 b4	 mov	 eax, DWORD PTR tv83[ebp]
  000d7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000dc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000df	0f 84 8a 00 00
	00		 je	 $L14513

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000e5	eb 09		 jmp	 SHORT $L14514
$L14515:
  000e7	8b 4d e8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  000ea	83 e9 01	 sub	 ecx, 1
  000ed	89 4d e8	 mov	 DWORD PTR __Pad$[ebp], ecx
$L14514:
  000f0	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  000f4	76 79		 jbe	 SHORT $L14513

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  000f6	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000f9	8b 02		 mov	 eax, DWORD PTR [edx]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000fe	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  00107	88 45 b3	 mov	 BYTE PTR tv207[ebp], al
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0010d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00112	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0011b	89 45 ac	 mov	 DWORD PTR tv208[ebp], eax
  0011e	8a 45 b3	 mov	 al, BYTE PTR tv207[ebp]
  00121	50		 push	 eax
  00122	8b 4d ac	 mov	 ecx, DWORD PTR tv208[ebp]
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0012b	89 45 a8	 mov	 DWORD PTR tv209[ebp], eax
  0012e	8b 4d a8	 mov	 ecx, DWORD PTR tv209[ebp]
  00131	89 4d d4	 mov	 DWORD PTR $T16389[ebp], ecx
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0013a	89 45 a4	 mov	 DWORD PTR tv210[ebp], eax
  0013d	8b 55 a4	 mov	 edx, DWORD PTR tv210[ebp]
  00140	89 55 d0	 mov	 DWORD PTR $T16390[ebp], edx
  00143	8d 45 d4	 lea	 eax, DWORD PTR $T16389[ebp]
  00146	50		 push	 eax
  00147	8d 4d d0	 lea	 ecx, DWORD PTR $T16390[ebp]
  0014a	51		 push	 ecx
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00151	83 c4 08	 add	 esp, 8
  00154	88 45 a3	 mov	 BYTE PTR tv211[ebp], al
  00157	0f b6 55 a3	 movzx	 edx, BYTE PTR tv211[ebp]
  0015b	85 d2		 test	 edx, edx
  0015d	74 0b		 je	 SHORT $L14519

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  0015f	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00162	83 c8 04	 or	 eax, 4
  00165	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  00168	eb 05		 jmp	 SHORT $L14513
$L14519:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  0016a	e9 78 ff ff ff	 jmp	 $L14515
$L14513:
  0016f	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00173	0f 85 91 00 00
	00		 jne	 $L14520

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00179	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Count$14521[ebp], 0
  00180	eb 09		 jmp	 SHORT $L14522
$L14523:
  00182	8b 4d d8	 mov	 ecx, DWORD PTR __Count$14521[ebp]
  00185	83 c1 01	 add	 ecx, 1
  00188	89 4d d8	 mov	 DWORD PTR __Count$14521[ebp], ecx
$L14522:
  0018b	8b 55 d8	 mov	 edx, DWORD PTR __Count$14521[ebp]
  0018e	3b 55 dc	 cmp	 edx, DWORD PTR __Size$[ebp]
  00191	73 77		 jae	 SHORT $L14520

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  00193	8b 45 d8	 mov	 eax, DWORD PTR __Count$14521[ebp]
  00196	50		 push	 eax
  00197	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
  001a0	89 45 9c	 mov	 DWORD PTR tv212[ebp], eax
  001a3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001ab	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001b4	89 45 98	 mov	 DWORD PTR tv213[ebp], eax
  001b7	8b 45 9c	 mov	 eax, DWORD PTR tv212[ebp]
  001ba	8a 08		 mov	 cl, BYTE PTR [eax]
  001bc	51		 push	 ecx
  001bd	8b 4d 98	 mov	 ecx, DWORD PTR tv213[ebp]
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  001c6	89 45 94	 mov	 DWORD PTR tv214[ebp], eax
  001c9	8b 55 94	 mov	 edx, DWORD PTR tv214[ebp]
  001cc	89 55 cc	 mov	 DWORD PTR $T16391[ebp], edx
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  001d5	89 45 90	 mov	 DWORD PTR tv215[ebp], eax
  001d8	8b 45 90	 mov	 eax, DWORD PTR tv215[ebp]
  001db	89 45 c8	 mov	 DWORD PTR $T16392[ebp], eax
  001de	8d 4d cc	 lea	 ecx, DWORD PTR $T16391[ebp]
  001e1	51		 push	 ecx
  001e2	8d 55 c8	 lea	 edx, DWORD PTR $T16392[ebp]
  001e5	52		 push	 edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  001ec	83 c4 08	 add	 esp, 8
  001ef	88 45 8f	 mov	 BYTE PTR tv216[ebp], al
  001f2	0f b6 45 8f	 movzx	 eax, BYTE PTR tv216[ebp]
  001f6	85 c0		 test	 eax, eax
  001f8	74 0b		 je	 SHORT $L14527

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  001fa	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001fd	83 c9 04	 or	 ecx, 4
  00200	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  00203	eb 05		 jmp	 SHORT $L14520
$L14527:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00205	e9 78 ff ff ff	 jmp	 $L14523
$L14520:
  0020a	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  0020e	0f 85 98 00 00
	00		 jne	 $L14528

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00214	eb 09		 jmp	 SHORT $L14529
$L14530:
  00216	8b 55 e8	 mov	 edx, DWORD PTR __Pad$[ebp]
  00219	83 ea 01	 sub	 edx, 1
  0021c	89 55 e8	 mov	 DWORD PTR __Pad$[ebp], edx
$L14529:
  0021f	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00223	0f 86 83 00 00
	00		 jbe	 $L14528

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  00229	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0022c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00231	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00234	8b ca		 mov	 ecx, edx
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0023c	88 45 8e	 mov	 BYTE PTR tv217[ebp], al
  0023f	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00242	8b 08		 mov	 ecx, DWORD PTR [eax]
  00244	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00247	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0024a	8b ca		 mov	 ecx, edx
  0024c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00252	89 45 88	 mov	 DWORD PTR tv218[ebp], eax
  00255	8a 45 8e	 mov	 al, BYTE PTR tv217[ebp]
  00258	50		 push	 eax
  00259	8b 4d 88	 mov	 ecx, DWORD PTR tv218[ebp]
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00262	89 45 84	 mov	 DWORD PTR tv219[ebp], eax
  00265	8b 4d 84	 mov	 ecx, DWORD PTR tv219[ebp]
  00268	89 4d c4	 mov	 DWORD PTR $T16393[ebp], ecx
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  00271	89 45 80	 mov	 DWORD PTR tv220[ebp], eax
  00274	8b 55 80	 mov	 edx, DWORD PTR tv220[ebp]
  00277	89 55 c0	 mov	 DWORD PTR $T16394[ebp], edx
  0027a	8d 45 c4	 lea	 eax, DWORD PTR $T16393[ebp]
  0027d	50		 push	 eax
  0027e	8d 4d c0	 lea	 ecx, DWORD PTR $T16394[ebp]
  00281	51		 push	 ecx
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00288	83 c4 08	 add	 esp, 8
  0028b	88 85 7f ff ff
	ff		 mov	 BYTE PTR tv221[ebp], al
  00291	0f b6 95 7f ff
	ff ff		 movzx	 edx, BYTE PTR tv221[ebp]
  00298	85 d2		 test	 edx, edx
  0029a	74 0b		 je	 SHORT $L14534

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  0029c	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0029f	83 c8 04	 or	 eax, 4
  002a2	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  002a5	eb 05		 jmp	 SHORT $L14528
$L14534:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  002a7	e9 6a ff ff ff	 jmp	 $L14530
$L14528:
  002ac	6a 00		 push	 0
  002ae	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  002b3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002b6	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  002bf	eb 1d		 jmp	 SHORT $L16396
$L16397:

; 581  : 		_CATCH_IO_(_Ostr)

  002c1	6a 01		 push	 1
  002c3	6a 04		 push	 4
  002c5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ca	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002cd	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002d0	8b ca		 mov	 ecx, edx
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  002d8	b8 00 00 00 00	 mov	 eax, $L16396
  002dd	c3		 ret	 0
$L16396:
  002de	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  002e5	6a 00		 push	 0
  002e7	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002ea	50		 push	 eax
  002eb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002f3	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 585  : 	return (_Ostr);

  002fc	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002ff	89 45 bc	 mov	 DWORD PTR $T16395[ebp], eax
  00302	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00309	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0030c	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00311	8b 45 bc	 mov	 eax, DWORD PTR $T16395[ebp]

; 586  : 	}

  00314	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00317	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0031e	5f		 pop	 edi
  0031f	5e		 pop	 esi
  00320	5b		 pop	 ebx
  00321	8b e5		 mov	 esp, ebp
  00323	5d		 pop	 ebp
  00324	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16398:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16400
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T16413	DD	0ffffffffH
	DD	FLAT:$L16409
$T16411	DD	019930520H
	DD	01H
	DD	FLAT:$T16413
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00037	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	74 30		 je	 SHORT $L13808
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  00058	85 c0		 test	 eax, eax
  0005a	74 1b		 je	 SHORT $L13808

; 90   : 				_Ostr.tie()->flush();

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b ca		 mov	 ecx, edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0006f	8b c8		 mov	 ecx, eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$L13808:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00077	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00082	8b ca		 mov	 ecx, edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16409:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16411
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:NEAR
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16422	DD	0ffffffffH
	DD	FLAT:$L16418
$T16420	DD	019930520H
	DD	01H
	DD	FLAT:$T16422
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0b		 jne	 SHORT $L13810

; 99   : 				this->_Myostr._Osfx();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$L13810:

; 100  : 			}

  0003b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16418:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16420
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L14096

; 70   : 				_Myostr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L14096:

; 71   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L14099

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L14099:

; 77   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@_W@std@@SAGXZ:NEAR
EXTRN	__imp_?is@?$ctype@_W@std@@QBE_NF_W@Z:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB:DWORD
EXTRN	__imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z:NEAR
EXTRN	__imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T16445	DD	0ffffffffH
	DD	FLAT:$L16440
	DD	00H
	DD	FLAT:$L16441
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T16447	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L16439
$T16446	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T16447
$T16443	DD	019930520H
	DD	04H
	DD	FLAT:$T16445
	DD	01H
	DD	FLAT:$T16446
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv205 = -112						; size = 2
tv204 = -109						; size = 1
tv203 = -108						; size = 2
tv202 = -105						; size = 1
tv201 = -104						; size = 2
tv200 = -102						; size = 2
tv199 = -100						; size = 4
tv198 = -94						; size = 2
tv197 = -92						; size = 4
tv196 = -88						; size = 4
tv135 = -84						; size = 4
tv195 = -80						; size = 4
tv194 = -76						; size = 4
tv193 = -72						; size = 4
tv192 = -68						; size = 4
tv189 = -64						; size = 4
tv65 = -60						; size = 4
$T16437 = -56						; size = 4
$T16436 = -50						; size = 2
$T16433 = -48						; size = 4
__Meta$14551 = -44					; size = 2
__Size$14548 = -40					; size = 4
__Ctype_fac$14545 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 e9 01 00
	00		 je	 $L16438

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00055	8d 55 d0	 lea	 edx, DWORD PTR $T16433[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00061	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00064	8b ca		 mov	 ecx, edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0006c	89 45 c4	 mov	 DWORD PTR tv65[ebp], eax
  0006f	8b 45 c4	 mov	 eax, DWORD PTR tv65[ebp]
  00072	89 45 c0	 mov	 DWORD PTR tv189[ebp], eax
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00079	8b 4d c0	 mov	 ecx, DWORD PTR tv189[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 dc	 mov	 DWORD PTR __Ctype_fac$14545[ebp], eax
  00088	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0008c	8d 4d d0	 lea	 ecx, DWORD PTR $T16433[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	50		 push	 eax
  0009e	6a 00		 push	 0
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000a9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000be	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  000c1	83 7d bc 00	 cmp	 DWORD PTR tv192[ebp], 0
  000c5	7e 46		 jle	 SHORT $L16434
  000c7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000d2	8b ca		 mov	 ecx, edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000da	89 45 b8	 mov	 DWORD PTR tv193[ebp], eax
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  000e6	89 45 b4	 mov	 DWORD PTR tv194[ebp], eax
  000e9	8b 45 b8	 mov	 eax, DWORD PTR tv193[ebp]
  000ec	3b 45 b4	 cmp	 eax, DWORD PTR tv194[ebp]
  000ef	73 1c		 jae	 SHORT $L16434
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f9	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00102	89 45 b0	 mov	 DWORD PTR tv195[ebp], eax
  00105	8b 45 b0	 mov	 eax, DWORD PTR tv195[ebp]
  00108	89 45 ac	 mov	 DWORD PTR tv135[ebp], eax
  0010b	eb 12		 jmp	 SHORT $L16435
$L16434:
  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00116	89 45 a8	 mov	 DWORD PTR tv196[ebp], eax
  00119	8b 4d a8	 mov	 ecx, DWORD PTR tv196[ebp]
  0011c	89 4d ac	 mov	 DWORD PTR tv135[ebp], ecx
$L16435:
  0011f	8b 55 ac	 mov	 edx, DWORD PTR tv135[ebp]
  00122	89 55 d8	 mov	 DWORD PTR __Size$14548[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00125	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0012d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00130	8b ca		 mov	 ecx, edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00138	89 45 a4	 mov	 DWORD PTR tv197[ebp], eax
  0013b	8b 4d a4	 mov	 ecx, DWORD PTR tv197[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  00144	66 89 45 a2	 mov	 WORD PTR tv198[ebp], ax
  00148	66 8b 45 a2	 mov	 ax, WORD PTR tv198[ebp]
  0014c	66 89 45 d4	 mov	 WORD PTR __Meta$14551[ebp], ax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  00150	eb 32		 jmp	 SHORT $L14552
$L14553:
  00152	8b 4d d8	 mov	 ecx, DWORD PTR __Size$14548[ebp]
  00155	83 e9 01	 sub	 ecx, 1
  00158	89 4d d8	 mov	 DWORD PTR __Size$14548[ebp], ecx
  0015b	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0015e	8b 02		 mov	 eax, DWORD PTR [edx]
  00160	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00163	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0016c	89 45 9c	 mov	 DWORD PTR tv199[ebp], eax
  0016f	8b 4d 9c	 mov	 ecx, DWORD PTR tv199[ebp]
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  00178	66 89 45 9a	 mov	 WORD PTR tv200[ebp], ax
  0017c	66 8b 4d 9a	 mov	 cx, WORD PTR tv200[ebp]
  00180	66 89 4d d4	 mov	 WORD PTR __Meta$14551[ebp], cx
$L14552:
  00184	83 7d d8 00	 cmp	 DWORD PTR __Size$14548[ebp], 0
  00188	0f 86 91 00 00
	00		 jbe	 $L14554

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00194	66 89 45 98	 mov	 WORD PTR tv201[ebp], ax
  00198	66 8b 55 98	 mov	 dx, WORD PTR tv201[ebp]
  0019c	66 89 55 ce	 mov	 WORD PTR $T16436[ebp], dx
  001a0	8d 45 d4	 lea	 eax, DWORD PTR __Meta$14551[ebp]
  001a3	50		 push	 eax
  001a4	8d 4d ce	 lea	 ecx, DWORD PTR $T16436[ebp]
  001a7	51		 push	 ecx
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  001ae	83 c4 08	 add	 esp, 8
  001b1	88 45 97	 mov	 BYTE PTR tv202[ebp], al
  001b4	0f b6 55 97	 movzx	 edx, BYTE PTR tv202[ebp]
  001b8	85 d2		 test	 edx, edx
  001ba	74 0b		 je	 SHORT $L14556

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  001bc	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001bf	83 c8 01	 or	 eax, 1
  001c2	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  001c5	eb 58		 jmp	 SHORT $L14554
$L14556:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  001c7	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$14551[ebp]
  001ca	51		 push	 ecx
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  001d1	83 c4 04	 add	 esp, 4
  001d4	66 89 45 94	 mov	 WORD PTR tv203[ebp], ax
  001d8	66 8b 55 94	 mov	 dx, WORD PTR tv203[ebp]
  001dc	52		 push	 edx
  001dd	6a 48		 push	 72			; 00000048H
  001df	8b 4d dc	 mov	 ecx, DWORD PTR __Ctype_fac$14545[ebp]
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z
  001e8	88 45 93	 mov	 BYTE PTR tv204[ebp], al
  001eb	0f b6 45 93	 movzx	 eax, BYTE PTR tv204[ebp]
  001ef	85 c0		 test	 eax, eax
  001f1	74 02		 je	 SHORT $L14558

; 454  : 				break;	// whitespace, quit

  001f3	eb 2a		 jmp	 SHORT $L14554
$L14558:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  001f5	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$14551[ebp]
  001f8	51		 push	 ecx
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  001ff	83 c4 04	 add	 esp, 4
  00202	66 89 45 90	 mov	 WORD PTR tv205[ebp], ax
  00206	66 8b 55 90	 mov	 dx, WORD PTR tv205[ebp]
  0020a	52		 push	 edx
  0020b	6a 01		 push	 1
  0020d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z

; 458  : 				_Changed = true;

  00216	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  0021a	e9 33 ff ff ff	 jmp	 $L14553
$L14554:
  0021f	eb 1d		 jmp	 SHORT $L16438
$L16439:

; 460  : 		_CATCH_IO_(_Istr)

  00221	6a 01		 push	 1
  00223	6a 04		 push	 4
  00225	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00228	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0022d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00230	8b ca		 mov	 ecx, edx
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  00238	b8 00 00 00 00	 mov	 eax, $L16438
  0023d	c3		 ret	 0
$L16438:
  0023e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  00245	6a 00		 push	 0
  00247	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0024a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024c	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0024f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00252	8b ca		 mov	 ecx, edx
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z

; 464  : 	if (!_Changed)

  0025a	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  0025e	85 c0		 test	 eax, eax
  00260	75 09		 jne	 SHORT $L14560

; 465  : 		_State |= ios_base::failbit;

  00262	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00265	83 c9 02	 or	 ecx, 2
  00268	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L14560:

; 466  : 	_Istr.setstate(_State);

  0026b	6a 00		 push	 0
  0026d	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00270	52		 push	 edx
  00271	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00274	8b 08		 mov	 ecx, DWORD PTR [eax]
  00276	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00279	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0027c	8b ca		 mov	 ecx, edx
  0027e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 467  : 	return (_Istr);

  00284	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00287	89 45 c8	 mov	 DWORD PTR $T16437[ebp], eax
  0028a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00291	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00294	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00299	8b 45 c8	 mov	 eax, DWORD PTR $T16437[ebp]

; 468  : 	}

  0029c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0029f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002a6	5f		 pop	 edi
  002a7	5e		 pop	 esi
  002a8	5b		 pop	 ebx
  002a9	8b e5		 mov	 esp, ebp
  002ab	5d		 pop	 ebp
  002ac	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16440:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
$L16441:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T16433[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16443
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T16459	DD	0ffffffffH
	DD	FLAT:$L16455
$T16457	DD	019930520H
	DD	01H
	DD	FLAT:$T16459
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0002f	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16455:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16457
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L12714

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L12714:

; 61   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L13771

; 54   : 				_Myistr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L13771:

; 55   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
EXTRN	__imp_?id@?$ctype@_W@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16476	DD	0ffffffffH
	DD	FLAT:$L16472
$T16474	DD	019930520H
	DD	01H
	DD	FLAT:$T16476
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T16471 = -48						; size = 4
$T16470 = -44						; size = 12
__Pfmod$14418 = -32					; size = 4
__Psave$ = -28						; size = 4
__Lock$ = -24						; size = 4
__Id$ = -20						; size = 4
__Pf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 24	 sub	 esp, 36			; 00000024H

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	6a 00		 push	 0
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  00032	89 45 e4	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@_W@std@@2V0locale@2@A
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00041	89 45 ec	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00044	8b 4d ec	 mov	 ecx, DWORD PTR __Id$[ebp]
  00047	51		 push	 ecx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00051	89 45 f0	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00054	83 7d f0 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00058	74 02		 je	 SHORT $L14409

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  0005a	eb 62		 jmp	 SHORT $L14410
$L14409:
  0005c	83 7d e4 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  00060	74 08		 je	 SHORT $L14411

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00062	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  00065	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00068	eb 54		 jmp	 SHORT $L14410
$L14411:
  0006a	8d 45 e4	 lea	 eax, DWORD PTR __Psave$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z
  00074	83 c4 04	 add	 esp, 4
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	75 1c		 jne	 SHORT $L14414

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  00081	8d 4d d4	 lea	 ecx, DWORD PTR $T16470[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  0008f	8d 4d d4	 lea	 ecx, DWORD PTR $T16470[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 __CxxThrowException@8
$L14414:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  00098	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  0009b	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Psave$[ebp]
  000a1	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000a6	8b 4d e4	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000a9	89 4d e0	 mov	 DWORD PTR __Pfmod$14418[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ac	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$14418[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$14418[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L14410:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000be	8b 55 f0	 mov	 edx, DWORD PTR __Pf$[ebp]
  000c1	89 55 d0	 mov	 DWORD PTR $T16471[ebp], edx
  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d4	8b 45 d0	 mov	 eax, DWORD PTR $T16471[ebp]
$L16469:

; 347  : 	}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16472:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16474
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00003	6a 0a		 push	 10			; 0000000aH
  00005	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0000d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00010	8b ca		 mov	 ecx, edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  00018	50		 push	 eax
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
EXTRN	__imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z:NEAR
EXTRN	__imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16492	DD	0ffffffffH
	DD	FLAT:$L16488
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T16494	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L16487
$T16493	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T16494
$T16490	DD	019930520H
	DD	03H
	DD	FLAT:$T16492
	DD	01H
	DD	FLAT:$T16493
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT
tv175 = -86						; size = 2
tv174 = -84						; size = 4
tv173 = -80						; size = 4
tv172 = -76						; size = 4
tv171 = -70						; size = 1
tv170 = -69						; size = 1
tv169 = -68						; size = 2
tv168 = -66						; size = 2
tv167 = -64						; size = 4
tv166 = -58						; size = 2
tv165 = -56						; size = 4
tv65 = -50						; size = 2
$T16485 = -48						; size = 4
$T16484 = -42						; size = 2
__Meta$14571 = -40					; size = 2
__Metadelim$14570 = -36					; size = 2
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 2
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 48	 sub	 esp, 72			; 00000048H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 74 01 00
	00		 je	 $L16486

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  0006d	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z
  00077	83 c4 04	 add	 esp, 4
  0007a	66 89 45 ce	 mov	 WORD PTR tv65[ebp], ax
  0007e	66 8b 55 ce	 mov	 dx, WORD PTR tv65[ebp]
  00082	66 89 55 dc	 mov	 WORD PTR __Metadelim$14570[ebp], dx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00086	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0008e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00091	8b ca		 mov	 ecx, edx
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00099	89 45 c8	 mov	 DWORD PTR tv165[ebp], eax
  0009c	8b 4d c8	 mov	 ecx, DWORD PTR tv165[ebp]
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000a5	66 89 45 c6	 mov	 WORD PTR tv166[ebp], ax
  000a9	66 8b 45 c6	 mov	 ax, WORD PTR tv166[ebp]
  000ad	66 89 45 d8	 mov	 WORD PTR __Meta$14571[ebp], ax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000b1	eb 29		 jmp	 SHORT $L14572
$L14573:
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000bb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  000c4	89 45 c0	 mov	 DWORD PTR tv167[ebp], eax
  000c7	8b 4d c0	 mov	 ecx, DWORD PTR tv167[ebp]
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000d0	66 89 45 be	 mov	 WORD PTR tv168[ebp], ax
  000d4	66 8b 45 be	 mov	 ax, WORD PTR tv168[ebp]
  000d8	66 89 45 d8	 mov	 WORD PTR __Meta$14571[ebp], ax
$L14572:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  000e2	66 89 45 bc	 mov	 WORD PTR tv169[ebp], ax
  000e6	66 8b 4d bc	 mov	 cx, WORD PTR tv169[ebp]
  000ea	66 89 4d d6	 mov	 WORD PTR $T16484[ebp], cx
  000ee	8d 55 d8	 lea	 edx, DWORD PTR __Meta$14571[ebp]
  000f1	52		 push	 edx
  000f2	8d 45 d6	 lea	 eax, DWORD PTR $T16484[ebp]
  000f5	50		 push	 eax
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  000fc	83 c4 08	 add	 esp, 8
  000ff	88 45 bb	 mov	 BYTE PTR tv170[ebp], al
  00102	0f b6 4d bb	 movzx	 ecx, BYTE PTR tv170[ebp]
  00106	85 c9		 test	 ecx, ecx
  00108	74 0e		 je	 SHORT $L14576

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  0010a	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  0010d	83 ca 01	 or	 edx, 1
  00110	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  00113	e9 94 00 00 00	 jmp	 $L14574
$L14576:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  00118	8d 45 dc	 lea	 eax, DWORD PTR __Metadelim$14570[ebp]
  0011b	50		 push	 eax
  0011c	8d 4d d8	 lea	 ecx, DWORD PTR __Meta$14571[ebp]
  0011f	51		 push	 ecx
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  00126	83 c4 08	 add	 esp, 8
  00129	88 45 ba	 mov	 BYTE PTR tv171[ebp], al
  0012c	0f b6 55 ba	 movzx	 edx, BYTE PTR tv171[ebp]
  00130	85 d2		 test	 edx, edx
  00132	74 25		 je	 SHORT $L14578

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00134	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  00138	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0013b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00140	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00143	8b ca		 mov	 ecx, edx
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0014b	89 45 b4	 mov	 DWORD PTR tv172[ebp], eax
  0014e	8b 4d b4	 mov	 ecx, DWORD PTR tv172[ebp]
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ

; 501  : 				break;

  00157	eb 53		 jmp	 SHORT $L14574
$L14578:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  00159	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00162	89 45 b0	 mov	 DWORD PTR tv173[ebp], eax
  00165	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  0016e	89 45 ac	 mov	 DWORD PTR tv174[ebp], eax
  00171	8b 45 b0	 mov	 eax, DWORD PTR tv173[ebp]
  00174	3b 45 ac	 cmp	 eax, DWORD PTR tv174[ebp]
  00177	77 0b		 ja	 SHORT $L14580

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  00179	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  0017c	83 c9 02	 or	 ecx, 2
  0017f	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  00182	eb 28		 jmp	 SHORT $L14574
$L14580:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  00184	8d 55 d8	 lea	 edx, DWORD PTR __Meta$14571[ebp]
  00187	52		 push	 edx
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  0018e	83 c4 04	 add	 esp, 4
  00191	66 89 45 aa	 mov	 WORD PTR tv175[ebp], ax
  00195	66 8b 45 aa	 mov	 ax, WORD PTR tv175[ebp]
  00199	50		 push	 eax
  0019a	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z

; 511  : 				_Changed = true;

  001a3	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  001a7	e9 07 ff ff ff	 jmp	 $L14573
$L14574:
  001ac	eb 1b		 jmp	 SHORT $L16486
$L16487:

; 513  : 		_CATCH_IO_(_Istr)

  001ae	6a 01		 push	 1
  001b0	6a 04		 push	 4
  001b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b7	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001ba	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  001c3	b8 00 00 00 00	 mov	 eax, $L16486
  001c8	c3		 ret	 0
$L16486:
  001c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  001d0	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  001d4	85 c0		 test	 eax, eax
  001d6	75 09		 jne	 SHORT $L14582

; 517  : 		_State |= ios_base::failbit;

  001d8	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001db	83 c9 02	 or	 ecx, 2
  001de	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L14582:

; 518  : 	_Istr.setstate(_State);

  001e1	6a 00		 push	 0
  001e3	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001e6	52		 push	 edx
  001e7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ec	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001ef	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001f2	8b ca		 mov	 ecx, edx
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 519  : 	return (_Istr);

  001fa	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001fd	89 45 d0	 mov	 DWORD PTR $T16485[ebp], eax
  00200	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00207	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0020a	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0020f	8b 45 d0	 mov	 eax, DWORD PTR $T16485[ebp]

; 520  : 	}

  00212	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00215	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0021c	5f		 pop	 edi
  0021d	5e		 pop	 esi
  0021e	5b		 pop	 ebx
  0021f	8b e5		 mov	 esp, ebp
  00221	5d		 pop	 ebp
  00222	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16488:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
__ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16490
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z:NEAR
EXTRN	__imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z:NEAR
EXTRN	__imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16514	DD	0ffffffffH
	DD	FLAT:$L16510
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T16516	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L16509
$T16515	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T16516
$T16512	DD	019930520H
	DD	03H
	DD	FLAT:$T16514
	DD	01H
	DD	FLAT:$T16515
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv221 = -105						; size = 1
tv220 = -104						; size = 2
tv219 = -102						; size = 2
tv218 = -100						; size = 4
tv217 = -96						; size = 2
tv216 = -93						; size = 1
tv215 = -92						; size = 2
tv214 = -90						; size = 2
tv213 = -88						; size = 4
tv212 = -84						; size = 4
tv211 = -77						; size = 1
tv210 = -76						; size = 2
tv209 = -74						; size = 2
tv208 = -72						; size = 4
tv207 = -66						; size = 2
tv83 = -64						; size = 4
tv81 = -60						; size = 4
$T16507 = -56						; size = 4
$T16506 = -52						; size = 2
$T16505 = -50						; size = 2
$T16504 = -48						; size = 2
$T16503 = -46						; size = 2
$T16502 = -44						; size = 2
$T16501 = -42						; size = 2
__Count$14605 = -40					; size = 4
__Size$ = -36						; size = 4
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00032	89 45 dc	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0003d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00040	8b ca		 mov	 ecx, edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00048	85 c0		 test	 eax, eax
  0004a	7e 33		 jle	 SHORT $L16499
  0004c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00054	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00057	8b ca		 mov	 ecx, edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0005f	3b 45 dc	 cmp	 eax, DWORD PTR __Size$[ebp]
  00062	76 1b		 jbe	 SHORT $L16499
  00064	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00077	2b 45 dc	 sub	 eax, DWORD PTR __Size$[ebp]
  0007a	89 45 c4	 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 07		 jmp	 SHORT $L16500
$L16499:
  0007f	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L16500:
  00086	8b 45 c4	 mov	 eax, DWORD PTR tv81[ebp]
  00089	89 45 e8	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008f	51		 push	 ecx
  00090	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00093	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  0009f	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000a2	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  000a7	0f b6 d0	 movzx	 edx, al
  000aa	85 d2		 test	 edx, edx
  000ac	75 0e		 jne	 SHORT $L14594

; 550  : 		_State |= ios_base::badbit;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000b1	83 c8 04	 or	 eax, 4
  000b4	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000b7	e9 37 02 00 00	 jmp	 $L16508
$L14594:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  000d1	89 45 c0	 mov	 DWORD PTR tv83[ebp], eax
  000d4	8b 45 c0	 mov	 eax, DWORD PTR tv83[ebp]
  000d7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000dc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000df	0f 84 96 00 00
	00		 je	 $L14597

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000e5	eb 09		 jmp	 SHORT $L14598
$L14599:
  000e7	8b 4d e8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  000ea	83 e9 01	 sub	 ecx, 1
  000ed	89 4d e8	 mov	 DWORD PTR __Pad$[ebp], ecx
$L14598:
  000f0	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  000f4	0f 86 81 00 00
	00		 jbe	 $L14597

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  000fa	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00102	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  0010b	66 89 45 be	 mov	 WORD PTR tv207[ebp], ax
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00117	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00120	89 45 b8	 mov	 DWORD PTR tv208[ebp], eax
  00123	66 8b 45 be	 mov	 ax, WORD PTR tv207[ebp]
  00127	50		 push	 eax
  00128	8b 4d b8	 mov	 ecx, DWORD PTR tv208[ebp]
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00131	66 89 45 b6	 mov	 WORD PTR tv209[ebp], ax
  00135	66 8b 4d b6	 mov	 cx, WORD PTR tv209[ebp]
  00139	66 89 4d d6	 mov	 WORD PTR $T16501[ebp], cx
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00143	66 89 45 b4	 mov	 WORD PTR tv210[ebp], ax
  00147	66 8b 55 b4	 mov	 dx, WORD PTR tv210[ebp]
  0014b	66 89 55 d4	 mov	 WORD PTR $T16502[ebp], dx
  0014f	8d 45 d6	 lea	 eax, DWORD PTR $T16501[ebp]
  00152	50		 push	 eax
  00153	8d 4d d4	 lea	 ecx, DWORD PTR $T16502[ebp]
  00156	51		 push	 ecx
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  0015d	83 c4 08	 add	 esp, 8
  00160	88 45 b3	 mov	 BYTE PTR tv211[ebp], al
  00163	0f b6 55 b3	 movzx	 edx, BYTE PTR tv211[ebp]
  00167	85 d2		 test	 edx, edx
  00169	74 0b		 je	 SHORT $L14603

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  0016b	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0016e	83 c8 04	 or	 eax, 4
  00171	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  00174	eb 05		 jmp	 SHORT $L14597
$L14603:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  00176	e9 6c ff ff ff	 jmp	 $L14599
$L14597:
  0017b	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  0017f	0f 85 98 00 00
	00		 jne	 $L14604

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00185	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Count$14605[ebp], 0
  0018c	eb 09		 jmp	 SHORT $L14606
$L14607:
  0018e	8b 4d d8	 mov	 ecx, DWORD PTR __Count$14605[ebp]
  00191	83 c1 01	 add	 ecx, 1
  00194	89 4d d8	 mov	 DWORD PTR __Count$14605[ebp], ecx
$L14606:
  00197	8b 55 d8	 mov	 edx, DWORD PTR __Count$14605[ebp]
  0019a	3b 55 dc	 cmp	 edx, DWORD PTR __Size$[ebp]
  0019d	73 7e		 jae	 SHORT $L14604

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  0019f	8b 45 d8	 mov	 eax, DWORD PTR __Count$14605[ebp]
  001a2	50		 push	 eax
  001a3	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z
  001ac	89 45 ac	 mov	 DWORD PTR tv212[ebp], eax
  001af	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b4	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001b7	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  001c0	89 45 a8	 mov	 DWORD PTR tv213[ebp], eax
  001c3	8b 45 ac	 mov	 eax, DWORD PTR tv212[ebp]
  001c6	66 8b 08	 mov	 cx, WORD PTR [eax]
  001c9	51		 push	 ecx
  001ca	8b 4d a8	 mov	 ecx, DWORD PTR tv213[ebp]
  001cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  001d3	66 89 45 a6	 mov	 WORD PTR tv214[ebp], ax
  001d7	66 8b 55 a6	 mov	 dx, WORD PTR tv214[ebp]
  001db	66 89 55 d2	 mov	 WORD PTR $T16503[ebp], dx
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  001e5	66 89 45 a4	 mov	 WORD PTR tv215[ebp], ax
  001e9	66 8b 45 a4	 mov	 ax, WORD PTR tv215[ebp]
  001ed	66 89 45 d0	 mov	 WORD PTR $T16504[ebp], ax
  001f1	8d 4d d2	 lea	 ecx, DWORD PTR $T16503[ebp]
  001f4	51		 push	 ecx
  001f5	8d 55 d0	 lea	 edx, DWORD PTR $T16504[ebp]
  001f8	52		 push	 edx
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  001ff	83 c4 08	 add	 esp, 8
  00202	88 45 a3	 mov	 BYTE PTR tv216[ebp], al
  00205	0f b6 45 a3	 movzx	 eax, BYTE PTR tv216[ebp]
  00209	85 c0		 test	 eax, eax
  0020b	74 0b		 je	 SHORT $L14611

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  0020d	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00210	83 c9 04	 or	 ecx, 4
  00213	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  00216	eb 05		 jmp	 SHORT $L14604
$L14611:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00218	e9 71 ff ff ff	 jmp	 $L14607
$L14604:
  0021d	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00221	0f 85 9a 00 00
	00		 jne	 $L14612

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00227	eb 09		 jmp	 SHORT $L14613
$L14614:
  00229	8b 55 e8	 mov	 edx, DWORD PTR __Pad$[ebp]
  0022c	83 ea 01	 sub	 edx, 1
  0022f	89 55 e8	 mov	 DWORD PTR __Pad$[ebp], edx
$L14613:
  00232	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00236	0f 86 85 00 00
	00		 jbe	 $L14612

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  0023c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0023f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00241	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00244	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00247	8b ca		 mov	 ecx, edx
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  0024f	66 89 45 a0	 mov	 WORD PTR tv217[ebp], ax
  00253	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00256	8b 08		 mov	 ecx, DWORD PTR [eax]
  00258	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0025b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0025e	8b ca		 mov	 ecx, edx
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00266	89 45 9c	 mov	 DWORD PTR tv218[ebp], eax
  00269	66 8b 45 a0	 mov	 ax, WORD PTR tv217[ebp]
  0026d	50		 push	 eax
  0026e	8b 4d 9c	 mov	 ecx, DWORD PTR tv218[ebp]
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00277	66 89 45 9a	 mov	 WORD PTR tv219[ebp], ax
  0027b	66 8b 4d 9a	 mov	 cx, WORD PTR tv219[ebp]
  0027f	66 89 4d ce	 mov	 WORD PTR $T16505[ebp], cx
  00283	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00289	66 89 45 98	 mov	 WORD PTR tv220[ebp], ax
  0028d	66 8b 55 98	 mov	 dx, WORD PTR tv220[ebp]
  00291	66 89 55 cc	 mov	 WORD PTR $T16506[ebp], dx
  00295	8d 45 ce	 lea	 eax, DWORD PTR $T16505[ebp]
  00298	50		 push	 eax
  00299	8d 4d cc	 lea	 ecx, DWORD PTR $T16506[ebp]
  0029c	51		 push	 ecx
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  002a3	83 c4 08	 add	 esp, 8
  002a6	88 45 97	 mov	 BYTE PTR tv221[ebp], al
  002a9	0f b6 55 97	 movzx	 edx, BYTE PTR tv221[ebp]
  002ad	85 d2		 test	 edx, edx
  002af	74 0b		 je	 SHORT $L14618

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  002b1	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002b4	83 c8 04	 or	 eax, 4
  002b7	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  002ba	eb 05		 jmp	 SHORT $L14612
$L14618:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  002bc	e9 68 ff ff ff	 jmp	 $L14614
$L14612:
  002c1	6a 00		 push	 0
  002c3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002cb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  002d4	eb 1d		 jmp	 SHORT $L16508
$L16509:

; 581  : 		_CATCH_IO_(_Ostr)

  002d6	6a 01		 push	 1
  002d8	6a 04		 push	 4
  002da	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002df	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002e2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002e5	8b ca		 mov	 ecx, edx
  002e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  002ed	b8 00 00 00 00	 mov	 eax, $L16508
  002f2	c3		 ret	 0
$L16508:
  002f3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  002fa	6a 00		 push	 0
  002fc	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002ff	50		 push	 eax
  00300	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00303	8b 11		 mov	 edx, DWORD PTR [ecx]
  00305	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00308	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 585  : 	return (_Ostr);

  00311	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00314	89 45 c8	 mov	 DWORD PTR $T16507[ebp], eax
  00317	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0031e	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00321	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00326	8b 45 c8	 mov	 eax, DWORD PTR $T16507[ebp]

; 586  : 	}

  00329	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0032c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00333	5f		 pop	 edi
  00334	5e		 pop	 esi
  00335	5b		 pop	 ebx
  00336	8b e5		 mov	 esp, ebp
  00338	5d		 pop	 ebp
  00339	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16510:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16512
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T16525	DD	0ffffffffH
	DD	FLAT:$L16521
$T16523	DD	019930520H
	DD	01H
	DD	FLAT:$T16525
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00037	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	74 30		 je	 SHORT $L13816
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  00058	85 c0		 test	 eax, eax
  0005a	74 1b		 je	 SHORT $L13816

; 90   : 				_Ostr.tie()->flush();

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b ca		 mov	 ecx, edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  0006f	8b c8		 mov	 ecx, eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
$L13816:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00077	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00082	8b ca		 mov	 ecx, edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16521:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16523
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
EXTRN	__imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T16534	DD	0ffffffffH
	DD	FLAT:$L16530
$T16532	DD	019930520H
	DD	01H
	DD	FLAT:$T16534
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0b		 jne	 SHORT $L13818

; 99   : 				this->_Myostr._Osfx();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L13818:

; 100  : 			}

  0003b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16530:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16532
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L14102

; 70   : 				_Myostr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L14102:

; 71   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L14105

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L14105:

; 77   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
$T16545 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00004	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T16545[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T16545[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
$T16548 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T16548[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T16548[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z PROC NEAR ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1135 : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L14892
$L14893:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L14892:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0f		 je	 SHORT $L14891

; 1136 : 		*_First = _Val;

  00016	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00023	eb e0		 jmp	 SHORT $L14893
$L14891:

; 1137 : 	}

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ENDP ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Odt
;	COMDAT ??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z
_TEXT	SEGMENT
$T16555 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z PROC NEAR ; std::copy_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T16555[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T16555[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ENDP ; std::copy_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z PROC NEAR ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC NEAR ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
PUBLIC	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T16567	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T16569	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L16563
$T16568	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T16569
$T16565	DD	019930520H
	DD	02H
	DD	FLAT:$T16567
	DD	01H
	DD	FLAT:$T16568
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 208  : 	_FwdIt _Next = _First;

  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 209  : 
; 210  : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  0002d	eb 12		 jmp	 SHORT $L15028
$L15029:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00032	83 e9 01	 sub	 ecx, 1
  00035	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 1c	 add	 edx, 28			; 0000001cH
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L15028:
  00041	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00045	76 12		 jbe	 SHORT $L15030

; 212  : 		_Al.construct(_First, _Val);

  00047	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00052	e8 00 00 00 00	 call	 ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
  00057	eb d6		 jmp	 SHORT $L15029
$L15030:
  00059	eb 2a		 jmp	 SHORT $L16562
$L16563:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

  0005b	eb 09		 jmp	 SHORT $L15031
$L15032:
  0005d	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00060	83 c2 1c	 add	 edx, 28			; 0000001cH
  00063	89 55 ec	 mov	 DWORD PTR __Next$[ebp], edx
$L15031:
  00066	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00069	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  0006c	74 0e		 je	 SHORT $L15033

; 215  : 		_Al.destroy(_Next);

  0006e	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00071	51		 push	 ecx
  00072	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00075	e8 00 00 00 00	 call	 ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
  0007a	eb e1		 jmp	 SHORT $L15032
$L15033:

; 216  : 	_RERAISE;

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	e8 00 00 00 00	 call	 __CxxThrowException@8
$L16562:

; 217  : 	_CATCH_END

  00085	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$L16561:

; 218  : 	}

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16565
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L15035
$L15036:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L15035:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L15034

; 226  : 		_Al.destroy(_First);

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001d	e8 00 00 00 00	 call	 ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
  00022	eb e1		 jmp	 SHORT $L15036
$L15034:

; 227  : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
$T16576 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T16576[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T16576[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L15080:

; 1049 : 	while (_First != _Last)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00009	74 21		 je	 SHORT $L15081

; 1050 : 		*--_Dest = *--_Last;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	83 e9 1c	 sub	 ecx, 28			; 0000001cH
  00011	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  00014	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00017	83 ea 1c	 sub	 edx, 28			; 0000001cH
  0001a	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0001d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0002a	eb d7		 jmp	 SHORT $L15080
$L15081:

; 1051 : 	return (_Dest);

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1052 : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T16590	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T16592	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L16586
$T16591	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T16592
$T16588	DD	019930520H
	DD	02H
	DD	FLAT:$T16590
	DD	01H
	DD	FLAT:$T16591
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 78   : 	_FwdIt _Next = _Dest;

  00020	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 79   : 
; 80   : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  0002d	eb 12		 jmp	 SHORT $L15110
$L15111:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00035	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 1c	 add	 edx, 28			; 0000001cH
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L15110:
  00041	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00044	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00047	74 12		 je	 SHORT $L15112

; 82   : 		_Al.construct(_Dest, *_First);

  00049	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00050	52		 push	 edx
  00051	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00054	e8 00 00 00 00	 call	 ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
  00059	eb d4		 jmp	 SHORT $L15111
$L15112:
  0005b	eb 2a		 jmp	 SHORT $L16585
$L16586:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  0005d	eb 09		 jmp	 SHORT $L15113
$L15114:
  0005f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00062	83 c0 1c	 add	 eax, 28			; 0000001cH
  00065	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$L15113:
  00068	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  0006b	3b 4d 10	 cmp	 ecx, DWORD PTR __Dest$[ebp]
  0006e	74 0e		 je	 SHORT $L15115

; 85   : 		_Al.destroy(_Next);

  00070	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00073	52		 push	 edx
  00074	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00077	e8 00 00 00 00	 call	 ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
  0007c	eb e1		 jmp	 SHORT $L15114
$L15115:

; 86   : 	_RERAISE;

  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	e8 00 00 00 00	 call	 __CxxThrowException@8
$L16585:

; 87   : 	_CATCH_END

  00087	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 88   : 	return (_Dest);

  0008e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$L16584:

; 89   : 	}

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16588
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T16605	DD	0ffffffffH
	DD	FLAT:$L16601
$T16603	DD	019930520H
	DD	01H
	DD	FLAT:$T16605
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
tv74 = -24						; size = 4
$T16598 = -20						; size = 4
$T16597 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC NEAR ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001e	50		 push	 eax
  0001f	6a 1c		 push	 28			; 0000001cH
  00021	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00026	83 c4 08	 add	 esp, 8
  00029	89 45 ec	 mov	 DWORD PTR $T16598[ebp], eax
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	83 7d ec 00	 cmp	 DWORD PTR $T16598[ebp], 0
  00037	74 12		 je	 SHORT $L16599
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR $T16598[ebp]
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00046	89 45 e8	 mov	 DWORD PTR tv74[ebp], eax
  00049	eb 07		 jmp	 SHORT $L16600
$L16599:
  0004b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L16600:
  00052	8b 55 e8	 mov	 edx, DWORD PTR tv74[ebp]
  00055	89 55 f0	 mov	 DWORD PTR $T16597[ebp], edx
  00058	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 43   : 	}

  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L16601:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ec	 mov	 ecx, DWORD PTR $T16598[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T16603
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 63   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 64   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 65   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 68   : 	{	// delete if placement new fails

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00003	6a 00		 push	 0
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z

; 50   : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00010	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	74 0c		 je	 SHORT $L15127
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00021	83 c4 04	 add	 esp, 4
$L15127:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
END
