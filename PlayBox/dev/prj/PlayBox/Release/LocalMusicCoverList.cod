; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\module\PlayedGamePanel\LocalMusicCoverList.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ?Unlock@CSyncObject@@UAEHJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CCriticalSection@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCriticalSection@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCriticalSection@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCriticalSection@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CCriticalSection@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CCriticalSection@@UAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CCriticalSection@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0GdiRes@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_tagLMCItemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E5
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??_GCLocalMusicCoverList@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_tagLMCItemInfo@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEAAVCPoint@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXABVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEPAU_tagLMCItemInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindCharRev@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Growmap@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@VCPoint@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@VCPoint@@@std@@QAEPAVCPoint@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@ABV3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEAAU_tagLMCItemInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEAAVCPoint@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@VCPoint@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVCPoint@@@std@@QAEPAPAVCPoint@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEABU_tagLMCItemInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEABVCPoint@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VCPoint@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHVconst_iterator@01@0PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPAVCPoint@@PAPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAVCPoint@@IPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@VCPoint@@@std@@YAPAVCPoint@@IPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@VCPoint@@V1@@std@@YAXPAVCPoint@@ABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@VCPoint@@@std@@YAXPAVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0VCPoint@@@?$allocator@PAVCPoint@@@std@@QAE@ABV?$allocator@VCPoint@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCPoint@@@std@@YAPAPAVCPoint@@IPAPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAVCPoint@@@std@@YAXPAPAVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@VCPoint@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPoint@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAVCPoint@@PAV1@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@HV?$allocator@H@std@@@0@AAPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAHIH@std@@YAXPAHIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@H@std@@QAEXPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@HH@std@@YAXPAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@H@std@@YAXPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CLocalMusicCoverList@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CLocalMusicCoverList@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSyncObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CCmdTarget@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CLocalMusicCoverList@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCSyncObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCCriticalSection@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCLocalMusicCoverList@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CCriticalSection@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?EndModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BeginModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4CLocalMusicCoverList@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRButtonDown@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnKillFocus@CWnd@@IAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnShowWindow@CWnd@@IAEXHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRButtonUp@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnLButtonUp@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndDrag@CImageList@@SGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DragLeave@CImageList@@SGHPAVCWnd@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRect@CRect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnLButtonDown@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCapture@CWnd@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_idrag@?P@??OnMouseMove@CLocalMusicCoverList@@QAEXIVCPoint@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?KillTimer@CWnd@@QAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnMouseWheel@CWnd@@IAEHIFVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTimer@CWnd@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PtInRect@CRect@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawTextA@CDC@@QAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRECT@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCGdiObject@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectObject@CDC@@QAEPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBkMode@CDC@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTextColor@CDC@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCurrentFont@CDC@@QBEPAVCFont@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FromHandle@CFont@@SGPAV1@PAUHFONT__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawPath@Graphics@Gdiplus@@QAE?AW4Status@2@PBVPen@2@PBVGraphicsPath@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatus@Graphics@Gdiplus@@IBE?AW4Status@2@W432@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Point@Gdiplus@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Pen@Gdiplus@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Pen@Gdiplus@@QAE@ABVColor@1@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetValue@Color@Gdiplus@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFromCOLORREF@Color@Gdiplus@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeARGB@Color@Gdiplus@@SAKEEEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Color@Gdiplus@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSmoothingMode@Graphics@Gdiplus@@QAE?AW4Status@2@W4SmoothingMode@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@ABVRect@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rect@Gdiplus@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Graphics@Gdiplus@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Graphics@Gdiplus@@QAE@PAUHDC__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNativeGraphics@Graphics@Gdiplus@@IAEXPAVGpGraphics@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddLine@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatus@GraphicsPath@Gdiplus@@IBE?AW4Status@2@W432@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddArc@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHHMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@GraphicsPath@Gdiplus@@QBEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2GdiplusBase@Gdiplus@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3GdiplusBase@Gdiplus@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0GraphicsPath@Gdiplus@@IAE@PAVGpPath@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNativePath@GraphicsPath@Gdiplus@@IAEXPAVGpPath@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1GraphicsPath@Gdiplus@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0GraphicsPath@Gdiplus@@QAE@W4FillMode@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCompatibleBitmap@CBitmap@@QAEHPAVCDC@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHandle@CGdiObject@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8CRect@@QBEHABUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRectEmpty@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRectNull@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RedrawWindow@CWnd@@QAEHPBUtagRECT@@PAVCRgn@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AlphaBlend@CDC@@QAEHHHHHPAV1@HHHHU_BLENDFUNCTION@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IntersectRect@CRect@@QAEHPBUtagRECT@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rectangle@CDC@@QAEHPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPen@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CPen@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CPen@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCPen@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CPen@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CPen@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CPen@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GCPen@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateStockObject@CGdiObject@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBrush@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBrush@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CBrush@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCBrush@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CBrush@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CBrush@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBrush@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCBrush@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBrush@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPoint@CPoint@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AfxGetApp@@YGPAVCWinApp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStandardCursor@CWinApp@@QBEPAUHICON__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnSize@CWnd@@IAEXIHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnEraseBkgnd@CWnd@@IAEHPAVCDC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@Image@Gdiplus@@UAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatus@Image@Gdiplus@@IBE?AW4Status@2@W432@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Image@Gdiplus@@IAE@PAVGpImage@1@W4Status@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7Image@Gdiplus@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4Image@Gdiplus@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVImage@Gdiplus@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3Image@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2Image@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@Image@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R13?0A@A@GdiplusBase@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVGdiplusBase@Gdiplus@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GImage@Gdiplus@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNativeImage@Image@Gdiplus@@IAEXPAVGpImage@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Image@Gdiplus@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Image@Gdiplus@@QAE@PB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTimer@CWnd@@QAEIIIP6GXPAUHWND__@@IIK@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateFontA@CFont@@QAEHHHHHHEEEEEEEEPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_messageEntries@CLocalMusicCoverList@@0QBUAFX_MSGMAP_ENTRY@@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messageMap@CLocalMusicCoverList@@1UAFX_MSGMAP@@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CObject@@SGPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFont@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CFont@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCFont@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCFont@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFont@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBitmap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBitmap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CBitmap@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCBitmap@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCBitmap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBitmap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CLocalMusicCoverList@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?classCLocalMusicCoverList@CLocalMusicCoverList@@2UCRuntimeClass@@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CCriticalSection@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?OnTimer@CLocalMusicCoverList@@QAEXI@Z		; CLocalMusicCoverList::OnTimer
PUBLIC	?OnMouseWheel@CLocalMusicCoverList@@QAEHIFVCPoint@@@Z ; CLocalMusicCoverList::OnMouseWheel
PUBLIC	?OnMouseMove@CLocalMusicCoverList@@QAEXIVCPoint@@@Z ; CLocalMusicCoverList::OnMouseMove
PUBLIC	?OnLButtonDown@CLocalMusicCoverList@@QAEXIVCPoint@@@Z ; CLocalMusicCoverList::OnLButtonDown
PUBLIC	?OnTrackerChange@CLocalMusicCoverList@@QAEJIJ@Z	; CLocalMusicCoverList::OnTrackerChange
PUBLIC	?OnLButtonUp@CLocalMusicCoverList@@QAEXIVCPoint@@@Z ; CLocalMusicCoverList::OnLButtonUp
PUBLIC	?OnRButtonUp@CLocalMusicCoverList@@QAEXIVCPoint@@@Z ; CLocalMusicCoverList::OnRButtonUp
PUBLIC	?OnCoolSBCustomdraw@CLocalMusicCoverList@@QAEXPAUtagNMHDR@@PAJ@Z ; CLocalMusicCoverList::OnCoolSBCustomdraw
PUBLIC	?OnDestroy@CLocalMusicCoverList@@QAEXXZ		; CLocalMusicCoverList::OnDestroy
PUBLIC	?OnVScroll@CLocalMusicCoverList@@QAEXIIPAVCScrollBar@@@Z ; CLocalMusicCoverList::OnVScroll
PUBLIC	?OnShowWindow@CLocalMusicCoverList@@QAEXHI@Z	; CLocalMusicCoverList::OnShowWindow
PUBLIC	?OnKeyDown@CLocalMusicCoverList@@QAEXIII@Z	; CLocalMusicCoverList::OnKeyDown
PUBLIC	?OnSetFocus@CLocalMusicCoverList@@QAEXPAVCWnd@@@Z ; CLocalMusicCoverList::OnSetFocus
PUBLIC	?OnKillFocus@CLocalMusicCoverList@@QAEXPAVCWnd@@@Z ; CLocalMusicCoverList::OnKillFocus
PUBLIC	?OnRButtonDown@CLocalMusicCoverList@@QAEXIVCPoint@@@Z ; CLocalMusicCoverList::OnRButtonDown
PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	?classCLocalMusicCoverList@CLocalMusicCoverList@@2UCRuntimeClass@@B ; CLocalMusicCoverList::classCLocalMusicCoverList
PUBLIC	?_messageEntries@CLocalMusicCoverList@@0QBUAFX_MSGMAP_ENTRY@@B ; CLocalMusicCoverList::_messageEntries
PUBLIC	?messageMap@CLocalMusicCoverList@@1UAFX_MSGMAP@@B ; CLocalMusicCoverList::messageMap
PUBLIC	?OnCreate@CLocalMusicCoverList@@IAEHPAUtagCREATESTRUCTA@@@Z ; CLocalMusicCoverList::OnCreate
PUBLIC	?OnEraseBkgnd@CLocalMusicCoverList@@IAEHPAVCDC@@@Z ; CLocalMusicCoverList::OnEraseBkgnd
PUBLIC	?OnPaint@CLocalMusicCoverList@@IAEXXZ		; CLocalMusicCoverList::OnPaint
PUBLIC	?OnSize@CLocalMusicCoverList@@IAEXIHH@Z		; CLocalMusicCoverList::OnSize
EXTRN	?GetThisMessageMap@CWnd@@KGPBUAFX_MSGMAP@@XZ:NEAR ; CWnd::GetThisMessageMap
EXTRN	?GetThisClass@CWnd@@SGPAUCRuntimeClass@@XZ:NEAR	; CWnd::GetThisClass
CONST	SEGMENT
$SG198880 DB	'int', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_INT DD FLAT:$SG198880
_DATA	ENDS
CONST	SEGMENT
$SG198882 DB	'str', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_STR DD FLAT:$SG198882
_DATA	ENDS
CONST	SEGMENT
$SG198884 DB	'double', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_DOUBLE DD FLAT:$SG198884
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG198886 DB	'bool', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_BOOL DD FLAT:$SG198886
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG198888 DB	'sepint', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_INT_HASSEP DD FLAT:$SG198888
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG198890 DB	'sepstr', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_STR_HASSEP DD FLAT:$SG198890
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG198892 DB	'sepdouble', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_DOUBLE_HASSEP DD FLAT:$SG198892
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG198894 DB	'sepbool', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_BOOL_HASSEP DD FLAT:$SG198894
_DATA	ENDS
CONST	SEGMENT
$SG198896 DB	'App', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_MODULE_NAME DD FLAT:$SG198896
_DATA	ENDS
CONST	SEGMENT
$SG198898 DB	'SwfPath', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_SWF_PATH DD FLAT:$SG198898
_DATA	ENDS
CONST	SEGMENT
$SG198900 DB	'MainWndHold', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_MAINWND_HOLD DD FLAT:$SG198900
_DATA	ENDS
CONST	SEGMENT
$SG198902 DB	'RunCount', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_RUN_COUNT DD FLAT:$SG198902
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG198904 DB	'PlayedGame', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_PLAYED_GAME DD FLAT:$SG198904
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG198906 DB	'playedPcGame', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_PLAYED_PC_GAME DD FLAT:$SG198906
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG198908 DB	'PlayedIconSize', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_PLAYED_ICON_SIZE DD FLAT:$SG198908
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG198910 DB	'PictureSavePath', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_PIC_SAVE_PATH DD FLAT:$SG198910
_DATA	ENDS
CONST	SEGMENT
$SG199838 DB	'CLocalMusicCoverList', 00H
CONST	ENDS
;	COMDAT ?classCLocalMusicCoverList@CLocalMusicCoverList@@2UCRuntimeClass@@B
CONST	SEGMENT
?classCLocalMusicCoverList@CLocalMusicCoverList@@2UCRuntimeClass@@B DD FLAT:$SG199838 ; CLocalMusicCoverList::classCLocalMusicCoverList
	DD	017cH
	DD	0ffffH
	DD	00H
	DD	FLAT:?GetThisClass@CWnd@@SGPAUCRuntimeClass@@XZ
	DD	00H
	DD	00H
CONST	ENDS
CONST	SEGMENT
	ORG $+3
$SG199859 DB	'ScrollHorz', 00H
	ORG $+1
$SG199860 DB	'ScrollVert', 00H
	ORG $+1
$SG199861 DB	'PlayedGameDetailTextColor', 00H
	ORG $+2
$SG199862 DB	'PlayedGameBkColor', 00H
	ORG $+2
$SG199863 DB	'PlayedGameNameColor', 00H
CONST	ENDS
;	COMDAT ?_messageEntries@CLocalMusicCoverList@@0QBUAFX_MSGMAP_ENTRY@@B
CONST	SEGMENT
?_messageEntries@CLocalMusicCoverList@@0QBUAFX_MSGMAP_ENTRY@@B DD 01H ; CLocalMusicCoverList::_messageEntries
	DD	00H
	DD	00H
	DD	00H
	DD	0dH
	DD	FLAT:?OnCreate@CLocalMusicCoverList@@IAEHPAUtagCREATESTRUCTA@@@Z
	DD	014H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:?OnEraseBkgnd@CLocalMusicCoverList@@IAEHPAVCDC@@@Z
	DD	0fH
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	FLAT:?OnPaint@CLocalMusicCoverList@@IAEXXZ
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	DD	016H
	DD	FLAT:?OnSize@CLocalMusicCoverList@@IAEXIHH@Z
	DD	0113H
	DD	00H
	DD	00H
	DD	00H
	DD	011H
	DD	FLAT:?OnTimer@CLocalMusicCoverList@@QAEXI@Z
	DD	020aH
	DD	00H
	DD	00H
	DD	00H
	DD	034H
	DD	FLAT:?OnMouseWheel@CLocalMusicCoverList@@QAEHIFVCPoint@@@Z
	DD	0200H
	DD	00H
	DD	00H
	DD	00H
	DD	032H
	DD	FLAT:?OnMouseMove@CLocalMusicCoverList@@QAEXIVCPoint@@@Z
	DD	0201H
	DD	00H
	DD	00H
	DD	00H
	DD	032H
	DD	FLAT:?OnLButtonDown@CLocalMusicCoverList@@QAEXIVCPoint@@@Z
	DD	04c8H
	DD	00H
	DD	00H
	DD	00H
	DD	0eH
	DD	FLAT:?OnTrackerChange@CLocalMusicCoverList@@QAEJIJ@Z
	DD	0bc4eH
	DD	0f001H
	DD	00H
	DD	00H
	DD	039H
	DD	FLAT:?OnCoolSBCustomdraw@CLocalMusicCoverList@@QAEXPAUtagNMHDR@@PAJ@Z
	DD	0202H
	DD	00H
	DD	00H
	DD	00H
	DD	032H
	DD	FLAT:?OnLButtonUp@CLocalMusicCoverList@@QAEXIVCPoint@@@Z
	DD	0205H
	DD	00H
	DD	00H
	DD	00H
	DD	032H
	DD	FLAT:?OnRButtonUp@CLocalMusicCoverList@@QAEXIVCPoint@@@Z
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	FLAT:?OnDestroy@CLocalMusicCoverList@@QAEXXZ
	DD	0115H
	DD	00H
	DD	00H
	DD	00H
	DD	027H
	DD	FLAT:?OnVScroll@CLocalMusicCoverList@@QAEXIIPAVCScrollBar@@@Z
	DD	018H
	DD	00H
	DD	00H
	DD	00H
	DD	012H
	DD	FLAT:?OnShowWindow@CLocalMusicCoverList@@QAEXHI@Z
	DD	0100H
	DD	00H
	DD	00H
	DD	00H
	DD	015H
	DD	FLAT:?OnKeyDown@CLocalMusicCoverList@@QAEXIII@Z
	DD	07H
	DD	00H
	DD	00H
	DD	00H
	DD	020H
	DD	FLAT:?OnSetFocus@CLocalMusicCoverList@@QAEXPAVCWnd@@@Z
	DD	08H
	DD	00H
	DD	00H
	DD	00H
	DD	020H
	DD	FLAT:?OnKillFocus@CLocalMusicCoverList@@QAEXPAVCWnd@@@Z
	DD	0204H
	DD	00H
	DD	00H
	DD	00H
	DD	032H
	DD	FLAT:?OnRButtonDown@CLocalMusicCoverList@@QAEXIVCPoint@@@Z
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?messageMap@CLocalMusicCoverList@@1UAFX_MSGMAP@@B
CONST	SEGMENT
?messageMap@CLocalMusicCoverList@@1UAFX_MSGMAP@@B DD FLAT:?GetThisMessageMap@CWnd@@KGPBUAFX_MSGMAP@@XZ ; CLocalMusicCoverList::messageMap
	DD	FLAT:?_messageEntries@CLocalMusicCoverList@@0QBUAFX_MSGMAP_ENTRY@@B
CONST	ENDS
CONST	SEGMENT
$SG199990 DB	0cbH, 0ceH, 0ccH, 0e5H, 00H
	ORG $+3
$SG199991 DB	0cbH, 0ceH, 0ccH, 0e5H, 00H
	ORG $+3
$SG199995 DB	'\Resources\StandardUI\IconBorder.png', 00H
$SG200047 DB	00H
	ORG $+2
$SG200641 DB	'PlayedGameFrameBorder', 00H
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
PUBLIC	?GetThisClass@CLocalMusicCoverList@@SGPAUCRuntimeClass@@XZ ; CLocalMusicCoverList::GetThisClass
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\playedgamepanel\localmusiccoverlist.cpp
_TEXT	SEGMENT
?GetThisClass@CLocalMusicCoverList@@SGPAUCRuntimeClass@@XZ PROC NEAR ; CLocalMusicCoverList::GetThisClass

; 12   : IMPLEMENT_DYNAMIC(CLocalMusicCoverList, CWnd)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?classCLocalMusicCoverList@CLocalMusicCoverList@@2UCRuntimeClass@@B ; CLocalMusicCoverList::classCLocalMusicCoverList
  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetThisClass@CLocalMusicCoverList@@SGPAUCRuntimeClass@@XZ ENDP ; CLocalMusicCoverList::GetThisClass
_TEXT	ENDS
PUBLIC	?GetRuntimeClass@CLocalMusicCoverList@@UBEPAUCRuntimeClass@@XZ ; CLocalMusicCoverList::GetRuntimeClass
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRuntimeClass@CLocalMusicCoverList@@UBEPAUCRuntimeClass@@XZ PROC NEAR ; CLocalMusicCoverList::GetRuntimeClass
; _this$ = ecx

; 12   : IMPLEMENT_DYNAMIC(CLocalMusicCoverList, CWnd)

  00010	55		 push	 ebp
  00011	8b ec		 mov	 ebp, esp
  00013	51		 push	 ecx
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?classCLocalMusicCoverList@CLocalMusicCoverList@@2UCRuntimeClass@@B ; CLocalMusicCoverList::classCLocalMusicCoverList
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?GetRuntimeClass@CLocalMusicCoverList@@UBEPAUCRuntimeClass@@XZ ENDP ; CLocalMusicCoverList::GetRuntimeClass
_TEXT	ENDS
PUBLIC	??0CPoint@@QAE@HH@Z				; CPoint::CPoint
PUBLIC	?PreTranslateMessage@CLocalMusicCoverList@@UAEHPAUtagMSG@@@Z ; CLocalMusicCoverList::PreTranslateMessage
PUBLIC	??_7CLocalMusicCoverList@@6B@			; CLocalMusicCoverList::`vftable'
PUBLIC	??_GCLocalMusicCoverList@@UAEPAXI@Z		; CLocalMusicCoverList::`scalar deleting destructor'
PUBLIC	??0CRect@@QAE@HHHH@Z				; CRect::CRect
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CWnd@@8				; CWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCWnd@@@8				; CWnd `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CCmdTarget@@8			; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCCmdTarget@@@8				; CCmdTarget `RTTI Type Descriptor'
PUBLIC	??0GdiRes@@QAE@XZ				; GdiRes::GdiRes
PUBLIC	??2CObject@@SGPAXI@Z				; CObject::operator new
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	??_R4CLocalMusicCoverList@@6B@			; CLocalMusicCoverList::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCLocalMusicCoverList@@@8		; CLocalMusicCoverList `RTTI Type Descriptor'
PUBLIC	??_R3CLocalMusicCoverList@@8			; CLocalMusicCoverList::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CLocalMusicCoverList@@8			; CLocalMusicCoverList::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CLocalMusicCoverList@@8		; CLocalMusicCoverList::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0CLocalMusicCoverList@@QAE@XZ			; CLocalMusicCoverList::CLocalMusicCoverList
PUBLIC	?GetMessageMap@CLocalMusicCoverList@@MBEPBUAFX_MSGMAP@@XZ ; CLocalMusicCoverList::GetMessageMap
PUBLIC	?Create@CLocalMusicCoverList@@UAEHPBD0KABUtagRECT@@PAVCWnd@@IPAUCCreateContext@@@Z ; CLocalMusicCoverList::Create
PUBLIC	?SetItemWH@CLocalMusicCoverList@@QAEXHH@Z	; CLocalMusicCoverList::SetItemWH
PUBLIC	?SetScrollBitmap@CLocalMusicCoverList@@QAEXPAVCDibBitmap@@0@Z ; CLocalMusicCoverList::SetScrollBitmap
PUBLIC	?OnMoveDraging@CLocalMusicCoverList@@UAEXXZ	; CLocalMusicCoverList::OnMoveDraging
PUBLIC	?OnEndDrag@CLocalMusicCoverList@@UAEXXZ		; CLocalMusicCoverList::OnEndDrag
PUBLIC	??0CFont@@QAE@XZ				; CFont::CFont
PUBLIC	??1CFont@@UAE@XZ				; CFont::~CFont
PUBLIC	??0CBitmap@@QAE@XZ				; CBitmap::CBitmap
PUBLIC	??0CCriticalSection@@QAE@XZ			; CCriticalSection::CCriticalSection
PUBLIC	??1CCriticalSection@@UAE@XZ			; CCriticalSection::~CCriticalSection
PUBLIC	??0?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ ; std::deque<CPoint,std::allocator<CPoint> >::deque<CPoint,std::allocator<CPoint> >
PUBLIC	??1CBitmap@@UAE@XZ				; CBitmap::~CBitmap
PUBLIC	??1?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ ; std::deque<CPoint,std::allocator<CPoint> >::~deque<CPoint,std::allocator<CPoint> >
PUBLIC	?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z	; CWnd::DoDataExchange
PUBLIC	?BeginModalState@CWnd@@UAEXXZ			; CWnd::BeginModalState
PUBLIC	?EndModalState@CWnd@@UAEXXZ			; CWnd::EndModalState
EXTRN	??0CDC@@QAE@XZ:NEAR				; CDC::CDC
EXTRN	?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z:NEAR ; CWnd::CreateControlContainer
EXTRN	?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z:NEAR ; CWnd::CreateControlSite
EXTRN	?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:NEAR ; CWnd::SetOccDialogInfo
EXTRN	??_ECLocalMusicCoverList@@UAEPAXI@Z:NEAR	; CLocalMusicCoverList::`vector deleting destructor'
EXTRN	?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z:NEAR ; CWnd::OnToolHitTest
EXTRN	?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z:NEAR ; CWnd::GetScrollBarCtrl
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?GetConfigIntValue@AfxUserConfig@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAH@Z:NEAR ; AfxUserConfig::GetConfigIntValue
EXTRN	?WinHelpA@CWnd@@UAEXKI@Z:NEAR			; CWnd::WinHelpA
EXTRN	?HtmlHelpA@CWnd@@UAEXKI@Z:NEAR			; CWnd::HtmlHelpA
EXTRN	?WinHelpInternal@CWnd@@UAEXKI@Z:NEAR		; CWnd::WinHelpInternal
EXTRN	?ContinueModal@CWnd@@UAEHXZ:NEAR		; CWnd::ContinueModal
EXTRN	?EndModalLoop@CWnd@@UAEXH@Z:NEAR		; CWnd::EndModalLoop
EXTRN	?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ:NEAR ; CWnd::GetInterfaceMap
EXTRN	?EnsureStdObj@CWnd@@UAEJXZ:NEAR			; CWnd::EnsureStdObj
EXTRN	?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z:NEAR ; CWnd::get_accParent
EXTRN	?get_accChildCount@CWnd@@UAEJPAJ@Z:NEAR		; CWnd::get_accChildCount
EXTRN	?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:NEAR ; CCmdTarget::OnCmdMsg
EXTRN	?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z:NEAR ; CWnd::get_accChild
EXTRN	?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z:NEAR	; CCmdTarget::IsInvokeAllowed
EXTRN	?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accName
EXTRN	?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accValue
EXTRN	?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accDescription
EXTRN	?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z:NEAR ; CCmdTarget::GetDispatchIID
EXTRN	?GetTypeInfoCount@CCmdTarget@@UAEIXZ:NEAR	; CCmdTarget::GetTypeInfoCount
EXTRN	?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ:NEAR ; CCmdTarget::GetTypeLibCache
EXTRN	?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:NEAR ; CWnd::get_accRole
EXTRN	?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z:NEAR ; CCmdTarget::GetTypeLib
EXTRN	?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:NEAR ; CWnd::get_accState
EXTRN	?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accHelp
EXTRN	?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z:NEAR ; CWnd::get_accHelpTopic
EXTRN	??0CLMCDataMgr@@QAE@XZ:NEAR			; CLMCDataMgr::CLMCDataMgr
EXTRN	?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accKeyboardShortcut
EXTRN	??1CLMCDataMgr@@QAE@XZ:NEAR			; CLMCDataMgr::~CLMCDataMgr
EXTRN	?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z:NEAR	; CWnd::get_accFocus
EXTRN	?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z:NEAR ; CWnd::get_accSelection
EXTRN	?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accDefaultAction
EXTRN	?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ:NEAR ; CCmdTarget::GetCommandMap
EXTRN	?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z:NEAR	; CWnd::accSelect
EXTRN	?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z:NEAR ; CWnd::accLocation
EXTRN	?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ:NEAR ; CCmdTarget::GetDispatchMap
EXTRN	?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z:NEAR ; CWnd::accNavigate
EXTRN	?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z:NEAR	; CWnd::accHitTest
EXTRN	?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ:NEAR ; CCmdTarget::GetConnectionMap
EXTRN	?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z:NEAR ; CWnd::accDoDefaultAction
EXTRN	?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z:NEAR	; CWnd::put_accName
EXTRN	?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z:NEAR ; CWnd::put_accValue
EXTRN	?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z:NEAR ; CWnd::SetProxy
EXTRN	?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z:NEAR	; CWnd::CreateAccessibleProxy
EXTRN	?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ:NEAR ; CCmdTarget::GetEventSinkMap
EXTRN	?OnCreateAggregates@CCmdTarget@@UAEHXZ:NEAR	; CCmdTarget::OnCreateAggregates
EXTRN	?OnCommand@CWnd@@MAEHIJ@Z:NEAR			; CWnd::OnCommand
EXTRN	?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z:NEAR ; CCmdTarget::GetInterfaceHook
EXTRN	?OnNotify@CWnd@@MAEHIJPAJ@Z:NEAR		; CWnd::OnNotify
EXTRN	?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z:NEAR ; CCmdTarget::GetExtraConnectionPoints
EXTRN	?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z:NEAR ; CCmdTarget::GetConnectionHook
EXTRN	??1CDC@@UAE@XZ:NEAR				; CDC::~CDC
EXTRN	??0CWnd@@QAE@XZ:NEAR				; CWnd::CWnd
EXTRN	?PreSubclassWindow@CWnd@@UAEXXZ:NEAR		; CWnd::PreSubclassWindow
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z:NEAR ; CWnd::CreateEx
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z:NEAR ; CWnd::CreateEx
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	?DestroyWindow@CWnd@@UAEHXZ:NEAR		; CWnd::DestroyWindow
EXTRN	?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z:NEAR ; CWnd::PreCreateWindow
EXTRN	?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z:NEAR	; CWnd::CalcWindowRect
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ:NEAR ; CWnd::GetSuperWndProcAddr
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z:NEAR ; CWnd::OnAmbientProperty
EXTRN	?WindowProc@CWnd@@MAEJIIJ@Z:NEAR		; CWnd::WindowProc
EXTRN	?OnWndMsg@CWnd@@MAEHIIJPAJ@Z:NEAR		; CWnd::OnWndMsg
EXTRN	?DefWindowProcA@CWnd@@MAEJIIJ@Z:NEAR		; CWnd::DefWindowProcA
EXTRN	?PostNcDestroy@CWnd@@MAEXXZ:NEAR		; CWnd::PostNcDestroy
EXTRN	?OnChildNotify@CWnd@@MAEHIIJPAJ@Z:NEAR		; CWnd::OnChildNotify
EXTRN	?AfxGetUIManager@@YAPAVIUIManager@@XZ:NEAR	; AfxGetUIManager
EXTRN	??1CWnd@@UAE@XZ:NEAR				; CWnd::~CWnd
EXTRN	?AfxGetUserConfig@@YAPAVAfxUserConfig@@XZ:NEAR	; AfxGetUserConfig
EXTRN	?CheckAutoCenter@CWnd@@UAEHXZ:NEAR		; CWnd::CheckAutoCenter
EXTRN	?IsFrameWnd@CWnd@@UBEHXZ:NEAR			; CWnd::IsFrameWnd
EXTRN	?OnFinalRelease@CWnd@@UAEXXZ:NEAR		; CWnd::OnFinalRelease
xdata$x	SEGMENT
$T203011 DD	0ffffffffH
	DD	FLAT:$L202991
	DD	00H
	DD	FLAT:$L202992
	DD	01H
	DD	FLAT:$L202993
	DD	02H
	DD	FLAT:$L202994
	DD	03H
	DD	FLAT:$L202995
	DD	04H
	DD	FLAT:$L202996
	DD	05H
	DD	FLAT:$L202997
	DD	06H
	DD	FLAT:$L202998
	DD	07H
	DD	FLAT:$L202999
	DD	08H
	DD	FLAT:$L203000
	DD	09H
	DD	FLAT:$L203001
	DD	09H
	DD	FLAT:$L203002
	DD	09H
	DD	FLAT:$L203003
	DD	0cH
	DD	FLAT:$L203004
$T203008 DD	019930520H
	DD	0eH
	DD	FLAT:$T203011
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CLocalMusicCoverList@@6B@
CONST	SEGMENT
??_7CLocalMusicCoverList@@6B@ DD FLAT:??_R4CLocalMusicCoverList@@6B@ ; CLocalMusicCoverList::`vftable'
	DD	FLAT:?GetRuntimeClass@CLocalMusicCoverList@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECLocalMusicCoverList@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CLocalMusicCoverList@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CLocalMusicCoverList@@UAEHPBD0KABUtagRECT@@PAVCWnd@@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CLocalMusicCoverList@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?CheckAutoCenter@CWnd@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?OnMoveDraging@CLocalMusicCoverList@@UAEXXZ
	DD	FLAT:?OnEndDrag@CLocalMusicCoverList@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4CLocalMusicCoverList@@6B@
rdata$r	SEGMENT
??_R4CLocalMusicCoverList@@6B@ DD 00H			; CLocalMusicCoverList::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCLocalMusicCoverList@@@8
	DD	FLAT:??_R3CLocalMusicCoverList@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCLocalMusicCoverList@@@8
_DATA	SEGMENT
??_R0?AVCLocalMusicCoverList@@@8 DD FLAT:??_7type_info@@6B@ ; CLocalMusicCoverList `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCLocalMusicCoverList@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CLocalMusicCoverList@@8
rdata$r	SEGMENT
??_R3CLocalMusicCoverList@@8 DD 00H			; CLocalMusicCoverList::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CLocalMusicCoverList@@8
rdata$r	ENDS
;	COMDAT ??_R2CLocalMusicCoverList@@8
rdata$r	SEGMENT
??_R2CLocalMusicCoverList@@8 DD FLAT:??_R1A@?0A@A@CLocalMusicCoverList@@8 ; CLocalMusicCoverList::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CWnd@@8
	DD	FLAT:??_R1A@?0A@A@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CLocalMusicCoverList@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CLocalMusicCoverList@@8 DD FLAT:??_R0?AVCLocalMusicCoverList@@@8 ; CLocalMusicCoverList::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CWnd@@8 DD FLAT:??_R0?AVCWnd@@@8		; CWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCWnd@@@8
_DATA	SEGMENT
??_R0?AVCWnd@@@8 DD FLAT:??_7type_info@@6B@		; CWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CCmdTarget@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CCmdTarget@@8 DD FLAT:??_R0?AVCCmdTarget@@@8 ; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
_DATA	SEGMENT
??_R0?AVCCmdTarget@@@8 DD FLAT:??_7type_info@@6B@	; CCmdTarget `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCmdTarget@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
tv274 = -112						; size = 4
tv223 = -108						; size = 4
tv221 = -104						; size = 4
tv213 = -100						; size = 4
_this$ = -96						; size = 4
$T202990 = -92						; size = 28
$T202989 = -64						; size = 28
$T202986 = -36						; size = 4
$T202985 = -32						; size = 4
$T202982 = -28						; size = 4
$T202981 = -24						; size = 4
_pSkinMgr$ = -20					; size = 4
_iValue$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CLocalMusicCoverList@@QAE@XZ PROC NEAR		; CLocalMusicCoverList::CLocalMusicCoverList
; _this$ = ecx

; 35   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	6a ff		 push	 -1
  00025	68 00 00 00 00	 push	 __ehhandler$??0CLocalMusicCoverList@@QAE@XZ
  0002a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00030	50		 push	 eax
  00031	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00038	83 ec 64	 sub	 esp, 100		; 00000064H
  0003b	89 4d a0	 mov	 DWORD PTR _this$[ebp], ecx
  0003e	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ??0CWnd@@QAE@XZ		; CWnd::CWnd
  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004d	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CLocalMusicCoverList@@6B@
  00056	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0
  00060	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  00063	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0
  0006a	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	c7 40 5c 01 00
	00 00		 mov	 DWORD PTR [eax+92], 1
  00074	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	83 c1 60	 add	 ecx, 96			; 00000060H
  0007a	e8 00 00 00 00	 call	 ??0CDC@@QAE@XZ		; CDC::CDC
  0007f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00083	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	83 c1 70	 add	 ecx, 112		; 00000070H
  00089	e8 00 00 00 00	 call	 ??0CBitmap@@QAE@XZ	; CBitmap::CBitmap
  0008e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00092	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	c7 41 78 00 00
	00 00		 mov	 DWORD PTR [ecx+120], 0
  0009c	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	83 c1 7c	 add	 ecx, 124		; 0000007cH
  000a2	e8 00 00 00 00	 call	 ??0CFont@@QAE@XZ	; CFont::CFont
  000a7	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000ab	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  000b4	e8 00 00 00 00	 call	 ??0CFont@@QAE@XZ	; CFont::CFont
  000b9	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000bd	6a 00		 push	 0
  000bf	6a 00		 push	 0
  000c1	6a 00		 push	 0
  000c3	6a 00		 push	 0
  000c5	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  000ce	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  000d3	6a 00		 push	 0
  000d5	6a 00		 push	 0
  000d7	6a 00		 push	 0
  000d9	6a 00		 push	 0
  000db	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  000e4	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  000e9	6a 00		 push	 0
  000eb	6a 00		 push	 0
  000ed	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	81 c1 ac 00 00
	00		 add	 ecx, 172		; 000000acH
  000f6	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint
  000fb	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00104	e8 00 00 00 00	 call	 ??0CCriticalSection@@QAE@XZ ; CCriticalSection::CCriticalSection
  00109	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0010d	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  00116	e8 00 00 00 00	 call	 ??0?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ ; std::deque<CPoint,std::allocator<CPoint> >::deque<CPoint,std::allocator<CPoint> >
  0011b	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0011f	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	81 c1 ec 00 00
	00		 add	 ecx, 236		; 000000ecH
  00128	e8 00 00 00 00	 call	 ??0GdiRes@@QAE@XZ	; GdiRes::GdiRes
  0012d	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  00130	c7 82 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+248], 0
  0013a	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  0013d	c7 80 fc 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+252], -1
  00147	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00150	e8 00 00 00 00	 call	 ??0CDC@@QAE@XZ		; CDC::CDC
  00155	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00159	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  00162	e8 00 00 00 00	 call	 ??0CBitmap@@QAE@XZ	; CBitmap::CBitmap
  00167	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0016b	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	c7 81 18 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+280], 0
  00178	6a ff		 push	 -1
  0017a	6a ff		 push	 -1
  0017c	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0017f	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  00185	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint
  0018a	6a 00		 push	 0
  0018c	6a 00		 push	 0
  0018e	6a 00		 push	 0
  00190	6a 00		 push	 0
  00192	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00195	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  0019b	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  001a0	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  001a3	c7 82 38 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+312], 0
  001ad	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  001b0	c7 80 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+324], 0
  001ba	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  001bd	c7 81 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+336], 0
  001c7	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  001ca	c7 82 54 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+340], 0
  001d4	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  001d7	c6 80 58 01 00
	00 00		 mov	 BYTE PTR [eax+344], 0
  001de	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e1	c7 81 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+348], 0
  001eb	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  001ee	c7 82 64 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+356], 0
  001f8	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  001fb	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00201	e8 00 00 00 00	 call	 ??0CLMCDataMgr@@QAE@XZ	; CLMCDataMgr::CLMCDataMgr
  00206	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  0020a	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  0020d	c7 80 78 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+376], 0

; 36   : 	m_pBitmapYes=new CBitmap();

  00217	6a 08		 push	 8
  00219	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  0021e	89 45 e4	 mov	 DWORD PTR $T202982[ebp], eax
  00221	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00225	83 7d e4 00	 cmp	 DWORD PTR $T202982[ebp], 0
  00229	74 0d		 je	 SHORT $L202983
  0022b	8b 4d e4	 mov	 ecx, DWORD PTR $T202982[ebp]
  0022e	e8 00 00 00 00	 call	 ??0CBitmap@@QAE@XZ	; CBitmap::CBitmap
  00233	89 45 9c	 mov	 DWORD PTR tv213[ebp], eax
  00236	eb 07		 jmp	 SHORT $L202984
$L202983:
  00238	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv213[ebp], 0
$L202984:
  0023f	8b 4d 9c	 mov	 ecx, DWORD PTR tv213[ebp]
  00242	89 4d e8	 mov	 DWORD PTR $T202981[ebp], ecx
  00245	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00249	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  0024c	8b 45 e8	 mov	 eax, DWORD PTR $T202981[ebp]
  0024f	89 82 48 01 00
	00		 mov	 DWORD PTR [edx+328], eax

; 37   : 	m_pBitmapNo=new CBitmap();

  00255	6a 08		 push	 8
  00257	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  0025c	89 45 dc	 mov	 DWORD PTR $T202986[ebp], eax
  0025f	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00263	83 7d dc 00	 cmp	 DWORD PTR $T202986[ebp], 0
  00267	74 0d		 je	 SHORT $L202987
  00269	8b 4d dc	 mov	 ecx, DWORD PTR $T202986[ebp]
  0026c	e8 00 00 00 00	 call	 ??0CBitmap@@QAE@XZ	; CBitmap::CBitmap
  00271	89 45 98	 mov	 DWORD PTR tv221[ebp], eax
  00274	eb 07		 jmp	 SHORT $L202988
$L202987:
  00276	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv221[ebp], 0
$L202988:
  0027d	8b 4d 98	 mov	 ecx, DWORD PTR tv221[ebp]
  00280	89 4d e0	 mov	 DWORD PTR $T202985[ebp], ecx
  00283	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00287	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  0028a	8b 45 e0	 mov	 eax, DWORD PTR $T202985[ebp]
  0028d	89 82 4c 01 00
	00		 mov	 DWORD PTR [edx+332], eax

; 38   : 	ISkinMgr*	pSkinMgr = AfxGetUIManager()->UIGetSkinMgr();

  00293	e8 00 00 00 00	 call	 ?AfxGetUIManager@@YAPAVIUIManager@@XZ ; AfxGetUIManager
  00298	89 45 94	 mov	 DWORD PTR tv223[ebp], eax
  0029b	8b 4d 94	 mov	 ecx, DWORD PTR tv223[ebp]
  0029e	8b 11		 mov	 edx, DWORD PTR [ecx]
  002a0	8b 4d 94	 mov	 ecx, DWORD PTR tv223[ebp]
  002a3	ff 52 28	 call	 DWORD PTR [edx+40]
  002a6	89 45 ec	 mov	 DWORD PTR _pSkinMgr$[ebp], eax

; 39   : 	SetScrollBitmap(pSkinMgr->GetDibBmp("ScrollVert"), pSkinMgr->GetDibBmp("ScrollHorz"));

  002a9	68 00 00 00 00	 push	 OFFSET FLAT:$SG199859
  002ae	8b 45 ec	 mov	 eax, DWORD PTR _pSkinMgr$[ebp]
  002b1	8b 10		 mov	 edx, DWORD PTR [eax]
  002b3	8b 4d ec	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  002b6	ff 52 04	 call	 DWORD PTR [edx+4]
  002b9	50		 push	 eax
  002ba	68 00 00 00 00	 push	 OFFSET FLAT:$SG199860
  002bf	8b 45 ec	 mov	 eax, DWORD PTR _pSkinMgr$[ebp]
  002c2	8b 10		 mov	 edx, DWORD PTR [eax]
  002c4	8b 4d ec	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  002c7	ff 52 04	 call	 DWORD PTR [edx+4]
  002ca	50		 push	 eax
  002cb	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  002ce	e8 00 00 00 00	 call	 ?SetScrollBitmap@CLocalMusicCoverList@@QAEXPAVCDibBitmap@@0@Z ; CLocalMusicCoverList::SetScrollBitmap

; 40   : 	m_gdires.colDetail = pSkinMgr->GetColor( "PlayedGameDetailTextColor" );

  002d3	68 00 00 00 00	 push	 OFFSET FLAT:$SG199861
  002d8	8b 45 ec	 mov	 eax, DWORD PTR _pSkinMgr$[ebp]
  002db	8b 10		 mov	 edx, DWORD PTR [eax]
  002dd	8b 4d ec	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  002e0	ff 52 08	 call	 DWORD PTR [edx+8]
  002e3	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  002e6	89 81 f4 00 00
	00		 mov	 DWORD PTR [ecx+244], eax

; 41   : 	m_gdires.colListBK = pSkinMgr->GetColor( "PlayedGameBkColor" );

  002ec	68 00 00 00 00	 push	 OFFSET FLAT:$SG199862
  002f1	8b 55 ec	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  002f4	8b 02		 mov	 eax, DWORD PTR [edx]
  002f6	8b 4d ec	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  002f9	ff 50 08	 call	 DWORD PTR [eax+8]
  002fc	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  002ff	89 81 ec 00 00
	00		 mov	 DWORD PTR [ecx+236], eax

; 42   : 	m_gdires.colName = pSkinMgr->GetColor( "PlayedGameNameColor" );

  00305	68 00 00 00 00	 push	 OFFSET FLAT:$SG199863
  0030a	8b 55 ec	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  0030d	8b 02		 mov	 eax, DWORD PTR [edx]
  0030f	8b 4d ec	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  00312	ff 50 08	 call	 DWORD PTR [eax+8]
  00315	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00318	89 81 f0 00 00
	00		 mov	 DWORD PTR [ecx+240], eax

; 43   : 	
; 44   : 	int iValue = 0;

  0031e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iValue$[ebp], 0

; 45   : 	AfxGetUserConfig()->GetConfigIntValue( CONF_APP_MODULE_NAME,CONF_APP_PLAYED_ICON_SIZE, iValue);

  00325	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_APP_PLAYED_ICON_SIZE
  0032b	52		 push	 edx
  0032c	8d 4d c0	 lea	 ecx, DWORD PTR $T202989[ebp]
  0032f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00335	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00339	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_APP_MODULE_NAME
  0033e	50		 push	 eax
  0033f	8d 4d a4	 lea	 ecx, DWORD PTR $T202990[ebp]
  00342	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00348	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  0034c	8d 4d f0	 lea	 ecx, DWORD PTR _iValue$[ebp]
  0034f	51		 push	 ecx
  00350	8d 55 c0	 lea	 edx, DWORD PTR $T202989[ebp]
  00353	52		 push	 edx
  00354	8d 45 a4	 lea	 eax, DWORD PTR $T202990[ebp]
  00357	50		 push	 eax
  00358	e8 00 00 00 00	 call	 ?AfxGetUserConfig@@YAPAVAfxUserConfig@@XZ ; AfxGetUserConfig
  0035d	8b c8		 mov	 ecx, eax
  0035f	e8 00 00 00 00	 call	 ?GetConfigIntValue@AfxUserConfig@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAH@Z ; AfxUserConfig::GetConfigIntValue
  00364	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00368	8d 4d a4	 lea	 ecx, DWORD PTR $T202990[ebp]
  0036b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00371	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00375	8d 4d c0	 lea	 ecx, DWORD PTR $T202989[ebp]
  00378	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 46   : 	switch( iValue )

  0037e	8b 4d f0	 mov	 ecx, DWORD PTR _iValue$[ebp]
  00381	89 4d 90	 mov	 DWORD PTR tv274[ebp], ecx
  00384	83 7d 90 00	 cmp	 DWORD PTR tv274[ebp], 0
  00388	74 08		 je	 SHORT $L199871
  0038a	83 7d 90 01	 cmp	 DWORD PTR tv274[ebp], 1
  0038e	74 10		 je	 SHORT $L199872
  00390	eb 1c		 jmp	 SHORT $L199873
$L199871:

; 47   : 	{
; 48   : 	case 0: //
; 49   : 		SetItemWH(80,80);

  00392	6a 50		 push	 80			; 00000050H
  00394	6a 50		 push	 80			; 00000050H
  00396	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00399	e8 00 00 00 00	 call	 ?SetItemWH@CLocalMusicCoverList@@QAEXHH@Z ; CLocalMusicCoverList::SetItemWH

; 50   : 		break;

  0039e	eb 20		 jmp	 SHORT $L199849
$L199872:

; 51   : 	case 1:
; 52   : 		SetItemWH(100,100);

  003a0	6a 64		 push	 100			; 00000064H
  003a2	6a 64		 push	 100			; 00000064H
  003a4	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  003a7	e8 00 00 00 00	 call	 ?SetItemWH@CLocalMusicCoverList@@QAEXHH@Z ; CLocalMusicCoverList::SetItemWH

; 53   : 		break;

  003ac	eb 12		 jmp	 SHORT $L199849
$L199873:

; 54   : 	default:
; 55   : 		SetItemWH(130,130);

  003ae	68 82 00 00 00	 push	 130			; 00000082H
  003b3	68 82 00 00 00	 push	 130			; 00000082H
  003b8	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  003bb	e8 00 00 00 00	 call	 ?SetItemWH@CLocalMusicCoverList@@QAEXHH@Z ; CLocalMusicCoverList::SetItemWH
$L199849:

; 56   : 		break;
; 57   : 	}
; 58   : }

  003c0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003c7	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  003ca	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003cd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  003d4	8b e5		 mov	 esp, ebp
  003d6	5d		 pop	 ebp
  003d7	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202991:
  00000	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CWnd@@UAE@XZ		; CWnd::~CWnd
$L202992:
  00008	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 60	 add	 ecx, 96			; 00000060H
  0000e	e9 00 00 00 00	 jmp	 ??1CDC@@UAE@XZ		; CDC::~CDC
$L202993:
  00013	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 70	 add	 ecx, 112		; 00000070H
  00019	e9 00 00 00 00	 jmp	 ??1CBitmap@@UAE@XZ	; CBitmap::~CBitmap
$L202994:
  0001e	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00024	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
$L202995:
  00029	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00032	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
$L202996:
  00037	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00040	e9 00 00 00 00	 jmp	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
$L202997:
  00045	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  0004e	e9 00 00 00 00	 jmp	 ??1?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ ; std::deque<CPoint,std::allocator<CPoint> >::~deque<CPoint,std::allocator<CPoint> >
$L202998:
  00053	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  0005c	e9 00 00 00 00	 jmp	 ??1CDC@@UAE@XZ		; CDC::~CDC
$L202999:
  00061	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  0006a	e9 00 00 00 00	 jmp	 ??1CBitmap@@UAE@XZ	; CBitmap::~CBitmap
$L203000:
  0006f	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00078	e9 00 00 00 00	 jmp	 ??1CLMCDataMgr@@QAE@XZ	; CLMCDataMgr::~CLMCDataMgr
$L203001:
  0007d	8b 45 e4	 mov	 eax, DWORD PTR $T202982[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00086	c3		 ret	 0
$L203002:
  00087	8b 45 dc	 mov	 eax, DWORD PTR $T202986[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00090	c3		 ret	 0
$L203003:
  00091	8d 4d c0	 lea	 ecx, DWORD PTR $T202989[ebp]
  00094	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203004:
  0009a	8d 4d a4	 lea	 ecx, DWORD PTR $T202990[ebp]
  0009d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0CLocalMusicCoverList@@QAE@XZ:
  000a3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203008
  000a8	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CLocalMusicCoverList@@QAE@XZ ENDP			; CLocalMusicCoverList::CLocalMusicCoverList
PUBLIC	??_R4CCriticalSection@@6B@			; CCriticalSection::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCriticalSection@@@8			; CCriticalSection `RTTI Type Descriptor'
PUBLIC	??_R3CCriticalSection@@8			; CCriticalSection::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCriticalSection@@8			; CCriticalSection::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CCriticalSection@@8		; CCriticalSection::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@CSyncObject@@8			; CSyncObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCSyncObject@@@8				; CSyncObject `RTTI Type Descriptor'
PUBLIC	?Unlock@CSyncObject@@UAEHJPAJ@Z			; CSyncObject::Unlock
PUBLIC	?Unlock@CCriticalSection@@UAEHXZ		; CCriticalSection::Unlock
PUBLIC	?Lock@CCriticalSection@@UAEHK@Z			; CCriticalSection::Lock
PUBLIC	?Init@CCriticalSection@@AAEHXZ			; CCriticalSection::Init
PUBLIC	??_7CCriticalSection@@6B@			; CCriticalSection::`vftable'
PUBLIC	??_GCCriticalSection@@UAEPAXI@Z			; CCriticalSection::`scalar deleting destructor'
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	??0CSyncObject@@QAE@PBD@Z:NEAR			; CSyncObject::CSyncObject
EXTRN	??1CSyncObject@@UAE@XZ:NEAR			; CSyncObject::~CSyncObject
EXTRN	?GetRuntimeClass@CCriticalSection@@UBEPAUCRuntimeClass@@XZ:NEAR ; CCriticalSection::GetRuntimeClass
EXTRN	??_ECCriticalSection@@UAEPAXI@Z:NEAR		; CCriticalSection::`vector deleting destructor'
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxmt.inl
xdata$x	SEGMENT
$T203018 DD	0ffffffffH
	DD	FLAT:$L203014
$T203016 DD	019930520H
	DD	01H
	DD	FLAT:$T203018
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CCriticalSection@@6B@
CONST	SEGMENT
??_7CCriticalSection@@6B@ DD FLAT:??_R4CCriticalSection@@6B@ ; CCriticalSection::`vftable'
	DD	FLAT:?GetRuntimeClass@CCriticalSection@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECCriticalSection@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?Lock@CCriticalSection@@UAEHK@Z
	DD	FLAT:?Unlock@CSyncObject@@UAEHJPAJ@Z
	DD	FLAT:?Unlock@CCriticalSection@@UAEHXZ
CONST	ENDS
;	COMDAT ??_R4CCriticalSection@@6B@
rdata$r	SEGMENT
??_R4CCriticalSection@@6B@ DD 00H			; CCriticalSection::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCriticalSection@@@8
	DD	FLAT:??_R3CCriticalSection@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCriticalSection@@@8
_DATA	SEGMENT
??_R0?AVCCriticalSection@@@8 DD FLAT:??_7type_info@@6B@	; CCriticalSection `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCriticalSection@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CCriticalSection@@8
rdata$r	SEGMENT
??_R3CCriticalSection@@8 DD 00H				; CCriticalSection::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CCriticalSection@@8
rdata$r	ENDS
;	COMDAT ??_R2CCriticalSection@@8
rdata$r	SEGMENT
??_R2CCriticalSection@@8 DD FLAT:??_R1A@?0A@A@CCriticalSection@@8 ; CCriticalSection::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CSyncObject@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCriticalSection@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CCriticalSection@@8 DD FLAT:??_R0?AVCCriticalSection@@@8 ; CCriticalSection::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSyncObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CSyncObject@@8 DD FLAT:??_R0?AVCSyncObject@@@8 ; CSyncObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCSyncObject@@@8
_DATA	SEGMENT
??_R0?AVCSyncObject@@@8 DD FLAT:??_7type_info@@6B@	; CSyncObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSyncObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0CCriticalSection@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_bSuccess$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0CCriticalSection@@QAE@XZ PROC NEAR			; CCriticalSection::CCriticalSection, COMDAT
; _this$ = ecx

; 56   : 	{ 	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CCriticalSection@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	6a 00		 push	 0
  00020	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0CSyncObject@@QAE@PBD@Z ; CSyncObject::CSyncObject
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CCriticalSection@@6B@

; 57   : 		BOOL bSuccess;
; 58   : 
; 59   : 		bSuccess = Init();

  00038	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?Init@CCriticalSection@@AAEHXZ ; CCriticalSection::Init
  00040	89 45 f0	 mov	 DWORD PTR _bSuccess$[ebp], eax

; 60   : 		if (!bSuccess)

  00043	83 7d f0 00	 cmp	 DWORD PTR _bSuccess$[ebp], 0
  00047	75 05		 jne	 SHORT $L197587

; 61   : 			AfxThrowMemoryException();

  00049	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L197587:

; 62   : 	}

  0004e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$L203013:
  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203014:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CSyncObject@@UAE@XZ	; CSyncObject::~CSyncObject
__ehhandler$??0CCriticalSection@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203016
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CCriticalSection@@QAE@XZ ENDP			; CCriticalSection::CCriticalSection
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxmt.h
;	COMDAT ?Unlock@CSyncObject@@UAEHJPAJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?Unlock@CSyncObject@@UAEHJPAJ@Z PROC NEAR		; CSyncObject::Unlock, COMDAT
; _this$ = ecx

; 71   : 		{ return TRUE; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 01 00 00 00	 mov	 eax, 1
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?Unlock@CSyncObject@@UAEHJPAJ@Z ENDP			; CSyncObject::Unlock
_TEXT	ENDS
EXTRN	__except_handler3:NEAR
EXTRN	__imp__InitializeCriticalSection@4:NEAR
;	COMDAT CONST
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxmt.inl
CONST	SEGMENT
$T203030 DD	0ffffffffH
	DD	FLAT:$L203026
	DD	FLAT:$L203027
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Init@CCriticalSection@@AAEHXZ
_TEXT	SEGMENT
tv68 = -32						; size = 4
_this$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
?Init@CCriticalSection@@AAEHXZ PROC NEAR		; CCriticalSection::Init, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 OFFSET FLAT:$T203030
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:__except_handler3
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00015	50		 push	 eax
  00016	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001d	83 c4 f0	 add	 esp, -16		; fffffff0H
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00026	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 	__try

  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 44   : 	{
; 45   : 		::InitializeCriticalSection(&m_sect);

  00030	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 c0 08	 add	 eax, 8
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
  0003d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00044	eb 1c		 jmp	 SHORT $L203029
$L203026:
$L203034:

; 46   : 	}
; 47   : 	__except( EXCEPTION_EXECUTE_HANDLER )

  00046	b8 01 00 00 00	 mov	 eax, 1
$L203028:
$L203033:
  0004b	c3		 ret	 0
$L203027:
  0004c	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]
  0004f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00056	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1

; 48   : 	{
; 49   : 		return FALSE;

  0005d	8b 45 e0	 mov	 eax, DWORD PTR tv68[ebp]
  00060	eb 05		 jmp	 SHORT $L203025
$L203029:

; 50   : 	}
; 51   : 
; 52   : 	return TRUE;

  00062	b8 01 00 00 00	 mov	 eax, 1
$L203025:

; 53   : }

  00067	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?Init@CCriticalSection@@AAEHXZ ENDP			; CCriticalSection::Init
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCCriticalSection@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCCriticalSection@@UAEPAXI@Z PROC NEAR		; CCriticalSection::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L197593
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L197593:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCCriticalSection@@UAEPAXI@Z ENDP			; CCriticalSection::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp__DeleteCriticalSection@4:NEAR
; Function compile flags: /Odt
;	COMDAT ??1CCriticalSection@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CCriticalSection@@UAE@XZ PROC NEAR			; CCriticalSection::~CCriticalSection, COMDAT
; _this$ = ecx

; 67   : 	{ ::DeleteCriticalSection(&m_sect); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CCriticalSection@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	51		 push	 ecx
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??1CSyncObject@@UAE@XZ	; CSyncObject::~CSyncObject
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??1CCriticalSection@@UAE@XZ ENDP			; CCriticalSection::~CCriticalSection
_TEXT	ENDS
PUBLIC	?Lock@CCriticalSection@@QAEHXZ			; CCriticalSection::Lock
; Function compile flags: /Odt
;	COMDAT ?Lock@CCriticalSection@@UAEHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwTimeout$ = 8						; size = 4
?Lock@CCriticalSection@@UAEHK@Z PROC NEAR		; CCriticalSection::Lock, COMDAT
; _this$ = ecx

; 81   : 	{ ASSERT(dwTimeout == INFINITE); (void)dwTimeout; return Lock(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Lock@CCriticalSection@@QAEHXZ ; CCriticalSection::Lock
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?Lock@CCriticalSection@@UAEHK@Z ENDP			; CCriticalSection::Lock
_TEXT	ENDS
EXTRN	__imp__EnterCriticalSection@4:NEAR
;	COMDAT CONST
CONST	SEGMENT
$T203051 DD	0ffffffffH
	DD	FLAT:$L203047
	DD	FLAT:$L203048
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Lock@CCriticalSection@@QAEHXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
?Lock@CCriticalSection@@QAEHXZ PROC NEAR		; CCriticalSection::Lock, COMDAT
; _this$ = ecx

; 69   : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 OFFSET FLAT:$T203051
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:__except_handler3
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00015	50		 push	 eax
  00016	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001d	83 c4 f4	 add	 esp, -12		; fffffff4H
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00026	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 70   : 		__try

  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 71   : 		{
; 72   : 			::EnterCriticalSection(&m_sect); 

  00030	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 c0 08	 add	 eax, 8
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0003d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00044	eb 0e		 jmp	 SHORT $L203050
$L203047:
$L203054:

; 73   : 		}
; 74   : 		__except( EXCEPTION_EXECUTE_HANDLER )

  00046	b8 01 00 00 00	 mov	 eax, 1
$L203049:
$L203053:
  0004b	c3		 ret	 0
$L203048:
  0004c	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 75   : 		{
; 76   : 			AfxThrowMemoryException();

  0004f	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L203050:

; 77   : 		}
; 78   : 		return TRUE; 

  00054	b8 01 00 00 00	 mov	 eax, 1
$L203046:

; 79   : 	}

  00059	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?Lock@CCriticalSection@@QAEHXZ ENDP			; CCriticalSection::Lock
_TEXT	ENDS
EXTRN	__imp__LeaveCriticalSection@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Unlock@CCriticalSection@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Unlock@CCriticalSection@@UAEHXZ PROC NEAR		; CCriticalSection::Unlock, COMDAT
; _this$ = ecx

; 83   : 	{ ::LeaveCriticalSection(&m_sect); return TRUE; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00014	b8 01 00 00 00	 mov	 eax, 1
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?Unlock@CCriticalSection@@UAEHXZ ENDP			; CCriticalSection::Unlock
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\playedgamepanel\lmcstructs.h
_TEXT	ENDS
;	COMDAT ??0GdiRes@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0GdiRes@@QAE@XZ PROC NEAR				; GdiRes::GdiRes, COMDAT
; _this$ = ecx

; 13   : 	GdiRes()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 14   : 	{
; 15   : 		colListBK = RGB(240,247,252);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 f0 f7 fc
	00		 mov	 DWORD PTR [eax], 16578544 ; 00fcf7f0H

; 16   : 		colName   = RGB(77,77,77);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 4d 4d
	4d 00		 mov	 DWORD PTR [ecx+4], 5066061 ; 004d4d4dH

; 17   : 		colDetail = RGB(125,125,125);

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 7d 7d
	7d 00		 mov	 DWORD PTR [edx+8], 8224125 ; 007d7d7dH

; 18   : 	}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0GdiRes@@QAE@XZ ENDP					; GdiRes::GdiRes
_TEXT	ENDS
PUBLIC	??1CLocalMusicCoverList@@UAE@XZ			; CLocalMusicCoverList::~CLocalMusicCoverList
; Function compile flags: /Odt
;	COMDAT ??_GCLocalMusicCoverList@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCLocalMusicCoverList@@UAEPAXI@Z PROC NEAR		; CLocalMusicCoverList::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CLocalMusicCoverList@@UAE@XZ ; CLocalMusicCoverList::~CLocalMusicCoverList
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L199877
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L199877:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCLocalMusicCoverList@@UAEPAXI@Z ENDP		; CLocalMusicCoverList::`scalar deleting destructor'
_TEXT	ENDS
xdata$x	SEGMENT
$T203086 DD	0ffffffffH
	DD	FLAT:$L203073
	DD	00H
	DD	FLAT:$L203074
	DD	01H
	DD	FLAT:$L203075
	DD	02H
	DD	FLAT:$L203076
	DD	03H
	DD	FLAT:$L203077
	DD	04H
	DD	FLAT:$L203078
	DD	05H
	DD	FLAT:$L203079
	DD	06H
	DD	FLAT:$L203080
	DD	07H
	DD	FLAT:$L203081
	DD	08H
	DD	FLAT:$L203082
$T203084 DD	019930520H
	DD	0aH
	DD	FLAT:$T203086
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\playedgamepanel\localmusiccoverlist.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv148 = -40						; size = 4
tv140 = -36						; size = 4
_this$ = -32						; size = 4
$T203070 = -28						; size = 4
$T203069 = -24						; size = 4
$T203066 = -20						; size = 4
$T203065 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CLocalMusicCoverList@@UAE@XZ PROC NEAR		; CLocalMusicCoverList::~CLocalMusicCoverList
; _this$ = ecx

; 61   : {

  003e0	55		 push	 ebp
  003e1	8b ec		 mov	 ebp, esp
  003e3	6a ff		 push	 -1
  003e5	68 00 00 00 00	 push	 __ehhandler$??1CLocalMusicCoverList@@UAE@XZ
  003ea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  003f0	50		 push	 eax
  003f1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  003f8	83 ec 1c	 sub	 esp, 28			; 0000001cH
  003fb	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  003fe	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00401	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CLocalMusicCoverList@@6B@
  00407	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9

; 62   : 	delete m_pBitmapYes;

  0040e	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00411	8b 91 48 01 00
	00		 mov	 edx, DWORD PTR [ecx+328]
  00417	89 55 ec	 mov	 DWORD PTR $T203066[ebp], edx
  0041a	8b 45 ec	 mov	 eax, DWORD PTR $T203066[ebp]
  0041d	89 45 f0	 mov	 DWORD PTR $T203065[ebp], eax
  00420	83 7d f0 00	 cmp	 DWORD PTR $T203065[ebp], 0
  00424	74 12		 je	 SHORT $L203067
  00426	6a 01		 push	 1
  00428	8b 4d f0	 mov	 ecx, DWORD PTR $T203065[ebp]
  0042b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0042d	8b 4d f0	 mov	 ecx, DWORD PTR $T203065[ebp]
  00430	ff 52 04	 call	 DWORD PTR [edx+4]
  00433	89 45 dc	 mov	 DWORD PTR tv140[ebp], eax
  00436	eb 07		 jmp	 SHORT $L203068
$L203067:
  00438	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$L203068:

; 63   : 	delete m_pBitmapNo;

  0043f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00442	8b 88 4c 01 00
	00		 mov	 ecx, DWORD PTR [eax+332]
  00448	89 4d e4	 mov	 DWORD PTR $T203070[ebp], ecx
  0044b	8b 55 e4	 mov	 edx, DWORD PTR $T203070[ebp]
  0044e	89 55 e8	 mov	 DWORD PTR $T203069[ebp], edx
  00451	83 7d e8 00	 cmp	 DWORD PTR $T203069[ebp], 0
  00455	74 12		 je	 SHORT $L203071
  00457	6a 01		 push	 1
  00459	8b 45 e8	 mov	 eax, DWORD PTR $T203069[ebp]
  0045c	8b 10		 mov	 edx, DWORD PTR [eax]
  0045e	8b 4d e8	 mov	 ecx, DWORD PTR $T203069[ebp]
  00461	ff 52 04	 call	 DWORD PTR [edx+4]
  00464	89 45 d8	 mov	 DWORD PTR tv148[ebp], eax
  00467	eb 07		 jmp	 SHORT $L199880
$L203071:
  00469	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv148[ebp], 0
$L199880:

; 64   : }

  00470	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00474	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00477	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0047d	e8 00 00 00 00	 call	 ??1CLMCDataMgr@@QAE@XZ	; CLMCDataMgr::~CLMCDataMgr
  00482	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00486	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00489	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  0048f	e8 00 00 00 00	 call	 ??1CBitmap@@UAE@XZ	; CBitmap::~CBitmap
  00494	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00498	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0049b	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  004a1	e8 00 00 00 00	 call	 ??1CDC@@UAE@XZ		; CDC::~CDC
  004a6	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  004aa	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  004ad	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  004b3	e8 00 00 00 00	 call	 ??1?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ ; std::deque<CPoint,std::allocator<CPoint> >::~deque<CPoint,std::allocator<CPoint> >
  004b8	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  004bc	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  004bf	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  004c5	e8 00 00 00 00	 call	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
  004ca	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  004ce	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  004d1	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  004d7	e8 00 00 00 00	 call	 ??1CFont@@UAE@XZ	; CFont::~CFont
  004dc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  004e0	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  004e3	83 c1 7c	 add	 ecx, 124		; 0000007cH
  004e6	e8 00 00 00 00	 call	 ??1CFont@@UAE@XZ	; CFont::~CFont
  004eb	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  004ef	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  004f2	83 c1 70	 add	 ecx, 112		; 00000070H
  004f5	e8 00 00 00 00	 call	 ??1CBitmap@@UAE@XZ	; CBitmap::~CBitmap
  004fa	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  004fe	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00501	83 c1 60	 add	 ecx, 96			; 00000060H
  00504	e8 00 00 00 00	 call	 ??1CDC@@UAE@XZ		; CDC::~CDC
  00509	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00510	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00513	e8 00 00 00 00	 call	 ??1CWnd@@UAE@XZ		; CWnd::~CWnd
  00518	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0051b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00522	8b e5		 mov	 esp, ebp
  00524	5d		 pop	 ebp
  00525	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L203073:
  000ad	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	e9 00 00 00 00	 jmp	 ??1CWnd@@UAE@XZ		; CWnd::~CWnd
$L203074:
  000b5	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	83 c1 60	 add	 ecx, 96			; 00000060H
  000bb	e9 00 00 00 00	 jmp	 ??1CDC@@UAE@XZ		; CDC::~CDC
$L203075:
  000c0	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	83 c1 70	 add	 ecx, 112		; 00000070H
  000c6	e9 00 00 00 00	 jmp	 ??1CBitmap@@UAE@XZ	; CBitmap::~CBitmap
$L203076:
  000cb	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	83 c1 7c	 add	 ecx, 124		; 0000007cH
  000d1	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
$L203077:
  000d6	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  000df	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
$L203078:
  000e4	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  000ed	e9 00 00 00 00	 jmp	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
$L203079:
  000f2	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  000fb	e9 00 00 00 00	 jmp	 ??1?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ ; std::deque<CPoint,std::allocator<CPoint> >::~deque<CPoint,std::allocator<CPoint> >
$L203080:
  00100	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00109	e9 00 00 00 00	 jmp	 ??1CDC@@UAE@XZ		; CDC::~CDC
$L203081:
  0010e	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00111	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  00117	e9 00 00 00 00	 jmp	 ??1CBitmap@@UAE@XZ	; CBitmap::~CBitmap
$L203082:
  0011c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00125	e9 00 00 00 00	 jmp	 ??1CLMCDataMgr@@QAE@XZ	; CLMCDataMgr::~CLMCDataMgr
__ehhandler$??1CLocalMusicCoverList@@UAE@XZ:
  0012a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203084
  0012f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CLocalMusicCoverList@@UAE@XZ ENDP			; CLocalMusicCoverList::~CLocalMusicCoverList
PUBLIC	?GetThisMessageMap@CLocalMusicCoverList@@KGPBUAFX_MSGMAP@@XZ ; CLocalMusicCoverList::GetThisMessageMap
; Function compile flags: /Odt
_TEXT	SEGMENT
?GetThisMessageMap@CLocalMusicCoverList@@KGPBUAFX_MSGMAP@@XZ PROC NEAR ; CLocalMusicCoverList::GetThisMessageMap

; 66   : BEGIN_MESSAGE_MAP(CLocalMusicCoverList, CWnd)

  00530	55		 push	 ebp
  00531	8b ec		 mov	 ebp, esp
  00533	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?messageMap@CLocalMusicCoverList@@1UAFX_MSGMAP@@B ; CLocalMusicCoverList::messageMap
  00538	5d		 pop	 ebp
  00539	c3		 ret	 0
?GetThisMessageMap@CLocalMusicCoverList@@KGPBUAFX_MSGMAP@@XZ ENDP ; CLocalMusicCoverList::GetThisMessageMap
; Function compile flags: /Odt
_this$ = -4						; size = 4
?GetMessageMap@CLocalMusicCoverList@@MBEPBUAFX_MSGMAP@@XZ PROC NEAR ; CLocalMusicCoverList::GetMessageMap
; _this$ = ecx

; 66   : BEGIN_MESSAGE_MAP(CLocalMusicCoverList, CWnd)

  00540	55		 push	 ebp
  00541	8b ec		 mov	 ebp, esp
  00543	51		 push	 ecx
  00544	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00547	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?messageMap@CLocalMusicCoverList@@1UAFX_MSGMAP@@B ; CLocalMusicCoverList::messageMap
  0054c	8b e5		 mov	 esp, ebp
  0054e	5d		 pop	 ebp
  0054f	c3		 ret	 0
?GetMessageMap@CLocalMusicCoverList@@MBEPBUAFX_MSGMAP@@XZ ENDP ; CLocalMusicCoverList::GetMessageMap
_TEXT	ENDS
PUBLIC	?CreateCompatibleDC@CDC@@QAEHPAV1@@Z		; CDC::CreateCompatibleDC
PUBLIC	?SetTimer@CWnd@@QAEIIIP6GXPAUHWND__@@IIK@Z@Z	; CWnd::SetTimer
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
PUBLIC	??0Image@Gdiplus@@QAE@PB_WH@Z			; Gdiplus::Image::Image
PUBLIC	??1Image@Gdiplus@@UAE@XZ			; Gdiplus::Image::~Image
PUBLIC	?Clone@Image@Gdiplus@@UAEPAV12@XZ		; Gdiplus::Image::Clone
PUBLIC	?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z	; CWnd::OnCreate
PUBLIC	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z		; AtlA2WHelper
PUBLIC	?CreateFontA@CFont@@QAEHHHHHHEEEEEEEEPBD@Z	; CFont::CreateFontA
EXTRN	__imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:NEAR
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:NEAR
EXTRN	__imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:NEAR
EXTRN	__imp_?ReverseFind@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHD@Z:NEAR
EXTRN	__alloca_probe:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z:NEAR
EXTRN	__imp__GetModuleFileNameA@12:NEAR
EXTRN	??0CClientDC@@QAE@PAVCWnd@@@Z:NEAR		; CClientDC::CClientDC
EXTRN	??1CClientDC@@UAE@XZ:NEAR			; CClientDC::~CClientDC
xdata$x	SEGMENT
$T203106 DD	0ffffffffH
	DD	FLAT:$L203095
	DD	00H
	DD	FLAT:$L203096
	DD	01H
	DD	FLAT:$L203097
	DD	01H
	DD	FLAT:$L203098
$T203100 DD	019930520H
	DD	04H
	DD	FLAT:$T203106
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv195 = -368						; size = 4
tv199 = -364						; size = 4
tv208 = -360						; size = 4
tv163 = -356						; size = 4
_this$ = -352						; size = 4
$T203094 = -348						; size = 4
$T203091 = -344						; size = 4
__lpa$ = -340						; size = 4
__acp$ = -336						; size = 4
_path_tmp$ = -332					; size = 260
__$ArrayPad$ = -64					; size = 4
_strFrameImg$ = -60					; size = 4
_imgFrame$ = -52					; size = 16
_dc$ = -36						; size = 20
__convert$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lpCreateStruct$ = 8					; size = 4
?OnCreate@CLocalMusicCoverList@@IAEHPAUtagCREATESTRUCTA@@@Z PROC NEAR ; CLocalMusicCoverList::OnCreate
; _this$ = ecx

; 89   : {

  00550	55		 push	 ebp
  00551	8b ec		 mov	 ebp, esp
  00553	6a ff		 push	 -1
  00555	68 00 00 00 00	 push	 __ehhandler$?OnCreate@CLocalMusicCoverList@@IAEHPAUtagCREATESTRUCTA@@@Z
  0055a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00560	50		 push	 eax
  00561	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00568	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  0056e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00573	89 45 c0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00576	57		 push	 edi
  00577	89 8d a0 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 90   : 	if (CWnd::OnCreate(lpCreateStruct) == -1)

  0057d	8b 45 08	 mov	 eax, DWORD PTR _lpCreateStruct$[ebp]
  00580	50		 push	 eax
  00581	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00587	e8 00 00 00 00	 call	 ?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z ; CWnd::OnCreate
  0058c	83 f8 ff	 cmp	 eax, -1
  0058f	75 08		 jne	 SHORT $L199988

; 91   : 		return -1;

  00591	83 c8 ff	 or	 eax, -1
  00594	e9 71 02 00 00	 jmp	 $L199987
$L199988:

; 92   : 	// 
; 93   : 	CClientDC dc(this);

  00599	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0059f	51		 push	 ecx
  005a0	8d 4d dc	 lea	 ecx, DWORD PTR _dc$[ebp]
  005a3	e8 00 00 00 00	 call	 ??0CClientDC@@QAE@PAVCWnd@@@Z ; CClientDC::CClientDC
  005a8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 94   : 	m_dcMem.CreateCompatibleDC(&dc);

  005af	8d 55 dc	 lea	 edx, DWORD PTR _dc$[ebp]
  005b2	52		 push	 edx
  005b3	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005b9	83 c1 60	 add	 ecx, 96			; 00000060H
  005bc	e8 00 00 00 00	 call	 ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z ; CDC::CreateCompatibleDC

; 95   : 	m_dcTracker.CreateCompatibleDC(&dc);

  005c1	8d 45 dc	 lea	 eax, DWORD PTR _dc$[ebp]
  005c4	50		 push	 eax
  005c5	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005cb	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  005d1	e8 00 00 00 00	 call	 ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z ; CDC::CreateCompatibleDC

; 96   : 	m_fName.CreateFont(12, 0, 0, 0, FW_BOLD , FALSE, FALSE, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, _T(""));

  005d6	68 00 00 00 00	 push	 OFFSET FLAT:$SG199990
  005db	6a 20		 push	 32			; 00000020H
  005dd	6a 00		 push	 0
  005df	6a 00		 push	 0
  005e1	6a 00		 push	 0
  005e3	6a 00		 push	 0
  005e5	6a 00		 push	 0
  005e7	6a 00		 push	 0
  005e9	6a 00		 push	 0
  005eb	68 bc 02 00 00	 push	 700			; 000002bcH
  005f0	6a 00		 push	 0
  005f2	6a 00		 push	 0
  005f4	6a 00		 push	 0
  005f6	6a 0c		 push	 12			; 0000000cH
  005f8	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005fe	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00601	e8 00 00 00 00	 call	 ?CreateFontA@CFont@@QAEHHHHHHEEEEEEEEPBD@Z ; CFont::CreateFontA

; 97   : 	m_fDeInfo.CreateFont(12, 0, 0, 0, FW_NORMAL , FALSE, FALSE, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, _T(""));

  00606	68 00 00 00 00	 push	 OFFSET FLAT:$SG199991
  0060b	6a 20		 push	 32			; 00000020H
  0060d	6a 00		 push	 0
  0060f	6a 00		 push	 0
  00611	6a 00		 push	 0
  00613	6a 00		 push	 0
  00615	6a 00		 push	 0
  00617	6a 00		 push	 0
  00619	6a 00		 push	 0
  0061b	68 90 01 00 00	 push	 400			; 00000190H
  00620	6a 00		 push	 0
  00622	6a 00		 push	 0
  00624	6a 00		 push	 0
  00626	6a 0c		 push	 12			; 0000000cH
  00628	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0062e	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00634	e8 00 00 00 00	 call	 ?CreateFontA@CFont@@QAEHHHHHHEEEEEEEEPBD@Z ; CFont::CreateFontA

; 98   : 	// 
; 99   : 	m_vScrollTimer = SetTimer(100,1,NULL);

  00639	6a 00		 push	 0
  0063b	6a 01		 push	 1
  0063d	6a 64		 push	 100			; 00000064H
  0063f	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00645	e8 00 00 00 00	 call	 ?SetTimer@CWnd@@QAEIIIP6GXPAUHWND__@@IIK@Z@Z ; CWnd::SetTimer
  0064a	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00650	89 81 e8 00 00
	00		 mov	 DWORD PTR [ecx+232], eax

; 100  : 	// 
; 101  : 	m_bf.BlendOp = AC_SRC_OVER; 

  00656	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0065c	c6 82 24 01 00
	00 00		 mov	 BYTE PTR [edx+292], 0

; 102  : 	m_bf.BlendFlags = 0; 

  00663	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00669	c6 80 25 01 00
	00 00		 mov	 BYTE PTR [eax+293], 0

; 103  : 	m_bf.AlphaFormat = 0; 

  00670	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00676	c6 81 27 01 00
	00 00		 mov	 BYTE PTR [ecx+295], 0

; 104  : 	m_bf.SourceConstantAlpha = 50; 

  0067d	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00683	c6 82 26 01 00
	00 32		 mov	 BYTE PTR [edx+294], 50	; 00000032H

; 105  : 
; 106  : 	TCHAR path_tmp[MAX_PATH]={0};

  0068a	c6 85 b4 fe ff
	ff 00		 mov	 BYTE PTR _path_tmp$[ebp], 0
  00691	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00696	33 c0		 xor	 eax, eax
  00698	8d bd b5 fe ff
	ff		 lea	 edi, DWORD PTR _path_tmp$[ebp+1]
  0069e	f3 ab		 rep stosd
  006a0	66 ab		 stosw
  006a2	aa		 stosb

; 107  : 	::GetModuleFileName(NULL,path_tmp,MAX_PATH);

  006a3	68 04 01 00 00	 push	 260			; 00000104H
  006a8	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _path_tmp$[ebp]
  006ae	50		 push	 eax
  006af	6a 00		 push	 0
  006b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 108  : 	CString strFrameImg(path_tmp);

  006b7	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _path_tmp$[ebp]
  006bd	51		 push	 ecx
  006be	8d 4d c4	 lea	 ecx, DWORD PTR _strFrameImg$[ebp]
  006c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  006c7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 109  : 	strFrameImg=strFrameImg.Mid(0,strFrameImg.ReverseFind('\\'));

  006cb	6a 5c		 push	 92			; 0000005cH
  006cd	8d 4d c4	 lea	 ecx, DWORD PTR _strFrameImg$[ebp]
  006d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReverseFind@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHD@Z
  006d6	50		 push	 eax
  006d7	6a 00		 push	 0
  006d9	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR $T203091[ebp]
  006df	52		 push	 edx
  006e0	8d 4d c4	 lea	 ecx, DWORD PTR _strFrameImg$[ebp]
  006e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z
  006e9	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv163[ebp], eax
  006ef	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv163[ebp]
  006f5	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv208[ebp], eax
  006fb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  006ff	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR tv208[ebp]
  00705	51		 push	 ecx
  00706	8d 4d c4	 lea	 ecx, DWORD PTR _strFrameImg$[ebp]
  00709	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0070f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00713	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR $T203091[ebp]
  00719	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 110  : 	strFrameImg+="\\Resources\\StandardUI\\IconBorder.png";

  0071f	68 00 00 00 00	 push	 OFFSET FLAT:$SG199995
  00724	8d 4d c4	 lea	 ecx, DWORD PTR _strFrameImg$[ebp]
  00727	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 111  : 	USES_CONVERSION;

  0072d	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00732	89 85 b0 fe ff
	ff		 mov	 DWORD PTR __acp$[ebp], eax

; 112  : 	Image imgFrame(A2W(strFrameImg));

  00738	8d 4d c4	 lea	 ecx, DWORD PTR _strFrameImg$[ebp]
  0073b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00741	89 85 ac fe ff
	ff		 mov	 DWORD PTR __lpa$[ebp], eax
  00747	83 bd ac fe ff
	ff 00		 cmp	 DWORD PTR __lpa$[ebp], 0
  0074e	75 0c		 jne	 SHORT $L203092
  00750	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv199[ebp], 0
  0075a	eb 4d		 jmp	 SHORT $L203093
$L203092:
  0075c	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR __lpa$[ebp]
  00762	52		 push	 edx
  00763	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00769	83 c0 01	 add	 eax, 1
  0076c	89 45 f0	 mov	 DWORD PTR __convert$[ebp], eax
  0076f	8b 45 f0	 mov	 eax, DWORD PTR __convert$[ebp]
  00772	d1 e0		 shl	 eax, 1
  00774	83 c0 03	 add	 eax, 3
  00777	83 e0 fc	 and	 eax, -4			; fffffffcH
  0077a	e8 00 00 00 00	 call	 __alloca_probe
  0077f	89 a5 90 fe ff
	ff		 mov	 DWORD PTR tv195[ebp], esp
  00785	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR __acp$[ebp]
  0078b	50		 push	 eax
  0078c	8b 4d f0	 mov	 ecx, DWORD PTR __convert$[ebp]
  0078f	51		 push	 ecx
  00790	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR __lpa$[ebp]
  00796	52		 push	 edx
  00797	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv195[ebp]
  0079d	50		 push	 eax
  0079e	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  007a3	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv199[ebp], eax
$L203093:
  007a9	6a 00		 push	 0
  007ab	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR tv199[ebp]
  007b1	51		 push	 ecx
  007b2	8d 4d cc	 lea	 ecx, DWORD PTR _imgFrame$[ebp]
  007b5	e8 00 00 00 00	 call	 ??0Image@Gdiplus@@QAE@PB_WH@Z ; Gdiplus::Image::Image
  007ba	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 113  : 	pImageFrame=imgFrame.Clone();

  007be	8d 4d cc	 lea	 ecx, DWORD PTR _imgFrame$[ebp]
  007c1	e8 00 00 00 00	 call	 ?Clone@Image@Gdiplus@@UAEPAV12@XZ ; Gdiplus::Image::Clone
  007c6	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  007cc	89 82 60 01 00
	00		 mov	 DWORD PTR [edx+352], eax

; 114  : 	return 0;

  007d2	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T203094[ebp], 0
  007dc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  007e0	8d 4d cc	 lea	 ecx, DWORD PTR _imgFrame$[ebp]
  007e3	e8 00 00 00 00	 call	 ??1Image@Gdiplus@@UAE@XZ ; Gdiplus::Image::~Image
  007e8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  007ec	8d 4d c4	 lea	 ecx, DWORD PTR _strFrameImg$[ebp]
  007ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  007f5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  007fc	8d 4d dc	 lea	 ecx, DWORD PTR _dc$[ebp]
  007ff	e8 00 00 00 00	 call	 ??1CClientDC@@UAE@XZ	; CClientDC::~CClientDC
  00804	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR $T203094[ebp]
$L199987:

; 115  : }

  0080a	8d a5 8c fe ff
	ff		 lea	 esp, DWORD PTR [ebp-372]
  00810	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00813	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0081a	8b 4d c0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00822	5f		 pop	 edi
  00823	8b e5		 mov	 esp, ebp
  00825	5d		 pop	 ebp
  00826	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L203095:
  00134	8d 4d dc	 lea	 ecx, DWORD PTR _dc$[ebp]
  00137	e9 00 00 00 00	 jmp	 ??1CClientDC@@UAE@XZ	; CClientDC::~CClientDC
$L203096:
  0013c	8d 4d c4	 lea	 ecx, DWORD PTR _strFrameImg$[ebp]
  0013f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L203097:
  00145	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR $T203091[ebp]
  0014b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L203098:
  00151	8d 4d cc	 lea	 ecx, DWORD PTR _imgFrame$[ebp]
  00154	e9 00 00 00 00	 jmp	 ??1Image@Gdiplus@@UAE@XZ ; Gdiplus::Image::~Image
__ehhandler$?OnCreate@CLocalMusicCoverList@@IAEHPAUtagCREATESTRUCTA@@@Z:
  00159	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203100
  0015e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OnCreate@CLocalMusicCoverList@@IAEHPAUtagCREATESTRUCTA@@@Z ENDP ; CLocalMusicCoverList::OnCreate
PUBLIC	?OnEraseBkgnd@CWnd@@IAEHPAVCDC@@@Z		; CWnd::OnEraseBkgnd
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?OnEraseBkgnd@CLocalMusicCoverList@@IAEHPAVCDC@@@Z PROC NEAR ; CLocalMusicCoverList::OnEraseBkgnd
; _this$ = ecx

; 118  : {

  00830	55		 push	 ebp
  00831	8b ec		 mov	 ebp, esp
  00833	51		 push	 ecx
  00834	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  : 	return CWnd::OnEraseBkgnd(pDC);

  00837	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  0083a	50		 push	 eax
  0083b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0083e	e8 00 00 00 00	 call	 ?OnEraseBkgnd@CWnd@@IAEHPAVCDC@@@Z ; CWnd::OnEraseBkgnd

; 120  : }

  00843	8b e5		 mov	 esp, ebp
  00845	5d		 pop	 ebp
  00846	c2 04 00	 ret	 4
?OnEraseBkgnd@CLocalMusicCoverList@@IAEHPAVCDC@@@Z ENDP	; CLocalMusicCoverList::OnEraseBkgnd
_TEXT	ENDS
PUBLIC	?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z		; CWnd::GetClientRect
PUBLIC	??0CSize@@QAE@HH@Z				; CSize::CSize
PUBLIC	??0CRect@@QAE@XZ				; CRect::CRect
PUBLIC	?Width@CRect@@QBEHXZ				; CRect::Width
PUBLIC	?Height@CRect@@QBEHXZ				; CRect::Height
PUBLIC	?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z			; CDC::BitBlt
EXTRN	_InitializeCoolSB@4:NEAR
EXTRN	_CoolSB_SetMinThumbSize@12:NEAR
EXTRN	_CoolSB_SetScrollPos@16:NEAR
EXTRN	_CoolSB_SetSize@16:NEAR
EXTRN	_CoolSB_SetStyle@12:NEAR
EXTRN	?GetWidth@CDibBitmap@@QAEHXZ:NEAR		; CDibBitmap::GetWidth
EXTRN	?GetHeight@CDibBitmap@@QAEHXZ:NEAR		; CDibBitmap::GetHeight
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	??0CPaintDC@@QAE@PAVCWnd@@@Z:NEAR		; CPaintDC::CPaintDC
EXTRN	??1CPaintDC@@UAE@XZ:NEAR			; CPaintDC::~CPaintDC
xdata$x	SEGMENT
$T203117 DD	0ffffffffH
	DD	FLAT:$L203110
$T203112 DD	019930520H
	DD	01H
	DD	FLAT:$T203117
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv274 = -212						; size = 4
tv271 = -208						; size = 4
tv268 = -204						; size = 4
tv263 = -200						; size = 4
tv262 = -196						; size = 4
tv259 = -192						; size = 4
tv258 = -188						; size = 4
tv255 = -184						; size = 4
tv250 = -180						; size = 4
tv249 = -176						; size = 4
tv246 = -172						; size = 4
tv245 = -168						; size = 4
tv242 = -164						; size = 4
_this$ = -160						; size = 4
_lenVbar$200015 = -156					; size = 4
_nPos$200021 = -152					; size = 4
_realhight$200017 = -148				; size = 4
_fper$200019 = -144					; size = 4
_h$200012 = -140					; size = 4
_w$200011 = -136					; size = 4
_sz$ = -132						; size = 8
_rcClient$ = -124					; size = 16
_dc$ = -108						; size = 84
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?OnPaint@CLocalMusicCoverList@@IAEXXZ PROC NEAR		; CLocalMusicCoverList::OnPaint
; _this$ = ecx

; 123  : {

  00850	55		 push	 ebp
  00851	8b ec		 mov	 ebp, esp
  00853	6a ff		 push	 -1
  00855	68 00 00 00 00	 push	 __ehhandler$?OnPaint@CLocalMusicCoverList@@IAEXXZ
  0085a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00860	50		 push	 eax
  00861	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00868	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0086e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00873	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00876	56		 push	 esi
  00877	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 124  : 	if(!m_bInit )

  0087d	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00883	0f b6 88 58 01
	00 00		 movzx	 ecx, BYTE PTR [eax+344]
  0088a	85 c9		 test	 ecx, ecx
  0088c	0f 85 d3 00 00
	00		 jne	 $L200010

; 125  : 	{
; 126  : 		m_bInit = true;

  00892	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00898	c6 82 58 01 00
	00 01		 mov	 BYTE PTR [edx+344], 1

; 127  : 		int w,h;
; 128  : 		w = h = 15;

  0089f	c7 85 74 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _h$200012[ebp], 15 ; 0000000fH
  008a9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _h$200012[ebp]
  008af	89 85 78 ff ff
	ff		 mov	 DWORD PTR _w$200011[ebp], eax

; 129  : 
; 130  : 		if( m_pBitmapScrollHorz && m_pBitmapScrollVert )

  008b5	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  008bb	83 b9 54 01 00
	00 00		 cmp	 DWORD PTR [ecx+340], 0
  008c2	74 4d		 je	 SHORT $L200013
  008c4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008ca	83 ba 50 01 00
	00 00		 cmp	 DWORD PTR [edx+336], 0
  008d1	74 3e		 je	 SHORT $L200013

; 131  : 		{
; 132  : 			h = m_pBitmapScrollVert->GetHeight() / 3;

  008d3	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008d9	8b 88 50 01 00
	00		 mov	 ecx, DWORD PTR [eax+336]
  008df	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  008e4	99		 cdq
  008e5	b9 03 00 00 00	 mov	 ecx, 3
  008ea	f7 f9		 idiv	 ecx
  008ec	89 85 74 ff ff
	ff		 mov	 DWORD PTR _h$200012[ebp], eax

; 133  : 			w = m_pBitmapScrollVert->GetWidth() / 6;

  008f2	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008f8	8b 8a 50 01 00
	00		 mov	 ecx, DWORD PTR [edx+336]
  008fe	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  00903	99		 cdq
  00904	b9 06 00 00 00	 mov	 ecx, 6
  00909	f7 f9		 idiv	 ecx
  0090b	89 85 78 ff ff
	ff		 mov	 DWORD PTR _w$200011[ebp], eax
$L200013:

; 134  : 		}
; 135  : 
; 136  : 		InitializeCoolSB(m_hWnd);

  00911	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00917	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0091a	50		 push	 eax
  0091b	e8 00 00 00 00	 call	 _InitializeCoolSB@4

; 137  : 		CoolSB_SetStyle(m_hWnd, SB_BOTH, CSBS_HOTTRACKED);

  00920	6a 02		 push	 2
  00922	6a 03		 push	 3
  00924	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0092a	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0092d	52		 push	 edx
  0092e	e8 00 00 00 00	 call	 _CoolSB_SetStyle@12

; 138  : 		CoolSB_SetSize(m_hWnd, SB_BOTH, h, w);

  00933	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _w$200011[ebp]
  00939	50		 push	 eax
  0093a	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _h$200012[ebp]
  00940	51		 push	 ecx
  00941	6a 03		 push	 3
  00943	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00949	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0094c	50		 push	 eax
  0094d	e8 00 00 00 00	 call	 _CoolSB_SetSize@16

; 139  : 		::CoolSB_SetMinThumbSize(m_hWnd, SB_BOTH, 8);

  00952	6a 08		 push	 8
  00954	6a 03		 push	 3
  00956	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0095c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0095f	52		 push	 edx
  00960	e8 00 00 00 00	 call	 _CoolSB_SetMinThumbSize@12
$L200010:

; 140  : 		
; 141  : 	}
; 142  : 	if (m_PaintScrollBar)

  00965	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0096b	83 b8 5c 01 00
	00 00		 cmp	 DWORD PTR [eax+348], 0
  00972	0f 84 99 01 00
	00		 je	 $L200014

; 143  : 	{
; 144  : 		int lenVbar = (float)m_rect.Height()/m_rcRealRect.Height()*m_rect.Height();

  00978	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0097e	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00984	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00989	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv242[ebp], eax
  0098f	db 85 5c ff ff
	ff		 fild	 DWORD PTR tv242[ebp]
  00995	d9 9d 58 ff ff
	ff		 fstp	 DWORD PTR tv245[ebp]
  0099b	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009a1	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  009a7	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  009ac	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv246[ebp], eax
  009b2	db 85 54 ff ff
	ff		 fild	 DWORD PTR tv246[ebp]
  009b8	d8 bd 58 ff ff
	ff		 fdivr	 DWORD PTR tv245[ebp]
  009be	d9 9d 50 ff ff
	ff		 fstp	 DWORD PTR tv249[ebp]
  009c4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009ca	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  009d0	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  009d5	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv250[ebp], eax
  009db	db 85 4c ff ff
	ff		 fild	 DWORD PTR tv250[ebp]
  009e1	d8 8d 50 ff ff
	ff		 fmul	 DWORD PTR tv249[ebp]
  009e7	e8 00 00 00 00	 call	 __ftol2
  009ec	89 85 64 ff ff
	ff		 mov	 DWORD PTR _lenVbar$200015[ebp], eax

; 145  : 		int realhight = (float)(m_rect.Height()-lenVbar)/m_rect.Height()*m_rcRealRect.Height();

  009f2	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009f8	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  009fe	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00a03	2b 85 64 ff ff
	ff		 sub	 eax, DWORD PTR _lenVbar$200015[ebp]
  00a09	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv255[ebp], eax
  00a0f	db 85 48 ff ff
	ff		 fild	 DWORD PTR tv255[ebp]
  00a15	d9 9d 44 ff ff
	ff		 fstp	 DWORD PTR tv258[ebp]
  00a1b	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a21	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00a27	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00a2c	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv259[ebp], eax
  00a32	db 85 40 ff ff
	ff		 fild	 DWORD PTR tv259[ebp]
  00a38	d8 bd 44 ff ff
	ff		 fdivr	 DWORD PTR tv258[ebp]
  00a3e	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv262[ebp]
  00a44	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a4a	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  00a50	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00a55	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv263[ebp], eax
  00a5b	db 85 38 ff ff
	ff		 fild	 DWORD PTR tv263[ebp]
  00a61	d8 8d 3c ff ff
	ff		 fmul	 DWORD PTR tv262[ebp]
  00a67	e8 00 00 00 00	 call	 __ftol2
  00a6c	89 85 6c ff ff
	ff		 mov	 DWORD PTR _realhight$200017[ebp], eax

; 146  : 		float fper = (float)(0-m_ptClientStart.y)/(m_rcRealRect.Height()-m_rect.Height());

  00a72	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a78	33 d2		 xor	 edx, edx
  00a7a	2b 91 b0 00 00
	00		 sub	 edx, DWORD PTR [ecx+176]
  00a80	89 95 34 ff ff
	ff		 mov	 DWORD PTR tv268[ebp], edx
  00a86	db 85 34 ff ff
	ff		 fild	 DWORD PTR tv268[ebp]
  00a8c	d9 9d 30 ff ff
	ff		 fstp	 DWORD PTR tv271[ebp]
  00a92	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a98	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  00a9e	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00aa3	8b f0		 mov	 esi, eax
  00aa5	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00aab	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00ab1	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00ab6	2b f0		 sub	 esi, eax
  00ab8	89 b5 2c ff ff
	ff		 mov	 DWORD PTR tv274[ebp], esi
  00abe	db 85 2c ff ff
	ff		 fild	 DWORD PTR tv274[ebp]
  00ac4	d8 bd 30 ff ff
	ff		 fdivr	 DWORD PTR tv271[ebp]
  00aca	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR _fper$200019[ebp]

; 147  : 		int nPos = fper*realhight;

  00ad0	db 85 6c ff ff
	ff		 fild	 DWORD PTR _realhight$200017[ebp]
  00ad6	d8 8d 70 ff ff
	ff		 fmul	 DWORD PTR _fper$200019[ebp]
  00adc	e8 00 00 00 00	 call	 __ftol2
  00ae1	89 85 68 ff ff
	ff		 mov	 DWORD PTR _nPos$200021[ebp], eax

; 148  : 		CoolSB_SetScrollPos(m_hWnd,SB_VERT,nPos,TRUE);

  00ae7	6a 01		 push	 1
  00ae9	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _nPos$200021[ebp]
  00aef	50		 push	 eax
  00af0	6a 01		 push	 1
  00af2	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00af8	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00afb	52		 push	 edx
  00afc	e8 00 00 00 00	 call	 _CoolSB_SetScrollPos@16

; 149  : 		m_PaintScrollBar = FALSE;

  00b01	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b07	c7 80 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+348], 0
$L200014:

; 150  : 	}
; 151  : 	CPaintDC dc(this); 

  00b11	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b17	51		 push	 ecx
  00b18	8d 4d 94	 lea	 ecx, DWORD PTR _dc$[ebp]
  00b1b	e8 00 00 00 00	 call	 ??0CPaintDC@@QAE@PAVCWnd@@@Z ; CPaintDC::CPaintDC
  00b20	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 152  : 	CRect rcClient;

  00b27	8d 4d 84	 lea	 ecx, DWORD PTR _rcClient$[ebp]
  00b2a	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 153  : 	GetClientRect(&rcClient);

  00b2f	8d 55 84	 lea	 edx, DWORD PTR _rcClient$[ebp]
  00b32	52		 push	 edx
  00b33	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b39	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 154  : 	CSize sz = CSize(m_rect.Width(),m_rect.Height());

  00b3e	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b44	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00b4a	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00b4f	50		 push	 eax
  00b50	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b56	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00b5c	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00b61	50		 push	 eax
  00b62	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _sz$[ebp]
  00b68	e8 00 00 00 00	 call	 ??0CSize@@QAE@HH@Z	; CSize::CSize

; 155  : 	
; 156  : 	dc.BitBlt(0,0,sz.cx,sz.cy,&m_dcMem,0,0,SRCCOPY);

  00b6d	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00b72	6a 00		 push	 0
  00b74	6a 00		 push	 0
  00b76	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b7c	83 c0 60	 add	 eax, 96			; 00000060H
  00b7f	50		 push	 eax
  00b80	8b 4d 80	 mov	 ecx, DWORD PTR _sz$[ebp+4]
  00b83	51		 push	 ecx
  00b84	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _sz$[ebp]
  00b8a	52		 push	 edx
  00b8b	6a 00		 push	 0
  00b8d	6a 00		 push	 0
  00b8f	8d 4d 94	 lea	 ecx, DWORD PTR _dc$[ebp]
  00b92	e8 00 00 00 00	 call	 ?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z ; CDC::BitBlt

; 157  : }

  00b97	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b9e	8d 4d 94	 lea	 ecx, DWORD PTR _dc$[ebp]
  00ba1	e8 00 00 00 00	 call	 ??1CPaintDC@@UAE@XZ	; CPaintDC::~CPaintDC
  00ba6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00ba9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00bb0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bb3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bb8	5e		 pop	 esi
  00bb9	8b e5		 mov	 esp, ebp
  00bbb	5d		 pop	 ebp
  00bbc	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L203110:
  00163	8d 4d 94	 lea	 ecx, DWORD PTR _dc$[ebp]
  00166	e9 00 00 00 00	 jmp	 ??1CPaintDC@@UAE@XZ	; CPaintDC::~CPaintDC
__ehhandler$?OnPaint@CLocalMusicCoverList@@IAEXXZ:
  0016b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203112
  00170	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OnPaint@CLocalMusicCoverList@@IAEXXZ ENDP		; CLocalMusicCoverList::OnPaint
PUBLIC	?SizeChanged@CLocalMusicCoverList@@IAEXH@Z	; CLocalMusicCoverList::SizeChanged
PUBLIC	?OnSize@CWnd@@IAEXIHH@Z				; CWnd::OnSize
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nType$ = 8						; size = 4
_cx$ = 12						; size = 4
_cy$ = 16						; size = 4
?OnSize@CLocalMusicCoverList@@IAEXIHH@Z PROC NEAR	; CLocalMusicCoverList::OnSize
; _this$ = ecx

; 160  : {

  00bc0	55		 push	 ebp
  00bc1	8b ec		 mov	 ebp, esp
  00bc3	51		 push	 ecx
  00bc4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 	CWnd::OnSize(nType, cx, cy);

  00bc7	8b 45 10	 mov	 eax, DWORD PTR _cy$[ebp]
  00bca	50		 push	 eax
  00bcb	8b 4d 0c	 mov	 ecx, DWORD PTR _cx$[ebp]
  00bce	51		 push	 ecx
  00bcf	8b 55 08	 mov	 edx, DWORD PTR _nType$[ebp]
  00bd2	52		 push	 edx
  00bd3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bd6	e8 00 00 00 00	 call	 ?OnSize@CWnd@@IAEXIHH@Z	; CWnd::OnSize

; 162  : 	SizeChanged();

  00bdb	6a 00		 push	 0
  00bdd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00be0	e8 00 00 00 00	 call	 ?SizeChanged@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::SizeChanged

; 163  : 	
; 164  : }

  00be5	8b e5		 mov	 esp, ebp
  00be7	5d		 pop	 ebp
  00be8	c2 0c 00	 ret	 12			; 0000000cH
?OnSize@CLocalMusicCoverList@@IAEXIHH@Z ENDP		; CLocalMusicCoverList::OnSize
_TEXT	ENDS
PUBLIC	?AfxGetApp@@YGPAVCWinApp@@XZ			; AfxGetApp
PUBLIC	?LoadStandardCursor@CWinApp@@QBEPAUHICON__@@PBD@Z ; CWinApp::LoadStandardCursor
EXTRN	?AfxRegisterWndClass@@YGPBDIPAUHICON__@@PAUHBRUSH__@@0@Z:NEAR ; AfxRegisterWndClass
EXTRN	?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z:NEAR ; CWnd::Create
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_ret$ = -4						; size = 4
_lpszClassName$ = 8					; size = 4
_lpszWindowName$ = 12					; size = 4
_dwStyle$ = 16						; size = 4
_rect$ = 20						; size = 4
_pParentWnd$ = 24					; size = 4
_nID$ = 28						; size = 4
_pContext$ = 32						; size = 4
?Create@CLocalMusicCoverList@@UAEHPBD0KABUtagRECT@@PAVCWnd@@IPAUCCreateContext@@@Z PROC NEAR ; CLocalMusicCoverList::Create
; _this$ = ecx

; 167  : {

  00bf0	55		 push	 ebp
  00bf1	8b ec		 mov	 ebp, esp
  00bf3	83 ec 08	 sub	 esp, 8
  00bf6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 168  : 	BOOL ret = CWnd::Create(AfxRegisterWndClass(CS_DBLCLKS| CS_CLASSDC | CS_SAVEBITS,AfxGetApp()->LoadStandardCursor(IDC_ARROW),0,0),
; 169  : 		_T(""), dwStyle, rect, pParentWnd, nID, pContext);

  00bf9	8b 45 20	 mov	 eax, DWORD PTR _pContext$[ebp]
  00bfc	50		 push	 eax
  00bfd	8b 4d 1c	 mov	 ecx, DWORD PTR _nID$[ebp]
  00c00	51		 push	 ecx
  00c01	8b 55 18	 mov	 edx, DWORD PTR _pParentWnd$[ebp]
  00c04	52		 push	 edx
  00c05	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  00c08	50		 push	 eax
  00c09	8b 4d 10	 mov	 ecx, DWORD PTR _dwStyle$[ebp]
  00c0c	51		 push	 ecx
  00c0d	68 00 00 00 00	 push	 OFFSET FLAT:$SG200047
  00c12	6a 00		 push	 0
  00c14	6a 00		 push	 0
  00c16	68 00 7f 00 00	 push	 32512			; 00007f00H
  00c1b	e8 00 00 00 00	 call	 ?AfxGetApp@@YGPAVCWinApp@@XZ ; AfxGetApp
  00c20	8b c8		 mov	 ecx, eax
  00c22	e8 00 00 00 00	 call	 ?LoadStandardCursor@CWinApp@@QBEPAUHICON__@@PBD@Z ; CWinApp::LoadStandardCursor
  00c27	50		 push	 eax
  00c28	68 48 08 00 00	 push	 2120			; 00000848H
  00c2d	e8 00 00 00 00	 call	 ?AfxRegisterWndClass@@YGPBDIPAUHICON__@@PAUHBRUSH__@@0@Z ; AfxRegisterWndClass
  00c32	50		 push	 eax
  00c33	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c36	e8 00 00 00 00	 call	 ?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z ; CWnd::Create
  00c3b	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 170  : 
; 171  : 	return ret;	

  00c3e	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 172  : }

  00c41	8b e5		 mov	 esp, ebp
  00c43	5d		 pop	 ebp
  00c44	c2 1c 00	 ret	 28			; 0000001cH
?Create@CLocalMusicCoverList@@UAEHPBD0KABUtagRECT@@PAVCWnd@@IPAUCCreateContext@@@Z ENDP ; CLocalMusicCoverList::Create
; Function compile flags: /Odt
_this$ = -4						; size = 4
_iItemWidth$ = 8					; size = 4
_iItemHeight$ = 12					; size = 4
?SetItemWH@CLocalMusicCoverList@@QAEXHH@Z PROC NEAR	; CLocalMusicCoverList::SetItemWH
; _this$ = ecx

; 175  : {

  00c50	55		 push	 ebp
  00c51	8b ec		 mov	 ebp, esp
  00c53	51		 push	 ecx
  00c54	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 176  : 	m_iItemWidth = iItemWidth;

  00c57	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c5a	8b 4d 08	 mov	 ecx, DWORD PTR _iItemWidth$[ebp]
  00c5d	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 177  : 	m_iItemHeight = iItemHeight;

  00c60	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00c63	8b 45 0c	 mov	 eax, DWORD PTR _iItemHeight$[ebp]
  00c66	89 42 58	 mov	 DWORD PTR [edx+88], eax

; 178  : }

  00c69	8b e5		 mov	 esp, ebp
  00c6b	5d		 pop	 ebp
  00c6c	c2 08 00	 ret	 8
?SetItemWH@CLocalMusicCoverList@@QAEXHH@Z ENDP		; CLocalMusicCoverList::SetItemWH
_TEXT	ENDS
PUBLIC	?SetPoint@CPoint@@QAEXHH@Z			; CPoint::SetPoint
PUBLIC	?SetImgState@CLocalMusicCoverList@@QAEXW4LMCImgState@@@Z ; CLocalMusicCoverList::SetImgState
PUBLIC	?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z	; CLocalMusicCoverList::OnMemoryDraw
PUBLIC	?UpdateList@CLocalMusicCoverList@@IAEXXZ	; CLocalMusicCoverList::UpdateList
EXTRN	?SetConfigIntValue@AfxUserConfig@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H_N@Z:NEAR ; AfxUserConfig::SetConfigIntValue
xdata$x	SEGMENT
$T203129 DD	0ffffffffH
	DD	FLAT:$L203124
	DD	00H
	DD	FLAT:$L203125
$T203127 DD	019930520H
	DD	02H
	DD	FLAT:$T203129
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv66 = -80						; size = 4
_this$ = -76						; size = 4
$T203123 = -72						; size = 28
$T203122 = -44						; size = 28
_iValue$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_is$ = 8						; size = 4
?SetImgState@CLocalMusicCoverList@@QAEXW4LMCImgState@@@Z PROC NEAR ; CLocalMusicCoverList::SetImgState
; _this$ = ecx

; 181  : {

  00c70	55		 push	 ebp
  00c71	8b ec		 mov	 ebp, esp
  00c73	6a ff		 push	 -1
  00c75	68 00 00 00 00	 push	 __ehhandler$?SetImgState@CLocalMusicCoverList@@QAEXW4LMCImgState@@@Z
  00c7a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00c80	50		 push	 eax
  00c81	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00c88	83 ec 44	 sub	 esp, 68			; 00000044H
  00c8b	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 	m_ImgState=is;

  00c8e	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00c91	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  00c94	89 48 5c	 mov	 DWORD PTR [eax+92], ecx

; 183  : 	int iValue = 0;

  00c97	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iValue$[ebp], 0

; 184  : 	switch(m_ImgState)

  00c9e	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  00ca1	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00ca4	89 45 b0	 mov	 DWORD PTR tv66[ebp], eax
  00ca7	83 7d b0 00	 cmp	 DWORD PTR tv66[ebp], 0
  00cab	74 0e		 je	 SHORT $L200062
  00cad	83 7d b0 01	 cmp	 DWORD PTR tv66[ebp], 1
  00cb1	74 1d		 je	 SHORT $L200063
  00cb3	83 7d b0 02	 cmp	 DWORD PTR tv66[ebp], 2
  00cb7	74 2c		 je	 SHORT $L200064
  00cb9	eb 43		 jmp	 SHORT $L200059
$L200062:

; 185  : 	{
; 186  : 	case LMCI_Small:
; 187  : 		SetItemWH(80,80);

  00cbb	6a 50		 push	 80			; 00000050H
  00cbd	6a 50		 push	 80			; 00000050H
  00cbf	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00cc2	e8 00 00 00 00	 call	 ?SetItemWH@CLocalMusicCoverList@@QAEXHH@Z ; CLocalMusicCoverList::SetItemWH

; 188  : 		iValue = 0;

  00cc7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iValue$[ebp], 0

; 189  : 		break;

  00cce	eb 2e		 jmp	 SHORT $L200059
$L200063:

; 190  : 	case LMCI_Middle:
; 191  : 		SetItemWH(100,100);

  00cd0	6a 64		 push	 100			; 00000064H
  00cd2	6a 64		 push	 100			; 00000064H
  00cd4	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00cd7	e8 00 00 00 00	 call	 ?SetItemWH@CLocalMusicCoverList@@QAEXHH@Z ; CLocalMusicCoverList::SetItemWH

; 192  : 		iValue = 1;

  00cdc	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _iValue$[ebp], 1

; 193  : 		break;

  00ce3	eb 19		 jmp	 SHORT $L200059
$L200064:

; 194  : 	case LMCI_Big:
; 195  : 		SetItemWH(130,130);

  00ce5	68 82 00 00 00	 push	 130			; 00000082H
  00cea	68 82 00 00 00	 push	 130			; 00000082H
  00cef	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00cf2	e8 00 00 00 00	 call	 ?SetItemWH@CLocalMusicCoverList@@QAEXHH@Z ; CLocalMusicCoverList::SetItemWH

; 196  : 		iValue = 2;

  00cf7	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR _iValue$[ebp], 2
$L200059:

; 197  : 		break;
; 198  : 	}
; 199  : 	AfxGetUserConfig()->SetConfigIntValue( CONF_APP_MODULE_NAME,CONF_APP_PLAYED_ICON_SIZE, iValue);

  00cfe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_APP_PLAYED_ICON_SIZE
  00d04	51		 push	 ecx
  00d05	8d 4d d4	 lea	 ecx, DWORD PTR $T203122[ebp]
  00d08	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00d0e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00d15	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_APP_MODULE_NAME
  00d1b	52		 push	 edx
  00d1c	8d 4d b8	 lea	 ecx, DWORD PTR $T203123[ebp]
  00d1f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00d25	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00d29	6a 00		 push	 0
  00d2b	8b 45 f0	 mov	 eax, DWORD PTR _iValue$[ebp]
  00d2e	50		 push	 eax
  00d2f	8d 4d d4	 lea	 ecx, DWORD PTR $T203122[ebp]
  00d32	51		 push	 ecx
  00d33	8d 55 b8	 lea	 edx, DWORD PTR $T203123[ebp]
  00d36	52		 push	 edx
  00d37	e8 00 00 00 00	 call	 ?AfxGetUserConfig@@YAPAVAfxUserConfig@@XZ ; AfxGetUserConfig
  00d3c	8b c8		 mov	 ecx, eax
  00d3e	e8 00 00 00 00	 call	 ?SetConfigIntValue@AfxUserConfig@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H_N@Z ; AfxUserConfig::SetConfigIntValue
  00d43	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00d47	8d 4d b8	 lea	 ecx, DWORD PTR $T203123[ebp]
  00d4a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00d50	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d57	8d 4d d4	 lea	 ecx, DWORD PTR $T203122[ebp]
  00d5a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 200  : 	m_ptClientStart.SetPoint(0,0);

  00d60	6a 00		 push	 0
  00d62	6a 00		 push	 0
  00d64	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d67	81 c1 ac 00 00
	00		 add	 ecx, 172		; 000000acH
  00d6d	e8 00 00 00 00	 call	 ?SetPoint@CPoint@@QAEXHH@Z ; CPoint::SetPoint

; 201  : 	UpdateList();

  00d72	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d75	e8 00 00 00 00	 call	 ?UpdateList@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UpdateList

; 202  : 	OnMemoryDraw();

  00d7a	6a 01		 push	 1
  00d7c	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d7f	e8 00 00 00 00	 call	 ?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::OnMemoryDraw

; 203  : }

  00d84	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00d87	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00d8e	8b e5		 mov	 esp, ebp
  00d90	5d		 pop	 ebp
  00d91	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L203124:
  00175	8d 4d d4	 lea	 ecx, DWORD PTR $T203122[ebp]
  00178	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203125:
  0017e	8d 4d b8	 lea	 ecx, DWORD PTR $T203123[ebp]
  00181	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?SetImgState@CLocalMusicCoverList@@QAEXW4LMCImgState@@@Z:
  00187	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203127
  0018c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SetImgState@CLocalMusicCoverList@@QAEXW4LMCImgState@@@Z ENDP ; CLocalMusicCoverList::SetImgState
PUBLIC	?InsertItem@CLocalMusicCoverList@@QAEHPAVCDibBitmap@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CLocalMusicCoverList::InsertItem
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:NEAR
EXTRN	?InsertItem@CLMCDataMgr@@QAEHPAVCDibBitmap@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:NEAR ; CLMCDataMgr::InsertItem
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
xdata$x	SEGMENT
$T203144 DD	0ffffffffH
	DD	FLAT:$L203135
	DD	00H
	DD	FLAT:$L203136
	DD	01H
	DD	FLAT:$L203137
	DD	02H
	DD	FLAT:$L203138
	DD	03H
	DD	FLAT:$L203139
$T203142 DD	019930520H
	DD	05H
	DD	FLAT:$T203144
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv166 = -64						; size = 4
tv172 = -60						; size = 4
tv169 = -56						; size = 4
tv177 = -52						; size = 4
tv165 = -48						; size = 4
tv176 = -44						; size = 4
_this$ = -40						; size = 4
$T203134 = -36						; size = 4
$T203133 = -32						; size = 4
$T203132 = -28						; size = 4
$T203131 = -24						; size = 4
_iHeightSpaceMB$ = -20					; size = 4
_iHeightSpaceS$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pImg$ = 8						; size = 4
_strItemName$ = 12					; size = 4
_strdetail$ = 16					; size = 4
_strGID$ = 20						; size = 28
_blSel$ = 48						; size = 4
?InsertItem@CLocalMusicCoverList@@QAEHPAVCDibBitmap@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC NEAR ; CLocalMusicCoverList::InsertItem
; _this$ = ecx

; 206  : {

  00da0	55		 push	 ebp
  00da1	8b ec		 mov	 ebp, esp
  00da3	6a ff		 push	 -1
  00da5	68 00 00 00 00	 push	 __ehhandler$?InsertItem@CLocalMusicCoverList@@QAEHPAVCDibBitmap@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
  00daa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00db0	50		 push	 eax
  00db1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00db8	83 ec 34	 sub	 esp, 52			; 00000034H
  00dbb	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00dbe	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 207  : 	int iHeightSpaceS = m_iItemHeight+SPACEH + ITEMTXTH + SPACEH;

  00dc5	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00dc8	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00dcb	83 c1 17	 add	 ecx, 23			; 00000017H
  00dce	89 4d f0	 mov	 DWORD PTR _iHeightSpaceS$[ebp], ecx

; 208  : 	int iHeightSpaceMB = m_iItemHeight+SPACEH + ITEMTXTH + SPACEH + ITEMTXTH + SPACEH  ;	

  00dd1	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00dd4	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00dd7	83 c0 2a	 add	 eax, 42			; 0000002aH
  00dda	89 45 ec	 mov	 DWORD PTR _iHeightSpaceMB$[ebp], eax

; 209  : 	if (m_ImgState==LMCI_Small)
; 210  : 	{
; 211  : 	}
; 212  : 	else if (m_ImgState==LMCI_Middle||m_ImgState==LMCI_Big)
; 213  : 	{
; 214  : 
; 215  : 	}
; 216  : 	return m_DataMgr.InsertItem(pImg,strItemName,strdetail, strGID, blSel);

  00ddd	8b 4d 30	 mov	 ecx, DWORD PTR _blSel$[ebp]
  00de0	51		 push	 ecx
  00de1	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00de4	8b cc		 mov	 ecx, esp
  00de6	89 65 e4	 mov	 DWORD PTR $T203132[ebp], esp
  00de9	8d 55 14	 lea	 edx, DWORD PTR _strGID$[ebp]
  00dec	52		 push	 edx
  00ded	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00df3	89 45 d4	 mov	 DWORD PTR tv176[ebp], eax
  00df6	8b 45 d4	 mov	 eax, DWORD PTR tv176[ebp]
  00df9	89 45 d0	 mov	 DWORD PTR tv165[ebp], eax
  00dfc	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00e00	51		 push	 ecx
  00e01	8b cc		 mov	 ecx, esp
  00e03	89 65 e0	 mov	 DWORD PTR $T203133[ebp], esp
  00e06	8d 55 10	 lea	 edx, DWORD PTR _strdetail$[ebp]
  00e09	52		 push	 edx
  00e0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00e10	89 45 cc	 mov	 DWORD PTR tv177[ebp], eax
  00e13	8b 45 cc	 mov	 eax, DWORD PTR tv177[ebp]
  00e16	89 45 c8	 mov	 DWORD PTR tv169[ebp], eax
  00e19	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00e1d	51		 push	 ecx
  00e1e	8b cc		 mov	 ecx, esp
  00e20	89 65 dc	 mov	 DWORD PTR $T203134[ebp], esp
  00e23	8d 55 0c	 lea	 edx, DWORD PTR _strItemName$[ebp]
  00e26	52		 push	 edx
  00e27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00e2d	89 45 c4	 mov	 DWORD PTR tv172[ebp], eax
  00e30	8b 45 08	 mov	 eax, DWORD PTR _pImg$[ebp]
  00e33	50		 push	 eax
  00e34	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e37	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00e3d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00e41	e8 00 00 00 00	 call	 ?InsertItem@CLMCDataMgr@@QAEHPAVCDibBitmap@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CLMCDataMgr::InsertItem
  00e46	89 45 c0	 mov	 DWORD PTR tv166[ebp], eax
  00e49	8b 4d c0	 mov	 ecx, DWORD PTR tv166[ebp]
  00e4c	89 4d e8	 mov	 DWORD PTR $T203131[ebp], ecx
  00e4f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00e53	8d 4d 0c	 lea	 ecx, DWORD PTR _strItemName$[ebp]
  00e56	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00e5c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00e60	8d 4d 10	 lea	 ecx, DWORD PTR _strdetail$[ebp]
  00e63	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00e69	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00e70	8d 4d 14	 lea	 ecx, DWORD PTR _strGID$[ebp]
  00e73	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00e79	8b 45 e8	 mov	 eax, DWORD PTR $T203131[ebp]

; 217  : }

  00e7c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00e7f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00e86	8b e5		 mov	 esp, ebp
  00e88	5d		 pop	 ebp
  00e89	c2 2c 00	 ret	 44			; 0000002cH
_TEXT	ENDS
text$x	SEGMENT
$L203135:
  00191	8d 4d 14	 lea	 ecx, DWORD PTR _strGID$[ebp]
  00194	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203136:
  0019a	8d 4d 10	 lea	 ecx, DWORD PTR _strdetail$[ebp]
  0019d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L203137:
  001a3	8d 4d 0c	 lea	 ecx, DWORD PTR _strItemName$[ebp]
  001a6	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L203138:
  001ac	8b 4d e4	 mov	 ecx, DWORD PTR $T203132[ebp]
  001af	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203139:
  001b5	8b 4d e0	 mov	 ecx, DWORD PTR $T203133[ebp]
  001b8	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?InsertItem@CLocalMusicCoverList@@QAEHPAVCDibBitmap@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:
  001be	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203142
  001c3	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?InsertItem@CLocalMusicCoverList@@QAEHPAVCDibBitmap@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; CLocalMusicCoverList::InsertItem
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -160						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

  00011	c7 85 60 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _ver$[ebp], 148 ; 00000094H

; 139  : 	::GetVersionEx( &ver );

  0001b	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _ver$[ebp]
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00028	83 bd 70 ff ff
	ff 02		 cmp	 DWORD PTR _ver$[ebp+16], 2
  0002f	75 15		 jne	 SHORT $L24173
  00031	83 bd 64 ff ff
	ff 05		 cmp	 DWORD PTR _ver$[ebp+4], 5
  00038	72 0c		 jb	 SHORT $L24173

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  0003a	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

  00044	eb 0a		 jmp	 SHORT $L24174
$L24173:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00046	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L24174:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  00050	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pfnGetThreadACP$[ebp]
  00056	51		 push	 ecx
  00057	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0005c	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pNew$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pp$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 93   : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$24161 = -24					; size = 4
_lcidThread$ = -20					; size = 4
_szACP$ = -16						; size = 7
__$ArrayPad$ = -8					; size = 4
_nACP$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0
  0001b	89 45 ec	 mov	 DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  0001e	6a 07		 push	 7
  00020	8d 45 f0	 lea	 eax, DWORD PTR _szACP$[ebp]
  00023	50		 push	 eax
  00024	68 04 10 00 00	 push	 4100			; 00001004H
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _lcidThread$[ebp]
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00033	85 c0		 test	 eax, eax
  00035	74 34		 je	 SHORT $L24160

; 111  : 	{
; 112  : 		char* pch = szACP;

  00037	8d 55 f0	 lea	 edx, DWORD PTR _szACP$[ebp]
  0003a	89 55 e8	 mov	 DWORD PTR _pch$24161[ebp], edx
$L24163:

; 113  : 		while (*pch != '\0')

  0003d	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00040	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00043	85 c9		 test	 ecx, ecx
  00045	74 24		 je	 SHORT $L24160

; 114  : 		{
; 115  : 			nACP *= 10;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  0004a	6b d2 0a	 imul	 edx, 10			; 0000000aH
  0004d	89 55 fc	 mov	 DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

  00050	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  00059	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  0005d	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
  00060	8b 4d e8	 mov	 ecx, DWORD PTR _pch$24161[ebp]
  00063	83 c1 01	 add	 ecx, 1
  00066	89 4d e8	 mov	 DWORD PTR _pch$24161[ebp], ecx

; 117  : 		}

  00069	eb d2		 jmp	 SHORT $L24163
$L24160:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  0006b	83 7d fc 00	 cmp	 DWORD PTR _nACP$[ebp], 0
  0006f	75 09		 jne	 SHORT $L24165

; 121  : 		nACP = ::GetACP();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  00077	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
$L24165:

; 122  : 
; 123  : 	return nACP;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _nACP$[ebp]

; 124  : }

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  : 	return( CP_THREAD_ACP );

  00003	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 158  : 	return( g_pfnGetThreadACP() );

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 159  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?InsertItem@CLocalMusicCoverList@@QAEHPBDV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CLocalMusicCoverList::InsertItem
EXTRN	?InsertItem@CLMCDataMgr@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:NEAR ; CLMCDataMgr::InsertItem
xdata$x	SEGMENT
$T203175 DD	0ffffffffH
	DD	FLAT:$L203165
	DD	00H
	DD	FLAT:$L203166
	DD	01H
	DD	FLAT:$L203167
	DD	02H
	DD	FLAT:$L203168
	DD	03H
	DD	FLAT:$L203169
	DD	04H
	DD	FLAT:$L203170
$T203173 DD	019930520H
	DD	06H
	DD	FLAT:$T203175
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\playedgamepanel\localmusiccoverlist.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv162 = -68						; size = 4
tv171 = -64						; size = 4
tv168 = -60						; size = 4
tv177 = -56						; size = 4
tv165 = -52						; size = 4
tv176 = -48						; size = 4
tv161 = -44						; size = 4
tv175 = -40						; size = 4
_this$ = -36						; size = 4
$T203164 = -32						; size = 4
$T203163 = -28						; size = 4
$T203162 = -24						; size = 4
$T203161 = -20						; size = 4
$T203160 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_szImgPath$ = 8						; size = 4
_strItemName$ = 12					; size = 4
_strdetail$ = 16					; size = 4
_strGID$ = 20						; size = 28
_blSel$ = 48						; size = 4
?InsertItem@CLocalMusicCoverList@@QAEHPBDV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC NEAR ; CLocalMusicCoverList::InsertItem
; _this$ = ecx

; 220  : {

  00e90	55		 push	 ebp
  00e91	8b ec		 mov	 ebp, esp
  00e93	6a ff		 push	 -1
  00e95	68 00 00 00 00	 push	 __ehhandler$?InsertItem@CLocalMusicCoverList@@QAEHPBDV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
  00e9a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00ea0	50		 push	 eax
  00ea1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00ea8	83 ec 38	 sub	 esp, 56			; 00000038H
  00eab	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
  00eae	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 221  : 	return m_DataMgr.InsertItem(szImgPath,strItemName,strdetail,strGID,blSel);

  00eb5	8b 45 30	 mov	 eax, DWORD PTR _blSel$[ebp]
  00eb8	50		 push	 eax
  00eb9	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00ebc	8b cc		 mov	 ecx, esp
  00ebe	89 65 ec	 mov	 DWORD PTR $T203161[ebp], esp
  00ec1	8d 55 14	 lea	 edx, DWORD PTR _strGID$[ebp]
  00ec4	52		 push	 edx
  00ec5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00ecb	89 45 d8	 mov	 DWORD PTR tv175[ebp], eax
  00ece	8b 45 d8	 mov	 eax, DWORD PTR tv175[ebp]
  00ed1	89 45 d4	 mov	 DWORD PTR tv161[ebp], eax
  00ed4	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00ed8	51		 push	 ecx
  00ed9	8b cc		 mov	 ecx, esp
  00edb	89 65 e8	 mov	 DWORD PTR $T203162[ebp], esp
  00ede	8d 55 10	 lea	 edx, DWORD PTR _strdetail$[ebp]
  00ee1	52		 push	 edx
  00ee2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00ee8	89 45 d0	 mov	 DWORD PTR tv176[ebp], eax
  00eeb	8b 45 d0	 mov	 eax, DWORD PTR tv176[ebp]
  00eee	89 45 cc	 mov	 DWORD PTR tv165[ebp], eax
  00ef1	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00ef5	51		 push	 ecx
  00ef6	8b cc		 mov	 ecx, esp
  00ef8	89 65 e4	 mov	 DWORD PTR $T203163[ebp], esp
  00efb	8d 55 0c	 lea	 edx, DWORD PTR _strItemName$[ebp]
  00efe	52		 push	 edx
  00eff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00f05	89 45 c8	 mov	 DWORD PTR tv177[ebp], eax
  00f08	8b 45 c8	 mov	 eax, DWORD PTR tv177[ebp]
  00f0b	89 45 c4	 mov	 DWORD PTR tv168[ebp], eax
  00f0e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00f12	51		 push	 ecx
  00f13	8b cc		 mov	 ecx, esp
  00f15	89 65 e0	 mov	 DWORD PTR $T203164[ebp], esp
  00f18	8b 55 08	 mov	 edx, DWORD PTR _szImgPath$[ebp]
  00f1b	52		 push	 edx
  00f1c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00f22	89 45 c0	 mov	 DWORD PTR tv171[ebp], eax
  00f25	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f28	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00f2e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00f32	e8 00 00 00 00	 call	 ?InsertItem@CLMCDataMgr@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CLMCDataMgr::InsertItem
  00f37	89 45 bc	 mov	 DWORD PTR tv162[ebp], eax
  00f3a	8b 45 bc	 mov	 eax, DWORD PTR tv162[ebp]
  00f3d	89 45 f0	 mov	 DWORD PTR $T203160[ebp], eax
  00f40	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00f44	8d 4d 0c	 lea	 ecx, DWORD PTR _strItemName$[ebp]
  00f47	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00f4d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00f51	8d 4d 10	 lea	 ecx, DWORD PTR _strdetail$[ebp]
  00f54	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00f5a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00f61	8d 4d 14	 lea	 ecx, DWORD PTR _strGID$[ebp]
  00f64	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00f6a	8b 45 f0	 mov	 eax, DWORD PTR $T203160[ebp]

; 222  : }

  00f6d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00f70	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00f77	8b e5		 mov	 esp, ebp
  00f79	5d		 pop	 ebp
  00f7a	c2 2c 00	 ret	 44			; 0000002cH
_TEXT	ENDS
text$x	SEGMENT
$L203165:
  001c8	8d 4d 14	 lea	 ecx, DWORD PTR _strGID$[ebp]
  001cb	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203166:
  001d1	8d 4d 10	 lea	 ecx, DWORD PTR _strdetail$[ebp]
  001d4	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L203167:
  001da	8d 4d 0c	 lea	 ecx, DWORD PTR _strItemName$[ebp]
  001dd	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L203168:
  001e3	8b 4d ec	 mov	 ecx, DWORD PTR $T203161[ebp]
  001e6	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203169:
  001ec	8b 4d e8	 mov	 ecx, DWORD PTR $T203162[ebp]
  001ef	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L203170:
  001f5	8b 4d e4	 mov	 ecx, DWORD PTR $T203163[ebp]
  001f8	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?InsertItem@CLocalMusicCoverList@@QAEHPBDV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:
  001fe	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203173
  00203	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?InsertItem@CLocalMusicCoverList@@QAEHPBDV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@1V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; CLocalMusicCoverList::InsertItem
EXTRN	__imp__MultiByteToWideChar@24:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z PROC NEAR		; AtlA2WHelper, COMDAT

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 555  : 	ATLASSERT(lpa != NULL);
; 556  : 	ATLASSERT(lpw != NULL);
; 557  : 	if (lpw == NULL || lpa == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpw$[ebp], 0
  00008	74 06		 je	 SHORT $L24306
  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpa$[ebp], 0
  0000e	75 04		 jne	 SHORT $L24305
$L24306:

; 558  : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 32		 jmp	 SHORT $L24302
$L24305:

; 559  : 	// verify that no illegal character present
; 560  : 	// since lpw was allocated based on the size of lpa
; 561  : 	// don't worry about the number of chars
; 562  : 	lpw[0] = '\0';

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
  00017	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 563  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _nChars$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 08	 mov	 edx, DWORD PTR _lpw$[ebp]
  00023	52		 push	 edx
  00024	6a ff		 push	 -1
  00026	8b 45 0c	 mov	 eax, DWORD PTR _lpa$[ebp]
  00029	50		 push	 eax
  0002a	6a 00		 push	 0
  0002c	8b 4d 14	 mov	 ecx, DWORD PTR _acp$[ebp]
  0002f	51		 push	 ecx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00036	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 564  : 	if(ret == 0)

  00039	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0003d	75 04		 jne	 SHORT $L24308

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);
; 567  : 		return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	eb 03		 jmp	 SHORT $L24302
$L24308:

; 568  : 	}		
; 569  : 	return lpw;

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
$L24302:

; 570  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?begin@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::begin
PUBLIC	?end@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::end
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?GetSelectItem@CLocalMusicCoverList@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@XZ ; CLocalMusicCoverList::GetSelectItem
PUBLIC	??9const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator!=
PUBLIC	??Citerator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEPAU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator->
PUBLIC	??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AV012@H@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator++
xdata$x	SEGMENT
$T203187 DD	0ffffffffH
	DD	FLAT:$L203181
	DD	00H
	DD	FLAT:$L203180
$T203185 DD	019930520H
	DD	02H
	DD	FLAT:$T203187
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\playedgamepanel\localmusiccoverlist.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T203182 = -44						; size = 4
$T203179 = -40						; size = 4
_vIndex$ = -36						; size = 16
_itend$ = -20						; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetSelectItem@CLocalMusicCoverList@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@XZ PROC NEAR ; CLocalMusicCoverList::GetSelectItem
; _this$ = ecx

; 225  : {

  00f80	55		 push	 ebp
  00f81	8b ec		 mov	 ebp, esp
  00f83	6a ff		 push	 -1
  00f85	68 00 00 00 00	 push	 __ehhandler$?GetSelectItem@CLocalMusicCoverList@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@XZ
  00f8a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00f90	50		 push	 eax
  00f91	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00f98	83 ec 24	 sub	 esp, 36			; 00000024H
  00f9b	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  00f9e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T203182[ebp], 0

; 226  : 	vector<int> vIndex;

  00fa5	8d 4d dc	 lea	 ecx, DWORD PTR _vIndex$[ebp]
  00fa8	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00fad	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 227  : 	CLMCDataMgr::iterLMCItem it = m_DataMgr.m_vItem.begin();

  00fb4	8d 45 f0	 lea	 eax, DWORD PTR _it$[ebp]
  00fb7	50		 push	 eax
  00fb8	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00fbb	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00fc1	e8 00 00 00 00	 call	 ?begin@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::begin

; 228  : 	CLMCDataMgr::iterLMCItem itend = m_DataMgr.m_vItem.end();

  00fc6	8d 4d ec	 lea	 ecx, DWORD PTR _itend$[ebp]
  00fc9	51		 push	 ecx
  00fca	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00fcd	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00fd3	e8 00 00 00 00	 call	 ?end@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::end

; 229  : 	for (;it!=itend;it++)

  00fd8	eb 0e		 jmp	 SHORT $L200467
$L200468:
  00fda	6a 00		 push	 0
  00fdc	8d 55 d8	 lea	 edx, DWORD PTR $T203179[ebp]
  00fdf	52		 push	 edx
  00fe0	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  00fe3	e8 00 00 00 00	 call	 ??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AV012@H@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator++
$L200467:
  00fe8	8d 45 ec	 lea	 eax, DWORD PTR _itend$[ebp]
  00feb	50		 push	 eax
  00fec	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  00fef	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator!=
  00ff4	0f b6 c8	 movzx	 ecx, al
  00ff7	85 c9		 test	 ecx, ecx
  00ff9	74 24		 je	 SHORT $L200469

; 230  : 	{
; 231  : 		if (it->blSel)

  00ffb	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  00ffe	e8 00 00 00 00	 call	 ??Citerator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEPAU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator->
  01003	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  01007	74 14		 je	 SHORT $L200470

; 232  : 		{
; 233  : 			vIndex.push_back(it->iIndex);

  01009	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  0100c	e8 00 00 00 00	 call	 ??Citerator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEPAU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator->
  01011	83 c0 1c	 add	 eax, 28			; 0000001cH
  01014	50		 push	 eax
  01015	8d 4d dc	 lea	 ecx, DWORD PTR _vIndex$[ebp]
  01018	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
$L200470:

; 234  : 		}
; 235  : 	}

  0101d	eb bb		 jmp	 SHORT $L200468
$L200469:

; 236  : 	return vIndex;

  0101f	8d 55 dc	 lea	 edx, DWORD PTR _vIndex$[ebp]
  01022	52		 push	 edx
  01023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01026	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  0102b	8b 45 d4	 mov	 eax, DWORD PTR $T203182[ebp]
  0102e	83 c8 01	 or	 eax, 1
  01031	89 45 d4	 mov	 DWORD PTR $T203182[ebp], eax
  01034	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01038	8d 4d dc	 lea	 ecx, DWORD PTR _vIndex$[ebp]
  0103b	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  01040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 237  : }

  01043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0104d	8b e5		 mov	 esp, ebp
  0104f	5d		 pop	 ebp
  01050	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L203180:
  00208	8d 4d dc	 lea	 ecx, DWORD PTR _vIndex$[ebp]
  0020b	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
$L203181:
  00210	8b 45 d4	 mov	 eax, DWORD PTR $T203182[ebp]
  00213	83 e0 01	 and	 eax, 1
  00216	0f 84 0c 00 00
	00		 je	 $L203183
  0021c	83 65 d4 fe	 and	 DWORD PTR $T203182[ebp], -2 ; fffffffeH
  00220	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00223	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
$L203183:
  00228	c3		 ret	 0
__ehhandler$?GetSelectItem@CLocalMusicCoverList@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@XZ:
  00229	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203185
  0022e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetSelectItem@CLocalMusicCoverList@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@XZ ENDP ; CLocalMusicCoverList::GetSelectItem
PUBLIC	??0_tagLMCItemInfo@@QAE@ABU0@@Z			; _tagLMCItemInfo::_tagLMCItemInfo
PUBLIC	??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
PUBLIC	?GetItemInfoByIndex@CLocalMusicCoverList@@QAE?AU_tagLMCItemInfo@@H@Z ; CLocalMusicCoverList::GetItemInfoByIndex
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T203190 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iItem$ = 12						; size = 4
?GetItemInfoByIndex@CLocalMusicCoverList@@QAE?AU_tagLMCItemInfo@@H@Z PROC NEAR ; CLocalMusicCoverList::GetItemInfoByIndex
; _this$ = ecx

; 240  : {

  01060	55		 push	 ebp
  01061	8b ec		 mov	 ebp, esp
  01063	83 ec 08	 sub	 esp, 8
  01066	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  01069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T203190[ebp], 0

; 241  : 	return m_DataMgr.m_vItem[iItem];

  01070	8b 45 0c	 mov	 eax, DWORD PTR _iItem$[ebp]
  01073	50		 push	 eax
  01074	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01077	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0107d	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  01082	50		 push	 eax
  01083	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01086	e8 00 00 00 00	 call	 ??0_tagLMCItemInfo@@QAE@ABU0@@Z
  0108b	8b 4d fc	 mov	 ecx, DWORD PTR $T203190[ebp]
  0108e	83 c9 01	 or	 ecx, 1
  01091	89 4d fc	 mov	 DWORD PTR $T203190[ebp], ecx
  01094	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 242  : }

  01097	8b e5		 mov	 esp, ebp
  01099	5d		 pop	 ebp
  0109a	c2 08 00	 ret	 8
?GetItemInfoByIndex@CLocalMusicCoverList@@QAE?AU_tagLMCItemInfo@@H@Z ENDP ; CLocalMusicCoverList::GetItemInfoByIndex
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203200 DD	0ffffffffH
	DD	FLAT:$L203193
	DD	00H
	DD	FLAT:$L203194
	DD	01H
	DD	FLAT:$L203195
$T203198 DD	019930520H
	DD	03H
	DD	FLAT:$T203200
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0_tagLMCItemInfo@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0_tagLMCItemInfo@@QAE@ABU0@@Z PROC NEAR		; _tagLMCItemInfo::_tagLMCItemInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_tagLMCItemInfo@@QAE@ABU0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00036	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00039	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00042	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00045	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0004e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00051	89 41 24	 mov	 DWORD PTR [ecx+36], eax
  00054	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00057	83 c1 28	 add	 ecx, 40			; 00000028H
  0005a	51		 push	 ecx
  0005b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 28	 add	 ecx, 40			; 00000028H
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00067	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0006b	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0006e	83 c2 2c	 add	 edx, 44			; 0000002cH
  00071	52		 push	 edx
  00072	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0007e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00082	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00085	83 c0 30	 add	 eax, 48			; 00000030H
  00088	50		 push	 eax
  00089	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	83 c1 30	 add	 ecx, 48			; 00000030H
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00095	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00098	83 c1 34	 add	 ecx, 52			; 00000034H
  0009b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	83 c2 34	 add	 edx, 52			; 00000034H
  000a1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a3	89 02		 mov	 DWORD PTR [edx], eax
  000a5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000a8	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000ab	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000ae	89 42 08	 mov	 DWORD PTR [edx+8], eax
  000b1	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  000b4	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000be	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203193:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203194:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 28	 add	 ecx, 40			; 00000028H
  0000f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L203195:
  00015	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0001b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$??0_tagLMCItemInfo@@QAE@ABU0@@Z:
  00021	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203198
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0_tagLMCItemInfo@@QAE@ABU0@@Z ENDP			; _tagLMCItemInfo::_tagLMCItemInfo
PUBLIC	?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z	; CWnd::ScreenToClient
PUBLIC	??0CPoint@@QAE@XZ				; CPoint::CPoint
PUBLIC	?OnCalcTracker@CLocalMusicCoverList@@IAEXXZ	; CLocalMusicCoverList::OnCalcTracker
EXTRN	__imp__GetCursorPos@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_point$200483 = -8					; size = 8
?OnCalcTracker@CLocalMusicCoverList@@IAEXXZ PROC NEAR	; CLocalMusicCoverList::OnCalcTracker
; _this$ = ecx

; 245  : {

  010a0	55		 push	 ebp
  010a1	8b ec		 mov	 ebp, esp
  010a3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  010a6	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 246  : 	if (m_blTracker)

  010a9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  010ac	83 b8 64 01 00
	00 00		 cmp	 DWORD PTR [eax+356], 0
  010b3	0f 84 1d 01 00
	00		 je	 $L200481

; 247  : 	{
; 248  : 		CPoint point;

  010b9	8d 4d f8	 lea	 ecx, DWORD PTR _point$200483[ebp]
  010bc	e8 00 00 00 00	 call	 ??0CPoint@@QAE@XZ	; CPoint::CPoint

; 249  : 		GetCursorPos(&point);

  010c1	8d 4d f8	 lea	 ecx, DWORD PTR _point$200483[ebp]
  010c4	51		 push	 ecx
  010c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4

; 250  : 		ScreenToClient(&point);

  010cb	8d 55 f8	 lea	 edx, DWORD PTR _point$200483[ebp]
  010ce	52		 push	 edx
  010cf	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  010d2	e8 00 00 00 00	 call	 ?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z ; CWnd::ScreenToClient

; 251  : 		m_ptDown.y = m_ptClientStart.y+m_iDistance;

  010d7	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  010da	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  010e0	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  010e3	03 8a 38 01 00
	00		 add	 ecx, DWORD PTR [edx+312]
  010e9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  010ec	89 88 20 01 00
	00		 mov	 DWORD PTR [eax+288], ecx

; 252  : 		if (point.x>m_ptDown.x)

  010f2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  010f5	8b 55 f8	 mov	 edx, DWORD PTR _point$200483[ebp]
  010f8	3b 91 1c 01 00
	00		 cmp	 edx, DWORD PTR [ecx+284]
  010fe	7e 20		 jle	 SHORT $L200484

; 253  : 		{
; 254  : 			m_rcTracker.left = m_ptDown.x;

  01100	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01103	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01106	8b 91 1c 01 00
	00		 mov	 edx, DWORD PTR [ecx+284]
  0110c	89 90 28 01 00
	00		 mov	 DWORD PTR [eax+296], edx

; 255  : 			m_rcTracker.right = point.x;

  01112	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01115	8b 4d f8	 mov	 ecx, DWORD PTR _point$200483[ebp]
  01118	89 88 30 01 00
	00		 mov	 DWORD PTR [eax+304], ecx

; 256  : 		}
; 257  : 		else

  0111e	eb 1e		 jmp	 SHORT $L200485
$L200484:

; 258  : 		{
; 259  : 			m_rcTracker.left = point.x;

  01120	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01123	8b 45 f8	 mov	 eax, DWORD PTR _point$200483[ebp]
  01126	89 82 28 01 00
	00		 mov	 DWORD PTR [edx+296], eax

; 260  : 			m_rcTracker.right = m_ptDown.x;

  0112c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0112f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01132	8b 82 1c 01 00
	00		 mov	 eax, DWORD PTR [edx+284]
  01138	89 81 30 01 00
	00		 mov	 DWORD PTR [ecx+304], eax
$L200485:

; 261  : 		}
; 262  : 		if (point.y>m_ptDown.y)

  0113e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01141	8b 55 fc	 mov	 edx, DWORD PTR _point$200483[ebp+4]
  01144	3b 91 20 01 00
	00		 cmp	 edx, DWORD PTR [ecx+288]
  0114a	7e 20		 jle	 SHORT $L200486

; 263  : 		{
; 264  : 			m_rcTracker.top = m_ptDown.y;

  0114c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0114f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01152	8b 91 20 01 00
	00		 mov	 edx, DWORD PTR [ecx+288]
  01158	89 90 2c 01 00
	00		 mov	 DWORD PTR [eax+300], edx

; 265  : 			m_rcTracker.bottom = point.y;

  0115e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01161	8b 4d fc	 mov	 ecx, DWORD PTR _point$200483[ebp+4]
  01164	89 88 34 01 00
	00		 mov	 DWORD PTR [eax+308], ecx

; 266  : 		}
; 267  : 		else

  0116a	eb 1e		 jmp	 SHORT $L200487
$L200486:

; 268  : 		{
; 269  : 			m_rcTracker.top = point.y;

  0116c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0116f	8b 45 fc	 mov	 eax, DWORD PTR _point$200483[ebp+4]
  01172	89 82 2c 01 00
	00		 mov	 DWORD PTR [edx+300], eax

; 270  : 			m_rcTracker.bottom = m_ptDown.y;

  01178	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0117b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0117e	8b 82 20 01 00
	00		 mov	 eax, DWORD PTR [edx+288]
  01184	89 81 34 01 00
	00		 mov	 DWORD PTR [ecx+308], eax
$L200487:

; 271  : 		}
; 272  : 
; 273  : 		// 
; 274  : 		if (m_rcTracker.left<m_rect.left)

  0118a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0118d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01190	8b 81 28 01 00
	00		 mov	 eax, DWORD PTR [ecx+296]
  01196	3b 82 8c 00 00
	00		 cmp	 eax, DWORD PTR [edx+140]
  0119c	7d 12		 jge	 SHORT $L200488

; 275  : 			m_rcTracker.left = m_rect.left;

  0119e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  011a1	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  011a4	8b 82 8c 00 00
	00		 mov	 eax, DWORD PTR [edx+140]
  011aa	89 81 28 01 00
	00		 mov	 DWORD PTR [ecx+296], eax
$L200488:

; 276  : 		if (m_rcTracker.right>m_rect.right)

  011b0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  011b3	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  011b6	8b 81 30 01 00
	00		 mov	 eax, DWORD PTR [ecx+304]
  011bc	3b 82 94 00 00
	00		 cmp	 eax, DWORD PTR [edx+148]
  011c2	7e 12		 jle	 SHORT $L200481

; 277  : 			m_rcTracker.right = m_rect.right;

  011c4	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  011c7	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  011ca	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [edx+148]
  011d0	89 81 30 01 00
	00		 mov	 DWORD PTR [ecx+304], eax
$L200481:

; 278  : 
; 279  : 	}
; 280  : }

  011d6	8b e5		 mov	 esp, ebp
  011d8	5d		 pop	 ebp
  011d9	c3		 ret	 0
?OnCalcTracker@CLocalMusicCoverList@@IAEXXZ ENDP	; CLocalMusicCoverList::OnCalcTracker
_TEXT	ENDS
PUBLIC	?IntersectRect@CRect@@QAEHPBUtagRECT@@0@Z	; CRect::IntersectRect
PUBLIC	?Rectangle@CDC@@QAEHPBUtagRECT@@@Z		; CDC::Rectangle
PUBLIC	?AlphaBlend@CDC@@QAEHHHHHPAV1@HHHHU_BLENDFUNCTION@@@Z ; CDC::AlphaBlend
PUBLIC	?OnCalcSelectItem@CLocalMusicCoverList@@IAEXXZ	; CLocalMusicCoverList::OnCalcSelectItem
PUBLIC	?OnDrawTracker@CLocalMusicCoverList@@IAEXXZ	; CLocalMusicCoverList::OnDrawTracker
PUBLIC	?CreateStockObject@CGdiObject@@QAEHH@Z		; CGdiObject::CreateStockObject
PUBLIC	??1CPen@@UAE@XZ					; CPen::~CPen
PUBLIC	??0CBrush@@QAE@XZ				; CBrush::CBrush
PUBLIC	??1CBrush@@UAE@XZ				; CBrush::~CBrush
EXTRN	?SelectObject@CDC@@QAEPAVCPen@@PAV2@@Z:NEAR	; CDC::SelectObject
EXTRN	?SelectObject@CDC@@QAEPAVCBrush@@PAV2@@Z:NEAR	; CDC::SelectObject
EXTRN	??0CPen@@QAE@HHK@Z:NEAR				; CPen::CPen
xdata$x	SEGMENT
$T203211 DD	0ffffffffH
	DD	FLAT:$L203206
	DD	00H
	DD	FLAT:$L203207
$T203209 DD	019930520H
	DD	02H
	DD	FLAT:$T203211
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -56						; size = 4
_pen$200502 = -52					; size = 8
_brOld$200495 = -44					; size = 4
_brNull$200494 = -40					; size = 8
_rcDraw$200504 = -32					; size = 16
_penold$200503 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnDrawTracker@CLocalMusicCoverList@@IAEXXZ PROC NEAR	; CLocalMusicCoverList::OnDrawTracker
; _this$ = ecx

; 283  : {

  011e0	55		 push	 ebp
  011e1	8b ec		 mov	 ebp, esp
  011e3	6a ff		 push	 -1
  011e5	68 00 00 00 00	 push	 __ehhandler$?OnDrawTracker@CLocalMusicCoverList@@IAEXXZ
  011ea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  011f0	50		 push	 eax
  011f1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  011f8	83 ec 2c	 sub	 esp, 44			; 0000002cH
  011fb	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 284  : 	if (m_blTracker)

  011fe	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  01201	83 b8 64 01 00
	00 00		 cmp	 DWORD PTR [eax+356], 0
  01208	0f 84 1e 01 00
	00		 je	 $L200492

; 285  : 	{
; 286  : 		CBrush brNull;

  0120e	8d 4d d8	 lea	 ecx, DWORD PTR _brNull$200494[ebp]
  01211	e8 00 00 00 00	 call	 ??0CBrush@@QAE@XZ	; CBrush::CBrush
  01216	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 287  : 		brNull.CreateStockObject(NULL_BRUSH);

  0121d	6a 05		 push	 5
  0121f	8d 4d d8	 lea	 ecx, DWORD PTR _brNull$200494[ebp]
  01222	e8 00 00 00 00	 call	 ?CreateStockObject@CGdiObject@@QAEHH@Z ; CGdiObject::CreateStockObject

; 288  : 		CBrush* brOld = m_dcMem.SelectObject(&brNull);

  01227	8d 4d d8	 lea	 ecx, DWORD PTR _brNull$200494[ebp]
  0122a	51		 push	 ecx
  0122b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0122e	83 c1 60	 add	 ecx, 96			; 00000060H
  01231	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCBrush@@PAV2@@Z ; CDC::SelectObject
  01236	89 45 d4	 mov	 DWORD PTR _brOld$200495[ebp], eax

; 289  : 		CPen pen(PS_SOLID,1,RGB(125,125,125));

  01239	68 7d 7d 7d 00	 push	 8224125			; 007d7d7dH
  0123e	6a 01		 push	 1
  01240	6a 00		 push	 0
  01242	8d 4d cc	 lea	 ecx, DWORD PTR _pen$200502[ebp]
  01245	e8 00 00 00 00	 call	 ??0CPen@@QAE@HHK@Z	; CPen::CPen
  0124a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 290  : 		CPen *penold = m_dcMem.SelectObject(&pen);

  0124e	8d 55 cc	 lea	 edx, DWORD PTR _pen$200502[ebp]
  01251	52		 push	 edx
  01252	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01255	83 c1 60	 add	 ecx, 96			; 00000060H
  01258	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCPen@@PAV2@@Z ; CDC::SelectObject
  0125d	89 45 f0	 mov	 DWORD PTR _penold$200503[ebp], eax

; 291  : 		m_dcMem.Rectangle(&m_rcTracker);

  01260	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  01263	05 28 01 00 00	 add	 eax, 296		; 00000128H
  01268	50		 push	 eax
  01269	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0126c	83 c1 60	 add	 ecx, 96			; 00000060H
  0126f	e8 00 00 00 00	 call	 ?Rectangle@CDC@@QAEHPBUtagRECT@@@Z ; CDC::Rectangle

; 292  : 		CRect rcDraw;

  01274	8d 4d e0	 lea	 ecx, DWORD PTR _rcDraw$200504[ebp]
  01277	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 293  : 		if (rcDraw.IntersectRect(&m_rcTracker,&m_rect))

  0127c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0127f	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01285	51		 push	 ecx
  01286	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  01289	81 c2 28 01 00
	00		 add	 edx, 296		; 00000128H
  0128f	52		 push	 edx
  01290	8d 4d e0	 lea	 ecx, DWORD PTR _rcDraw$200504[ebp]
  01293	e8 00 00 00 00	 call	 ?IntersectRect@CRect@@QAEHPBUtagRECT@@0@Z ; CRect::IntersectRect
  01298	85 c0		 test	 eax, eax
  0129a	74 4f		 je	 SHORT $L200505

; 294  : 			m_dcMem.AlphaBlend(rcDraw.left,rcDraw.top,rcDraw.Width(),rcDraw.Height(),&m_dcTracker,0,0,rcDraw.Width(),rcDraw.Height(),m_bf);

  0129c	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0129f	8b 88 24 01 00
	00		 mov	 ecx, DWORD PTR [eax+292]
  012a5	51		 push	 ecx
  012a6	8d 4d e0	 lea	 ecx, DWORD PTR _rcDraw$200504[ebp]
  012a9	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  012ae	50		 push	 eax
  012af	8d 4d e0	 lea	 ecx, DWORD PTR _rcDraw$200504[ebp]
  012b2	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  012b7	50		 push	 eax
  012b8	6a 00		 push	 0
  012ba	6a 00		 push	 0
  012bc	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  012bf	81 c2 00 01 00
	00		 add	 edx, 256		; 00000100H
  012c5	52		 push	 edx
  012c6	8d 4d e0	 lea	 ecx, DWORD PTR _rcDraw$200504[ebp]
  012c9	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  012ce	50		 push	 eax
  012cf	8d 4d e0	 lea	 ecx, DWORD PTR _rcDraw$200504[ebp]
  012d2	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  012d7	50		 push	 eax
  012d8	8b 45 e4	 mov	 eax, DWORD PTR _rcDraw$200504[ebp+4]
  012db	50		 push	 eax
  012dc	8b 4d e0	 mov	 ecx, DWORD PTR _rcDraw$200504[ebp]
  012df	51		 push	 ecx
  012e0	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  012e3	83 c1 60	 add	 ecx, 96			; 00000060H
  012e6	e8 00 00 00 00	 call	 ?AlphaBlend@CDC@@QAEHHHHHPAV1@HHHHU_BLENDFUNCTION@@@Z ; CDC::AlphaBlend
$L200505:

; 295  : 		m_dcMem.SelectObject(brOld);

  012eb	8b 55 d4	 mov	 edx, DWORD PTR _brOld$200495[ebp]
  012ee	52		 push	 edx
  012ef	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  012f2	83 c1 60	 add	 ecx, 96			; 00000060H
  012f5	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCBrush@@PAV2@@Z ; CDC::SelectObject

; 296  : 		m_dcMem.SelectObject(penold);

  012fa	8b 45 f0	 mov	 eax, DWORD PTR _penold$200503[ebp]
  012fd	50		 push	 eax
  012fe	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01301	83 c1 60	 add	 ecx, 96			; 00000060H
  01304	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCPen@@PAV2@@Z ; CDC::SelectObject

; 297  : 		OnCalcSelectItem();

  01309	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0130c	e8 00 00 00 00	 call	 ?OnCalcSelectItem@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::OnCalcSelectItem

; 298  : 	}

  01311	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01315	8d 4d cc	 lea	 ecx, DWORD PTR _pen$200502[ebp]
  01318	e8 00 00 00 00	 call	 ??1CPen@@UAE@XZ		; CPen::~CPen
  0131d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01324	8d 4d d8	 lea	 ecx, DWORD PTR _brNull$200494[ebp]
  01327	e8 00 00 00 00	 call	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
$L200492:

; 299  : }

  0132c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0132f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01336	8b e5		 mov	 esp, ebp
  01338	5d		 pop	 ebp
  01339	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L203206:
  00233	8d 4d d8	 lea	 ecx, DWORD PTR _brNull$200494[ebp]
  00236	e9 00 00 00 00	 jmp	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
$L203207:
  0023b	8d 4d cc	 lea	 ecx, DWORD PTR _pen$200502[ebp]
  0023e	e9 00 00 00 00	 jmp	 ??1CPen@@UAE@XZ		; CPen::~CPen
__ehhandler$?OnDrawTracker@CLocalMusicCoverList@@IAEXXZ:
  00243	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203209
  00248	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OnDrawTracker@CLocalMusicCoverList@@IAEXXZ ENDP	; CLocalMusicCoverList::OnDrawTracker
PUBLIC	?RedrawWindow@CWnd@@QAEHPBUtagRECT@@PAVCRgn@@I@Z ; CWnd::RedrawWindow
PUBLIC	?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
PUBLIC	?DrawItem@CLocalMusicCoverList@@IAEXVCPoint@@AAU_tagLMCItemInfo@@@Z ; CLocalMusicCoverList::DrawItem
PUBLIC	?CalcHideItemRect@CLocalMusicCoverList@@IAEXVCPoint@@AAU_tagLMCItemInfo@@@Z ; CLocalMusicCoverList::CalcHideItemRect
EXTRN	?FillSolidRect@CDC@@QAEXPBUtagRECT@@K@Z:NEAR	; CDC::FillSolidRect
; Function compile flags: /Odt
_TEXT	SEGMENT
tv375 = -108						; size = 4
tv372 = -104						; size = 4
tv369 = -100						; size = 4
tv364 = -96						; size = 4
tv363 = -92						; size = 4
tv360 = -88						; size = 4
tv359 = -84						; size = 4
tv356 = -80						; size = 4
tv351 = -76						; size = 4
tv350 = -72						; size = 4
tv347 = -68						; size = 4
tv346 = -64						; size = 4
tv343 = -60						; size = 4
_this$ = -56						; size = 4
_i$200526 = -52						; size = 4
_rcRightLine$200512 = -48				; size = 16
_iWidthSpace$ = -32					; size = 4
_lenVbar$ = -28						; size = 4
_nPos$ = -24						; size = 4
_ptS$ = -20						; size = 8
_realhight$ = -12					; size = 4
_iHeightSpace$ = -8					; size = 4
_fper$ = -4						; size = 4
_blRePaint$ = 8						; size = 4
?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z PROC NEAR	; CLocalMusicCoverList::OnMemoryDraw
; _this$ = ecx

; 302  : {

  01340	55		 push	 ebp
  01341	8b ec		 mov	 ebp, esp
  01343	83 ec 6c	 sub	 esp, 108		; 0000006cH
  01346	56		 push	 esi
  01347	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 303  : 	if (m_rect.Width()==0) return;

  0134a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0134d	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01353	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  01358	85 c0		 test	 eax, eax
  0135a	75 05		 jne	 SHORT $L200510
  0135c	e9 47 03 00 00	 jmp	 $L200509
$L200510:

; 304  : 	m_dcMem.FillSolidRect(&m_rect,m_gdires.colListBK);

  01361	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  01364	8b 88 ec 00 00
	00		 mov	 ecx, DWORD PTR [eax+236]
  0136a	51		 push	 ecx
  0136b	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0136e	81 c2 8c 00 00
	00		 add	 edx, 140		; 0000008cH
  01374	52		 push	 edx
  01375	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01378	83 c1 60	 add	 ecx, 96			; 00000060H
  0137b	e8 00 00 00 00	 call	 ?FillSolidRect@CDC@@QAEXPBUtagRECT@@K@Z ; CDC::FillSolidRect

; 305  : 	
; 306  : 	if (m_rect.Width()<550&&m_rect.Height()>m_rcRealRect.Height())

  01380	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01383	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01389	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  0138e	3d 26 02 00 00	 cmp	 eax, 550		; 00000226H
  01393	7d 5e		 jge	 SHORT $L200511
  01395	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01398	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0139e	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  013a3	8b f0		 mov	 esi, eax
  013a5	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  013a8	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  013ae	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  013b3	3b f0		 cmp	 esi, eax
  013b5	7e 3c		 jle	 SHORT $L200511

; 307  : 	{// RmPanel
; 308  : 		CRect rcRightLine=m_rect;

  013b7	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  013ba	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
  013bf	8b 08		 mov	 ecx, DWORD PTR [eax]
  013c1	89 4d d0	 mov	 DWORD PTR _rcRightLine$200512[ebp], ecx
  013c4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  013c7	89 55 d4	 mov	 DWORD PTR _rcRightLine$200512[ebp+4], edx
  013ca	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  013cd	89 4d d8	 mov	 DWORD PTR _rcRightLine$200512[ebp+8], ecx
  013d0	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  013d3	89 55 dc	 mov	 DWORD PTR _rcRightLine$200512[ebp+12], edx

; 309  : 		rcRightLine.left=rcRightLine.right-1;

  013d6	8b 45 d8	 mov	 eax, DWORD PTR _rcRightLine$200512[ebp+8]
  013d9	83 e8 01	 sub	 eax, 1
  013dc	89 45 d0	 mov	 DWORD PTR _rcRightLine$200512[ebp], eax

; 310  : 		m_dcMem.FillSolidRect(&rcRightLine,RGB(165,186,214));

  013df	68 a5 ba d6 00	 push	 14072485		; 00d6baa5H
  013e4	8d 4d d0	 lea	 ecx, DWORD PTR _rcRightLine$200512[ebp]
  013e7	51		 push	 ecx
  013e8	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  013eb	83 c1 60	 add	 ecx, 96			; 00000060H
  013ee	e8 00 00 00 00	 call	 ?FillSolidRect@CDC@@QAEXPBUtagRECT@@K@Z ; CDC::FillSolidRect
$L200511:

; 311  : 	}
; 312  : 	// 
; 313  : 	OnCalcTracker();

  013f3	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  013f6	e8 00 00 00 00	 call	 ?OnCalcTracker@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::OnCalcTracker

; 314  : 	int iHeightSpace=0;

  013fb	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iHeightSpace$[ebp], 0

; 315  : 	int iWidthSpace=0;

  01402	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iWidthSpace$[ebp], 0

; 316  : 	if (m_ImgState==LMCI_Small)

  01409	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0140c	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  01410	75 0e		 jne	 SHORT $L200521

; 317  : 		iHeightSpace = m_iItemHeight+SPACEH + ITEMTXTH + SPACEH*2;

  01412	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  01415	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  01418	83 c1 1b	 add	 ecx, 27			; 0000001bH
  0141b	89 4d f8	 mov	 DWORD PTR _iHeightSpace$[ebp], ecx

; 318  : 	else

  0141e	eb 0c		 jmp	 SHORT $L200522
$L200521:

; 319  : 		iHeightSpace = m_iItemHeight+SPACEH + ITEMTXTH + SPACEH + ITEMTXTH + SPACEH*3;

  01420	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  01423	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  01426	83 c0 32	 add	 eax, 50			; 00000032H
  01429	89 45 f8	 mov	 DWORD PTR _iHeightSpace$[ebp], eax
$L200522:

; 320  : 	if (m_ImgState==LMCI_Small)

  0142c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0142f	83 79 5c 00	 cmp	 DWORD PTR [ecx+92], 0
  01433	75 09		 jne	 SHORT $L200523

; 321  : 		iWidthSpace = SPACEWS;

  01435	c7 45 e0 0a 00
	00 00		 mov	 DWORD PTR _iWidthSpace$[ebp], 10 ; 0000000aH

; 322  : 	else

  0143c	eb 07		 jmp	 SHORT $L200524
$L200523:

; 323  : 		iWidthSpace = SPACEW;

  0143e	c7 45 e0 10 00
	00 00		 mov	 DWORD PTR _iWidthSpace$[ebp], 16 ; 00000010H
$L200524:

; 324  : 	CPoint ptS = m_ptClientStart;

  01445	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  01448	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  0144e	8b 8a b0 00 00
	00		 mov	 ecx, DWORD PTR [edx+176]
  01454	89 45 ec	 mov	 DWORD PTR _ptS$[ebp], eax
  01457	89 4d f0	 mov	 DWORD PTR _ptS$[ebp+4], ecx

; 325  : 	ptS.x = iWidthSpace+m_ptClientStart.x;

  0145a	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0145d	8b 45 e0	 mov	 eax, DWORD PTR _iWidthSpace$[ebp]
  01460	03 82 ac 00 00
	00		 add	 eax, DWORD PTR [edx+172]
  01466	89 45 ec	 mov	 DWORD PTR _ptS$[ebp], eax

; 326  : 	ptS.y = SPACEH+m_ptClientStart.y;

  01469	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0146c	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  01472	83 c2 04	 add	 edx, 4
  01475	89 55 f0	 mov	 DWORD PTR _ptS$[ebp+4], edx

; 327  : 	
; 328  : 	for(int i=0;i<m_DataMgr.m_vItem.size();i++)

  01478	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$200526[ebp], 0
  0147f	eb 09		 jmp	 SHORT $L200527
$L200528:
  01481	8b 45 cc	 mov	 eax, DWORD PTR _i$200526[ebp]
  01484	83 c0 01	 add	 eax, 1
  01487	89 45 cc	 mov	 DWORD PTR _i$200526[ebp], eax
$L200527:
  0148a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0148d	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  01493	e8 00 00 00 00	 call	 ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
  01498	39 45 cc	 cmp	 DWORD PTR _i$200526[ebp], eax
  0149b	0f 83 e9 00 00
	00		 jae	 $L200529

; 329  : 	{
; 330  : 		if (ptS.x+m_iItemWidth>m_rect.right)

  014a1	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  014a4	8b 55 ec	 mov	 edx, DWORD PTR _ptS$[ebp]
  014a7	03 51 54	 add	 edx, DWORD PTR [ecx+84]
  014aa	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  014ad	3b 90 94 00 00
	00		 cmp	 edx, DWORD PTR [eax+148]
  014b3	7e 26		 jle	 SHORT $L200530

; 331  : 		{
; 332  : 			ptS.y = ptS.y + iHeightSpace;

  014b5	8b 4d f0	 mov	 ecx, DWORD PTR _ptS$[ebp+4]
  014b8	03 4d f8	 add	 ecx, DWORD PTR _iHeightSpace$[ebp]
  014bb	89 4d f0	 mov	 DWORD PTR _ptS$[ebp+4], ecx

; 333  : 			//ptS.x = m_ptClientStart.x+SPACEW;
; 334  : 			ptS.x = m_ptClientStart.x+iWidthSpace;

  014be	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  014c1	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  014c7	03 45 e0	 add	 eax, DWORD PTR _iWidthSpace$[ebp]
  014ca	89 45 ec	 mov	 DWORD PTR _ptS$[ebp], eax

; 335  : 			i--;// 1

  014cd	8b 4d cc	 mov	 ecx, DWORD PTR _i$200526[ebp]
  014d0	83 e9 01	 sub	 ecx, 1
  014d3	89 4d cc	 mov	 DWORD PTR _i$200526[ebp], ecx

; 336  : 		}
; 337  : 		else

  014d6	e9 aa 00 00 00	 jmp	 $L200531
$L200530:

; 338  : 		{
; 339  : 			if (ptS.y>m_rect.bottom)

  014db	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  014de	8b 45 f0	 mov	 eax, DWORD PTR _ptS$[ebp+4]
  014e1	3b 82 98 00 00
	00		 cmp	 eax, DWORD PTR [edx+152]
  014e7	7e 34		 jle	 SHORT $L200532

; 340  : 			{
; 341  : 				// Item
; 342  : 				CalcHideItemRect(ptS,m_DataMgr.m_vItem[i]);

  014e9	8b 4d cc	 mov	 ecx, DWORD PTR _i$200526[ebp]
  014ec	51		 push	 ecx
  014ed	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  014f0	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  014f6	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  014fb	50		 push	 eax
  014fc	8b 55 f0	 mov	 edx, DWORD PTR _ptS$[ebp+4]
  014ff	52		 push	 edx
  01500	8b 45 ec	 mov	 eax, DWORD PTR _ptS$[ebp]
  01503	50		 push	 eax
  01504	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01507	e8 00 00 00 00	 call	 ?CalcHideItemRect@CLocalMusicCoverList@@IAEXVCPoint@@AAU_tagLMCItemInfo@@@Z ; CLocalMusicCoverList::CalcHideItemRect

; 343  : 				//ptS.x = ptS.x+m_iItemWidth+SPACEW;
; 344  : 				ptS.x = ptS.x+m_iItemWidth+iWidthSpace;

  0150c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0150f	8b 55 ec	 mov	 edx, DWORD PTR _ptS$[ebp]
  01512	03 51 54	 add	 edx, DWORD PTR [ecx+84]
  01515	03 55 e0	 add	 edx, DWORD PTR _iWidthSpace$[ebp]
  01518	89 55 ec	 mov	 DWORD PTR _ptS$[ebp], edx

; 345  : 			}
; 346  : 			else

  0151b	eb 68		 jmp	 SHORT $L200531
$L200532:

; 347  : 			{
; 348  : 				if (ptS.y+iHeightSpace>=m_rect.top)

  0151d	8b 45 f0	 mov	 eax, DWORD PTR _ptS$[ebp+4]
  01520	03 45 f8	 add	 eax, DWORD PTR _iHeightSpace$[ebp]
  01523	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01526	3b 81 90 00 00
	00		 cmp	 eax, DWORD PTR [ecx+144]
  0152c	7c 25		 jl	 SHORT $L200534

; 349  : 				{
; 350  : 					DrawItem(ptS,m_DataMgr.m_vItem[i]);

  0152e	8b 55 cc	 mov	 edx, DWORD PTR _i$200526[ebp]
  01531	52		 push	 edx
  01532	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01535	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0153b	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  01540	50		 push	 eax
  01541	8b 45 f0	 mov	 eax, DWORD PTR _ptS$[ebp+4]
  01544	50		 push	 eax
  01545	8b 4d ec	 mov	 ecx, DWORD PTR _ptS$[ebp]
  01548	51		 push	 ecx
  01549	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0154c	e8 00 00 00 00	 call	 ?DrawItem@CLocalMusicCoverList@@IAEXVCPoint@@AAU_tagLMCItemInfo@@@Z ; CLocalMusicCoverList::DrawItem

; 351  : 				}
; 352  : 				else

  01551	eb 23		 jmp	 SHORT $L200535
$L200534:

; 353  : 				{
; 354  : 					// Item
; 355  : 					CalcHideItemRect(ptS,m_DataMgr.m_vItem[i]);

  01553	8b 55 cc	 mov	 edx, DWORD PTR _i$200526[ebp]
  01556	52		 push	 edx
  01557	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0155a	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  01560	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  01565	50		 push	 eax
  01566	8b 45 f0	 mov	 eax, DWORD PTR _ptS$[ebp+4]
  01569	50		 push	 eax
  0156a	8b 4d ec	 mov	 ecx, DWORD PTR _ptS$[ebp]
  0156d	51		 push	 ecx
  0156e	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01571	e8 00 00 00 00	 call	 ?CalcHideItemRect@CLocalMusicCoverList@@IAEXVCPoint@@AAU_tagLMCItemInfo@@@Z ; CLocalMusicCoverList::CalcHideItemRect
$L200535:

; 356  : 				}
; 357  : 				//ptS.x = ptS.x+m_iItemWidth+SPACEW;
; 358  : 				ptS.x = ptS.x+m_iItemWidth+iWidthSpace;

  01576	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  01579	8b 45 ec	 mov	 eax, DWORD PTR _ptS$[ebp]
  0157c	03 42 54	 add	 eax, DWORD PTR [edx+84]
  0157f	03 45 e0	 add	 eax, DWORD PTR _iWidthSpace$[ebp]
  01582	89 45 ec	 mov	 DWORD PTR _ptS$[ebp], eax
$L200531:

; 359  : 			}
; 360  : 		}
; 361  : 	}

  01585	e9 f7 fe ff ff	 jmp	 $L200528
$L200529:

; 362  : 	// 
; 363  : 	OnDrawTracker();

  0158a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0158d	e8 00 00 00 00	 call	 ?OnDrawTracker@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::OnDrawTracker

; 364  : 	//Invalidate();
; 365  : 	RedrawWindow();

  01592	68 05 01 00 00	 push	 261			; 00000105H
  01597	6a 00		 push	 0
  01599	6a 00		 push	 0
  0159b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0159e	e8 00 00 00 00	 call	 ?RedrawWindow@CWnd@@QAEHPBUtagRECT@@PAVCRgn@@I@Z ; CWnd::RedrawWindow

; 366  : 
; 367  : 	int lenVbar = (float)m_rect.Height()/m_rcRealRect.Height()*m_rect.Height();

  015a3	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  015a6	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  015ac	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  015b1	89 45 c4	 mov	 DWORD PTR tv343[ebp], eax
  015b4	db 45 c4	 fild	 DWORD PTR tv343[ebp]
  015b7	d9 5d c0	 fstp	 DWORD PTR tv346[ebp]
  015ba	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  015bd	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  015c3	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  015c8	89 45 bc	 mov	 DWORD PTR tv347[ebp], eax
  015cb	db 45 bc	 fild	 DWORD PTR tv347[ebp]
  015ce	d8 7d c0	 fdivr	 DWORD PTR tv346[ebp]
  015d1	d9 5d b8	 fstp	 DWORD PTR tv350[ebp]
  015d4	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  015d7	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  015dd	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  015e2	89 45 b4	 mov	 DWORD PTR tv351[ebp], eax
  015e5	db 45 b4	 fild	 DWORD PTR tv351[ebp]
  015e8	d8 4d b8	 fmul	 DWORD PTR tv350[ebp]
  015eb	e8 00 00 00 00	 call	 __ftol2
  015f0	89 45 e4	 mov	 DWORD PTR _lenVbar$[ebp], eax

; 368  : 	int realhight = (float)(m_rect.Height()-lenVbar)/m_rect.Height()*m_rcRealRect.Height();

  015f3	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  015f6	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  015fc	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01601	2b 45 e4	 sub	 eax, DWORD PTR _lenVbar$[ebp]
  01604	89 45 b0	 mov	 DWORD PTR tv356[ebp], eax
  01607	db 45 b0	 fild	 DWORD PTR tv356[ebp]
  0160a	d9 5d ac	 fstp	 DWORD PTR tv359[ebp]
  0160d	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01610	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01616	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0161b	89 45 a8	 mov	 DWORD PTR tv360[ebp], eax
  0161e	db 45 a8	 fild	 DWORD PTR tv360[ebp]
  01621	d8 7d ac	 fdivr	 DWORD PTR tv359[ebp]
  01624	d9 5d a4	 fstp	 DWORD PTR tv363[ebp]
  01627	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0162a	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  01630	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01635	89 45 a0	 mov	 DWORD PTR tv364[ebp], eax
  01638	db 45 a0	 fild	 DWORD PTR tv364[ebp]
  0163b	d8 4d a4	 fmul	 DWORD PTR tv363[ebp]
  0163e	e8 00 00 00 00	 call	 __ftol2
  01643	89 45 f4	 mov	 DWORD PTR _realhight$[ebp], eax

; 369  : 	float fper = (float)(0-m_ptClientStart.y)/(m_rcRealRect.Height()-m_rect.Height());

  01646	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01649	33 d2		 xor	 edx, edx
  0164b	2b 91 b0 00 00
	00		 sub	 edx, DWORD PTR [ecx+176]
  01651	89 55 9c	 mov	 DWORD PTR tv369[ebp], edx
  01654	db 45 9c	 fild	 DWORD PTR tv369[ebp]
  01657	d9 5d 98	 fstp	 DWORD PTR tv372[ebp]
  0165a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0165d	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  01663	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01668	8b f0		 mov	 esi, eax
  0166a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0166d	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01673	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01678	2b f0		 sub	 esi, eax
  0167a	89 75 94	 mov	 DWORD PTR tv375[ebp], esi
  0167d	db 45 94	 fild	 DWORD PTR tv375[ebp]
  01680	d8 7d 98	 fdivr	 DWORD PTR tv372[ebp]
  01683	d9 5d fc	 fstp	 DWORD PTR _fper$[ebp]

; 370  : 	int nPos = fper*realhight;

  01686	db 45 f4	 fild	 DWORD PTR _realhight$[ebp]
  01689	d8 4d fc	 fmul	 DWORD PTR _fper$[ebp]
  0168c	e8 00 00 00 00	 call	 __ftol2
  01691	89 45 e8	 mov	 DWORD PTR _nPos$[ebp], eax

; 371  : 	CoolSB_SetScrollPos(m_hWnd,SB_VERT,nPos,TRUE);

  01694	6a 01		 push	 1
  01696	8b 45 e8	 mov	 eax, DWORD PTR _nPos$[ebp]
  01699	50		 push	 eax
  0169a	6a 01		 push	 1
  0169c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0169f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  016a2	52		 push	 edx
  016a3	e8 00 00 00 00	 call	 _CoolSB_SetScrollPos@16
$L200509:

; 372  : }

  016a8	5e		 pop	 esi
  016a9	8b e5		 mov	 esp, ebp
  016ab	5d		 pop	 ebp
  016ac	c2 04 00	 ret	 4
?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z ENDP	; CLocalMusicCoverList::OnMemoryDraw
_TEXT	ENDS
PUBLIC	?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ		; CDC::GetSafeHdc
PUBLIC	?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z	; CDC::SelectObject
PUBLIC	?IsRectEmpty@CRect@@QBEHXZ			; CRect::IsRectEmpty
PUBLIC	?IsRectNull@CRect@@QBEHXZ			; CRect::IsRectNull
PUBLIC	??8CRect@@QBEHABUtagRECT@@@Z			; CRect::operator==
PUBLIC	?GetSafeHandle@CGdiObject@@QBEPAXXZ		; CGdiObject::GetSafeHandle
PUBLIC	?CreateCompatibleBitmap@CBitmap@@QAEHPAVCDC@@HH@Z ; CBitmap::CreateCompatibleBitmap
EXTRN	?DeleteObject@CGdiObject@@QAEHXZ:NEAR		; CGdiObject::DeleteObject
xdata$x	SEGMENT
$T203218 DD	0ffffffffH
	DD	FLAT:$L203214
$T203216 DD	019930520H
	DD	01H
	DD	FLAT:$T203218
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -60						; size = 4
_sz$ = -56						; size = 8
_rs$ = -48						; size = 16
_dc$ = -32						; size = 20
__$EHRec$ = -12						; size = 12
_blFouce$ = 8						; size = 4
?SizeChanged@CLocalMusicCoverList@@IAEXH@Z PROC NEAR	; CLocalMusicCoverList::SizeChanged
; _this$ = ecx

; 375  : {

  016b0	55		 push	 ebp
  016b1	8b ec		 mov	 ebp, esp
  016b3	6a ff		 push	 -1
  016b5	68 00 00 00 00	 push	 __ehhandler$?SizeChanged@CLocalMusicCoverList@@IAEXH@Z
  016ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  016c0	50		 push	 eax
  016c1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  016c8	83 ec 30	 sub	 esp, 48			; 00000030H
  016cb	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 	CRect rs;

  016ce	8d 4d d0	 lea	 ecx, DWORD PTR _rs$[ebp]
  016d1	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 377  : 	GetClientRect(&rs);

  016d6	8d 45 d0	 lea	 eax, DWORD PTR _rs$[ebp]
  016d9	50		 push	 eax
  016da	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  016dd	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 378  : 	if (!blFouce)

  016e2	83 7d 08 00	 cmp	 DWORD PTR _blFouce$[ebp], 0
  016e6	75 33		 jne	 SHORT $L200548

; 379  : 	{
; 380  : 		if(rs.IsRectNull() || rs.IsRectEmpty() || rs == m_rect)

  016e8	8d 4d d0	 lea	 ecx, DWORD PTR _rs$[ebp]
  016eb	e8 00 00 00 00	 call	 ?IsRectNull@CRect@@QBEHXZ ; CRect::IsRectNull
  016f0	85 c0		 test	 eax, eax
  016f2	75 22		 jne	 SHORT $L200550
  016f4	8d 4d d0	 lea	 ecx, DWORD PTR _rs$[ebp]
  016f7	e8 00 00 00 00	 call	 ?IsRectEmpty@CRect@@QBEHXZ ; CRect::IsRectEmpty
  016fc	85 c0		 test	 eax, eax
  016fe	75 16		 jne	 SHORT $L200550
  01700	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01703	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01709	51		 push	 ecx
  0170a	8d 4d d0	 lea	 ecx, DWORD PTR _rs$[ebp]
  0170d	e8 00 00 00 00	 call	 ??8CRect@@QBEHABUtagRECT@@@Z ; CRect::operator==
  01712	85 c0		 test	 eax, eax
  01714	74 05		 je	 SHORT $L200548
$L200550:

; 381  : 			return;

  01716	e9 55 01 00 00	 jmp	 $L200546
$L200548:

; 382  : 	}
; 383  : 
; 384  : 	m_rect = rs;

  0171b	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0171e	81 c2 8c 00 00
	00		 add	 edx, 140		; 0000008cH
  01724	8b 45 d0	 mov	 eax, DWORD PTR _rs$[ebp]
  01727	89 02		 mov	 DWORD PTR [edx], eax
  01729	8b 4d d4	 mov	 ecx, DWORD PTR _rs$[ebp+4]
  0172c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0172f	8b 45 d8	 mov	 eax, DWORD PTR _rs$[ebp+8]
  01732	89 42 08	 mov	 DWORD PTR [edx+8], eax
  01735	8b 4d dc	 mov	 ecx, DWORD PTR _rs$[ebp+12]
  01738	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 385  : 	CClientDC dc(this);

  0173b	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0173e	52		 push	 edx
  0173f	8d 4d e0	 lea	 ecx, DWORD PTR _dc$[ebp]
  01742	e8 00 00 00 00	 call	 ??0CClientDC@@QAE@PAVCWnd@@@Z ; CClientDC::CClientDC
  01747	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 386  : 	CSize sz = CSize(m_rect.Width(),m_rect.Height());

  0174e	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01751	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01757	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0175c	50		 push	 eax
  0175d	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01760	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01766	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  0176b	50		 push	 eax
  0176c	8d 4d c8	 lea	 ecx, DWORD PTR _sz$[ebp]
  0176f	e8 00 00 00 00	 call	 ??0CSize@@QAE@HH@Z	; CSize::CSize

; 387  : 	if(m_pOldBitmap)

  01774	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  01777	83 78 78 00	 cmp	 DWORD PTR [eax+120], 0
  0177b	74 2b		 je	 SHORT $L200554

; 388  : 	{
; 389  : 		if(m_dcMem.GetSafeHdc())

  0177d	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01780	83 c1 60	 add	 ecx, 96			; 00000060H
  01783	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01788	85 c0		 test	 eax, eax
  0178a	74 12		 je	 SHORT $L200555

; 390  : 			m_dcMem.SelectObject(m_pOldBitmap);

  0178c	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0178f	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  01792	52		 push	 edx
  01793	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01796	83 c1 60	 add	 ecx, 96			; 00000060H
  01799	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z ; CDC::SelectObject
$L200555:

; 391  : 		m_pOldBitmap = NULL;

  0179e	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  017a1	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [eax+120], 0
$L200554:

; 392  : 	}
; 393  : 	if (m_bmpoldTracker)

  017a8	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  017ab	83 b9 18 01 00
	00 00		 cmp	 DWORD PTR [ecx+280], 0
  017b2	74 34		 je	 SHORT $L200556

; 394  : 	{
; 395  : 		if (m_dcTracker.GetSafeHdc())

  017b4	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  017b7	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  017bd	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  017c2	85 c0		 test	 eax, eax
  017c4	74 15		 je	 SHORT $L200557

; 396  : 			m_dcTracker.SelectObject(m_pOldBitmap);

  017c6	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  017c9	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  017cc	50		 push	 eax
  017cd	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  017d0	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  017d6	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z ; CDC::SelectObject
$L200557:

; 397  : 		m_bmpoldTracker = NULL;

  017db	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  017de	c7 81 18 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+280], 0
$L200556:

; 398  : 	}
; 399  : 	if(m_memBitmap.GetSafeHandle())

  017e8	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  017eb	83 c1 70	 add	 ecx, 112		; 00000070H
  017ee	e8 00 00 00 00	 call	 ?GetSafeHandle@CGdiObject@@QBEPAXXZ ; CGdiObject::GetSafeHandle
  017f3	85 c0		 test	 eax, eax
  017f5	74 0b		 je	 SHORT $L200558

; 400  : 		m_memBitmap.DeleteObject();

  017f7	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  017fa	83 c1 70	 add	 ecx, 112		; 00000070H
  017fd	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject
$L200558:

; 401  : 	if(m_memBitmap.CreateCompatibleBitmap(&dc,sz.cx,sz.cy))

  01802	8b 55 cc	 mov	 edx, DWORD PTR _sz$[ebp+4]
  01805	52		 push	 edx
  01806	8b 45 c8	 mov	 eax, DWORD PTR _sz$[ebp]
  01809	50		 push	 eax
  0180a	8d 4d e0	 lea	 ecx, DWORD PTR _dc$[ebp]
  0180d	51		 push	 ecx
  0180e	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01811	83 c1 70	 add	 ecx, 112		; 00000070H
  01814	e8 00 00 00 00	 call	 ?CreateCompatibleBitmap@CBitmap@@QAEHPAVCDC@@HH@Z ; CBitmap::CreateCompatibleBitmap
  01819	85 c0		 test	 eax, eax
  0181b	74 18		 je	 SHORT $L200559

; 402  : 		m_pOldBitmap = m_dcMem.SelectObject(&m_memBitmap);

  0181d	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  01820	83 c2 70	 add	 edx, 112		; 00000070H
  01823	52		 push	 edx
  01824	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01827	83 c1 60	 add	 ecx, 96			; 00000060H
  0182a	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z ; CDC::SelectObject
  0182f	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01832	89 41 78	 mov	 DWORD PTR [ecx+120], eax
$L200559:

; 403  : 	
; 404  : 	UpdateList();

  01835	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01838	e8 00 00 00 00	 call	 ?UpdateList@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UpdateList

; 405  : 	m_ptClientStart.x = 0;

  0183d	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  01840	c7 82 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+172], 0

; 406  : 	m_ptClientStart.y = 0;

  0184a	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0184d	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0

; 407  : 	OnMemoryDraw();

  01857	6a 01		 push	 1
  01859	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0185c	e8 00 00 00 00	 call	 ?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::OnMemoryDraw

; 408  : }

  01861	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01868	8d 4d e0	 lea	 ecx, DWORD PTR _dc$[ebp]
  0186b	e8 00 00 00 00	 call	 ??1CClientDC@@UAE@XZ	; CClientDC::~CClientDC
$L200546:
  01870	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01873	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0187a	8b e5		 mov	 esp, ebp
  0187c	5d		 pop	 ebp
  0187d	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L203214:
  0024d	8d 4d e0	 lea	 ecx, DWORD PTR _dc$[ebp]
  00250	e9 00 00 00 00	 jmp	 ??1CClientDC@@UAE@XZ	; CClientDC::~CClientDC
__ehhandler$?SizeChanged@CLocalMusicCoverList@@IAEXH@Z:
  00255	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203216
  0025a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SizeChanged@CLocalMusicCoverList@@IAEXH@Z ENDP		; CLocalMusicCoverList::SizeChanged
EXTRN	_CoolSB_GetScrollPos@8:NEAR
EXTRN	_CoolSB_SetScrollInfo@16:NEAR
EXTRN	_CoolSB_ShowScrollBar@12:NEAR
EXTRN	?FillSolidRect@CDC@@QAEXHHHHK@Z:NEAR		; CDC::FillSolidRect
xdata$x	SEGMENT
$T203228 DD	0ffffffffH
	DD	FLAT:$L203224
$T203226 DD	019930520H
	DD	01H
	DD	FLAT:$T203228
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv215 = -108						; size = 4
tv139 = -104						; size = 4
_this$ = -100						; size = 4
_iCount$ = -96						; size = 4
_iLine$ = -92						; size = 4
_si$ = -88						; size = 28
_rs$ = -60						; size = 16
_iHeightSpace$ = -44					; size = 4
_iPos$ = -40						; size = 4
_iW$ = -36						; size = 4
_dc$ = -32						; size = 20
__$EHRec$ = -12						; size = 12
?UpdateList@CLocalMusicCoverList@@IAEXXZ PROC NEAR	; CLocalMusicCoverList::UpdateList
; _this$ = ecx

; 411  : {

  01880	55		 push	 ebp
  01881	8b ec		 mov	 ebp, esp
  01883	6a ff		 push	 -1
  01885	68 00 00 00 00	 push	 __ehhandler$?UpdateList@CLocalMusicCoverList@@IAEXXZ
  0188a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01890	50		 push	 eax
  01891	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01898	83 ec 60	 sub	 esp, 96			; 00000060H
  0189b	89 4d 9c	 mov	 DWORD PTR _this$[ebp], ecx

; 412  : 	m_ptClientStart.SetPoint(0,0);

  0189e	6a 00		 push	 0
  018a0	6a 00		 push	 0
  018a2	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  018a5	81 c1 ac 00 00
	00		 add	 ecx, 172		; 000000acH
  018ab	e8 00 00 00 00	 call	 ?SetPoint@CPoint@@QAEXHH@Z ; CPoint::SetPoint

; 413  : 	CRect rs;

  018b0	8d 4d c4	 lea	 ecx, DWORD PTR _rs$[ebp]
  018b3	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 414  : 	GetClientRect(&rs);

  018b8	8d 45 c4	 lea	 eax, DWORD PTR _rs$[ebp]
  018bb	50		 push	 eax
  018bc	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  018bf	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 415  : 	if (rs.IsRectNull() || rs.IsRectEmpty()) return;

  018c4	8d 4d c4	 lea	 ecx, DWORD PTR _rs$[ebp]
  018c7	e8 00 00 00 00	 call	 ?IsRectNull@CRect@@QBEHXZ ; CRect::IsRectNull
  018cc	85 c0		 test	 eax, eax
  018ce	75 0c		 jne	 SHORT $L200565
  018d0	8d 4d c4	 lea	 ecx, DWORD PTR _rs$[ebp]
  018d3	e8 00 00 00 00	 call	 ?IsRectEmpty@CRect@@QBEHXZ ; CRect::IsRectEmpty
  018d8	85 c0		 test	 eax, eax
  018da	74 05		 je	 SHORT $L200564
$L200565:
  018dc	e9 34 02 00 00	 jmp	 $L200562
$L200564:

; 416  : 	CClientDC dc(this);

  018e1	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  018e4	51		 push	 ecx
  018e5	8d 4d e0	 lea	 ecx, DWORD PTR _dc$[ebp]
  018e8	e8 00 00 00 00	 call	 ??0CClientDC@@QAE@PAVCWnd@@@Z ; CClientDC::CClientDC
  018ed	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 417  : 	if (m_bmpTracker.GetSafeHandle())

  018f4	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  018f7	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  018fd	e8 00 00 00 00	 call	 ?GetSafeHandle@CGdiObject@@QBEPAXXZ ; CGdiObject::GetSafeHandle
  01902	85 c0		 test	 eax, eax
  01904	74 0e		 je	 SHORT $L200567

; 418  : 		m_bmpTracker.DeleteObject();

  01906	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01909	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  0190f	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject
$L200567:

; 419  : 	int iHeightSpace=0;

  01914	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iHeightSpace$[ebp], 0

; 420  : 	if (m_ImgState==LMCI_Small)

  0191b	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  0191e	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  01922	75 0e		 jne	 SHORT $L200569

; 421  : 		iHeightSpace = m_iItemHeight+SPACEH + ITEMTXTH + SPACEH;

  01924	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  01927	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  0192a	83 c1 17	 add	 ecx, 23			; 00000017H
  0192d	89 4d d4	 mov	 DWORD PTR _iHeightSpace$[ebp], ecx

; 422  : 	else

  01930	eb 0c		 jmp	 SHORT $L200570
$L200569:

; 423  : 		iHeightSpace = m_iItemHeight+SPACEH + ITEMTXTH + SPACEH + ITEMTXTH + SPACEH*3;

  01932	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  01935	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  01938	83 c0 32	 add	 eax, 50			; 00000032H
  0193b	89 45 d4	 mov	 DWORD PTR _iHeightSpace$[ebp], eax
$L200570:

; 424  : 	int iW=0;

  0193e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iW$[ebp], 0

; 425  : 	m_ImgState==LMCI_Small?iW = m_iItemWidth+SPACEWS:iW = m_iItemWidth+SPACEW;

  01945	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01948	83 79 5c 00	 cmp	 DWORD PTR [ecx+92], 0
  0194c	75 14		 jne	 SHORT $L203220
  0194e	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  01951	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  01954	83 c0 0a	 add	 eax, 10			; 0000000aH
  01957	89 45 dc	 mov	 DWORD PTR _iW$[ebp], eax
  0195a	8b 4d dc	 mov	 ecx, DWORD PTR _iW$[ebp]
  0195d	89 4d 98	 mov	 DWORD PTR tv139[ebp], ecx
  01960	eb 12		 jmp	 SHORT $L203221
$L203220:
  01962	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  01965	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  01968	83 c0 10	 add	 eax, 16			; 00000010H
  0196b	89 45 dc	 mov	 DWORD PTR _iW$[ebp], eax
  0196e	8b 4d dc	 mov	 ecx, DWORD PTR _iW$[ebp]
  01971	89 4d 98	 mov	 DWORD PTR tv139[ebp], ecx
$L203221:

; 426  : 	
; 427  : 	int iCount = m_rect.Width()/iW;

  01974	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01977	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0197d	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  01982	99		 cdq
  01983	f7 7d dc	 idiv	 DWORD PTR _iW$[ebp]
  01986	89 45 a0	 mov	 DWORD PTR _iCount$[ebp], eax

; 428  : 	int iLine = m_DataMgr.m_vItem.size()/iCount;

  01989	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0198c	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  01992	e8 00 00 00 00	 call	 ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
  01997	33 d2		 xor	 edx, edx
  01999	f7 75 a0	 div	 DWORD PTR _iCount$[ebp]
  0199c	89 45 a4	 mov	 DWORD PTR _iLine$[ebp], eax

; 429  : 	if (m_DataMgr.m_vItem.size()%iCount)

  0199f	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  019a2	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  019a8	e8 00 00 00 00	 call	 ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
  019ad	33 d2		 xor	 edx, edx
  019af	f7 75 a0	 div	 DWORD PTR _iCount$[ebp]
  019b2	85 d2		 test	 edx, edx
  019b4	74 09		 je	 SHORT $L200574

; 430  : 		iLine++;

  019b6	8b 55 a4	 mov	 edx, DWORD PTR _iLine$[ebp]
  019b9	83 c2 01	 add	 edx, 1
  019bc	89 55 a4	 mov	 DWORD PTR _iLine$[ebp], edx
$L200574:

; 431  : 	m_rcRealRect.bottom = iLine* iHeightSpace;

  019bf	8b 45 a4	 mov	 eax, DWORD PTR _iLine$[ebp]
  019c2	0f af 45 d4	 imul	 eax, DWORD PTR _iHeightSpace$[ebp]
  019c6	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  019c9	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax

; 432  : 	m_rcRealRect.right = m_rect.right;

  019cf	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  019d2	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  019d5	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  019db	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx

; 433  : 
; 434  : 	if (m_bmpTracker.CreateCompatibleBitmap(&dc,m_rect.Width(),m_rect.Height()))

  019e1	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  019e4	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  019ea	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  019ef	50		 push	 eax
  019f0	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  019f3	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  019f9	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  019fe	50		 push	 eax
  019ff	8d 55 e0	 lea	 edx, DWORD PTR _dc$[ebp]
  01a02	52		 push	 edx
  01a03	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01a06	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  01a0c	e8 00 00 00 00	 call	 ?CreateCompatibleBitmap@CBitmap@@QAEHPAVCDC@@HH@Z ; CBitmap::CreateCompatibleBitmap
  01a11	85 c0		 test	 eax, eax
  01a13	74 55		 je	 SHORT $L200575

; 435  :  	{
; 436  :  		m_bmpoldTracker = m_dcTracker.SelectObject(&m_bmpTracker);

  01a15	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  01a18	05 10 01 00 00	 add	 eax, 272		; 00000110H
  01a1d	50		 push	 eax
  01a1e	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01a21	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  01a27	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z ; CDC::SelectObject
  01a2c	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01a2f	89 81 18 01 00
	00		 mov	 DWORD PTR [ecx+280], eax

; 437  :  		//m_dcTracker.FillSolidRect(0,0,m_rcRealRect.Width(),m_rcRealRect.Height(),RGB(180,180,180));
; 438  : 		m_dcTracker.FillSolidRect(0,0,m_rect.Width(),m_rect.Height(),RGB(180,180,180));

  01a35	68 b4 b4 b4 00	 push	 11842740		; 00b4b4b4H
  01a3a	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01a3d	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01a43	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01a48	50		 push	 eax
  01a49	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01a4c	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01a52	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  01a57	50		 push	 eax
  01a58	6a 00		 push	 0
  01a5a	6a 00		 push	 0
  01a5c	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01a5f	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  01a65	e8 00 00 00 00	 call	 ?FillSolidRect@CDC@@QAEXHHHHK@Z ; CDC::FillSolidRect
$L200575:

; 439  :  	}
; 440  : 
; 441  : 	SCROLLINFO si;
; 442  : 	si.cbSize	= sizeof(si);

  01a6a	c7 45 a8 1c 00
	00 00		 mov	 DWORD PTR _si$[ebp], 28	; 0000001cH

; 443  : 	si.fMask	= SIF_PAGE | SIF_POS | SIF_RANGE | SIF_DISABLENOSCROLL;

  01a71	c7 45 ac 0f 00
	00 00		 mov	 DWORD PTR _si$[ebp+4], 15 ; 0000000fH

; 444  : 	si.nMin		= 0;

  01a78	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _si$[ebp+8], 0

; 445  : 	si.nMax		= m_rcRealRect.Height();

  01a7f	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01a82	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  01a88	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01a8d	89 45 b4	 mov	 DWORD PTR _si$[ebp+12], eax

; 446  : 	si.nPos		= 0;

  01a90	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _si$[ebp+20], 0

; 447  : 	si.nPage	= rs.Height();

  01a97	8d 4d c4	 lea	 ecx, DWORD PTR _rs$[ebp]
  01a9a	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01a9f	89 45 b8	 mov	 DWORD PTR _si$[ebp+16], eax

; 448  : 	si.nMax<m_rect.Height()?CoolSB_ShowScrollBar(m_hWnd,SB_VERT,FALSE):CoolSB_SetScrollInfo (m_hWnd, SB_VERT, &si, TRUE);

  01aa2	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01aa5	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01aab	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01ab0	39 45 b4	 cmp	 DWORD PTR _si$[ebp+12], eax
  01ab3	7d 15		 jge	 SHORT $L203222
  01ab5	6a 00		 push	 0
  01ab7	6a 01		 push	 1
  01ab9	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  01abc	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01abf	50		 push	 eax
  01ac0	e8 00 00 00 00	 call	 _CoolSB_ShowScrollBar@12
  01ac5	89 45 94	 mov	 DWORD PTR tv215[ebp], eax
  01ac8	eb 17		 jmp	 SHORT $L203223
$L203222:
  01aca	6a 01		 push	 1
  01acc	8d 4d a8	 lea	 ecx, DWORD PTR _si$[ebp]
  01acf	51		 push	 ecx
  01ad0	6a 01		 push	 1
  01ad2	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  01ad5	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01ad8	50		 push	 eax
  01ad9	e8 00 00 00 00	 call	 _CoolSB_SetScrollInfo@16
  01ade	89 45 94	 mov	 DWORD PTR tv215[ebp], eax
$L203223:

; 449  : 	//CoolSB_SetScrollRange(m_hWnd,SB_VERT,0,m_rcRealRect.Height(),TRUE);
; 450  : 	// 
; 451  : 	int iPos = CoolSB_GetScrollPos(m_hWnd,SB_VERT);

  01ae1	6a 01		 push	 1
  01ae3	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01ae6	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  01ae9	52		 push	 edx
  01aea	e8 00 00 00 00	 call	 _CoolSB_GetScrollPos@8
  01aef	89 45 d8	 mov	 DWORD PTR _iPos$[ebp], eax

; 452  : 	CoolSB_SetScrollPos(m_hWnd,SB_VERT,iPos,TRUE);

  01af2	6a 01		 push	 1
  01af4	8b 45 d8	 mov	 eax, DWORD PTR _iPos$[ebp]
  01af7	50		 push	 eax
  01af8	6a 01		 push	 1
  01afa	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  01afd	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  01b00	52		 push	 edx
  01b01	e8 00 00 00 00	 call	 _CoolSB_SetScrollPos@16

; 453  : }

  01b06	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01b0d	8d 4d e0	 lea	 ecx, DWORD PTR _dc$[ebp]
  01b10	e8 00 00 00 00	 call	 ??1CClientDC@@UAE@XZ	; CClientDC::~CClientDC
$L200562:
  01b15	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01b18	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01b1f	8b e5		 mov	 esp, ebp
  01b21	5d		 pop	 ebp
  01b22	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L203224:
  0025f	8d 4d e0	 lea	 ecx, DWORD PTR _dc$[ebp]
  00262	e9 00 00 00 00	 jmp	 ??1CClientDC@@UAE@XZ	; CClientDC::~CClientDC
__ehhandler$?UpdateList@CLocalMusicCoverList@@IAEXXZ:
  00267	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203226
  0026c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?UpdateList@CLocalMusicCoverList@@IAEXXZ ENDP		; CLocalMusicCoverList::UpdateList
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_h$ = -8						; size = 4
_w$ = -4						; size = 4
_pBitmapVert$ = 8					; size = 4
_pBitmapHorz$ = 12					; size = 4
?SetScrollBitmap@CLocalMusicCoverList@@QAEXPAVCDibBitmap@@0@Z PROC NEAR ; CLocalMusicCoverList::SetScrollBitmap
; _this$ = ecx

; 456  : {

  01b30	55		 push	 ebp
  01b31	8b ec		 mov	 ebp, esp
  01b33	83 ec 0c	 sub	 esp, 12			; 0000000cH
  01b36	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 457  : 	m_pBitmapScrollHorz = pBitmapHorz;

  01b39	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01b3c	8b 4d 0c	 mov	 ecx, DWORD PTR _pBitmapHorz$[ebp]
  01b3f	89 88 54 01 00
	00		 mov	 DWORD PTR [eax+340], ecx

; 458  : 	m_pBitmapScrollVert = pBitmapVert;

  01b45	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01b48	8b 45 08	 mov	 eax, DWORD PTR _pBitmapVert$[ebp]
  01b4b	89 82 50 01 00
	00		 mov	 DWORD PTR [edx+336], eax

; 459  : 
; 460  : 	int w,h;
; 461  : 	w = h = 15;

  01b51	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR _h$[ebp], 15	; 0000000fH
  01b58	8b 4d f8	 mov	 ecx, DWORD PTR _h$[ebp]
  01b5b	89 4d fc	 mov	 DWORD PTR _w$[ebp], ecx

; 462  : 	if( m_pBitmapScrollHorz && m_pBitmapScrollVert )

  01b5e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01b61	83 ba 54 01 00
	00 00		 cmp	 DWORD PTR [edx+340], 0
  01b68	74 3e		 je	 SHORT $L200591
  01b6a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01b6d	83 b8 50 01 00
	00 00		 cmp	 DWORD PTR [eax+336], 0
  01b74	74 32		 je	 SHORT $L200591

; 463  : 	{
; 464  : 		h = m_pBitmapScrollVert->GetHeight() / 3;

  01b76	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01b79	8b 89 50 01 00
	00		 mov	 ecx, DWORD PTR [ecx+336]
  01b7f	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  01b84	99		 cdq
  01b85	b9 03 00 00 00	 mov	 ecx, 3
  01b8a	f7 f9		 idiv	 ecx
  01b8c	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax

; 465  : 		w = m_pBitmapScrollVert->GetWidth() / 6;

  01b8f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01b92	8b 8a 50 01 00
	00		 mov	 ecx, DWORD PTR [edx+336]
  01b98	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  01b9d	99		 cdq
  01b9e	b9 06 00 00 00	 mov	 ecx, 6
  01ba3	f7 f9		 idiv	 ecx
  01ba5	89 45 fc	 mov	 DWORD PTR _w$[ebp], eax
$L200591:

; 466  : 	}
; 467  : 	CoolSB_SetSize(m_hWnd, SB_BOTH, h, w);

  01ba8	8b 55 fc	 mov	 edx, DWORD PTR _w$[ebp]
  01bab	52		 push	 edx
  01bac	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  01baf	50		 push	 eax
  01bb0	6a 03		 push	 3
  01bb2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01bb5	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  01bb8	52		 push	 edx
  01bb9	e8 00 00 00 00	 call	 _CoolSB_SetSize@16

; 468  : 	::CoolSB_SetMinThumbSize(m_hWnd, SB_BOTH, 8);

  01bbe	6a 08		 push	 8
  01bc0	6a 03		 push	 3
  01bc2	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01bc5	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  01bc8	51		 push	 ecx
  01bc9	e8 00 00 00 00	 call	 _CoolSB_SetMinThumbSize@12

; 469  : 
; 470  : }

  01bce	8b e5		 mov	 esp, ebp
  01bd0	5d		 pop	 ebp
  01bd1	c2 08 00	 ret	 8
?SetScrollBitmap@CLocalMusicCoverList@@QAEXPAVCDibBitmap@@0@Z ENDP ; CLocalMusicCoverList::SetScrollBitmap
_TEXT	ENDS
PUBLIC	?MakeRoundRect@CLocalMusicCoverList@@IAEPAVGraphicsPath@Gdiplus@@VPoint@3@0H@Z ; CLocalMusicCoverList::MakeRoundRect
PUBLIC	??0GraphicsPath@Gdiplus@@QAE@W4FillMode@1@@Z	; Gdiplus::GraphicsPath::GraphicsPath
PUBLIC	??1GraphicsPath@Gdiplus@@QAE@XZ			; Gdiplus::GraphicsPath::~GraphicsPath
PUBLIC	?Clone@GraphicsPath@Gdiplus@@QBEPAV12@XZ	; Gdiplus::GraphicsPath::Clone
PUBLIC	?AddLine@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHH@Z ; Gdiplus::GraphicsPath::AddLine
PUBLIC	?AddArc@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHHMM@Z ; Gdiplus::GraphicsPath::AddArc
xdata$x	SEGMENT
$T203244 DD	0ffffffffH
	DD	FLAT:$L203240
$T203242 DD	019930520H
	DD	01H
	DD	FLAT:$T203244
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv71 = -72						; size = 4
tv69 = -68						; size = 4
tv67 = -64						; size = 4
tv65 = -60						; size = 4
_this$ = -56						; size = 4
$T203239 = -52						; size = 4
_path$ = -48						; size = 4
_offsetX$ = -44						; size = 4
_top$ = -40						; size = 4
_right$ = -36						; size = 4
_left$ = -32						; size = 4
_offsetY$ = -28						; size = 4
_pt$ = -24						; size = 8
_bottom$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_topLeft$ = 8						; size = 8
_bottomRight$ = 16					; size = 8
_percentageRounded$ = 24				; size = 4
?MakeRoundRect@CLocalMusicCoverList@@IAEPAVGraphicsPath@Gdiplus@@VPoint@3@0H@Z PROC NEAR ; CLocalMusicCoverList::MakeRoundRect
; _this$ = ecx

; 473  : {

  01be0	55		 push	 ebp
  01be1	8b ec		 mov	 ebp, esp
  01be3	6a ff		 push	 -1
  01be5	68 00 00 00 00	 push	 __ehhandler$?MakeRoundRect@CLocalMusicCoverList@@IAEPAVGraphicsPath@Gdiplus@@VPoint@3@0H@Z
  01bea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01bf0	50		 push	 eax
  01bf1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01bf8	83 ec 3c	 sub	 esp, 60			; 0000003cH
  01bfb	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 474  : 	ASSERT (percentageRounded >= 1 && percentageRounded <= 100);
; 475  : 
; 476  : 	INT left  = min(topLeft.X, bottomRight.X);

  01bfe	8b 45 08	 mov	 eax, DWORD PTR _topLeft$[ebp]
  01c01	3b 45 10	 cmp	 eax, DWORD PTR _bottomRight$[ebp]
  01c04	7d 08		 jge	 SHORT $L203231
  01c06	8b 4d 08	 mov	 ecx, DWORD PTR _topLeft$[ebp]
  01c09	89 4d c4	 mov	 DWORD PTR tv65[ebp], ecx
  01c0c	eb 06		 jmp	 SHORT $L203232
$L203231:
  01c0e	8b 55 10	 mov	 edx, DWORD PTR _bottomRight$[ebp]
  01c11	89 55 c4	 mov	 DWORD PTR tv65[ebp], edx
$L203232:
  01c14	8b 45 c4	 mov	 eax, DWORD PTR tv65[ebp]
  01c17	89 45 e0	 mov	 DWORD PTR _left$[ebp], eax

; 477  : 	INT right = max(topLeft.X, bottomRight.X);

  01c1a	8b 4d 08	 mov	 ecx, DWORD PTR _topLeft$[ebp]
  01c1d	3b 4d 10	 cmp	 ecx, DWORD PTR _bottomRight$[ebp]
  01c20	7e 08		 jle	 SHORT $L203233
  01c22	8b 55 08	 mov	 edx, DWORD PTR _topLeft$[ebp]
  01c25	89 55 c0	 mov	 DWORD PTR tv67[ebp], edx
  01c28	eb 06		 jmp	 SHORT $L203234
$L203233:
  01c2a	8b 45 10	 mov	 eax, DWORD PTR _bottomRight$[ebp]
  01c2d	89 45 c0	 mov	 DWORD PTR tv67[ebp], eax
$L203234:
  01c30	8b 4d c0	 mov	 ecx, DWORD PTR tv67[ebp]
  01c33	89 4d dc	 mov	 DWORD PTR _right$[ebp], ecx

; 478  : 
; 479  : 	INT top    = min(topLeft.Y, bottomRight.Y);

  01c36	8b 55 0c	 mov	 edx, DWORD PTR _topLeft$[ebp+4]
  01c39	3b 55 14	 cmp	 edx, DWORD PTR _bottomRight$[ebp+4]
  01c3c	7d 08		 jge	 SHORT $L203235
  01c3e	8b 45 0c	 mov	 eax, DWORD PTR _topLeft$[ebp+4]
  01c41	89 45 bc	 mov	 DWORD PTR tv69[ebp], eax
  01c44	eb 06		 jmp	 SHORT $L203236
$L203235:
  01c46	8b 4d 14	 mov	 ecx, DWORD PTR _bottomRight$[ebp+4]
  01c49	89 4d bc	 mov	 DWORD PTR tv69[ebp], ecx
$L203236:
  01c4c	8b 55 bc	 mov	 edx, DWORD PTR tv69[ebp]
  01c4f	89 55 d8	 mov	 DWORD PTR _top$[ebp], edx

; 480  : 	INT bottom = max(topLeft.Y, bottomRight.Y);

  01c52	8b 45 0c	 mov	 eax, DWORD PTR _topLeft$[ebp+4]
  01c55	3b 45 14	 cmp	 eax, DWORD PTR _bottomRight$[ebp+4]
  01c58	7e 08		 jle	 SHORT $L203237
  01c5a	8b 4d 0c	 mov	 ecx, DWORD PTR _topLeft$[ebp+4]
  01c5d	89 4d b8	 mov	 DWORD PTR tv71[ebp], ecx
  01c60	eb 06		 jmp	 SHORT $L203238
$L203237:
  01c62	8b 55 14	 mov	 edx, DWORD PTR _bottomRight$[ebp+4]
  01c65	89 55 b8	 mov	 DWORD PTR tv71[ebp], edx
$L203238:
  01c68	8b 45 b8	 mov	 eax, DWORD PTR tv71[ebp]
  01c6b	89 45 f0	 mov	 DWORD PTR _bottom$[ebp], eax

; 481  : 
; 482  : 	INT offsetX = (right-left)*percentageRounded/100;  

  01c6e	8b 45 dc	 mov	 eax, DWORD PTR _right$[ebp]
  01c71	2b 45 e0	 sub	 eax, DWORD PTR _left$[ebp]
  01c74	0f af 45 18	 imul	 eax, DWORD PTR _percentageRounded$[ebp]
  01c78	99		 cdq
  01c79	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  01c7e	f7 f9		 idiv	 ecx
  01c80	89 45 d4	 mov	 DWORD PTR _offsetX$[ebp], eax

; 483  : 	INT offsetY = (bottom-top)*percentageRounded/100;

  01c83	8b 45 f0	 mov	 eax, DWORD PTR _bottom$[ebp]
  01c86	2b 45 d8	 sub	 eax, DWORD PTR _top$[ebp]
  01c89	0f af 45 18	 imul	 eax, DWORD PTR _percentageRounded$[ebp]
  01c8d	99		 cdq
  01c8e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  01c93	f7 f9		 idiv	 ecx
  01c95	89 45 e4	 mov	 DWORD PTR _offsetY$[ebp], eax

; 484  : 
; 485  : 	GraphicsPath pt;

  01c98	6a 00		 push	 0
  01c9a	8d 4d e8	 lea	 ecx, DWORD PTR _pt$[ebp]
  01c9d	e8 00 00 00 00	 call	 ??0GraphicsPath@Gdiplus@@QAE@W4FillMode@1@@Z ; Gdiplus::GraphicsPath::GraphicsPath
  01ca2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 486  : 	GraphicsPath * path = pt.Clone();

  01ca9	8d 4d e8	 lea	 ecx, DWORD PTR _pt$[ebp]
  01cac	e8 00 00 00 00	 call	 ?Clone@GraphicsPath@Gdiplus@@QBEPAV12@XZ ; Gdiplus::GraphicsPath::Clone
  01cb1	89 45 d0	 mov	 DWORD PTR _path$[ebp], eax

; 487  : 
; 488  : 	path->AddArc(right-offsetX, top, offsetX, offsetY, 270, 90);

  01cb4	68 00 00 b4 42	 push	 1119092736		; 42b40000H
  01cb9	68 00 00 87 43	 push	 1132920832		; 43870000H
  01cbe	8b 55 e4	 mov	 edx, DWORD PTR _offsetY$[ebp]
  01cc1	52		 push	 edx
  01cc2	8b 45 d4	 mov	 eax, DWORD PTR _offsetX$[ebp]
  01cc5	50		 push	 eax
  01cc6	8b 4d d8	 mov	 ecx, DWORD PTR _top$[ebp]
  01cc9	51		 push	 ecx
  01cca	8b 55 dc	 mov	 edx, DWORD PTR _right$[ebp]
  01ccd	2b 55 d4	 sub	 edx, DWORD PTR _offsetX$[ebp]
  01cd0	52		 push	 edx
  01cd1	8b 4d d0	 mov	 ecx, DWORD PTR _path$[ebp]
  01cd4	e8 00 00 00 00	 call	 ?AddArc@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHHMM@Z ; Gdiplus::GraphicsPath::AddArc

; 489  : 	path->AddArc(right-offsetX, bottom-offsetY, offsetX, offsetY, 0, 90);

  01cd9	68 00 00 b4 42	 push	 1119092736		; 42b40000H
  01cde	6a 00		 push	 0
  01ce0	8b 45 e4	 mov	 eax, DWORD PTR _offsetY$[ebp]
  01ce3	50		 push	 eax
  01ce4	8b 4d d4	 mov	 ecx, DWORD PTR _offsetX$[ebp]
  01ce7	51		 push	 ecx
  01ce8	8b 55 f0	 mov	 edx, DWORD PTR _bottom$[ebp]
  01ceb	2b 55 e4	 sub	 edx, DWORD PTR _offsetY$[ebp]
  01cee	52		 push	 edx
  01cef	8b 45 dc	 mov	 eax, DWORD PTR _right$[ebp]
  01cf2	2b 45 d4	 sub	 eax, DWORD PTR _offsetX$[ebp]
  01cf5	50		 push	 eax
  01cf6	8b 4d d0	 mov	 ecx, DWORD PTR _path$[ebp]
  01cf9	e8 00 00 00 00	 call	 ?AddArc@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHHMM@Z ; Gdiplus::GraphicsPath::AddArc

; 490  : 	path->AddArc(left, bottom - offsetY, offsetX, offsetY, 90, 90);

  01cfe	68 00 00 b4 42	 push	 1119092736		; 42b40000H
  01d03	68 00 00 b4 42	 push	 1119092736		; 42b40000H
  01d08	8b 4d e4	 mov	 ecx, DWORD PTR _offsetY$[ebp]
  01d0b	51		 push	 ecx
  01d0c	8b 55 d4	 mov	 edx, DWORD PTR _offsetX$[ebp]
  01d0f	52		 push	 edx
  01d10	8b 45 f0	 mov	 eax, DWORD PTR _bottom$[ebp]
  01d13	2b 45 e4	 sub	 eax, DWORD PTR _offsetY$[ebp]
  01d16	50		 push	 eax
  01d17	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  01d1a	51		 push	 ecx
  01d1b	8b 4d d0	 mov	 ecx, DWORD PTR _path$[ebp]
  01d1e	e8 00 00 00 00	 call	 ?AddArc@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHHMM@Z ; Gdiplus::GraphicsPath::AddArc

; 491  : 	path->AddArc(left, top, offsetX, offsetY, 180, 90);

  01d23	68 00 00 b4 42	 push	 1119092736		; 42b40000H
  01d28	68 00 00 34 43	 push	 1127481344		; 43340000H
  01d2d	8b 55 e4	 mov	 edx, DWORD PTR _offsetY$[ebp]
  01d30	52		 push	 edx
  01d31	8b 45 d4	 mov	 eax, DWORD PTR _offsetX$[ebp]
  01d34	50		 push	 eax
  01d35	8b 4d d8	 mov	 ecx, DWORD PTR _top$[ebp]
  01d38	51		 push	 ecx
  01d39	8b 55 e0	 mov	 edx, DWORD PTR _left$[ebp]
  01d3c	52		 push	 edx
  01d3d	8b 4d d0	 mov	 ecx, DWORD PTR _path$[ebp]
  01d40	e8 00 00 00 00	 call	 ?AddArc@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHHMM@Z ; Gdiplus::GraphicsPath::AddArc

; 492  : 
; 493  : 	path->AddLine(left + offsetX, top, right - offsetX/2, top);

  01d45	8b 45 d8	 mov	 eax, DWORD PTR _top$[ebp]
  01d48	50		 push	 eax
  01d49	8b 45 d4	 mov	 eax, DWORD PTR _offsetX$[ebp]
  01d4c	99		 cdq
  01d4d	2b c2		 sub	 eax, edx
  01d4f	d1 f8		 sar	 eax, 1
  01d51	8b 4d dc	 mov	 ecx, DWORD PTR _right$[ebp]
  01d54	2b c8		 sub	 ecx, eax
  01d56	51		 push	 ecx
  01d57	8b 55 d8	 mov	 edx, DWORD PTR _top$[ebp]
  01d5a	52		 push	 edx
  01d5b	8b 45 e0	 mov	 eax, DWORD PTR _left$[ebp]
  01d5e	03 45 d4	 add	 eax, DWORD PTR _offsetX$[ebp]
  01d61	50		 push	 eax
  01d62	8b 4d d0	 mov	 ecx, DWORD PTR _path$[ebp]
  01d65	e8 00 00 00 00	 call	 ?AddLine@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHH@Z ; Gdiplus::GraphicsPath::AddLine

; 494  : 
; 495  : 	return path;

  01d6a	8b 4d d0	 mov	 ecx, DWORD PTR _path$[ebp]
  01d6d	89 4d cc	 mov	 DWORD PTR $T203239[ebp], ecx
  01d70	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01d77	8d 4d e8	 lea	 ecx, DWORD PTR _pt$[ebp]
  01d7a	e8 00 00 00 00	 call	 ??1GraphicsPath@Gdiplus@@QAE@XZ ; Gdiplus::GraphicsPath::~GraphicsPath
  01d7f	8b 45 cc	 mov	 eax, DWORD PTR $T203239[ebp]

; 496  : }

  01d82	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01d85	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01d8c	8b e5		 mov	 esp, ebp
  01d8e	5d		 pop	 ebp
  01d8f	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
text$x	SEGMENT
$L203240:
  00271	8d 4d e8	 lea	 ecx, DWORD PTR _pt$[ebp]
  00274	e9 00 00 00 00	 jmp	 ??1GraphicsPath@Gdiplus@@QAE@XZ ; Gdiplus::GraphicsPath::~GraphicsPath
__ehhandler$?MakeRoundRect@CLocalMusicCoverList@@IAEPAVGraphicsPath@Gdiplus@@VPoint@3@0H@Z:
  00279	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203242
  0027e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?MakeRoundRect@CLocalMusicCoverList@@IAEPAVGraphicsPath@Gdiplus@@VPoint@3@0H@Z ENDP ; CLocalMusicCoverList::MakeRoundRect
PUBLIC	?UnSelectAll@CLocalMusicCoverList@@IAEXXZ	; CLocalMusicCoverList::UnSelectAll
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$200611 = -4						; size = 4
?UnSelectAll@CLocalMusicCoverList@@IAEXXZ PROC NEAR	; CLocalMusicCoverList::UnSelectAll
; _this$ = ecx

; 499  : {

  01da0	55		 push	 ebp
  01da1	8b ec		 mov	 ebp, esp
  01da3	83 ec 08	 sub	 esp, 8
  01da6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 500  : 	for(int i=0;i<m_DataMgr.m_vItem.size();i++)

  01da9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$200611[ebp], 0
  01db0	eb 09		 jmp	 SHORT $L200612
$L200613:
  01db2	8b 45 fc	 mov	 eax, DWORD PTR _i$200611[ebp]
  01db5	83 c0 01	 add	 eax, 1
  01db8	89 45 fc	 mov	 DWORD PTR _i$200611[ebp], eax
$L200612:
  01dbb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01dbe	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  01dc4	e8 00 00 00 00	 call	 ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
  01dc9	39 45 fc	 cmp	 DWORD PTR _i$200611[ebp], eax
  01dcc	73 1b		 jae	 SHORT $L200610

; 501  : 		m_DataMgr.m_vItem[i].blSel = FALSE;

  01dce	8b 4d fc	 mov	 ecx, DWORD PTR _i$200611[ebp]
  01dd1	51		 push	 ecx
  01dd2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01dd5	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  01ddb	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  01de0	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  01de7	eb c9		 jmp	 SHORT $L200613
$L200610:

; 502  : }

  01de9	8b e5		 mov	 esp, ebp
  01deb	5d		 pop	 ebp
  01dec	c3		 ret	 0
?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ENDP		; CLocalMusicCoverList::UnSelectAll
; Function compile flags: /Odt
_this$ = -8						; size = 4
_iSpaceforline$ = -4					; size = 4
_ptS$ = 8						; size = 8
_lmci$ = 16						; size = 4
?CalcHideItemRect@CLocalMusicCoverList@@IAEXVCPoint@@AAU_tagLMCItemInfo@@@Z PROC NEAR ; CLocalMusicCoverList::CalcHideItemRect
; _this$ = ecx

; 505  : {

  01df0	55		 push	 ebp
  01df1	8b ec		 mov	 ebp, esp
  01df3	83 ec 08	 sub	 esp, 8
  01df6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 506  : 	int iSpaceforline = 6;

  01df9	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR _iSpaceforline$[ebp], 6

; 507  : 	lmci.rc.left = ptS.x+iSpaceforline/2;

  01e00	8b 45 fc	 mov	 eax, DWORD PTR _iSpaceforline$[ebp]
  01e03	99		 cdq
  01e04	2b c2		 sub	 eax, edx
  01e06	d1 f8		 sar	 eax, 1
  01e08	03 45 08	 add	 eax, DWORD PTR _ptS$[ebp]
  01e0b	8b 4d 10	 mov	 ecx, DWORD PTR _lmci$[ebp]
  01e0e	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 508  : 	lmci.rc.top = ptS.y+iSpaceforline/2;

  01e11	8b 45 fc	 mov	 eax, DWORD PTR _iSpaceforline$[ebp]
  01e14	99		 cdq
  01e15	2b c2		 sub	 eax, edx
  01e17	d1 f8		 sar	 eax, 1
  01e19	03 45 0c	 add	 eax, DWORD PTR _ptS$[ebp+4]
  01e1c	8b 55 10	 mov	 edx, DWORD PTR _lmci$[ebp]
  01e1f	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 509  : 	lmci.rc.right = ptS.x+m_iItemWidth-iSpaceforline/2;

  01e22	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01e25	8b 4d 08	 mov	 ecx, DWORD PTR _ptS$[ebp]
  01e28	03 48 54	 add	 ecx, DWORD PTR [eax+84]
  01e2b	8b 45 fc	 mov	 eax, DWORD PTR _iSpaceforline$[ebp]
  01e2e	99		 cdq
  01e2f	2b c2		 sub	 eax, edx
  01e31	d1 f8		 sar	 eax, 1
  01e33	2b c8		 sub	 ecx, eax
  01e35	8b 55 10	 mov	 edx, DWORD PTR _lmci$[ebp]
  01e38	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 510  : 	lmci.rc.bottom = ptS.y+m_iItemHeight-iSpaceforline/2;

  01e3b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01e3e	8b 4d 0c	 mov	 ecx, DWORD PTR _ptS$[ebp+4]
  01e41	03 48 58	 add	 ecx, DWORD PTR [eax+88]
  01e44	8b 45 fc	 mov	 eax, DWORD PTR _iSpaceforline$[ebp]
  01e47	99		 cdq
  01e48	2b c2		 sub	 eax, edx
  01e4a	d1 f8		 sar	 eax, 1
  01e4c	2b c8		 sub	 ecx, eax
  01e4e	8b 55 10	 mov	 edx, DWORD PTR _lmci$[ebp]
  01e51	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 511  : }

  01e54	8b e5		 mov	 esp, ebp
  01e56	5d		 pop	 ebp
  01e57	c2 0c 00	 ret	 12			; 0000000cH
?CalcHideItemRect@CLocalMusicCoverList@@IAEXVCPoint@@AAU_tagLMCItemInfo@@@Z ENDP ; CLocalMusicCoverList::CalcHideItemRect
_TEXT	ENDS
PUBLIC	?GetCurrentFont@CDC@@QBEPAVCFont@@XZ		; CDC::GetCurrentFont
PUBLIC	?SetSmoothingMode@Graphics@Gdiplus@@QAE?AW4Status@2@W4SmoothingMode@2@@Z ; Gdiplus::Graphics::SetSmoothingMode
PUBLIC	?GetBkMode@CDC@@QBEHXZ				; CDC::GetBkMode
PUBLIC	?GetTextColor@CDC@@QBEKXZ			; CDC::GetTextColor
PUBLIC	??0Point@Gdiplus@@QAE@HH@Z			; Gdiplus::Point::Point
PUBLIC	?DrawPath@Graphics@Gdiplus@@QAE?AW4Status@2@PBVPen@2@PBVGraphicsPath@2@@Z ; Gdiplus::Graphics::DrawPath
PUBLIC	??0Rect@Gdiplus@@QAE@HHHH@Z			; Gdiplus::Rect::Rect
PUBLIC	??0Pen@Gdiplus@@QAE@ABVColor@1@M@Z		; Gdiplus::Pen::Pen
PUBLIC	??1Pen@Gdiplus@@QAE@XZ				; Gdiplus::Pen::~Pen
PUBLIC	?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@ABVRect@2@@Z ; Gdiplus::Graphics::DrawImage
PUBLIC	??0Color@Gdiplus@@QAE@XZ			; Gdiplus::Color::Color
PUBLIC	?DrawTextA@CDC@@QAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRECT@@I@Z ; CDC::DrawTextA
PUBLIC	?SetFromCOLORREF@Color@Gdiplus@@QAEXK@Z		; Gdiplus::Color::SetFromCOLORREF
PUBLIC	??BCGdiObject@@QBEPAXXZ				; CGdiObject::operator void *
PUBLIC	?SelectObject@CDC@@QAEPAXPAX@Z			; CDC::SelectObject
PUBLIC	??0Graphics@Gdiplus@@QAE@PAUHDC__@@@Z		; Gdiplus::Graphics::Graphics
PUBLIC	??1Graphics@Gdiplus@@QAE@XZ			; Gdiplus::Graphics::~Graphics
EXTRN	__imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADXZ:NEAR
EXTRN	?SetBkMode@CDC@@QAEHH@Z:NEAR			; CDC::SetBkMode
xdata$x	SEGMENT
$T203259 DD	0ffffffffH
	DD	FLAT:$L203252
	DD	00H
	DD	FLAT:$L203253
	DD	01H
	DD	FLAT:$L203254
	DD	02H
	DD	FLAT:$L203255
$T203257 DD	019930520H
	DD	04H
	DD	FLAT:$T203259
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv190 = -196						; size = 4
tv185 = -192						; size = 4
tv81 = -188						; size = 4
tv85 = -184						; size = 4
_this$ = -180						; size = 4
$T203251 = -176						; size = 4
$T203250 = -172						; size = 4
_rcdetailText$200656 = -168				; size = 16
_pPath$200644 = -152					; size = 4
_grpen$200643 = -148					; size = 8
_colPen$200642 = -140					; size = 4
_dis$200638 = -136					; size = 4
_ipy$200639 = -132					; size = 4
_graphics$200637 = -128					; size = 8
_col$200640 = -120					; size = 4
__lpa$ = -116						; size = 4
__acp$ = -112						; size = 4
_gc$ = -108						; size = 8
_rcImgDesRect$ = -100					; size = 16
_rcImgCover$ = -84					; size = 16
_rcText$ = -64						; size = 16
_iSpaceforline$ = -48					; size = 4
_pOldFont$ = -44					; size = 4
__convert$ = -40					; size = 4
_img$ = -36						; size = 16
_oldText$ = -20						; size = 4
_iBK$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ptS$ = 8						; size = 8
_lmci$ = 16						; size = 4
?DrawItem@CLocalMusicCoverList@@IAEXVCPoint@@AAU_tagLMCItemInfo@@@Z PROC NEAR ; CLocalMusicCoverList::DrawItem
; _this$ = ecx

; 514  : {

  01e60	55		 push	 ebp
  01e61	8b ec		 mov	 ebp, esp
  01e63	6a ff		 push	 -1
  01e65	68 00 00 00 00	 push	 __ehhandler$?DrawItem@CLocalMusicCoverList@@IAEXVCPoint@@AAU_tagLMCItemInfo@@@Z
  01e6a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01e70	50		 push	 eax
  01e71	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01e78	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  01e7e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 515  : 	int iSpaceforline = 6;

  01e84	c7 45 d0 06 00
	00 00		 mov	 DWORD PTR _iSpaceforline$[ebp], 6

; 516  : 	// 
; 517  : 	USES_CONVERSION;

  01e8b	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  01e90	89 45 90	 mov	 DWORD PTR __acp$[ebp], eax

; 518  : 	Image img(A2W(lmci.strImgPath.GetBuffer()));

  01e93	8b 4d 10	 mov	 ecx, DWORD PTR _lmci$[ebp]
  01e96	83 c1 30	 add	 ecx, 48			; 00000030H
  01e99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADXZ
  01e9f	89 45 8c	 mov	 DWORD PTR __lpa$[ebp], eax
  01ea2	83 7d 8c 00	 cmp	 DWORD PTR __lpa$[ebp], 0
  01ea6	75 0c		 jne	 SHORT $L203248
  01ea8	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv85[ebp], 0
  01eb2	eb 44		 jmp	 SHORT $L203249
$L203248:
  01eb4	8b 45 8c	 mov	 eax, DWORD PTR __lpa$[ebp]
  01eb7	50		 push	 eax
  01eb8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  01ebe	83 c0 01	 add	 eax, 1
  01ec1	89 45 d8	 mov	 DWORD PTR __convert$[ebp], eax
  01ec4	8b 45 d8	 mov	 eax, DWORD PTR __convert$[ebp]
  01ec7	d1 e0		 shl	 eax, 1
  01ec9	83 c0 03	 add	 eax, 3
  01ecc	83 e0 fc	 and	 eax, -4			; fffffffcH
  01ecf	e8 00 00 00 00	 call	 __alloca_probe
  01ed4	89 a5 44 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], esp
  01eda	8b 4d 90	 mov	 ecx, DWORD PTR __acp$[ebp]
  01edd	51		 push	 ecx
  01ede	8b 55 d8	 mov	 edx, DWORD PTR __convert$[ebp]
  01ee1	52		 push	 edx
  01ee2	8b 45 8c	 mov	 eax, DWORD PTR __lpa$[ebp]
  01ee5	50		 push	 eax
  01ee6	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR tv81[ebp]
  01eec	51		 push	 ecx
  01eed	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  01ef2	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
$L203249:
  01ef8	6a 00		 push	 0
  01efa	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv85[ebp]
  01f00	52		 push	 edx
  01f01	8d 4d dc	 lea	 ecx, DWORD PTR _img$[ebp]
  01f04	e8 00 00 00 00	 call	 ??0Image@Gdiplus@@QAE@PB_WH@Z ; Gdiplus::Image::Image
  01f09	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 519  : 	Graphics gc(m_dcMem.GetSafeHdc());

  01f10	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01f16	83 c1 60	 add	 ecx, 96			; 00000060H
  01f19	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01f1e	50		 push	 eax
  01f1f	8d 4d 94	 lea	 ecx, DWORD PTR _gc$[ebp]
  01f22	e8 00 00 00 00	 call	 ??0Graphics@Gdiplus@@QAE@PAUHDC__@@@Z ; Gdiplus::Graphics::Graphics
  01f27	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 520  : 	Rect rcImgDesRect(ptS.x, ptS.y,m_iItemWidth-3,m_iItemHeight-2);

  01f2b	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01f31	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  01f34	83 e9 02	 sub	 ecx, 2
  01f37	51		 push	 ecx
  01f38	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01f3e	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  01f41	83 e8 03	 sub	 eax, 3
  01f44	50		 push	 eax
  01f45	8b 4d 0c	 mov	 ecx, DWORD PTR _ptS$[ebp+4]
  01f48	51		 push	 ecx
  01f49	8b 55 08	 mov	 edx, DWORD PTR _ptS$[ebp]
  01f4c	52		 push	 edx
  01f4d	8d 4d 9c	 lea	 ecx, DWORD PTR _rcImgDesRect$[ebp]
  01f50	e8 00 00 00 00	 call	 ??0Rect@Gdiplus@@QAE@HHHH@Z ; Gdiplus::Rect::Rect

; 521  : 	Rect rcImgCover(rcImgDesRect.X+2,rcImgDesRect.Y+2,rcImgDesRect.Width-5,rcImgDesRect.Height-5);

  01f55	8b 45 a8	 mov	 eax, DWORD PTR _rcImgDesRect$[ebp+12]
  01f58	83 e8 05	 sub	 eax, 5
  01f5b	50		 push	 eax
  01f5c	8b 4d a4	 mov	 ecx, DWORD PTR _rcImgDesRect$[ebp+8]
  01f5f	83 e9 05	 sub	 ecx, 5
  01f62	51		 push	 ecx
  01f63	8b 55 a0	 mov	 edx, DWORD PTR _rcImgDesRect$[ebp+4]
  01f66	83 c2 02	 add	 edx, 2
  01f69	52		 push	 edx
  01f6a	8b 45 9c	 mov	 eax, DWORD PTR _rcImgDesRect$[ebp]
  01f6d	83 c0 02	 add	 eax, 2
  01f70	50		 push	 eax
  01f71	8d 4d ac	 lea	 ecx, DWORD PTR _rcImgCover$[ebp]
  01f74	e8 00 00 00 00	 call	 ??0Rect@Gdiplus@@QAE@HHHH@Z ; Gdiplus::Rect::Rect

; 522  : 	gc.DrawImage(&img, rcImgCover);

  01f79	8d 4d ac	 lea	 ecx, DWORD PTR _rcImgCover$[ebp]
  01f7c	51		 push	 ecx
  01f7d	8d 55 dc	 lea	 edx, DWORD PTR _img$[ebp]
  01f80	52		 push	 edx
  01f81	8d 4d 94	 lea	 ecx, DWORD PTR _gc$[ebp]
  01f84	e8 00 00 00 00	 call	 ?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@ABVRect@2@@Z ; Gdiplus::Graphics::DrawImage

; 523  : 	gc.DrawImage(pImageFrame, rcImgDesRect);

  01f89	8d 45 9c	 lea	 eax, DWORD PTR _rcImgDesRect$[ebp]
  01f8c	50		 push	 eax
  01f8d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01f93	8b 91 60 01 00
	00		 mov	 edx, DWORD PTR [ecx+352]
  01f99	52		 push	 edx
  01f9a	8d 4d 94	 lea	 ecx, DWORD PTR _gc$[ebp]
  01f9d	e8 00 00 00 00	 call	 ?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@ABVRect@2@@Z ; Gdiplus::Graphics::DrawImage

; 524  : 	// Item
; 525  : 	lmci.rc.left = ptS.x+iSpaceforline/2;

  01fa2	8b 45 d0	 mov	 eax, DWORD PTR _iSpaceforline$[ebp]
  01fa5	99		 cdq
  01fa6	2b c2		 sub	 eax, edx
  01fa8	d1 f8		 sar	 eax, 1
  01faa	03 45 08	 add	 eax, DWORD PTR _ptS$[ebp]
  01fad	8b 4d 10	 mov	 ecx, DWORD PTR _lmci$[ebp]
  01fb0	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 526  : 	lmci.rc.top = ptS.y+iSpaceforline/2;

  01fb3	8b 45 d0	 mov	 eax, DWORD PTR _iSpaceforline$[ebp]
  01fb6	99		 cdq
  01fb7	2b c2		 sub	 eax, edx
  01fb9	d1 f8		 sar	 eax, 1
  01fbb	03 45 0c	 add	 eax, DWORD PTR _ptS$[ebp+4]
  01fbe	8b 55 10	 mov	 edx, DWORD PTR _lmci$[ebp]
  01fc1	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 527  : 	lmci.rc.right = ptS.x+m_iItemWidth-iSpaceforline/2;

  01fc4	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01fca	8b 4d 08	 mov	 ecx, DWORD PTR _ptS$[ebp]
  01fcd	03 48 54	 add	 ecx, DWORD PTR [eax+84]
  01fd0	8b 45 d0	 mov	 eax, DWORD PTR _iSpaceforline$[ebp]
  01fd3	99		 cdq
  01fd4	2b c2		 sub	 eax, edx
  01fd6	d1 f8		 sar	 eax, 1
  01fd8	2b c8		 sub	 ecx, eax
  01fda	8b 55 10	 mov	 edx, DWORD PTR _lmci$[ebp]
  01fdd	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 528  : 	lmci.rc.bottom = ptS.y+m_iItemHeight-iSpaceforline/2;

  01fe0	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01fe6	8b 4d 0c	 mov	 ecx, DWORD PTR _ptS$[ebp+4]
  01fe9	03 48 58	 add	 ecx, DWORD PTR [eax+88]
  01fec	8b 45 d0	 mov	 eax, DWORD PTR _iSpaceforline$[ebp]
  01fef	99		 cdq
  01ff0	2b c2		 sub	 eax, edx
  01ff2	d1 f8		 sar	 eax, 1
  01ff4	2b c8		 sub	 ecx, eax
  01ff6	8b 55 10	 mov	 edx, DWORD PTR _lmci$[ebp]
  01ff9	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 529  : 	// 
; 530  : 	if (lmci.blSel)

  01ffc	8b 45 10	 mov	 eax, DWORD PTR _lmci$[ebp]
  01fff	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  02003	0f 84 3d 01 00
	00		 je	 $L200636

; 531  : 	{
; 532  : 		Graphics   graphics(m_dcMem.GetSafeHdc()); 

  02009	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0200f	83 c1 60	 add	 ecx, 96			; 00000060H
  02012	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  02017	50		 push	 eax
  02018	8d 4d 80	 lea	 ecx, DWORD PTR _graphics$200637[ebp]
  0201b	e8 00 00 00 00	 call	 ??0Graphics@Gdiplus@@QAE@PAUHDC__@@@Z ; Gdiplus::Graphics::Graphics
  02020	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 533  : 		graphics.SetSmoothingMode(SmoothingModeHighQuality );

  02024	6a 02		 push	 2
  02026	8d 4d 80	 lea	 ecx, DWORD PTR _graphics$200637[ebp]
  02029	e8 00 00 00 00	 call	 ?SetSmoothingMode@Graphics@Gdiplus@@QAE?AW4Status@2@W4SmoothingMode@2@@Z ; Gdiplus::Graphics::SetSmoothingMode

; 534  : 		int dis = 10;

  0202e	c7 85 78 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR _dis$200638[ebp], 10 ; 0000000aH

; 535  : 		int ipy=8;

  02038	c7 85 7c ff ff
	ff 08 00 00 00	 mov	 DWORD PTR _ipy$200639[ebp], 8

; 536  : 		//Pen grpen(Color(57,137,194),3);
; 537  : 		COLORREF col = AfxGetUIManager()->UIGetSkinMgr()->GetColor("PlayedGameFrameBorder");

  02042	e8 00 00 00 00	 call	 ?AfxGetUIManager@@YAPAVIUIManager@@XZ ; AfxGetUIManager
  02047	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv185[ebp], eax
  0204d	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv185[ebp]
  02053	8b 11		 mov	 edx, DWORD PTR [ecx]
  02055	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv185[ebp]
  0205b	ff 52 28	 call	 DWORD PTR [edx+40]
  0205e	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv190[ebp], eax
  02064	68 00 00 00 00	 push	 OFFSET FLAT:$SG200641
  02069	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv190[ebp]
  0206f	8b 10		 mov	 edx, DWORD PTR [eax]
  02071	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv190[ebp]
  02077	ff 52 08	 call	 DWORD PTR [edx+8]
  0207a	89 45 88	 mov	 DWORD PTR _col$200640[ebp], eax

; 538  : 		Color colPen;

  0207d	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _colPen$200642[ebp]
  02083	e8 00 00 00 00	 call	 ??0Color@Gdiplus@@QAE@XZ ; Gdiplus::Color::Color

; 539  : 		colPen.SetFromCOLORREF( col );

  02088	8b 45 88	 mov	 eax, DWORD PTR _col$200640[ebp]
  0208b	50		 push	 eax
  0208c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _colPen$200642[ebp]
  02092	e8 00 00 00 00	 call	 ?SetFromCOLORREF@Color@Gdiplus@@QAEXK@Z ; Gdiplus::Color::SetFromCOLORREF

; 540  : 		Pen grpen(colPen,3);

  02097	68 00 00 40 40	 push	 1077936128		; 40400000H
  0209c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _colPen$200642[ebp]
  020a2	51		 push	 ecx
  020a3	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _grpen$200643[ebp]
  020a9	e8 00 00 00 00	 call	 ??0Pen@Gdiplus@@QAE@ABVColor@1@M@Z ; Gdiplus::Pen::Pen
  020ae	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 541  : 		GraphicsPath * pPath = MakeRoundRect(Point(ptS.x+2,ptS.y+2),Point(ptS.x+m_iItemWidth-6, ptS.y+m_iItemHeight-5), 10);

  020b2	6a 0a		 push	 10			; 0000000aH
  020b4	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  020ba	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  020bd	8b 4d 0c	 mov	 ecx, DWORD PTR _ptS$[ebp+4]
  020c0	8d 54 01 fb	 lea	 edx, DWORD PTR [ecx+eax-5]
  020c4	83 ec 08	 sub	 esp, 8
  020c7	8b cc		 mov	 ecx, esp
  020c9	89 a5 54 ff ff
	ff		 mov	 DWORD PTR $T203250[ebp], esp
  020cf	52		 push	 edx
  020d0	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  020d6	8b 50 54	 mov	 edx, DWORD PTR [eax+84]
  020d9	8b 45 08	 mov	 eax, DWORD PTR _ptS$[ebp]
  020dc	8d 54 10 fa	 lea	 edx, DWORD PTR [eax+edx-6]
  020e0	52		 push	 edx
  020e1	e8 00 00 00 00	 call	 ??0Point@Gdiplus@@QAE@HH@Z ; Gdiplus::Point::Point
  020e6	8b 45 0c	 mov	 eax, DWORD PTR _ptS$[ebp+4]
  020e9	83 c0 02	 add	 eax, 2
  020ec	83 ec 08	 sub	 esp, 8
  020ef	8b cc		 mov	 ecx, esp
  020f1	89 a5 50 ff ff
	ff		 mov	 DWORD PTR $T203251[ebp], esp
  020f7	50		 push	 eax
  020f8	8b 55 08	 mov	 edx, DWORD PTR _ptS$[ebp]
  020fb	83 c2 02	 add	 edx, 2
  020fe	52		 push	 edx
  020ff	e8 00 00 00 00	 call	 ??0Point@Gdiplus@@QAE@HH@Z ; Gdiplus::Point::Point
  02104	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0210a	e8 00 00 00 00	 call	 ?MakeRoundRect@CLocalMusicCoverList@@IAEPAVGraphicsPath@Gdiplus@@VPoint@3@0H@Z ; CLocalMusicCoverList::MakeRoundRect
  0210f	89 85 68 ff ff
	ff		 mov	 DWORD PTR _pPath$200644[ebp], eax

; 542  : 		graphics.DrawPath(&grpen,pPath);

  02115	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _pPath$200644[ebp]
  0211b	50		 push	 eax
  0211c	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _grpen$200643[ebp]
  02122	51		 push	 ecx
  02123	8d 4d 80	 lea	 ecx, DWORD PTR _graphics$200637[ebp]
  02126	e8 00 00 00 00	 call	 ?DrawPath@Graphics@Gdiplus@@QAE?AW4Status@2@PBVPen@2@PBVGraphicsPath@2@@Z ; Gdiplus::Graphics::DrawPath

; 543  : 	}

  0212b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0212f	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _grpen$200643[ebp]
  02135	e8 00 00 00 00	 call	 ??1Pen@Gdiplus@@QAE@XZ	; Gdiplus::Pen::~Pen
  0213a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0213e	8d 4d 80	 lea	 ecx, DWORD PTR _graphics$200637[ebp]
  02141	e8 00 00 00 00	 call	 ??1Graphics@Gdiplus@@QAE@XZ ; Gdiplus::Graphics::~Graphics
$L200636:

; 544  : 	// 
; 545  : 	CFont *pOldFont = m_dcMem.GetCurrentFont();

  02146	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0214c	83 c1 60	 add	 ecx, 96			; 00000060H
  0214f	e8 00 00 00 00	 call	 ?GetCurrentFont@CDC@@QBEPAVCFont@@XZ ; CDC::GetCurrentFont
  02154	89 45 d4	 mov	 DWORD PTR _pOldFont$[ebp], eax

; 546  : 	COLORREF oldText = m_dcMem.GetTextColor();

  02157	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0215d	83 c1 60	 add	 ecx, 96			; 00000060H
  02160	e8 00 00 00 00	 call	 ?GetTextColor@CDC@@QBEKXZ ; CDC::GetTextColor
  02165	89 45 ec	 mov	 DWORD PTR _oldText$[ebp], eax

; 547  : 	int iBK = m_dcMem.GetBkMode();

  02168	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0216e	83 c1 60	 add	 ecx, 96			; 00000060H
  02171	e8 00 00 00 00	 call	 ?GetBkMode@CDC@@QBEHXZ	; CDC::GetBkMode
  02176	89 45 f0	 mov	 DWORD PTR _iBK$[ebp], eax

; 548  : 	m_dcMem.SelectObject(m_fName);

  02179	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0217f	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02182	e8 00 00 00 00	 call	 ??BCGdiObject@@QBEPAXXZ	; CGdiObject::operator void *
  02187	50		 push	 eax
  02188	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0218e	83 c1 60	 add	 ecx, 96			; 00000060H
  02191	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAXPAX@Z ; CDC::SelectObject

; 549  : 	m_dcMem.SetBkMode(TRANSPARENT);

  02196	6a 01		 push	 1
  02198	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0219e	83 c1 60	 add	 ecx, 96			; 00000060H
  021a1	e8 00 00 00 00	 call	 ?SetBkMode@CDC@@QAEHH@Z	; CDC::SetBkMode

; 550  : 	m_dcMem.SetTextColor(m_gdires.colName);

  021a6	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  021ac	8b 82 f0 00 00
	00		 mov	 eax, DWORD PTR [edx+240]
  021b2	50		 push	 eax
  021b3	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  021b9	83 c1 60	 add	 ecx, 96			; 00000060H
  021bc	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  021c2	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  021c5	ff 50 38	 call	 DWORD PTR [eax+56]

; 551  : 	CRect rcText;

  021c8	8d 4d c0	 lea	 ecx, DWORD PTR _rcText$[ebp]
  021cb	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 552  : 	rcText.left = ptS.x-10;

  021d0	8b 4d 08	 mov	 ecx, DWORD PTR _ptS$[ebp]
  021d3	83 e9 0a	 sub	 ecx, 10			; 0000000aH
  021d6	89 4d c0	 mov	 DWORD PTR _rcText$[ebp], ecx

; 553  : 	rcText.top = ptS.y+(m_iItemHeight-iSpaceforline/2)+SPACEH;

  021d9	8b 45 d0	 mov	 eax, DWORD PTR _iSpaceforline$[ebp]
  021dc	99		 cdq
  021dd	2b c2		 sub	 eax, edx
  021df	d1 f8		 sar	 eax, 1
  021e1	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  021e7	8b 4a 58	 mov	 ecx, DWORD PTR [edx+88]
  021ea	2b c8		 sub	 ecx, eax
  021ec	8b 55 0c	 mov	 edx, DWORD PTR _ptS$[ebp+4]
  021ef	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  021f3	89 45 c4	 mov	 DWORD PTR _rcText$[ebp+4], eax

; 554  : 	rcText.right = ptS.x+m_iItemWidth+10;

  021f6	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  021fc	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  021ff	8b 45 08	 mov	 eax, DWORD PTR _ptS$[ebp]
  02202	8d 4c 10 0a	 lea	 ecx, DWORD PTR [eax+edx+10]
  02206	89 4d c8	 mov	 DWORD PTR _rcText$[ebp+8], ecx

; 555  : 	rcText.bottom = rcText.top+ITEMTXTH;

  02209	8b 55 c4	 mov	 edx, DWORD PTR _rcText$[ebp+4]
  0220c	83 c2 0f	 add	 edx, 15			; 0000000fH
  0220f	89 55 cc	 mov	 DWORD PTR _rcText$[ebp+12], edx

; 556  : 	if (lmci.strItemName.GetBuffer())// err

  02212	8b 4d 10	 mov	 ecx, DWORD PTR _lmci$[ebp]
  02215	83 c1 28	 add	 ecx, 40			; 00000028H
  02218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADXZ
  0221e	85 c0		 test	 eax, eax
  02220	74 1e		 je	 SHORT $L200653

; 557  : 		m_dcMem.DrawText(lmci.strItemName,&rcText,DT_VCENTER|DT_CENTER|DT_END_ELLIPSIS);

  02222	68 05 80 00 00	 push	 32773			; 00008005H
  02227	8d 45 c0	 lea	 eax, DWORD PTR _rcText$[ebp]
  0222a	50		 push	 eax
  0222b	8b 4d 10	 mov	 ecx, DWORD PTR _lmci$[ebp]
  0222e	83 c1 28	 add	 ecx, 40			; 00000028H
  02231	51		 push	 ecx
  02232	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  02238	83 c1 60	 add	 ecx, 96			; 00000060H
  0223b	e8 00 00 00 00	 call	 ?DrawTextA@CDC@@QAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRECT@@I@Z ; CDC::DrawTextA
$L200653:

; 558  : 	if (m_ImgState==LMCI_Big||m_ImgState==LMCI_Middle)

  02240	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  02246	83 7a 5c 02	 cmp	 DWORD PTR [edx+92], 2
  0224a	74 10		 je	 SHORT $L200655
  0224c	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  02252	83 78 5c 01	 cmp	 DWORD PTR [eax+92], 1
  02256	0f 85 a5 00 00
	00		 jne	 $L200654
$L200655:

; 559  : 	{
; 560  : 		CRect rcdetailText;

  0225c	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _rcdetailText$200656[ebp]
  02262	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 561  : 		rcdetailText.left = ptS.x;

  02267	8b 4d 08	 mov	 ecx, DWORD PTR _ptS$[ebp]
  0226a	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _rcdetailText$200656[ebp], ecx

; 562  : 		rcdetailText.top = rcText.bottom+SPACEH;

  02270	8b 55 cc	 mov	 edx, DWORD PTR _rcText$[ebp+12]
  02273	83 c2 04	 add	 edx, 4
  02276	89 95 5c ff ff
	ff		 mov	 DWORD PTR _rcdetailText$200656[ebp+4], edx

; 563  : 		rcdetailText.right = ptS.x+m_iItemWidth;

  0227c	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  02282	8b 4d 08	 mov	 ecx, DWORD PTR _ptS$[ebp]
  02285	03 48 54	 add	 ecx, DWORD PTR [eax+84]
  02288	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _rcdetailText$200656[ebp+8], ecx

; 564  : 		rcdetailText.bottom = rcdetailText.top+ITEMDETAILTXTH;

  0228e	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _rcdetailText$200656[ebp+4]
  02294	83 c2 0d	 add	 edx, 13			; 0000000dH
  02297	89 95 64 ff ff
	ff		 mov	 DWORD PTR _rcdetailText$200656[ebp+12], edx

; 565  : 		m_dcMem.SelectObject(&m_fDeInfo);

  0229d	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  022a3	05 84 00 00 00	 add	 eax, 132		; 00000084H
  022a8	50		 push	 eax
  022a9	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  022af	83 c1 60	 add	 ecx, 96			; 00000060H
  022b2	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  022b8	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  022bb	ff 50 30	 call	 DWORD PTR [eax+48]

; 566  : 		m_dcMem.SetTextColor(m_gdires.colDetail);

  022be	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  022c4	8b 91 f4 00 00
	00		 mov	 edx, DWORD PTR [ecx+244]
  022ca	52		 push	 edx
  022cb	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  022d1	83 c1 60	 add	 ecx, 96			; 00000060H
  022d4	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  022da	8b 50 60	 mov	 edx, DWORD PTR [eax+96]
  022dd	ff 52 38	 call	 DWORD PTR [edx+56]

; 567  : 		m_dcMem.DrawText(lmci.strItemdDetailinfo,&rcdetailText,DT_VCENTER|DT_CENTER|DT_END_ELLIPSIS);

  022e0	68 05 80 00 00	 push	 32773			; 00008005H
  022e5	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _rcdetailText$200656[ebp]
  022eb	50		 push	 eax
  022ec	8b 4d 10	 mov	 ecx, DWORD PTR _lmci$[ebp]
  022ef	83 c1 2c	 add	 ecx, 44			; 0000002cH
  022f2	51		 push	 ecx
  022f3	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  022f9	83 c1 60	 add	 ecx, 96			; 00000060H
  022fc	e8 00 00 00 00	 call	 ?DrawTextA@CDC@@QAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRECT@@I@Z ; CDC::DrawTextA
$L200654:

; 568  : 	}
; 569  : 	m_dcMem.SelectObject(pOldFont);

  02301	8b 55 d4	 mov	 edx, DWORD PTR _pOldFont$[ebp]
  02304	52		 push	 edx
  02305	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0230b	83 c1 60	 add	 ecx, 96			; 00000060H
  0230e	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  02314	8b 50 60	 mov	 edx, DWORD PTR [eax+96]
  02317	ff 52 30	 call	 DWORD PTR [edx+48]

; 570  : 	m_dcMem.SetTextColor(oldText);

  0231a	8b 45 ec	 mov	 eax, DWORD PTR _oldText$[ebp]
  0231d	50		 push	 eax
  0231e	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  02324	83 c1 60	 add	 ecx, 96			; 00000060H
  02327	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0232d	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  02330	ff 50 38	 call	 DWORD PTR [eax+56]

; 571  : 	m_dcMem.SetBkMode(iBK);

  02333	8b 4d f0	 mov	 ecx, DWORD PTR _iBK$[ebp]
  02336	51		 push	 ecx
  02337	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0233d	83 c1 60	 add	 ecx, 96			; 00000060H
  02340	e8 00 00 00 00	 call	 ?SetBkMode@CDC@@QAEHH@Z	; CDC::SetBkMode

; 572  : }

  02345	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02349	8d 4d 94	 lea	 ecx, DWORD PTR _gc$[ebp]
  0234c	e8 00 00 00 00	 call	 ??1Graphics@Gdiplus@@QAE@XZ ; Gdiplus::Graphics::~Graphics
  02351	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02358	8d 4d dc	 lea	 ecx, DWORD PTR _img$[ebp]
  0235b	e8 00 00 00 00	 call	 ??1Image@Gdiplus@@UAE@XZ ; Gdiplus::Image::~Image
  02360	8d a5 3c ff ff
	ff		 lea	 esp, DWORD PTR [ebp-196]
  02366	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02369	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02370	8b e5		 mov	 esp, ebp
  02372	5d		 pop	 ebp
  02373	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L203252:
  00283	8d 4d dc	 lea	 ecx, DWORD PTR _img$[ebp]
  00286	e9 00 00 00 00	 jmp	 ??1Image@Gdiplus@@UAE@XZ ; Gdiplus::Image::~Image
$L203253:
  0028b	8d 4d 94	 lea	 ecx, DWORD PTR _gc$[ebp]
  0028e	e9 00 00 00 00	 jmp	 ??1Graphics@Gdiplus@@QAE@XZ ; Gdiplus::Graphics::~Graphics
$L203254:
  00293	8d 4d 80	 lea	 ecx, DWORD PTR _graphics$200637[ebp]
  00296	e9 00 00 00 00	 jmp	 ??1Graphics@Gdiplus@@QAE@XZ ; Gdiplus::Graphics::~Graphics
$L203255:
  0029b	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _grpen$200643[ebp]
  002a1	e9 00 00 00 00	 jmp	 ??1Pen@Gdiplus@@QAE@XZ	; Gdiplus::Pen::~Pen
__ehhandler$?DrawItem@CLocalMusicCoverList@@IAEXVCPoint@@AAU_tagLMCItemInfo@@@Z:
  002a6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203257
  002ab	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DrawItem@CLocalMusicCoverList@@IAEXVCPoint@@AAU_tagLMCItemInfo@@@Z ENDP ; CLocalMusicCoverList::DrawItem
PUBLIC	?MoveVWnd@CLocalMusicCoverList@@IAEXH@Z		; CLocalMusicCoverList::MoveVWnd
PUBLIC	?push_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXABVCPoint@@@Z ; std::deque<CPoint,std::allocator<CPoint> >::push_back
; Function compile flags: /Odt
_TEXT	SEGMENT
tv75 = -20						; size = 4
tv71 = -16						; size = 4
_this$ = -12						; size = 4
_pt$ = -8						; size = 8
_blIsup$ = 8						; size = 4
?MoveVWnd@CLocalMusicCoverList@@IAEXH@Z PROC NEAR	; CLocalMusicCoverList::MoveVWnd
; _this$ = ecx

; 575  : {

  02380	55		 push	 ebp
  02381	8b ec		 mov	 ebp, esp
  02383	83 ec 14	 sub	 esp, 20			; 00000014H
  02386	56		 push	 esi
  02387	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 576  : 	CPoint pt = m_ptClientStart;

  0238a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0238d	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  02393	8b 90 b0 00 00
	00		 mov	 edx, DWORD PTR [eax+176]
  02399	89 4d f8	 mov	 DWORD PTR _pt$[ebp], ecx
  0239c	89 55 fc	 mov	 DWORD PTR _pt$[ebp+4], edx

; 577  : 	if (m_blTracker)// Tracker

  0239f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  023a2	83 b8 64 01 00
	00 00		 cmp	 DWORD PTR [eax+356], 0
  023a9	74 28		 je	 SHORT $L200662

; 578  : 		blIsup?pt.y+=VSCROLLMAX:pt.y-=VSCROLLMAX;

  023ab	83 7d 08 00	 cmp	 DWORD PTR _blIsup$[ebp], 0
  023af	74 11		 je	 SHORT $L203261
  023b1	8b 4d fc	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  023b4	83 c1 64	 add	 ecx, 100		; 00000064H
  023b7	89 4d fc	 mov	 DWORD PTR _pt$[ebp+4], ecx
  023ba	8b 55 fc	 mov	 edx, DWORD PTR _pt$[ebp+4]
  023bd	89 55 f0	 mov	 DWORD PTR tv71[ebp], edx
  023c0	eb 0f		 jmp	 SHORT $L203262
$L203261:
  023c2	8b 45 fc	 mov	 eax, DWORD PTR _pt$[ebp+4]
  023c5	83 e8 64	 sub	 eax, 100		; 00000064H
  023c8	89 45 fc	 mov	 DWORD PTR _pt$[ebp+4], eax
  023cb	8b 4d fc	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  023ce	89 4d f0	 mov	 DWORD PTR tv71[ebp], ecx
$L203262:

; 579  : 	else

  023d1	eb 26		 jmp	 SHORT $L200663
$L200662:

; 580  : 		blIsup?pt.y+=VSCROLLMIN:pt.y-=VSCROLLMIN;

  023d3	83 7d 08 00	 cmp	 DWORD PTR _blIsup$[ebp], 0
  023d7	74 11		 je	 SHORT $L203263
  023d9	8b 55 fc	 mov	 edx, DWORD PTR _pt$[ebp+4]
  023dc	83 c2 28	 add	 edx, 40			; 00000028H
  023df	89 55 fc	 mov	 DWORD PTR _pt$[ebp+4], edx
  023e2	8b 45 fc	 mov	 eax, DWORD PTR _pt$[ebp+4]
  023e5	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  023e8	eb 0f		 jmp	 SHORT $L200663
$L203263:
  023ea	8b 4d fc	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  023ed	83 e9 28	 sub	 ecx, 40			; 00000028H
  023f0	89 4d fc	 mov	 DWORD PTR _pt$[ebp+4], ecx
  023f3	8b 55 fc	 mov	 edx, DWORD PTR _pt$[ebp+4]
  023f6	89 55 ec	 mov	 DWORD PTR tv75[ebp], edx
$L200663:

; 581  : 	
; 582  : 	if (pt.y>=m_rect.top)

  023f9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  023fc	8b 4d fc	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  023ff	3b 88 90 00 00
	00		 cmp	 ecx, DWORD PTR [eax+144]
  02405	7c 0e		 jl	 SHORT $L200664

; 583  : 	{
; 584  : 		pt.y=m_rect.top;

  02407	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0240a	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  02410	89 45 fc	 mov	 DWORD PTR _pt$[ebp+4], eax

; 585  : 	}
; 586  : 	else if(pt.y+m_rcRealRect.Height()<= m_rect.bottom)

  02413	eb 42		 jmp	 SHORT $L200665
$L200664:
  02415	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02418	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  0241e	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  02423	03 45 fc	 add	 eax, DWORD PTR _pt$[ebp+4]
  02426	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02429	3b 81 98 00 00
	00		 cmp	 eax, DWORD PTR [ecx+152]
  0242f	7f 26		 jg	 SHORT $L200665

; 587  : 	{
; 588  : 		pt.y = m_rect.Height() - m_rcRealRect.Height()-SPACEH;

  02431	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02434	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0243a	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0243f	8b f0		 mov	 esi, eax
  02441	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02444	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  0244a	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0244f	2b f0		 sub	 esi, eax
  02451	83 ee 04	 sub	 esi, 4
  02454	89 75 fc	 mov	 DWORD PTR _pt$[ebp+4], esi
$L200665:

; 589  : 	}
; 590  : 	m_csLockV.Lock();

  02457	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0245a	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  02460	e8 00 00 00 00	 call	 ?Lock@CCriticalSection@@QAEHXZ ; CCriticalSection::Lock

; 591  : 	m_vPtQueue.push_back(pt);

  02465	8d 55 f8	 lea	 edx, DWORD PTR _pt$[ebp]
  02468	52		 push	 edx
  02469	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0246c	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  02472	e8 00 00 00 00	 call	 ?push_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXABVCPoint@@@Z ; std::deque<CPoint,std::allocator<CPoint> >::push_back

; 592  : 	m_csLockV.Unlock();

  02477	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0247a	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  02480	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  02483	8b 90 b4 00 00
	00		 mov	 edx, DWORD PTR [eax+180]
  02489	ff 52 1c	 call	 DWORD PTR [edx+28]

; 593  : 	
; 594  : }

  0248c	5e		 pop	 esi
  0248d	8b e5		 mov	 esp, ebp
  0248f	5d		 pop	 ebp
  02490	c2 04 00	 ret	 4
?MoveVWnd@CLocalMusicCoverList@@IAEXH@Z ENDP		; CLocalMusicCoverList::MoveVWnd
; Function compile flags: /Odt
_this$ = -24						; size = 4
_rectInter$200674 = -20					; size = 16
_i$200670 = -4						; size = 4
?OnCalcSelectItem@CLocalMusicCoverList@@IAEXXZ PROC NEAR ; CLocalMusicCoverList::OnCalcSelectItem
; _this$ = ecx

; 597  : {

  024a0	55		 push	 ebp
  024a1	8b ec		 mov	 ebp, esp
  024a3	83 ec 18	 sub	 esp, 24			; 00000018H
  024a6	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 598  : 	for (int i=0;i<m_DataMgr.m_vItem.size();i++)

  024a9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$200670[ebp], 0
  024b0	eb 09		 jmp	 SHORT $L200671
$L200672:
  024b2	8b 45 fc	 mov	 eax, DWORD PTR _i$200670[ebp]
  024b5	83 c0 01	 add	 eax, 1
  024b8	89 45 fc	 mov	 DWORD PTR _i$200670[ebp], eax
$L200671:
  024bb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  024be	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  024c4	e8 00 00 00 00	 call	 ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
  024c9	39 45 fc	 cmp	 DWORD PTR _i$200670[ebp], eax
  024cc	73 6d		 jae	 SHORT $L200669

; 599  : 	{	
; 600  : 		CRect rectInter;

  024ce	8d 4d ec	 lea	 ecx, DWORD PTR _rectInter$200674[ebp]
  024d1	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 601  : 		if (rectInter.IntersectRect(&m_DataMgr.m_vItem[i].rc, &m_rcTracker))

  024d6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  024d9	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  024df	51		 push	 ecx
  024e0	8b 55 fc	 mov	 edx, DWORD PTR _i$200670[ebp]
  024e3	52		 push	 edx
  024e4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  024e7	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  024ed	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  024f2	83 c0 34	 add	 eax, 52			; 00000034H
  024f5	50		 push	 eax
  024f6	8d 4d ec	 lea	 ecx, DWORD PTR _rectInter$200674[ebp]
  024f9	e8 00 00 00 00	 call	 ?IntersectRect@CRect@@QAEHPBUtagRECT@@0@Z ; CRect::IntersectRect
  024fe	85 c0		 test	 eax, eax
  02500	74 1b		 je	 SHORT $L200675

; 602  : 			m_DataMgr.m_vItem[i].blSel = TRUE;

  02502	8b 45 fc	 mov	 eax, DWORD PTR _i$200670[ebp]
  02505	50		 push	 eax
  02506	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02509	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0250f	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  02514	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 603  : 		else 

  0251b	eb 19		 jmp	 SHORT $L200676
$L200675:

; 604  : 			m_DataMgr.m_vItem[i].blSel = FALSE;

  0251d	8b 4d fc	 mov	 ecx, DWORD PTR _i$200670[ebp]
  02520	51		 push	 ecx
  02521	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02524	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0252a	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  0252f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
$L200676:

; 605  : 	}

  02536	e9 77 ff ff ff	 jmp	 $L200672
$L200669:

; 606  : }

  0253b	8b e5		 mov	 esp, ebp
  0253d	5d		 pop	 ebp
  0253e	c3		 ret	 0
?OnCalcSelectItem@CLocalMusicCoverList@@IAEXXZ ENDP	; CLocalMusicCoverList::OnCalcSelectItem
_TEXT	ENDS
PUBLIC	?PtInRect@CRect@@QBEHUtagPOINT@@@Z		; CRect::PtInRect
PUBLIC	?HitTest@CLocalMusicCoverList@@IAEHAAHVCPoint@@@Z ; CLocalMusicCoverList::HitTest
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T203267 = -12						; size = 8
_i$200682 = -4						; size = 4
_itemIndex$ = 8						; size = 4
_pt$ = 12						; size = 8
?HitTest@CLocalMusicCoverList@@IAEHAAHVCPoint@@@Z PROC NEAR ; CLocalMusicCoverList::HitTest
; _this$ = ecx

; 609  : {

  02540	55		 push	 ebp
  02541	8b ec		 mov	 ebp, esp
  02543	83 ec 10	 sub	 esp, 16			; 00000010H
  02546	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 610  : 	for (int i=0;i<m_DataMgr.m_vItem.size();i++)

  02549	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$200682[ebp], 0
  02550	eb 09		 jmp	 SHORT $L200683
$L200684:
  02552	8b 45 fc	 mov	 eax, DWORD PTR _i$200682[ebp]
  02555	83 c0 01	 add	 eax, 1
  02558	89 45 fc	 mov	 DWORD PTR _i$200682[ebp], eax
$L200683:
  0255b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0255e	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  02564	e8 00 00 00 00	 call	 ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
  02569	39 45 fc	 cmp	 DWORD PTR _i$200682[ebp], eax
  0256c	73 57		 jae	 SHORT $L200685

; 611  : 	{
; 612  : 		if (m_DataMgr.m_vItem[i].rc.PtInRect(pt))

  0256e	8b 4d 0c	 mov	 ecx, DWORD PTR _pt$[ebp]
  02571	89 4d f4	 mov	 DWORD PTR $T203267[ebp], ecx
  02574	8b 55 10	 mov	 edx, DWORD PTR _pt$[ebp+4]
  02577	89 55 f8	 mov	 DWORD PTR $T203267[ebp+4], edx
  0257a	8b 45 f8	 mov	 eax, DWORD PTR $T203267[ebp+4]
  0257d	50		 push	 eax
  0257e	8b 4d f4	 mov	 ecx, DWORD PTR $T203267[ebp]
  02581	51		 push	 ecx
  02582	8b 55 fc	 mov	 edx, DWORD PTR _i$200682[ebp]
  02585	52		 push	 edx
  02586	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  02589	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0258f	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  02594	83 c0 34	 add	 eax, 52			; 00000034H
  02597	8b c8		 mov	 ecx, eax
  02599	e8 00 00 00 00	 call	 ?PtInRect@CRect@@QBEHUtagPOINT@@@Z ; CRect::PtInRect
  0259e	85 c0		 test	 eax, eax
  025a0	74 21		 je	 SHORT $L200687

; 613  : 		{
; 614  : 			itemIndex = m_DataMgr.m_vItem[i].iIndex;

  025a2	8b 45 fc	 mov	 eax, DWORD PTR _i$200682[ebp]
  025a5	50		 push	 eax
  025a6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  025a9	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  025af	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  025b4	8b 4d 08	 mov	 ecx, DWORD PTR _itemIndex$[ebp]
  025b7	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  025ba	89 11		 mov	 DWORD PTR [ecx], edx

; 615  : 			return TRUE;

  025bc	b8 01 00 00 00	 mov	 eax, 1
  025c1	eb 04		 jmp	 SHORT $L200681
$L200687:

; 616  : 		}
; 617  : 	}

  025c3	eb 8d		 jmp	 SHORT $L200684
$L200685:

; 618  : 	return FALSE;

  025c5	33 c0		 xor	 eax, eax
$L200681:

; 619  : }

  025c7	8b e5		 mov	 esp, ebp
  025c9	5d		 pop	 ebp
  025ca	c2 0c 00	 ret	 12			; 0000000cH
?HitTest@CLocalMusicCoverList@@IAEHAAHVCPoint@@@Z ENDP	; CLocalMusicCoverList::HitTest
_TEXT	ENDS
PUBLIC	?OnTimer@CWnd@@IAEXI@Z				; CWnd::OnTimer
PUBLIC	?size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ ; std::deque<CPoint,std::allocator<CPoint> >::size
PUBLIC	?front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEAAVCPoint@@XZ ; std::deque<CPoint,std::allocator<CPoint> >::front
PUBLIC	?pop_front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ ; std::deque<CPoint,std::allocator<CPoint> >::pop_front
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIDEvent$ = 8						; size = 4
?OnTimer@CLocalMusicCoverList@@QAEXI@Z PROC NEAR	; CLocalMusicCoverList::OnTimer
; _this$ = ecx

; 622  : {

  025d0	55		 push	 ebp
  025d1	8b ec		 mov	 ebp, esp
  025d3	51		 push	 ecx
  025d4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 623  : 	if (m_vScrollTimer == nIDEvent)

  025d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  025da	8b 88 e8 00 00
	00		 mov	 ecx, DWORD PTR [eax+232]
  025e0	3b 4d 08	 cmp	 ecx, DWORD PTR _nIDEvent$[ebp]
  025e3	75 6f		 jne	 SHORT $L200692

; 624  : 	{
; 625  : 		m_csLockV.Lock();

  025e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  025e8	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  025ee	e8 00 00 00 00	 call	 ?Lock@CCriticalSection@@QAEHXZ ; CCriticalSection::Lock

; 626  : 		if(m_vPtQueue.size()>0)

  025f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  025f6	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  025fc	e8 00 00 00 00	 call	 ?size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ ; std::deque<CPoint,std::allocator<CPoint> >::size
  02601	85 c0		 test	 eax, eax
  02603	76 3a		 jbe	 SHORT $L200693

; 627  : 		{
; 628  : 			m_ptClientStart = m_vPtQueue.front();

  02605	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02608	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  0260e	e8 00 00 00 00	 call	 ?front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEAAVCPoint@@XZ ; std::deque<CPoint,std::allocator<CPoint> >::front
  02613	8b 10		 mov	 edx, DWORD PTR [eax]
  02615	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  02618	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0261b	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx
  02621	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax

; 629  : 			m_vPtQueue.pop_front();

  02627	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0262a	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  02630	e8 00 00 00 00	 call	 ?pop_front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ ; std::deque<CPoint,std::allocator<CPoint> >::pop_front

; 630  : 			OnMemoryDraw();

  02635	6a 01		 push	 1
  02637	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0263a	e8 00 00 00 00	 call	 ?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::OnMemoryDraw
$L200693:

; 631  : 		}
; 632  : 		m_csLockV.Unlock();

  0263f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02642	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  02648	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0264b	8b 82 b4 00 00
	00		 mov	 eax, DWORD PTR [edx+180]
  02651	ff 50 1c	 call	 DWORD PTR [eax+28]
$L200692:

; 633  : 	}
; 634  : 	if (m_vScrDownTimer == nIDEvent)

  02654	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02657	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  0265d	3b 55 08	 cmp	 edx, DWORD PTR _nIDEvent$[ebp]
  02660	75 0a		 jne	 SHORT $L200694

; 635  : 	{
; 636  : 		MoveVWnd(FALSE);

  02662	6a 00		 push	 0
  02664	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02667	e8 00 00 00 00	 call	 ?MoveVWnd@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::MoveVWnd
$L200694:

; 637  : 	}
; 638  : 	if (m_vScrUpTimer == nIDEvent)

  0266c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0266f	8b 88 40 01 00
	00		 mov	 ecx, DWORD PTR [eax+320]
  02675	3b 4d 08	 cmp	 ecx, DWORD PTR _nIDEvent$[ebp]
  02678	75 0a		 jne	 SHORT $L200695

; 639  : 	{
; 640  : 		MoveVWnd(TRUE);

  0267a	6a 01		 push	 1
  0267c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0267f	e8 00 00 00 00	 call	 ?MoveVWnd@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::MoveVWnd
$L200695:

; 641  : 	}
; 642  : 
; 643  : 	CWnd::OnTimer(nIDEvent);

  02684	8b 55 08	 mov	 edx, DWORD PTR _nIDEvent$[ebp]
  02687	52		 push	 edx
  02688	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0268b	e8 00 00 00 00	 call	 ?OnTimer@CWnd@@IAEXI@Z	; CWnd::OnTimer

; 644  : }

  02690	8b e5		 mov	 esp, ebp
  02692	5d		 pop	 ebp
  02693	c2 04 00	 ret	 4
?OnTimer@CLocalMusicCoverList@@QAEXI@Z ENDP		; CLocalMusicCoverList::OnTimer
_TEXT	ENDS
PUBLIC	?OnMouseWheel@CWnd@@IAEHIFVCPoint@@@Z		; CWnd::OnMouseWheel
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nFlags$ = 8						; size = 4
_zDelta$ = 12						; size = 2
_pt$ = 16						; size = 8
?OnMouseWheel@CLocalMusicCoverList@@QAEHIFVCPoint@@@Z PROC NEAR ; CLocalMusicCoverList::OnMouseWheel
; _this$ = ecx

; 647  : {

  026a0	55		 push	 ebp
  026a1	8b ec		 mov	 ebp, esp
  026a3	51		 push	 ecx
  026a4	56		 push	 esi
  026a5	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 648  : 	if (m_rcRealRect.Height()>m_rect.Height())

  026a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  026ab	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  026b1	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  026b6	8b f0		 mov	 esi, eax
  026b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  026bb	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  026c1	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  026c6	3b f0		 cmp	 esi, eax
  026c8	7e 1e		 jle	 SHORT $L200702

; 649  : 	{
; 650  : 		if(zDelta<0)

  026ca	0f bf 45 0c	 movsx	 eax, WORD PTR _zDelta$[ebp]
  026ce	85 c0		 test	 eax, eax
  026d0	7d 0c		 jge	 SHORT $L200703

; 651  : 			MoveVWnd(FALSE);

  026d2	6a 00		 push	 0
  026d4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  026d7	e8 00 00 00 00	 call	 ?MoveVWnd@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::MoveVWnd

; 652  : 		else

  026dc	eb 0a		 jmp	 SHORT $L200702
$L200703:

; 653  : 			MoveVWnd(TRUE);

  026de	6a 01		 push	 1
  026e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  026e3	e8 00 00 00 00	 call	 ?MoveVWnd@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::MoveVWnd
$L200702:

; 654  : 	}
; 655  : 	
; 656  : 	return CWnd::OnMouseWheel(nFlags, zDelta, pt);

  026e8	8b 4d 14	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  026eb	51		 push	 ecx
  026ec	8b 55 10	 mov	 edx, DWORD PTR _pt$[ebp]
  026ef	52		 push	 edx
  026f0	66 8b 45 0c	 mov	 ax, WORD PTR _zDelta$[ebp]
  026f4	50		 push	 eax
  026f5	8b 4d 08	 mov	 ecx, DWORD PTR _nFlags$[ebp]
  026f8	51		 push	 ecx
  026f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  026fc	e8 00 00 00 00	 call	 ?OnMouseWheel@CWnd@@IAEHIFVCPoint@@@Z ; CWnd::OnMouseWheel

; 657  : }

  02701	5e		 pop	 esi
  02702	8b e5		 mov	 esp, ebp
  02704	5d		 pop	 ebp
  02705	c2 10 00	 ret	 16			; 00000010H
?OnMouseWheel@CLocalMusicCoverList@@QAEHIFVCPoint@@@Z ENDP ; CLocalMusicCoverList::OnMouseWheel
; Function compile flags: /Odt
_this$ = -12						; size = 4
_pt$ = -8						; size = 8
_wParam$ = 8						; size = 4
_lParam$ = 12						; size = 4
?OnTrackerChange@CLocalMusicCoverList@@QAEJIJ@Z PROC NEAR ; CLocalMusicCoverList::OnTrackerChange
; _this$ = ecx

; 660  : {

  02710	55		 push	 ebp
  02711	8b ec		 mov	 ebp, esp
  02713	83 ec 0c	 sub	 esp, 12			; 0000000cH
  02716	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 661  : 	CPoint pt;

  02719	8d 4d f8	 lea	 ecx, DWORD PTR _pt$[ebp]
  0271c	e8 00 00 00 00	 call	 ??0CPoint@@QAE@XZ	; CPoint::CPoint

; 662  : 	GetCursorPos(&pt);

  02721	8d 45 f8	 lea	 eax, DWORD PTR _pt$[ebp]
  02724	50		 push	 eax
  02725	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4

; 663  : 	ScreenToClient(&pt);

  0272b	8d 4d f8	 lea	 ecx, DWORD PTR _pt$[ebp]
  0272e	51		 push	 ecx
  0272f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02732	e8 00 00 00 00	 call	 ?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z ; CWnd::ScreenToClient

; 664  : 	if (pt.y>0 && pt.y<10)

  02737	83 7d fc 00	 cmp	 DWORD PTR _pt$[ebp+4], 0
  0273b	7e 12		 jle	 SHORT $L200711
  0273d	83 7d fc 0a	 cmp	 DWORD PTR _pt$[ebp+4], 10 ; 0000000aH
  02741	7d 0c		 jge	 SHORT $L200711

; 665  : 	{
; 666  : 		MoveVWnd(TRUE);

  02743	6a 01		 push	 1
  02745	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02748	e8 00 00 00 00	 call	 ?MoveVWnd@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::MoveVWnd

; 667  : 	}
; 668  : 	else if (pt.y>m_rect.bottom-10 && pt.y<m_rect.bottom)

  0274d	eb 29		 jmp	 SHORT $L200712
$L200711:
  0274f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  02752	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  02758	83 e8 0a	 sub	 eax, 10			; 0000000aH
  0275b	39 45 fc	 cmp	 DWORD PTR _pt$[ebp+4], eax
  0275e	7e 18		 jle	 SHORT $L200712
  02760	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02763	8b 55 fc	 mov	 edx, DWORD PTR _pt$[ebp+4]
  02766	3b 91 98 00 00
	00		 cmp	 edx, DWORD PTR [ecx+152]
  0276c	7d 0a		 jge	 SHORT $L200712

; 669  : 	{
; 670  : 		MoveVWnd(FALSE);	

  0276e	6a 00		 push	 0
  02770	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02773	e8 00 00 00 00	 call	 ?MoveVWnd@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::MoveVWnd
$L200712:

; 671  : 	}
; 672  : 	return 0;

  02778	33 c0		 xor	 eax, eax

; 673  : }

  0277a	8b e5		 mov	 esp, ebp
  0277c	5d		 pop	 ebp
  0277d	c2 08 00	 ret	 8
?OnTrackerChange@CLocalMusicCoverList@@QAEJIJ@Z ENDP	; CLocalMusicCoverList::OnTrackerChange
_TEXT	ENDS
PUBLIC	?KillTimer@CWnd@@QAEHI@Z			; CWnd::KillTimer
PUBLIC	?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z		; CWnd::OnMouseMove
;	COMDAT ?g_idrag@?P@??OnMouseMove@CLocalMusicCoverList@@QAEXIVCPoint@@@Z@4JA
_BSS	SEGMENT
?g_idrag@?P@??OnMouseMove@CLocalMusicCoverList@@QAEXIVCPoint@@@Z@4JA DD 01H DUP (?) ; `CLocalMusicCoverList::OnMouseMove'::`15'::g_idrag
; Function compile flags: /Odt
_BSS	ENDS
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iItem$200728 = -4					; size = 4
_nFlags$ = 8						; size = 4
_point$ = 12						; size = 8
?OnMouseMove@CLocalMusicCoverList@@QAEXIVCPoint@@@Z PROC NEAR ; CLocalMusicCoverList::OnMouseMove
; _this$ = ecx

; 676  : {

  02780	55		 push	 ebp
  02781	8b ec		 mov	 ebp, esp
  02783	83 ec 08	 sub	 esp, 8
  02786	56		 push	 esi
  02787	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 677  : 	/*SetFocus();*/
; 678  : 	if (m_rcRealRect.Height()>m_rect.Height() && m_rcTracker.bottom>m_rect.bottom && point.y>m_rect.bottom)

  0278a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0278d	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  02793	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  02798	8b f0		 mov	 esi, eax
  0279a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0279d	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  027a3	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  027a8	3b f0		 cmp	 esi, eax
  027aa	7e 31		 jle	 SHORT $L200719
  027ac	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  027af	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  027b2	8b 90 34 01 00
	00		 mov	 edx, DWORD PTR [eax+308]
  027b8	3b 91 98 00 00
	00		 cmp	 edx, DWORD PTR [ecx+152]
  027be	7e 1d		 jle	 SHORT $L200719
  027c0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  027c3	8b 4d 10	 mov	 ecx, DWORD PTR _point$[ebp+4]
  027c6	3b 88 98 00 00
	00		 cmp	 ecx, DWORD PTR [eax+152]
  027cc	7e 0f		 jle	 SHORT $L200719

; 679  : 	{
; 680  : 		MoveVWnd(FALSE);

  027ce	6a 00		 push	 0
  027d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  027d3	e8 00 00 00 00	 call	 ?MoveVWnd@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::MoveVWnd

; 681  : 		// 		if (m_blTracker)
; 682  : 		// 			m_vScrDownTimer = SetTimer(101,1,NULL);
; 683  : 		return;

  027d8	e9 25 01 00 00	 jmp	 $L200718
$L200719:

; 684  : 	}
; 685  : 	else
; 686  : 	{
; 687  : 		KillTimer(m_vScrDownTimer);

  027dd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  027e0	8b 82 3c 01 00
	00		 mov	 eax, DWORD PTR [edx+316]
  027e6	50		 push	 eax
  027e7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  027ea	e8 00 00 00 00	 call	 ?KillTimer@CWnd@@QAEHI@Z ; CWnd::KillTimer

; 688  : 	}
; 689  : 
; 690  : 	if (m_rcRealRect.Height()>m_rect.Height() &&m_rcTracker.top<m_rect.top&&point.y<m_rect.top)

  027ef	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  027f2	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  027f8	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  027fd	8b f0		 mov	 esi, eax
  027ff	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02802	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  02808	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0280d	3b f0		 cmp	 esi, eax
  0280f	7e 31		 jle	 SHORT $L200721
  02811	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02814	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  02817	8b 81 2c 01 00
	00		 mov	 eax, DWORD PTR [ecx+300]
  0281d	3b 82 90 00 00
	00		 cmp	 eax, DWORD PTR [edx+144]
  02823	7d 1d		 jge	 SHORT $L200721
  02825	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02828	8b 55 10	 mov	 edx, DWORD PTR _point$[ebp+4]
  0282b	3b 91 90 00 00
	00		 cmp	 edx, DWORD PTR [ecx+144]
  02831	7d 0f		 jge	 SHORT $L200721

; 691  : 	{
; 692  : 		MoveVWnd(TRUE);

  02833	6a 01		 push	 1
  02835	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02838	e8 00 00 00 00	 call	 ?MoveVWnd@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::MoveVWnd

; 693  : 		// 		if (m_blTracker)
; 694  : 		// 			m_vScrUpTimer = SetTimer(102,1,NULL);
; 695  : 		return;

  0283d	e9 c0 00 00 00	 jmp	 $L200718
$L200721:

; 696  : 	}
; 697  : 	else
; 698  : 	{
; 699  : 		KillTimer(m_vScrUpTimer);

  02842	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02845	8b 88 40 01 00
	00		 mov	 ecx, DWORD PTR [eax+320]
  0284b	51		 push	 ecx
  0284c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0284f	e8 00 00 00 00	 call	 ?KillTimer@CWnd@@QAEHI@Z ; CWnd::KillTimer

; 700  : 	}
; 701  : 	if (m_blTracker)

  02854	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  02857	83 ba 64 01 00
	00 00		 cmp	 DWORD PTR [edx+356], 0
  0285e	74 2e		 je	 SHORT $L200723

; 702  : 	{
; 703  : 		static long g_idrag=0;
; 704  : 		g_idrag++;

  02860	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_idrag@?P@??OnMouseMove@CLocalMusicCoverList@@QAEXIVCPoint@@@Z@4JA
  02865	83 c0 01	 add	 eax, 1
  02868	a3 00 00 00 00	 mov	 DWORD PTR ?g_idrag@?P@??OnMouseMove@CLocalMusicCoverList@@QAEXIVCPoint@@@Z@4JA, eax

; 705  : 		if (g_idrag%2==0)

  0286d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_idrag@?P@??OnMouseMove@CLocalMusicCoverList@@QAEXIVCPoint@@@Z@4JA
  02873	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  02879	79 05		 jns	 SHORT $L203272
  0287b	49		 dec	 ecx
  0287c	83 c9 fe	 or	 ecx, -2			; fffffffeH
  0287f	41		 inc	 ecx
$L203272:
  02880	85 c9		 test	 ecx, ecx
  02882	75 0a		 jne	 SHORT $L200723

; 706  : 			OnMemoryDraw();

  02884	6a 01		 push	 1
  02886	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02889	e8 00 00 00 00	 call	 ?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::OnMemoryDraw
$L200723:

; 707  : 	}
; 708  : 	// 
; 709  : 	if ((nFlags&MK_LBUTTON) && m_blIsJudgeDrag)

  0288e	8b 55 08	 mov	 edx, DWORD PTR _nFlags$[ebp]
  02891	83 e2 01	 and	 edx, 1
  02894	74 3e		 je	 SHORT $L200727
  02896	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02899	83 b8 44 01 00
	00 00		 cmp	 DWORD PTR [eax+324], 0
  028a0	74 32		 je	 SHORT $L200727

; 710  : 	{
; 711  : 		int iItem;
; 712  : 		if (HitTest(iItem,point))

  028a2	8b 4d 10	 mov	 ecx, DWORD PTR _point$[ebp+4]
  028a5	51		 push	 ecx
  028a6	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  028a9	52		 push	 edx
  028aa	8d 45 fc	 lea	 eax, DWORD PTR _iItem$200728[ebp]
  028ad	50		 push	 eax
  028ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  028b1	e8 00 00 00 00	 call	 ?HitTest@CLocalMusicCoverList@@IAEHAAHVCPoint@@@Z ; CLocalMusicCoverList::HitTest
  028b6	85 c0		 test	 eax, eax
  028b8	74 1a		 je	 SHORT $L200727

; 713  : 		{
; 714  : 			m_blIsJudgeDrag = FALSE;

  028ba	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  028bd	c7 81 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+324], 0

; 715  : 			m_blDrag = TRUE;

  028c7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  028ca	c7 82 78 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+376], 1
$L200727:

; 716  : 		}
; 717  : 	}
; 718  : 	if (m_blDrag)

  028d4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  028d7	83 b8 78 01 00
	00 00		 cmp	 DWORD PTR [eax+376], 0
  028de	74 0e		 je	 SHORT $L200730

; 719  : 	{
; 720  : 		OnMoveDraging();

  028e0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  028e3	8b 11		 mov	 edx, DWORD PTR [ecx]
  028e5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  028e8	ff 92 38 01 00
	00		 call	 DWORD PTR [edx+312]
$L200730:

; 721  : 	}
; 722  : 	CWnd::OnMouseMove(nFlags, point);

  028ee	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp+4]
  028f1	50		 push	 eax
  028f2	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  028f5	51		 push	 ecx
  028f6	8b 55 08	 mov	 edx, DWORD PTR _nFlags$[ebp]
  028f9	52		 push	 edx
  028fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  028fd	e8 00 00 00 00	 call	 ?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z ; CWnd::OnMouseMove
$L200718:

; 723  : }

  02902	5e		 pop	 esi
  02903	8b e5		 mov	 esp, ebp
  02905	5d		 pop	 ebp
  02906	c2 0c 00	 ret	 12			; 0000000cH
?OnMouseMove@CLocalMusicCoverList@@QAEXIVCPoint@@@Z ENDP ; CLocalMusicCoverList::OnMouseMove
; Function compile flags: /Odt
_this$ = -4						; size = 4
?OnMoveDraging@CLocalMusicCoverList@@UAEXXZ PROC NEAR	; CLocalMusicCoverList::OnMoveDraging
; _this$ = ecx

; 726  : {

  02910	55		 push	 ebp
  02911	8b ec		 mov	 ebp, esp
  02913	51		 push	 ecx
  02914	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 727  : 
; 728  : }

  02917	8b e5		 mov	 esp, ebp
  02919	5d		 pop	 ebp
  0291a	c3		 ret	 0
?OnMoveDraging@CLocalMusicCoverList@@UAEXXZ ENDP	; CLocalMusicCoverList::OnMoveDraging
; Function compile flags: /Odt
_this$ = -4						; size = 4
?OnEndDrag@CLocalMusicCoverList@@UAEXXZ PROC NEAR	; CLocalMusicCoverList::OnEndDrag
; _this$ = ecx

; 731  : {

  02920	55		 push	 ebp
  02921	8b ec		 mov	 ebp, esp
  02923	51		 push	 ecx
  02924	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 732  : 
; 733  : }

  02927	8b e5		 mov	 esp, ebp
  02929	5d		 pop	 ebp
  0292a	c3		 ret	 0
?OnEndDrag@CLocalMusicCoverList@@UAEXXZ ENDP		; CLocalMusicCoverList::OnEndDrag
_TEXT	ENDS
PUBLIC	??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator!=
PUBLIC	?SetCapture@CWnd@@QAEPAV1@XZ			; CWnd::SetCapture
PUBLIC	??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z ; std::find<std::vector<int,std::allocator<int> >::iterator,int>
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	?OnLButtonDown@CWnd@@IAEXIVCPoint@@@Z		; CWnd::OnLButtonDown
EXTRN	?SetFocus@CWnd@@QAEPAV1@XZ:NEAR			; CWnd::SetFocus
xdata$x	SEGMENT
$T203288 DD	0ffffffffH
	DD	FLAT:$L203284
$T203286 DD	019930520H
	DD	01H
	DD	FLAT:$T203288
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv169 = -80						; size = 4
_this$ = -76						; size = 4
$T203281 = -72						; size = 4
$T203280 = -68						; size = 4
$T203279 = -64						; size = 4
$T203278 = -60						; size = 4
$T203277 = -56						; size = 4
_itend$200882 = -52					; size = 4
_it$200880 = -48					; size = 4
_pt$200878 = -44					; size = 8
_vSel$200748 = -36					; size = 16
_blsel$200745 = -20					; size = 4
_iIndex$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_nFlags$ = 8						; size = 4
_point$ = 12						; size = 8
?OnLButtonDown@CLocalMusicCoverList@@QAEXIVCPoint@@@Z PROC NEAR ; CLocalMusicCoverList::OnLButtonDown
; _this$ = ecx

; 736  : {

  02930	55		 push	 ebp
  02931	8b ec		 mov	 ebp, esp
  02933	6a ff		 push	 -1
  02935	68 00 00 00 00	 push	 __ehhandler$?OnLButtonDown@CLocalMusicCoverList@@QAEXIVCPoint@@@Z
  0293a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02940	50		 push	 eax
  02941	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02948	83 ec 44	 sub	 esp, 68			; 00000044H
  0294b	53		 push	 ebx
  0294c	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 737  : 	SetFocus();

  0294f	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  02952	e8 00 00 00 00	 call	 ?SetFocus@CWnd@@QAEPAV1@XZ ; CWnd::SetFocus

; 738  : 	int iIndex;
; 739  : 	if (HitTest(iIndex,point))

  02957	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp+4]
  0295a	50		 push	 eax
  0295b	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  0295e	51		 push	 ecx
  0295f	8d 55 f0	 lea	 edx, DWORD PTR _iIndex$[ebp]
  02962	52		 push	 edx
  02963	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  02966	e8 00 00 00 00	 call	 ?HitTest@CLocalMusicCoverList@@IAEHAAHVCPoint@@@Z ; CLocalMusicCoverList::HitTest
  0296b	85 c0		 test	 eax, eax
  0296d	0f 84 62 01 00
	00		 je	 $L200743

; 740  : 	{// 
; 741  : 		m_blIsJudgeDrag = TRUE;

  02973	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  02976	c7 80 44 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+324], 1

; 742  : 		if (nFlags & MK_CONTROL)

  02980	8b 4d 08	 mov	 ecx, DWORD PTR _nFlags$[ebp]
  02983	83 e1 08	 and	 ecx, 8
  02986	74 48		 je	 SHORT $L200744

; 743  : 		{
; 744  : 			BOOL blsel = m_DataMgr.m_vItem[iIndex].blSel;

  02988	8b 55 f0	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0298b	52		 push	 edx
  0298c	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0298f	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  02995	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  0299a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0299d	89 45 ec	 mov	 DWORD PTR _blsel$200745[ebp], eax

; 745  : 			m_iPreSel = -1;

  029a0	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  029a3	c7 81 fc 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+252], -1

; 746  : 			m_DataMgr.m_vItem[iIndex].blSel = !blsel;

  029ad	33 db		 xor	 ebx, ebx
  029af	83 7d ec 00	 cmp	 DWORD PTR _blsel$200745[ebp], 0
  029b3	0f 94 c3	 sete	 bl
  029b6	8b 55 f0	 mov	 edx, DWORD PTR _iIndex$[ebp]
  029b9	52		 push	 edx
  029ba	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  029bd	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  029c3	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  029c8	89 58 20	 mov	 DWORD PTR [eax+32], ebx

; 747  : 		}
; 748  : 		else

  029cb	e9 03 01 00 00	 jmp	 $L200746
$L200744:

; 749  : 		{
; 750  : 			vector<int> vSel = GetSelectItem();

  029d0	8d 45 dc	 lea	 eax, DWORD PTR _vSel$200748[ebp]
  029d3	50		 push	 eax
  029d4	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  029d7	e8 00 00 00 00	 call	 ?GetSelectItem@CLocalMusicCoverList@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@XZ ; CLocalMusicCoverList::GetSelectItem
  029dc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 751  : 			if (find(vSel.begin(),vSel.end(),iIndex)!=vSel.end())

  029e3	8d 4d bc	 lea	 ecx, DWORD PTR $T203280[ebp]
  029e6	51		 push	 ecx
  029e7	8d 4d dc	 lea	 ecx, DWORD PTR _vSel$200748[ebp]
  029ea	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  029ef	50		 push	 eax
  029f0	8d 55 f0	 lea	 edx, DWORD PTR _iIndex$[ebp]
  029f3	52		 push	 edx
  029f4	8d 45 c8	 lea	 eax, DWORD PTR $T203277[ebp]
  029f7	50		 push	 eax
  029f8	8d 4d dc	 lea	 ecx, DWORD PTR _vSel$200748[ebp]
  029fb	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  02a00	8b 08		 mov	 ecx, DWORD PTR [eax]
  02a02	51		 push	 ecx
  02a03	8d 55 c4	 lea	 edx, DWORD PTR $T203278[ebp]
  02a06	52		 push	 edx
  02a07	8d 4d dc	 lea	 ecx, DWORD PTR _vSel$200748[ebp]
  02a0a	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
  02a0f	8b 00		 mov	 eax, DWORD PTR [eax]
  02a11	50		 push	 eax
  02a12	8d 4d c0	 lea	 ecx, DWORD PTR $T203279[ebp]
  02a15	51		 push	 ecx
  02a16	e8 00 00 00 00	 call	 ??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z ; std::find<std::vector<int,std::allocator<int> >::iterator,int>
  02a1b	83 c4 10	 add	 esp, 16			; 00000010H
  02a1e	8b c8		 mov	 ecx, eax
  02a20	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator!=
  02a25	0f b6 d0	 movzx	 edx, al
  02a28	85 d2		 test	 edx, edx
  02a2a	74 11		 je	 SHORT $L200877

; 752  : 			{
; 753  : 				CPoint pt = point;

  02a2c	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  02a2f	89 45 d4	 mov	 DWORD PTR _pt$200878[ebp], eax
  02a32	8b 4d 10	 mov	 ecx, DWORD PTR _point$[ebp+4]
  02a35	89 4d d8	 mov	 DWORD PTR _pt$200878[ebp+4], ecx

; 754  : 			}
; 755  : 			else

  02a38	e9 87 00 00 00	 jmp	 $L200879
$L200877:

; 756  : 			{
; 757  : 				CLMCDataMgr::iterLMCItem it = m_DataMgr.m_vItem.begin();

  02a3d	8d 55 d0	 lea	 edx, DWORD PTR _it$200880[ebp]
  02a40	52		 push	 edx
  02a41	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  02a44	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  02a4a	e8 00 00 00 00	 call	 ?begin@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::begin

; 758  : 				CLMCDataMgr::iterLMCItem itend = m_DataMgr.m_vItem.end();

  02a4f	8d 45 cc	 lea	 eax, DWORD PTR _itend$200882[ebp]
  02a52	50		 push	 eax
  02a53	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  02a56	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  02a5c	e8 00 00 00 00	 call	 ?end@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::end

; 759  : 				for (;it!=itend;it++)

  02a61	eb 0e		 jmp	 SHORT $L200885
$L200886:
  02a63	6a 00		 push	 0
  02a65	8d 4d b8	 lea	 ecx, DWORD PTR $T203281[ebp]
  02a68	51		 push	 ecx
  02a69	8d 4d d0	 lea	 ecx, DWORD PTR _it$200880[ebp]
  02a6c	e8 00 00 00 00	 call	 ??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AV012@H@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator++
$L200885:
  02a71	8d 55 cc	 lea	 edx, DWORD PTR _itend$200882[ebp]
  02a74	52		 push	 edx
  02a75	8d 4d d0	 lea	 ecx, DWORD PTR _it$200880[ebp]
  02a78	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator!=
  02a7d	0f b6 c0	 movzx	 eax, al
  02a80	85 c0		 test	 eax, eax
  02a82	74 40		 je	 SHORT $L200879

; 760  : 					it->iIndex==iIndex?it->blSel=TRUE:it->blSel=FALSE;

  02a84	8d 4d d0	 lea	 ecx, DWORD PTR _it$200880[ebp]
  02a87	e8 00 00 00 00	 call	 ??Citerator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEPAU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator->
  02a8c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02a8f	3b 4d f0	 cmp	 ecx, DWORD PTR _iIndex$[ebp]
  02a92	75 18		 jne	 SHORT $L203282
  02a94	8d 4d d0	 lea	 ecx, DWORD PTR _it$200880[ebp]
  02a97	e8 00 00 00 00	 call	 ??Citerator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEPAU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator->
  02a9c	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1
  02aa3	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv169[ebp], 1
  02aaa	eb 16		 jmp	 SHORT $L203283
$L203282:
  02aac	8d 4d d0	 lea	 ecx, DWORD PTR _it$200880[ebp]
  02aaf	e8 00 00 00 00	 call	 ??Citerator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEPAU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator->
  02ab4	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  02abb	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv169[ebp], 0
$L203283:
  02ac2	eb 9f		 jmp	 SHORT $L200886
$L200879:

; 761  : 			}
; 762  : 		}

  02ac4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02acb	8d 4d dc	 lea	 ecx, DWORD PTR _vSel$200748[ebp]
  02ace	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
$L200746:

; 763  : 	}
; 764  : 	else

  02ad3	eb 49		 jmp	 SHORT $L200888
$L200743:

; 765  : 	{// 
; 766  : 		if (nFlags & MK_CONTROL)

  02ad5	8b 55 08	 mov	 edx, DWORD PTR _nFlags$[ebp]
  02ad8	83 e2 08	 and	 edx, 8
  02adb	74 02		 je	 SHORT $L200889

; 767  : 		{
; 768  : 
; 769  : 		}
; 770  : 		else

  02add	eb 3f		 jmp	 SHORT $L200888
$L200889:

; 771  : 		{
; 772  : 			SetCapture();

  02adf	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  02ae2	e8 00 00 00 00	 call	 ?SetCapture@CWnd@@QAEPAV1@XZ ; CWnd::SetCapture

; 773  : 			m_blTracker = TRUE;

  02ae7	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  02aea	c7 80 64 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+356], 1

; 774  : 			m_iDistance = point.y-m_ptClientStart.y;

  02af4	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  02af7	8b 55 10	 mov	 edx, DWORD PTR _point$[ebp+4]
  02afa	2b 91 b0 00 00
	00		 sub	 edx, DWORD PTR [ecx+176]
  02b00	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  02b03	89 90 38 01 00
	00		 mov	 DWORD PTR [eax+312], edx

; 775  : 			m_ptDown = point;

  02b09	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  02b0c	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  02b0f	89 91 1c 01 00
	00		 mov	 DWORD PTR [ecx+284], edx
  02b15	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp+4]
  02b18	89 81 20 01 00
	00		 mov	 DWORD PTR [ecx+288], eax
$L200888:

; 776  : 		}
; 777  : 	}
; 778  : 	OnMemoryDraw();

  02b1e	6a 01		 push	 1
  02b20	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  02b23	e8 00 00 00 00	 call	 ?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::OnMemoryDraw

; 779  : 	CWnd::OnLButtonDown(nFlags, point);

  02b28	8b 4d 10	 mov	 ecx, DWORD PTR _point$[ebp+4]
  02b2b	51		 push	 ecx
  02b2c	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  02b2f	52		 push	 edx
  02b30	8b 45 08	 mov	 eax, DWORD PTR _nFlags$[ebp]
  02b33	50		 push	 eax
  02b34	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  02b37	e8 00 00 00 00	 call	 ?OnLButtonDown@CWnd@@IAEXIVCPoint@@@Z ; CWnd::OnLButtonDown

; 780  : }

  02b3c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02b3f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02b46	5b		 pop	 ebx
  02b47	8b e5		 mov	 esp, ebp
  02b49	5d		 pop	 ebp
  02b4a	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L203284:
  002b0	8d 4d dc	 lea	 ecx, DWORD PTR _vSel$200748[ebp]
  002b3	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?OnLButtonDown@CLocalMusicCoverList@@QAEXIVCPoint@@@Z:
  002b8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203286
  002bd	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OnLButtonDown@CLocalMusicCoverList@@QAEXIVCPoint@@@Z ENDP ; CLocalMusicCoverList::OnLButtonDown
PUBLIC	?SetRect@CRect@@QAEXHHHH@Z			; CRect::SetRect
PUBLIC	?EndDrag@CImageList@@SGXXZ			; CImageList::EndDrag
PUBLIC	?DragLeave@CImageList@@SGHPAVCWnd@@@Z		; CImageList::DragLeave
PUBLIC	?OnLButtonUp@CWnd@@IAEXIVCPoint@@@Z		; CWnd::OnLButtonUp
EXTRN	__imp__ReleaseCapture@0:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T203290 = -20						; size = 4
_itend$200907 = -16					; size = 4
_it$200905 = -12					; size = 4
_iIndex$200901 = -8					; size = 4
_iItem$ = -4						; size = 4
_nFlags$ = 8						; size = 4
_point$ = 12						; size = 8
?OnLButtonUp@CLocalMusicCoverList@@QAEXIVCPoint@@@Z PROC NEAR ; CLocalMusicCoverList::OnLButtonUp
; _this$ = ecx

; 783  : {

  02b50	55		 push	 ebp
  02b51	8b ec		 mov	 ebp, esp
  02b53	83 ec 18	 sub	 esp, 24			; 00000018H
  02b56	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 784  : 
; 785  : 	//================================
; 786  : 	if (m_blTracker)

  02b59	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  02b5c	83 b8 64 01 00
	00 00		 cmp	 DWORD PTR [eax+356], 0
  02b63	74 57		 je	 SHORT $L200896

; 787  : 	{
; 788  : 		ReleaseCapture();

  02b65	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseCapture@0

; 789  : 		m_rcTracker.SetRect(0,0,0,0);

  02b6b	6a 00		 push	 0
  02b6d	6a 00		 push	 0
  02b6f	6a 00		 push	 0
  02b71	6a 00		 push	 0
  02b73	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02b76	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  02b7c	e8 00 00 00 00	 call	 ?SetRect@CRect@@QAEXHHHH@Z ; CRect::SetRect

; 790  : 		m_iDistance = 0;

  02b81	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02b84	c7 81 38 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+312], 0

; 791  : 		m_blTracker = FALSE;

  02b8e	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  02b91	c7 82 64 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+356], 0

; 792  : 		OnMemoryDraw();

  02b9b	6a 01		 push	 1
  02b9d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02ba0	e8 00 00 00 00	 call	 ?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::OnMemoryDraw

; 793  : 		KillTimer(m_vScrDownTimer);

  02ba5	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  02ba8	8b 88 3c 01 00
	00		 mov	 ecx, DWORD PTR [eax+316]
  02bae	51		 push	 ecx
  02baf	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02bb2	e8 00 00 00 00	 call	 ?KillTimer@CWnd@@QAEHI@Z ; CWnd::KillTimer

; 794  : 		return;

  02bb7	e9 2f 01 00 00	 jmp	 $L200895
$L200896:

; 795  : 	}
; 796  : 	//End
; 797  : 
; 798  : 	//================================
; 799  : 	if (m_blDrag)

  02bbc	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  02bbf	83 ba 78 01 00
	00 00		 cmp	 DWORD PTR [edx+376], 0
  02bc6	74 39		 je	 SHORT $L200897

; 800  : 	{
; 801  : 		m_blDrag = FALSE;

  02bc8	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  02bcb	c7 80 78 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+376], 0

; 802  : 		CImageList::DragLeave(NULL);

  02bd5	6a 00		 push	 0
  02bd7	e8 00 00 00 00	 call	 ?DragLeave@CImageList@@SGHPAVCWnd@@@Z ; CImageList::DragLeave

; 803  : 		CImageList::EndDrag();

  02bdc	e8 00 00 00 00	 call	 ?EndDrag@CImageList@@SGXXZ ; CImageList::EndDrag

; 804  : 		ReleaseCapture();

  02be1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseCapture@0

; 805  : 		OnMemoryDraw();

  02be7	6a 01		 push	 1
  02be9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02bec	e8 00 00 00 00	 call	 ?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::OnMemoryDraw

; 806  : 		OnEndDrag();

  02bf1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02bf4	8b 11		 mov	 edx, DWORD PTR [ecx]
  02bf6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02bf9	ff 92 3c 01 00
	00		 call	 DWORD PTR [edx+316]

; 807  : 	}
; 808  : 	else

  02bff	eb 4d		 jmp	 SHORT $L200898
$L200897:

; 809  : 	{
; 810  : 		if (nFlags&MK_CONTROL)

  02c01	8b 45 08	 mov	 eax, DWORD PTR _nFlags$[ebp]
  02c04	83 e0 08	 and	 eax, 8
  02c07	74 02		 je	 SHORT $L200899

; 811  : 		{
; 812  : 		}
; 813  : 		else

  02c09	eb 43		 jmp	 SHORT $L200898
$L200899:

; 814  : 		{
; 815  : 			UnSelectAll();

  02c0b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02c0e	e8 00 00 00 00	 call	 ?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UnSelectAll

; 816  : 			int iIndex;
; 817  : 			if (HitTest(iIndex,point))

  02c13	8b 4d 10	 mov	 ecx, DWORD PTR _point$[ebp+4]
  02c16	51		 push	 ecx
  02c17	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  02c1a	52		 push	 edx
  02c1b	8d 45 f8	 lea	 eax, DWORD PTR _iIndex$200901[ebp]
  02c1e	50		 push	 eax
  02c1f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02c22	e8 00 00 00 00	 call	 ?HitTest@CLocalMusicCoverList@@IAEHAAHVCPoint@@@Z ; CLocalMusicCoverList::HitTest
  02c27	85 c0		 test	 eax, eax
  02c29	74 19		 je	 SHORT $L200902

; 818  : 				m_DataMgr.m_vItem[iIndex].blSel = TRUE;	

  02c2b	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$200901[ebp]
  02c2e	51		 push	 ecx
  02c2f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02c32	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  02c38	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  02c3d	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1
$L200902:

; 819  : 			OnMemoryDraw();

  02c44	6a 01		 push	 1
  02c46	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02c49	e8 00 00 00 00	 call	 ?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::OnMemoryDraw
$L200898:

; 820  : 		}
; 821  : 	}
; 822  : 	m_blIsJudgeDrag = FALSE;

  02c4e	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  02c51	c7 82 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+324], 0

; 823  : 	//End
; 824  : 
; 825  : 	//============================
; 826  : 	int iItem;
; 827  : 	if (!HitTest(iItem,point)&&!m_blDrag)

  02c5b	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp+4]
  02c5e	50		 push	 eax
  02c5f	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  02c62	51		 push	 ecx
  02c63	8d 55 fc	 lea	 edx, DWORD PTR _iItem$[ebp]
  02c66	52		 push	 edx
  02c67	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02c6a	e8 00 00 00 00	 call	 ?HitTest@CLocalMusicCoverList@@IAEHAAHVCPoint@@@Z ; CLocalMusicCoverList::HitTest
  02c6f	85 c0		 test	 eax, eax
  02c71	75 64		 jne	 SHORT $L200904
  02c73	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  02c76	83 b8 78 01 00
	00 00		 cmp	 DWORD PTR [eax+376], 0
  02c7d	75 58		 jne	 SHORT $L200904

; 828  : 	{
; 829  : 		CLMCDataMgr::iterLMCItem it = m_DataMgr.m_vItem.begin();

  02c7f	8d 4d f4	 lea	 ecx, DWORD PTR _it$200905[ebp]
  02c82	51		 push	 ecx
  02c83	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02c86	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  02c8c	e8 00 00 00 00	 call	 ?begin@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::begin

; 830  : 		CLMCDataMgr::iterLMCItem itend = m_DataMgr.m_vItem.end();

  02c91	8d 55 f0	 lea	 edx, DWORD PTR _itend$200907[ebp]
  02c94	52		 push	 edx
  02c95	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02c98	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  02c9e	e8 00 00 00 00	 call	 ?end@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::end

; 831  : 		for (;it!=itend;it++)

  02ca3	eb 0e		 jmp	 SHORT $L200910
$L200911:
  02ca5	6a 00		 push	 0
  02ca7	8d 45 ec	 lea	 eax, DWORD PTR $T203290[ebp]
  02caa	50		 push	 eax
  02cab	8d 4d f4	 lea	 ecx, DWORD PTR _it$200905[ebp]
  02cae	e8 00 00 00 00	 call	 ??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AV012@H@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator++
$L200910:
  02cb3	8d 4d f0	 lea	 ecx, DWORD PTR _itend$200907[ebp]
  02cb6	51		 push	 ecx
  02cb7	8d 4d f4	 lea	 ecx, DWORD PTR _it$200905[ebp]
  02cba	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator!=
  02cbf	0f b6 d0	 movzx	 edx, al
  02cc2	85 d2		 test	 edx, edx
  02cc4	74 11		 je	 SHORT $L200904

; 832  : 			it->blSel=FALSE;

  02cc6	8d 4d f4	 lea	 ecx, DWORD PTR _it$200905[ebp]
  02cc9	e8 00 00 00 00	 call	 ??Citerator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEPAU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator->
  02cce	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  02cd5	eb ce		 jmp	 SHORT $L200911
$L200904:

; 833  : 
; 834  : 
; 835  : 	}
; 836  : 	//End
; 837  : 
; 838  : 	CWnd::OnLButtonUp(nFlags, point);

  02cd7	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp+4]
  02cda	50		 push	 eax
  02cdb	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  02cde	51		 push	 ecx
  02cdf	8b 55 08	 mov	 edx, DWORD PTR _nFlags$[ebp]
  02ce2	52		 push	 edx
  02ce3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02ce6	e8 00 00 00 00	 call	 ?OnLButtonUp@CWnd@@IAEXIVCPoint@@@Z ; CWnd::OnLButtonUp
$L200895:

; 839  : }

  02ceb	8b e5		 mov	 esp, ebp
  02ced	5d		 pop	 ebp
  02cee	c2 0c 00	 ret	 12			; 0000000cH
?OnLButtonUp@CLocalMusicCoverList@@QAEXIVCPoint@@@Z ENDP ; CLocalMusicCoverList::OnLButtonUp
_TEXT	ENDS
PUBLIC	?OnRButtonUp@CWnd@@IAEXIVCPoint@@@Z		; CWnd::OnRButtonUp
xdata$x	SEGMENT
$T203300 DD	0ffffffffH
	DD	FLAT:$L203296
$T203298 DD	019930520H
	DD	01H
	DD	FLAT:$T203300
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T203295 = -48						; size = 4
$T203294 = -44						; size = 4
$T203293 = -40						; size = 4
$T203292 = -36						; size = 4
_vSel$200921 = -32					; size = 16
_iItem$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_nFlags$ = 8						; size = 4
_point$ = 12						; size = 8
?OnRButtonUp@CLocalMusicCoverList@@QAEXIVCPoint@@@Z PROC NEAR ; CLocalMusicCoverList::OnRButtonUp
; _this$ = ecx

; 842  : {	

  02d00	55		 push	 ebp
  02d01	8b ec		 mov	 ebp, esp
  02d03	6a ff		 push	 -1
  02d05	68 00 00 00 00	 push	 __ehhandler$?OnRButtonUp@CLocalMusicCoverList@@QAEXIVCPoint@@@Z
  02d0a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02d10	50		 push	 eax
  02d11	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02d18	83 ec 28	 sub	 esp, 40			; 00000028H
  02d1b	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 843  : 	int iItem;
; 844  : 	if (HitTest(iItem,point))

  02d1e	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp+4]
  02d21	50		 push	 eax
  02d22	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  02d25	51		 push	 ecx
  02d26	8d 55 f0	 lea	 edx, DWORD PTR _iItem$[ebp]
  02d29	52		 push	 edx
  02d2a	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  02d2d	e8 00 00 00 00	 call	 ?HitTest@CLocalMusicCoverList@@IAEHAAHVCPoint@@@Z ; CLocalMusicCoverList::HitTest
  02d32	85 c0		 test	 eax, eax
  02d34	0f 84 9f 00 00
	00		 je	 $L200919

; 845  : 	{
; 846  : 		// 
; 847  : 		vector<int> vSel = GetSelectItem();

  02d3a	8d 45 e0	 lea	 eax, DWORD PTR _vSel$200921[ebp]
  02d3d	50		 push	 eax
  02d3e	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  02d41	e8 00 00 00 00	 call	 ?GetSelectItem@CLocalMusicCoverList@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@XZ ; CLocalMusicCoverList::GetSelectItem
  02d46	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 848  : 		if (find(vSel.begin(),vSel.end(),iItem)!=vSel.end())

  02d4d	8d 4d d0	 lea	 ecx, DWORD PTR $T203295[ebp]
  02d50	51		 push	 ecx
  02d51	8d 4d e0	 lea	 ecx, DWORD PTR _vSel$200921[ebp]
  02d54	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  02d59	50		 push	 eax
  02d5a	8d 55 f0	 lea	 edx, DWORD PTR _iItem$[ebp]
  02d5d	52		 push	 edx
  02d5e	8d 45 dc	 lea	 eax, DWORD PTR $T203292[ebp]
  02d61	50		 push	 eax
  02d62	8d 4d e0	 lea	 ecx, DWORD PTR _vSel$200921[ebp]
  02d65	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  02d6a	8b 08		 mov	 ecx, DWORD PTR [eax]
  02d6c	51		 push	 ecx
  02d6d	8d 55 d8	 lea	 edx, DWORD PTR $T203293[ebp]
  02d70	52		 push	 edx
  02d71	8d 4d e0	 lea	 ecx, DWORD PTR _vSel$200921[ebp]
  02d74	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
  02d79	8b 00		 mov	 eax, DWORD PTR [eax]
  02d7b	50		 push	 eax
  02d7c	8d 4d d4	 lea	 ecx, DWORD PTR $T203294[ebp]
  02d7f	51		 push	 ecx
  02d80	e8 00 00 00 00	 call	 ??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z ; std::find<std::vector<int,std::allocator<int> >::iterator,int>
  02d85	83 c4 10	 add	 esp, 16			; 00000010H
  02d88	8b c8		 mov	 ecx, eax
  02d8a	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator!=
  02d8f	0f b6 d0	 movzx	 edx, al
  02d92	85 d2		 test	 edx, edx
  02d94	74 11		 je	 SHORT $L200927

; 849  : 		{
; 850  : 			return;

  02d96	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02d9d	8d 4d e0	 lea	 ecx, DWORD PTR _vSel$200921[ebp]
  02da0	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  02da5	eb 58		 jmp	 SHORT $L200917
$L200927:

; 851  : 		}
; 852  : 		else
; 853  : 		{
; 854  : 			UnSelectAll();

  02da7	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  02daa	e8 00 00 00 00	 call	 ?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UnSelectAll

; 855  : 			m_DataMgr.m_vItem[iItem].blSel = TRUE;

  02daf	8b 45 f0	 mov	 eax, DWORD PTR _iItem$[ebp]
  02db2	50		 push	 eax
  02db3	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  02db6	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  02dbc	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  02dc1	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 856  : 		}
; 857  : 	}

  02dc8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02dcf	8d 4d e0	 lea	 ecx, DWORD PTR _vSel$200921[ebp]
  02dd2	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >

; 858  : 	else

  02dd7	eb 08		 jmp	 SHORT $L200929
$L200919:

; 859  : 	{
; 860  : 		// 
; 861  : 		UnSelectAll();

  02dd9	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  02ddc	e8 00 00 00 00	 call	 ?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UnSelectAll
$L200929:

; 862  : 	}
; 863  : 	OnMemoryDraw();

  02de1	6a 01		 push	 1
  02de3	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  02de6	e8 00 00 00 00	 call	 ?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::OnMemoryDraw

; 864  : 	CWnd::OnRButtonUp(nFlags, point);

  02deb	8b 4d 10	 mov	 ecx, DWORD PTR _point$[ebp+4]
  02dee	51		 push	 ecx
  02def	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  02df2	52		 push	 edx
  02df3	8b 45 08	 mov	 eax, DWORD PTR _nFlags$[ebp]
  02df6	50		 push	 eax
  02df7	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  02dfa	e8 00 00 00 00	 call	 ?OnRButtonUp@CWnd@@IAEXIVCPoint@@@Z ; CWnd::OnRButtonUp
$L200917:

; 865  : }

  02dff	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02e02	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02e09	8b e5		 mov	 esp, ebp
  02e0b	5d		 pop	 ebp
  02e0c	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L203296:
  002c2	8d 4d e0	 lea	 ecx, DWORD PTR _vSel$200921[ebp]
  002c5	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?OnRButtonUp@CLocalMusicCoverList@@QAEXIVCPoint@@@Z:
  002ca	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203298
  002cf	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OnRButtonUp@CLocalMusicCoverList@@QAEXIVCPoint@@@Z ENDP ; CLocalMusicCoverList::OnRButtonUp
EXTRN	?HandleCustomDraw@@YAJIPAUNMCSBCUSTOMDRAW@@PAVCDibBitmap@@1@Z:NEAR ; HandleCustomDraw
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pNMCD$ = -4						; size = 4
_pNMHDR$ = 8						; size = 4
_pResult$ = 12						; size = 4
?OnCoolSBCustomdraw@CLocalMusicCoverList@@QAEXPAUtagNMHDR@@PAJ@Z PROC NEAR ; CLocalMusicCoverList::OnCoolSBCustomdraw
; _this$ = ecx

; 868  : {

  02e10	55		 push	 ebp
  02e11	8b ec		 mov	 ebp, esp
  02e13	83 ec 08	 sub	 esp, 8
  02e16	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 869  : 	NMCSBCUSTOMDRAW* pNMCD = reinterpret_cast<NMCSBCUSTOMDRAW*>(pNMHDR);	

  02e19	8b 45 08	 mov	 eax, DWORD PTR _pNMHDR$[ebp]
  02e1c	89 45 fc	 mov	 DWORD PTR _pNMCD$[ebp], eax

; 870  : 	if( m_pBitmapScrollHorz != NULL && m_pBitmapScrollVert != NULL )

  02e1f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02e22	83 b9 54 01 00
	00 00		 cmp	 DWORD PTR [ecx+340], 0
  02e29	74 33		 je	 SHORT $L200934
  02e2b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  02e2e	83 ba 50 01 00
	00 00		 cmp	 DWORD PTR [edx+336], 0
  02e35	74 27		 je	 SHORT $L200934

; 871  : 	{
; 872  : 		*pResult = HandleCustomDraw(0, (NMCSBCUSTOMDRAW*)pNMHDR, m_pBitmapScrollVert,m_pBitmapScrollHorz );

  02e37	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02e3a	8b 88 54 01 00
	00		 mov	 ecx, DWORD PTR [eax+340]
  02e40	51		 push	 ecx
  02e41	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  02e44	8b 82 50 01 00
	00		 mov	 eax, DWORD PTR [edx+336]
  02e4a	50		 push	 eax
  02e4b	8b 4d 08	 mov	 ecx, DWORD PTR _pNMHDR$[ebp]
  02e4e	51		 push	 ecx
  02e4f	6a 00		 push	 0
  02e51	e8 00 00 00 00	 call	 ?HandleCustomDraw@@YAJIPAUNMCSBCUSTOMDRAW@@PAVCDibBitmap@@1@Z ; HandleCustomDraw
  02e56	83 c4 10	 add	 esp, 16			; 00000010H
  02e59	8b 55 0c	 mov	 edx, DWORD PTR _pResult$[ebp]
  02e5c	89 02		 mov	 DWORD PTR [edx], eax
$L200934:

; 873  : 	}
; 874  : }

  02e5e	8b e5		 mov	 esp, ebp
  02e60	5d		 pop	 ebp
  02e61	c2 08 00	 ret	 8
?OnCoolSBCustomdraw@CLocalMusicCoverList@@QAEXPAUtagNMHDR@@PAJ@Z ENDP ; CLocalMusicCoverList::OnCoolSBCustomdraw
_TEXT	ENDS
EXTRN	_UninitializeCoolSB@4:NEAR
EXTRN	?OnDestroy@CWnd@@IAEXXZ:NEAR			; CWnd::OnDestroy
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnDestroy@CLocalMusicCoverList@@QAEXXZ PROC NEAR	; CLocalMusicCoverList::OnDestroy
; _this$ = ecx

; 877  : {

  02e70	55		 push	 ebp
  02e71	8b ec		 mov	 ebp, esp
  02e73	51		 push	 ecx
  02e74	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 	CWnd::OnDestroy();

  02e77	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02e7a	e8 00 00 00 00	 call	 ?OnDestroy@CWnd@@IAEXXZ	; CWnd::OnDestroy

; 879  : 	if( m_bInit )

  02e7f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02e82	0f b6 88 58 01
	00 00		 movzx	 ecx, BYTE PTR [eax+344]
  02e89	85 c9		 test	 ecx, ecx
  02e8b	74 0c		 je	 SHORT $L200941

; 880  : 	{
; 881  : 		UninitializeCoolSB( m_hWnd );

  02e8d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02e90	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  02e93	50		 push	 eax
  02e94	e8 00 00 00 00	 call	 _UninitializeCoolSB@4
$L200941:

; 882  : 	}
; 883  : }

  02e99	8b e5		 mov	 esp, ebp
  02e9b	5d		 pop	 ebp
  02e9c	c3		 ret	 0
?OnDestroy@CLocalMusicCoverList@@QAEXXZ ENDP		; CLocalMusicCoverList::OnDestroy
_TEXT	ENDS
EXTRN	?OnVScroll@CWnd@@IAEXIIPAVCScrollBar@@@Z:NEAR	; CWnd::OnVScroll
; Function compile flags: /Odt
_TEXT	SEGMENT
tv131 = -68						; size = 4
tv204 = -64						; size = 4
tv203 = -60						; size = 4
tv200 = -56						; size = 4
tv199 = -52						; size = 4
tv196 = -48						; size = 4
tv191 = -44						; size = 4
tv190 = -40						; size = 4
tv187 = -36						; size = 4
tv186 = -32						; size = 4
tv183 = -28						; size = 4
_this$ = -24						; size = 4
_lenVbar$ = -20						; size = 4
_realhight$ = -16					; size = 4
_pt$ = -12						; size = 8
_nCurrpos$ = -4						; size = 4
_nSBCode$ = 8						; size = 4
_nPos$ = 12						; size = 4
_pScrollBar$ = 16					; size = 4
?OnVScroll@CLocalMusicCoverList@@QAEXIIPAVCScrollBar@@@Z PROC NEAR ; CLocalMusicCoverList::OnVScroll
; _this$ = ecx

; 886  : {

  02ea0	55		 push	 ebp
  02ea1	8b ec		 mov	 ebp, esp
  02ea3	83 ec 44	 sub	 esp, 68			; 00000044H
  02ea6	56		 push	 esi
  02ea7	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 887  : 	int nCurrpos = CoolSB_GetScrollPos(m_hWnd,SB_VERT);

  02eaa	6a 01		 push	 1
  02eac	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  02eaf	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  02eb2	51		 push	 ecx
  02eb3	e8 00 00 00 00	 call	 _CoolSB_GetScrollPos@8
  02eb8	89 45 fc	 mov	 DWORD PTR _nCurrpos$[ebp], eax

; 888  : 	int lenVbar = (float)m_rect.Height()/m_rcRealRect.Height()*m_rect.Height();// 

  02ebb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02ebe	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  02ec4	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  02ec9	89 45 e4	 mov	 DWORD PTR tv183[ebp], eax
  02ecc	db 45 e4	 fild	 DWORD PTR tv183[ebp]
  02ecf	d9 5d e0	 fstp	 DWORD PTR tv186[ebp]
  02ed2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02ed5	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  02edb	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  02ee0	89 45 dc	 mov	 DWORD PTR tv187[ebp], eax
  02ee3	db 45 dc	 fild	 DWORD PTR tv187[ebp]
  02ee6	d8 7d e0	 fdivr	 DWORD PTR tv186[ebp]
  02ee9	d9 5d d8	 fstp	 DWORD PTR tv190[ebp]
  02eec	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02eef	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  02ef5	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  02efa	89 45 d4	 mov	 DWORD PTR tv191[ebp], eax
  02efd	db 45 d4	 fild	 DWORD PTR tv191[ebp]
  02f00	d8 4d d8	 fmul	 DWORD PTR tv190[ebp]
  02f03	e8 00 00 00 00	 call	 __ftol2
  02f08	89 45 ec	 mov	 DWORD PTR _lenVbar$[ebp], eax

; 889  : 	int realhight = (float)(m_rect.Height()-lenVbar)/m_rect.Height()*m_rcRealRect.Height();// -

  02f0b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02f0e	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  02f14	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  02f19	2b 45 ec	 sub	 eax, DWORD PTR _lenVbar$[ebp]
  02f1c	89 45 d0	 mov	 DWORD PTR tv196[ebp], eax
  02f1f	db 45 d0	 fild	 DWORD PTR tv196[ebp]
  02f22	d9 5d cc	 fstp	 DWORD PTR tv199[ebp]
  02f25	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02f28	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  02f2e	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  02f33	89 45 c8	 mov	 DWORD PTR tv200[ebp], eax
  02f36	db 45 c8	 fild	 DWORD PTR tv200[ebp]
  02f39	d8 7d cc	 fdivr	 DWORD PTR tv199[ebp]
  02f3c	d9 5d c4	 fstp	 DWORD PTR tv203[ebp]
  02f3f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02f42	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  02f48	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  02f4d	89 45 c0	 mov	 DWORD PTR tv204[ebp], eax
  02f50	db 45 c0	 fild	 DWORD PTR tv204[ebp]
  02f53	d8 4d c4	 fmul	 DWORD PTR tv203[ebp]
  02f56	e8 00 00 00 00	 call	 __ftol2
  02f5b	89 45 f0	 mov	 DWORD PTR _realhight$[ebp], eax

; 890  : 	switch(nSBCode)

  02f5e	8b 55 08	 mov	 edx, DWORD PTR _nSBCode$[ebp]
  02f61	89 55 bc	 mov	 DWORD PTR tv131[ebp], edx
  02f64	83 7d bc 05	 cmp	 DWORD PTR tv131[ebp], 5
  02f68	0f 87 8e 00 00
	00		 ja	 $L200955
  02f6e	8b 45 bc	 mov	 eax, DWORD PTR tv131[ebp]
  02f71	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L203304[eax*4]
$L200958:

; 891  : 	{
; 892  : 	case SB_LINEUP:
; 893  : 		nCurrpos-=realhight/10;

  02f78	8b 45 f0	 mov	 eax, DWORD PTR _realhight$[ebp]
  02f7b	99		 cdq
  02f7c	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  02f81	f7 f9		 idiv	 ecx
  02f83	8b 55 fc	 mov	 edx, DWORD PTR _nCurrpos$[ebp]
  02f86	2b d0		 sub	 edx, eax
  02f88	89 55 fc	 mov	 DWORD PTR _nCurrpos$[ebp], edx

; 894  : 		if (nCurrpos<0) nCurrpos=0;

  02f8b	79 07		 jns	 SHORT $L200959
  02f8d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nCurrpos$[ebp], 0
$L200959:

; 895  : 		break;

  02f94	eb 66		 jmp	 SHORT $L200955
$L200960:

; 896  : 	case SB_LINEDOWN:
; 897  : 		nCurrpos+=realhight/10;

  02f96	8b 45 f0	 mov	 eax, DWORD PTR _realhight$[ebp]
  02f99	99		 cdq
  02f9a	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  02f9f	f7 f9		 idiv	 ecx
  02fa1	03 45 fc	 add	 eax, DWORD PTR _nCurrpos$[ebp]
  02fa4	89 45 fc	 mov	 DWORD PTR _nCurrpos$[ebp], eax

; 898  : 		if(nCurrpos>realhight) nCurrpos=realhight;

  02fa7	8b 55 fc	 mov	 edx, DWORD PTR _nCurrpos$[ebp]
  02faa	3b 55 f0	 cmp	 edx, DWORD PTR _realhight$[ebp]
  02fad	7e 06		 jle	 SHORT $L200961
  02faf	8b 45 f0	 mov	 eax, DWORD PTR _realhight$[ebp]
  02fb2	89 45 fc	 mov	 DWORD PTR _nCurrpos$[ebp], eax
$L200961:

; 899  : 		break;

  02fb5	eb 45		 jmp	 SHORT $L200955
$L200962:

; 900  : 	case SB_PAGEUP:
; 901  : 		nCurrpos-=realhight/10;

  02fb7	8b 45 f0	 mov	 eax, DWORD PTR _realhight$[ebp]
  02fba	99		 cdq
  02fbb	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  02fc0	f7 f9		 idiv	 ecx
  02fc2	8b 55 fc	 mov	 edx, DWORD PTR _nCurrpos$[ebp]
  02fc5	2b d0		 sub	 edx, eax
  02fc7	89 55 fc	 mov	 DWORD PTR _nCurrpos$[ebp], edx

; 902  : 		if (nCurrpos<0) nCurrpos=0;

  02fca	79 07		 jns	 SHORT $L200963
  02fcc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nCurrpos$[ebp], 0
$L200963:

; 903  : 		break;

  02fd3	eb 27		 jmp	 SHORT $L200955
$L200964:

; 904  : 		break;
; 905  : 	case SB_PAGEDOWN:
; 906  : 		nCurrpos+=realhight/10;

  02fd5	8b 45 f0	 mov	 eax, DWORD PTR _realhight$[ebp]
  02fd8	99		 cdq
  02fd9	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  02fde	f7 f9		 idiv	 ecx
  02fe0	03 45 fc	 add	 eax, DWORD PTR _nCurrpos$[ebp]
  02fe3	89 45 fc	 mov	 DWORD PTR _nCurrpos$[ebp], eax

; 907  : 		if(nCurrpos>realhight) nCurrpos=realhight;

  02fe6	8b 55 fc	 mov	 edx, DWORD PTR _nCurrpos$[ebp]
  02fe9	3b 55 f0	 cmp	 edx, DWORD PTR _realhight$[ebp]
  02fec	7e 06		 jle	 SHORT $L200965
  02fee	8b 45 f0	 mov	 eax, DWORD PTR _realhight$[ebp]
  02ff1	89 45 fc	 mov	 DWORD PTR _nCurrpos$[ebp], eax
$L200965:

; 908  : 		break;

  02ff4	eb 06		 jmp	 SHORT $L200955
$L200968:

; 909  : 		break;
; 910  : 	case SB_TOP:
; 911  : 		break;
; 912  : 	case SB_BOTTOM:
; 913  : 		break;
; 914  : 	case SB_THUMBTRACK:
; 915  : 		nCurrpos=nPos;

  02ff6	8b 4d 0c	 mov	 ecx, DWORD PTR _nPos$[ebp]
  02ff9	89 4d fc	 mov	 DWORD PTR _nCurrpos$[ebp], ecx
$L200955:

; 916  : 		break;
; 917  : 	}
; 918  : 	
; 919  : 	CPoint pt=m_ptClientStart;

  02ffc	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  02fff	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  03005	8b 8a b0 00 00
	00		 mov	 ecx, DWORD PTR [edx+176]
  0300b	89 45 f4	 mov	 DWORD PTR _pt$[ebp], eax
  0300e	89 4d f8	 mov	 DWORD PTR _pt$[ebp+4], ecx

; 920  : 	pt.y = nCurrpos*(m_rcRealRect.Height()-m_rect.Height())/realhight;

  03011	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  03014	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  0301a	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0301f	8b f0		 mov	 esi, eax
  03021	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  03024	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0302a	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0302f	2b f0		 sub	 esi, eax
  03031	8b c6		 mov	 eax, esi
  03033	0f af 45 fc	 imul	 eax, DWORD PTR _nCurrpos$[ebp]
  03037	99		 cdq
  03038	f7 7d f0	 idiv	 DWORD PTR _realhight$[ebp]
  0303b	89 45 f8	 mov	 DWORD PTR _pt$[ebp+4], eax

; 921  : 	pt.y=0-pt.y;

  0303e	33 d2		 xor	 edx, edx
  03040	2b 55 f8	 sub	 edx, DWORD PTR _pt$[ebp+4]
  03043	89 55 f8	 mov	 DWORD PTR _pt$[ebp+4], edx

; 922  : 	m_csLockV.Lock();

  03046	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  03049	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  0304f	e8 00 00 00 00	 call	 ?Lock@CCriticalSection@@QAEHXZ ; CCriticalSection::Lock

; 923  : 	m_vPtQueue.push_back(pt);

  03054	8d 45 f4	 lea	 eax, DWORD PTR _pt$[ebp]
  03057	50		 push	 eax
  03058	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0305b	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  03061	e8 00 00 00 00	 call	 ?push_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXABVCPoint@@@Z ; std::deque<CPoint,std::allocator<CPoint> >::push_back

; 924  : 	m_csLockV.Unlock();

  03066	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  03069	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  0306f	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  03072	8b 82 b4 00 00
	00		 mov	 eax, DWORD PTR [edx+180]
  03078	ff 50 1c	 call	 DWORD PTR [eax+28]

; 925  : 	CoolSB_SetScrollPos(m_hWnd,SB_VERT,nCurrpos,TRUE);

  0307b	6a 01		 push	 1
  0307d	8b 4d fc	 mov	 ecx, DWORD PTR _nCurrpos$[ebp]
  03080	51		 push	 ecx
  03081	6a 01		 push	 1
  03083	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  03086	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  03089	50		 push	 eax
  0308a	e8 00 00 00 00	 call	 _CoolSB_SetScrollPos@16

; 926  : 	CWnd::OnVScroll(nSBCode, nPos, pScrollBar);

  0308f	8b 4d 10	 mov	 ecx, DWORD PTR _pScrollBar$[ebp]
  03092	51		 push	 ecx
  03093	8b 55 0c	 mov	 edx, DWORD PTR _nPos$[ebp]
  03096	52		 push	 edx
  03097	8b 45 08	 mov	 eax, DWORD PTR _nSBCode$[ebp]
  0309a	50		 push	 eax
  0309b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0309e	e8 00 00 00 00	 call	 ?OnVScroll@CWnd@@IAEXIIPAVCScrollBar@@@Z ; CWnd::OnVScroll

; 927  : }

  030a3	5e		 pop	 esi
  030a4	8b e5		 mov	 esp, ebp
  030a6	5d		 pop	 ebp
  030a7	c2 0c 00	 ret	 12			; 0000000cH
$L203304:
  030aa	00 00 00 00	 DD	 $L200958
  030ae	00 00 00 00	 DD	 $L200960
  030b2	00 00 00 00	 DD	 $L200962
  030b6	00 00 00 00	 DD	 $L200964
  030ba	00 00 00 00	 DD	 $L200955
  030be	00 00 00 00	 DD	 $L200968
?OnVScroll@CLocalMusicCoverList@@QAEXIIPAVCScrollBar@@@Z ENDP ; CLocalMusicCoverList::OnVScroll
_TEXT	ENDS
PUBLIC	?OnShowWindow@CWnd@@IAEXHI@Z			; CWnd::OnShowWindow
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bShow$ = 8						; size = 4
_nStatus$ = 12						; size = 4
?OnShowWindow@CLocalMusicCoverList@@QAEXHI@Z PROC NEAR	; CLocalMusicCoverList::OnShowWindow
; _this$ = ecx

; 930  : {

  030d0	55		 push	 ebp
  030d1	8b ec		 mov	 ebp, esp
  030d3	51		 push	 ecx
  030d4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 931  : 	CWnd::OnShowWindow(bShow, nStatus);

  030d7	8b 45 0c	 mov	 eax, DWORD PTR _nStatus$[ebp]
  030da	50		 push	 eax
  030db	8b 4d 08	 mov	 ecx, DWORD PTR _bShow$[ebp]
  030de	51		 push	 ecx
  030df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  030e2	e8 00 00 00 00	 call	 ?OnShowWindow@CWnd@@IAEXHI@Z ; CWnd::OnShowWindow

; 932  : 	m_PaintScrollBar = bShow;

  030e7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  030ea	8b 45 08	 mov	 eax, DWORD PTR _bShow$[ebp]
  030ed	89 82 5c 01 00
	00		 mov	 DWORD PTR [edx+348], eax

; 933  : }

  030f3	8b e5		 mov	 esp, ebp
  030f5	5d		 pop	 ebp
  030f6	c2 08 00	 ret	 8
?OnShowWindow@CLocalMusicCoverList@@QAEXHI@Z ENDP	; CLocalMusicCoverList::OnShowWindow
_TEXT	ENDS
EXTRN	__imp__GetKeyState@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$200983 = -4						; size = 4
_nChar$ = 8						; size = 4
_nRepCnt$ = 12						; size = 4
_nFlags$ = 16						; size = 4
?OnKeyDown@CLocalMusicCoverList@@QAEXIII@Z PROC NEAR	; CLocalMusicCoverList::OnKeyDown
; _this$ = ecx

; 936  : {

  03100	55		 push	 ebp
  03101	8b ec		 mov	 ebp, esp
  03103	83 ec 08	 sub	 esp, 8
  03106	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 937  : 	if( ( GetKeyState(VK_CONTROL) & 0xF0000000) &&
; 938  : 		( nChar=='A' || nChar=='a') )

  03109	6a 11		 push	 17			; 00000011H
  0310b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyState@4
  03111	0f bf c0	 movsx	 eax, ax
  03114	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  03119	74 56		 je	 SHORT $L200980
  0311b	83 7d 08 41	 cmp	 DWORD PTR _nChar$[ebp], 65 ; 00000041H
  0311f	74 06		 je	 SHORT $L200982
  03121	83 7d 08 61	 cmp	 DWORD PTR _nChar$[ebp], 97 ; 00000061H
  03125	75 4a		 jne	 SHORT $L200980
$L200982:

; 939  : 	{
; 940  : 		for (int i=0;i<m_DataMgr.m_vItem.size();i++)

  03127	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$200983[ebp], 0
  0312e	eb 09		 jmp	 SHORT $L200984
$L200985:
  03130	8b 4d fc	 mov	 ecx, DWORD PTR _i$200983[ebp]
  03133	83 c1 01	 add	 ecx, 1
  03136	89 4d fc	 mov	 DWORD PTR _i$200983[ebp], ecx
$L200984:
  03139	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0313c	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  03142	e8 00 00 00 00	 call	 ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
  03147	39 45 fc	 cmp	 DWORD PTR _i$200983[ebp], eax
  0314a	73 1b		 jae	 SHORT $L200986

; 941  : 			m_DataMgr.m_vItem[i].blSel = TRUE;

  0314c	8b 55 fc	 mov	 edx, DWORD PTR _i$200983[ebp]
  0314f	52		 push	 edx
  03150	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  03153	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  03159	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  0315e	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1
  03165	eb c9		 jmp	 SHORT $L200985
$L200986:

; 942  : 		OnMemoryDraw();

  03167	6a 01		 push	 1
  03169	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0316c	e8 00 00 00 00	 call	 ?OnMemoryDraw@CLocalMusicCoverList@@IAEXH@Z ; CLocalMusicCoverList::OnMemoryDraw
$L200980:

; 943  : 		return;
; 944  : 	}
; 945  : }

  03171	8b e5		 mov	 esp, ebp
  03173	5d		 pop	 ebp
  03174	c2 0c 00	 ret	 12			; 0000000cH
?OnKeyDown@CLocalMusicCoverList@@QAEXIII@Z ENDP		; CLocalMusicCoverList::OnKeyDown
_TEXT	ENDS
PUBLIC	?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z	; CLocalMusicCoverList::EnsureVisible
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pt$ = -8						; size = 8
_iIndex$ = 8						; size = 4
?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z PROC NEAR	; CLocalMusicCoverList::EnsureVisible
; _this$ = ecx

; 948  : {

  03180	55		 push	 ebp
  03181	8b ec		 mov	 ebp, esp
  03183	83 ec 0c	 sub	 esp, 12			; 0000000cH
  03186	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 949  : 	CPoint pt=m_ptClientStart;

  03189	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0318c	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  03192	8b 90 b0 00 00
	00		 mov	 edx, DWORD PTR [eax+176]
  03198	89 4d f8	 mov	 DWORD PTR _pt$[ebp], ecx
  0319b	89 55 fc	 mov	 DWORD PTR _pt$[ebp+4], edx

; 950  : 	if (m_DataMgr.m_vItem[iIndex].rc.top>m_rect.bottom)

  0319e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  031a1	50		 push	 eax
  031a2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  031a5	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  031ab	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  031b0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  031b3	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  031b6	3b 91 98 00 00
	00		 cmp	 edx, DWORD PTR [ecx+152]
  031bc	7e 2f		 jle	 SHORT $L200992

; 951  : 		pt.y = pt.y-(m_DataMgr.m_vItem[iIndex].rc.top-m_rect.bottom+m_iItemHeight)-20;//20 temp

  031be	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  031c1	50		 push	 eax
  031c2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  031c5	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  031cb	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  031d0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  031d3	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  031d6	2b 91 98 00 00
	00		 sub	 edx, DWORD PTR [ecx+152]
  031dc	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  031df	03 50 58	 add	 edx, DWORD PTR [eax+88]
  031e2	8b 4d fc	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  031e5	2b ca		 sub	 ecx, edx
  031e7	83 e9 14	 sub	 ecx, 20			; 00000014H
  031ea	89 4d fc	 mov	 DWORD PTR _pt$[ebp+4], ecx
$L200992:

; 952  : 	if(m_DataMgr.m_vItem[iIndex].rc.bottom<m_rect.top)

  031ed	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  031f0	52		 push	 edx
  031f1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  031f4	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  031fa	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  031ff	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  03202	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  03205	3b 91 90 00 00
	00		 cmp	 edx, DWORD PTR [ecx+144]
  0320b	7d 2a		 jge	 SHORT $L200993

; 953  : 		pt.y = pt.y+(m_rect.top-m_DataMgr.m_vItem[iIndex].rc.bottom)+m_iItemHeight;

  0320d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03210	50		 push	 eax
  03211	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  03214	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0321a	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  0321f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  03222	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  03228	2b 50 40	 sub	 edx, DWORD PTR [eax+64]
  0322b	03 55 fc	 add	 edx, DWORD PTR _pt$[ebp+4]
  0322e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  03231	03 50 58	 add	 edx, DWORD PTR [eax+88]
  03234	89 55 fc	 mov	 DWORD PTR _pt$[ebp+4], edx
$L200993:

; 954  : 	m_DataMgr.m_vItem[iIndex].blSel = TRUE;

  03237	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0323a	51		 push	 ecx
  0323b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0323e	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  03244	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  03249	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 955  : 	m_csLockV.Lock();

  03250	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  03253	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  03259	e8 00 00 00 00	 call	 ?Lock@CCriticalSection@@QAEHXZ ; CCriticalSection::Lock

; 956  : 	m_vPtQueue.push_back(pt);

  0325e	8d 55 f8	 lea	 edx, DWORD PTR _pt$[ebp]
  03261	52		 push	 edx
  03262	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  03265	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  0326b	e8 00 00 00 00	 call	 ?push_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXABVCPoint@@@Z ; std::deque<CPoint,std::allocator<CPoint> >::push_back

; 957  : 	m_csLockV.Unlock();

  03270	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  03273	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  03279	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0327c	8b 90 b4 00 00
	00		 mov	 edx, DWORD PTR [eax+180]
  03282	ff 52 1c	 call	 DWORD PTR [edx+28]

; 958  : }

  03285	8b e5		 mov	 esp, ebp
  03287	5d		 pop	 ebp
  03288	c2 04 00	 ret	 4
?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ENDP	; CLocalMusicCoverList::EnsureVisible
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
PUBLIC	??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::iterator::operator--
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
EXTRN	?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z:NEAR ; CWnd::PreTranslateMessage
xdata$x	SEGMENT
$T203327 DD	0ffffffffH
	DD	FLAT:$L203320
	DD	0ffffffffH
	DD	FLAT:$L203321
	DD	0ffffffffH
	DD	FLAT:$L203322
	DD	0ffffffffH
	DD	FLAT:$L203323
$T203325 DD	019930520H
	DD	04H
	DD	FLAT:$T203327
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv211 = -152						; size = 4
tv141 = -148						; size = 4
_this$ = -144						; size = 4
$T203319 = -140						; size = 4
$T203318 = -136						; size = 4
$T203317 = -132						; size = 4
$T203316 = -128						; size = 4
$T203315 = -124						; size = 4
$T203314 = -120						; size = 4
$T203313 = -116						; size = 4
$T203312 = -112						; size = 4
$T203311 = -108						; size = 4
$T203310 = -104						; size = 4
$T203309 = -100						; size = 4
_iSel$201049 = -96					; size = 4
_vIndex$201042 = -92					; size = 16
_iSel$201036 = -76					; size = 4
_vIndex$201029 = -72					; size = 16
_isel$201023 = -56					; size = 4
_isel$201017 = -52					; size = 4
_vIndex$201012 = -48					; size = 16
_isel$201008 = -32					; size = 4
_vIndex$201001 = -28					; size = 16
__$EHRec$ = -12						; size = 12
_pMsg$ = 8						; size = 4
?PreTranslateMessage@CLocalMusicCoverList@@UAEHPAUtagMSG@@@Z PROC NEAR ; CLocalMusicCoverList::PreTranslateMessage
; _this$ = ecx

; 960  : {

  03290	55		 push	 ebp
  03291	8b ec		 mov	 ebp, esp
  03293	6a ff		 push	 -1
  03295	68 00 00 00 00	 push	 __ehhandler$?PreTranslateMessage@CLocalMusicCoverList@@UAEHPAUtagMSG@@@Z
  0329a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  032a0	50		 push	 eax
  032a1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  032a8	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  032ae	56		 push	 esi
  032af	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 961  : 	if(pMsg->message==WM_KEYDOWN)

  032b5	8b 45 08	 mov	 eax, DWORD PTR _pMsg$[ebp]
  032b8	81 78 04 00 01
	00 00		 cmp	 DWORD PTR [eax+4], 256	; 00000100H
  032bf	0f 85 2c 06 00
	00		 jne	 $L200998

; 962  : 	{
; 963  : 		if (pMsg->wParam==VK_LEFT)

  032c5	8b 4d 08	 mov	 ecx, DWORD PTR _pMsg$[ebp]
  032c8	83 79 08 25	 cmp	 DWORD PTR [ecx+8], 37	; 00000025H
  032cc	0f 85 4f 01 00
	00		 jne	 $L200999

; 964  : 		{
; 965  : 			vector<int> vIndex = GetSelectItem();

  032d2	8d 55 e4	 lea	 edx, DWORD PTR _vIndex$201001[ebp]
  032d5	52		 push	 edx
  032d6	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  032dc	e8 00 00 00 00	 call	 ?GetSelectItem@CLocalMusicCoverList@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@XZ ; CLocalMusicCoverList::GetSelectItem
  032e1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 966  : 			if(vIndex.size()==0) 

  032e8	8d 4d e4	 lea	 ecx, DWORD PTR _vIndex$201001[ebp]
  032eb	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  032f0	85 c0		 test	 eax, eax
  032f2	75 45		 jne	 SHORT $L201003

; 967  : 			{
; 968  : 				m_DataMgr.m_vItem[0].blSel = TRUE;

  032f4	6a 00		 push	 0
  032f6	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  032fc	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  03302	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  03307	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 969  : 				EnsureVisible(0);

  0330e	6a 00		 push	 0
  03310	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03316	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible

; 970  : 				return TRUE;

  0331b	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR $T203309[ebp], 1
  03322	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  03329	8d 4d e4	 lea	 ecx, DWORD PTR _vIndex$201001[ebp]
  0332c	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  03331	8b 45 9c	 mov	 eax, DWORD PTR $T203309[ebp]
  03334	e9 c7 05 00 00	 jmp	 $L200997
$L201003:

; 971  : 			}
; 972  : 			if (vIndex.size()>1)

  03339	8d 4d e4	 lea	 ecx, DWORD PTR _vIndex$201001[ebp]
  0333c	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  03341	83 f8 01	 cmp	 eax, 1
  03344	76 4a		 jbe	 SHORT $L201005

; 973  : 			{
; 974  : 				UnSelectAll();

  03346	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0334c	e8 00 00 00 00	 call	 ?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UnSelectAll

; 975  : 				m_DataMgr.m_vItem[vIndex[0]].blSel = TRUE;

  03351	6a 00		 push	 0
  03353	8d 4d e4	 lea	 ecx, DWORD PTR _vIndex$201001[ebp]
  03356	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  0335b	8b 00		 mov	 eax, DWORD PTR [eax]
  0335d	50		 push	 eax
  0335e	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03364	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0336a	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  0336f	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 976  : 				EnsureVisible(vIndex[0]);

  03376	6a 00		 push	 0
  03378	8d 4d e4	 lea	 ecx, DWORD PTR _vIndex$201001[ebp]
  0337b	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  03380	8b 08		 mov	 ecx, DWORD PTR [eax]
  03382	51		 push	 ecx
  03383	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03389	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible

; 977  : 			}
; 978  : 			else

  0338e	eb 73		 jmp	 SHORT $L201006
$L201005:

; 979  : 			{
; 980  : 				if (vIndex[0]>0)

  03390	6a 00		 push	 0
  03392	8d 4d e4	 lea	 ecx, DWORD PTR _vIndex$201001[ebp]
  03395	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  0339a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0339d	7e 64		 jle	 SHORT $L201006

; 981  : 				{
; 982  : 					UnSelectAll();

  0339f	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  033a5	e8 00 00 00 00	 call	 ?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UnSelectAll

; 983  : 					int isel=--vIndex[0];

  033aa	6a 00		 push	 0
  033ac	8d 4d e4	 lea	 ecx, DWORD PTR _vIndex$201001[ebp]
  033af	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  033b4	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv141[ebp], eax
  033ba	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR tv141[ebp]
  033c0	8b 02		 mov	 eax, DWORD PTR [edx]
  033c2	83 e8 01	 sub	 eax, 1
  033c5	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv141[ebp]
  033cb	89 01		 mov	 DWORD PTR [ecx], eax
  033cd	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR tv141[ebp]
  033d3	8b 02		 mov	 eax, DWORD PTR [edx]
  033d5	89 45 e0	 mov	 DWORD PTR _isel$201008[ebp], eax

; 984  : 					m_DataMgr.m_vItem[isel].blSel=TRUE;

  033d8	8b 4d e0	 mov	 ecx, DWORD PTR _isel$201008[ebp]
  033db	51		 push	 ecx
  033dc	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  033e2	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  033e8	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  033ed	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 985  : 					EnsureVisible(isel);

  033f4	8b 55 e0	 mov	 edx, DWORD PTR _isel$201008[ebp]
  033f7	52		 push	 edx
  033f8	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  033fe	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible
$L201006:

; 986  : 				}
; 987  : 			}
; 988  : 			//SetFocus();
; 989  : 			return 1;

  03403	c7 45 98 01 00
	00 00		 mov	 DWORD PTR $T203310[ebp], 1
  0340a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  03411	8d 4d e4	 lea	 ecx, DWORD PTR _vIndex$201001[ebp]
  03414	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  03419	8b 45 98	 mov	 eax, DWORD PTR $T203310[ebp]
  0341c	e9 df 04 00 00	 jmp	 $L200997
$L200999:

; 990  : 		}
; 991  : 		if (pMsg->wParam==VK_RIGHT)

  03421	8b 45 08	 mov	 eax, DWORD PTR _pMsg$[ebp]
  03424	83 78 08 27	 cmp	 DWORD PTR [eax+8], 39	; 00000027H
  03428	0f 85 a5 01 00
	00		 jne	 $L201010

; 992  : 		{
; 993  : 			vector<int> vIndex = GetSelectItem();

  0342e	8d 4d d0	 lea	 ecx, DWORD PTR _vIndex$201012[ebp]
  03431	51		 push	 ecx
  03432	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03438	e8 00 00 00 00	 call	 ?GetSelectItem@CLocalMusicCoverList@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@XZ ; CLocalMusicCoverList::GetSelectItem
  0343d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 994  : 			if(vIndex.size()==0) 

  03444	8d 4d d0	 lea	 ecx, DWORD PTR _vIndex$201012[ebp]
  03447	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  0344c	85 c0		 test	 eax, eax
  0344e	75 45		 jne	 SHORT $L201014

; 995  : 			{
; 996  : 				m_DataMgr.m_vItem[0].blSel = TRUE;

  03450	6a 00		 push	 0
  03452	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03458	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0345e	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  03463	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 997  : 				EnsureVisible(0);

  0346a	6a 00		 push	 0
  0346c	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03472	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible

; 998  : 				return TRUE;

  03477	c7 45 94 01 00
	00 00		 mov	 DWORD PTR $T203311[ebp], 1
  0347e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  03485	8d 4d d0	 lea	 ecx, DWORD PTR _vIndex$201012[ebp]
  03488	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0348d	8b 45 94	 mov	 eax, DWORD PTR $T203311[ebp]
  03490	e9 6b 04 00 00	 jmp	 $L200997
$L201014:

; 999  : 			}
; 1000 : 			if (vIndex.size()>1)

  03495	8d 4d d0	 lea	 ecx, DWORD PTR _vIndex$201012[ebp]
  03498	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  0349d	83 f8 01	 cmp	 eax, 1
  034a0	76 5a		 jbe	 SHORT $L201016

; 1001 : 			{
; 1002 : 				UnSelectAll();

  034a2	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  034a8	e8 00 00 00 00	 call	 ?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UnSelectAll

; 1003 : 				int isel=*(--vIndex.end());

  034ad	8d 55 90	 lea	 edx, DWORD PTR $T203312[ebp]
  034b0	52		 push	 edx
  034b1	8d 4d d0	 lea	 ecx, DWORD PTR _vIndex$201012[ebp]
  034b4	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  034b9	8b c8		 mov	 ecx, eax
  034bb	e8 00 00 00 00	 call	 ??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::iterator::operator--
  034c0	8b c8		 mov	 ecx, eax
  034c2	e8 00 00 00 00	 call	 ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
  034c7	8b 00		 mov	 eax, DWORD PTR [eax]
  034c9	89 45 cc	 mov	 DWORD PTR _isel$201017[ebp], eax

; 1004 : 				m_DataMgr.m_vItem[isel].blSel=TRUE;

  034cc	8b 4d cc	 mov	 ecx, DWORD PTR _isel$201017[ebp]
  034cf	51		 push	 ecx
  034d0	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  034d6	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  034dc	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  034e1	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 1005 : 				EnsureVisible(isel);

  034e8	8b 55 cc	 mov	 edx, DWORD PTR _isel$201017[ebp]
  034eb	52		 push	 edx
  034ec	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  034f2	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible

; 1006 : 			}
; 1007 : 			else if(vIndex.size()==1)

  034f7	e9 b9 00 00 00	 jmp	 $L201019
$L201016:
  034fc	8d 4d d0	 lea	 ecx, DWORD PTR _vIndex$201012[ebp]
  034ff	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  03504	83 f8 01	 cmp	 eax, 1
  03507	0f 85 a8 00 00
	00		 jne	 $L201019

; 1008 : 			{
; 1009 : 				if (*(--vIndex.end())<m_DataMgr.m_vItem.size()-1)

  0350d	8d 45 8c	 lea	 eax, DWORD PTR $T203313[ebp]
  03510	50		 push	 eax
  03511	8d 4d d0	 lea	 ecx, DWORD PTR _vIndex$201012[ebp]
  03514	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  03519	8b c8		 mov	 ecx, eax
  0351b	e8 00 00 00 00	 call	 ??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::iterator::operator--
  03520	8b c8		 mov	 ecx, eax
  03522	e8 00 00 00 00	 call	 ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
  03527	8b f0		 mov	 esi, eax
  03529	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0352f	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  03535	e8 00 00 00 00	 call	 ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
  0353a	83 e8 01	 sub	 eax, 1
  0353d	39 06		 cmp	 DWORD PTR [esi], eax
  0353f	73 74		 jae	 SHORT $L201019

; 1010 : 				{
; 1011 : 					UnSelectAll();

  03541	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03547	e8 00 00 00 00	 call	 ?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UnSelectAll

; 1012 : 					int isel=++*(--vIndex.end());

  0354c	8d 4d 88	 lea	 ecx, DWORD PTR $T203314[ebp]
  0354f	51		 push	 ecx
  03550	8d 4d d0	 lea	 ecx, DWORD PTR _vIndex$201012[ebp]
  03553	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  03558	8b c8		 mov	 ecx, eax
  0355a	e8 00 00 00 00	 call	 ??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::iterator::operator--
  0355f	8b c8		 mov	 ecx, eax
  03561	e8 00 00 00 00	 call	 ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
  03566	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv211[ebp], eax
  0356c	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv211[ebp]
  03572	8b 02		 mov	 eax, DWORD PTR [edx]
  03574	83 c0 01	 add	 eax, 1
  03577	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv211[ebp]
  0357d	89 01		 mov	 DWORD PTR [ecx], eax
  0357f	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv211[ebp]
  03585	8b 02		 mov	 eax, DWORD PTR [edx]
  03587	89 45 c8	 mov	 DWORD PTR _isel$201023[ebp], eax

; 1013 : 					m_DataMgr.m_vItem[isel].blSel=TRUE;

  0358a	8b 4d c8	 mov	 ecx, DWORD PTR _isel$201023[ebp]
  0358d	51		 push	 ecx
  0358e	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03594	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0359a	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  0359f	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 1014 : 					EnsureVisible(isel);

  035a6	8b 55 c8	 mov	 edx, DWORD PTR _isel$201023[ebp]
  035a9	52		 push	 edx
  035aa	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  035b0	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible
$L201019:

; 1015 : 				}
; 1016 : 			}
; 1017 : 			//SetFocus();
; 1018 : 			return TRUE;

  035b5	c7 45 84 01 00
	00 00		 mov	 DWORD PTR $T203315[ebp], 1
  035bc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  035c3	8d 4d d0	 lea	 ecx, DWORD PTR _vIndex$201012[ebp]
  035c6	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  035cb	8b 45 84	 mov	 eax, DWORD PTR $T203315[ebp]
  035ce	e9 2d 03 00 00	 jmp	 $L200997
$L201010:

; 1019 : 		}
; 1020 : 		else if (pMsg->wParam==VK_UP)

  035d3	8b 45 08	 mov	 eax, DWORD PTR _pMsg$[ebp]
  035d6	83 78 08 26	 cmp	 DWORD PTR [eax+8], 38	; 00000026H
  035da	0f 85 6c 01 00
	00		 jne	 $L201027

; 1021 : 		{
; 1022 : 			vector<int> vIndex = GetSelectItem();

  035e0	8d 4d b8	 lea	 ecx, DWORD PTR _vIndex$201029[ebp]
  035e3	51		 push	 ecx
  035e4	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  035ea	e8 00 00 00 00	 call	 ?GetSelectItem@CLocalMusicCoverList@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@XZ ; CLocalMusicCoverList::GetSelectItem
  035ef	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 1023 : 			if(vIndex.size()==0) 

  035f6	8d 4d b8	 lea	 ecx, DWORD PTR _vIndex$201029[ebp]
  035f9	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  035fe	85 c0		 test	 eax, eax
  03600	75 50		 jne	 SHORT $L201031

; 1024 : 			{
; 1025 : 				m_DataMgr.m_vItem[0].blSel = TRUE;

  03602	6a 00		 push	 0
  03604	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0360a	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  03610	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  03615	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 1026 : 				EnsureVisible(0);

  0361c	6a 00		 push	 0
  0361e	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03624	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible

; 1027 : 				return CWnd::PreTranslateMessage(pMsg);

  03629	8b 55 08	 mov	 edx, DWORD PTR _pMsg$[ebp]
  0362c	52		 push	 edx
  0362d	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03633	e8 00 00 00 00	 call	 ?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z ; CWnd::PreTranslateMessage
  03638	89 45 80	 mov	 DWORD PTR $T203316[ebp], eax
  0363b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  03642	8d 4d b8	 lea	 ecx, DWORD PTR _vIndex$201029[ebp]
  03645	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0364a	8b 45 80	 mov	 eax, DWORD PTR $T203316[ebp]
  0364d	e9 ae 02 00 00	 jmp	 $L200997
$L201031:

; 1028 : 			}
; 1029 : 			if (vIndex.size()>1)

  03652	8d 4d b8	 lea	 ecx, DWORD PTR _vIndex$201029[ebp]
  03655	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  0365a	83 f8 01	 cmp	 eax, 1
  0365d	76 4a		 jbe	 SHORT $L201033

; 1030 : 			{
; 1031 : 				UnSelectAll();

  0365f	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03665	e8 00 00 00 00	 call	 ?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UnSelectAll

; 1032 : 				m_DataMgr.m_vItem[vIndex[0]].blSel=TRUE;

  0366a	6a 00		 push	 0
  0366c	8d 4d b8	 lea	 ecx, DWORD PTR _vIndex$201029[ebp]
  0366f	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  03674	8b 00		 mov	 eax, DWORD PTR [eax]
  03676	50		 push	 eax
  03677	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0367d	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  03683	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  03688	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 1033 : 				EnsureVisible(vIndex[0]);

  0368f	6a 00		 push	 0
  03691	8d 4d b8	 lea	 ecx, DWORD PTR _vIndex$201029[ebp]
  03694	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  03699	8b 08		 mov	 ecx, DWORD PTR [eax]
  0369b	51		 push	 ecx
  0369c	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  036a2	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible

; 1034 : 			}
; 1035 : 			else if(vIndex.size()==1)

  036a7	eb 7f		 jmp	 SHORT $L201034
$L201033:
  036a9	8d 4d b8	 lea	 ecx, DWORD PTR _vIndex$201029[ebp]
  036ac	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  036b1	83 f8 01	 cmp	 eax, 1
  036b4	75 72		 jne	 SHORT $L201034

; 1036 : 			{
; 1037 : 				UnSelectAll();

  036b6	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  036bc	e8 00 00 00 00	 call	 ?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UnSelectAll

; 1038 : 				int iSel=vIndex[0]-m_rect.Width()/(m_iItemWidth+SPACEW);

  036c1	6a 00		 push	 0
  036c3	8d 4d b8	 lea	 ecx, DWORD PTR _vIndex$201029[ebp]
  036c6	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  036cb	8b f0		 mov	 esi, eax
  036cd	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  036d3	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  036d9	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  036de	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  036e4	8b 4a 54	 mov	 ecx, DWORD PTR [edx+84]
  036e7	83 c1 10	 add	 ecx, 16			; 00000010H
  036ea	99		 cdq
  036eb	f7 f9		 idiv	 ecx
  036ed	8b 16		 mov	 edx, DWORD PTR [esi]
  036ef	2b d0		 sub	 edx, eax
  036f1	89 55 b4	 mov	 DWORD PTR _iSel$201036[ebp], edx

; 1039 : 				if (iSel<0) iSel=0;

  036f4	79 07		 jns	 SHORT $L201037
  036f6	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _iSel$201036[ebp], 0
$L201037:

; 1040 : 				m_DataMgr.m_vItem[iSel].blSel = TRUE;

  036fd	8b 45 b4	 mov	 eax, DWORD PTR _iSel$201036[ebp]
  03700	50		 push	 eax
  03701	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03707	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0370d	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  03712	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 1041 : 				EnsureVisible(iSel);

  03719	8b 4d b4	 mov	 ecx, DWORD PTR _iSel$201036[ebp]
  0371c	51		 push	 ecx
  0371d	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03723	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible
$L201034:

; 1042 : 			}
; 1043 : 			//SetFocus();
; 1044 : 			return TRUE;

  03728	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T203317[ebp], 1
  03732	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  03739	8d 4d b8	 lea	 ecx, DWORD PTR _vIndex$201029[ebp]
  0373c	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  03741	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T203317[ebp]
  03747	e9 b4 01 00 00	 jmp	 $L200997
$L201027:

; 1045 : 		}
; 1046 : 		else if (pMsg->wParam==VK_DOWN)

  0374c	8b 55 08	 mov	 edx, DWORD PTR _pMsg$[ebp]
  0374f	83 7a 08 28	 cmp	 DWORD PTR [edx+8], 40	; 00000028H
  03753	0f 85 98 01 00
	00		 jne	 $L200998

; 1047 : 		{
; 1048 : 			vector<int> vIndex = GetSelectItem();

  03759	8d 45 a4	 lea	 eax, DWORD PTR _vIndex$201042[ebp]
  0375c	50		 push	 eax
  0375d	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03763	e8 00 00 00 00	 call	 ?GetSelectItem@CLocalMusicCoverList@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@XZ ; CLocalMusicCoverList::GetSelectItem
  03768	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 1049 : 			if(vIndex.size()==0) 

  0376f	8d 4d a4	 lea	 ecx, DWORD PTR _vIndex$201042[ebp]
  03772	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  03777	85 c0		 test	 eax, eax
  03779	75 56		 jne	 SHORT $L201044

; 1050 : 			{
; 1051 : 				m_DataMgr.m_vItem[0].blSel = TRUE;

  0377b	6a 00		 push	 0
  0377d	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03783	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  03789	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  0378e	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 1052 : 				EnsureVisible(0);

  03795	6a 00		 push	 0
  03797	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0379d	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible

; 1053 : 				return CWnd::PreTranslateMessage(pMsg);

  037a2	8b 4d 08	 mov	 ecx, DWORD PTR _pMsg$[ebp]
  037a5	51		 push	 ecx
  037a6	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  037ac	e8 00 00 00 00	 call	 ?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z ; CWnd::PreTranslateMessage
  037b1	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T203318[ebp], eax
  037b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  037be	8d 4d a4	 lea	 ecx, DWORD PTR _vIndex$201042[ebp]
  037c1	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  037c6	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T203318[ebp]
  037cc	e9 2f 01 00 00	 jmp	 $L200997
$L201044:

; 1054 : 			}
; 1055 : 			if (vIndex.size()>1)

  037d1	8d 4d a4	 lea	 ecx, DWORD PTR _vIndex$201042[ebp]
  037d4	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  037d9	83 f8 01	 cmp	 eax, 1
  037dc	76 4d		 jbe	 SHORT $L201046

; 1056 : 			{
; 1057 : 				UnSelectAll();

  037de	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  037e4	e8 00 00 00 00	 call	 ?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UnSelectAll

; 1058 : 				m_DataMgr.m_vItem[vIndex[0]].blSel=TRUE;

  037e9	6a 00		 push	 0
  037eb	8d 4d a4	 lea	 ecx, DWORD PTR _vIndex$201042[ebp]
  037ee	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  037f3	8b 10		 mov	 edx, DWORD PTR [eax]
  037f5	52		 push	 edx
  037f6	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  037fc	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  03802	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  03807	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 1059 : 				EnsureVisible(vIndex[0]);

  0380e	6a 00		 push	 0
  03810	8d 4d a4	 lea	 ecx, DWORD PTR _vIndex$201042[ebp]
  03813	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  03818	8b 00		 mov	 eax, DWORD PTR [eax]
  0381a	50		 push	 eax
  0381b	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03821	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible

; 1060 : 			}
; 1061 : 			else if(vIndex.size()==1)

  03826	e9 a5 00 00 00	 jmp	 $L201047
$L201046:
  0382b	8d 4d a4	 lea	 ecx, DWORD PTR _vIndex$201042[ebp]
  0382e	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  03833	83 f8 01	 cmp	 eax, 1
  03836	0f 85 94 00 00
	00		 jne	 $L201047

; 1062 : 			{
; 1063 : 				UnSelectAll();

  0383c	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03842	e8 00 00 00 00	 call	 ?UnSelectAll@CLocalMusicCoverList@@IAEXXZ ; CLocalMusicCoverList::UnSelectAll

; 1064 : 				int iSel=vIndex[0]+m_rect.Width()/(m_iItemWidth+SPACEW);

  03847	6a 00		 push	 0
  03849	8d 4d a4	 lea	 ecx, DWORD PTR _vIndex$201042[ebp]
  0384c	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  03851	8b f0		 mov	 esi, eax
  03853	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03859	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0385f	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  03864	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0386a	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  0386d	83 c1 10	 add	 ecx, 16			; 00000010H
  03870	99		 cdq
  03871	f7 f9		 idiv	 ecx
  03873	03 06		 add	 eax, DWORD PTR [esi]
  03875	89 45 a0	 mov	 DWORD PTR _iSel$201049[ebp], eax

; 1065 : 				if (iSel>=m_DataMgr.m_vItem.size())

  03878	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0387e	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  03884	e8 00 00 00 00	 call	 ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
  03889	39 45 a0	 cmp	 DWORD PTR _iSel$201049[ebp], eax
  0388c	72 17		 jb	 SHORT $L201050

; 1066 : 				{
; 1067 : 					iSel=m_DataMgr.m_vItem.size()-1;

  0388e	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  03894	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0389a	e8 00 00 00 00	 call	 ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
  0389f	83 e8 01	 sub	 eax, 1
  038a2	89 45 a0	 mov	 DWORD PTR _iSel$201049[ebp], eax
$L201050:

; 1068 : 				}
; 1069 : 				m_DataMgr.m_vItem[iSel].blSel = TRUE;

  038a5	8b 55 a0	 mov	 edx, DWORD PTR _iSel$201049[ebp]
  038a8	52		 push	 edx
  038a9	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  038af	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  038b5	e8 00 00 00 00	 call	 ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
  038ba	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 1070 : 				EnsureVisible(iSel);

  038c1	8b 45 a0	 mov	 eax, DWORD PTR _iSel$201049[ebp]
  038c4	50		 push	 eax
  038c5	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  038cb	e8 00 00 00 00	 call	 ?EnsureVisible@CLocalMusicCoverList@@QAEXH@Z ; CLocalMusicCoverList::EnsureVisible
$L201047:

; 1071 : 			}
; 1072 : 			//SetFocus();
; 1073 : 			return TRUE;

  038d0	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T203319[ebp], 1
  038da	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  038e1	8d 4d a4	 lea	 ecx, DWORD PTR _vIndex$201042[ebp]
  038e4	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  038e9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T203319[ebp]
  038ef	eb 0f		 jmp	 SHORT $L200997
$L200998:

; 1074 : 		}
; 1075 : 	}	
; 1076 : 	return CWnd::PreTranslateMessage(pMsg);

  038f1	8b 4d 08	 mov	 ecx, DWORD PTR _pMsg$[ebp]
  038f4	51		 push	 ecx
  038f5	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  038fb	e8 00 00 00 00	 call	 ?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z ; CWnd::PreTranslateMessage
$L200997:

; 1077 : }

  03900	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  03903	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0390a	5e		 pop	 esi
  0390b	8b e5		 mov	 esp, ebp
  0390d	5d		 pop	 ebp
  0390e	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L203320:
  002d4	8d 4d e4	 lea	 ecx, DWORD PTR _vIndex$201001[ebp]
  002d7	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
$L203321:
  002dc	8d 4d d0	 lea	 ecx, DWORD PTR _vIndex$201012[ebp]
  002df	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
$L203322:
  002e4	8d 4d b8	 lea	 ecx, DWORD PTR _vIndex$201029[ebp]
  002e7	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
$L203323:
  002ec	8d 4d a4	 lea	 ecx, DWORD PTR _vIndex$201042[ebp]
  002ef	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?PreTranslateMessage@CLocalMusicCoverList@@UAEHPAUtagMSG@@@Z:
  002f4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203325
  002f9	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?PreTranslateMessage@CLocalMusicCoverList@@UAEHPAUtagMSG@@@Z ENDP ; CLocalMusicCoverList::PreTranslateMessage
EXTRN	?OnSetFocus@CWnd@@IAEXPAV1@@Z:NEAR		; CWnd::OnSetFocus
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pOldWnd$ = 8						; size = 4
?OnSetFocus@CLocalMusicCoverList@@QAEXPAVCWnd@@@Z PROC NEAR ; CLocalMusicCoverList::OnSetFocus
; _this$ = ecx

; 1080 : {

  03920	55		 push	 ebp
  03921	8b ec		 mov	 ebp, esp
  03923	51		 push	 ecx
  03924	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1081 : 	CWnd::OnSetFocus(pOldWnd);

  03927	8b 45 08	 mov	 eax, DWORD PTR _pOldWnd$[ebp]
  0392a	50		 push	 eax
  0392b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0392e	e8 00 00 00 00	 call	 ?OnSetFocus@CWnd@@IAEXPAV1@@Z ; CWnd::OnSetFocus

; 1082 : }

  03933	8b e5		 mov	 esp, ebp
  03935	5d		 pop	 ebp
  03936	c2 04 00	 ret	 4
?OnSetFocus@CLocalMusicCoverList@@QAEXPAVCWnd@@@Z ENDP	; CLocalMusicCoverList::OnSetFocus
_TEXT	ENDS
PUBLIC	?OnKillFocus@CWnd@@IAEXPAV1@@Z			; CWnd::OnKillFocus
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pNewWnd$ = 8						; size = 4
?OnKillFocus@CLocalMusicCoverList@@QAEXPAVCWnd@@@Z PROC NEAR ; CLocalMusicCoverList::OnKillFocus
; _this$ = ecx

; 1085 : {

  03940	55		 push	 ebp
  03941	8b ec		 mov	 ebp, esp
  03943	51		 push	 ecx
  03944	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1086 : 	CWnd::OnKillFocus(pNewWnd);

  03947	8b 45 08	 mov	 eax, DWORD PTR _pNewWnd$[ebp]
  0394a	50		 push	 eax
  0394b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0394e	e8 00 00 00 00	 call	 ?OnKillFocus@CWnd@@IAEXPAV1@@Z ; CWnd::OnKillFocus

; 1087 : }

  03953	8b e5		 mov	 esp, ebp
  03955	5d		 pop	 ebp
  03956	c2 04 00	 ret	 4
?OnKillFocus@CLocalMusicCoverList@@QAEXPAVCWnd@@@Z ENDP	; CLocalMusicCoverList::OnKillFocus
_TEXT	ENDS
PUBLIC	?OnRButtonDown@CWnd@@IAEXIVCPoint@@@Z		; CWnd::OnRButtonDown
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nFlags$ = 8						; size = 4
_point$ = 12						; size = 8
?OnRButtonDown@CLocalMusicCoverList@@QAEXIVCPoint@@@Z PROC NEAR ; CLocalMusicCoverList::OnRButtonDown
; _this$ = ecx

; 1090 : {

  03960	55		 push	 ebp
  03961	8b ec		 mov	 ebp, esp
  03963	51		 push	 ecx
  03964	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1091 : 	// TODO: Add your message handler code here and/or call default
; 1092 : 	SetFocus();

  03967	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0396a	e8 00 00 00 00	 call	 ?SetFocus@CWnd@@QAEPAV1@XZ ; CWnd::SetFocus

; 1093 : 	CWnd::OnRButtonDown(nFlags, point);

  0396f	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp+4]
  03972	50		 push	 eax
  03973	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  03976	51		 push	 ecx
  03977	8b 55 08	 mov	 edx, DWORD PTR _nFlags$[ebp]
  0397a	52		 push	 edx
  0397b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0397e	e8 00 00 00 00	 call	 ?OnRButtonDown@CWnd@@IAEXIVCPoint@@@Z ; CWnd::OnRButtonDown

; 1094 : }

  03983	8b e5		 mov	 esp, ebp
  03985	5d		 pop	 ebp
  03986	c2 0c 00	 ret	 12			; 0000000cH
?OnRButtonDown@CLocalMusicCoverList@@QAEXIVCPoint@@@Z ENDP ; CLocalMusicCoverList::OnRButtonDown
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::end
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L203336
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L203337
$L203336:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L203337:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?size@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::size
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEAAU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator*
PUBLIC	??Hiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE?AV012@H@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator+
; Function compile flags: /Odt
;	COMDAT ??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T203341 = -8						; size = 4
$T203340 = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[], COMDAT
; _this$ = ecx

; 554  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		return (*(begin() + _Pos));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d f8	 lea	 ecx, DWORD PTR $T203341[ebp]
  00010	51		 push	 ecx
  00011	8d 55 fc	 lea	 edx, DWORD PTR $T203340[ebp]
  00014	52		 push	 edx
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?begin@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::begin
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ??Hiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE?AV012@H@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator+
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??Diterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEAAU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator*

; 556  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??A?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAU_tagLMCItemInfo@@I@Z ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$allocator@VCPoint@@@std@@QAE@XZ		; std::allocator<CPoint>::allocator<CPoint>
PUBLIC	??0?$_Deque_val@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z ; std::_Deque_val<CPoint,std::allocator<CPoint> >::_Deque_val<CPoint,std::allocator<CPoint> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\deque
;	COMDAT ??0?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::deque<CPoint,std::allocator<CPoint> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct empty deque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@VCPoint@@@std@@QAE@XZ ; std::allocator<CPoint>::allocator<CPoint>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Deque_val@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z ; std::_Deque_val<CPoint,std::allocator<CPoint> >::_Deque_val<CPoint,std::allocator<CPoint> >
  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0002d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00030	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  00037	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 328  : 		}

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??0?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::deque<CPoint,std::allocator<CPoint> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXXZ ; std::deque<CPoint,std::allocator<CPoint> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::~deque<CPoint,std::allocator<CPoint> >, COMDAT
; _this$ = ecx

; 413  : 		{	// destroy the deque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 414  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXXZ ; std::deque<CPoint,std::allocator<CPoint> >::_Tidy

; 415  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@XZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::~deque<CPoint,std::allocator<CPoint> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::size, COMDAT
; _this$ = ecx

; 491  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 492  : 		return (_Mysize);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 493  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::size
_TEXT	ENDS
PUBLIC	??Diterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEAAVCPoint@@XZ ; std::deque<CPoint,std::allocator<CPoint> >::iterator::operator*
PUBLIC	?begin@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE?AViterator@12@XZ ; std::deque<CPoint,std::allocator<CPoint> >::begin
; Function compile flags: /Odt
;	COMDAT ?front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEAAVCPoint@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T203351 = -8						; size = 8
?front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEAAVCPoint@@XZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::front, COMDAT
; _this$ = ecx

; 535  : 		{	// return first element of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 536  : 		return (*begin());

  00009	8d 45 f8	 lea	 eax, DWORD PTR $T203351[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?begin@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE?AViterator@12@XZ ; std::deque<CPoint,std::allocator<CPoint> >::begin
  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ??Diterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEAAVCPoint@@XZ ; std::deque<CPoint,std::allocator<CPoint> >::iterator::operator*

; 537  : 		}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEAAVCPoint@@XZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::front
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@@Z ; std::allocator<CPoint>::destroy
PUBLIC	?empty@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBE_NXZ ; std::deque<CPoint,std::allocator<CPoint> >::empty
; Function compile flags: /Odt
;	COMDAT ?pop_front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Block$201280 = -4					; size = 4
?pop_front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::pop_front, COMDAT
; _this$ = ecx

; 570  : 		{	// erase element at beginning

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 571  : 		if (!empty())

  0000a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?empty@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBE_NXZ ; std::deque<CPoint,std::allocator<CPoint> >::empty
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	0f 85 80 00 00
	00		 jne	 $L201278

; 572  : 			{	// something to erase, do it
; 573  : 			size_type _Block = _Myoff / _DEQUESIZ;

  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00023	d1 ea		 shr	 edx, 1
  00025	89 55 fc	 mov	 DWORD PTR __Block$201280[ebp], edx

; 574  : 			this->_Alval.destroy(_Map[_Block] + _Myoff % _DEQUESIZ);

  00028	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00034	33 d2		 xor	 edx, edx
  00036	be 02 00 00 00	 mov	 esi, 2
  0003b	f7 f6		 div	 esi
  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Block$201280[ebp]
  00040	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00043	8d 14 d1	 lea	 edx, DWORD PTR [ecx+edx*8]
  00046	52		 push	 edx
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	83 c1 01	 add	 ecx, 1
  0004d	e8 00 00 00 00	 call	 ?destroy@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@@Z ; std::allocator<CPoint>::destroy

; 575  : 			if (_Mapsize * _DEQUESIZ <= ++_Myoff)

  00052	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00058	83 c1 01	 add	 ecx, 1
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00067	d1 e1		 shl	 ecx, 1
  00069	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0006f	77 0a		 ja	 SHORT $L201281

; 576  : 				_Myoff = 0;

  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$L201281:

; 577  : 			if (--_Mysize == 0)

  0007b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00081	83 ea 01	 sub	 edx, 1
  00084	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00087	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00091	75 0a		 jne	 SHORT $L201278

; 578  : 				_Myoff = 0;

  00093	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00096	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$L201278:

; 579  : 			}
; 580  : 		}

  0009d	5e		 pop	 esi
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?pop_front@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::pop_front
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCPoint@@@std@@QAEPAVCPoint@@I@Z ; std::allocator<CPoint>::allocate
PUBLIC	?construct@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@ABV3@@Z ; std::allocator<CPoint>::construct
PUBLIC	?_Growmap@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXI@Z ; std::deque<CPoint,std::allocator<CPoint> >::_Growmap
; Function compile flags: /Odt
;	COMDAT ?push_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXABVCPoint@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Block$ = -8						; size = 4
__Newoff$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXABVCPoint@@@Z PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::push_back, COMDAT
; _this$ = ecx

; 583  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 584  : 		if ((_Myoff + _Mysize) % _DEQUESIZ == 0
; 585  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

  0000a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00016	33 d2		 xor	 edx, edx
  00018	b9 02 00 00 00	 mov	 ecx, 2
  0001d	f7 f1		 div	 ecx
  0001f	85 d2		 test	 edx, edx
  00021	75 1d		 jne	 SHORT $L201285
  00023	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00029	83 c0 02	 add	 eax, 2
  0002c	d1 e8		 shr	 eax, 1
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  00034	77 0a		 ja	 SHORT $L201285

; 586  : 			_Growmap(1);

  00036	6a 01		 push	 1
  00038	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Growmap@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXI@Z ; std::deque<CPoint,std::allocator<CPoint> >::_Growmap
$L201285:

; 587  : 		size_type _Newoff = _Myoff + _Mysize;

  00040	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00043	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00046	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  0004c	89 45 fc	 mov	 DWORD PTR __Newoff$[ebp], eax

; 588  : 		size_type _Block = _Newoff / _DEQUESIZ;

  0004f	8b 55 fc	 mov	 edx, DWORD PTR __Newoff$[ebp]
  00052	d1 ea		 shr	 edx, 1
  00054	89 55 f8	 mov	 DWORD PTR __Block$[ebp], edx

; 589  : 		if (_Mapsize <= _Block)

  00057	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005d	3b 4d f8	 cmp	 ecx, DWORD PTR __Block$[ebp]
  00060	77 0c		 ja	 SHORT $L201288

; 590  : 			_Block -= _Mapsize;

  00062	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 45 f8	 mov	 eax, DWORD PTR __Block$[ebp]
  00068	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  0006b	89 45 f8	 mov	 DWORD PTR __Block$[ebp], eax
$L201288:

; 591  : 		if (_Map[_Block] == 0)

  0006e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00074	8b 45 f8	 mov	 eax, DWORD PTR __Block$[ebp]
  00077	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  0007b	75 19		 jne	 SHORT $L201289

; 592  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

  0007d	6a 02		 push	 2
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	83 c1 01	 add	 ecx, 1
  00085	e8 00 00 00 00	 call	 ?allocate@?$allocator@VCPoint@@@std@@QAEPAVCPoint@@I@Z ; std::allocator<CPoint>::allocate
  0008a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00090	8b 4d f8	 mov	 ecx, DWORD PTR __Block$[ebp]
  00093	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$L201289:

; 593  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

  00096	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00099	52		 push	 edx
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a0	8b 45 fc	 mov	 eax, DWORD PTR __Newoff$[ebp]
  000a3	33 d2		 xor	 edx, edx
  000a5	be 02 00 00 00	 mov	 esi, 2
  000aa	f7 f6		 div	 esi
  000ac	8b 45 f8	 mov	 eax, DWORD PTR __Block$[ebp]
  000af	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  000b2	8d 14 d1	 lea	 edx, DWORD PTR [ecx+edx*8]
  000b5	52		 push	 edx
  000b6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	83 c1 01	 add	 ecx, 1
  000bc	e8 00 00 00 00	 call	 ?construct@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@ABV3@@Z ; std::allocator<CPoint>::construct

; 594  : 		++_Mysize;

  000c1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000c7	83 c1 01	 add	 ecx, 1
  000ca	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000cd	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 595  : 		}

  000d0	5e		 pop	 esi
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 04 00	 ret	 4
?push_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXABVCPoint@@@Z ENDP ; std::deque<CPoint,std::allocator<CPoint> >::push_back
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	??$_Ucopy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHVconst_iterator@01@0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<std::vector<int,std::allocator<int> >::const_iterator>
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203370 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T203372 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L203366
$T203371 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T203372
$T203368 DD	019930520H
	DD	02H
	DD	FLAT:$T203370
	DD	01H
	DD	FLAT:$T203371
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv134 = -44						; size = 4
tv133 = -40						; size = 4
tv132 = -36						; size = 4
_this$ = -32						; size = 4
$T203363 = -28						; size = 4
$T203362 = -24						; size = 4
$T203361 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 329  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  00025	51		 push	 ecx
  00026	8b cc		 mov	 ecx, esp
  00028	89 65 ec	 mov	 DWORD PTR $T203361[ebp], esp
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@ABV01@@Z ; std::allocator<int>::allocator<int>
  00034	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >

; 330  : 		if (_Buy(_Right.size()))

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003f	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00044	50		 push	 eax
  00045	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
  0004d	0f b6 c8	 movzx	 ecx, al
  00050	85 c9		 test	 ecx, ecx
  00052	74 5f		 je	 SHORT $L203365

; 331  : 			_TRY_BEGIN

  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 332  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

  0005b	8d 55 e8	 lea	 edx, DWORD PTR $T203362[ebp]
  0005e	52		 push	 edx
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00062	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  00067	89 45 dc	 mov	 DWORD PTR tv132[ebp], eax
  0006a	8d 45 e4	 lea	 eax, DWORD PTR $T203363[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00071	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
  00076	89 45 d8	 mov	 DWORD PTR tv133[ebp], eax
  00079	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 dc	 mov	 eax, DWORD PTR tv132[ebp]
  00083	8b 08		 mov	 ecx, DWORD PTR [eax]
  00085	51		 push	 ecx
  00086	8b 55 d8	 mov	 edx, DWORD PTR tv133[ebp]
  00089	8b 02		 mov	 eax, DWORD PTR [edx]
  0008b	50		 push	 eax
  0008c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ??$_Ucopy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHVconst_iterator@01@0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<std::vector<int,std::allocator<int> >::const_iterator>
  00094	89 45 d4	 mov	 DWORD PTR tv134[ebp], eax
  00097	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	8b 55 d4	 mov	 edx, DWORD PTR tv134[ebp]
  0009d	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000a0	eb 11		 jmp	 SHORT $L203365
$L203366:

; 333  : 			_CATCH_ALL
; 334  : 			_Tidy();

  000a2	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 335  : 			_RERAISE;

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203365:

; 336  : 			_CATCH_END

  000b3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 337  : 		}

  000ba	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
$L203360:
  000bd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203368
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Odt
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L203383
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 12		 jmp	 SHORT $L203384
$L203383:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	c1 f8 02	 sar	 eax, 2
  0002a	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L203384:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+
; Function compile flags: /Odt
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T203388 = -8						; size = 4
$T203387 = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC NEAR ; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 554  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		return (*(begin() + _Pos));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d f8	 lea	 ecx, DWORD PTR $T203388[ebp]
  00010	51		 push	 ecx
  00011	8d 55 fc	 lea	 edx, DWORD PTR $T203387[ebp]
  00014	52		 push	 edx
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*

; 556  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Odt
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T203392 = -8						; size = 4
$T203391 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0000a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00012	8b f0		 mov	 esi, eax
  00014	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  0001c	3b f0		 cmp	 esi, eax
  0001e	73 1d		 jae	 SHORT $L201328

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	50		 push	 eax
  00024	6a 01		 push	 1
  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	52		 push	 edx
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  0003b	eb 1f		 jmp	 SHORT $L201327
$L201328:

; 583  : 			insert(end(), _Val);

  0003d	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00040	52		 push	 edx
  00041	8d 45 fc	 lea	 eax, DWORD PTR $T203391[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	51		 push	 ecx
  00050	8d 55 f8	 lea	 edx, DWORD PTR $T203392[ebp]
  00053	52		 push	 edx
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$L201327:

; 584  : 		}

  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Citerator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEPAU_tagLMCItemInfo@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Citerator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEPAU_tagLMCItemInfo@@XZ PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator->, COMDAT
; _this$ = ecx

; 224  : 			{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 225  : 			return (&**this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Diterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEAAU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator*

; 226  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Citerator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEPAU_tagLMCItemInfo@@XZ ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 236  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 237  : 			++*this;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator++

; 238  : 			return (_Tmp);

  00019	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 239  : 			}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator==
; Function compile flags: /Odt
;	COMDAT ??9const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 159  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 161  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::vector<int,std::allocator<int> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::vector<int,std::allocator<int> >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::vector<int,std::allocator<int> >::iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator--, COMDAT
; _this$ = ecx

; 242  : 			{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 243  : 			--this->_Myptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	83 e9 04	 sub	 ecx, 4
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 244  : 			return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 245  : 			}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<int,std::allocator<int> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator==
; Function compile flags: /Odt
;	COMDAT ??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 159  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 161  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z ; std::deque<CPoint,std::allocator<CPoint> >::iterator::iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\deque
;	COMDAT ?begin@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::begin, COMDAT
; _this$ = ecx

; 438  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 439  : 		return (iterator(_Myoff, this));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00011	52		 push	 edx
  00012	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00015	e8 00 00 00 00	 call	 ??0iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z ; std::deque<CPoint,std::allocator<CPoint> >::iterator::iterator
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 440  : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?begin@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?empty@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBE_NXZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::empty, COMDAT
; _this$ = ecx

; 501  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 502  : 		return (_Mysize == 0);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	0f 94 c1	 sete	 cl
  00013	8a c1		 mov	 al, cl

; 503  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?empty@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBE_NXZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::empty
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAPAVCPoint@@PAPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@@Z ; std::_Uninitialized_copy<CPoint * *,CPoint * *,std::allocator<CPoint *> >
PUBLIC	??$_Uninitialized_fill_n@PAPAVCPoint@@IPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@@Z ; std::_Uninitialized_fill_n<CPoint * *,unsigned int,CPoint *,std::allocator<CPoint *> >
PUBLIC	??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@@Z ; std::_Destroy_range<CPoint *,std::allocator<CPoint *> >
PUBLIC	?deallocate@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@I@Z ; std::allocator<CPoint *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCPoint@@@std@@QAEPAPAVCPoint@@I@Z ; std::allocator<CPoint *>::allocate
PUBLIC	?max_size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ ; std::deque<CPoint,std::allocator<CPoint> >::max_size
PUBLIC	?_Xlen@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IBEXXZ ; std::deque<CPoint,std::allocator<CPoint> >::_Xlen
; Function compile flags: /Odt
;	COMDAT ?_Growmap@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T203413 = -28						; size = 4
$T203412 = -24						; size = 4
$T203411 = -20						; size = 4
__Newmap$ = -16						; size = 4
__Myptr$ = -12						; size = 4
__Inc$ = -8						; size = 4
__Myboff$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXI@Z PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::_Growmap, COMDAT
; _this$ = ecx

; 907  : 		{	// grow map by _Count pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 908  : 		if (max_size() / _DEQUESIZ - _Mapsize < _Count)

  00009	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ ; std::deque<CPoint,std::allocator<CPoint> >::max_size
  00011	d1 e8		 shr	 eax, 1
  00013	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	2b 41 08	 sub	 eax, DWORD PTR [ecx+8]
  00019	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0001c	73 08		 jae	 SHORT $L201376

; 909  : 			_Xlen();	// result too long

  0001e	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Xlen@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IBEXXZ ; std::deque<CPoint,std::allocator<CPoint> >::_Xlen
$L201376:

; 910  : 
; 911  : 		size_type _Inc = _Mapsize / 2;	// try to grow by 50%

  00026	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002c	d1 e8		 shr	 eax, 1
  0002e	89 45 f8	 mov	 DWORD PTR __Inc$[ebp], eax

; 912  : 		if (_Inc < _DEQUEMAPSIZ)

  00031	83 7d f8 08	 cmp	 DWORD PTR __Inc$[ebp], 8
  00035	73 07		 jae	 SHORT $L201378

; 913  : 			_Inc = _DEQUEMAPSIZ;

  00037	c7 45 f8 08 00
	00 00		 mov	 DWORD PTR __Inc$[ebp], 8
$L201378:

; 914  : 		if (_Count < _Inc && _Mapsize <= max_size() / _DEQUESIZ - _Inc)

  0003e	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00041	3b 4d f8	 cmp	 ecx, DWORD PTR __Inc$[ebp]
  00044	73 1b		 jae	 SHORT $L201379
  00046	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?max_size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ ; std::deque<CPoint,std::allocator<CPoint> >::max_size
  0004e	d1 e8		 shr	 eax, 1
  00050	2b 45 f8	 sub	 eax, DWORD PTR __Inc$[ebp]
  00053	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00056	39 42 08	 cmp	 DWORD PTR [edx+8], eax
  00059	77 06		 ja	 SHORT $L201379

; 915  : 			_Count = _Inc;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR __Inc$[ebp]
  0005e	89 45 08	 mov	 DWORD PTR __Count$[ebp], eax
$L201379:

; 916  : 		size_type _Myboff = _Myoff / _DEQUESIZ;

  00061	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00067	d1 ea		 shr	 edx, 1
  00069	89 55 fc	 mov	 DWORD PTR __Myboff$[ebp], edx

; 917  : 		_Mapptr _Newmap = this->_Almap.allocate(_Mapsize + _Count);

  0006c	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00072	03 4d 08	 add	 ecx, DWORD PTR __Count$[ebp]
  00075	51		 push	 ecx
  00076	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAVCPoint@@@std@@QAEPAPAVCPoint@@I@Z ; std::allocator<CPoint *>::allocate
  0007e	89 45 f0	 mov	 DWORD PTR __Newmap$[ebp], eax

; 918  : 		_Mapptr _Myptr = _Newmap + _Myboff;

  00081	8b 55 fc	 mov	 edx, DWORD PTR __Myboff$[ebp]
  00084	8b 45 f0	 mov	 eax, DWORD PTR __Newmap$[ebp]
  00087	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0008a	89 4d f4	 mov	 DWORD PTR __Myptr$[ebp], ecx

; 919  : 
; 920  : 		_Myptr = _Uninitialized_copy(_Map + _Myboff,
; 921  : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

  0008d	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00090	52		 push	 edx
  00091	8b 45 f4	 mov	 eax, DWORD PTR __Myptr$[ebp]
  00094	50		 push	 eax
  00095	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0009b	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a1	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  000a4	52		 push	 edx
  000a5	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ab	8b 55 fc	 mov	 edx, DWORD PTR __Myboff$[ebp]
  000ae	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAPAVCPoint@@PAPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@@Z ; std::_Uninitialized_copy<CPoint * *,CPoint * *,std::allocator<CPoint *> >
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
  000ba	89 45 f4	 mov	 DWORD PTR __Myptr$[ebp], eax

; 922  : 		if (_Myboff <= _Count)

  000bd	8b 4d fc	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  000c0	3b 4d 08	 cmp	 ecx, DWORD PTR __Count$[ebp]
  000c3	77 6a		 ja	 SHORT $L201392

; 923  : 			{	// increment greater than offset of initial block
; 924  : 			_Myptr = _Uninitialized_copy(_Map,
; 925  : 				_Map + _Myboff, _Myptr, this->_Almap);	// copy rest of old

  000c5	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000c8	52		 push	 edx
  000c9	8b 45 f4	 mov	 eax, DWORD PTR __Myptr$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d3	8b 45 fc	 mov	 eax, DWORD PTR __Myboff$[ebp]
  000d6	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000d9	51		 push	 ecx
  000da	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000dd	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAPAVCPoint@@PAPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@@Z ; std::_Uninitialized_copy<CPoint * *,CPoint * *,std::allocator<CPoint *> >
  000e6	83 c4 10	 add	 esp, 16			; 00000010H
  000e9	89 45 f4	 mov	 DWORD PTR __Myptr$[ebp], eax

; 926  : 			_Uninitialized_fill_n(_Myptr, _Count - _Myboff,
; 927  : 				(_Tptr)0, this->_Almap);	// clear suffix of new

  000ec	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T203411[ebp], 0
  000f3	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	51		 push	 ecx
  000f7	8d 55 ec	 lea	 edx, DWORD PTR $T203411[ebp]
  000fa	52		 push	 edx
  000fb	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  000fe	2b 45 fc	 sub	 eax, DWORD PTR __Myboff$[ebp]
  00101	50		 push	 eax
  00102	8b 4d f4	 mov	 ecx, DWORD PTR __Myptr$[ebp]
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAPAVCPoint@@IPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@@Z ; std::_Uninitialized_fill_n<CPoint * *,unsigned int,CPoint *,std::allocator<CPoint *> >
  0010b	83 c4 10	 add	 esp, 16			; 00000010H

; 928  : 			_Uninitialized_fill_n(_Newmap, _Myboff,
; 929  : 				(_Tptr)0, this->_Almap);	// clear prefix of new

  0010e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T203412[ebp], 0
  00115	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00118	52		 push	 edx
  00119	8d 45 e8	 lea	 eax, DWORD PTR $T203412[ebp]
  0011c	50		 push	 eax
  0011d	8b 4d fc	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  00120	51		 push	 ecx
  00121	8b 55 f0	 mov	 edx, DWORD PTR __Newmap$[ebp]
  00124	52		 push	 edx
  00125	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAPAVCPoint@@IPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@@Z ; std::_Uninitialized_fill_n<CPoint * *,unsigned int,CPoint *,std::allocator<CPoint *> >
  0012a	83 c4 10	 add	 esp, 16			; 00000010H

; 930  : 			}
; 931  : 		else

  0012d	eb 70		 jmp	 SHORT $L201407
$L201392:

; 932  : 			{	// increment not greater than offset of initial block
; 933  : 			_Uninitialized_copy(_Map,
; 934  : 				_Map + _Count, _Myptr, this->_Almap);	// copy more old

  0012f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00132	50		 push	 eax
  00133	8b 4d f4	 mov	 ecx, DWORD PTR __Myptr$[ebp]
  00136	51		 push	 ecx
  00137	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0013a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0013d	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00140	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00143	52		 push	 edx
  00144	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00147	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014a	51		 push	 ecx
  0014b	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAPAVCPoint@@PAPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@@Z ; std::_Uninitialized_copy<CPoint * *,CPoint * *,std::allocator<CPoint *> >
  00150	83 c4 10	 add	 esp, 16			; 00000010H

; 935  : 			_Myptr = _Uninitialized_copy(_Map + _Count,
; 936  : 				_Map + _Myboff, _Newmap, this->_Almap);	// copy rest of old

  00153	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00156	52		 push	 edx
  00157	8b 45 f0	 mov	 eax, DWORD PTR __Newmap$[ebp]
  0015a	50		 push	 eax
  0015b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00161	8b 45 fc	 mov	 eax, DWORD PTR __Myboff$[ebp]
  00164	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  00167	51		 push	 ecx
  00168	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0016b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0016e	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00171	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00174	52		 push	 edx
  00175	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAPAVCPoint@@PAPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@@Z ; std::_Uninitialized_copy<CPoint * *,CPoint * *,std::allocator<CPoint *> >
  0017a	83 c4 10	 add	 esp, 16			; 00000010H
  0017d	89 45 f4	 mov	 DWORD PTR __Myptr$[ebp], eax

; 937  : 			_Uninitialized_fill_n(_Myptr, _Count,
; 938  : 				(_Tptr)0, this->_Almap);	// clear rest to initial block

  00180	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T203413[ebp], 0
  00187	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0018a	50		 push	 eax
  0018b	8d 4d e4	 lea	 ecx, DWORD PTR $T203413[ebp]
  0018e	51		 push	 ecx
  0018f	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00192	52		 push	 edx
  00193	8b 45 f4	 mov	 eax, DWORD PTR __Myptr$[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAPAVCPoint@@IPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@@Z ; std::_Uninitialized_fill_n<CPoint * *,unsigned int,CPoint *,std::allocator<CPoint *> >
  0019c	83 c4 10	 add	 esp, 16			; 00000010H
$L201407:

; 939  : 			}
; 940  : 
; 941  : 		_Destroy_range(_Map + _Myboff, _Map + _Mapsize, this->_Almap);

  0019f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	51		 push	 ecx
  001a3	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  001a6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001a9	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ac	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001af	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  001b2	50		 push	 eax
  001b3	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001b6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001b9	8b 45 fc	 mov	 eax, DWORD PTR __Myboff$[ebp]
  001bc	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  001bf	51		 push	 ecx
  001c0	e8 00 00 00 00	 call	 ??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@@Z ; std::_Destroy_range<CPoint *,std::allocator<CPoint *> >
  001c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 942  : 		if (_Map)

  001c8	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  001cb	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  001cf	74 16		 je	 SHORT $L201417

; 943  : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for old

  001d1	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  001d4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001d7	51		 push	 ecx
  001d8	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  001db	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001de	50		 push	 eax
  001df	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@I@Z ; std::allocator<CPoint *>::deallocate
$L201417:

; 944  : 
; 945  : 		_Map = _Newmap;	// point at new

  001e7	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ea	8b 55 f0	 mov	 edx, DWORD PTR __Newmap$[ebp]
  001ed	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 946  : 		_Mapsize += _Count;

  001f0	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  001f3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001f6	03 4d 08	 add	 ecx, DWORD PTR __Count$[ebp]
  001f9	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  001fc	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 947  : 		}

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c2 04 00	 ret	 4
?_Growmap@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXI@Z ENDP ; std::deque<CPoint,std::allocator<CPoint> >::_Growmap
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@I@Z ; std::allocator<CPoint>::deallocate
PUBLIC	?destroy@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@@Z ; std::allocator<CPoint *>::destroy
PUBLIC	?pop_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ ; std::deque<CPoint,std::allocator<CPoint> >::pop_back
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$201423 = -4					; size = 4
?_Tidy@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXXZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::_Tidy, COMDAT
; _this$ = ecx

; 950  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$L201421:

; 951  : 		while (!empty())

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?empty@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBE_NXZ ; std::deque<CPoint,std::allocator<CPoint> >::empty
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	75 0a		 jne	 SHORT $L201422

; 952  : 			pop_back();

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?pop_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ ; std::deque<CPoint,std::allocator<CPoint> >::pop_back
  00020	eb e7		 jmp	 SHORT $L201421
$L201422:

; 953  : 		for (size_type _Count = _Mapsize; 0 < _Count; )

  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00028	89 55 fc	 mov	 DWORD PTR __Count$201423[ebp], edx
$L201425:
  0002b	83 7d fc 00	 cmp	 DWORD PTR __Count$201423[ebp], 0
  0002f	76 49		 jbe	 SHORT $L201426

; 954  : 			{	// free storage for a block and destroy pointer
; 955  : 			if (*(_Map + --_Count) != 0)

  00031	8b 45 fc	 mov	 eax, DWORD PTR __Count$201423[ebp]
  00034	83 e8 01	 sub	 eax, 1
  00037	89 45 fc	 mov	 DWORD PTR __Count$201423[ebp], eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00040	8b 45 fc	 mov	 eax, DWORD PTR __Count$201423[ebp]
  00043	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  00047	74 1a		 je	 SHORT $L201427

; 956  : 				this->_Alval.deallocate(*(_Map + _Count), _DEQUESIZ);

  00049	6a 02		 push	 2
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00051	8b 45 fc	 mov	 eax, DWORD PTR __Count$201423[ebp]
  00054	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00057	51		 push	 ecx
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	83 c1 01	 add	 ecx, 1
  0005e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@I@Z ; std::allocator<CPoint>::deallocate
$L201427:

; 957  : 			this->_Almap.destroy(_Map + _Count);

  00063	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	8b 4d fc	 mov	 ecx, DWORD PTR __Count$201423[ebp]
  0006c	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  0006f	52		 push	 edx
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@@Z ; std::allocator<CPoint *>::destroy

; 958  : 			}

  00078	eb b1		 jmp	 SHORT $L201425
$L201426:

; 959  : 
; 960  : 		if (_Map)

  0007a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00081	74 16		 je	 SHORT $L201428

; 961  : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for map

  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00089	52		 push	 edx
  0008a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00090	51		 push	 ecx
  00091	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@I@Z ; std::allocator<CPoint *>::deallocate
$L201428:

; 962  : 		_Mapsize = 0;

  00099	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0009c	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 963  : 		_Map = 0;

  000a3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 964  : 		}

  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
?_Tidy@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAEXXZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Deque_map@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z ; std::_Deque_map<CPoint,std::allocator<CPoint> >::_Deque_map<CPoint,std::allocator<CPoint> >
PUBLIC	??0?$allocator@VCPoint@@@std@@QAE@ABV01@@Z	; std::allocator<CPoint>::allocator<CPoint>
; Function compile flags: /Odt
;	COMDAT ??0?$_Deque_val@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = 8						; size = 1
??0?$_Deque_val@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z PROC NEAR ; std::_Deque_val<CPoint,std::allocator<CPoint> >::_Deque_val<CPoint,std::allocator<CPoint> >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct allocator and base from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??0?$allocator@VCPoint@@@std@@QAE@ABV01@@Z ; std::allocator<CPoint>::allocator<CPoint>
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??0?$_Deque_map@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z ; std::_Deque_map<CPoint,std::allocator<CPoint> >::_Deque_map<CPoint,std::allocator<CPoint> >
  0001d	8d 4d 08	 lea	 ecx, DWORD PTR __Al$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 01	 add	 ecx, 1
  00027	e8 00 00 00 00	 call	 ??0?$allocator@VCPoint@@@std@@QAE@ABV01@@Z ; std::allocator<CPoint>::allocator<CPoint>

; 41   : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??0?$_Deque_val@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z ENDP ; std::_Deque_val<CPoint,std::allocator<CPoint> >::_Deque_val<CPoint,std::allocator<CPoint> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@VCPoint@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@VCPoint@@@std@@QAE@XZ PROC NEAR		; std::allocator<CPoint>::allocator<CPoint>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@VCPoint@@@std@@QAE@XZ ENDP		; std::allocator<CPoint>::allocator<CPoint>
_TEXT	ENDS
PUBLIC	??$_Allocate@VCPoint@@@std@@YAPAVCPoint@@IPAV1@@Z ; std::_Allocate<CPoint>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@VCPoint@@@std@@QAEPAVCPoint@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@VCPoint@@@std@@QAEPAVCPoint@@I@Z PROC NEAR ; std::allocator<CPoint>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@VCPoint@@@std@@YAPAVCPoint@@IPAV1@@Z ; std::_Allocate<CPoint>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@VCPoint@@@std@@QAEPAVCPoint@@I@Z ENDP ; std::allocator<CPoint>::allocate
_TEXT	ENDS
PUBLIC	??$_Construct@VCPoint@@V1@@std@@YAXPAVCPoint@@ABV1@@Z ; std::_Construct<CPoint,CPoint>
; Function compile flags: /Odt
;	COMDAT ?construct@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@ABV3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@ABV3@@Z PROC NEAR ; std::allocator<CPoint>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@VCPoint@@V1@@std@@YAXPAVCPoint@@ABV1@@Z ; std::_Construct<CPoint,CPoint>
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@ABV3@@Z ENDP ; std::allocator<CPoint>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@VCPoint@@@std@@YAXPAVCPoint@@@Z	; std::_Destroy<CPoint>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@@Z PROC NEAR ; std::allocator<CPoint>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@VCPoint@@@std@@YAXPAVCPoint@@@Z ; std::_Destroy<CPoint>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@@Z ENDP ; std::allocator<CPoint>::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L203429
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 12		 jmp	 SHORT $L203430
$L203429:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	c1 f8 02	 sar	 eax, 2
  0002a	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L203430:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 467  : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 468  : 		return (const_iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 469  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 477  : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 478  : 		return (const_iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 479  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<int,std::allocator<int> >::iterator::operator-
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odt
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
_this$ = -16						; size = 4
$T203440 = -12						; size = 4
$T203437 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00011	85 c0		 test	 eax, eax
  00013	75 09		 jne	 SHORT $L203438
  00015	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0001c	eb 18		 jmp	 SHORT $L203439
$L203438:
  0001e	8d 45 f8	 lea	 eax, DWORD PTR $T203437[ebp]
  00021	50		 push	 eax
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
  0002a	50		 push	 eax
  0002b	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002e	e8 00 00 00 00	 call	 ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<int,std::allocator<int> >::iterator::operator-
  00033	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$L203439:
  00036	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00039	89 4d fc	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0003c	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0003f	52		 push	 edx
  00040	6a 01		 push	 1
  00042	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00045	50		 push	 eax
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 623  : 		return (begin() + _Off);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	52		 push	 edx
  00056	8d 45 f4	 lea	 eax, DWORD PTR $T203440[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+
  00069	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odt
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L201476

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 49		 jmp	 SHORT $L201475
$L201476:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L201478

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 776  : 		else

  00044	eb 30		 jmp	 SHORT $L201477
$L201478:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00067	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0006d	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L201477:

; 781  : 			}
; 782  : 		return (true);

  00076	b0 01		 mov	 al, 1
$L201475:

; 783  : 		}

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 35		 je	 SHORT $L201482

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	c1 f9 02	 sar	 ecx, 2
  00035	51		 push	 ecx
  00036	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00039	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003c	50		 push	 eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate
$L201482:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Odt
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00022	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00025	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]

; 880  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC NEAR ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@ABV01@@Z ; std::allocator<int>::allocator<int>

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@H@std@@QAE@XZ PROC NEAR			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEABU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEAAU_tagLMCItemInfo@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEAAU_tagLMCItemInfo@@XZ PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEABU_tagLMCItemInfo@@XZ ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEAAU_tagLMCItemInfo@@XZ ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 			++this->_Myptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	83 c1 44	 add	 ecx, 68			; 00000044H
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 232  : 			}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??Eiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@H@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator+=
; Function compile flags: /Odt
;	COMDAT ??Hiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@H@Z ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator+
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 152  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 156  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator==
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+=
; Function compile flags: /Odt
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 152  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 156  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEABVCPoint@@XZ ; std::deque<CPoint,std::allocator<CPoint> >::const_iterator::operator*
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\deque
;	COMDAT ??Diterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEAAVCPoint@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEAAVCPoint@@XZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::iterator::operator*, COMDAT
; _this$ = ecx

; 246  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 247  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEABVCPoint@@XZ ; std::deque<CPoint,std::allocator<CPoint> >::const_iterator::operator*

; 248  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEAAVCPoint@@XZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::iterator::operator*
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initCX$ = 8						; size = 4
_initCY$ = 12						; size = 4
??0CSize@@QAE@HH@Z PROC NEAR				; CSize::CSize, COMDAT
; _this$ = ecx

; 24   : 	{ cx = initCX; cy = initCY; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _initCX$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _initCY$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0CSize@@QAE@HH@Z ENDP					; CSize::CSize
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCPoint@@@std@@QBEIXZ	; std::allocator<CPoint>::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\deque
;	COMDAT ?max_size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::max_size, COMDAT
; _this$ = ecx

; 496  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 497  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 01	 add	 ecx, 1
  0000d	e8 00 00 00 00	 call	 ?max_size@?$allocator@VCPoint@@@std@@QBEIXZ ; std::allocator<CPoint>::max_size

; 498  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?max_size@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEIXZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::max_size
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Block$201585 = -8					; size = 4
__Newoff$201584 = -4					; size = 4
?pop_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::pop_back, COMDAT
; _this$ = ecx

; 598  : 		{	// erase element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 599  : 		if (!empty())

  0000a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?empty@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBE_NXZ ; std::deque<CPoint,std::allocator<CPoint> >::empty
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 7b		 jne	 SHORT $L201582

; 600  : 			{	// something to erase, do it
; 601  : 			size_type _Newoff = _Mysize + _Myoff - 1;

  00019	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0001f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00025	8d 54 0a ff	 lea	 edx, DWORD PTR [edx+ecx-1]
  00029	89 55 fc	 mov	 DWORD PTR __Newoff$201584[ebp], edx

; 602  : 			size_type _Block = _Newoff / _DEQUESIZ;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR __Newoff$201584[ebp]
  0002f	d1 e8		 shr	 eax, 1
  00031	89 45 f8	 mov	 DWORD PTR __Block$201585[ebp], eax

; 603  : 			if (_Mapsize <= _Block)

  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003a	3b 55 f8	 cmp	 edx, DWORD PTR __Block$201585[ebp]
  0003d	77 0c		 ja	 SHORT $L201586

; 604  : 				_Block -= _Mapsize;

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d f8	 mov	 ecx, DWORD PTR __Block$201585[ebp]
  00045	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  00048	89 4d f8	 mov	 DWORD PTR __Block$201585[ebp], ecx
$L201586:

; 605  : 			this->_Alval.destroy(_Map[_Block] + _Newoff % _DEQUESIZ);

  0004b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00051	8b 45 fc	 mov	 eax, DWORD PTR __Newoff$201584[ebp]
  00054	33 d2		 xor	 edx, edx
  00056	be 02 00 00 00	 mov	 esi, 2
  0005b	f7 f6		 div	 esi
  0005d	8b 45 f8	 mov	 eax, DWORD PTR __Block$201585[ebp]
  00060	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00063	8d 14 d1	 lea	 edx, DWORD PTR [ecx+edx*8]
  00066	52		 push	 edx
  00067	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 01	 add	 ecx, 1
  0006d	e8 00 00 00 00	 call	 ?destroy@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@@Z ; std::allocator<CPoint>::destroy

; 606  : 			if (--_Mysize == 0)

  00072	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00075	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00078	83 e9 01	 sub	 ecx, 1
  0007b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0007e	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00081	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00084	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00088	75 0a		 jne	 SHORT $L201582

; 607  : 				_Myoff = 0;

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
$L201582:

; 608  : 			}
; 609  : 		}

  00094	5e		 pop	 esi
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?pop_back@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAEXXZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::pop_back
_TEXT	ENDS
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203487 DD	0ffffffffH
	DD	FLAT:$L203483
$T203485 DD	019930520H
	DD	01H
	DD	FLAT:$T203487
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
	ORG $-30
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?_Xlen@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T203482 = -80						; size = 28
$T203481 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IBEXXZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::_Xlen, COMDAT
; _this$ = ecx

; 897  : 		{	// report length error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 898  : 		_THROW(length_error, "deque<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T203482[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T203482[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T203481[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T203481[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203480:

; 899  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203483:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T203482[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203485
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IBEXXZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::_Xlen
PUBLIC	??$?0VCPoint@@@?$allocator@PAVCPoint@@@std@@QAE@ABV?$allocator@VCPoint@@@1@@Z ; std::allocator<CPoint *>::allocator<CPoint *><CPoint>
; Function compile flags: /Odt
;	COMDAT ??0?$_Deque_map@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Deque_map@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z PROC NEAR ; std::_Deque_map<CPoint,std::allocator<CPoint> >::_Deque_map<CPoint,std::allocator<CPoint> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$?0VCPoint@@@?$allocator@PAVCPoint@@@std@@QAE@ABV?$allocator@VCPoint@@@1@@Z ; std::allocator<CPoint *>::allocator<CPoint *><CPoint>

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Deque_map@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@IAE@V?$allocator@VCPoint@@@1@@Z ENDP ; std::_Deque_map<CPoint,std::allocator<CPoint> >::_Deque_map<CPoint,std::allocator<CPoint> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@VCPoint@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@VCPoint@@@std@@QAE@ABV01@@Z PROC NEAR	; std::allocator<CPoint>::allocator<CPoint>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@VCPoint@@@std@@QAE@ABV01@@Z ENDP		; std::allocator<CPoint>::allocator<CPoint>
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt
;	COMDAT ?deallocate@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@I@Z PROC NEAR ; std::allocator<CPoint>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@VCPoint@@@std@@QAEXPAVCPoint@@I@Z ENDP ; std::allocator<CPoint>::deallocate
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CPoint@@QAE@XZ PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 61   : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CPoint@@QAE@XZ ENDP					; CPoint::CPoint
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@I@Z PROC NEAR ; std::allocator<CPoint *>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@I@Z ENDP ; std::allocator<CPoint *>::deallocate
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initX$ = 8						; size = 4
_initY$ = 12						; size = 4
??0CPoint@@QAE@HH@Z PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 63   : 	{ x = initX; y = initY; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _initX$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _initY$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0CPoint@@QAE@HH@Z ENDP				; CPoint::CPoint
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCPoint@@@std@@YAPAPAVCPoint@@IPAPAV1@@Z ; std::_Allocate<CPoint *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCPoint@@@std@@QAEPAPAVCPoint@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCPoint@@@std@@QAEPAPAVCPoint@@I@Z PROC NEAR ; std::allocator<CPoint *>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@PAVCPoint@@@std@@YAPAPAVCPoint@@IPAPAV1@@Z ; std::_Allocate<CPoint *>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@PAVCPoint@@@std@@QAEPAPAVCPoint@@I@Z ENDP ; std::allocator<CPoint *>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAVCPoint@@@std@@YAXPAPAVCPoint@@@Z	; std::_Destroy<CPoint *>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@@Z PROC NEAR ; std::allocator<CPoint *>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@PAVCPoint@@@std@@YAXPAPAVCPoint@@@Z ; std::_Destroy<CPoint *>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@PAVCPoint@@@std@@QAEXPAPAVCPoint@@@Z ENDP ; std::allocator<CPoint *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@H@std@@QBEIXZ ; std::allocator<int>::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
PUBLIC	??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z	; std::copy_backward<int *,int *>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203521 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T203523 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L203515
$T203524 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L203517
$T203522 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T203523
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T203524
$T203519 DD	019930520H
	DD	04H
	DD	FLAT:$T203521
	DD	02H
	DD	FLAT:$T203522
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
_TEXT	SEGMENT
tv240 = -52						; size = 4
tv239 = -48						; size = 4
tv85 = -44						; size = 4
_this$ = -40						; size = 4
__Oldend$201664 = -36					; size = 4
__Newvec$201643 = -32					; size = 4
__Ptr$201644 = -28					; size = 4
__Capacity$ = -24					; size = 4
__Tmp$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 24	 sub	 esp, 36			; 00000024H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00025	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d ec	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 811  : 		size_type _Capacity = capacity();

  0002d	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  00035	89 45 e8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  00038	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0003c	75 05		 jne	 SHORT $L201637

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0003e	e9 c6 02 00 00	 jmp	 $L203511
$L201637:
  00043	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  0004b	8b f0		 mov	 esi, eax
  0004d	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00055	2b c6		 sub	 eax, esi
  00057	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0005a	73 0d		 jae	 SHORT $L201639

; 816  : 			_Xlen();	// result too long

  0005c	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  00064	e9 a0 02 00 00	 jmp	 $L203511
$L201639:
  00069	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00071	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00074	39 45 e8	 cmp	 DWORD PTR __Capacity$[ebp], eax
  00077	0f 83 66 01 00
	00		 jae	 $L201641

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0007d	8b 75 e8	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00080	d1 ee		 shr	 esi, 1
  00082	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  0008a	2b c6		 sub	 eax, esi
  0008c	3b 45 e8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0008f	73 09		 jae	 SHORT $L203512
  00091	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  00098	eb 0b		 jmp	 SHORT $L203513
$L203512:
  0009a	8b 55 e8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0009d	d1 ea		 shr	 edx, 1
  0009f	03 55 e8	 add	 edx, DWORD PTR __Capacity$[ebp]
  000a2	89 55 d4	 mov	 DWORD PTR tv85[ebp], edx
$L203513:
  000a5	8b 45 d4	 mov	 eax, DWORD PTR tv85[ebp]
  000a8	89 45 e8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 821  : 			if (_Capacity < size() + _Count)

  000ab	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  000b3	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000b6	39 45 e8	 cmp	 DWORD PTR __Capacity$[ebp], eax
  000b9	73 0e		 jae	 SHORT $L201642

; 822  : 				_Capacity = size() + _Count;

  000bb	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  000c3	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000c6	89 45 e8	 mov	 DWORD PTR __Capacity$[ebp], eax
$L201642:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000c9	8b 4d e8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  000cc	51		 push	 ecx
  000cd	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate
  000d5	89 45 e0	 mov	 DWORD PTR __Newvec$201643[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  000d8	8b 55 e0	 mov	 edx, DWORD PTR __Newvec$201643[ebp]
  000db	89 55 e4	 mov	 DWORD PTR __Ptr$201644[ebp], edx

; 825  : 
; 826  : 			_TRY_BEGIN

  000de	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000e5	8b 45 e0	 mov	 eax, DWORD PTR __Newvec$201643[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  000ec	51		 push	 ecx
  000ed	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  000f0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f3	50		 push	 eax
  000f4	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
  000fc	89 45 d0	 mov	 DWORD PTR tv239[ebp], eax
  000ff	8b 4d d0	 mov	 ecx, DWORD PTR tv239[ebp]
  00102	89 4d e4	 mov	 DWORD PTR __Ptr$201644[ebp], ecx

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00105	8d 55 ec	 lea	 edx, DWORD PTR __Tmp$[ebp]
  00108	52		 push	 edx
  00109	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0010c	50		 push	 eax
  0010d	8b 4d e4	 mov	 ecx, DWORD PTR __Ptr$201644[ebp]
  00110	51		 push	 ecx
  00111	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00114	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
  00119	89 45 cc	 mov	 DWORD PTR tv240[ebp], eax
  0011c	8b 55 cc	 mov	 edx, DWORD PTR tv240[ebp]
  0011f	89 55 e4	 mov	 DWORD PTR __Ptr$201644[ebp], edx

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$201644[ebp]
  00125	50		 push	 eax
  00126	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0012c	52		 push	 edx
  0012d	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00130	50		 push	 eax
  00131	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00134	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
  00139	eb 29		 jmp	 SHORT $L203514
$L203515:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  0013b	8b 4d e4	 mov	 ecx, DWORD PTR __Ptr$201644[ebp]
  0013e	51		 push	 ecx
  0013f	8b 55 e0	 mov	 edx, DWORD PTR __Newvec$201643[ebp]
  00142	52		 push	 edx
  00143	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  0014b	8b 45 e8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  0014e	50		 push	 eax
  0014f	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$201643[ebp]
  00152	51		 push	 ecx
  00153	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate

; 834  : 			_RERAISE;

  0015b	6a 00		 push	 0
  0015d	6a 00		 push	 0
  0015f	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203514:

; 835  : 			_CATCH_END

  00164	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 836  : 
; 837  : 			_Count += size();

  0016b	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00173	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00176	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  00179	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0017c	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00180	74 35		 je	 SHORT $L201651

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  00182	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00185	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00188	51		 push	 ecx
  00189	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0018c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0018f	50		 push	 eax
  00190	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00198	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0019b	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0019e	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  001a1	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  001a4	c1 f8 02	 sar	 eax, 2
  001a7	50		 push	 eax
  001a8	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001ae	52		 push	 edx
  001af	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate
$L201651:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001b7	8b 45 e8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  001ba	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$201643[ebp]
  001bd	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  001c0	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  001c3	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 844  : 			_Mylast = _Newvec + _Count;

  001c6	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  001c9	8b 55 e0	 mov	 edx, DWORD PTR __Newvec$201643[ebp]
  001cc	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  001cf	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d2	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

  001d5	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  001d8	8b 45 e0	 mov	 eax, DWORD PTR __Newvec$201643[ebp]
  001db	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001de	e9 26 01 00 00	 jmp	 $L203511
$L201641:
  001e3	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e6	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001e9	2b 55 08	 sub	 edx, DWORD PTR __Where$[ebp]
  001ec	c1 fa 02	 sar	 edx, 2
  001ef	3b 55 0c	 cmp	 edx, DWORD PTR __Count$[ebp]
  001f2	0f 83 ad 00 00
	00		 jae	 $L201654

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  001f8	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001fb	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  001fe	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00201	52		 push	 edx
  00202	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00205	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00208	51		 push	 ecx
  00209	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  0020c	52		 push	 edx
  0020d	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00210	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>

; 851  : 
; 852  : 			_TRY_BEGIN

  00215	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0021c	8d 45 ec	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0021f	50		 push	 eax
  00220	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00223	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00226	2b 55 08	 sub	 edx, DWORD PTR __Where$[ebp]
  00229	c1 fa 02	 sar	 edx, 2
  0022c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0022f	2b c2		 sub	 eax, edx
  00231	50		 push	 eax
  00232	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00235	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00238	52		 push	 edx
  00239	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023c	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
  00241	eb 28		 jmp	 SHORT $L203516
$L203517:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  00243	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00246	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00249	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0024c	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0024f	50		 push	 eax
  00250	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00253	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00256	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00259	50		 push	 eax
  0025a	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0025d	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 857  : 			_RERAISE;

  00262	6a 00		 push	 0
  00264	6a 00		 push	 0
  00266	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203516:

; 858  : 			_CATCH_END

  0026b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 859  : 
; 860  : 			_Mylast += _Count;

  00272	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00275	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00278	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0027b	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  0027e	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00281	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00284	8d 45 ec	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00287	50		 push	 eax
  00288	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0028b	c1 e1 02	 shl	 ecx, 2
  0028e	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00291	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00294	2b c1		 sub	 eax, ecx
  00296	50		 push	 eax
  00297	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  0029a	51		 push	 ecx
  0029b	e8 00 00 00 00	 call	 ??$fill@PAHH@std@@YAXPAH0ABH@Z ; std::fill<int *,int>
  002a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002a3	eb 64		 jmp	 SHORT $L203511
$L201654:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  002a5	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  002a8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002ab	89 45 dc	 mov	 DWORD PTR __Oldend$201664[ebp], eax

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002b4	52		 push	 edx
  002b5	8b 45 dc	 mov	 eax, DWORD PTR __Oldend$201664[ebp]
  002b8	50		 push	 eax
  002b9	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002bc	c1 e1 02	 shl	 ecx, 2
  002bf	8b 55 dc	 mov	 edx, DWORD PTR __Oldend$201664[ebp]
  002c2	2b d1		 sub	 edx, ecx
  002c4	52		 push	 edx
  002c5	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c8	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
  002cd	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d0	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  002d3	8b 55 dc	 mov	 edx, DWORD PTR __Oldend$201664[ebp]
  002d6	52		 push	 edx
  002d7	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002da	c1 e0 02	 shl	 eax, 2
  002dd	8b 4d dc	 mov	 ecx, DWORD PTR __Oldend$201664[ebp]
  002e0	2b c8		 sub	 ecx, eax
  002e2	51		 push	 ecx
  002e3	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  002e6	52		 push	 edx
  002e7	e8 00 00 00 00	 call	 ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z ; std::copy_backward<int *,int *>
  002ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  002ef	8d 45 ec	 lea	 eax, DWORD PTR __Tmp$[ebp]
  002f2	50		 push	 eax
  002f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002f6	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  002f9	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  002fc	50		 push	 eax
  002fd	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00300	51		 push	 ecx
  00301	e8 00 00 00 00	 call	 ??$fill@PAHH@std@@YAXPAH0ABH@Z ; std::fill<int *,int>
  00306	83 c4 0c	 add	 esp, 12			; 0000000cH
$L203511:

; 873  : 			}
; 874  : 		}

  00309	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0030c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00313	5f		 pop	 edi
  00314	5e		 pop	 esi
  00315	5b		 pop	 ebx
  00316	8b e5		 mov	 esp, ebp
  00318	5d		 pop	 ebp
  00319	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203519
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
;	COMDAT ?SetPoint@CPoint@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
?SetPoint@CPoint@@QAEXHH@Z PROC NEAR			; CPoint::SetPoint, COMDAT
; _this$ = ecx

; 80   : 	{ x = X; y = Y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _X$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _Y$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?SetPoint@CPoint@@QAEXHH@Z ENDP				; CPoint::SetPoint
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	SEGMENT
$T203537 DD	0ffffffffH
	DD	FLAT:$L203533
$T203535 DD	019930520H
	DD	01H
	DD	FLAT:$T203537
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T203532 = -80						; size = 28
$T203531 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T203532[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T203532[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T203531[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T203531[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203530:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203533:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T203532[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203535
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC NEAR	; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC NEAR	; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@H@std@@YAPAHIPAH@Z ; std::_Allocate<int>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	6b c0 44	 imul	 eax, 68			; 00000044H
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 01		 add	 eax, DWORD PTR [ecx]
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	89 02		 mov	 DWORD PTR [edx], eax

; 257  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??Yiterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::iterator::operator+=
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRect@@QAE@XZ PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 110  : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CRect@@QAE@XZ ENDP					; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
??0CRect@@QAE@HHHH@Z PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 112  : 	{ left = l; top = t; right = r; bottom = b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _r$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _b$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
??0CRect@@QAE@HHHH@Z ENDP				; CRect::CRect
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QAE@PAU_tagLMCItemInfo@@@Z ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEABU_tagLMCItemInfo@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEABU_tagLMCItemInfo@@XZ PROC NEAR ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@U_tagLMCItemInfo@@V?$allocator@U_tagLMCItemInfo@@@std@@@std@@QBEABU_tagLMCItemInfo@@XZ ENDP ; std::vector<_tagLMCItemInfo,std::allocator<_tagLMCItemInfo> >::const_iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  0000f	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax

; 257  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator-
; Function compile flags: /Odt
;	COMDAT ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T203558 = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR $T203558[ebp], ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR $T203558[ebp]
  00018	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator-

; 280  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator-
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z ; std::deque<CPoint,std::allocator<CPoint> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\deque
;	COMDAT ??0iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::iterator::iterator, COMDAT
; _this$ = ecx

; 242  : 			{	// construct with offset _Off in *_Pdeque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Pdeque$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0const_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z ; std::deque<CPoint,std::allocator<CPoint> >::const_iterator::const_iterator

; 243  : 			}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
??0iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z ENDP ; std::deque<CPoint,std::allocator<CPoint> >::iterator::iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Width@CRect@@QBEHXZ PROC NEAR				; CRect::Width, COMDAT
; _this$ = ecx

; 123  : 	{ return right - left; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Width@CRect@@QBEHXZ ENDP				; CRect::Width
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEABVCPoint@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Off$ = -8						; size = 4
__Block$ = -4						; size = 4
??Dconst_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEABVCPoint@@XZ PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 108  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			size_type _Block = _Myoff / _DEQUESIZ;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	d1 e9		 shr	 ecx, 1
  00011	89 4d fc	 mov	 DWORD PTR __Block$[ebp], ecx

; 110  : 			size_type _Off = _Myoff - _Block * _DEQUESIZ;

  00014	8b 55 fc	 mov	 edx, DWORD PTR __Block$[ebp]
  00017	d1 e2		 shl	 edx, 1
  00019	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	2b ca		 sub	 ecx, edx
  00021	89 4d f8	 mov	 DWORD PTR __Off$[ebp], ecx

; 111  : 			if (_Mycont->_Mapsize <= _Block)

  00024	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002c	3b 4d fc	 cmp	 ecx, DWORD PTR __Block$[ebp]
  0002f	77 0e		 ja	 SHORT $L201708

; 112  : 				_Block -= _Mycont->_Mapsize;

  00031	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00034	8b 02		 mov	 eax, DWORD PTR [edx]
  00036	8b 4d fc	 mov	 ecx, DWORD PTR __Block$[ebp]
  00039	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  0003c	89 4d fc	 mov	 DWORD PTR __Block$[ebp], ecx
$L201708:

; 113  : 			return ((_Mycont->_Map)[_Block][_Off]);

  0003f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 02		 mov	 eax, DWORD PTR [edx]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	8b 55 fc	 mov	 edx, DWORD PTR __Block$[ebp]
  0004a	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR __Off$[ebp]
  00050	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 114  : 			}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
??Dconst_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QBEABVCPoint@@XZ ENDP ; std::deque<CPoint,std::allocator<CPoint> >::const_iterator::operator*
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Height@CRect@@QBEHXZ PROC NEAR				; CRect::Height, COMDAT
; _this$ = ecx

; 125  : 	{ return bottom - top; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?Height@CRect@@QBEHXZ ENDP				; CRect::Height
_TEXT	ENDS
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VCPoint@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@VCPoint@@@std@@QBEIXZ PROC NEAR	; std::allocator<CPoint>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L203574
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L203575
$L203574:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L203575:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@VCPoint@@@std@@QBEIXZ ENDP	; std::allocator<CPoint>::max_size
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@H@std@@QBEIXZ PROC NEAR		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc ff ff
	ff 3f		 mov	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L203578
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L203579
$L203578:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L203579:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator-
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0const_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z PROC NEAR ; std::deque<CPoint,std::allocator<CPoint> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 101  : 		const_iterator(size_type _Off, const _Myt *_Pdeque)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 102  : 			{	// construct with offset _Off in *_Pdeque
; 103  : 			_Mycont = _Pdeque;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdeque$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 104  : 			_Myoff = _Off;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 105  : 			}

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0const_iterator@?$deque@VCPoint@@V?$allocator@VCPoint@@@std@@@std@@QAE@IPBV12@@Z ENDP ; std::deque<CPoint,std::allocator<CPoint> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::iterator::operator++
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\algorithm
;	COMDAT ??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z PROC NEAR ; std::find<std::vector<int,std::allocator<int> >::iterator,int>, COMDAT

; 29   : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 	for (; _First != _Last; ++_First)

  00003	eb 08		 jmp	 SHORT $L201737
$L201738:
  00005	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00008	e8 00 00 00 00	 call	 ??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::iterator::operator++
$L201737:
  0000d	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00010	50		 push	 eax
  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator!=
  00019	0f b6 c8	 movzx	 ecx, al
  0001c	85 c9		 test	 ecx, ecx
  0001e	74 15		 je	 SHORT $L201739

; 31   : 		if (*_First == _Val)

  00020	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00023	e8 00 00 00 00	 call	 ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
  00028	8b 55 14	 mov	 edx, DWORD PTR __Val$[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	3b 02		 cmp	 eax, DWORD PTR [edx]
  0002f	75 02		 jne	 SHORT $L201740

; 32   : 			break;

  00031	eb 02		 jmp	 SHORT $L201739
$L201740:

; 33   : 	return (_First);

  00033	eb d0		 jmp	 SHORT $L201738
$L201739:
  00035	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00038	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	89 11		 mov	 DWORD PTR [ecx], edx
  0003d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 34   : 	}

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$find@Viterator@?$vector@HV?$allocator@H@std@@@std@@H@std@@YA?AViterator@?$vector@HV?$allocator@H@std@@@0@V120@0ABH@Z ENDP ; std::find<std::vector<int,std::allocator<int> >::iterator,int>
_TEXT	ENDS
EXTRN	__imp__IsRectEmpty@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
;	COMDAT ?IsRectEmpty@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRectEmpty@CRect@@QBEHXZ PROC NEAR			; CRect::IsRectEmpty, COMDAT
; _this$ = ecx

; 147  : 	{ return ::IsRectEmpty(this); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsRectEmpty@4
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?IsRectEmpty@CRect@@QBEHXZ ENDP				; CRect::IsRectEmpty
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> >::const_iterator,int *,std::allocator<int> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHVconst_iterator@01@0PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHVconst_iterator@01@0PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Ucopy<std::vector<int,std::allocator<int> >::const_iterator>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> >::const_iterator,int *,std::allocator<int> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHVconst_iterator@01@0PAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<std::vector<int,std::allocator<int> >::const_iterator>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ?IsRectNull@CRect@@QBEHXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
?IsRectNull@CRect@@QBEHXZ PROC NEAR			; CRect::IsRectNull, COMDAT
; _this$ = ecx

; 149  : 	{ return (left == 0 && right == 0 && top == 0 && bottom == 0); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 24		 jne	 SHORT $L203592
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00018	75 1b		 jne	 SHORT $L203592
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00021	75 12		 jne	 SHORT $L203592
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0002a	75 09		 jne	 SHORT $L203592
  0002c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  00033	eb 07		 jmp	 SHORT $L203593
$L203592:
  00035	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L203593:
  0003c	8b 45 f8	 mov	 eax, DWORD PTR tv71[ebp]
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?IsRectNull@CRect@@QBEHXZ ENDP				; CRect::IsRectNull
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@VCPoint@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPoint@@0@Z ; std::_Ptr_cat<CPoint>
PUBLIC	??$_Uninit_copy@PAVCPoint@@PAV1@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CPoint *,CPoint *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAPAVCPoint@@PAPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@@Z
_TEXT	SEGMENT
$T203596 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAVCPoint@@PAPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<CPoint * *,CPoint * *,std::allocator<CPoint *> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@VCPoint@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPoint@@0@Z ; std::_Ptr_cat<CPoint>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203596[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203596[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVCPoint@@PAV1@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CPoint *,CPoint *>
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_copy@PAPAVCPoint@@PAPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@@Z ENDP ; std::_Uninitialized_copy<CPoint * *,CPoint * *,std::allocator<CPoint *> >
_TEXT	ENDS
EXTRN	__imp__PtInRect@12:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
;	COMDAT ?PtInRect@CRect@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_point$ = 8						; size = 8
?PtInRect@CRect@@QBEHUtagPOINT@@@Z PROC NEAR		; CRect::PtInRect, COMDAT
; _this$ = ecx

; 151  : 	{ return ::PtInRect(this, point); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp+4]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _point$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	52		 push	 edx
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?PtInRect@CRect@@QBEHUtagPOINT@@@Z ENDP			; CRect::PtInRect
_TEXT	ENDS
EXTRN	__imp__SetRect@20:NEAR
; Function compile flags: /Odt
;	COMDAT ?SetRect@CRect@@QAEXHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?SetRect@CRect@@QAEXHHHH@Z PROC NEAR			; CRect::SetRect, COMDAT
; _this$ = ecx

; 153  : 	{ ::SetRect(this, x1, y1, x2, y2); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 14	 mov	 eax, DWORD PTR _y2$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _x2$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _y1$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR _x1$[ebp]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 10 00	 ret	 16			; 00000010H
?SetRect@CRect@@QAEXHHHH@Z ENDP				; CRect::SetRect
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CPoint *,unsigned int,CPoint *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAPAVCPoint@@IPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@@Z
_TEXT	SEGMENT
$T203603 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAPAVCPoint@@IPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<CPoint * *,unsigned int,CPoint *,std::allocator<CPoint *> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@VCPoint@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPoint@@0@Z ; std::_Ptr_cat<CPoint>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203603[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203603[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CPoint *,unsigned int,CPoint *>
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_fill_n@PAPAVCPoint@@IPAV1@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CPoint * *,unsigned int,CPoint *,std::allocator<CPoint *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CPoint *,std::allocator<CPoint *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@@Z
_TEXT	SEGMENT
$T203606 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@@Z PROC NEAR ; std::_Destroy_range<CPoint *,std::allocator<CPoint *> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@VCPoint@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPoint@@0@Z ; std::_Ptr_cat<CPoint>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203606[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203606[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CPoint *,std::allocator<CPoint *> >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@@Z ENDP ; std::_Destroy_range<CPoint *,std::allocator<CPoint *> >
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Odt
;	COMDAT ??$_Allocate@VCPoint@@@std@@YAPAVCPoint@@IPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCPoint@@@std@@YAPAVCPoint@@IPAV1@@Z PROC NEAR ; std::_Allocate<CPoint>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 03	 shl	 eax, 3
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@VCPoint@@@std@@YAPAVCPoint@@IPAV1@@Z ENDP	; std::_Allocate<CPoint>
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Odt
;	COMDAT ??$_Construct@VCPoint@@V1@@std@@YAXPAVCPoint@@ABV1@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
$T203611 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCPoint@@V1@@std@@YAXPAVCPoint@@ABV1@@Z PROC NEAR ; std::_Construct<CPoint,CPoint>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	50		 push	 eax
  0000a	6a 08		 push	 8
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00011	83 c4 08	 add	 esp, 8
  00014	89 45 fc	 mov	 DWORD PTR $T203611[ebp], eax
  00017	83 7d fc 00	 cmp	 DWORD PTR $T203611[ebp], 0
  0001b	74 18		 je	 SHORT $L203612
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR $T203611[ebp]
  00028	89 11		 mov	 DWORD PTR [ecx], edx
  0002a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002d	8b 55 fc	 mov	 edx, DWORD PTR $T203611[ebp]
  00030	89 55 f8	 mov	 DWORD PTR tv69[ebp], edx
  00033	eb 07		 jmp	 SHORT $L201934
$L203612:
  00035	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L201934:

; 43   : 	}

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Construct@VCPoint@@V1@@std@@YAXPAVCPoint@@ABV1@@Z ENDP ; std::_Construct<CPoint,CPoint>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@VCPoint@@@std@@YAXPAVCPoint@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCPoint@@@std@@YAXPAVCPoint@@@Z PROC NEAR	; std::_Destroy<CPoint>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@VCPoint@@@std@@YAXPAVCPoint@@@Z ENDP	; std::_Destroy<CPoint>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<int,unsigned int,int>
PUBLIC	?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T203620 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203620[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203620[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<int,unsigned int,int>
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0VCPoint@@@?$allocator@PAVCPoint@@@std@@QAE@ABV?$allocator@VCPoint@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0VCPoint@@@?$allocator@PAVCPoint@@@std@@QAE@ABV?$allocator@VCPoint@@@1@@Z PROC NEAR ; std::allocator<CPoint *>::allocator<CPoint *><CPoint>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0VCPoint@@@?$allocator@PAVCPoint@@@std@@QAE@ABV?$allocator@VCPoint@@@1@@Z ENDP ; std::allocator<CPoint *>::allocator<CPoint *><CPoint>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCPoint@@@std@@YAPAPAVCPoint@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCPoint@@@std@@YAPAPAVCPoint@@IPAPAV1@@Z PROC NEAR ; std::_Allocate<CPoint *>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@PAVCPoint@@@std@@YAPAPAVCPoint@@IPAPAV1@@Z ENDP ; std::_Allocate<CPoint *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAVCPoint@@@std@@YAXPAPAVCPoint@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAVCPoint@@@std@@YAXPAPAVCPoint@@@Z PROC NEAR ; std::_Destroy<CPoint *>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@PAVCPoint@@@std@@YAXPAPAVCPoint@@@Z ENDP	; std::_Destroy<CPoint *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
; Function compile flags: /Odt
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T203629 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC NEAR ; std::_Destroy_range<int,std::allocator<int> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203629[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203629[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC NEAR		; std::fill<int *,int>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1135 : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L202085
$L202086:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 04	 add	 eax, 4
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L202085:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0c		 je	 SHORT $L202084

; 1136 : 		*_First = _Val;

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	89 0a		 mov	 DWORD PTR [edx], ecx
  00020	eb e3		 jmp	 SHORT $L202086
$L202084:

; 1137 : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *>
; Function compile flags: /Odt
;	COMDAT ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T203636 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z PROC NEAR	; std::copy_backward<int *,int *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00004	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203636[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203636[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::copy_backward<int *,int *>
_TEXT	ENDS
EXTRN	__imp__IntersectRect@12:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
;	COMDAT ?IntersectRect@CRect@@QAEHPBUtagRECT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect1$ = 8						; size = 4
_lpRect2$ = 12						; size = 4
?IntersectRect@CRect@@QAEHPBUtagRECT@@0@Z PROC NEAR	; CRect::IntersectRect, COMDAT
; _this$ = ecx

; 185  : 	{ return ::IntersectRect(this, lpRect1, lpRect2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _lpRect2$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect1$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	52		 push	 edx
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IntersectRect@12
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?IntersectRect@CRect@@QAEHPBUtagRECT@@0@Z ENDP		; CRect::IntersectRect
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC NEAR		; std::_Allocate<int>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 			++this->_Myptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	83 c1 04	 add	 ecx, 4
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 232  : 			}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??Eiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<int,std::allocator<int> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@HV?$allocator@H@std@@@0@AAPAH@Z ; std::_Ptr_cat<std::vector<int,std::allocator<int> >::const_iterator,int *>
PUBLIC	??$_Uninit_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<int,std::allocator<int> >::const_iterator,int *,std::allocator<int> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T203645 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@@Z PROC NEAR ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> >::const_iterator,int *,std::allocator<int> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@HV?$allocator@H@std@@@0@AAPAH@Z ; std::_Ptr_cat<std::vector<int,std::allocator<int> >::const_iterator,int *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203645[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203645[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<int,std::allocator<int> >::const_iterator,int *,std::allocator<int> >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> >::const_iterator,int *,std::allocator<int> >
_TEXT	ENDS
EXTRN	__imp__EqualRect@8:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
;	COMDAT ??8CRect@@QBEHABUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rect$ = 8						; size = 4
??8CRect@@QBEHABUtagRECT@@@Z PROC NEAR			; CRect::operator==, COMDAT
; _this$ = ecx

; 191  : 	{ return ::EqualRect(this, &rect); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EqualRect@8
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??8CRect@@QBEHABUtagRECT@@@Z ENDP			; CRect::operator==
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@VCPoint@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPoint@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@VCPoint@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPoint@@0@Z PROC NEAR ; std::_Ptr_cat<CPoint>, COMDAT

; 218  : 	{	// return pointer category from pointer to pointer arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 219  : 	_Scalar_ptr_iterator_tag _Cat;
; 220  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 221  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@VCPoint@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPoint@@0@Z ENDP ; std::_Ptr_cat<CPoint>
_TEXT	ENDS
EXTRN	__imp__memmove:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_copy@PAVCPoint@@PAV1@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAVCPoint@@PAV1@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<CPoint *,CPoint *>, COMDAT

; 105  : 	{	// copy [_First, _Last) to raw _Dest, (const) scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00010	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  00013	c1 e1 02	 shl	 ecx, 2
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 109  : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$_Uninit_copy@PAVCPoint@@PAV1@@std@@YAPAPAVCPoint@@PAPAV1@00AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CPoint *,CPoint *>
_TEXT	ENDS
PUBLIC	??$fill_n@PAPAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@@Z ; std::fill_n<CPoint * *,unsigned int,CPoint *>
; Function compile flags: /Odt
;	COMDAT ??$_Uninit_fill_n@PAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<CPoint *,unsigned int,CPoint *>, COMDAT

; 236  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 	fill_n(_First, _Count, _Val);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ??$fill_n@PAPAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@@Z ; std::fill_n<CPoint * *,unsigned int,CPoint *>
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 238  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Uninit_fill_n@PAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CPoint *,unsigned int,CPoint *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CPoint *,std::allocator<CPoint *> >, COMDAT

; 233  : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@PAVCPoint@@V?$allocator@PAVCPoint@@@std@@@std@@YAXPAPAVCPoint@@0AAV?$allocator@PAVCPoint@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CPoint *,std::allocator<CPoint *> >
_TEXT	ENDS
PUBLIC	??$fill_n@PAHIH@std@@YAXPAHIABH@Z		; std::fill_n<int *,unsigned int,int>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<int,unsigned int,int>, COMDAT

; 236  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 	fill_n(_First, _Count, _Val);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ??$fill_n@PAHIH@std@@YAXPAHIABH@Z ; std::fill_n<int *,unsigned int,int>
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 238  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int,unsigned int,int>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<int,std::allocator<int> >, COMDAT

; 233  : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T203662 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z PROC NEAR ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203662[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203662[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<int *,int *>, COMDAT

; 1058 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	89 45 fc	 mov	 DWORD PTR __Off$[ebp], eax

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  00010	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00013	c1 e1 02	 shl	 ecx, 2
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Off$[ebp]
  0001e	c1 e0 02	 shl	 eax, 2
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@HV?$allocator@H@std@@@0@AAPAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@HV?$allocator@H@std@@@0@AAPAH@Z PROC NEAR ; std::_Ptr_cat<std::vector<int,std::allocator<int> >::const_iterator,int *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@HV?$allocator@H@std@@@0@AAPAH@Z ENDP ; std::_Ptr_cat<std::vector<int,std::allocator<int> >::const_iterator,int *>
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::const_iterator::operator++
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
PUBLIC	?destroy@?$allocator@H@std@@QAEXPAH@Z		; std::allocator<int>::destroy
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T203674 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T203676 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L203670
$T203675 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T203676
$T203672 DD	019930520H
	DD	02H
	DD	FLAT:$T203674
	DD	01H
	DD	FLAT:$T203675
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -28						; size = 4
tv83 = -21						; size = 1
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<std::vector<int,std::allocator<int> >::const_iterator,int *,std::allocator<int> >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 78   : 	_FwdIt _Next = _Dest;

  00022	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00025	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 79   : 
; 80   : 	_TRY_BEGIN

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  0002f	eb 11		 jmp	 SHORT $L202213
$L202214:
  00031	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00034	83 c1 04	 add	 ecx, 4
  00037	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  0003a	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0003d	e8 00 00 00 00	 call	 ??Econst_iterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::const_iterator::operator++
$L202213:
  00042	8d 55 0c	 lea	 edx, DWORD PTR __Last$[ebp]
  00045	52		 push	 edx
  00046	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00049	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator!=
  0004e	88 45 eb	 mov	 BYTE PTR tv83[ebp], al
  00051	0f b6 45 eb	 movzx	 eax, BYTE PTR tv83[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 1d		 je	 SHORT $L202215

; 82   : 		_Al.construct(_Dest, *_First);

  00059	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0005c	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::vector<int,std::allocator<int> >::const_iterator::operator*
  00061	89 45 e4	 mov	 DWORD PTR tv84[ebp], eax
  00064	8b 4d e4	 mov	 ecx, DWORD PTR tv84[ebp]
  00067	51		 push	 ecx
  00068	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0006b	52		 push	 edx
  0006c	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0006f	e8 00 00 00 00	 call	 ?construct@?$allocator@H@std@@QAEXPAHABH@Z ; std::allocator<int>::construct
  00074	eb bb		 jmp	 SHORT $L202214
$L202215:
  00076	eb 2a		 jmp	 SHORT $L203669
$L203670:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  00078	eb 09		 jmp	 SHORT $L202216
$L202217:
  0007a	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007d	83 c0 04	 add	 eax, 4
  00080	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$L202216:
  00083	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00086	3b 4d 10	 cmp	 ecx, DWORD PTR __Dest$[ebp]
  00089	74 0e		 je	 SHORT $L202218

; 85   : 		_Al.destroy(_Next);

  0008b	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  0008e	52		 push	 edx
  0008f	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00092	e8 00 00 00 00	 call	 ?destroy@?$allocator@H@std@@QAEXPAH@Z ; std::allocator<int>::destroy
  00097	eb e1		 jmp	 SHORT $L202217
$L202218:

; 86   : 	_RERAISE;

  00099	6a 00		 push	 0
  0009b	6a 00		 push	 0
  0009d	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203669:

; 87   : 	_CATCH_END

  000a2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 88   : 	return (_Dest);

  000a9	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$L203668:

; 89   : 	}

  000ac	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000af	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203672
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@Vconst_iterator@?$vector@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@3@@std@@YAPAHVconst_iterator@?$vector@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::vector<int,std::allocator<int> >::const_iterator,int *,std::allocator<int> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill_n@PAPAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAPAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@@Z PROC NEAR ; std::fill_n<CPoint * *,unsigned int,CPoint *>, COMDAT

; 1159 : 	{	// copy _Val _Count times through [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00003	eb 12		 jmp	 SHORT $L202220
$L202221:
  00005	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00008	83 e8 01	 sub	 eax, 1
  0000b	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	83 c1 04	 add	 ecx, 4
  00014	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$L202220:
  00017	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0001b	76 0c		 jbe	 SHORT $L202219

; 1161 : 		*_First = _Val;

  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	89 0a		 mov	 DWORD PTR [edx], ecx
  00027	eb dc		 jmp	 SHORT $L202221
$L202219:

; 1162 : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$fill_n@PAPAVCPoint@@IPAV1@@std@@YAXPAPAVCPoint@@IABQAV1@@Z ENDP ; std::fill_n<CPoint * *,unsigned int,CPoint *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$fill_n@PAHIH@std@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAHIH@std@@YAXPAHIABH@Z PROC NEAR		; std::fill_n<int *,unsigned int,int>, COMDAT

; 1159 : 	{	// copy _Val _Count times through [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00003	eb 12		 jmp	 SHORT $L202224
$L202225:
  00005	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00008	83 e8 01	 sub	 eax, 1
  0000b	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	83 c1 04	 add	 ecx, 4
  00014	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$L202224:
  00017	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0001b	76 0c		 jbe	 SHORT $L202223

; 1161 : 		*_First = _Val;

  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	89 0a		 mov	 DWORD PTR [edx], ecx
  00027	eb dc		 jmp	 SHORT $L202225
$L202223:

; 1162 : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$fill_n@PAHIH@std@@YAXPAHIABH@Z ENDP			; std::fill_n<int *,unsigned int,int>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<int,int>, COMDAT

; 105  : 	{	// copy [_First, _Last) to raw _Dest, (const) scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00010	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  00013	c1 e1 02	 shl	 ecx, 2
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 109  : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int,int>
_TEXT	ENDS
PUBLIC	??$_Construct@HH@std@@YAXPAHABH@Z		; std::_Construct<int,int>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC NEAR	; std::allocator<int>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@HH@std@@YAXPAHABH@Z ; std::_Construct<int,int>
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@H@std@@YAXPAH@Z			; std::_Destroy<int>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@H@std@@QAEXPAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@H@std@@QAEXPAH@Z PROC NEAR		; std::allocator<int>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@H@std@@YAXPAH@Z ; std::_Destroy<int>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@H@std@@QAEXPAH@Z ENDP		; std::allocator<int>::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 91   : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 92   : 			++_Myptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	83 c1 04	 add	 ecx, 4
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 93   : 			return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 94   : 			}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??Econst_iterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator++
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@HH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
$T203693 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@HH@std@@YAXPAHABH@Z PROC NEAR		; std::_Construct<int,int>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	50		 push	 eax
  0000a	6a 04		 push	 4
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00011	83 c4 08	 add	 esp, 8
  00014	89 45 fc	 mov	 DWORD PTR $T203693[ebp], eax
  00017	83 7d fc 00	 cmp	 DWORD PTR $T203693[ebp], 0
  0001b	74 12		 je	 SHORT $L203694
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T203693[ebp]
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	89 01		 mov	 DWORD PTR [ecx], eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR $T203693[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0002d	eb 07		 jmp	 SHORT $L202247
$L203694:
  0002f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L202247:

; 43   : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$_Construct@HH@std@@YAXPAHABH@Z ENDP			; std::_Construct<int,int>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Destroy@H@std@@YAXPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@H@std@@YAXPAH@Z PROC NEAR			; std::_Destroy<int>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@H@std@@YAXPAH@Z ENDP			; std::_Destroy<int>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC NEAR	; CObject::Serialize, COMDAT
; _this$ = ecx

; 25   : 	{ /* CObject does not serialize anything by default */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC NEAR				; CObject::operator delete, COMDAT

; 31   : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??2CObject@@SGPAXI@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
??2CObject@@SGPAXI@Z PROC NEAR				; CObject::operator new, COMDAT

; 37   : 	{ return ::operator new(nSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _nSize$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??2CObject@@SGPAXI@Z ENDP				; CObject::operator new
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AssertValid@CObject@@UBEXXZ PROC NEAR			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 41   : 	{ /* no asserts in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC NEAR	; CObject::Dump, COMDAT
; _this$ = ecx

; 43   : 	{ /* no dumping in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
EXTRN	?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ:NEAR ; AfxGetModuleState
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
;	COMDAT ?AfxGetApp@@YGPAVCWinApp@@XZ
_TEXT	SEGMENT
?AfxGetApp@@YGPAVCWinApp@@XZ PROC NEAR			; AfxGetApp, COMDAT

; 21   : 	{ return afxCurrentWinApp; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 ?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetModuleState
  00008	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?AfxGetApp@@YGPAVCWinApp@@XZ ENDP			; AfxGetApp
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??BCGdiObject@@QBEPAXXZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
??BCGdiObject@@QBEPAXXZ PROC NEAR			; CGdiObject::operator void *, COMDAT
; _this$ = ecx

; 78   : 	{ return this == NULL ? NULL : m_hObject; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  0000d	75 09		 jne	 SHORT $L203712
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00016	eb 09		 jmp	 SHORT $L203713
$L203712:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	89 4d f8	 mov	 DWORD PTR tv66[ebp], ecx
$L203713:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??BCGdiObject@@QBEPAXXZ ENDP				; CGdiObject::operator void *
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSafeHandle@CGdiObject@@QBEPAXXZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?GetSafeHandle@CGdiObject@@QBEPAXXZ PROC NEAR		; CGdiObject::GetSafeHandle, COMDAT
; _this$ = ecx

; 80   : 	{ return this == NULL ? NULL : m_hObject; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  0000d	75 09		 jne	 SHORT $L203716
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00016	eb 09		 jmp	 SHORT $L203717
$L203716:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	89 4d f8	 mov	 DWORD PTR tv66[ebp], ecx
$L203717:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GetSafeHandle@CGdiObject@@QBEPAXXZ ENDP		; CGdiObject::GetSafeHandle
_TEXT	ENDS
EXTRN	__imp__GetStockObject@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CreateStockObject@CGdiObject@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?CreateStockObject@CGdiObject@@QAEHH@Z PROC NEAR	; CGdiObject::CreateStockObject, COMDAT
; _this$ = ecx

; 88   : 	{ return (m_hObject = ::GetStockObject(nIndex)) != NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStockObject@4
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	33 c0		 xor	 eax, eax
  0001c	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00020	0f 95 c0	 setne	 al
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CreateStockObject@CGdiObject@@QAEHH@Z ENDP		; CGdiObject::CreateStockObject
_TEXT	ENDS
PUBLIC	??_R0?AVCGdiObject@@@8				; CGdiObject `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CGdiObject@@8			; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4CPen@@6B@					; CPen::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPen@@@8				; CPen `RTTI Type Descriptor'
PUBLIC	??_R3CPen@@8					; CPen::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPen@@8					; CPen::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CPen@@8				; CPen::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??1CGdiObject@@UAE@XZ				; CGdiObject::~CGdiObject
PUBLIC	??_7CPen@@6B@					; CPen::`vftable'
PUBLIC	??_GCPen@@UAEPAXI@Z				; CPen::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CPen@@UBEPAUCRuntimeClass@@XZ:NEAR ; CPen::GetRuntimeClass
EXTRN	??_ECPen@@UAEPAXI@Z:NEAR			; CPen::`vector deleting destructor'
;	COMDAT ??_7CPen@@6B@
CONST	SEGMENT
??_7CPen@@6B@ DD FLAT:??_R4CPen@@6B@			; CPen::`vftable'
	DD	FLAT:?GetRuntimeClass@CPen@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECPen@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CPen@@6B@
rdata$r	SEGMENT
??_R4CPen@@6B@ DD 00H					; CPen::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPen@@@8
	DD	FLAT:??_R3CPen@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPen@@@8
_DATA	SEGMENT
??_R0?AVCPen@@@8 DD FLAT:??_7type_info@@6B@		; CPen `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPen@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CPen@@8
rdata$r	SEGMENT
??_R3CPen@@8 DD	00H					; CPen::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CPen@@8
rdata$r	ENDS
;	COMDAT ??_R2CPen@@8
rdata$r	SEGMENT
??_R2CPen@@8 DD	FLAT:??_R1A@?0A@A@CPen@@8		; CPen::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CPen@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CPen@@8 DD FLAT:??_R0?AVCPen@@@8		; CPen::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CGdiObject@@8 DD FLAT:??_R0?AVCGdiObject@@@8 ; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
_DATA	SEGMENT
??_R0?AVCGdiObject@@@8 DD FLAT:??_7type_info@@6B@	; CGdiObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGdiObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??1CPen@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CPen@@UAE@XZ PROC NEAR				; CPen::~CPen, COMDAT
; _this$ = ecx

; 106  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CPen@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CPen@@UAE@XZ ENDP					; CPen::~CPen
_TEXT	ENDS
PUBLIC	??_R4CGdiObject@@6B@				; CGdiObject::`RTTI Complete Object Locator'
PUBLIC	??_R3CGdiObject@@8				; CGdiObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGdiObject@@8				; CGdiObject::`RTTI Base Class Array'
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
PUBLIC	??_7CGdiObject@@6B@				; CGdiObject::`vftable'
PUBLIC	??_GCGdiObject@@UAEPAXI@Z			; CGdiObject::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ:NEAR ; CGdiObject::GetRuntimeClass
EXTRN	??_ECGdiObject@@UAEPAXI@Z:NEAR			; CGdiObject::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203729 DD	0ffffffffH
	DD	FLAT:$L203725
$T203727 DD	019930520H
	DD	01H
	DD	FLAT:$T203729
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT
??_7CGdiObject@@6B@ DD FLAT:??_R4CGdiObject@@6B@	; CGdiObject::`vftable'
	DD	FLAT:?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECGdiObject@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT
??_R4CGdiObject@@6B@ DD 00H				; CGdiObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGdiObject@@@8
	DD	FLAT:??_R3CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT
??_R3CGdiObject@@8 DD 00H				; CGdiObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT
??_R2CGdiObject@@8 DD FLAT:??_R1A@?0A@A@CGdiObject@@8	; CGdiObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CObject@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CGdiObject@@UAE@XZ PROC NEAR				; CGdiObject::~CGdiObject, COMDAT
; _this$ = ecx

; 84   : 	{ DeleteObject(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGdiObject@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CGdiObject@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject
  00034	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CObject@@UAE@XZ	; CObject::~CObject
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203725:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CObject@@UAE@XZ	; CObject::~CObject
__ehhandler$??1CGdiObject@@UAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203727
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CGdiObject@@UAE@XZ ENDP				; CGdiObject::~CGdiObject
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CObject@@UAE@XZ PROC NEAR				; CObject::~CObject, COMDAT
; _this$ = ecx

; 23   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGdiObject@@UAEPAXI@Z PROC NEAR			; CGdiObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41495
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41495:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCGdiObject@@UAEPAXI@Z ENDP				; CGdiObject::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCPen@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCPen@@UAEPAXI@Z PROC NEAR				; CPen::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CPen@@UAE@XZ		; CPen::~CPen
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41541
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41541:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCPen@@UAEPAXI@Z ENDP				; CPen::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4CBrush@@6B@				; CBrush::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBrush@@@8				; CBrush `RTTI Type Descriptor'
PUBLIC	??_R3CBrush@@8					; CBrush::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBrush@@8					; CBrush::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CBrush@@8				; CBrush::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0CGdiObject@@QAE@XZ				; CGdiObject::CGdiObject
PUBLIC	??_7CBrush@@6B@					; CBrush::`vftable'
PUBLIC	??_GCBrush@@UAEPAXI@Z				; CBrush::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CBrush@@UBEPAUCRuntimeClass@@XZ:NEAR ; CBrush::GetRuntimeClass
EXTRN	??_ECBrush@@UAEPAXI@Z:NEAR			; CBrush::`vector deleting destructor'
;	COMDAT ??_7CBrush@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
CONST	SEGMENT
??_7CBrush@@6B@ DD FLAT:??_R4CBrush@@6B@		; CBrush::`vftable'
	DD	FLAT:?GetRuntimeClass@CBrush@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECBrush@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CBrush@@6B@
rdata$r	SEGMENT
??_R4CBrush@@6B@ DD 00H					; CBrush::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBrush@@@8
	DD	FLAT:??_R3CBrush@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBrush@@@8
_DATA	SEGMENT
??_R0?AVCBrush@@@8 DD FLAT:??_7type_info@@6B@		; CBrush `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBrush@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CBrush@@8
rdata$r	SEGMENT
??_R3CBrush@@8 DD 00H					; CBrush::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CBrush@@8
rdata$r	ENDS
;	COMDAT ??_R2CBrush@@8
rdata$r	SEGMENT
??_R2CBrush@@8 DD FLAT:??_R1A@?0A@A@CBrush@@8		; CBrush::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBrush@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CBrush@@8 DD FLAT:??_R0?AVCBrush@@@8	; CBrush::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CBrush@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CBrush@@QAE@XZ PROC NEAR				; CBrush::CBrush, COMDAT
; _this$ = ecx

; 128  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CGdiObject@@QAE@XZ	; CGdiObject::CGdiObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBrush@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CBrush@@QAE@XZ ENDP					; CBrush::CBrush
_TEXT	ENDS
PUBLIC	??0CObject@@IAE@XZ				; CObject::CObject
; Function compile flags: /Odt
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CGdiObject@@QAE@XZ PROC NEAR				; CGdiObject::CGdiObject, COMDAT
; _this$ = ecx

; 82   : 	{ m_hObject = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CObject@@IAE@XZ	; CObject::CObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CGdiObject@@6B@
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0CGdiObject@@QAE@XZ ENDP				; CGdiObject::CGdiObject
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CObject@@IAE@XZ PROC NEAR				; CObject::CObject, COMDAT
; _this$ = ecx

; 21   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CObject@@IAE@XZ ENDP					; CObject::CObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCBrush@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCBrush@@UAEPAXI@Z PROC NEAR				; CBrush::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41589
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41589:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCBrush@@UAEPAXI@Z ENDP				; CBrush::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
_TEXT	ENDS
;	COMDAT ??1CBrush@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CBrush@@UAE@XZ PROC NEAR				; CBrush::~CBrush, COMDAT
; _this$ = ecx

; 130  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBrush@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CBrush@@UAE@XZ ENDP					; CBrush::~CBrush
_TEXT	ENDS
PUBLIC	??_R4CFont@@6B@					; CFont::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCFont@@@8				; CFont `RTTI Type Descriptor'
PUBLIC	??_R3CFont@@8					; CFont::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CFont@@8					; CFont::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CFont@@8				; CFont::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_7CFont@@6B@					; CFont::`vftable'
PUBLIC	??_GCFont@@UAEPAXI@Z				; CFont::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CFont@@UBEPAUCRuntimeClass@@XZ:NEAR ; CFont::GetRuntimeClass
EXTRN	??_ECFont@@UAEPAXI@Z:NEAR			; CFont::`vector deleting destructor'
;	COMDAT ??_7CFont@@6B@
CONST	SEGMENT
??_7CFont@@6B@ DD FLAT:??_R4CFont@@6B@			; CFont::`vftable'
	DD	FLAT:?GetRuntimeClass@CFont@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECFont@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CFont@@6B@
rdata$r	SEGMENT
??_R4CFont@@6B@ DD 00H					; CFont::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCFont@@@8
	DD	FLAT:??_R3CFont@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFont@@@8
_DATA	SEGMENT
??_R0?AVCFont@@@8 DD FLAT:??_7type_info@@6B@		; CFont `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFont@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CFont@@8
rdata$r	SEGMENT
??_R3CFont@@8 DD 00H					; CFont::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CFont@@8
rdata$r	ENDS
;	COMDAT ??_R2CFont@@8
rdata$r	SEGMENT
??_R2CFont@@8 DD FLAT:??_R1A@?0A@A@CFont@@8		; CFont::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CFont@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CFont@@8 DD FLAT:??_R0?AVCFont@@@8		; CFont::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CFont@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CFont@@QAE@XZ PROC NEAR				; CFont::CFont, COMDAT
; _this$ = ecx

; 153  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CGdiObject@@QAE@XZ	; CGdiObject::CGdiObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CFont@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CFont@@QAE@XZ ENDP					; CFont::CFont
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCFont@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCFont@@UAEPAXI@Z PROC NEAR				; CFont::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CFont@@UAE@XZ	; CFont::~CFont
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41640
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41640:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCFont@@UAEPAXI@Z ENDP				; CFont::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CFont@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CFont@@UAE@XZ PROC NEAR				; CFont::~CFont, COMDAT
; _this$ = ecx

; 155  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CFont@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CFont@@UAE@XZ ENDP					; CFont::~CFont
_TEXT	ENDS
EXTRN	__imp__CreateFontA@56:NEAR
EXTRN	?Attach@CGdiObject@@QAEHPAX@Z:NEAR		; CGdiObject::Attach
; Function compile flags: /Odt
;	COMDAT ?CreateFontA@CFont@@QAEHHHHHHEEEEEEEEPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nHeight$ = 8						; size = 4
_nWidth$ = 12						; size = 4
_nEscapement$ = 16					; size = 4
_nOrientation$ = 20					; size = 4
_nWeight$ = 24						; size = 4
_bItalic$ = 28						; size = 1
_bUnderline$ = 32					; size = 1
_cStrikeOut$ = 36					; size = 1
_nCharSet$ = 40						; size = 1
_nOutPrecision$ = 44					; size = 1
_nClipPrecision$ = 48					; size = 1
_nQuality$ = 52						; size = 1
_nPitchAndFamily$ = 56					; size = 1
_lpszFacename$ = 60					; size = 4
?CreateFontA@CFont@@QAEHHHHHHEEEEEEEEPBD@Z PROC NEAR	; CFont::CreateFontA, COMDAT
; _this$ = ecx

; 163  : 	{ return Attach(::CreateFont(nHeight, nWidth, nEscapement,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 164  : 		nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
; 165  : 		nCharSet, nOutPrecision, nClipPrecision, nQuality,
; 166  : 		nPitchAndFamily, lpszFacename)); }

  00007	8b 45 3c	 mov	 eax, DWORD PTR _lpszFacename$[ebp]
  0000a	50		 push	 eax
  0000b	0f b6 4d 38	 movzx	 ecx, BYTE PTR _nPitchAndFamily$[ebp]
  0000f	51		 push	 ecx
  00010	0f b6 55 34	 movzx	 edx, BYTE PTR _nQuality$[ebp]
  00014	52		 push	 edx
  00015	0f b6 45 30	 movzx	 eax, BYTE PTR _nClipPrecision$[ebp]
  00019	50		 push	 eax
  0001a	0f b6 4d 2c	 movzx	 ecx, BYTE PTR _nOutPrecision$[ebp]
  0001e	51		 push	 ecx
  0001f	0f b6 55 28	 movzx	 edx, BYTE PTR _nCharSet$[ebp]
  00023	52		 push	 edx
  00024	0f b6 45 24	 movzx	 eax, BYTE PTR _cStrikeOut$[ebp]
  00028	50		 push	 eax
  00029	0f b6 4d 20	 movzx	 ecx, BYTE PTR _bUnderline$[ebp]
  0002d	51		 push	 ecx
  0002e	0f b6 55 1c	 movzx	 edx, BYTE PTR _bItalic$[ebp]
  00032	52		 push	 edx
  00033	8b 45 18	 mov	 eax, DWORD PTR _nWeight$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 14	 mov	 ecx, DWORD PTR _nOrientation$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 10	 mov	 edx, DWORD PTR _nEscapement$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 0c	 mov	 eax, DWORD PTR _nWidth$[ebp]
  00042	50		 push	 eax
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _nHeight$[ebp]
  00046	51		 push	 ecx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFontA@56
  0004d	50		 push	 eax
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 38 00	 ret	 56			; 00000038H
?CreateFontA@CFont@@QAEHHHHHHEEEEEEEEPBD@Z ENDP		; CFont::CreateFontA
_TEXT	ENDS
PUBLIC	??_R4CBitmap@@6B@				; CBitmap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBitmap@@@8				; CBitmap `RTTI Type Descriptor'
PUBLIC	??_R3CBitmap@@8					; CBitmap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBitmap@@8					; CBitmap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CBitmap@@8				; CBitmap::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_7CBitmap@@6B@				; CBitmap::`vftable'
PUBLIC	??_GCBitmap@@UAEPAXI@Z				; CBitmap::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CBitmap@@UBEPAUCRuntimeClass@@XZ:NEAR ; CBitmap::GetRuntimeClass
EXTRN	??_ECBitmap@@UAEPAXI@Z:NEAR			; CBitmap::`vector deleting destructor'
;	COMDAT ??_7CBitmap@@6B@
CONST	SEGMENT
??_7CBitmap@@6B@ DD FLAT:??_R4CBitmap@@6B@		; CBitmap::`vftable'
	DD	FLAT:?GetRuntimeClass@CBitmap@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECBitmap@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CBitmap@@6B@
rdata$r	SEGMENT
??_R4CBitmap@@6B@ DD 00H				; CBitmap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBitmap@@@8
	DD	FLAT:??_R3CBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBitmap@@@8
_DATA	SEGMENT
??_R0?AVCBitmap@@@8 DD FLAT:??_7type_info@@6B@		; CBitmap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBitmap@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CBitmap@@8
rdata$r	SEGMENT
??_R3CBitmap@@8 DD 00H					; CBitmap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R2CBitmap@@8
rdata$r	SEGMENT
??_R2CBitmap@@8 DD FLAT:??_R1A@?0A@A@CBitmap@@8		; CBitmap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBitmap@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CBitmap@@8 DD FLAT:??_R0?AVCBitmap@@@8	; CBitmap::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CBitmap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CBitmap@@QAE@XZ PROC NEAR				; CBitmap::CBitmap, COMDAT
; _this$ = ecx

; 177  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CGdiObject@@QAE@XZ	; CGdiObject::CGdiObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBitmap@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CBitmap@@QAE@XZ ENDP					; CBitmap::CBitmap
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCBitmap@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCBitmap@@UAEPAXI@Z PROC NEAR			; CBitmap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CBitmap@@UAE@XZ	; CBitmap::~CBitmap
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41685
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41685:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCBitmap@@UAEPAXI@Z ENDP				; CBitmap::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CBitmap@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CBitmap@@UAE@XZ PROC NEAR				; CBitmap::~CBitmap, COMDAT
; _this$ = ecx

; 179  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBitmap@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CBitmap@@UAE@XZ ENDP					; CBitmap::~CBitmap
_TEXT	ENDS
EXTRN	__imp__CreateCompatibleBitmap@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?CreateCompatibleBitmap@CBitmap@@QAEHPAVCDC@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
_nWidth$ = 12						; size = 4
_nHeight$ = 16						; size = 4
?CreateCompatibleBitmap@CBitmap@@QAEHPAVCDC@@HH@Z PROC NEAR ; CBitmap::CreateCompatibleBitmap, COMDAT
; _this$ = ecx

; 217  : 	{ return Attach(::CreateCompatibleBitmap(pDC->m_hDC, nWidth, nHeight)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 10	 mov	 eax, DWORD PTR _nHeight$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _nWidth$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR _pDC$[ebp]
  00012	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  0001c	50		 push	 eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 0c 00	 ret	 12			; 0000000cH
?CreateCompatibleBitmap@CBitmap@@QAEHPAVCDC@@HH@Z ENDP	; CBitmap::CreateCompatibleBitmap
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ PROC NEAR		; CDC::GetSafeHdc, COMDAT
; _this$ = ecx

; 316  : 	{ return this == NULL ? NULL : m_hDC; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  0000d	75 09		 jne	 SHORT $L203773
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00016	eb 09		 jmp	 SHORT $L203774
$L203773:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	89 4d f8	 mov	 DWORD PTR tv66[ebp], ecx
$L203774:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ENDP			; CDC::GetSafeHdc
_TEXT	ENDS
EXTRN	?Attach@CDC@@QAEHPAUHDC__@@@Z:NEAR		; CDC::Attach
EXTRN	__imp__CreateCompatibleDC@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?CreateCompatibleDC@CDC@@QAEHPAV1@@Z PROC NEAR		; CDC::CreateCompatibleDC, COMDAT
; _this$ = ecx

; 330  : 	{ return Attach(::CreateCompatibleDC(pDC->GetSafeHdc())); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?Attach@CDC@@QAEHPAUHDC__@@@Z ; CDC::Attach
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?CreateCompatibleDC@CDC@@QAEHPAV1@@Z ENDP		; CDC::CreateCompatibleDC
_TEXT	ENDS
EXTRN	?SelectGdiObject@CDC@@KGPAVCGdiObject@@PAUHDC__@@PAX@Z:NEAR ; CDC::SelectGdiObject
; Function compile flags: /Odt
;	COMDAT ?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pBitmap$ = 8						; size = 4
?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z PROC NEAR	; CDC::SelectObject, COMDAT
; _this$ = ecx

; 361  : 	{ ASSERT(m_hDC != NULL); return (CBitmap*) SelectGdiObject(m_hDC, pBitmap->GetSafeHandle()); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pBitmap$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetSafeHandle@CGdiObject@@QBEPAXXZ ; CGdiObject::GetSafeHandle
  0000f	50		 push	 eax
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?SelectGdiObject@CDC@@KGPAVCGdiObject@@PAUHDC__@@PAX@Z ; CDC::SelectGdiObject
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z ENDP		; CDC::SelectObject
_TEXT	ENDS
EXTRN	__imp__SelectObject@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?SelectObject@CDC@@QAEPAXPAX@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_hObject$ = 8						; size = 4
?SelectObject@CDC@@QAEPAXPAX@Z PROC NEAR		; CDC::SelectObject, COMDAT
; _this$ = ecx

; 365  : 	{ ASSERT(m_hDC == m_hAttribDC); // ASSERT a simple CDC object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 366  : 		return (hObject != NULL) ? ::SelectObject(m_hDC, hObject) : NULL; }

  00009	83 7d 08 00	 cmp	 DWORD PTR _hObject$[ebp], 0
  0000d	74 16		 je	 SHORT $L203781
  0000f	8b 45 08	 mov	 eax, DWORD PTR _hObject$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00019	52		 push	 edx
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  00020	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  00023	eb 07		 jmp	 SHORT $L203782
$L203781:
  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L203782:
  0002c	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?SelectObject@CDC@@QAEPAXPAX@Z ENDP			; CDC::SelectObject
_TEXT	ENDS
EXTRN	__imp__GetBkMode@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetBkMode@CDC@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBkMode@CDC@@QBEHXZ PROC NEAR			; CDC::GetBkMode, COMDAT
; _this$ = ecx

; 376  : 	{ ASSERT(m_hAttribDC != NULL); return ::GetBkMode(m_hAttribDC); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetBkMode@4
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetBkMode@CDC@@QBEHXZ ENDP				; CDC::GetBkMode
_TEXT	ENDS
EXTRN	__imp__GetTextColor@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetTextColor@CDC@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTextColor@CDC@@QBEKXZ PROC NEAR			; CDC::GetTextColor, COMDAT
; _this$ = ecx

; 384  : 	{ ASSERT(m_hAttribDC != NULL); return ::GetTextColor(m_hAttribDC); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextColor@4
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetTextColor@CDC@@QBEKXZ ENDP				; CDC::GetTextColor
_TEXT	ENDS
EXTRN	__imp__Rectangle@20:NEAR
; Function compile flags: /Odt
;	COMDAT ?Rectangle@CDC@@QAEHPBUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
?Rectangle@CDC@@QAEHPBUtagRECT@@@Z PROC NEAR		; CDC::Rectangle, COMDAT
; _this$ = ecx

; 537  : 	{ ASSERT(m_hDC != NULL); return ::Rectangle(m_hDC, lpRect->left, lpRect->top,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 538  : 		lpRect->right, lpRect->bottom); }

  00007	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  0000a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _lpRect$[ebp]
  00011	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	52		 push	 edx
  0001c	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	51		 push	 ecx
  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Rectangle@20
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?Rectangle@CDC@@QAEHPBUtagRECT@@@Z ENDP			; CDC::Rectangle
_TEXT	ENDS
EXTRN	__imp__BitBlt@36:NEAR
; Function compile flags: /Odt
;	COMDAT ?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_nWidth$ = 16						; size = 4
_nHeight$ = 20						; size = 4
_pSrcDC$ = 24						; size = 4
_xSrc$ = 28						; size = 4
_ySrc$ = 32						; size = 4
_dwRop$ = 36						; size = 4
?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z PROC NEAR		; CDC::BitBlt, COMDAT
; _this$ = ecx

; 548  : 	{ ASSERT(m_hDC != NULL); return ::BitBlt(m_hDC, x, y, nWidth, nHeight,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 549  : 		pSrcDC->GetSafeHdc(), xSrc, ySrc, dwRop); }

  00007	8b 45 24	 mov	 eax, DWORD PTR _dwRop$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 20	 mov	 ecx, DWORD PTR _ySrc$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 1c	 mov	 edx, DWORD PTR _xSrc$[ebp]
  00012	52		 push	 edx
  00013	8b 4d 18	 mov	 ecx, DWORD PTR _pSrcDC$[ebp]
  00016	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0001b	50		 push	 eax
  0001c	8b 45 14	 mov	 eax, DWORD PTR _nHeight$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR _nWidth$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	52		 push	 edx
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 20 00	 ret	 32			; 00000020H
?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z ENDP			; CDC::BitBlt
_TEXT	ENDS
EXTRN	__imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ?DrawTextA@CDC@@QAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRECT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_str$ = 8						; size = 4
_lpRect$ = 12						; size = 4
_nFormat$ = 16						; size = 4
?DrawTextA@CDC@@QAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRECT@@I@Z PROC NEAR ; CDC::DrawTextA, COMDAT
; _this$ = ecx

; 592  : 	{ ASSERT(m_hDC != NULL);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 593  : 		// these flags would modify the string
; 594  : 		ASSERT((nFormat & (DT_END_ELLIPSIS | DT_MODIFYSTRING)) != (DT_END_ELLIPSIS | DT_MODIFYSTRING));
; 595  : 		ASSERT((nFormat & (DT_PATH_ELLIPSIS | DT_MODIFYSTRING)) != (DT_PATH_ELLIPSIS | DT_MODIFYSTRING));
; 596  : 		return DrawText((LPCTSTR)str, (int)str.GetLength(), lpRect, nFormat); }

  00007	8b 45 10	 mov	 eax, DWORD PTR _nFormat$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00022	50		 push	 eax
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	ff 50 70	 call	 DWORD PTR [eax+112]
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
?DrawTextA@CDC@@QAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRECT@@I@Z ENDP ; CDC::DrawTextA
_TEXT	ENDS
PUBLIC	?FromHandle@CFont@@SGPAV1@PAUHFONT__@@@Z	; CFont::FromHandle
EXTRN	__imp__GetCurrentObject@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetCurrentFont@CDC@@QBEPAVCFont@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentFont@CDC@@QBEPAVCFont@@XZ PROC NEAR		; CDC::GetCurrentFont, COMDAT
; _this$ = ecx

; 772  : 	{ ASSERT(m_hAttribDC != NULL); return CFont::FromHandle((HFONT)::GetCurrentObject(m_hAttribDC, OBJ_FONT)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 06		 push	 6
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	51		 push	 ecx
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentObject@8
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?FromHandle@CFont@@SGPAV1@PAUHFONT__@@@Z ; CFont::FromHandle
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?GetCurrentFont@CDC@@QBEPAVCFont@@XZ ENDP		; CDC::GetCurrentFont
_TEXT	ENDS
EXTRN	?FromHandle@CGdiObject@@SGPAV1@PAX@Z:NEAR	; CGdiObject::FromHandle
; Function compile flags: /Odt
;	COMDAT ?FromHandle@CFont@@SGPAV1@PAUHFONT__@@@Z
_TEXT	SEGMENT
_hFont$ = 8						; size = 4
?FromHandle@CFont@@SGPAV1@PAUHFONT__@@@Z PROC NEAR	; CFont::FromHandle, COMDAT

; 151  : 	{ return (CFont*) CGdiObject::FromHandle(hFont); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _hFont$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?FromHandle@CGdiObject@@SGPAV1@PAX@Z ; CGdiObject::FromHandle
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?FromHandle@CFont@@SGPAV1@PAUHFONT__@@@Z ENDP		; CFont::FromHandle
_TEXT	ENDS
EXTRN	__imp__GetClientRect@8:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin2.inl
;	COMDAT ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z PROC NEAR	; CWnd::GetClientRect, COMDAT
; _this$ = ecx

; 107  : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ENDP		; CWnd::GetClientRect
_TEXT	ENDS
EXTRN	__imp__ScreenToClient@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpPoint$ = 8						; size = 4
?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z PROC NEAR	; CWnd::ScreenToClient, COMDAT
; _this$ = ecx

; 115  : 	{ ASSERT(::IsWindow(m_hWnd)); ::ScreenToClient(m_hWnd, lpPoint); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpPoint$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ScreenToClient@8
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z ENDP		; CWnd::ScreenToClient
_TEXT	ENDS
EXTRN	__imp__RedrawWindow@16:NEAR
; Function compile flags: /Odt
;	COMDAT ?RedrawWindow@CWnd@@QAEHPBUtagRECT@@PAVCRgn@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRectUpdate$ = 8					; size = 4
_prgnUpdate$ = 12					; size = 4
_flags$ = 16						; size = 4
?RedrawWindow@CWnd@@QAEHPBUtagRECT@@PAVCRgn@@I@Z PROC NEAR ; CWnd::RedrawWindow, COMDAT
; _this$ = ecx

; 172  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::RedrawWindow(m_hWnd, lpRectUpdate, (HRGN)prgnUpdate->GetSafeHandle(), flags); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _prgnUpdate$[ebp]
  0000e	e8 00 00 00 00	 call	 ?GetSafeHandle@CGdiObject@@QBEPAXXZ ; CGdiObject::GetSafeHandle
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _lpRectUpdate$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RedrawWindow@16
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 0c 00	 ret	 12			; 0000000cH
?RedrawWindow@CWnd@@QAEHPBUtagRECT@@PAVCRgn@@I@Z ENDP	; CWnd::RedrawWindow
_TEXT	ENDS
EXTRN	__imp__SetTimer@16:NEAR
; Function compile flags: /Odt
;	COMDAT ?SetTimer@CWnd@@QAEIIIP6GXPAUHWND__@@IIK@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIDEvent$ = 8						; size = 4
_nElapse$ = 12						; size = 4
_lpfnTimer$ = 16					; size = 4
?SetTimer@CWnd@@QAEIIIP6GXPAUHWND__@@IIK@Z@Z PROC NEAR	; CWnd::SetTimer, COMDAT
; _this$ = ecx

; 182  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::SetTimer(m_hWnd, nIDEvent, nElapse,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 183  : 		lpfnTimer); }

  00007	8b 45 10	 mov	 eax, DWORD PTR _lpfnTimer$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _nElapse$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR _nIDEvent$[ebp]
  00012	52		 push	 edx
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00019	51		 push	 ecx
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
?SetTimer@CWnd@@QAEIIIP6GXPAUHWND__@@IIK@Z@Z ENDP	; CWnd::SetTimer
_TEXT	ENDS
EXTRN	__imp__KillTimer@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?KillTimer@CWnd@@QAEHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIDEvent$ = 8						; size = 4
?KillTimer@CWnd@@QAEHI@Z PROC NEAR			; CWnd::KillTimer, COMDAT
; _this$ = ecx

; 185  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::KillTimer(m_hWnd, nIDEvent); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _nIDEvent$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?KillTimer@CWnd@@QAEHI@Z ENDP				; CWnd::KillTimer
_TEXT	ENDS
EXTRN	?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z:NEAR	; CWnd::FromHandle
EXTRN	__imp__SetCapture@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?SetCapture@CWnd@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetCapture@CWnd@@QAEPAV1@XZ PROC NEAR			; CWnd::SetCapture, COMDAT
; _this$ = ecx

; 199  : 	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetCapture(m_hWnd)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCapture@4
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z ; CWnd::FromHandle
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?SetCapture@CWnd@@QAEPAV1@XZ ENDP			; CWnd::SetCapture
_TEXT	ENDS
EXTRN	?Default@CWnd@@IAEJXZ:NEAR			; CWnd::Default
; Function compile flags: /Odt
;	COMDAT ?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z PROC NEAR	; CWnd::OnCreate, COMDAT
; _this$ = ecx

; 360  : 	{ return (int)Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z ENDP	; CWnd::OnCreate
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnEraseBkgnd@CWnd@@IAEHPAVCDC@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?OnEraseBkgnd@CWnd@@IAEHPAVCDC@@@Z PROC NEAR		; CWnd::OnEraseBkgnd, COMDAT
; _this$ = ecx

; 366  : 	{ return (BOOL)Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?OnEraseBkgnd@CWnd@@IAEHPAVCDC@@@Z ENDP			; CWnd::OnEraseBkgnd
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnKillFocus@CWnd@@IAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?OnKillFocus@CWnd@@IAEXPAV1@@Z PROC NEAR		; CWnd::OnKillFocus, COMDAT
; _this$ = ecx

; 372  : 	{ Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?OnKillFocus@CWnd@@IAEXPAV1@@Z ENDP			; CWnd::OnKillFocus
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnShowWindow@CWnd@@IAEXHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?OnShowWindow@CWnd@@IAEXHI@Z PROC NEAR			; CWnd::OnShowWindow, COMDAT
; _this$ = ecx

; 390  : 	{ Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?OnShowWindow@CWnd@@IAEXHI@Z ENDP			; CWnd::OnShowWindow
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnSize@CWnd@@IAEXIHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?OnSize@CWnd@@IAEXIHH@Z PROC NEAR			; CWnd::OnSize, COMDAT
; _this$ = ecx

; 392  : 	{ Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
?OnSize@CWnd@@IAEXIHH@Z ENDP				; CWnd::OnSize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnLButtonDown@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?OnLButtonDown@CWnd@@IAEXIVCPoint@@@Z PROC NEAR		; CWnd::OnLButtonDown, COMDAT
; _this$ = ecx

; 464  : 	{ Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
?OnLButtonDown@CWnd@@IAEXIVCPoint@@@Z ENDP		; CWnd::OnLButtonDown
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnLButtonUp@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?OnLButtonUp@CWnd@@IAEXIVCPoint@@@Z PROC NEAR		; CWnd::OnLButtonUp, COMDAT
; _this$ = ecx

; 466  : 	{ Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
?OnLButtonUp@CWnd@@IAEXIVCPoint@@@Z ENDP		; CWnd::OnLButtonUp
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z PROC NEAR		; CWnd::OnMouseMove, COMDAT
; _this$ = ecx

; 476  : 	{ Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
?OnMouseMove@CWnd@@IAEXIVCPoint@@@Z ENDP		; CWnd::OnMouseMove
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnMouseWheel@CWnd@@IAEHIFVCPoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 8
?OnMouseWheel@CWnd@@IAEHIFVCPoint@@@Z PROC NEAR		; CWnd::OnMouseWheel, COMDAT
; _this$ = ecx

; 478  : 	{ return (BOOL)Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 10 00	 ret	 16			; 00000010H
?OnMouseWheel@CWnd@@IAEHIFVCPoint@@@Z ENDP		; CWnd::OnMouseWheel
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnRButtonDown@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?OnRButtonDown@CWnd@@IAEXIVCPoint@@@Z PROC NEAR		; CWnd::OnRButtonDown, COMDAT
; _this$ = ecx

; 484  : 	{ Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
?OnRButtonDown@CWnd@@IAEXIVCPoint@@@Z ENDP		; CWnd::OnRButtonDown
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnRButtonUp@CWnd@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?OnRButtonUp@CWnd@@IAEXIVCPoint@@@Z PROC NEAR		; CWnd::OnRButtonUp, COMDAT
; _this$ = ecx

; 486  : 	{ Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
?OnRButtonUp@CWnd@@IAEXIVCPoint@@@Z ENDP		; CWnd::OnRButtonUp
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?OnTimer@CWnd@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?OnTimer@CWnd@@IAEXI@Z PROC NEAR			; CWnd::OnTimer, COMDAT
; _this$ = ecx

; 488  : 	{ Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?OnTimer@CWnd@@IAEXI@Z ENDP				; CWnd::OnTimer
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z PROC NEAR ; CWnd::DoDataExchange, COMDAT
; _this$ = ecx

; 545  : 	{ } // default does nothing

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z ENDP	; CWnd::DoDataExchange
_TEXT	ENDS
EXTRN	__imp__EnableWindow@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?BeginModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BeginModalState@CWnd@@UAEXXZ PROC NEAR			; CWnd::BeginModalState, COMDAT
; _this$ = ecx

; 549  : 	{ ::EnableWindow(m_hWnd, FALSE); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	51		 push	 ecx
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?BeginModalState@CWnd@@UAEXXZ ENDP			; CWnd::BeginModalState
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?EndModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EndModalState@CWnd@@UAEXXZ PROC NEAR			; CWnd::EndModalState, COMDAT
; _this$ = ecx

; 551  : 	{ ::EnableWindow(m_hWnd, TRUE); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 01		 push	 1
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	51		 push	 ecx
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?EndModalState@CWnd@@UAEXXZ ENDP			; CWnd::EndModalState
_TEXT	ENDS
EXTRN	__imp__LoadCursorA@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?LoadStandardCursor@CWinApp@@QBEPAUHICON__@@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpszCursorName$ = 8					; size = 4
?LoadStandardCursor@CWinApp@@QBEPAUHICON__@@PBD@Z PROC NEAR ; CWinApp::LoadStandardCursor, COMDAT
; _this$ = ecx

; 1007 : 	{ return ::LoadCursor(NULL, lpszCursorName); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpszCursorName$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?LoadStandardCursor@CWinApp@@QBEPAUHICON__@@PBD@Z ENDP	; CWinApp::LoadStandardCursor
_TEXT	ENDS
EXTRN	__imp__AlphaBlend@44:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin3.inl
;	COMDAT ?AlphaBlend@CDC@@QAEHHHHHPAV1@HHHHU_BLENDFUNCTION@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_xDest$ = 8						; size = 4
_yDest$ = 12						; size = 4
_nDestWidth$ = 16					; size = 4
_nDestHeight$ = 20					; size = 4
_pSrcDC$ = 24						; size = 4
_xSrc$ = 28						; size = 4
_ySrc$ = 32						; size = 4
_nSrcWidth$ = 36					; size = 4
_nSrcHeight$ = 40					; size = 4
_blend$ = 44						; size = 4
?AlphaBlend@CDC@@QAEHHHHHPAV1@HHHHU_BLENDFUNCTION@@@Z PROC NEAR ; CDC::AlphaBlend, COMDAT
; _this$ = ecx

; 21   :    { ASSERT(m_hDC != NULL); return ::AlphaBlend(m_hDC, xDest, yDest, 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 22   : 	  nDestWidth, nDestHeight, pSrcDC->GetSafeHdc(), xSrc, ySrc, nSrcWidth, 
; 23   : 	  nSrcHeight, blend); }

  00007	8b 45 2c	 mov	 eax, DWORD PTR _blend$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 28	 mov	 ecx, DWORD PTR _nSrcHeight$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 24	 mov	 edx, DWORD PTR _nSrcWidth$[ebp]
  00012	52		 push	 edx
  00013	8b 45 20	 mov	 eax, DWORD PTR _ySrc$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 1c	 mov	 ecx, DWORD PTR _xSrc$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 4d 18	 mov	 ecx, DWORD PTR _pSrcDC$[ebp]
  0001e	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  00023	50		 push	 eax
  00024	8b 55 14	 mov	 edx, DWORD PTR _nDestHeight$[ebp]
  00027	52		 push	 edx
  00028	8b 45 10	 mov	 eax, DWORD PTR _nDestWidth$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _yDest$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _xDest$[ebp]
  00033	52		 push	 edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	51		 push	 ecx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AlphaBlend@44
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 28 00	 ret	 40			; 00000028H
?AlphaBlend@CDC@@QAEHHHHHPAV1@HHHHU_BLENDFUNCTION@@@Z ENDP ; CDC::AlphaBlend
_TEXT	ENDS
EXTRN	__imp__ImageList_EndDrag@0:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxcmn.inl
;	COMDAT ?EndDrag@CImageList@@SGXXZ
_TEXT	SEGMENT
?EndDrag@CImageList@@SGXXZ PROC NEAR			; CImageList::EndDrag, COMDAT

; 527  : 	{ ImageList_EndDrag(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ImageList_EndDrag@0
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?EndDrag@CImageList@@SGXXZ ENDP				; CImageList::EndDrag
_TEXT	ENDS
PUBLIC	?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ		; CWnd::GetSafeHwnd
EXTRN	__imp__ImageList_DragLeave@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?DragLeave@CImageList@@SGHPAVCWnd@@@Z
_TEXT	SEGMENT
_pWndLock$ = 8						; size = 4
?DragLeave@CImageList@@SGHPAVCWnd@@@Z PROC NEAR		; CImageList::DragLeave, COMDAT

; 539  : 	{ return ImageList_DragLeave(pWndLock->GetSafeHwnd()); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pWndLock$[ebp]
  00006	e8 00 00 00 00	 call	 ?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ ; CWnd::GetSafeHwnd
  0000b	50		 push	 eax
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ImageList_DragLeave@4
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?DragLeave@CImageList@@SGHPAVCWnd@@@Z ENDP		; CImageList::DragLeave
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin2.inl
_TEXT	ENDS
;	COMDAT ?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ PROC NEAR		; CWnd::GetSafeHwnd, COMDAT
; _this$ = ecx

; 27   : 	{ return this == NULL ? NULL : m_hWnd; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  0000d	75 09		 jne	 SHORT $L203849
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00016	eb 09		 jmp	 SHORT $L203850
$L203849:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001e	89 4d f8	 mov	 DWORD PTR tv66[ebp], ecx
$L203850:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ ENDP		; CWnd::GetSafeHwnd
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z PROC NEAR ; std::_Ptr_cat, COMDAT

; 335  : 	{	// return pointer category from pointer to int arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 336  : 	_Scalar_ptr_iterator_tag _Cat;
; 337  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 338  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ENDP ; std::_Ptr_cat
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 28   : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203865 DD	0ffffffffH
	DD	FLAT:$L203860
$T203863 DD	019930520H
	DD	01H
	DD	FLAT:$T203865
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 20   : 		}

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203860:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203863
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102266
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102266:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203877 DD	0ffffffffH
	DD	FLAT:$L203872
$T203875 DD	019930520H
	DD	01H
	DD	FLAT:$T203877
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203872:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203875
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102332
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102332:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdiplustypes.h
_TEXT	ENDS
;	COMDAT ??0Point@Gdiplus@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
??0Point@Gdiplus@@QAE@HH@Z PROC NEAR			; Gdiplus::Point::Point, COMDAT
; _this$ = ecx

; 296  :    Point(IN INT x,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 297  :          IN INT y)
; 298  :    {
; 299  :        X = x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 300  :        Y = y;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 301  :    }

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0Point@Gdiplus@@QAE@HH@Z ENDP				; Gdiplus::Point::Point
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0Rect@Gdiplus@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
??0Rect@Gdiplus@@QAE@HHHH@Z PROC NEAR			; Gdiplus::Rect::Rect, COMDAT
; _this$ = ecx

; 527  :     Rect(IN INT x,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 528  :          IN INT y,
; 529  :          IN INT width,
; 530  :          IN INT height)
; 531  :     {
; 532  :         X = x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 533  :         Y = y;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 534  :         Width = width;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 535  :         Height = height;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _height$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 536  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
??0Rect@Gdiplus@@QAE@HHHH@Z ENDP			; Gdiplus::Rect::Rect
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdipluscolor.h
_TEXT	ENDS
;	COMDAT ??0Color@Gdiplus@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Color@Gdiplus@@QAE@XZ PROC NEAR			; Gdiplus::Color::Color, COMDAT
; _this$ = ecx

; 49   :     Color()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 50   :     {
; 51   :         Argb = (ARGB)Color::Black;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	ff		 mov	 DWORD PTR [eax], -16777216 ; ff000000H

; 52   :     }

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0Color@Gdiplus@@QAE@XZ ENDP				; Gdiplus::Color::Color
_TEXT	ENDS
PUBLIC	?MakeARGB@Color@Gdiplus@@SAKEEEE@Z		; Gdiplus::Color::MakeARGB
; Function compile flags: /Odt
;	COMDAT ?SetFromCOLORREF@Color@Gdiplus@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rgb$ = 8						; size = 4
?SetFromCOLORREF@Color@Gdiplus@@QAEXK@Z PROC NEAR	; Gdiplus::Color::SetFromCOLORREF, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 131  :         Argb = MakeARGB(255, GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));

  00007	8b 45 08	 mov	 eax, DWORD PTR _rgb$[ebp]
  0000a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0000d	50		 push	 eax
  0000e	0f b7 4d 08	 movzx	 ecx, WORD PTR _rgb$[ebp]
  00012	c1 f9 08	 sar	 ecx, 8
  00015	51		 push	 ecx
  00016	8a 55 08	 mov	 dl, BYTE PTR _rgb$[ebp]
  00019	52		 push	 edx
  0001a	68 ff 00 00 00	 push	 255			; 000000ffH
  0001f	e8 00 00 00 00	 call	 ?MakeARGB@Color@Gdiplus@@SAKEEEE@Z ; Gdiplus::Color::MakeARGB
  00024	83 c4 10	 add	 esp, 16			; 00000010H
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	89 01		 mov	 DWORD PTR [ecx], eax

; 132  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
?SetFromCOLORREF@Color@Gdiplus@@QAEXK@Z ENDP		; Gdiplus::Color::SetFromCOLORREF
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?MakeARGB@Color@Gdiplus@@SAKEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?MakeARGB@Color@Gdiplus@@SAKEEEE@Z PROC NEAR		; Gdiplus::Color::MakeARGB, COMDAT

; 312  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  :         return (((ARGB) (b) <<  BlueShift) |
; 314  :                 ((ARGB) (g) << GreenShift) |
; 315  :                 ((ARGB) (r) <<   RedShift) |
; 316  :                 ((ARGB) (a) << AlphaShift));

  00003	0f b6 45 14	 movzx	 eax, BYTE PTR _b$[ebp]
  00007	0f b6 4d 10	 movzx	 ecx, BYTE PTR _g$[ebp]
  0000b	c1 e1 08	 shl	 ecx, 8
  0000e	0b c1		 or	 eax, ecx
  00010	0f b6 55 0c	 movzx	 edx, BYTE PTR _r$[ebp]
  00014	c1 e2 10	 shl	 edx, 16			; 00000010H
  00017	0b c2		 or	 eax, edx
  00019	0f b6 4d 08	 movzx	 ecx, BYTE PTR _a$[ebp]
  0001d	c1 e1 18	 shl	 ecx, 24			; 00000018H
  00020	0b c1		 or	 eax, ecx

; 317  :     }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?MakeARGB@Color@Gdiplus@@SAKEEEE@Z ENDP			; Gdiplus::Color::MakeARGB
_TEXT	ENDS
PUBLIC	?GetValue@Color@Gdiplus@@QBEKXZ			; Gdiplus::Color::GetValue
EXTRN	_GdipCreatePen1@16:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdipluspen.h
;	COMDAT ??0Pen@Gdiplus@@QAE@ABVColor@1@M@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_unit$ = -4						; size = 4
_color$ = 8						; size = 4
_width$ = 12						; size = 4
??0Pen@Gdiplus@@QAE@ABVColor@1@M@Z PROC NEAR		; Gdiplus::Pen::Pen, COMDAT
; _this$ = ecx

; 27   :     Pen(IN const Color& color, 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 28   :         IN REAL width = 1.0f)
; 29   :     {
; 30   :         Unit unit = UnitWorld;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _unit$[ebp], 0

; 31   :         nativePen = NULL;

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 32   :         lastResult = DllExports::GdipCreatePen1(color.GetValue(),
; 33   :                                     width, unit, &nativePen);

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 fc	 mov	 edx, DWORD PTR _unit$[ebp]
  00020	52		 push	 edx
  00021	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _color$[ebp]
  00028	e8 00 00 00 00	 call	 ?GetValue@Color@Gdiplus@@QBEKXZ ; Gdiplus::Color::GetValue
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _GdipCreatePen1@16
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 34   :     }

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
??0Pen@Gdiplus@@QAE@ABVColor@1@M@Z ENDP			; Gdiplus::Pen::Pen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdipluscolor.h
_TEXT	ENDS
;	COMDAT ?GetValue@Color@Gdiplus@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetValue@Color@Gdiplus@@QBEKXZ PROC NEAR		; Gdiplus::Color::GetValue, COMDAT
; _this$ = ecx

; 120  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  :         return Argb;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 122  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetValue@Color@Gdiplus@@QBEKXZ ENDP			; Gdiplus::Color::GetValue
_TEXT	ENDS
EXTRN	_GdipDeletePen@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdipluspen.h
;	COMDAT ??1Pen@Gdiplus@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Pen@Gdiplus@@QAE@XZ PROC NEAR			; Gdiplus::Pen::~Pen, COMDAT
; _this$ = ecx

; 46   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 47   :         DllExports::GdipDeletePen(nativePen);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _GdipDeletePen@4

; 48   :     }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1Pen@Gdiplus@@QAE@XZ ENDP				; Gdiplus::Pen::~Pen
_TEXT	ENDS
EXTRN	_GdipCreatePath@8:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdipluspath.h
;	COMDAT ??0GraphicsPath@Gdiplus@@QAE@W4FillMode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fillMode$ = 8						; size = 4
??0GraphicsPath@Gdiplus@@QAE@W4FillMode@1@@Z PROC NEAR	; Gdiplus::GraphicsPath::GraphicsPath, COMDAT
; _this$ = ecx

; 27   :     GraphicsPath(IN FillMode fillMode = FillModeAlternate)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   :     {
; 29   :         nativePath = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 30   :         lastResult = DllExports::GdipCreatePath(fillMode, &nativePath);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _fillMode$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _GdipCreatePath@8
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 31   :     }

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??0GraphicsPath@Gdiplus@@QAE@W4FillMode@1@@Z ENDP	; Gdiplus::GraphicsPath::GraphicsPath
_TEXT	ENDS
EXTRN	_GdipDeletePath@4:NEAR
; Function compile flags: /Odt
;	COMDAT ??1GraphicsPath@Gdiplus@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1GraphicsPath@Gdiplus@@QAE@XZ PROC NEAR		; Gdiplus::GraphicsPath::~GraphicsPath, COMDAT
; _this$ = ecx

; 60   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 61   :         DllExports::GdipDeletePath(nativePath);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _GdipDeletePath@4

; 62   :     }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1GraphicsPath@Gdiplus@@QAE@XZ ENDP			; Gdiplus::GraphicsPath::~GraphicsPath
_TEXT	ENDS
PUBLIC	??0GraphicsPath@Gdiplus@@IAE@PAVGpPath@1@@Z	; Gdiplus::GraphicsPath::GraphicsPath
PUBLIC	?SetStatus@GraphicsPath@Gdiplus@@IBE?AW4Status@2@W432@@Z ; Gdiplus::GraphicsPath::SetStatus
PUBLIC	??3GdiplusBase@Gdiplus@@SAXPAX@Z		; Gdiplus::GdiplusBase::operator delete
PUBLIC	??2GdiplusBase@Gdiplus@@SAPAXI@Z		; Gdiplus::GdiplusBase::operator new
EXTRN	_GdipClonePath@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203915 DD	0ffffffffH
	DD	FLAT:$L203911
$T203913 DD	019930520H
	DD	01H
	DD	FLAT:$T203915
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?Clone@GraphicsPath@Gdiplus@@QBEPAV12@XZ
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
$T203908 = -24						; size = 4
$T203907 = -20						; size = 4
_clonepath$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Clone@GraphicsPath@Gdiplus@@QBEPAV12@XZ PROC NEAR	; Gdiplus::GraphicsPath::Clone, COMDAT
; _this$ = ecx

; 65   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Clone@GraphicsPath@Gdiplus@@QBEPAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 14	 sub	 esp, 20			; 00000014H
  0001b	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :         GpPath *clonepath = NULL;

  0001e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _clonepath$[ebp], 0

; 67   : 
; 68   :         SetStatus(DllExports::GdipClonePath(nativePath, &clonepath));

  00025	8d 45 f0	 lea	 eax, DWORD PTR _clonepath$[ebp]
  00028	50		 push	 eax
  00029	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 _GdipClonePath@8
  00034	50		 push	 eax
  00035	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?SetStatus@GraphicsPath@Gdiplus@@IBE?AW4Status@2@W432@@Z ; Gdiplus::GraphicsPath::SetStatus

; 69   : 
; 70   :         return new GraphicsPath(clonepath);

  0003d	6a 08		 push	 8
  0003f	e8 00 00 00 00	 call	 ??2GdiplusBase@Gdiplus@@SAPAXI@Z ; Gdiplus::GdiplusBase::operator new
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 e8	 mov	 DWORD PTR $T203908[ebp], eax
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00051	83 7d e8 00	 cmp	 DWORD PTR $T203908[ebp], 0
  00055	74 11		 je	 SHORT $L203909
  00057	8b 45 f0	 mov	 eax, DWORD PTR _clonepath$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d e8	 mov	 ecx, DWORD PTR $T203908[ebp]
  0005e	e8 00 00 00 00	 call	 ??0GraphicsPath@Gdiplus@@IAE@PAVGpPath@1@@Z ; Gdiplus::GraphicsPath::GraphicsPath
  00063	89 45 e0	 mov	 DWORD PTR tv77[ebp], eax
  00066	eb 07		 jmp	 SHORT $L203910
$L203909:
  00068	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$L203910:
  0006f	8b 4d e0	 mov	 ecx, DWORD PTR tv77[ebp]
  00072	89 4d ec	 mov	 DWORD PTR $T203907[ebp], ecx
  00075	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007c	8b 45 ec	 mov	 eax, DWORD PTR $T203907[ebp]

; 71   :     }

  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00082	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203911:
  00000	8b 45 e8	 mov	 eax, DWORD PTR $T203908[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3GdiplusBase@Gdiplus@@SAXPAX@Z ; Gdiplus::GdiplusBase::operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?Clone@GraphicsPath@Gdiplus@@QBEPAV12@XZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203913
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Clone@GraphicsPath@Gdiplus@@QBEPAV12@XZ ENDP		; Gdiplus::GraphicsPath::Clone
EXTRN	_GdipFree@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdiplusbase.h
;	COMDAT ??3GdiplusBase@Gdiplus@@SAXPAX@Z
_TEXT	SEGMENT
_in_pVoid$ = 8						; size = 4
??3GdiplusBase@Gdiplus@@SAXPAX@Z PROC NEAR		; Gdiplus::GdiplusBase::operator delete, COMDAT

; 22   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   :        DllExports::GdipFree(in_pVoid);

  00003	8b 45 08	 mov	 eax, DWORD PTR _in_pVoid$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _GdipFree@4

; 24   :     }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3GdiplusBase@Gdiplus@@SAXPAX@Z ENDP			; Gdiplus::GdiplusBase::operator delete
_TEXT	ENDS
EXTRN	_GdipAlloc@4:NEAR
; Function compile flags: /Odt
;	COMDAT ??2GdiplusBase@Gdiplus@@SAPAXI@Z
_TEXT	SEGMENT
_in_size$ = 8						; size = 4
??2GdiplusBase@Gdiplus@@SAPAXI@Z PROC NEAR		; Gdiplus::GdiplusBase::operator new, COMDAT

; 26   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 27   :        return DllExports::GdipAlloc(in_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR _in_size$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _GdipAlloc@4

; 28   :     }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??2GdiplusBase@Gdiplus@@SAPAXI@Z ENDP			; Gdiplus::GdiplusBase::operator new
_TEXT	ENDS
EXTRN	_GdipAddPathLineI@20:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdipluspath.h
;	COMDAT ?AddLine@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?AddLine@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHH@Z PROC NEAR ; Gdiplus::GraphicsPath::AddLine, COMDAT
; _this$ = ecx

; 218  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 219  :         return SetStatus(DllExports::GdipAddPathLineI(nativePath,
; 220  :                                                      x1,
; 221  :                                                      y1,
; 222  :                                                      x2,
; 223  :                                                      y2));

  00007	8b 45 14	 mov	 eax, DWORD PTR _y2$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _x2$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _y1$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR _x1$[ebp]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 _GdipAddPathLineI@20
  00022	50		 push	 eax
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?SetStatus@GraphicsPath@Gdiplus@@IBE?AW4Status@2@W432@@Z ; Gdiplus::GraphicsPath::SetStatus

; 224  :     }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
?AddLine@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHH@Z ENDP ; Gdiplus::GraphicsPath::AddLine
_TEXT	ENDS
EXTRN	_GdipAddPathArcI@28:NEAR
; Function compile flags: /Odt
;	COMDAT ?AddArc@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHHMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_startAngle$ = 24					; size = 4
_sweepAngle$ = 28					; size = 4
?AddArc@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHHMM@Z PROC NEAR ; Gdiplus::GraphicsPath::AddArc, COMDAT
; _this$ = ecx

; 268  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 269  :         return SetStatus(DllExports::GdipAddPathArcI(nativePath,
; 270  :                                                     x,
; 271  :                                                     y,
; 272  :                                                     width,
; 273  :                                                     height,
; 274  :                                                     startAngle,
; 275  :                                                     sweepAngle));

  00007	8b 45 1c	 mov	 eax, DWORD PTR _sweepAngle$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 18	 mov	 ecx, DWORD PTR _startAngle$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 14	 mov	 edx, DWORD PTR _height$[ebp]
  00012	52		 push	 edx
  00013	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0001e	52		 push	 edx
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 _GdipAddPathArcI@28
  0002a	50		 push	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?SetStatus@GraphicsPath@Gdiplus@@IBE?AW4Status@2@W432@@Z ; Gdiplus::GraphicsPath::SetStatus

; 276  :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 18 00	 ret	 24			; 00000018H
?AddArc@GraphicsPath@Gdiplus@@QAE?AW4Status@2@HHHHMM@Z ENDP ; Gdiplus::GraphicsPath::AddArc
_TEXT	ENDS
PUBLIC	?SetNativePath@GraphicsPath@Gdiplus@@IAEXPAVGpPath@2@@Z ; Gdiplus::GraphicsPath::SetNativePath
; Function compile flags: /Odt
;	COMDAT ??0GraphicsPath@Gdiplus@@IAE@PAVGpPath@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nativePath$ = 8					; size = 4
??0GraphicsPath@Gdiplus@@IAE@PAVGpPath@1@@Z PROC NEAR	; Gdiplus::GraphicsPath::GraphicsPath, COMDAT
; _this$ = ecx

; 873  :     GraphicsPath(GpPath* nativePath)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 874  :     {
; 875  :         lastResult = Ok;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 876  :         SetNativePath(nativePath);

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _nativePath$[ebp]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?SetNativePath@GraphicsPath@Gdiplus@@IAEXPAVGpPath@2@@Z ; Gdiplus::GraphicsPath::SetNativePath

; 877  :     }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0GraphicsPath@Gdiplus@@IAE@PAVGpPath@1@@Z ENDP	; Gdiplus::GraphicsPath::GraphicsPath
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNativePath@GraphicsPath@Gdiplus@@IAEXPAVGpPath@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nativePath$ = 8					; size = 4
?SetNativePath@GraphicsPath@Gdiplus@@IAEXPAVGpPath@2@@Z PROC NEAR ; Gdiplus::GraphicsPath::SetNativePath, COMDAT
; _this$ = ecx

; 880  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 881  :         this->nativePath = nativePath;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _nativePath$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 882  :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetNativePath@GraphicsPath@Gdiplus@@IAEXPAVGpPath@2@@Z ENDP ; Gdiplus::GraphicsPath::SetNativePath
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetStatus@GraphicsPath@Gdiplus@@IBE?AW4Status@2@W432@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_status$ = 8						; size = 4
?SetStatus@GraphicsPath@Gdiplus@@IBE?AW4Status@2@W432@@Z PROC NEAR ; Gdiplus::GraphicsPath::SetStatus, COMDAT
; _this$ = ecx

; 885  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 886  :         if (status != Ok)

  00007	83 7d 08 00	 cmp	 DWORD PTR _status$[ebp], 0
  0000b	74 0e		 je	 SHORT $L124166

; 887  :             return (lastResult = status);

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _status$[ebp]
  00013	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00016	8b 45 08	 mov	 eax, DWORD PTR _status$[ebp]
  00019	eb 03		 jmp	 SHORT $L124165
$L124166:

; 888  :         else
; 889  :             return status;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _status$[ebp]
$L124165:

; 890  :     }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?SetStatus@GraphicsPath@Gdiplus@@IBE?AW4Status@2@W432@@Z ENDP ; Gdiplus::GraphicsPath::SetStatus
_TEXT	ENDS
PUBLIC	?SetNativeGraphics@Graphics@Gdiplus@@IAEXPAVGpGraphics@2@@Z ; Gdiplus::Graphics::SetNativeGraphics
EXTRN	_GdipCreateFromHDC@8:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdiplusgraphics.h
;	COMDAT ??0Graphics@Gdiplus@@QAE@PAUHDC__@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_graphics$ = -4						; size = 4
_hdc$ = 8						; size = 4
??0Graphics@Gdiplus@@QAE@PAUHDC__@@@Z PROC NEAR		; Gdiplus::Graphics::Graphics, COMDAT
; _this$ = ecx

; 53   :     Graphics(IN HDC hdc)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 54   :     {
; 55   :         GpGraphics *graphics = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _graphics$[ebp], 0

; 56   : 
; 57   :         lastResult = DllExports::GdipCreateFromHDC(hdc, &graphics);

  00010	8d 45 fc	 lea	 eax, DWORD PTR _graphics$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _hdc$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _GdipCreateFromHDC@8
  0001d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00020	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 58   : 
; 59   :         SetNativeGraphics(graphics);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _graphics$[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?SetNativeGraphics@Graphics@Gdiplus@@IAEXPAVGpGraphics@2@@Z ; Gdiplus::Graphics::SetNativeGraphics

; 60   :     }

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??0Graphics@Gdiplus@@QAE@PAUHDC__@@@Z ENDP		; Gdiplus::Graphics::Graphics
_TEXT	ENDS
EXTRN	_GdipDeleteGraphics@4:NEAR
; Function compile flags: /Odt
;	COMDAT ??1Graphics@Gdiplus@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Graphics@Gdiplus@@QAE@XZ PROC NEAR			; Gdiplus::Graphics::~Graphics, COMDAT
; _this$ = ecx

; 102  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 103  :         DllExports::GdipDeleteGraphics(nativeGraphics);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _GdipDeleteGraphics@4

; 104  :     }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1Graphics@Gdiplus@@QAE@XZ ENDP			; Gdiplus::Graphics::~Graphics
_TEXT	ENDS
PUBLIC	?SetStatus@Graphics@Gdiplus@@IBE?AW4Status@2@W432@@Z ; Gdiplus::Graphics::SetStatus
EXTRN	_GdipSetSmoothingMode@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?SetSmoothingMode@Graphics@Gdiplus@@QAE?AW4Status@2@W4SmoothingMode@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_smoothingMode$ = 8					; size = 4
?SetSmoothingMode@Graphics@Gdiplus@@QAE?AW4Status@2@W4SmoothingMode@2@@Z PROC NEAR ; Gdiplus::Graphics::SetSmoothingMode, COMDAT
; _this$ = ecx

; 246  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 247  :         return SetStatus(DllExports::GdipSetSmoothingMode(nativeGraphics,
; 248  :                                                           smoothingMode));

  00007	8b 45 08	 mov	 eax, DWORD PTR _smoothingMode$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _GdipSetSmoothingMode@8
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?SetStatus@Graphics@Gdiplus@@IBE?AW4Status@2@W432@@Z ; Gdiplus::Graphics::SetStatus

; 249  :     }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?SetSmoothingMode@Graphics@Gdiplus@@QAE?AW4Status@2@W4SmoothingMode@2@@Z ENDP ; Gdiplus::Graphics::SetSmoothingMode
_TEXT	ENDS
EXTRN	_GdipDrawPath@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?DrawPath@Graphics@Gdiplus@@QAE?AW4Status@2@PBVPen@2@PBVGraphicsPath@2@@Z
_TEXT	SEGMENT
tv71 = -12						; size = 4
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_pen$ = 8						; size = 4
_path$ = 12						; size = 4
?DrawPath@Graphics@Gdiplus@@QAE?AW4Status@2@PBVPen@2@PBVGraphicsPath@2@@Z PROC NEAR ; Gdiplus::Graphics::DrawPath, COMDAT
; _this$ = ecx

; 814  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 815  :         return SetStatus(DllExports::GdipDrawPath(nativeGraphics,
; 816  :                                                   pen ? pen->nativePen : NULL,
; 817  :                                                   path ? path->nativePath : NULL));

  00009	83 7d 0c 00	 cmp	 DWORD PTR _path$[ebp], 0
  0000d	74 0a		 je	 SHORT $L203940
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _path$[ebp]
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00017	eb 07		 jmp	 SHORT $L203941
$L203940:
  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L203941:
  00020	83 7d 08 00	 cmp	 DWORD PTR _pen$[ebp], 0
  00024	74 0a		 je	 SHORT $L203942
  00026	8b 55 08	 mov	 edx, DWORD PTR _pen$[ebp]
  00029	8b 02		 mov	 eax, DWORD PTR [edx]
  0002b	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  0002e	eb 07		 jmp	 SHORT $L203943
$L203942:
  00030	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L203943:
  00037	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 f4	 mov	 edx, DWORD PTR tv71[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 _GdipDrawPath@12
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?SetStatus@Graphics@Gdiplus@@IBE?AW4Status@2@W432@@Z ; Gdiplus::Graphics::SetStatus

; 818  :     }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
?DrawPath@Graphics@Gdiplus@@QAE?AW4Status@2@PBVPen@2@PBVGraphicsPath@2@@Z ENDP ; Gdiplus::Graphics::DrawPath
_TEXT	ENDS
PUBLIC	?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@HHHH@Z ; Gdiplus::Graphics::DrawImage
; Function compile flags: /Odt
;	COMDAT ?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@ABVRect@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_image$ = 8						; size = 4
_rect$ = 12						; size = 4
?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@ABVRect@2@@Z PROC NEAR ; Gdiplus::Graphics::DrawImage, COMDAT
; _this$ = ecx

; 1546 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1547 :         return DrawImage(image,
; 1548 :                          rect.X,
; 1549 :                          rect.Y,
; 1550 :                          rect.Width,
; 1551 :                          rect.Height);

  00007	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0000a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  00011	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00014	50		 push	 eax
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	52		 push	 edx
  0001c	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _image$[ebp]
  00025	52		 push	 edx
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@HHHH@Z ; Gdiplus::Graphics::DrawImage

; 1552 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@ABVRect@2@@Z ENDP ; Gdiplus::Graphics::DrawImage
_TEXT	ENDS
EXTRN	_GdipDrawImageRectI@24:NEAR
; Function compile flags: /Odt
;	COMDAT ?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@HHHH@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_image$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@HHHH@Z PROC NEAR ; Gdiplus::Graphics::DrawImage, COMDAT
; _this$ = ecx

; 1558 :                      IN INT height) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1559 :         return SetStatus(DllExports::GdipDrawImageRectI(nativeGraphics,
; 1560 :                                                         image ? image->nativeImage
; 1561 :                                                               : NULL,
; 1562 :                                                         x,
; 1563 :                                                         y,
; 1564 :                                                         width,
; 1565 :                                                         height));

  00009	83 7d 08 00	 cmp	 DWORD PTR _image$[ebp], 0
  0000d	74 0b		 je	 SHORT $L203948
  0000f	8b 45 08	 mov	 eax, DWORD PTR _image$[ebp]
  00012	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00015	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00018	eb 07		 jmp	 SHORT $L203949
$L203948:
  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$L203949:
  00021	8b 55 18	 mov	 edx, DWORD PTR _height$[ebp]
  00024	52		 push	 edx
  00025	8b 45 14	 mov	 eax, DWORD PTR _width$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00030	52		 push	 edx
  00031	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 _GdipDrawImageRectI@24
  00040	50		 push	 eax
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?SetStatus@Graphics@Gdiplus@@IBE?AW4Status@2@W432@@Z ; Gdiplus::Graphics::SetStatus

; 1566 :     }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 14 00	 ret	 20			; 00000014H
?DrawImage@Graphics@Gdiplus@@QAE?AW4Status@2@PAVImage@2@HHHH@Z ENDP ; Gdiplus::Graphics::DrawImage
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNativeGraphics@Graphics@Gdiplus@@IAEXPAVGpGraphics@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_graphics$ = 8						; size = 4
?SetNativeGraphics@Graphics@Gdiplus@@IAEXPAVGpGraphics@2@@Z PROC NEAR ; Gdiplus::Graphics::SetNativeGraphics, COMDAT
; _this$ = ecx

; 2339 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2340 :         this->nativeGraphics = graphics;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _graphics$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 2341 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetNativeGraphics@Graphics@Gdiplus@@IAEXPAVGpGraphics@2@@Z ENDP ; Gdiplus::Graphics::SetNativeGraphics
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetStatus@Graphics@Gdiplus@@IBE?AW4Status@2@W432@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_status$ = 8						; size = 4
?SetStatus@Graphics@Gdiplus@@IBE?AW4Status@2@W432@@Z PROC NEAR ; Gdiplus::Graphics::SetStatus, COMDAT
; _this$ = ecx

; 2344 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2345 :         if (status != Ok)

  00007	83 7d 08 00	 cmp	 DWORD PTR _status$[ebp], 0
  0000b	74 0e		 je	 SHORT $L126192

; 2346 :             return (lastResult = status);

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _status$[ebp]
  00013	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00016	8b 45 08	 mov	 eax, DWORD PTR _status$[ebp]
  00019	eb 03		 jmp	 SHORT $L126191
$L126192:

; 2347 :         else
; 2348 :             return status;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _status$[ebp]
$L126191:

; 2349 :     }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?SetStatus@Graphics@Gdiplus@@IBE?AW4Status@2@W432@@Z ENDP ; Gdiplus::Graphics::SetStatus
_TEXT	ENDS
PUBLIC	??_R13?0A@A@GdiplusBase@Gdiplus@@8		; Gdiplus::GdiplusBase::`RTTI Base Class Descriptor at (4,-1,0,0)'
PUBLIC	??_R0?AVGdiplusBase@Gdiplus@@@8			; Gdiplus::GdiplusBase `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@Image@Gdiplus@@8			; Gdiplus::Image::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVImage@Gdiplus@@@8			; Gdiplus::Image `RTTI Type Descriptor'
PUBLIC	??_R4Image@Gdiplus@@6B@				; Gdiplus::Image::`RTTI Complete Object Locator'
PUBLIC	??_R3Image@Gdiplus@@8				; Gdiplus::Image::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Image@Gdiplus@@8				; Gdiplus::Image::`RTTI Base Class Array'
PUBLIC	??_7Image@Gdiplus@@6B@				; Gdiplus::Image::`vftable'
PUBLIC	??_GImage@Gdiplus@@UAEPAXI@Z			; Gdiplus::Image::`scalar deleting destructor'
EXTRN	_GdipLoadImageFromFile@8:NEAR
EXTRN	_GdipLoadImageFromFileICM@8:NEAR
EXTRN	??_EImage@Gdiplus@@UAEPAXI@Z:NEAR		; Gdiplus::Image::`vector deleting destructor'
;	COMDAT ??_7Image@Gdiplus@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdiplusbitmap.h
CONST	SEGMENT
??_7Image@Gdiplus@@6B@ DD FLAT:??_R4Image@Gdiplus@@6B@	; Gdiplus::Image::`vftable'
	DD	FLAT:??_EImage@Gdiplus@@UAEPAXI@Z
	DD	FLAT:?Clone@Image@Gdiplus@@UAEPAV12@XZ
CONST	ENDS
;	COMDAT ??_R4Image@Gdiplus@@6B@
rdata$r	SEGMENT
??_R4Image@Gdiplus@@6B@ DD 00H				; Gdiplus::Image::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVImage@Gdiplus@@@8
	DD	FLAT:??_R3Image@Gdiplus@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVImage@Gdiplus@@@8
_DATA	SEGMENT
??_R0?AVImage@Gdiplus@@@8 DD FLAT:??_7type_info@@6B@	; Gdiplus::Image `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVImage@Gdiplus@@', 00H
_DATA	ENDS
;	COMDAT ??_R3Image@Gdiplus@@8
rdata$r	SEGMENT
??_R3Image@Gdiplus@@8 DD 00H				; Gdiplus::Image::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Image@Gdiplus@@8
rdata$r	ENDS
;	COMDAT ??_R2Image@Gdiplus@@8
rdata$r	SEGMENT
??_R2Image@Gdiplus@@8 DD FLAT:??_R1A@?0A@A@Image@Gdiplus@@8 ; Gdiplus::Image::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@A@GdiplusBase@Gdiplus@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@Image@Gdiplus@@8
rdata$r	SEGMENT
??_R1A@?0A@A@Image@Gdiplus@@8 DD FLAT:??_R0?AVImage@Gdiplus@@@8 ; Gdiplus::Image::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R13?0A@A@GdiplusBase@Gdiplus@@8
rdata$r	SEGMENT
??_R13?0A@A@GdiplusBase@Gdiplus@@8 DD FLAT:??_R0?AVGdiplusBase@Gdiplus@@@8 ; Gdiplus::GdiplusBase::`RTTI Base Class Descriptor at (4,-1,0,0)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVGdiplusBase@Gdiplus@@@8
_DATA	SEGMENT
??_R0?AVGdiplusBase@Gdiplus@@@8 DD FLAT:??_7type_info@@6B@ ; Gdiplus::GdiplusBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVGdiplusBase@Gdiplus@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0Image@Gdiplus@@QAE@PB_WH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
_useEmbeddedColorManagement$ = 12			; size = 4
??0Image@Gdiplus@@QAE@PB_WH@Z PROC NEAR			; Gdiplus::Image::Image, COMDAT
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7Image@Gdiplus@@6B@

; 24   :     nativeImage = NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 25   :     if(useEmbeddedColorManagement)

  0001a	83 7d 0c 00	 cmp	 DWORD PTR _useEmbeddedColorManagement$[ebp], 0
  0001e	74 18		 je	 SHORT $L126808

; 26   :     {
; 27   :         lastResult = DllExports::GdipLoadImageFromFileICM(
; 28   :             filename, 
; 29   :             &nativeImage
; 30   :         );

  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	83 c2 04	 add	 edx, 4
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _GdipLoadImageFromFileICM@8
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 31   :     }
; 32   :     else

  00036	eb 16		 jmp	 SHORT $L126807
$L126808:

; 33   :     {      
; 34   :         lastResult = DllExports::GdipLoadImageFromFile(
; 35   :             filename, 
; 36   :             &nativeImage
; 37   :         );

  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	83 c2 04	 add	 edx, 4
  0003e	52		 push	 edx
  0003f	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _GdipLoadImageFromFile@8
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L126807:

; 38   :     }
; 39   : }

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
??0Image@Gdiplus@@QAE@PB_WH@Z ENDP			; Gdiplus::Image::Image
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GImage@Gdiplus@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GImage@Gdiplus@@UAEPAXI@Z PROC NEAR			; Gdiplus::Image::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Image@Gdiplus@@UAE@XZ ; Gdiplus::Image::~Image
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L119539
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3GdiplusBase@Gdiplus@@SAXPAX@Z ; Gdiplus::GdiplusBase::operator delete
  00020	83 c4 04	 add	 esp, 4
$L119539:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GImage@Gdiplus@@UAEPAXI@Z ENDP			; Gdiplus::Image::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	_GdipDisposeImage@4:NEAR
; Function compile flags: /Odt
;	COMDAT ??1Image@Gdiplus@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Image@Gdiplus@@UAE@XZ PROC NEAR			; Gdiplus::Image::~Image, COMDAT
; _this$ = ecx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7Image@Gdiplus@@6B@

; 91   :     DllExports::GdipDisposeImage(nativeImage);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 _GdipDisposeImage@4

; 92   : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??1Image@Gdiplus@@UAE@XZ ENDP				; Gdiplus::Image::~Image
_TEXT	ENDS
PUBLIC	??0Image@Gdiplus@@IAE@PAVGpImage@1@W4Status@1@@Z ; Gdiplus::Image::Image
PUBLIC	?SetStatus@Image@Gdiplus@@IBE?AW4Status@2@W432@@Z ; Gdiplus::Image::SetStatus
EXTRN	_GdipCloneImage@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203970 DD	0ffffffffH
	DD	FLAT:$L203966
$T203968 DD	019930520H
	DD	01H
	DD	FLAT:$T203970
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?Clone@Image@Gdiplus@@UAEPAV12@XZ
_TEXT	SEGMENT
tv80 = -32						; size = 4
_this$ = -28						; size = 4
$T203963 = -24						; size = 4
$T203962 = -20						; size = 4
_cloneimage$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Clone@Image@Gdiplus@@UAEPAV12@XZ PROC NEAR		; Gdiplus::Image::Clone, COMDAT
; _this$ = ecx

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Clone@Image@Gdiplus@@UAEPAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 14	 sub	 esp, 20			; 00000014H
  0001b	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 97   :     GpImage *cloneimage = NULL;

  0001e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cloneimage$[ebp], 0

; 98   : 
; 99   :     SetStatus(DllExports::GdipCloneImage(nativeImage, &cloneimage));

  00025	8d 45 f0	 lea	 eax, DWORD PTR _cloneimage$[ebp]
  00028	50		 push	 eax
  00029	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _GdipCloneImage@8
  00035	50		 push	 eax
  00036	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?SetStatus@Image@Gdiplus@@IBE?AW4Status@2@W432@@Z ; Gdiplus::Image::SetStatus

; 100  : 
; 101  :     return new Image(cloneimage, lastResult);

  0003e	6a 10		 push	 16			; 00000010H
  00040	e8 00 00 00 00	 call	 ??2GdiplusBase@Gdiplus@@SAPAXI@Z ; Gdiplus::GdiplusBase::operator new
  00045	83 c4 04	 add	 esp, 4
  00048	89 45 e8	 mov	 DWORD PTR $T203963[ebp], eax
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00052	83 7d e8 00	 cmp	 DWORD PTR $T203963[ebp], 0
  00056	74 18		 je	 SHORT $L203964
  00058	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	51		 push	 ecx
  0005f	8b 55 f0	 mov	 edx, DWORD PTR _cloneimage$[ebp]
  00062	52		 push	 edx
  00063	8b 4d e8	 mov	 ecx, DWORD PTR $T203963[ebp]
  00066	e8 00 00 00 00	 call	 ??0Image@Gdiplus@@IAE@PAVGpImage@1@W4Status@1@@Z ; Gdiplus::Image::Image
  0006b	89 45 e0	 mov	 DWORD PTR tv80[ebp], eax
  0006e	eb 07		 jmp	 SHORT $L203965
$L203964:
  00070	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$L203965:
  00077	8b 45 e0	 mov	 eax, DWORD PTR tv80[ebp]
  0007a	89 45 ec	 mov	 DWORD PTR $T203962[ebp], eax
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00084	8b 45 ec	 mov	 eax, DWORD PTR $T203962[ebp]

; 102  : }

  00087	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203966:
  00000	8b 45 e8	 mov	 eax, DWORD PTR $T203963[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3GdiplusBase@Gdiplus@@SAXPAX@Z ; Gdiplus::GdiplusBase::operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?Clone@Image@Gdiplus@@UAEPAV12@XZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203968
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Clone@Image@Gdiplus@@UAEPAV12@XZ ENDP			; Gdiplus::Image::Clone
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdiplusheaders.h
;	COMDAT ?SetStatus@Image@Gdiplus@@IBE?AW4Status@2@W432@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_status$ = 8						; size = 4
?SetStatus@Image@Gdiplus@@IBE?AW4Status@2@W432@@Z PROC NEAR ; Gdiplus::Image::SetStatus, COMDAT
; _this$ = ecx

; 472  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  :         if (status != Ok)

  00007	83 7d 08 00	 cmp	 DWORD PTR _status$[ebp], 0
  0000b	74 0e		 je	 SHORT $L119534

; 474  :             return (lastResult = status);

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _status$[ebp]
  00013	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00016	8b 45 08	 mov	 eax, DWORD PTR _status$[ebp]
  00019	eb 03		 jmp	 SHORT $L119533
$L119534:

; 475  :         else
; 476  :             return status;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _status$[ebp]
$L119533:

; 477  :     }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?SetStatus@Image@Gdiplus@@IBE?AW4Status@2@W432@@Z ENDP	; Gdiplus::Image::SetStatus
_TEXT	ENDS
PUBLIC	?SetNativeImage@Image@Gdiplus@@IAEXPAVGpImage@2@@Z ; Gdiplus::Image::SetNativeImage
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\platformsdk\include\gdiplusbitmap.h
;	COMDAT ??0Image@Gdiplus@@IAE@PAVGpImage@1@W4Status@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nativeImage$ = 8					; size = 4
_status$ = 12						; size = 4
??0Image@Gdiplus@@IAE@PAVGpImage@1@W4Status@1@@Z PROC NEAR ; Gdiplus::Image::Image, COMDAT
; _this$ = ecx

; 497  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7Image@Gdiplus@@6B@

; 498  :     SetNativeImage(nativeImage);

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _nativeImage$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?SetNativeImage@Image@Gdiplus@@IAEXPAVGpImage@2@@Z ; Gdiplus::Image::SetNativeImage

; 499  :     lastResult = status;

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 45 0c	 mov	 eax, DWORD PTR _status$[ebp]
  00022	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 500  : }

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??0Image@Gdiplus@@IAE@PAVGpImage@1@W4Status@1@@Z ENDP	; Gdiplus::Image::Image
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNativeImage@Image@Gdiplus@@IAEXPAVGpImage@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nativeImage$ = 8					; size = 4
?SetNativeImage@Image@Gdiplus@@IAEXPAVGpImage@2@@Z PROC NEAR ; Gdiplus::Image::SetNativeImage, COMDAT
; _this$ = ecx

; 504  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 505  :     this->nativeImage = nativeImage;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _nativeImage$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 506  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetNativeImage@Image@Gdiplus@@IAEXPAVGpImage@2@@Z ENDP	; Gdiplus::Image::SetNativeImage
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203986 DD	0ffffffffH
	DD	FLAT:$L203981
$T203984 DD	019930520H
	DD	01H
	DD	FLAT:$T203986
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0003f	52		 push	 edx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203981:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203984
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
CRT$XCU	SEGMENT
_$S6	DD	FLAT:_$E5
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\appconfig\config\configappdef.h
CRT$XCU	ENDS
;	COMDAT _$E5
text$yc	SEGMENT
_$E5	PROC NEAR					; COMDAT

; 19   : 	CONF_APP_SWF_PATH,			TYPE_CONFIG_STR,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_APP_SWF_PATH
  00008	a3 00 00 00 00	 mov	 DWORD PTR _CONF_APP, eax
  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_STR
  00013	89 0d 04 00 00
	00		 mov	 DWORD PTR _CONF_APP+4, ecx

; 20   : 	CONF_APP_MAINWND_HOLD,		TYPE_CONFIG_BOOL,

  00019	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_APP_MAINWND_HOLD
  0001f	89 15 08 00 00
	00		 mov	 DWORD PTR _CONF_APP+8, edx
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_BOOL
  0002a	a3 0c 00 00 00	 mov	 DWORD PTR _CONF_APP+12, eax

; 21   : 	CONF_APP_RUN_COUNT,			TYPE_CONFIG_INT,

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_APP_RUN_COUNT
  00035	89 0d 10 00 00
	00		 mov	 DWORD PTR _CONF_APP+16, ecx
  0003b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_INT
  00041	89 15 14 00 00
	00		 mov	 DWORD PTR _CONF_APP+20, edx

; 22   : 	CONF_APP_PLAYED_GAME,		TYPE_CONFIG_INT,

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_APP_PLAYED_GAME
  0004c	a3 18 00 00 00	 mov	 DWORD PTR _CONF_APP+24, eax
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_INT
  00057	89 0d 1c 00 00
	00		 mov	 DWORD PTR _CONF_APP+28, ecx

; 23   : 	CONF_APP_PLAYED_PC_GAME,	TYPE_CONFIG_INT,

  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_APP_PLAYED_PC_GAME
  00063	89 15 20 00 00
	00		 mov	 DWORD PTR _CONF_APP+32, edx
  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_INT
  0006e	a3 24 00 00 00	 mov	 DWORD PTR _CONF_APP+36, eax

; 24   : 	CONF_APP_PLAYED_ICON_SIZE,	TYPE_CONFIG_INT, //panelicon0,1,2

  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_APP_PLAYED_ICON_SIZE
  00079	89 0d 28 00 00
	00		 mov	 DWORD PTR _CONF_APP+40, ecx
  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_INT
  00085	89 15 2c 00 00
	00		 mov	 DWORD PTR _CONF_APP+44, edx

; 25   : 	CONF_APP_PIC_SAVE_PATH,		TYPE_CONFIG_STR

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_APP_PIC_SAVE_PATH
  00090	a3 30 00 00 00	 mov	 DWORD PTR _CONF_APP+48, eax

; 26   : };

  00095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_STR
  0009b	89 0d 34 00 00
	00		 mov	 DWORD PTR _CONF_APP+52, ecx
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
_$E5	ENDP
text$yc	ENDS
_BSS	SEGMENT
_CONF_APP DD	0eH DUP (?)
_BSS	ENDS
END
