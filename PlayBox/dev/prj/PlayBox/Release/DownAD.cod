; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\module\DownAD\DownAD.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ?IConfUpdate_Update@IConfUpdateObserver@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IConfUpdate_ConfigFile@IConfUpdateObserver@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IConfUpdate_CodecSucc@IConfUpdateObserver@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1IData@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppStart@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppExit@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIData@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1IAdData@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIAdData@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCDownAD@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IMessageObserver@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IConfUpdateObserver@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1IConfUpdateObserver@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IAdData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_DCDownAD@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIConfUpdateObserver@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_DIConfUpdateObserver@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AD_STRUCT@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AD_STRUCT@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4AD_STRUCT@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAUAD_STRUCT@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXABUAD_STRUCT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@V312@ABUAD_STRUCT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU3@IABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE@V?$allocator@UAD_STRUCT@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UAD_STRUCT@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEAAUAD_STRUCT@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXPAUAD_STRUCT@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXViterator@12@IABUAD_STRUCT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UAD_STRUCT@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UAD_STRUCT@@@std@@QAEPAUAD_STRUCT@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEABUAD_STRUCT@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AD_STRUCT@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UAD_STRUCT@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAUAD_STRUCT@@@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU2@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAUAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@0ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@UAD_STRUCT@@@std@@YAPAUAD_STRUCT@@IPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUAD_STRUCT@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAD_STRUCT@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@ABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UAD_STRUCT@@@std@@YAXPAUAD_STRUCT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAD_STRUCT@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_ECDownAD@@W7AEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_ECDownAD@@WCI@AEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IConfUpdateObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CDownAD@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IAdData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IConfUpdateObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CDownAD@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IAdData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R17?0A@A@IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R17?0A@A@IAdData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@33BA@IMessageObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IConfUpdateObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDownAD@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IAdData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVIConfUpdateObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCDownAD@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVIData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVIAdData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4IData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IConfUpdateObserver@@6BIMessageObserver@@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IConfUpdateObserver@@6B0@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CDownAD@@6BIMessageObserver@@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CDownAD@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CDownAD@@6BIConfUpdateObserver@@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IAdData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVIAdObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7IConfUpdateObserver@@6BIMessageObserver@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IConfUpdateObserver@@6B0@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_8IConfUpdateObserver@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IMessageObserver@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4IMessageObserver@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IMessageObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IMessageObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IMessageObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GIMessageObserver@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CDownAD@@6BIMessageObserver@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CDownAD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CDownAD@@6BIConfUpdateObserver@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1IMessageObserver@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_8CDownAD@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IAdData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_pDownAD@CDownAD@@2PAV1@A			; CDownAD::m_pDownAD
_BSS	SEGMENT
?m_pDownAD@CDownAD@@2PAV1@A DD 01H DUP (?)		; CDownAD::m_pDownAD
_BSS	ENDS
CONST	SEGMENT
$SG198041 DB	0d0H, 0e8H, 0d2H, 0aaH, 0bdH, 0f8H, 0d0H, 0d0H, 'ZipRes', 0b8H
	DB	0fcH, 0d0H, 0c2H, 00H
	ORG $+1
$SG198042 DB	'CAdData', 00H
$SG198043 DB	'qq.txt', 00H
$SG198048 DB	00H
$SG198054 DB	0cfH, 0c2H, 0d4H, 0d8H, 0cdH, 0eaH, 0b3H, 0c9H, 00H
	ORG $+3
$SG198055 DB	'Ad--HTTP', 00H
	ORG $+3
$SG198056 DB	'log_httpr.txt', 00H
	ORG $+2
$SG198062 DB	0bbH, 0f1H, 0c8H, 0a1H, 'ZipRes Sign == ', 0caH, 0a7H, 0b0H
	DB	0dcH, 00H
$SG198063 DB	'CAdData', 00H
$SG198064 DB	'log_httpr.txt', 00H
	ORG $+2
$SG198067 DB	0b8H, 0fcH, 0d0H, 0c2H, 0b9H, 0e3H, 0b8H, 0e6H, '--', 0bdH
	DB	0e1H, 0caH, 0f8H, 00H
	ORG $+1
$SG198068 DB	'CAdData', 00H
$SG198069 DB	'log_httpr.txt', 00H
	ORG $+2
$SG198075 DB	'DataAppStart', 00H
	ORG $+3
$SG198076 DB	'CDownAD', 00H
$SG198077 DB	'main.txt', 00H
	ORG $+3
$SG198080 DB	'DataAppStart--OUT', 00H
	ORG $+2
$SG198081 DB	'CDownAD', 00H
$SG198082 DB	'main.txt', 00H
	ORG $+3
$SG198088 DB	'DataAppExit', 00H
$SG198089 DB	'CDownAD', 00H
$SG198090 DB	'main.txt', 00H
	ORG $+3
$SG198098 DB	'DataAppExit-- out', 00H
	ORG $+2
$SG198099 DB	'CDownAD', 00H
$SG198100 DB	'main.txt', 00H
	ORG $+3
$SG198629 DB	'GetAd Path Failed', 00H
	ORG $+2
$SG198630 DB	'DownZipFinish', 00H
	ORG $+2
$SG198631 DB	'ad.txt', 00H
$SG198831 DB	00H
$SG198834 DB	'res ', 0bdH, 0e2H, 0d1H, 0b9H, 0cbH, 0f5H, 0caH, 0a7H, 0b0H
	DB	0dcH, '!!!!!!', 00H
	ORG $+3
$SG198835 DB	'DownZipFinish', 00H
	ORG $+2
$SG198836 DB	'qq.txt', 00H
	ORG $+1
$SG198844 DB	'AdLoadingPane.ini', 00H
	ORG $+2
$SG198847 DB	'AdLoadingPane', 00H
	ORG $+2
$SG198849 DB	'AdLoadingPaneNum', 00H
	ORG $+3
$SG198859 DB	'LoadingPaneLink%d', 00H
	ORG $+2
$SG198863 DB	'LoadingPanePic%d', 00H
	ORG $+3
_ID_MESSAGE_AD DD 0fH
CONST	ENDS
PUBLIC	?clear@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::clear
PUBLIC	?ReloadAd@CDownAD@@AAEXXZ			; CDownAD::ReloadAd
PUBLIC	??_7CDownAD@@6BIConfUpdateObserver@@@		; CDownAD::`vftable'
PUBLIC	??_7CDownAD@@6B@				; CDownAD::`vftable'
PUBLIC	??_R0?AVIAdData@@@8				; IAdData `RTTI Type Descriptor'
PUBLIC	??_7CDownAD@@6BIMessageObserver@@@		; CDownAD::`vftable'
PUBLIC	??_8CDownAD@@7B@				; CDownAD::`vbtable'
PUBLIC	??_R0?AVIData@@@8				; IData `RTTI Type Descriptor'
PUBLIC	??_R4CDownAD@@6BIConfUpdateObserver@@@		; CDownAD::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDownAD@@@8				; CDownAD `RTTI Type Descriptor'
PUBLIC	??_R3CDownAD@@8					; CDownAD::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDownAD@@8					; CDownAD::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CDownAD@@8				; CDownAD::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@IConfUpdateObserver@@8		; IConfUpdateObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVIConfUpdateObserver@@@8			; IConfUpdateObserver `RTTI Type Descriptor'
PUBLIC	??_R1A@33BA@IMessageObserver@@8			; IMessageObserver::`RTTI Base Class Descriptor at (0,4,4,16)'
PUBLIC	??_R17?0A@A@IAdData@@8				; IAdData::`RTTI Base Class Descriptor at (8,-1,0,0)'
PUBLIC	??_R17?0A@A@IData@@8				; IData::`RTTI Base Class Descriptor at (8,-1,0,0)'
PUBLIC	??_ECDownAD@@W7AEPAXI@Z				; [thunk]:CDownAD::`vector deleting destructor'
PUBLIC	??_R4CDownAD@@6B@				; CDownAD::`RTTI Complete Object Locator'
PUBLIC	??_ECDownAD@@WCI@AEPAXI@Z			; [thunk]:CDownAD::`vector deleting destructor'
PUBLIC	??_R4CDownAD@@6BIMessageObserver@@@		; CDownAD::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVIMessageObserver@@@8			; IMessageObserver `RTTI Type Descriptor'
PUBLIC	?IConfUpdate_Update@IConfUpdateObserver@@UAEXXZ	; IConfUpdateObserver::IConfUpdate_Update
PUBLIC	?IConfUpdate_ConfigFile@IConfUpdateObserver@@UAEXXZ ; IConfUpdateObserver::IConfUpdate_ConfigFile
PUBLIC	?IConfUpdate_CodecSucc@IConfUpdateObserver@@UAEXXZ ; IConfUpdateObserver::IConfUpdate_CodecSucc
PUBLIC	??0IConfUpdateObserver@@QAE@XZ			; IConfUpdateObserver::IConfUpdateObserver
PUBLIC	??1IConfUpdateObserver@@UAE@XZ			; IConfUpdateObserver::~IConfUpdateObserver
PUBLIC	??1IAdData@@MAE@XZ				; IAdData::~IAdData
PUBLIC	??0IAdData@@QAE@XZ				; IAdData::IAdData
PUBLIC	??0CDownAD@@QAE@XZ				; CDownAD::CDownAD
PUBLIC	?DataAppStart@CDownAD@@UAEXXZ			; CDownAD::DataAppStart
PUBLIC	?DataAppExit@CDownAD@@UAEXXZ			; CDownAD::DataAppExit
PUBLIC	?GetLoadingPicAd@CDownAD@@UAE_NAAUAD_STRUCT@@@Z	; CDownAD::GetLoadingPicAd
PUBLIC	??1IMessageObserver@@UAE@XZ			; IMessageObserver::~IMessageObserver
PUBLIC	??0IMessageObserver@@QAE@XZ			; IMessageObserver::IMessageObserver
PUBLIC	??0?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::vector<AD_STRUCT,std::allocator<AD_STRUCT> >
PUBLIC	??1?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::~vector<AD_STRUCT,std::allocator<AD_STRUCT> >
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
xdata$x	SEGMENT
$T200299 DD	0ffffffffH
	DD	FLAT:$L200288
	DD	00H
	DD	FLAT:$L200290
	DD	01H
	DD	FLAT:$L200291
	DD	02H
	DD	FLAT:$L200292
$T200296 DD	019930520H
	DD	04H
	DD	FLAT:$T200299
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_8CDownAD@@7B@
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\downad\downad.cpp
CONST	SEGMENT
??_8CDownAD@@7B@ DD 0fffffffcH				; CDownAD::`vbtable'
	DD	024H
CONST	ENDS
;	COMDAT ??_7CDownAD@@6BIConfUpdateObserver@@@
CONST	SEGMENT
??_7CDownAD@@6BIConfUpdateObserver@@@ DD FLAT:??_R4CDownAD@@6BIConfUpdateObserver@@@ ; CDownAD::`vftable'
	DD	FLAT:?IConfUpdate_Update@IConfUpdateObserver@@UAEXXZ
	DD	FLAT:?IConfUpdate_ConfigFile@IConfUpdateObserver@@UAEXXZ
	DD	FLAT:?IConfUpdate_CodecSucc@IConfUpdateObserver@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7CDownAD@@6B@
CONST	SEGMENT
??_7CDownAD@@6B@ DD FLAT:??_R4CDownAD@@6B@		; CDownAD::`vftable'
	DD	FLAT:??_ECDownAD@@W7AEPAXI@Z
	DD	FLAT:?DataAppStart@CDownAD@@UAEXXZ
	DD	FLAT:?DataAppExit@CDownAD@@UAEXXZ
	DD	FLAT:?GetLoadingPicAd@CDownAD@@UAE_NAAUAD_STRUCT@@@Z
CONST	ENDS
;	COMDAT ??_7CDownAD@@6BIMessageObserver@@@
CONST	SEGMENT
??_7CDownAD@@6BIMessageObserver@@@ DD FLAT:??_R4CDownAD@@6BIMessageObserver@@@ ; CDownAD::`vftable'
	DD	FLAT:??_ECDownAD@@WCI@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CDownAD@@6BIConfUpdateObserver@@@
rdata$r	SEGMENT
??_R4CDownAD@@6BIConfUpdateObserver@@@ DD 00H		; CDownAD::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDownAD@@@8
	DD	FLAT:??_R3CDownAD@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDownAD@@@8
_DATA	SEGMENT
??_R0?AVCDownAD@@@8 DD FLAT:??_7type_info@@6B@		; CDownAD `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDownAD@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CDownAD@@8
rdata$r	SEGMENT
??_R3CDownAD@@8 DD 00H					; CDownAD::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	05H
	DD	FLAT:??_R2CDownAD@@8
rdata$r	ENDS
;	COMDAT ??_R2CDownAD@@8
rdata$r	SEGMENT
??_R2CDownAD@@8 DD FLAT:??_R1A@?0A@A@CDownAD@@8		; CDownAD::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@IConfUpdateObserver@@8
	DD	FLAT:??_R1A@33BA@IMessageObserver@@8
	DD	FLAT:??_R17?0A@A@IAdData@@8
	DD	FLAT:??_R17?0A@A@IData@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDownAD@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CDownAD@@8 DD FLAT:??_R0?AVCDownAD@@@8	; CDownAD::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IConfUpdateObserver@@8
rdata$r	SEGMENT
??_R1A@?0A@A@IConfUpdateObserver@@8 DD FLAT:??_R0?AVIConfUpdateObserver@@@8 ; IConfUpdateObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVIConfUpdateObserver@@@8
_DATA	SEGMENT
??_R0?AVIConfUpdateObserver@@@8 DD FLAT:??_7type_info@@6B@ ; IConfUpdateObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIConfUpdateObserver@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@33BA@IMessageObserver@@8
rdata$r	SEGMENT
??_R1A@33BA@IMessageObserver@@8 DD FLAT:??_R0?AVIMessageObserver@@@8 ; IMessageObserver::`RTTI Base Class Descriptor at (0,4,4,16)'
	DD	00H
	DD	00H
	DD	04H
	DD	04H
	DD	010H
rdata$r	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT
??_R0?AVIMessageObserver@@@8 DD FLAT:??_7type_info@@6B@	; IMessageObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIMessageObserver@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVIMessageObserver@@', 00H
_DATA	ENDS
;	COMDAT ??_R17?0A@A@IAdData@@8
rdata$r	SEGMENT
??_R17?0A@A@IAdData@@8 DD FLAT:??_R0?AVIAdData@@@8	; IAdData::`RTTI Base Class Descriptor at (8,-1,0,0)'
	DD	01H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVIAdData@@@8
_DATA	SEGMENT
??_R0?AVIAdData@@@8 DD FLAT:??_7type_info@@6B@		; IAdData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIAdData@@', 00H
_DATA	ENDS
;	COMDAT ??_R17?0A@A@IData@@8
rdata$r	SEGMENT
??_R17?0A@A@IData@@8 DD FLAT:??_R0?AVIData@@@8		; IData::`RTTI Base Class Descriptor at (8,-1,0,0)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVIData@@@8
_DATA	SEGMENT
??_R0?AVIData@@@8 DD FLAT:??_7type_info@@6B@		; IData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIData@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CDownAD@@6B@
rdata$r	SEGMENT
??_R4CDownAD@@6B@ DD 00H				; CDownAD::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AVCDownAD@@@8
	DD	FLAT:??_R3CDownAD@@8
rdata$r	ENDS
;	COMDAT ??_R4CDownAD@@6BIMessageObserver@@@
rdata$r	SEGMENT
??_R4CDownAD@@6BIMessageObserver@@@ DD 00H		; CDownAD::`RTTI Complete Object Locator'
	DD	028H
	DD	00H
	DD	FLAT:??_R0?AVCDownAD@@@8
	DD	FLAT:??_R3CDownAD@@8
; Function compile flags: /Odt
rdata$r	ENDS
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T200287 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_$initVBases$ = 8					; size = 4
??0CDownAD@@QAE@XZ PROC NEAR				; CDownAD::CDownAD
; _this$ = ecx

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CDownAD@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T200287[ebp], 0
  00025	83 7d 08 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00029	74 25		 je	 SHORT $L197999
  0002b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET FLAT:??_8CDownAD@@7B@
  00035	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 28	 add	 ecx, 40			; 00000028H
  0003b	e8 00 00 00 00	 call	 ??0IMessageObserver@@QAE@XZ
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	8b 4d f0	 mov	 ecx, DWORD PTR $T200287[ebp]
  0004a	83 c9 01	 or	 ecx, 1
  0004d	89 4d f0	 mov	 DWORD PTR $T200287[ebp], ecx
$L197999:
  00050	6a 00		 push	 0
  00052	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??0IConfUpdateObserver@@QAE@XZ
  0005a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	83 c1 08	 add	 ecx, 8
  00067	e8 00 00 00 00	 call	 ??0IAdData@@QAE@XZ
  0006c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00070	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00073	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET FLAT:??_7CDownAD@@6BIConfUpdateObserver@@@
  00079	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET FLAT:??_7CDownAD@@6B@
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00089	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0008c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	c7 44 01 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+4], OFFSET FLAT:??_7CDownAD@@6BIMessageObserver@@@
  00097	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	83 c1 14	 add	 ecx, 20			; 00000014H
  0009d	e8 00 00 00 00	 call	 ??0?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::vector<AD_STRUCT,std::allocator<AD_STRUCT> >
  000a2	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 14   : 	m_iCurAd = 0;

  000a6	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000a9	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0

; 15   : 	m_vecAD.clear();

  000b0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	83 c1 14	 add	 ecx, 20			; 00000014H
  000b6	e8 00 00 00 00	 call	 ?clear@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::clear

; 16   : 	ReloadAd();

  000bb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?ReloadAd@CDownAD@@AAEXXZ ; CDownAD::ReloadAd

; 17   : }

  000c3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ca	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L200288:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T200287[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $L200289
  0000c	83 65 f0 fe	 and	 DWORD PTR $T200287[ebp], -2 ; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 28	 add	 ecx, 40			; 00000028H
  00016	e9 00 00 00 00	 jmp	 ??1IMessageObserver@@UAE@XZ ; IMessageObserver::~IMessageObserver
$L200289:
  0001b	c3		 ret	 0
$L200290:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 08	 add	 ecx, 8
  00022	e9 00 00 00 00	 jmp	 ??1IConfUpdateObserver@@UAE@XZ
$L200291:
  00027	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 c1 08	 add	 ecx, 8
  0002d	e9 00 00 00 00	 jmp	 ??1IAdData@@MAE@XZ	; IAdData::~IAdData
$L200292:
  00032	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	83 c1 14	 add	 ecx, 20			; 00000014H
  00038	e9 00 00 00 00	 jmp	 ??1?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::~vector<AD_STRUCT,std::allocator<AD_STRUCT> >
__ehhandler$??0CDownAD@@QAE@XZ:
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200296
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CDownAD@@QAE@XZ ENDP					; CDownAD::CDownAD
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\datainterface\iconfupdateobserver.h
;	COMDAT ?IConfUpdate_Update@IConfUpdateObserver@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IConfUpdate_Update@IConfUpdateObserver@@UAEXXZ PROC NEAR ; IConfUpdateObserver::IConfUpdate_Update, COMDAT
; _this$ = ecx

; 9    : 	virtual void	IConfUpdate_Update(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?IConfUpdate_Update@IConfUpdateObserver@@UAEXXZ ENDP	; IConfUpdateObserver::IConfUpdate_Update
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IConfUpdate_ConfigFile@IConfUpdateObserver@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IConfUpdate_ConfigFile@IConfUpdateObserver@@UAEXXZ PROC NEAR ; IConfUpdateObserver::IConfUpdate_ConfigFile, COMDAT
; _this$ = ecx

; 10   : 	virtual void	IConfUpdate_ConfigFile(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?IConfUpdate_ConfigFile@IConfUpdateObserver@@UAEXXZ ENDP ; IConfUpdateObserver::IConfUpdate_ConfigFile
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IConfUpdate_CodecSucc@IConfUpdateObserver@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IConfUpdate_CodecSucc@IConfUpdateObserver@@UAEXXZ PROC NEAR ; IConfUpdateObserver::IConfUpdate_CodecSucc, COMDAT
; _this$ = ecx

; 11   : 	virtual void	IConfUpdate_CodecSucc(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?IConfUpdate_CodecSucc@IConfUpdateObserver@@UAEXXZ ENDP	; IConfUpdateObserver::IConfUpdate_CodecSucc
_TEXT	ENDS
PUBLIC	??_R4IAdData@@6B@				; IAdData::`RTTI Complete Object Locator'
PUBLIC	??_R3IAdData@@8					; IAdData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IAdData@@8					; IAdData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@IAdData@@8				; IAdData::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@IData@@8				; IData::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??1IData@@MAE@XZ				; IData::~IData
PUBLIC	?DataAppStart@IData@@UAEXXZ			; IData::DataAppStart
PUBLIC	?DataAppExit@IData@@UAEXXZ			; IData::DataAppExit
PUBLIC	??_7IAdData@@6B@				; IAdData::`vftable'
PUBLIC	??_GIAdData@@MAEPAXI@Z				; IAdData::`scalar deleting destructor'
EXTRN	__purecall:NEAR
EXTRN	??_EIAdData@@MAEPAXI@Z:NEAR			; IAdData::`vector deleting destructor'
;	COMDAT ??_7IAdData@@6B@
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\datainterface\iaddata.h
CONST	SEGMENT
??_7IAdData@@6B@ DD FLAT:??_R4IAdData@@6B@		; IAdData::`vftable'
	DD	FLAT:??_EIAdData@@MAEPAXI@Z
	DD	FLAT:?DataAppStart@IData@@UAEXXZ
	DD	FLAT:?DataAppExit@IData@@UAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4IAdData@@6B@
rdata$r	SEGMENT
??_R4IAdData@@6B@ DD 00H				; IAdData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIAdData@@@8
	DD	FLAT:??_R3IAdData@@8
rdata$r	ENDS
;	COMDAT ??_R3IAdData@@8
rdata$r	SEGMENT
??_R3IAdData@@8 DD 00H					; IAdData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IAdData@@8
rdata$r	ENDS
;	COMDAT ??_R2IAdData@@8
rdata$r	SEGMENT
??_R2IAdData@@8 DD FLAT:??_R1A@?0A@A@IAdData@@8		; IAdData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@IData@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IAdData@@8
rdata$r	SEGMENT
??_R1A@?0A@A@IAdData@@8 DD FLAT:??_R0?AVIAdData@@@8	; IAdData::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IData@@8
rdata$r	SEGMENT
??_R1A@?0A@A@IData@@8 DD FLAT:??_R0?AVIData@@@8		; IData::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??1IAdData@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1IAdData@@MAE@XZ PROC NEAR				; IAdData::~IAdData, COMDAT
; _this$ = ecx

; 17   : 	virtual ~IAdData(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IAdData@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1IData@@MAE@XZ	; IData::~IData
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1IAdData@@MAE@XZ ENDP					; IAdData::~IAdData
_TEXT	ENDS
PUBLIC	??_R4IData@@6B@					; IData::`RTTI Complete Object Locator'
PUBLIC	??_R3IData@@8					; IData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IData@@8					; IData::`RTTI Base Class Array'
PUBLIC	??_7IData@@6B@					; IData::`vftable'
PUBLIC	??_GIData@@MAEPAXI@Z				; IData::`scalar deleting destructor'
EXTRN	??_EIData@@MAEPAXI@Z:NEAR			; IData::`vector deleting destructor'
;	COMDAT ??_7IData@@6B@
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\datainterface\idata.h
CONST	SEGMENT
??_7IData@@6B@ DD FLAT:??_R4IData@@6B@			; IData::`vftable'
	DD	FLAT:??_EIData@@MAEPAXI@Z
	DD	FLAT:?DataAppStart@IData@@UAEXXZ
	DD	FLAT:?DataAppExit@IData@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4IData@@6B@
rdata$r	SEGMENT
??_R4IData@@6B@ DD 00H					; IData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIData@@@8
	DD	FLAT:??_R3IData@@8
rdata$r	ENDS
;	COMDAT ??_R3IData@@8
rdata$r	SEGMENT
??_R3IData@@8 DD 00H					; IData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IData@@8
rdata$r	ENDS
;	COMDAT ??_R2IData@@8
rdata$r	SEGMENT
??_R2IData@@8 DD FLAT:??_R1A@?0A@A@IData@@8		; IData::`RTTI Base Class Array'
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??1IData@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1IData@@MAE@XZ PROC NEAR				; IData::~IData, COMDAT
; _this$ = ecx

; 10   : 	virtual ~IData(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IData@@6B@
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1IData@@MAE@XZ ENDP					; IData::~IData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?DataAppStart@IData@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DataAppStart@IData@@UAEXXZ PROC NEAR			; IData::DataAppStart, COMDAT
; _this$ = ecx

; 15   : 	virtual void	DataAppStart(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?DataAppStart@IData@@UAEXXZ ENDP			; IData::DataAppStart
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?DataAppExit@IData@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DataAppExit@IData@@UAEXXZ PROC NEAR			; IData::DataAppExit, COMDAT
; _this$ = ecx

; 18   : 	virtual void	DataAppExit(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?DataAppExit@IData@@UAEXXZ ENDP				; IData::DataAppExit
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt
;	COMDAT ??_GIData@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIData@@MAEPAXI@Z PROC NEAR				; IData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1IData@@MAE@XZ	; IData::~IData
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L197424
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L197424:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GIData@@MAEPAXI@Z ENDP				; IData::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GIAdData@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIAdData@@MAEPAXI@Z PROC NEAR			; IAdData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1IAdData@@MAE@XZ	; IAdData::~IAdData
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L197459
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L197459:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GIAdData@@MAEPAXI@Z ENDP				; IAdData::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4IMessageObserver@@6B@			; IMessageObserver::`RTTI Complete Object Locator'
PUBLIC	??_R3IMessageObserver@@8			; IMessageObserver::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IMessageObserver@@8			; IMessageObserver::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@IMessageObserver@@8		; IMessageObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_7IMessageObserver@@6B@			; IMessageObserver::`vftable'
PUBLIC	??_GIMessageObserver@@UAEPAXI@Z			; IMessageObserver::`scalar deleting destructor'
EXTRN	??_EIMessageObserver@@UAEPAXI@Z:NEAR		; IMessageObserver::`vector deleting destructor'
;	COMDAT ??_7IMessageObserver@@6B@
CONST	SEGMENT
??_7IMessageObserver@@6B@ DD FLAT:??_R4IMessageObserver@@6B@ ; IMessageObserver::`vftable'
	DD	FLAT:??_EIMessageObserver@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4IMessageObserver@@6B@
rdata$r	SEGMENT
??_R4IMessageObserver@@6B@ DD 00H			; IMessageObserver::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIMessageObserver@@@8
	DD	FLAT:??_R3IMessageObserver@@8
rdata$r	ENDS
;	COMDAT ??_R3IMessageObserver@@8
rdata$r	SEGMENT
??_R3IMessageObserver@@8 DD 00H				; IMessageObserver::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IMessageObserver@@8
rdata$r	ENDS
;	COMDAT ??_R2IMessageObserver@@8
rdata$r	SEGMENT
??_R2IMessageObserver@@8 DD FLAT:??_R1A@?0A@A@IMessageObserver@@8 ; IMessageObserver::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IMessageObserver@@8
rdata$r	SEGMENT
??_R1A@?0A@A@IMessageObserver@@8 DD FLAT:??_R0?AVIMessageObserver@@@8 ; IMessageObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0IMessageObserver@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IMessageObserver@@QAE@XZ PROC NEAR			; IMessageObserver::IMessageObserver, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IMessageObserver@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0IMessageObserver@@QAE@XZ ENDP			; IMessageObserver::IMessageObserver
_TEXT	ENDS
PUBLIC	??_R4IConfUpdateObserver@@6B0@@			; IConfUpdateObserver::`RTTI Complete Object Locator'
PUBLIC	??_R3IConfUpdateObserver@@8			; IConfUpdateObserver::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IConfUpdateObserver@@8			; IConfUpdateObserver::`RTTI Base Class Array'
PUBLIC	??_R4IConfUpdateObserver@@6BIMessageObserver@@@	; IConfUpdateObserver::`RTTI Complete Object Locator'
PUBLIC	??_7IConfUpdateObserver@@6B0@@			; IConfUpdateObserver::`vftable'
PUBLIC	??_7IConfUpdateObserver@@6BIMessageObserver@@@	; IConfUpdateObserver::`vftable'
PUBLIC	??_8IConfUpdateObserver@@7B@			; IConfUpdateObserver::`vbtable'
PUBLIC	??_GIConfUpdateObserver@@UAEPAXI@Z		; IConfUpdateObserver::`scalar deleting destructor'
EXTRN	??_EIConfUpdateObserver@@UAEPAXI@Z:NEAR		; IConfUpdateObserver::`vector deleting destructor'
;	COMDAT ??_8IConfUpdateObserver@@7B@
CONST	SEGMENT
??_8IConfUpdateObserver@@7B@ DD 0fffffffcH		; IConfUpdateObserver::`vbtable'
	DD	04H
CONST	ENDS
;	COMDAT ??_7IConfUpdateObserver@@6B0@@
CONST	SEGMENT
??_7IConfUpdateObserver@@6B0@@ DD FLAT:??_R4IConfUpdateObserver@@6B0@@ ; IConfUpdateObserver::`vftable'
	DD	FLAT:?IConfUpdate_Update@IConfUpdateObserver@@UAEXXZ
	DD	FLAT:?IConfUpdate_ConfigFile@IConfUpdateObserver@@UAEXXZ
	DD	FLAT:?IConfUpdate_CodecSucc@IConfUpdateObserver@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7IConfUpdateObserver@@6BIMessageObserver@@@
CONST	SEGMENT
??_7IConfUpdateObserver@@6BIMessageObserver@@@ DD FLAT:??_R4IConfUpdateObserver@@6BIMessageObserver@@@ ; IConfUpdateObserver::`vftable'
	DD	FLAT:??_EIConfUpdateObserver@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4IConfUpdateObserver@@6B0@@
rdata$r	SEGMENT
??_R4IConfUpdateObserver@@6B0@@ DD 00H			; IConfUpdateObserver::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIConfUpdateObserver@@@8
	DD	FLAT:??_R3IConfUpdateObserver@@8
rdata$r	ENDS
;	COMDAT ??_R3IConfUpdateObserver@@8
rdata$r	SEGMENT
??_R3IConfUpdateObserver@@8 DD 00H			; IConfUpdateObserver::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IConfUpdateObserver@@8
rdata$r	ENDS
;	COMDAT ??_R2IConfUpdateObserver@@8
rdata$r	SEGMENT
??_R2IConfUpdateObserver@@8 DD FLAT:??_R1A@?0A@A@IConfUpdateObserver@@8 ; IConfUpdateObserver::`RTTI Base Class Array'
	DD	FLAT:??_R1A@33BA@IMessageObserver@@8
rdata$r	ENDS
;	COMDAT ??_R4IConfUpdateObserver@@6BIMessageObserver@@@
rdata$r	SEGMENT
??_R4IConfUpdateObserver@@6BIMessageObserver@@@ DD 00H	; IConfUpdateObserver::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AVIConfUpdateObserver@@@8
	DD	FLAT:??_R3IConfUpdateObserver@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0IConfUpdateObserver@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T200323 = -4						; size = 4
_$initVBases$ = 8					; size = 4
??0IConfUpdateObserver@@QAE@XZ PROC NEAR		; IConfUpdateObserver::IConfUpdateObserver, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T200323[ebp], 0
  00010	83 7d 08 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00014	74 19		 je	 SHORT $L198009
  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET FLAT:??_8IConfUpdateObserver@@7B@
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	83 c1 08	 add	 ecx, 8
  00026	e8 00 00 00 00	 call	 ??0IMessageObserver@@QAE@XZ
  0002b	83 4d fc 01	 or	 DWORD PTR $T200323[ebp], 1
$L198009:
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7IConfUpdateObserver@@6B0@@
  00038	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 44 0a 04 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+4], OFFSET FLAT:??_7IConfUpdateObserver@@6BIMessageObserver@@@
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
??0IConfUpdateObserver@@QAE@XZ ENDP			; IConfUpdateObserver::IConfUpdateObserver
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1IConfUpdateObserver@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1IConfUpdateObserver@@UAE@XZ PROC NEAR		; IConfUpdateObserver::~IConfUpdateObserver, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1IConfUpdateObserver@@UAE@XZ ENDP			; IConfUpdateObserver::~IConfUpdateObserver
_TEXT	ENDS
PUBLIC	??0IData@@QAE@XZ				; IData::IData
; Function compile flags: /Odt
;	COMDAT ??0IAdData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IAdData@@QAE@XZ PROC NEAR				; IAdData::IAdData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IData@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IAdData@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0IAdData@@QAE@XZ ENDP					; IAdData::IAdData
_TEXT	ENDS
PUBLIC	??_DIConfUpdateObserver@@QAEXXZ			; IConfUpdateObserver::`vbase destructor'
; Function compile flags: /Odt
;	COMDAT ??_GIConfUpdateObserver@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIConfUpdateObserver@@UAEPAXI@Z PROC NEAR		; IConfUpdateObserver::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 e9 08	 sub	 ecx, 8
  0000d	e8 00 00 00 00	 call	 ??_DIConfUpdateObserver@@QAEXXZ
  00012	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	74 0f		 je	 SHORT $L198019
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 e9 08	 sub	 ecx, 8
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
$L198019:
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 e8 08	 sub	 eax, 8
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??_GIConfUpdateObserver@@UAEPAXI@Z ENDP			; IConfUpdateObserver::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IData@@QAE@XZ PROC NEAR				; IData::IData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IData@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0IData@@QAE@XZ ENDP					; IData::IData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_DIConfUpdateObserver@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??_DIConfUpdateObserver@@QAEXXZ PROC NEAR		; IConfUpdateObserver::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 08	 add	 ecx, 8
  0000d	e8 00 00 00 00	 call	 ??1IConfUpdateObserver@@UAE@XZ
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 08	 add	 ecx, 8
  00018	e8 00 00 00 00	 call	 ??1IMessageObserver@@UAE@XZ ; IMessageObserver::~IMessageObserver
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??_DIConfUpdateObserver@@QAEXXZ ENDP			; IConfUpdateObserver::`vbase destructor'
_TEXT	ENDS
PUBLIC	??1CDownAD@@UAE@XZ				; CDownAD::~CDownAD
xdata$x	SEGMENT
$T200346 DD	0ffffffffH
	DD	FLAT:$L200338
	DD	00H
	DD	FLAT:$L200341
$T200344 DD	019930520H
	DD	02H
	DD	FLAT:$T200346
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\downad\downad.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv73 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CDownAD@@UAE@XZ PROC NEAR				; CDownAD::~CDownAD
; _this$ = ecx

; 20   : {

  000e0	55		 push	 ebp
  000e1	8b ec		 mov	 ebp, esp
  000e3	6a ff		 push	 -1
  000e5	68 00 00 00 00	 push	 __ehhandler$??1CDownAD@@UAE@XZ
  000ea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  000f0	50		 push	 eax
  000f1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  000f8	83 ec 08	 sub	 esp, 8
  000fb	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  000fe	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00101	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDownAD@@6BIConfUpdateObserver@@@
  00107	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET FLAT:??_7CDownAD@@6B@
  00111	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00114	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00117	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0011a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0011d	c7 44 0a 04 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+4], OFFSET FLAT:??_7CDownAD@@6BIMessageObserver@@@
  00125	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 21   : }

  0012c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	83 c1 14	 add	 ecx, 20			; 00000014H
  00132	e8 00 00 00 00	 call	 ??1?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::~vector<AD_STRUCT,std::allocator<AD_STRUCT> >
  00137	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0013b	83 7d f0 00	 cmp	 DWORD PTR _this$[ebp], 0
  0013f	74 0b		 je	 SHORT $L200336
  00141	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00144	83 c0 08	 add	 eax, 8
  00147	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
  0014a	eb 07		 jmp	 SHORT $L200337
$L200336:
  0014c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$L200337:
  00153	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00156	e8 00 00 00 00	 call	 ??1IAdData@@MAE@XZ	; IAdData::~IAdData
  0015b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00162	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00165	83 c1 08	 add	 ecx, 8
  00168	e8 00 00 00 00	 call	 ??1IConfUpdateObserver@@UAE@XZ
  0016d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00170	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200338:
  00047	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	83 c1 08	 add	 ecx, 8
  0004d	e9 00 00 00 00	 jmp	 ??1IConfUpdateObserver@@UAE@XZ
$L200341:
  00052	83 7d f0 00	 cmp	 DWORD PTR _this$[ebp], 0
  00056	0f 84 0e 00 00
	00		 je	 $L200339
  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	83 c0 08	 add	 eax, 8
  00062	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
  00065	e9 07 00 00 00	 jmp	 $L200340
$L200339:
  0006a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$L200340:
  00071	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1IAdData@@MAE@XZ	; IAdData::~IAdData
__ehhandler$??1CDownAD@@UAE@XZ:
  00079	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200344
  0007e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CDownAD@@UAE@XZ ENDP					; CDownAD::~CDownAD
PUBLIC	?GetInstance@CDownAD@@SAPAV1@XZ			; CDownAD::GetInstance
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
xdata$x	SEGMENT
$T200356 DD	0ffffffffH
	DD	FLAT:$L200352
$T200354 DD	019930520H
	DD	01H
	DD	FLAT:$T200356
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv73 = -24						; size = 4
$T200349 = -20						; size = 4
$T200348 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?GetInstance@CDownAD@@SAPAV1@XZ PROC NEAR		; CDownAD::GetInstance

; 24   : {

  00180	55		 push	 ebp
  00181	8b ec		 mov	 ebp, esp
  00183	6a ff		 push	 -1
  00185	68 00 00 00 00	 push	 __ehhandler$?GetInstance@CDownAD@@SAPAV1@XZ
  0018a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00190	50		 push	 eax
  00191	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00198	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 25   : 	if( m_pDownAD == NULL )

  0019b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pDownAD@CDownAD@@2PAV1@A, 0 ; CDownAD::m_pDownAD
  001a2	75 50		 jne	 SHORT $L198030

; 26   : 	{
; 27   : 		m_pDownAD = new CDownAD();

  001a4	6a 2c		 push	 44			; 0000002cH
  001a6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001ab	83 c4 04	 add	 esp, 4
  001ae	89 45 ec	 mov	 DWORD PTR $T200349[ebp], eax
  001b1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  001b8	83 7d ec 00	 cmp	 DWORD PTR $T200349[ebp], 0
  001bc	74 0f		 je	 SHORT $L200350
  001be	6a 01		 push	 1
  001c0	8b 4d ec	 mov	 ecx, DWORD PTR $T200349[ebp]
  001c3	e8 00 00 00 00	 call	 ??0CDownAD@@QAE@XZ	; CDownAD::CDownAD
  001c8	89 45 e8	 mov	 DWORD PTR tv73[ebp], eax
  001cb	eb 07		 jmp	 SHORT $L200351
$L200350:
  001cd	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$L200351:
  001d4	8b 45 e8	 mov	 eax, DWORD PTR tv73[ebp]
  001d7	89 45 f0	 mov	 DWORD PTR $T200348[ebp], eax
  001da	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001e1	8b 4d f0	 mov	 ecx, DWORD PTR $T200348[ebp]
  001e4	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_pDownAD@CDownAD@@2PAV1@A, ecx ; CDownAD::m_pDownAD

; 28   : 		m_pDownAD->m_bGetAdData = false;

  001ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_pDownAD@CDownAD@@2PAV1@A ; CDownAD::m_pDownAD
  001f0	c6 42 10 00	 mov	 BYTE PTR [edx+16], 0
$L198030:

; 29   : 	}
; 30   : 	return m_pDownAD;

  001f4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pDownAD@CDownAD@@2PAV1@A ; CDownAD::m_pDownAD

; 31   : }

  001f9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001fc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00203	8b e5		 mov	 esp, ebp
  00205	5d		 pop	 ebp
  00206	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200352:
  00083	8b 45 ec	 mov	 eax, DWORD PTR $T200349[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008c	59		 pop	 ecx
  0008d	c3		 ret	 0
__ehhandler$?GetInstance@CDownAD@@SAPAV1@XZ:
  0008e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200354
  00093	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetInstance@CDownAD@@SAPAV1@XZ ENDP			; CDownAD::GetInstance
EXTRN	__imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ:NEAR
EXTRN	__imp__CreateThread@24:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
xdata$x	SEGMENT
$T200369 DD	0ffffffffH
	DD	FLAT:$L200362
	DD	00H
	DD	FLAT:$L200363
	DD	0ffffffffH
	DD	FLAT:$L200364
	DD	02H
	DD	FLAT:$L200365
$T200367 DD	019930520H
	DD	04H
	DD	FLAT:$T200369
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -128						; size = 4
$T200361 = -124						; size = 28
$T200360 = -96						; size = 28
$T200359 = -68						; size = 28
$T200358 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?DataAppStart@CDownAD@@UAEXXZ PROC NEAR			; CDownAD::DataAppStart
; _this$ = ecx

; 73   : {

  00210	55		 push	 ebp
  00211	8b ec		 mov	 ebp, esp
  00213	6a ff		 push	 -1
  00215	68 00 00 00 00	 push	 __ehhandler$?DataAppStart@CDownAD@@UAEXXZ
  0021a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00220	50		 push	 eax
  00221	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00228	83 ec 74	 sub	 esp, 116		; 00000074H
  0022b	89 4d 80	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 	YL_Log( STR_LOG_FILE,LOG_NOTICE,"CDownAD","DataAppStart");

  0022e	68 00 00 00 00	 push	 OFFSET FLAT:$SG198076
  00233	8d 4d d8	 lea	 ecx, DWORD PTR $T200358[ebp]
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0023c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00243	68 00 00 00 00	 push	 OFFSET FLAT:$SG198077
  00248	8d 4d bc	 lea	 ecx, DWORD PTR $T200359[ebp]
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00251	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00255	68 00 00 00 00	 push	 OFFSET FLAT:$SG198075
  0025a	8d 45 d8	 lea	 eax, DWORD PTR $T200358[ebp]
  0025d	50		 push	 eax
  0025e	6a 01		 push	 1
  00260	8d 4d bc	 lea	 ecx, DWORD PTR $T200359[ebp]
  00263	51		 push	 ecx
  00264	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  0026a	83 c4 10	 add	 esp, 16			; 00000010H
  0026d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00271	8d 4d bc	 lea	 ecx, DWORD PTR $T200359[ebp]
  00274	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0027a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00281	8d 4d d8	 lea	 ecx, DWORD PTR $T200358[ebp]
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 75   : 	// 
; 76   : 	m_hThreadDown = CreateThread(0,0,Thread_DownZip,0,0,0);

  0028a	6a 00		 push	 0
  0028c	6a 00		 push	 0
  0028e	6a 00		 push	 0
  00290	68 00 00 00 00	 push	 OFFSET FLAT:?Thread_DownZip@@YGKPAX@Z ; Thread_DownZip
  00295	6a 00		 push	 0
  00297	6a 00		 push	 0
  00299	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  0029f	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  002a2	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 77   : 	YL_Log( STR_LOG_FILE,LOG_NOTICE,"CDownAD","DataAppStart--OUT");

  002a5	68 00 00 00 00	 push	 OFFSET FLAT:$SG198081
  002aa	8d 4d a0	 lea	 ecx, DWORD PTR $T200360[ebp]
  002ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  002b3	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  002ba	68 00 00 00 00	 push	 OFFSET FLAT:$SG198082
  002bf	8d 4d 84	 lea	 ecx, DWORD PTR $T200361[ebp]
  002c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  002c8	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  002cc	68 00 00 00 00	 push	 OFFSET FLAT:$SG198080
  002d1	8d 45 a0	 lea	 eax, DWORD PTR $T200360[ebp]
  002d4	50		 push	 eax
  002d5	6a 01		 push	 1
  002d7	8d 4d 84	 lea	 ecx, DWORD PTR $T200361[ebp]
  002da	51		 push	 ecx
  002db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  002e1	83 c4 10	 add	 esp, 16			; 00000010H
  002e4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  002e8	8d 4d 84	 lea	 ecx, DWORD PTR $T200361[ebp]
  002eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  002f1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002f8	8d 4d a0	 lea	 ecx, DWORD PTR $T200360[ebp]
  002fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 78   : }

  00301	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00304	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0030b	8b e5		 mov	 esp, ebp
  0030d	5d		 pop	 ebp
  0030e	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200362:
  00098	8d 4d d8	 lea	 ecx, DWORD PTR $T200358[ebp]
  0009b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200363:
  000a1	8d 4d bc	 lea	 ecx, DWORD PTR $T200359[ebp]
  000a4	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200364:
  000aa	8d 4d a0	 lea	 ecx, DWORD PTR $T200360[ebp]
  000ad	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200365:
  000b3	8d 4d 84	 lea	 ecx, DWORD PTR $T200361[ebp]
  000b6	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?DataAppStart@CDownAD@@UAEXXZ:
  000bc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200367
  000c1	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DataAppStart@CDownAD@@UAEXXZ ENDP			; CDownAD::DataAppStart
PUBLIC	?DownZipFinish@CDownAD@@QAEXPAXI@Z		; CDownAD::DownZipFinish
PUBLIC	?ZipResReady@CDownAD@@QAEXH@Z			; CDownAD::ZipResReady
EXTRN	?GetAdDataServer@CLhcImg@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:NEAR ; CLhcImg::GetAdDataServer
EXTRN	?CheckUpdateADData@CLhcImg@@SA_NXZ:NEAR		; CLhcImg::CheckUpdateADData
EXTRN	?HTTPWait_AD@CHTTPControl@@SAXXZ:NEAR		; CHTTPControl::HTTPWait_AD
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
EXTRN	?HTTPFinish_DownAD@CHTTPControl@@SAXXZ:NEAR	; CHTTPControl::HTTPFinish_DownAD
EXTRN	__imp_??0YL_CHTTPRequest@@QAE@XZ:NEAR
EXTRN	__imp_??1YL_CHTTPRequest@@QAE@XZ:NEAR
EXTRN	__imp_?Request@YL_CHTTPRequest@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4REQUEST_TYPE@1@JPAEI@Z:NEAR
EXTRN	__imp_?GetContent@YL_CHTTPRequest@@QAEPAEAAJ@Z:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
xdata$x	SEGMENT
$T200399 DD	0ffffffffH
	DD	FLAT:$L200382
	DD	00H
	DD	FLAT:$L200383
	DD	0ffffffffH
	DD	FLAT:$L200384
	DD	02H
	DD	FLAT:$L200385
	DD	03H
	DD	FLAT:$L200386
	DD	03H
	DD	FLAT:$L200387
	DD	05H
	DD	FLAT:$L200388
	DD	03H
	DD	FLAT:$L200389
	DD	07H
	DD	FLAT:$L200390
	DD	0ffffffffH
	DD	FLAT:$L200391
	DD	09H
	DD	FLAT:$L200392
$T200394 DD	019930520H
	DD	0bH
	DD	FLAT:$T200399
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T200381 = -312						; size = 28
$T200380 = -284						; size = 28
$T200379 = -256						; size = 28
$T200378 = -228						; size = 28
$T200377 = -200						; size = 28
$T200376 = -172						; size = 28
$T200375 = -144						; size = 28
$T200374 = -113						; size = 1
$T200373 = -112						; size = 28
$T200372 = -84						; size = 28
_lConLen$198057 = -56					; size = 4
_pContent$198058 = -52					; size = 4
_strSvr$198046 = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
_http$198045 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_ppar$ = 8						; size = 4
?Thread_DownZip@@YGKPAX@Z PROC NEAR			; Thread_DownZip

; 34   : {

  00310	55		 push	 ebp
  00311	8b ec		 mov	 ebp, esp
  00313	6a ff		 push	 -1
  00315	68 00 00 00 00	 push	 __ehhandler$?Thread_DownZip@@YGKPAX@Z
  0031a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00320	50		 push	 eax
  00321	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00328	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0032e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00333	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 35   : 	if( CLhcImg::CheckUpdateADData() )

  00336	e8 00 00 00 00	 call	 ?CheckUpdateADData@CLhcImg@@SA_NXZ ; CLhcImg::CheckUpdateADData
  0033b	0f b6 c0	 movzx	 eax, al
  0033e	85 c0		 test	 eax, eax
  00340	0f 84 b0 02 00
	00		 je	 $L198038

; 36   : 	{
; 37   : 		YL_Log( "qq.txt",LOG_NOTICE,"CAdData","ZipRes");

  00346	68 00 00 00 00	 push	 OFFSET FLAT:$SG198042
  0034b	8d 4d ac	 lea	 ecx, DWORD PTR $T200372[ebp]
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00354	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0035b	68 00 00 00 00	 push	 OFFSET FLAT:$SG198043
  00360	8d 4d 90	 lea	 ecx, DWORD PTR $T200373[ebp]
  00363	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00369	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0036d	68 00 00 00 00	 push	 OFFSET FLAT:$SG198041
  00372	8d 4d ac	 lea	 ecx, DWORD PTR $T200372[ebp]
  00375	51		 push	 ecx
  00376	6a 01		 push	 1
  00378	8d 55 90	 lea	 edx, DWORD PTR $T200373[ebp]
  0037b	52		 push	 edx
  0037c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00382	83 c4 10	 add	 esp, 16			; 00000010H
  00385	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00389	8d 4d 90	 lea	 ecx, DWORD PTR $T200373[ebp]
  0038c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00392	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00399	8d 4d ac	 lea	 ecx, DWORD PTR $T200372[ebp]
  0039c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 38   : 		CHTTPControl::HTTPWait_AD();

  003a2	e8 00 00 00 00	 call	 ?HTTPWait_AD@CHTTPControl@@SAXXZ ; CHTTPControl::HTTPWait_AD

; 39   : 
; 40   : 		if( CDownAD::m_pDownAD != NULL )

  003a7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pDownAD@CDownAD@@2PAV1@A, 0 ; CDownAD::m_pDownAD
  003ae	0f 84 d4 01 00
	00		 je	 $L198044

; 41   : 		{
; 42   : 			CDownAD::m_pDownAD->m_bGetAdData = TRUE;

  003b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pDownAD@CDownAD@@2PAV1@A ; CDownAD::m_pDownAD
  003b9	c6 40 10 01	 mov	 BYTE PTR [eax+16], 1

; 43   : 			YL_CHTTPRequest http;

  003bd	8d 4d f0	 lea	 ecx, DWORD PTR _http$198045[ebp]
  003c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0YL_CHTTPRequest@@QAE@XZ
  003c6	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 44   : 			string strSvr;

  003cd	8d 4d d0	 lea	 ecx, DWORD PTR _strSvr$198046[ebp]
  003d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  003d6	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 45   : 			if( !CLhcImg::GetAdDataServer( strSvr ) )

  003da	8d 4d d0	 lea	 ecx, DWORD PTR _strSvr$198046[ebp]
  003dd	51		 push	 ecx
  003de	e8 00 00 00 00	 call	 ?GetAdDataServer@CLhcImg@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CLhcImg::GetAdDataServer
  003e3	83 c4 04	 add	 esp, 4
  003e6	0f b6 d0	 movzx	 edx, al
  003e9	85 d2		 test	 edx, edx
  003eb	75 0e		 jne	 SHORT $L198047

; 46   : 			{
; 47   : 				strSvr = "";

  003ed	68 00 00 00 00	 push	 OFFSET FLAT:$SG198048
  003f2	8d 4d d0	 lea	 ecx, DWORD PTR _strSvr$198046[ebp]
  003f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$L198047:

; 48   : 			}
; 49   : 
; 50   : 			if( http.Request( strSvr.c_str() ,YL_CHTTPRequest::REQUEST_GET,30*1000 ) )

  003fb	8d 4d d0	 lea	 ecx, DWORD PTR _strSvr$198046[ebp]
  003fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00404	50		 push	 eax
  00405	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T200375[ebp]
  0040b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00411	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00415	6a 00		 push	 0
  00417	6a 00		 push	 0
  00419	68 30 75 00 00	 push	 30000			; 00007530H
  0041e	6a 00		 push	 0
  00420	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T200375[ebp]
  00426	50		 push	 eax
  00427	8d 4d f0	 lea	 ecx, DWORD PTR _http$198045[ebp]
  0042a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Request@YL_CHTTPRequest@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4REQUEST_TYPE@1@JPAEI@Z
  00430	88 45 8f	 mov	 BYTE PTR $T200374[ebp], al
  00433	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00437	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T200375[ebp]
  0043d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00443	0f b6 4d 8f	 movzx	 ecx, BYTE PTR $T200374[ebp]
  00447	85 c9		 test	 ecx, ecx
  00449	0f 84 94 00 00
	00		 je	 $L198050

; 51   : 			{
; 52   : 				YL_Log( "log_httpr.txt",LOG_DEBUG,"Ad--HTTP","");

  0044f	68 00 00 00 00	 push	 OFFSET FLAT:$SG198055
  00454	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T200376[ebp]
  0045a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00460	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00464	68 00 00 00 00	 push	 OFFSET FLAT:$SG198056
  00469	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T200377[ebp]
  0046f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00475	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00479	68 00 00 00 00	 push	 OFFSET FLAT:$SG198054
  0047e	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR $T200376[ebp]
  00484	52		 push	 edx
  00485	6a 00		 push	 0
  00487	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T200377[ebp]
  0048d	50		 push	 eax
  0048e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00494	83 c4 10	 add	 esp, 16			; 00000010H
  00497	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0049b	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T200377[ebp]
  004a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  004a7	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  004ab	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T200376[ebp]
  004b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 53   : 
; 54   : 				long		   lConLen = 0;

  004b7	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _lConLen$198057[ebp], 0

; 55   : 				unsigned char* pContent = http.GetContent(lConLen);

  004be	8d 4d c8	 lea	 ecx, DWORD PTR _lConLen$198057[ebp]
  004c1	51		 push	 ecx
  004c2	8d 4d f0	 lea	 ecx, DWORD PTR _http$198045[ebp]
  004c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetContent@YL_CHTTPRequest@@QAEPAEAAJ@Z
  004cb	89 45 cc	 mov	 DWORD PTR _pContent$198058[ebp], eax

; 56   : 
; 57   : 				CDownAD::m_pDownAD->DownZipFinish( pContent,lConLen );

  004ce	8b 55 c8	 mov	 edx, DWORD PTR _lConLen$198057[ebp]
  004d1	52		 push	 edx
  004d2	8b 45 cc	 mov	 eax, DWORD PTR _pContent$198058[ebp]
  004d5	50		 push	 eax
  004d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pDownAD@CDownAD@@2PAV1@A ; CDownAD::m_pDownAD
  004dc	e8 00 00 00 00	 call	 ?DownZipFinish@CDownAD@@QAEXPAXI@Z ; CDownAD::DownZipFinish

; 58   : 			}
; 59   :  			else

  004e1	eb 72		 jmp	 SHORT $L198059
$L198050:

; 60   :  			{
; 61   : 				CDownAD::m_pDownAD->m_bGetAdData = FALSE;

  004e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pDownAD@CDownAD@@2PAV1@A ; CDownAD::m_pDownAD
  004e9	c6 41 10 00	 mov	 BYTE PTR [ecx+16], 0

; 62   :  				YL_Log( "log_httpr.txt",LOG_NOTICE,"CAdData","ZipRes Sign == ");

  004ed	68 00 00 00 00	 push	 OFFSET FLAT:$SG198063
  004f2	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T200378[ebp]
  004f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  004fe	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00502	68 00 00 00 00	 push	 OFFSET FLAT:$SG198064
  00507	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T200379[ebp]
  0050d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00513	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00517	68 00 00 00 00	 push	 OFFSET FLAT:$SG198062
  0051c	8d 95 1c ff ff
	ff		 lea	 edx, DWORD PTR $T200378[ebp]
  00522	52		 push	 edx
  00523	6a 01		 push	 1
  00525	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T200379[ebp]
  0052b	50		 push	 eax
  0052c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00532	83 c4 10	 add	 esp, 16			; 00000010H
  00535	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00539	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T200379[ebp]
  0053f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00545	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00549	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T200378[ebp]
  0054f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L198059:

; 63   :  			}
; 64   :  			CDownAD::m_pDownAD->ZipResReady( CDownAD::m_pDownAD->m_bGetAdData );

  00555	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pDownAD@CDownAD@@2PAV1@A ; CDownAD::m_pDownAD
  0055b	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  0055f	52		 push	 edx
  00560	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pDownAD@CDownAD@@2PAV1@A ; CDownAD::m_pDownAD
  00566	e8 00 00 00 00	 call	 ?ZipResReady@CDownAD@@QAEXH@Z ; CDownAD::ZipResReady

; 65   : 		}

  0056b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0056f	8d 4d d0	 lea	 ecx, DWORD PTR _strSvr$198046[ebp]
  00572	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00578	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0057f	8d 4d f0	 lea	 ecx, DWORD PTR _http$198045[ebp]
  00582	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1YL_CHTTPRequest@@QAE@XZ
$L198044:

; 66   : 		YL_Log( "log_httpr.txt",LOG_NOTICE,"CAdData","--");

  00588	68 00 00 00 00	 push	 OFFSET FLAT:$SG198068
  0058d	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T200380[ebp]
  00593	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00599	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9
  005a0	68 00 00 00 00	 push	 OFFSET FLAT:$SG198069
  005a5	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T200381[ebp]
  005ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  005b1	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  005b5	68 00 00 00 00	 push	 OFFSET FLAT:$SG198067
  005ba	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T200380[ebp]
  005c0	50		 push	 eax
  005c1	6a 01		 push	 1
  005c3	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T200381[ebp]
  005c9	51		 push	 ecx
  005ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  005d0	83 c4 10	 add	 esp, 16			; 00000010H
  005d3	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  005d7	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T200381[ebp]
  005dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  005e3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  005ea	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T200380[ebp]
  005f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L198038:

; 67   :  	}
; 68   :  	CHTTPControl::HTTPFinish_DownAD();

  005f6	e8 00 00 00 00	 call	 ?HTTPFinish_DownAD@CHTTPControl@@SAXXZ ; CHTTPControl::HTTPFinish_DownAD

; 69   : 	return 0;

  005fb	33 c0		 xor	 eax, eax

; 70   : }

  005fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00600	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00607	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0060a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0060f	8b e5		 mov	 esp, ebp
  00611	5d		 pop	 ebp
  00612	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L200382:
  000c6	8d 4d ac	 lea	 ecx, DWORD PTR $T200372[ebp]
  000c9	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200383:
  000cf	8d 4d 90	 lea	 ecx, DWORD PTR $T200373[ebp]
  000d2	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200384:
  000d8	8d 4d f0	 lea	 ecx, DWORD PTR _http$198045[ebp]
  000db	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1YL_CHTTPRequest@@QAE@XZ
$L200385:
  000e1	8d 4d d0	 lea	 ecx, DWORD PTR _strSvr$198046[ebp]
  000e4	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200386:
  000ea	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T200375[ebp]
  000f0	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200387:
  000f6	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T200376[ebp]
  000fc	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200388:
  00102	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T200377[ebp]
  00108	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200389:
  0010e	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T200378[ebp]
  00114	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200390:
  0011a	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T200379[ebp]
  00120	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200391:
  00126	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T200380[ebp]
  0012c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200392:
  00132	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T200381[ebp]
  00138	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Thread_DownZip@@YGKPAX@Z:
  0013e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200394
  00143	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Thread_DownZip@@YGKPAX@Z ENDP				; Thread_DownZip
EXTRN	__imp__TerminateThread@8:NEAR
EXTRN	__imp__GetExitCodeThread@8:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
xdata$x	SEGMENT
$T200416 DD	0ffffffffH
	DD	FLAT:$L200409
	DD	00H
	DD	FLAT:$L200410
	DD	0ffffffffH
	DD	FLAT:$L200411
	DD	02H
	DD	FLAT:$L200412
$T200414 DD	019930520H
	DD	04H
	DD	FLAT:$T200416
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv135 = -144						; size = 4
_this$ = -140						; size = 4
$T200408 = -136						; size = 28
$T200407 = -108						; size = 28
$T200404 = -80						; size = 4
$T200403 = -76						; size = 4
$T200402 = -72						; size = 28
$T200401 = -44						; size = 28
_dwExitCode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?DataAppExit@CDownAD@@UAEXXZ PROC NEAR			; CDownAD::DataAppExit
; _this$ = ecx

; 81   : {

  00620	55		 push	 ebp
  00621	8b ec		 mov	 ebp, esp
  00623	6a ff		 push	 -1
  00625	68 00 00 00 00	 push	 __ehhandler$?DataAppExit@CDownAD@@UAEXXZ
  0062a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00630	50		 push	 eax
  00631	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00638	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  0063e	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 82   : 	YL_Log( STR_LOG_FILE,LOG_NOTICE,"CDownAD","DataAppExit");

  00644	68 00 00 00 00	 push	 OFFSET FLAT:$SG198089
  00649	8d 4d d4	 lea	 ecx, DWORD PTR $T200401[ebp]
  0064c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00652	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00659	68 00 00 00 00	 push	 OFFSET FLAT:$SG198090
  0065e	8d 4d b8	 lea	 ecx, DWORD PTR $T200402[ebp]
  00661	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00667	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0066b	68 00 00 00 00	 push	 OFFSET FLAT:$SG198088
  00670	8d 45 d4	 lea	 eax, DWORD PTR $T200401[ebp]
  00673	50		 push	 eax
  00674	6a 01		 push	 1
  00676	8d 4d b8	 lea	 ecx, DWORD PTR $T200402[ebp]
  00679	51		 push	 ecx
  0067a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00680	83 c4 10	 add	 esp, 16			; 00000010H
  00683	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00687	8d 4d b8	 lea	 ecx, DWORD PTR $T200402[ebp]
  0068a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00690	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00697	8d 4d d4	 lea	 ecx, DWORD PTR $T200401[ebp]
  0069a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 83   : 	DWORD dwExitCode = 0;

  006a0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwExitCode$[ebp], 0

; 84   : 
; 85   : 	if( GetExitCodeThread( m_hThreadDown,&dwExitCode) && dwExitCode == STILL_ACTIVE )

  006a7	8d 55 f0	 lea	 edx, DWORD PTR _dwExitCode$[ebp]
  006aa	52		 push	 edx
  006ab	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006b1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  006b4	51		 push	 ecx
  006b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeThread@8
  006bb	85 c0		 test	 eax, eax
  006bd	74 30		 je	 SHORT $L198093
  006bf	81 7d f0 03 01
	00 00		 cmp	 DWORD PTR _dwExitCode$[ebp], 259 ; 00000103H
  006c6	75 27		 jne	 SHORT $L198093

; 86   : 	{
; 87   : 		TerminateThread(m_hThreadDown,1);

  006c8	6a 01		 push	 1
  006ca	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006d0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  006d3	50		 push	 eax
  006d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 88   : 		WaitForSingleObject( m_hThreadDown,2000);

  006da	68 d0 07 00 00	 push	 2000			; 000007d0H
  006df	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006e5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  006e8	52		 push	 edx
  006e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$L198093:

; 89   : 	}
; 90   : 	CloseHandle( m_hThreadDown );

  006ef	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006f5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  006f8	51		 push	 ecx
  006f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 91   : 	delete this;

  006ff	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00705	83 ea 08	 sub	 edx, 8
  00708	89 55 b0	 mov	 DWORD PTR $T200404[ebp], edx
  0070b	8b 45 b0	 mov	 eax, DWORD PTR $T200404[ebp]
  0070e	89 45 b4	 mov	 DWORD PTR $T200403[ebp], eax
  00711	83 7d b4 00	 cmp	 DWORD PTR $T200403[ebp], 0
  00715	74 18		 je	 SHORT $L200405
  00717	6a 01		 push	 1
  00719	8b 4d b4	 mov	 ecx, DWORD PTR $T200403[ebp]
  0071c	83 c1 08	 add	 ecx, 8
  0071f	8b 55 b4	 mov	 edx, DWORD PTR $T200403[ebp]
  00722	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00725	ff 10		 call	 DWORD PTR [eax]
  00727	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv135[ebp], eax
  0072d	eb 0a		 jmp	 SHORT $L200406
$L200405:
  0072f	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv135[ebp], 0
$L200406:

; 92   : 	YL_Log( STR_LOG_FILE,LOG_NOTICE,"CDownAD","DataAppExit-- out");

  00739	68 00 00 00 00	 push	 OFFSET FLAT:$SG198099
  0073e	8d 4d 94	 lea	 ecx, DWORD PTR $T200407[ebp]
  00741	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00747	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0074e	68 00 00 00 00	 push	 OFFSET FLAT:$SG198100
  00753	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T200408[ebp]
  00759	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0075f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00763	68 00 00 00 00	 push	 OFFSET FLAT:$SG198098
  00768	8d 4d 94	 lea	 ecx, DWORD PTR $T200407[ebp]
  0076b	51		 push	 ecx
  0076c	6a 01		 push	 1
  0076e	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR $T200408[ebp]
  00774	52		 push	 edx
  00775	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  0077b	83 c4 10	 add	 esp, 16			; 00000010H
  0077e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00782	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T200408[ebp]
  00788	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0078e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00795	8d 4d 94	 lea	 ecx, DWORD PTR $T200407[ebp]
  00798	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 93   : }

  0079e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  007a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  007a8	8b e5		 mov	 esp, ebp
  007aa	5d		 pop	 ebp
  007ab	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200409:
  00148	8d 4d d4	 lea	 ecx, DWORD PTR $T200401[ebp]
  0014b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200410:
  00151	8d 4d b8	 lea	 ecx, DWORD PTR $T200402[ebp]
  00154	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200411:
  0015a	8d 4d 94	 lea	 ecx, DWORD PTR $T200407[ebp]
  0015d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200412:
  00163	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T200408[ebp]
  00169	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?DataAppExit@CDownAD@@UAEXXZ:
  0016f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200414
  00174	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DataAppExit@CDownAD@@UAEXXZ ENDP			; CDownAD::DataAppExit
PUBLIC	?NotifyZipSuc@CDownAD@@QAEXXZ			; CDownAD::NotifyZipSuc
PUBLIC	?NotifyZipFailed@CDownAD@@QAEXXZ		; CDownAD::NotifyZipFailed
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bDownSuccess$ = 8					; size = 4
?ZipResReady@CDownAD@@QAEXH@Z PROC NEAR			; CDownAD::ZipResReady
; _this$ = ecx

; 96   : {

  007b0	55		 push	 ebp
  007b1	8b ec		 mov	 ebp, esp
  007b3	51		 push	 ecx
  007b4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 97   : 	if(bDownSuccess)

  007b7	83 7d 08 00	 cmp	 DWORD PTR _bDownSuccess$[ebp], 0
  007bb	74 0a		 je	 SHORT $L198105

; 98   : 	{
; 99   : 		NotifyZipSuc();

  007bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007c0	e8 00 00 00 00	 call	 ?NotifyZipSuc@CDownAD@@QAEXXZ ; CDownAD::NotifyZipSuc

; 100  : 	}else

  007c5	eb 08		 jmp	 SHORT $L198104
$L198105:

; 101  : 	{
; 102  : 		NotifyZipFailed();

  007c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007ca	e8 00 00 00 00	 call	 ?NotifyZipFailed@CDownAD@@QAEXXZ ; CDownAD::NotifyZipFailed
$L198104:

; 103  : 	}
; 104  : }

  007cf	8b e5		 mov	 esp, ebp
  007d1	5d		 pop	 ebp
  007d2	c2 04 00	 ret	 4
?ZipResReady@CDownAD@@QAEXH@Z ENDP			; CDownAD::ZipResReady
; Function compile flags: /Odt
_this$ = -4						; size = 4
?NotifyZipFailed@CDownAD@@QAEXXZ PROC NEAR		; CDownAD::NotifyZipFailed
; _this$ = ecx

; 107  : {

  007e0	55		 push	 ebp
  007e1	8b ec		 mov	 ebp, esp
  007e3	51		 push	 ecx
  007e4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 108  : 	m_hThreadDown = CreateThread(0,0,Thread_DownZip,0,0,0);

  007e7	6a 00		 push	 0
  007e9	6a 00		 push	 0
  007eb	6a 00		 push	 0
  007ed	68 00 00 00 00	 push	 OFFSET FLAT:?Thread_DownZip@@YGKPAX@Z ; Thread_DownZip
  007f2	6a 00		 push	 0
  007f4	6a 00		 push	 0
  007f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  007fc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007ff	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 109  : }

  00802	8b e5		 mov	 esp, ebp
  00804	5d		 pop	 ebp
  00805	c3		 ret	 0
?NotifyZipFailed@CDownAD@@QAEXXZ ENDP			; CDownAD::NotifyZipFailed
_TEXT	ENDS
PUBLIC	??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
PUBLIC	?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
PUBLIC	??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
PUBLIC	??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
PUBLIC	??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
PUBLIC	??_R0?AVIAdObserver@@@8				; IAdObserver `RTTI Type Descriptor'
EXTRN	?SetUpdateADData@CLhcImg@@SA_NXZ:NEAR		; CLhcImg::SetUpdateADData
EXTRN	___RTDynamicCast:NEAR
EXTRN	?AfxGetMessageManager@@YAPAVIMessageManager@@XZ:NEAR ; AfxGetMessageManager
xdata$x	SEGMENT
$T200426 DD	0ffffffffH
	DD	FLAT:$L200422
$T200424 DD	019930520H
	DD	01H
	DD	FLAT:$T200426
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0?AVIAdObserver@@@8
_DATA	SEGMENT
??_R0?AVIAdObserver@@@8 DD FLAT:??_7type_info@@6B@	; IAdObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIAdObserver@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
tv70 = -48						; size = 4
_this$ = -44						; size = 4
$T200421 = -40						; size = 4
$T200420 = -36						; size = 4
_pOb$198614 = -32					; size = 4
_itOb$198607 = -28					; size = 4
_listOb$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
?NotifyZipSuc@CDownAD@@QAEXXZ PROC NEAR			; CDownAD::NotifyZipSuc
; _this$ = ecx

; 112  : {

  00810	55		 push	 ebp
  00811	8b ec		 mov	 ebp, esp
  00813	6a ff		 push	 -1
  00815	68 00 00 00 00	 push	 __ehhandler$?NotifyZipSuc@CDownAD@@QAEXXZ
  0081a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00820	50		 push	 eax
  00821	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00828	83 ec 24	 sub	 esp, 36			; 00000024H
  0082b	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 	ReloadAd();

  0082e	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00831	e8 00 00 00 00	 call	 ?ReloadAd@CDownAD@@AAEXXZ ; CDownAD::ReloadAd

; 114  : 
; 115  : 	list<IMessageObserver*> listOb;

  00836	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00839	e8 00 00 00 00	 call	 ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
  0083e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 116  : 	AfxGetMessageManager()->QueryObservers( ID_MESSAGE_AD,listOb);

  00845	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  0084a	89 45 d0	 mov	 DWORD PTR tv70[ebp], eax
  0084d	8d 45 e8	 lea	 eax, DWORD PTR _listOb$[ebp]
  00850	50		 push	 eax
  00851	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_AD
  00856	8b 4d d0	 mov	 ecx, DWORD PTR tv70[ebp]
  00859	8b 11		 mov	 edx, DWORD PTR [ecx]
  0085b	8b 4d d0	 mov	 ecx, DWORD PTR tv70[ebp]
  0085e	ff 52 0c	 call	 DWORD PTR [edx+12]

; 117  : 
; 118  : 	for( list<IMessageObserver*>::iterator itOb = listOb.begin();itOb != listOb.end();itOb++ )

  00861	8d 45 e4	 lea	 eax, DWORD PTR _itOb$198607[ebp]
  00864	50		 push	 eax
  00865	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00868	e8 00 00 00 00	 call	 ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
  0086d	eb 0e		 jmp	 SHORT $L198611
$L198612:
  0086f	6a 00		 push	 0
  00871	8d 4d dc	 lea	 ecx, DWORD PTR $T200420[ebp]
  00874	51		 push	 ecx
  00875	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$198607[ebp]
  00878	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
$L198611:
  0087d	8d 55 d8	 lea	 edx, DWORD PTR $T200421[ebp]
  00880	52		 push	 edx
  00881	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00884	e8 00 00 00 00	 call	 ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
  00889	50		 push	 eax
  0088a	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$198607[ebp]
  0088d	e8 00 00 00 00	 call	 ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
  00892	0f b6 c0	 movzx	 eax, al
  00895	85 c0		 test	 eax, eax
  00897	74 31		 je	 SHORT $L198613

; 119  : 	{
; 120  : 		IAdObserver* pOb = dynamic_cast<IAdObserver*>(*itOb);

  00899	6a 00		 push	 0
  0089b	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIAdObserver@@@8
  008a0	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIMessageObserver@@@8
  008a5	6a 00		 push	 0
  008a7	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$198607[ebp]
  008aa	e8 00 00 00 00	 call	 ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
  008af	8b 08		 mov	 ecx, DWORD PTR [eax]
  008b1	51		 push	 ecx
  008b2	e8 00 00 00 00	 call	 ___RTDynamicCast
  008b7	83 c4 14	 add	 esp, 20			; 00000014H
  008ba	89 45 e0	 mov	 DWORD PTR _pOb$198614[ebp], eax

; 121  : 		pOb->AdOb_UpdataSuc();

  008bd	8b 55 e0	 mov	 edx, DWORD PTR _pOb$198614[ebp]
  008c0	8b 02		 mov	 eax, DWORD PTR [edx]
  008c2	8b 4d e0	 mov	 ecx, DWORD PTR _pOb$198614[ebp]
  008c5	ff 50 04	 call	 DWORD PTR [eax+4]

; 122  : 	}

  008c8	eb a5		 jmp	 SHORT $L198612
$L198613:

; 123  : 	CLhcImg::SetUpdateADData();

  008ca	e8 00 00 00 00	 call	 ?SetUpdateADData@CLhcImg@@SA_NXZ ; CLhcImg::SetUpdateADData

; 124  : }

  008cf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  008d6	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  008d9	e8 00 00 00 00	 call	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
  008de	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  008e1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  008e8	8b e5		 mov	 esp, ebp
  008ea	5d		 pop	 ebp
  008eb	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200422:
  00179	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0017c	e9 00 00 00 00	 jmp	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
__ehhandler$?NotifyZipSuc@CDownAD@@QAEXXZ:
  00181	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200424
  00186	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NotifyZipSuc@CDownAD@@QAEXXZ ENDP			; CDownAD::NotifyZipSuc
PUBLIC	?NotifyZipStart@CDownAD@@QAEXXZ			; CDownAD::NotifyZipStart
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NotifyZipStart@CDownAD@@QAEXXZ PROC NEAR		; CDownAD::NotifyZipStart
; _this$ = ecx

; 127  : {

  008f0	55		 push	 ebp
  008f1	8b ec		 mov	 ebp, esp
  008f3	51		 push	 ecx
  008f4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : }

  008f7	8b e5		 mov	 esp, ebp
  008f9	5d		 pop	 ebp
  008fa	c3		 ret	 0
?NotifyZipStart@CDownAD@@QAEXXZ ENDP			; CDownAD::NotifyZipStart
_TEXT	ENDS
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
EXTRN	?GetAdPath@CLhcImg@@SA_NQADH@Z:NEAR		; CLhcImg::GetAdPath
EXTRN	__imp_?UnCompress@YL_CFileZip@@SA_NPAXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@_NV23@@Z:NEAR
xdata$x	SEGMENT
$T200448 DD	0ffffffffH
	DD	FLAT:$L200437
	DD	00H
	DD	FLAT:$L200438
	DD	0ffffffffH
	DD	FLAT:$L200439
	DD	02H
	DD	FLAT:$L200440
	DD	03H
	DD	FLAT:$L200441
	DD	02H
	DD	FLAT:$L200441
	DD	02H
	DD	FLAT:$L200442
	DD	06H
	DD	FLAT:$L200443
$T200445 DD	019930520H
	DD	08H
	DD	FLAT:$T200448
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv164 = -717						; size = 1
tv166 = -716						; size = 4
tv77 = -712						; size = 4
tv163 = -708						; size = 4
tv82 = -704						; size = 4
_this$ = -700						; size = 4
$T200436 = -696						; size = 28
$T200435 = -668						; size = 28
$T200434 = -640						; size = 28
$T200433 = -612						; size = 4
$T200432 = -605						; size = 1
$T200431 = -604						; size = 28
$T200430 = -576						; size = 28
_szBuffer$ = -548					; size = 512
__$ArrayPad$ = -32					; size = 4
_vecStrPath$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pVoid$ = 8						; size = 4
_unContentLen$ = 12					; size = 4
?DownZipFinish@CDownAD@@QAEXPAXI@Z PROC NEAR		; CDownAD::DownZipFinish
; _this$ = ecx

; 131  : {

  00900	55		 push	 ebp
  00901	8b ec		 mov	 ebp, esp
  00903	6a ff		 push	 -1
  00905	68 00 00 00 00	 push	 __ehhandler$?DownZipFinish@CDownAD@@QAEXPAXI@Z
  0090a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00910	50		 push	 eax
  00911	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00918	81 ec c4 02 00
	00		 sub	 esp, 708		; 000002c4H
  0091e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00923	89 45 e0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00926	89 8d 44 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 	char szBuffer[512];
; 133  : 	if( !CLhcImg::GetAdPath( szBuffer,512 ) )

  0092c	68 00 02 00 00	 push	 512			; 00000200H
  00931	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  00937	50		 push	 eax
  00938	e8 00 00 00 00	 call	 ?GetAdPath@CLhcImg@@SA_NQADH@Z ; CLhcImg::GetAdPath
  0093d	83 c4 08	 add	 esp, 8
  00940	0f b6 c8	 movzx	 ecx, al
  00943	85 c9		 test	 ecx, ecx
  00945	75 73		 jne	 SHORT $L198626

; 134  : 	{
; 135  : 		YL_Log( "ad.txt",LOG_NOTICE,"DownZipFinish","GetAd Path Failed" );

  00947	68 00 00 00 00	 push	 OFFSET FLAT:$SG198630
  0094c	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR $T200430[ebp]
  00952	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00958	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0095f	68 00 00 00 00	 push	 OFFSET FLAT:$SG198631
  00964	8d 8d a4 fd ff
	ff		 lea	 ecx, DWORD PTR $T200431[ebp]
  0096a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00970	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00974	68 00 00 00 00	 push	 OFFSET FLAT:$SG198629
  00979	8d 95 c0 fd ff
	ff		 lea	 edx, DWORD PTR $T200430[ebp]
  0097f	52		 push	 edx
  00980	6a 01		 push	 1
  00982	8d 85 a4 fd ff
	ff		 lea	 eax, DWORD PTR $T200431[ebp]
  00988	50		 push	 eax
  00989	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  0098f	83 c4 10	 add	 esp, 16			; 00000010H
  00992	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00996	8d 8d a4 fd ff
	ff		 lea	 ecx, DWORD PTR $T200431[ebp]
  0099c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  009a2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  009a9	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR $T200430[ebp]
  009af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 136  : 		return;

  009b5	e9 41 01 00 00	 jmp	 $L198624
$L198626:

; 137  : 	}
; 138  : 
; 139  : 	vector<string> vecStrPath;

  009ba	8d 4d e4	 lea	 ecx, DWORD PTR _vecStrPath$[ebp]
  009bd	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  009c2	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 140  : 	if( !YL_CFileZip::UnCompress( pVoid,unContentLen,string(szBuffer),vecStrPath,true) )

  009c9	83 ec 1c	 sub	 esp, 28			; 0000001cH
  009cc	8b cc		 mov	 ecx, esp
  009ce	89 a5 9c fd ff
	ff		 mov	 DWORD PTR $T200433[ebp], esp
  009d4	68 00 00 00 00	 push	 OFFSET FLAT:$SG198831
  009d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  009df	89 85 40 fd ff
	ff		 mov	 DWORD PTR tv82[ebp], eax
  009e5	8b 8d 40 fd ff
	ff		 mov	 ecx, DWORD PTR tv82[ebp]
  009eb	89 8d 3c fd ff
	ff		 mov	 DWORD PTR tv163[ebp], ecx
  009f1	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  009f5	8d 95 dc fd ff
	ff		 lea	 edx, DWORD PTR _szBuffer$[ebp]
  009fb	52		 push	 edx
  009fc	8d 8d 80 fd ff
	ff		 lea	 ecx, DWORD PTR $T200434[ebp]
  00a02	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00a08	89 85 38 fd ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  00a0e	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR tv77[ebp]
  00a14	89 85 34 fd ff
	ff		 mov	 DWORD PTR tv166[ebp], eax
  00a1a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00a1e	6a 01		 push	 1
  00a20	8d 4d e4	 lea	 ecx, DWORD PTR _vecStrPath$[ebp]
  00a23	51		 push	 ecx
  00a24	8b 95 34 fd ff
	ff		 mov	 edx, DWORD PTR tv166[ebp]
  00a2a	52		 push	 edx
  00a2b	8b 45 0c	 mov	 eax, DWORD PTR _unContentLen$[ebp]
  00a2e	50		 push	 eax
  00a2f	8b 4d 08	 mov	 ecx, DWORD PTR _pVoid$[ebp]
  00a32	51		 push	 ecx
  00a33	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00a37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?UnCompress@YL_CFileZip@@SA_NPAXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@_NV23@@Z
  00a3d	83 c4 30	 add	 esp, 48			; 00000030H
  00a40	88 85 33 fd ff
	ff		 mov	 BYTE PTR tv164[ebp], al
  00a46	0f b6 95 33 fd
	ff ff		 movzx	 edx, BYTE PTR tv164[ebp]
  00a4d	f7 da		 neg	 edx
  00a4f	1b d2		 sbb	 edx, edx
  00a51	42		 inc	 edx
  00a52	88 95 a3 fd ff
	ff		 mov	 BYTE PTR $T200432[ebp], dl
  00a58	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00a5c	8d 8d 80 fd ff
	ff		 lea	 ecx, DWORD PTR $T200434[ebp]
  00a62	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00a68	0f b6 85 a3 fd
	ff ff		 movzx	 eax, BYTE PTR $T200432[ebp]
  00a6f	85 c0		 test	 eax, eax
  00a71	74 79		 je	 SHORT $L198829

; 141  : 	{
; 142  : 		YL_Log( "qq.txt",LOG_NOTICE,"DownZipFinish","res !!!!!!" );

  00a73	68 00 00 00 00	 push	 OFFSET FLAT:$SG198835
  00a78	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR $T200435[ebp]
  00a7e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00a84	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00a88	68 00 00 00 00	 push	 OFFSET FLAT:$SG198836
  00a8d	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T200436[ebp]
  00a93	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00a99	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00a9d	68 00 00 00 00	 push	 OFFSET FLAT:$SG198834
  00aa2	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR $T200435[ebp]
  00aa8	51		 push	 ecx
  00aa9	6a 01		 push	 1
  00aab	8d 95 48 fd ff
	ff		 lea	 edx, DWORD PTR $T200436[ebp]
  00ab1	52		 push	 edx
  00ab2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00ab8	83 c4 10	 add	 esp, 16			; 00000010H
  00abb	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00abf	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T200436[ebp]
  00ac5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00acb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00acf	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR $T200435[ebp]
  00ad5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 143  : 		return;

  00adb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ae2	8d 4d e4	 lea	 ecx, DWORD PTR _vecStrPath$[ebp]
  00ae5	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00aea	eb 0f		 jmp	 SHORT $L198624
$L198829:

; 144  : 	}
; 145  : }

  00aec	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00af3	8d 4d e4	 lea	 ecx, DWORD PTR _vecStrPath$[ebp]
  00af6	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$L198624:
  00afb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00afe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00b05	8b 4d e0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b08	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b0d	8b e5		 mov	 esp, ebp
  00b0f	5d		 pop	 ebp
  00b10	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
$L200437:
  0018b	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR $T200430[ebp]
  00191	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200438:
  00197	8d 8d a4 fd ff
	ff		 lea	 ecx, DWORD PTR $T200431[ebp]
  0019d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200439:
  001a3	8d 4d e4	 lea	 ecx, DWORD PTR _vecStrPath$[ebp]
  001a6	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$L200440:
  001ab	8b 8d 9c fd ff
	ff		 mov	 ecx, DWORD PTR $T200433[ebp]
  001b1	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200441:
  001b7	8d 8d 80 fd ff
	ff		 lea	 ecx, DWORD PTR $T200434[ebp]
  001bd	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200442:
  001c3	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR $T200435[ebp]
  001c9	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200443:
  001cf	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T200436[ebp]
  001d5	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?DownZipFinish@CDownAD@@QAEXPAXI@Z:
  001db	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200445
  001e0	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DownZipFinish@CDownAD@@QAEXPAXI@Z ENDP			; CDownAD::DownZipFinish
PUBLIC	?push_back@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXABUAD_STRUCT@@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::push_back
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0AD_STRUCT@@QAE@XZ				; AD_STRUCT::AD_STRUCT
PUBLIC	??1AD_STRUCT@@QAE@XZ				; AD_STRUCT::~AD_STRUCT
EXTRN	__imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ:NEAR ; YL_StringUtil::Format
EXTRN	??0YL_Ini@@QAE@PBD@Z:NEAR			; YL_Ini::YL_Ini
EXTRN	??1YL_Ini@@UAE@XZ:NEAR				; YL_Ini::~YL_Ini
EXTRN	?GetString@YL_Ini@@QBEKPBD0PADK0@Z:NEAR		; YL_Ini::GetString
EXTRN	?GetInt@YL_Ini@@QBEHPBD0HH@Z:NEAR		; YL_Ini::GetInt
EXTRN	?IsValid@YL_FileInfo@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:NEAR ; YL_FileInfo::IsValid
EXTRN	_memset:NEAR
EXTRN	_strcat:NEAR
EXTRN	_strlen:NEAR
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
xdata$x	SEGMENT
$T200461 DD	0ffffffffH
	DD	FLAT:$L200452
	DD	00H
	DD	FLAT:$L200453
	DD	01H
	DD	FLAT:$L200454
	DD	02H
	DD	FLAT:$L200455
	DD	03H
	DD	FLAT:$L200456
$T200458 DD	019930520H
	DD	05H
	DD	FLAT:$T200461
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv199 = -1736						; size = 4
tv132 = -1732						; size = 4
_this$ = -1728						; size = 4
$T200451 = -1724					; size = 28
_ad$198857 = -1696					; size = 56
_i$198853 = -1640					; size = 4
_strAdPath$ = -1636					; size = 28
_strTmpKey$ = -1608					; size = 28
_ini$ = -1580						; size = 8
_szBuffer$ = -1572					; size = 512
_szSection$ = -1056					; size = 4
_dwTmpRet$ = -1052					; size = 4
_nAdNum$ = -1048					; size = 4
_szTmpBuf$ = -1044					; size = 1024
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?ReloadAd@CDownAD@@AAEXXZ PROC NEAR			; CDownAD::ReloadAd
; _this$ = ecx

; 148  : {

  00b20	55		 push	 ebp
  00b21	8b ec		 mov	 ebp, esp
  00b23	6a ff		 push	 -1
  00b25	68 00 00 00 00	 push	 __ehhandler$?ReloadAd@CDownAD@@AAEXXZ
  00b2a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00b30	50		 push	 eax
  00b31	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00b38	81 ec bc 06 00
	00		 sub	 esp, 1724		; 000006bcH
  00b3e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00b43	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00b46	57		 push	 edi
  00b47	89 8d 40 f9 ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 149  : 	m_iCurAd = 0;

  00b4d	8b 85 40 f9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b53	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 150  : 	m_vecAD.clear();

  00b5a	8b 8d 40 f9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b60	83 c1 14	 add	 ecx, 20			; 00000014H
  00b63	e8 00 00 00 00	 call	 ?clear@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::clear

; 151  : 	//
; 152  : 	char szBuffer[512];
; 153  : 	memset( szBuffer, 0, 512 );

  00b68	68 00 02 00 00	 push	 512			; 00000200H
  00b6d	6a 00		 push	 0
  00b6f	8d 8d dc f9 ff
	ff		 lea	 ecx, DWORD PTR _szBuffer$[ebp]
  00b75	51		 push	 ecx
  00b76	e8 00 00 00 00	 call	 _memset
  00b7b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 154  : 	if( !CLhcImg::GetAdPath( szBuffer,512 ) )

  00b7e	68 00 02 00 00	 push	 512			; 00000200H
  00b83	8d 95 dc f9 ff
	ff		 lea	 edx, DWORD PTR _szBuffer$[ebp]
  00b89	52		 push	 edx
  00b8a	e8 00 00 00 00	 call	 ?GetAdPath@CLhcImg@@SA_NQADH@Z ; CLhcImg::GetAdPath
  00b8f	83 c4 08	 add	 esp, 8
  00b92	0f b6 c0	 movzx	 eax, al
  00b95	85 c0		 test	 eax, eax
  00b97	75 05		 jne	 SHORT $L198841

; 155  : 	{
; 156  : 		return;

  00b99	e9 f0 02 00 00	 jmp	 $L198839
$L198841:

; 157  : 	}
; 158  : 	string strAdPath = string( szBuffer );

  00b9e	8d 8d dc f9 ff
	ff		 lea	 ecx, DWORD PTR _szBuffer$[ebp]
  00ba4	51		 push	 ecx
  00ba5	8d 8d 9c f9 ff
	ff		 lea	 ecx, DWORD PTR _strAdPath$[ebp]
  00bab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00bb1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 159  : 	strcat( szBuffer, "AdLoadingPane.ini" );

  00bb8	68 00 00 00 00	 push	 OFFSET FLAT:$SG198844
  00bbd	8d 95 dc f9 ff
	ff		 lea	 edx, DWORD PTR _szBuffer$[ebp]
  00bc3	52		 push	 edx
  00bc4	e8 00 00 00 00	 call	 _strcat
  00bc9	83 c4 08	 add	 esp, 8

; 160  : 
; 161  : 	YL_Ini ini (szBuffer);

  00bcc	8d 85 dc f9 ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  00bd2	50		 push	 eax
  00bd3	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _ini$[ebp]
  00bd9	e8 00 00 00 00	 call	 ??0YL_Ini@@QAE@PBD@Z	; YL_Ini::YL_Ini
  00bde	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 162  : 	const char * szSection = "AdLoadingPane";

  00be2	c7 85 e0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _szSection$[ebp], OFFSET FLAT:$SG198847

; 163  : 	int nAdNum = ini.GetInt (szSection, "AdLoadingPaneNum", 0);

  00bec	6a 0a		 push	 10			; 0000000aH
  00bee	6a 00		 push	 0
  00bf0	68 00 00 00 00	 push	 OFFSET FLAT:$SG198849
  00bf5	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR _szSection$[ebp]
  00bfb	51		 push	 ecx
  00bfc	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _ini$[ebp]
  00c02	e8 00 00 00 00	 call	 ?GetInt@YL_Ini@@QBEHPBD0HH@Z ; YL_Ini::GetInt
  00c07	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _nAdNum$[ebp], eax

; 164  : 
; 165  : 	char szTmpBuf [1024] = {0};

  00c0d	c6 85 ec fb ff
	ff 00		 mov	 BYTE PTR _szTmpBuf$[ebp], 0
  00c14	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00c19	33 c0		 xor	 eax, eax
  00c1b	8d bd ed fb ff
	ff		 lea	 edi, DWORD PTR _szTmpBuf$[ebp+1]
  00c21	f3 ab		 rep stosd
  00c23	66 ab		 stosw
  00c25	aa		 stosb

; 166  : 	DWORD dwTmpRet = 0;

  00c26	c7 85 e4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwTmpRet$[ebp], 0

; 167  : 	string strTmpKey;

  00c30	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _strTmpKey$[ebp]
  00c36	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00c3c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 168  : 	for (int i = 0; i < nAdNum; i++)

  00c40	c7 85 98 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$198853[ebp], 0
  00c4a	eb 0f		 jmp	 SHORT $L198854
$L198855:
  00c4c	8b 95 98 f9 ff
	ff		 mov	 edx, DWORD PTR _i$198853[ebp]
  00c52	83 c2 01	 add	 edx, 1
  00c55	89 95 98 f9 ff
	ff		 mov	 DWORD PTR _i$198853[ebp], edx
$L198854:
  00c5b	8b 85 98 f9 ff
	ff		 mov	 eax, DWORD PTR _i$198853[ebp]
  00c61	3b 85 e8 fb ff
	ff		 cmp	 eax, DWORD PTR _nAdNum$[ebp]
  00c67	0f 8d ef 01 00
	00		 jge	 $L198856

; 169  : 	{
; 170  : 		AD_STRUCT ad;

  00c6d	8d 8d 60 f9 ff
	ff		 lea	 ecx, DWORD PTR _ad$198857[ebp]
  00c73	e8 00 00 00 00	 call	 ??0AD_STRUCT@@QAE@XZ
  00c78	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 171  : 		//strLinkUrl
; 172  : 		memset (szTmpBuf, 0, sizeof (char) * 1024);

  00c7c	68 00 04 00 00	 push	 1024			; 00000400H
  00c81	6a 00		 push	 0
  00c83	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmpBuf$[ebp]
  00c89	51		 push	 ecx
  00c8a	e8 00 00 00 00	 call	 _memset
  00c8f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 173  : 		YL_StringUtil::Format (strTmpKey, "LoadingPaneLink%d", i);

  00c92	8b 95 98 f9 ff
	ff		 mov	 edx, DWORD PTR _i$198853[ebp]
  00c98	52		 push	 edx
  00c99	68 00 00 00 00	 push	 OFFSET FLAT:$SG198859
  00c9e	8d 85 b8 f9 ff
	ff		 lea	 eax, DWORD PTR _strTmpKey$[ebp]
  00ca4	50		 push	 eax
  00ca5	e8 00 00 00 00	 call	 ?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; YL_StringUtil::Format
  00caa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 174  : 		dwTmpRet = ini.GetString (szSection, strTmpKey.c_str (), szTmpBuf, 1024 - 1);

  00cad	6a 00		 push	 0
  00caf	68 ff 03 00 00	 push	 1023			; 000003ffH
  00cb4	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmpBuf$[ebp]
  00cba	51		 push	 ecx
  00cbb	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _strTmpKey$[ebp]
  00cc1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00cc7	50		 push	 eax
  00cc8	8b 95 e0 fb ff
	ff		 mov	 edx, DWORD PTR _szSection$[ebp]
  00cce	52		 push	 edx
  00ccf	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _ini$[ebp]
  00cd5	e8 00 00 00 00	 call	 ?GetString@YL_Ini@@QBEKPBD0PADK0@Z ; YL_Ini::GetString
  00cda	89 85 e4 fb ff
	ff		 mov	 DWORD PTR _dwTmpRet$[ebp], eax

; 175  : 		if (dwTmpRet == 0 || strlen(szTmpBuf) == 0)

  00ce0	83 bd e4 fb ff
	ff 00		 cmp	 DWORD PTR _dwTmpRet$[ebp], 0
  00ce7	74 13		 je	 SHORT $L198861
  00ce9	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szTmpBuf$[ebp]
  00cef	50		 push	 eax
  00cf0	e8 00 00 00 00	 call	 _strlen
  00cf5	83 c4 04	 add	 esp, 4
  00cf8	85 c0		 test	 eax, eax
  00cfa	75 14		 jne	 SHORT $L198860
$L198861:

; 176  : 			continue;

  00cfc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00d00	8d 8d 60 f9 ff
	ff		 lea	 ecx, DWORD PTR _ad$198857[ebp]
  00d06	e8 00 00 00 00	 call	 ??1AD_STRUCT@@QAE@XZ
  00d0b	e9 3c ff ff ff	 jmp	 $L198855
$L198860:

; 177  : 		ad.strLinkUrl = szTmpBuf;

  00d10	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmpBuf$[ebp]
  00d16	51		 push	 ecx
  00d17	8d 8d 60 f9 ff
	ff		 lea	 ecx, DWORD PTR _ad$198857[ebp]
  00d1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 178  : 		//strPicPath
; 179  : 		memset (szTmpBuf, 0, sizeof (char) * 1024);

  00d23	68 00 04 00 00	 push	 1024			; 00000400H
  00d28	6a 00		 push	 0
  00d2a	8d 95 ec fb ff
	ff		 lea	 edx, DWORD PTR _szTmpBuf$[ebp]
  00d30	52		 push	 edx
  00d31	e8 00 00 00 00	 call	 _memset
  00d36	83 c4 0c	 add	 esp, 12			; 0000000cH

; 180  : 		YL_StringUtil::Format (strTmpKey, "LoadingPanePic%d", i);

  00d39	8b 85 98 f9 ff
	ff		 mov	 eax, DWORD PTR _i$198853[ebp]
  00d3f	50		 push	 eax
  00d40	68 00 00 00 00	 push	 OFFSET FLAT:$SG198863
  00d45	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _strTmpKey$[ebp]
  00d4b	51		 push	 ecx
  00d4c	e8 00 00 00 00	 call	 ?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; YL_StringUtil::Format
  00d51	83 c4 0c	 add	 esp, 12			; 0000000cH

; 181  : 		dwTmpRet = ini.GetString (szSection, strTmpKey.c_str (), szTmpBuf, 1024 - 1);

  00d54	6a 00		 push	 0
  00d56	68 ff 03 00 00	 push	 1023			; 000003ffH
  00d5b	8d 95 ec fb ff
	ff		 lea	 edx, DWORD PTR _szTmpBuf$[ebp]
  00d61	52		 push	 edx
  00d62	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _strTmpKey$[ebp]
  00d68	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00d6e	50		 push	 eax
  00d6f	8b 85 e0 fb ff
	ff		 mov	 eax, DWORD PTR _szSection$[ebp]
  00d75	50		 push	 eax
  00d76	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _ini$[ebp]
  00d7c	e8 00 00 00 00	 call	 ?GetString@YL_Ini@@QBEKPBD0PADK0@Z ; YL_Ini::GetString
  00d81	89 85 e4 fb ff
	ff		 mov	 DWORD PTR _dwTmpRet$[ebp], eax

; 182  : 		if (dwTmpRet == 0 || strlen(szTmpBuf) == 0)

  00d87	83 bd e4 fb ff
	ff 00		 cmp	 DWORD PTR _dwTmpRet$[ebp], 0
  00d8e	74 13		 je	 SHORT $L198865
  00d90	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szTmpBuf$[ebp]
  00d96	51		 push	 ecx
  00d97	e8 00 00 00 00	 call	 _strlen
  00d9c	83 c4 04	 add	 esp, 4
  00d9f	85 c0		 test	 eax, eax
  00da1	75 14		 jne	 SHORT $L198864
$L198865:

; 183  : 			continue;

  00da3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00da7	8d 8d 60 f9 ff
	ff		 lea	 ecx, DWORD PTR _ad$198857[ebp]
  00dad	e8 00 00 00 00	 call	 ??1AD_STRUCT@@QAE@XZ
  00db2	e9 95 fe ff ff	 jmp	 $L198855
$L198864:

; 184  : 		ad.strPicPath = strAdPath + szTmpBuf;

  00db7	8d 95 ec fb ff
	ff		 lea	 edx, DWORD PTR _szTmpBuf$[ebp]
  00dbd	52		 push	 edx
  00dbe	8d 85 9c f9 ff
	ff		 lea	 eax, DWORD PTR _strAdPath$[ebp]
  00dc4	50		 push	 eax
  00dc5	8d 8d 44 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200451[ebp]
  00dcb	51		 push	 ecx
  00dcc	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00dd1	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dd4	89 85 3c f9 ff
	ff		 mov	 DWORD PTR tv132[ebp], eax
  00dda	8b 95 3c f9 ff
	ff		 mov	 edx, DWORD PTR tv132[ebp]
  00de0	89 95 38 f9 ff
	ff		 mov	 DWORD PTR tv199[ebp], edx
  00de6	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00dea	8b 85 38 f9 ff
	ff		 mov	 eax, DWORD PTR tv199[ebp]
  00df0	50		 push	 eax
  00df1	8d 8d 7c f9 ff
	ff		 lea	 ecx, DWORD PTR _ad$198857[ebp+28]
  00df7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00dfd	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00e01	8d 8d 44 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200451[ebp]
  00e07	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 185  : 
; 186  : 		if( ad.strLinkUrl.length() > 0 && YL_FileInfo::IsValid( ad.strPicPath ) )

  00e0d	8d 8d 60 f9 ff
	ff		 lea	 ecx, DWORD PTR _ad$198857[ebp]
  00e13	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00e19	85 c0		 test	 eax, eax
  00e1b	76 2b		 jbe	 SHORT $L198867
  00e1d	8d 8d 7c f9 ff
	ff		 lea	 ecx, DWORD PTR _ad$198857[ebp+28]
  00e23	51		 push	 ecx
  00e24	e8 00 00 00 00	 call	 ?IsValid@YL_FileInfo@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_FileInfo::IsValid
  00e29	83 c4 04	 add	 esp, 4
  00e2c	0f b6 d0	 movzx	 edx, al
  00e2f	85 d2		 test	 edx, edx
  00e31	74 15		 je	 SHORT $L198867

; 187  : 		{
; 188  : 			m_vecAD.push_back(ad);

  00e33	8d 85 60 f9 ff
	ff		 lea	 eax, DWORD PTR _ad$198857[ebp]
  00e39	50		 push	 eax
  00e3a	8b 8d 40 f9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e40	83 c1 14	 add	 ecx, 20			; 00000014H
  00e43	e8 00 00 00 00	 call	 ?push_back@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXABUAD_STRUCT@@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::push_back
$L198867:

; 189  : 		}
; 190  : 	}

  00e48	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00e4c	8d 8d 60 f9 ff
	ff		 lea	 ecx, DWORD PTR _ad$198857[ebp]
  00e52	e8 00 00 00 00	 call	 ??1AD_STRUCT@@QAE@XZ
  00e57	e9 f0 fd ff ff	 jmp	 $L198855
$L198856:

; 191  : }

  00e5c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00e60	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _strTmpKey$[ebp]
  00e66	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00e6c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00e70	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _ini$[ebp]
  00e76	e8 00 00 00 00	 call	 ??1YL_Ini@@UAE@XZ	; YL_Ini::~YL_Ini
  00e7b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00e82	8d 8d 9c f9 ff
	ff		 lea	 ecx, DWORD PTR _strAdPath$[ebp]
  00e88	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L198839:
  00e8e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00e91	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00e98	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e9b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ea0	5f		 pop	 edi
  00ea1	8b e5		 mov	 esp, ebp
  00ea3	5d		 pop	 ebp
  00ea4	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200452:
  001e5	8d 8d 9c f9 ff
	ff		 lea	 ecx, DWORD PTR _strAdPath$[ebp]
  001eb	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200453:
  001f1	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _ini$[ebp]
  001f7	e9 00 00 00 00	 jmp	 ??1YL_Ini@@UAE@XZ	; YL_Ini::~YL_Ini
$L200454:
  001fc	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _strTmpKey$[ebp]
  00202	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200455:
  00208	8d 8d 60 f9 ff
	ff		 lea	 ecx, DWORD PTR _ad$198857[ebp]
  0020e	e9 00 00 00 00	 jmp	 ??1AD_STRUCT@@QAE@XZ
$L200456:
  00213	8d 8d 44 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200451[ebp]
  00219	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?ReloadAd@CDownAD@@AAEXXZ:
  0021f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200458
  00224	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ReloadAd@CDownAD@@AAEXXZ ENDP				; CDownAD::ReloadAd
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200468 DD	0ffffffffH
	DD	FLAT:$L200463
$T200466 DD	019930520H
	DD	01H
	DD	FLAT:$T200468
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0AD_STRUCT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0AD_STRUCT@@QAE@XZ PROC NEAR				; AD_STRUCT::AD_STRUCT, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0AD_STRUCT@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00045	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200463:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0AD_STRUCT@@QAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200466
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0AD_STRUCT@@QAE@XZ ENDP				; AD_STRUCT::AD_STRUCT
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200478 DD	0ffffffffH
	DD	FLAT:$L200473
$T200476 DD	019930520H
	DD	01H
	DD	FLAT:$T200478
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1AD_STRUCT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AD_STRUCT@@QAE@XZ PROC NEAR				; AD_STRUCT::~AD_STRUCT, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1AD_STRUCT@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200473:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1AD_STRUCT@@QAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200476
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1AD_STRUCT@@QAE@XZ ENDP				; AD_STRUCT::~AD_STRUCT
PUBLIC	??A?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAUAD_STRUCT@@I@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::operator[]
PUBLIC	??4AD_STRUCT@@QAEAAU0@ABU0@@Z			; AD_STRUCT::operator=
PUBLIC	?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ad$ = 8						; size = 4
?GetLoadingPicAd@CDownAD@@UAE_NAAUAD_STRUCT@@@Z PROC NEAR ; CDownAD::GetLoadingPicAd
; _this$ = ecx

; 194  : {

  00eb0	55		 push	 ebp
  00eb1	8b ec		 mov	 ebp, esp
  00eb3	51		 push	 ecx
  00eb4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 195  : 	if( m_vecAD.size() == 0 )

  00eb7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00eba	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00ebd	e8 00 00 00 00	 call	 ?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size
  00ec2	85 c0		 test	 eax, eax
  00ec4	75 04		 jne	 SHORT $L198876

; 196  : 		return false;

  00ec6	32 c0		 xor	 al, al
  00ec8	eb 49		 jmp	 SHORT $L198875
$L198876:

; 197  : 
; 198  : 	m_iCurAd++;

  00eca	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ecd	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00ed0	83 c1 01	 add	 ecx, 1
  00ed3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ed6	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 199  : 	if( m_iCurAd >= m_vecAD.size() )

  00ed9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00edc	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00edf	e8 00 00 00 00	 call	 ?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size
  00ee4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ee7	39 41 1c	 cmp	 DWORD PTR [ecx+28], eax
  00eea	72 0a		 jb	 SHORT $L198877

; 200  : 	{
; 201  : 		m_iCurAd = 0;

  00eec	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00eef	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0
$L198877:

; 202  : 	} 
; 203  : 	ad = m_vecAD[m_iCurAd];

  00ef6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ef9	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00efc	51		 push	 ecx
  00efd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f00	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00f03	e8 00 00 00 00	 call	 ??A?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAUAD_STRUCT@@I@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::operator[]
  00f08	50		 push	 eax
  00f09	8b 4d 08	 mov	 ecx, DWORD PTR _ad$[ebp]
  00f0c	e8 00 00 00 00	 call	 ??4AD_STRUCT@@QAEAAU0@ABU0@@Z

; 204  : 	return true;

  00f11	b0 01		 mov	 al, 1
$L198875:

; 205  : }

  00f13	8b e5		 mov	 esp, ebp
  00f15	5d		 pop	 ebp
  00f16	c2 04 00	 ret	 4
?GetLoadingPicAd@CDownAD@@UAE_NAAUAD_STRUCT@@@Z ENDP	; CDownAD::GetLoadingPicAd
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??4AD_STRUCT@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4AD_STRUCT@@QAEAAU0@ABU0@@Z PROC NEAR			; AD_STRUCT::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00017	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0001a	51		 push	 ecx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??4AD_STRUCT@@QAEAAU0@ABU0@@Z ENDP			; AD_STRUCT::operator=
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE_NI@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Buy
PUBLIC	??0?$_Vector_val@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE@V?$allocator@UAD_STRUCT@@@1@@Z ; std::_Vector_val<AD_STRUCT,std::allocator<AD_STRUCT> >::_Vector_val<AD_STRUCT,std::allocator<AD_STRUCT> >
PUBLIC	??0?$allocator@UAD_STRUCT@@@std@@QAE@XZ		; std::allocator<AD_STRUCT>::allocator<AD_STRUCT>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::vector<AD_STRUCT,std::allocator<AD_STRUCT> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@UAD_STRUCT@@@std@@QAE@XZ ; std::allocator<AD_STRUCT>::allocator<AD_STRUCT>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE@V?$allocator@UAD_STRUCT@@@1@@Z ; std::_Vector_val<AD_STRUCT,std::allocator<AD_STRUCT> >::_Vector_val<AD_STRUCT,std::allocator<AD_STRUCT> >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE_NI@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::vector<AD_STRUCT,std::allocator<AD_STRUCT> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::~vector<AD_STRUCT,std::allocator<AD_STRUCT> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@XZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::~vector<AD_STRUCT,std::allocator<AD_STRUCT> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L200491
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L200492
$L200491:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L200492:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEAAUAD_STRUCT@@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator*
PUBLIC	??Hiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBE?AV012@H@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator+
PUBLIC	?begin@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::begin
; Function compile flags: /Odt
;	COMDAT ??A?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAUAD_STRUCT@@I@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T200496 = -8						; size = 4
$T200495 = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAUAD_STRUCT@@I@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::operator[], COMDAT
; _this$ = ecx

; 554  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		return (*(begin() + _Pos));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d f8	 lea	 ecx, DWORD PTR $T200496[ebp]
  00010	51		 push	 ecx
  00011	8d 55 fc	 lea	 edx, DWORD PTR $T200495[ebp]
  00014	52		 push	 edx
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?begin@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::begin
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBE?AV012@H@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator+
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??Diterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEAAUAD_STRUCT@@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator*

; 556  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??A?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAUAD_STRUCT@@I@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@V312@ABUAD_STRUCT@@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::insert
PUBLIC	?_Ufill@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU3@IABU3@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ufill
PUBLIC	?capacity@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::capacity
PUBLIC	?end@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::end
; Function compile flags: /Odt
;	COMDAT ?push_back@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXABUAD_STRUCT@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T200500 = -8						; size = 4
$T200499 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXABUAD_STRUCT@@@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0000a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size
  00012	8b f0		 mov	 esi, eax
  00014	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?capacity@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::capacity
  0001c	3b f0		 cmp	 esi, eax
  0001e	73 1d		 jae	 SHORT $L199068

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	50		 push	 eax
  00024	6a 01		 push	 1
  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	52		 push	 edx
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU3@IABU3@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ufill
  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  0003b	eb 1f		 jmp	 SHORT $L199067
$L199068:

; 583  : 			insert(end(), _Val);

  0003d	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00040	52		 push	 edx
  00041	8d 45 fc	 lea	 eax, DWORD PTR $T200499[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?end@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::end
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	51		 push	 ecx
  00050	8d 55 f8	 lea	 edx, DWORD PTR $T200500[ebp]
  00053	52		 push	 edx
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?insert@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@V312@ABUAD_STRUCT@@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::insert
$L199067:

; 584  : 		}

  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?push_back@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXABUAD_STRUCT@@@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::push_back
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Tidy

; 745  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?clear@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEXXZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::clear
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
PUBLIC	??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00027	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 281  : 		}

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 364  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 365  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy

; 366  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
PUBLIC	??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin, COMDAT
; _this$ = ecx

; 376  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 377  : 		return (iterator(_Nextnode(_Myhead)));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00013	83 c4 04	 add	 esp, 4
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	52		 push	 edx
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 378  : 		}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end, COMDAT
; _this$ = ecx

; 386  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 387  : 		return (iterator(_Myhead));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 388  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 239  : 			{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 240  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*

; 241  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 255  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 257  : 			++*this;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++

; 258  : 			return (_Tmp);

  00019	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 259  : 			}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
; Function compile flags: /Odt
;	COMDAT ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 201  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 203  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
PUBLIC	??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L200527
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L200528
$L200527:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L200528:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?capacity@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::capacity
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::end
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXViterator@12@IABUAD_STRUCT@@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Insert_n
PUBLIC	??Giterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator-
; Function compile flags: /Odt
;	COMDAT ?insert@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@V312@ABUAD_STRUCT@@@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
_this$ = -16						; size = 4
$T200538 = -12						; size = 4
$T200535 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@V312@ABUAD_STRUCT@@@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size
  00011	85 c0		 test	 eax, eax
  00013	75 09		 jne	 SHORT $L200536
  00015	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0001c	eb 18		 jmp	 SHORT $L200537
$L200536:
  0001e	8d 45 f8	 lea	 eax, DWORD PTR $T200535[ebp]
  00021	50		 push	 eax
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?begin@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::begin
  0002a	50		 push	 eax
  0002b	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002e	e8 00 00 00 00	 call	 ??Giterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator-
  00033	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$L200537:
  00036	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00039	89 4d fc	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0003c	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0003f	52		 push	 edx
  00040	6a 01		 push	 1
  00042	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00045	50		 push	 eax
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXViterator@12@IABUAD_STRUCT@@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Insert_n

; 623  : 		return (begin() + _Off);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	52		 push	 edx
  00056	8d 45 f4	 lea	 eax, DWORD PTR $T200538[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?begin@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::begin
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBE?AV012@H@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator+
  00069	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE?AViterator@12@V312@ABUAD_STRUCT@@@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::insert
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IBEXXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Xlen
PUBLIC	?allocate@?$allocator@UAD_STRUCT@@@std@@QAEPAUAD_STRUCT@@I@Z ; std::allocator<AD_STRUCT>::allocate
PUBLIC	?max_size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::max_size
; Function compile flags: /Odt
;	COMDAT ?_Buy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L199144

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 49		 jmp	 SHORT $L199143
$L199144:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L199146

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IBEXXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Xlen

; 776  : 		else

  00044	eb 30		 jmp	 SHORT $L199145
$L199146:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@UAD_STRUCT@@@std@@QAEPAUAD_STRUCT@@I@Z ; std::allocator<AD_STRUCT>::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00067	6b d2 38	 imul	 edx, 56			; 00000038H
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L199145:

; 781  : 			}
; 782  : 		return (true);

  00076	b0 01		 mov	 al, 1
$L199143:

; 783  : 		}

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Buy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXPAUAD_STRUCT@@0@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Destroy
PUBLIC	?deallocate@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@I@Z ; std::allocator<AD_STRUCT>::deallocate
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 3c		 je	 SHORT $L199150

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXPAUAD_STRUCT@@0@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	8b c1		 mov	 eax, ecx
  00034	99		 cdq
  00035	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0003a	f7 f9		 idiv	 ecx
  0003c	50		 push	 eax
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@I@Z ; std::allocator<AD_STRUCT>::deallocate
$L199150:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?_Tidy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXXZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@@Z ; std::_Uninitialized_fill_n<AD_STRUCT *,unsigned int,AD_STRUCT,std::allocator<AD_STRUCT> >
; Function compile flags: /Odt
;	COMDAT ?_Ufill@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU3@IABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU3@IABU3@@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@@Z ; std::_Uninitialized_fill_n<AD_STRUCT *,unsigned int,AD_STRUCT,std::allocator<AD_STRUCT> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	6b c0 38	 imul	 eax, 56			; 00000038H
  00025	03 45 08	 add	 eax, DWORD PTR __Ptr$[ebp]

; 880  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU3@IABU3@@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$allocator@UAD_STRUCT@@@std@@QAE@ABV01@@Z	; std::allocator<AD_STRUCT>::allocator<AD_STRUCT>
; Function compile flags: /Odt
;	COMDAT ??0?$_Vector_val@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE@V?$allocator@UAD_STRUCT@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE@V?$allocator@UAD_STRUCT@@@1@@Z PROC NEAR ; std::_Vector_val<AD_STRUCT,std::allocator<AD_STRUCT> >::_Vector_val<AD_STRUCT,std::allocator<AD_STRUCT> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@UAD_STRUCT@@@std@@QAE@ABV01@@Z ; std::allocator<AD_STRUCT>::allocator<AD_STRUCT>

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAE@V?$allocator@UAD_STRUCT@@@1@@Z ENDP ; std::_Vector_val<AD_STRUCT,std::allocator<AD_STRUCT> >::_Vector_val<AD_STRUCT,std::allocator<AD_STRUCT> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UAD_STRUCT@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UAD_STRUCT@@@std@@QAE@XZ PROC NEAR	; std::allocator<AD_STRUCT>::allocator<AD_STRUCT>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@UAD_STRUCT@@@std@@QAE@XZ ENDP		; std::allocator<AD_STRUCT>::allocator<AD_STRUCT>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode, COMDAT

; 107  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 109  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
PUBLIC	?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200559 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T200561 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L200555
$T200560 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T200561
$T200557 DD	019930520H
	DD	02H
	DD	FLAT:$T200559
	DD	01H
	DD	FLAT:$T200560
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
_TEXT	SEGMENT
tv93 = -36						; size = 4
tv92 = -32						; size = 4
_this$ = -28						; size = 4
__Pnode$ = -24						; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode, COMDAT
; _this$ = ecx

; 898  : 		{	// allocate a head node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 14	 sub	 esp, 20			; 00000014H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00025	6a 01		 push	 1
  00027	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
  0002f	89 45 e8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 900  : 		int _Linkcnt = 0;

  00032	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Linkcnt$[ebp], 0

; 901  : 
; 902  : 		_TRY_BEGIN

  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

  00040	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00049	83 c4 04	 add	 esp, 4
  0004c	89 45 e0	 mov	 DWORD PTR tv92[ebp], eax
  0004f	8d 4d e8	 lea	 ecx, DWORD PTR __Pnode$[ebp]
  00052	51		 push	 ecx
  00053	8b 55 e0	 mov	 edx, DWORD PTR tv92[ebp]
  00056	52		 push	 edx
  00057	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 01	 add	 ecx, 1
  0005d	e8 00 00 00 00	 call	 ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct

; 904  : 		++_Linkcnt;

  00062	8b 45 ec	 mov	 eax, DWORD PTR __Linkcnt$[ebp]
  00065	83 c0 01	 add	 eax, 1
  00068	89 45 ec	 mov	 DWORD PTR __Linkcnt$[ebp], eax

; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

  0006b	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  00074	83 c4 04	 add	 esp, 4
  00077	89 45 dc	 mov	 DWORD PTR tv93[ebp], eax
  0007a	8d 55 e8	 lea	 edx, DWORD PTR __Pnode$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 dc	 mov	 eax, DWORD PTR tv93[ebp]
  00081	50		 push	 eax
  00082	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	83 c1 01	 add	 ecx, 1
  00088	e8 00 00 00 00	 call	 ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
  0008d	eb 35		 jmp	 SHORT $L200554
$L200555:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)

  0008f	83 7d ec 00	 cmp	 DWORD PTR __Linkcnt$[ebp], 0
  00093	7e 18		 jle	 SHORT $L199186

; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));

  00095	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  0009e	83 c4 04	 add	 esp, 4
  000a1	50		 push	 eax
  000a2	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	83 c1 01	 add	 ecx, 1
  000a8	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
$L199186:

; 909  : 		this->_Alnod.deallocate(_Pnode, 1);

  000ad	6a 01		 push	 1
  000af	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000b2	52		 push	 edx
  000b3	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 910  : 		_RERAISE;

  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200554:

; 911  : 		_CATCH_END

  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 912  : 		return (_Pnode);

  000cb	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$L200552:

; 913  : 		}

  000ce	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000d1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200557
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
PUBLIC	?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy, COMDAT
; _this$ = ecx

; 929  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 930  : 		clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 01	 add	 ecx, 1
  00025	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy

; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  00036	83 c4 04	 add	 esp, 4
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 01	 add	 ecx, 1
  00040	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy

; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

  00045	6a 01		 push	 1
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004d	52		 push	 edx
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 934  : 		_Myhead = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 935  : 		}

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
PUBLIC	??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
;	COMDAT ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 82   : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
  0001d	8d 4d 08	 lea	 ecx, DWORD PTR __Al$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 02	 add	 ecx, 2
  00027	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>

; 83   : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ PROC NEAR ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ENDP	; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator

; 236  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 249  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 250  : 			++(*(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++

; 251  : 			return (*this);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 252  : 			}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
; Function compile flags: /Odt
;	COMDAT ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 160  : 			{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 			return (_Myval(_Ptr));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
  00012	83 c4 04	 add	 esp, 4

; 162  : 			}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 196  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 			return (_Ptr == _Right._Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 198  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L199205

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 49		 jmp	 SHORT $L199204
$L199205:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L199207

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen

; 776  : 		else

  00044	eb 30		 jmp	 SHORT $L199206
$L199207:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00067	6b d2 1c	 imul	 edx, 28			; 0000001cH
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L199206:

; 781  : 			}
; 782  : 		return (true);

  00076	b0 01		 mov	 al, 1
$L199204:

; 783  : 		}

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 3c		 je	 SHORT $L199211

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	8b c1		 mov	 eax, ecx
  00034	99		 cdq
  00035	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0003a	f7 f9		 idiv	 ecx
  0003c	50		 push	 eax
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
$L199211:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC NEAR ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEABUAD_STRUCT@@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEAAUAD_STRUCT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEAAUAD_STRUCT@@XZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEABUAD_STRUCT@@XZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEAAUAD_STRUCT@@XZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAV012@H@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator+=
; Function compile flags: /Odt
;	COMDAT ??Hiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAV012@H@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator+
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UAD_STRUCT@@@std@@QBEIXZ	; std::allocator<AD_STRUCT>::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@UAD_STRUCT@@@std@@QBEIXZ ; std::allocator<AD_STRUCT>::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@@Z ; std::_Destroy_range<AD_STRUCT,std::allocator<AD_STRUCT> >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXPAUAD_STRUCT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXPAUAD_STRUCT@@0@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@@Z ; std::_Destroy_range<AD_STRUCT,std::allocator<AD_STRUCT> >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXPAUAD_STRUCT@@0@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAUAD_STRUCT@@@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU2@00@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ucopy<AD_STRUCT *>
PUBLIC	??$fill@PAUAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@0ABU1@@Z ; std::fill<AD_STRUCT *,AD_STRUCT>
PUBLIC	??$copy_backward@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00@Z ; std::copy_backward<AD_STRUCT *,AD_STRUCT *>
PUBLIC	??0AD_STRUCT@@QAE@ABU0@@Z			; AD_STRUCT::AD_STRUCT
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200613 DD	0ffffffffH
	DD	FLAT:$L200608
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T200615 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L200605
$T200616 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L200607
$T200614 DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T200615
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T200616
$T200610 DD	019930520H
	DD	05H
	DD	FLAT:$T200613
	DD	02H
	DD	FLAT:$T200614
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXViterator@12@IABUAD_STRUCT@@@Z
_TEXT	SEGMENT
tv244 = -108						; size = 4
tv65 = -104						; size = 4
tv89 = -100						; size = 4
_this$ = -96						; size = 4
__Oldend$199316 = -92					; size = 4
__Newvec$199295 = -88					; size = 4
__Ptr$199296 = -84					; size = 4
__Capacity$ = -80					; size = 4
__Tmp$ = -76						; size = 56
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXViterator@12@IABUAD_STRUCT@@@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXViterator@12@IABUAD_STRUCT@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00024	53		 push	 ebx
  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002a	89 4d a0	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0002d	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00030	50		 push	 eax
  00031	8d 4d b4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00034	e8 00 00 00 00	 call	 ??0AD_STRUCT@@QAE@ABU0@@Z
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 811  : 		size_type _Capacity = capacity();

  00040	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?capacity@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::capacity
  00048	89 45 b0	 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  0004b	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0004f	75 05		 jne	 SHORT $L199289

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00051	e9 cf 02 00 00	 jmp	 $L199290
$L199289:
  00056	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size
  0005e	8b f0		 mov	 esi, eax
  00060	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?max_size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::max_size
  00068	2b c6		 sub	 eax, esi
  0006a	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0006d	73 0d		 jae	 SHORT $L199291

; 816  : 			_Xlen();	// result too long

  0006f	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IBEXXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  00077	e9 a9 02 00 00	 jmp	 $L199290
$L199291:
  0007c	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	e8 00 00 00 00	 call	 ?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size
  00084	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00087	39 45 b0	 cmp	 DWORD PTR __Capacity$[ebp], eax
  0008a	0f 83 68 01 00
	00		 jae	 $L199293

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00090	8b 75 b0	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00093	d1 ee		 shr	 esi, 1
  00095	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?max_size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::max_size
  0009d	2b c6		 sub	 eax, esi
  0009f	3b 45 b0	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  000a2	73 09		 jae	 SHORT $L200602
  000a4	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  000ab	eb 0b		 jmp	 SHORT $L200603
$L200602:
  000ad	8b 4d b0	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  000b0	d1 e9		 shr	 ecx, 1
  000b2	03 4d b0	 add	 ecx, DWORD PTR __Capacity$[ebp]
  000b5	89 4d 9c	 mov	 DWORD PTR tv89[ebp], ecx
$L200603:
  000b8	8b 55 9c	 mov	 edx, DWORD PTR tv89[ebp]
  000bb	89 55 b0	 mov	 DWORD PTR __Capacity$[ebp], edx

; 821  : 			if (_Capacity < size() + _Count)

  000be	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size
  000c6	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000c9	39 45 b0	 cmp	 DWORD PTR __Capacity$[ebp], eax
  000cc	73 0e		 jae	 SHORT $L199294

; 822  : 				_Capacity = size() + _Count;

  000ce	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	e8 00 00 00 00	 call	 ?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size
  000d6	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000d9	89 45 b0	 mov	 DWORD PTR __Capacity$[ebp], eax
$L199294:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000dc	8b 45 b0	 mov	 eax, DWORD PTR __Capacity$[ebp]
  000df	50		 push	 eax
  000e0	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?allocate@?$allocator@UAD_STRUCT@@@std@@QAEPAUAD_STRUCT@@I@Z ; std::allocator<AD_STRUCT>::allocate
  000e8	89 45 a8	 mov	 DWORD PTR __Newvec$199295[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  000eb	8b 4d a8	 mov	 ecx, DWORD PTR __Newvec$199295[ebp]
  000ee	89 4d ac	 mov	 DWORD PTR __Ptr$199296[ebp], ecx

; 825  : 
; 826  : 			_TRY_BEGIN

  000f1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000f5	8b 55 a8	 mov	 edx, DWORD PTR __Newvec$199295[ebp]
  000f8	52		 push	 edx
  000f9	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00103	52		 push	 edx
  00104	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ??$_Ucopy@PAUAD_STRUCT@@@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU2@00@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ucopy<AD_STRUCT *>
  0010c	89 45 98	 mov	 DWORD PTR tv65[ebp], eax
  0010f	8b 45 98	 mov	 eax, DWORD PTR tv65[ebp]
  00112	89 45 ac	 mov	 DWORD PTR __Ptr$199296[ebp], eax

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00115	8d 4d b4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00118	51		 push	 ecx
  00119	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0011c	52		 push	 edx
  0011d	8b 45 ac	 mov	 eax, DWORD PTR __Ptr$199296[ebp]
  00120	50		 push	 eax
  00121	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU3@IABU3@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ufill
  00129	89 45 94	 mov	 DWORD PTR tv244[ebp], eax
  0012c	8b 4d 94	 mov	 ecx, DWORD PTR tv244[ebp]
  0012f	89 4d ac	 mov	 DWORD PTR __Ptr$199296[ebp], ecx

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00132	8b 55 ac	 mov	 edx, DWORD PTR __Ptr$199296[ebp]
  00135	52		 push	 edx
  00136	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  00139	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0013c	51		 push	 ecx
  0013d	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00140	52		 push	 edx
  00141	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	e8 00 00 00 00	 call	 ??$_Ucopy@PAUAD_STRUCT@@@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU2@00@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ucopy<AD_STRUCT *>
  00149	eb 29		 jmp	 SHORT $L200604
$L200605:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  0014b	8b 45 ac	 mov	 eax, DWORD PTR __Ptr$199296[ebp]
  0014e	50		 push	 eax
  0014f	8b 4d a8	 mov	 ecx, DWORD PTR __Newvec$199295[ebp]
  00152	51		 push	 ecx
  00153	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXPAUAD_STRUCT@@0@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  0015b	8b 55 b0	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0015e	52		 push	 edx
  0015f	8b 45 a8	 mov	 eax, DWORD PTR __Newvec$199295[ebp]
  00162	50		 push	 eax
  00163	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@I@Z ; std::allocator<AD_STRUCT>::deallocate

; 834  : 			_RERAISE;

  0016b	6a 00		 push	 0
  0016d	6a 00		 push	 0
  0016f	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200604:

; 835  : 			_CATCH_END

  00174	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 836  : 
; 837  : 			_Count += size();

  0017b	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	e8 00 00 00 00	 call	 ?size@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEIXZ ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::size
  00183	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00186	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  00189	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00190	74 3a		 je	 SHORT $L199303

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  00192	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  00195	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00198	50		 push	 eax
  00199	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0019c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0019f	52		 push	 edx
  001a0	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXPAUAD_STRUCT@@0@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  001a8	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  001ab	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ae	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001b1	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  001b4	99		 cdq
  001b5	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  001ba	f7 f9		 idiv	 ecx
  001bc	50		 push	 eax
  001bd	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  001c0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001c3	50		 push	 eax
  001c4	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@I@Z ; std::allocator<AD_STRUCT>::deallocate
$L199303:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001cc	8b 4d b0	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  001cf	6b c9 38	 imul	 ecx, 56			; 00000038H
  001d2	03 4d a8	 add	 ecx, DWORD PTR __Newvec$199295[ebp]
  001d5	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  001d8	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 844  : 			_Mylast = _Newvec + _Count;

  001db	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001de	6b c0 38	 imul	 eax, 56			; 00000038H
  001e1	03 45 a8	 add	 eax, DWORD PTR __Newvec$199295[ebp]
  001e4	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e7	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

  001ea	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  001ed	8b 45 a8	 mov	 eax, DWORD PTR __Newvec$199295[ebp]
  001f0	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001f3	e9 2d 01 00 00	 jmp	 $L199290
$L199293:
  001f8	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  001fb	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001fe	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  00201	99		 cdq
  00202	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00207	f7 f9		 idiv	 ecx
  00209	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0020c	0f 83 af 00 00
	00		 jae	 $L199306

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00212	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00215	6b d2 38	 imul	 edx, 56			; 00000038H
  00218	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  0021b	52		 push	 edx
  0021c	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  0021f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00222	51		 push	 ecx
  00223	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00226	52		 push	 edx
  00227	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0022a	e8 00 00 00 00	 call	 ??$_Ucopy@PAUAD_STRUCT@@@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU2@00@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ucopy<AD_STRUCT *>

; 851  : 
; 852  : 			_TRY_BEGIN

  0022f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  00233	8d 45 b4	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00236	50		 push	 eax
  00237	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0023a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0023d	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  00240	99		 cdq
  00241	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00246	f7 f9		 idiv	 ecx
  00248	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0024b	2b d0		 sub	 edx, eax
  0024d	52		 push	 edx
  0024e	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  00251	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00254	51		 push	 ecx
  00255	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00258	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU3@IABU3@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ufill
  0025d	eb 28		 jmp	 SHORT $L200606
$L200607:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  0025f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00262	6b d2 38	 imul	 edx, 56			; 00000038H
  00265	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  00268	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0026b	52		 push	 edx
  0026c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0026f	6b c9 38	 imul	 ecx, 56			; 00000038H
  00272	03 4d 08	 add	 ecx, DWORD PTR __Where$[ebp]
  00275	51		 push	 ecx
  00276	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00279	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXPAUAD_STRUCT@@0@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Destroy

; 857  : 			_RERAISE;

  0027e	6a 00		 push	 0
  00280	6a 00		 push	 0
  00282	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200606:

; 858  : 			_CATCH_END

  00287	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 859  : 
; 860  : 			_Mylast += _Count;

  0028e	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00291	6b d2 38	 imul	 edx, 56			; 00000038H
  00294	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  00297	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0029a	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0029d	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  002a0	8d 55 b4	 lea	 edx, DWORD PTR __Tmp$[ebp]
  002a3	52		 push	 edx
  002a4	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002a7	6b c0 38	 imul	 eax, 56			; 00000038H
  002aa	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  002ad	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002b0	2b d0		 sub	 edx, eax
  002b2	52		 push	 edx
  002b3	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  002b6	50		 push	 eax
  002b7	e8 00 00 00 00	 call	 ??$fill@PAUAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@0ABU1@@Z ; std::fill<AD_STRUCT *,AD_STRUCT>
  002bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002bf	eb 64		 jmp	 SHORT $L199290
$L199306:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  002c1	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  002c4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002c7	89 55 a4	 mov	 DWORD PTR __Oldend$199316[ebp], edx

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002ca	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  002cd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002d0	51		 push	 ecx
  002d1	8b 55 a4	 mov	 edx, DWORD PTR __Oldend$199316[ebp]
  002d4	52		 push	 edx
  002d5	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002d8	6b c0 38	 imul	 eax, 56			; 00000038H
  002db	8b 4d a4	 mov	 ecx, DWORD PTR __Oldend$199316[ebp]
  002de	2b c8		 sub	 ecx, eax
  002e0	51		 push	 ecx
  002e1	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  002e4	e8 00 00 00 00	 call	 ??$_Ucopy@PAUAD_STRUCT@@@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU2@00@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ucopy<AD_STRUCT *>
  002e9	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  002ec	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  002ef	8b 45 a4	 mov	 eax, DWORD PTR __Oldend$199316[ebp]
  002f2	50		 push	 eax
  002f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002f6	6b c9 38	 imul	 ecx, 56			; 00000038H
  002f9	8b 55 a4	 mov	 edx, DWORD PTR __Oldend$199316[ebp]
  002fc	2b d1		 sub	 edx, ecx
  002fe	52		 push	 edx
  002ff	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00302	50		 push	 eax
  00303	e8 00 00 00 00	 call	 ??$copy_backward@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00@Z ; std::copy_backward<AD_STRUCT *,AD_STRUCT *>
  00308	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  0030b	8d 4d b4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0030e	51		 push	 ecx
  0030f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00312	6b d2 38	 imul	 edx, 56			; 00000038H
  00315	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  00318	52		 push	 edx
  00319	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0031c	50		 push	 eax
  0031d	e8 00 00 00 00	 call	 ??$fill@PAUAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@0ABU1@@Z ; std::fill<AD_STRUCT *,AD_STRUCT>
  00322	83 c4 0c	 add	 esp, 12			; 0000000cH
$L199290:

; 873  : 			}
; 874  : 		}

  00325	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0032c	8d 4d b4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0032f	e8 00 00 00 00	 call	 ??1AD_STRUCT@@QAE@XZ
$L200601:
  00334	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00337	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0033e	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00341	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00346	5f		 pop	 edi
  00347	5e		 pop	 esi
  00348	5b		 pop	 ebx
  00349	8b e5		 mov	 esp, ebp
  0034b	5d		 pop	 ebp
  0034c	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200608:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1AD_STRUCT@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXViterator@12@IABUAD_STRUCT@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200610
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEXViterator@12@IABUAD_STRUCT@@@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Insert_n
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200627 DD	0ffffffffH
	DD	FLAT:$L200623
$T200625 DD	019930520H
	DD	01H
	DD	FLAT:$T200627
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
	ORG $-30
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T200622 = -80						; size = 28
$T200621 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T200622[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T200622[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T200621[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T200621[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200620:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200623:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T200622[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200625
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IBEXXZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@UAD_STRUCT@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UAD_STRUCT@@@std@@QAE@ABV01@@Z PROC NEAR	; std::allocator<AD_STRUCT>::allocator<AD_STRUCT>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@UAD_STRUCT@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<AD_STRUCT>::allocator<AD_STRUCT>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@I@Z PROC NEAR ; std::allocator<AD_STRUCT>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@I@Z ENDP ; std::allocator<AD_STRUCT>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UAD_STRUCT@@@std@@YAPAUAD_STRUCT@@IPAU1@@Z ; std::_Allocate<AD_STRUCT>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@UAD_STRUCT@@@std@@QAEPAUAD_STRUCT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UAD_STRUCT@@@std@@QAEPAUAD_STRUCT@@I@Z PROC NEAR ; std::allocator<AD_STRUCT>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@UAD_STRUCT@@@std@@YAPAUAD_STRUCT@@IPAU1@@Z ; std::_Allocate<AD_STRUCT>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@UAD_STRUCT@@@std@@QAEPAUAD_STRUCT@@I@Z ENDP ; std::allocator<AD_STRUCT>::allocate
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode, COMDAT

; 112  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 114  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval, COMDAT

; 117  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 119  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy
; Function compile flags: /Odt
;	COMDAT ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnext$ = -8						; size = 4
__Pnode$ = -4						; size = 4
?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear, COMDAT
; _this$ = ecx

; 610  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00015	83 c4 04	 add	 esp, 4
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	89 55 fc	 mov	 DWORD PTR __Pnode$[ebp], edx

; 613  : 		_Nextnode(_Myhead) = _Myhead;

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00029	83 c4 04	 add	 esp, 4
  0002c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00032	89 08		 mov	 DWORD PTR [eax], ecx

; 614  : 		_Prevnode(_Myhead) = _Myhead;

  00034	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  00040	83 c4 04	 add	 esp, 4
  00043	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	89 10		 mov	 DWORD PTR [eax], edx

; 615  : 		_Mysize = 0;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

  00055	eb 06		 jmp	 SHORT $L199353
$L199354:
  00057	8b 4d f8	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  0005a	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx
$L199353:
  0005d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00063	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00066	74 2d		 je	 SHORT $L199350

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

  00068	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00071	83 c4 04	 add	 esp, 4
  00074	8b 10		 mov	 edx, DWORD PTR [eax]
  00076	89 55 f8	 mov	 DWORD PTR __Pnext$[ebp], edx

; 620  : 			this->_Alnod.destroy(_Pnode);

  00079	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy

; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

  00085	6a 01		 push	 1
  00087	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 622  : 			}

  00093	eb c2		 jmp	 SHORT $L199354
$L199350:

; 623  : 		}

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear
_TEXT	ENDS
PUBLIC	??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>
; Function compile flags: /Odt
;	COMDAT ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = 8						; size = 1
??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 64   : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
  0001d	8d 4d 08	 lea	 ecx, DWORD PTR __Al$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 01	 add	 ecx, 1
  00027	e8 00 00 00 00	 call	 ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>

; 65   : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 157  : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 170  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 			_Ptr = _Nextnode(_Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00012	83 c4 04	 add	 esp, 4
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 02		 mov	 DWORD PTR [edx], eax

; 172  : 			return (*this);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 173  : 			}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200671 DD	0ffffffffH
	DD	FLAT:$L200667
$T200669 DD	019930520H
	DD	01H
	DD	FLAT:$T200671
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T200666 = -80						; size = 28
$T200665 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T200666[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T200666[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T200665[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T200665[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200664:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200667:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T200666[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200669
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	??0const_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::const_iterator
; Function compile flags: /Odt
;	COMDAT ??0iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	6b c0 38	 imul	 eax, 56			; 00000038H
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 01		 add	 eax, DWORD PTR [ecx]
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	89 02		 mov	 DWORD PTR [edx], eax

; 257  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??Yiterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABV012@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::operator-
; Function compile flags: /Odt
;	COMDAT ??Giterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T200680 = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR $T200680[ebp], ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR $T200680[ebp]
  00018	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABV012@@Z ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::operator-

; 280  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Giterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::iterator::operator-
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEABUAD_STRUCT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEABUAD_STRUCT@@XZ PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEABUAD_STRUCT@@XZ ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::operator*
_TEXT	ENDS
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200690 DD	0ffffffffH
	DD	FLAT:$L200685
$T200688 DD	019930520H
	DD	01H
	DD	FLAT:$T200690
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0AD_STRUCT@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0AD_STRUCT@@QAE@ABU0@@Z PROC NEAR			; AD_STRUCT::AD_STRUCT, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0AD_STRUCT@@QAE@ABU0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00033	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00036	51		 push	 ecx
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00043	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200685:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0AD_STRUCT@@QAE@ABU0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200688
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0AD_STRUCT@@QAE@ABU0@@Z ENDP				; AD_STRUCT::AD_STRUCT
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc 49 92
	24 09		 mov	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L200698
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L200699
$L200698:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L200699:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UAD_STRUCT@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UAD_STRUCT@@@std@@QBEIXZ PROC NEAR ; std::allocator<AD_STRUCT>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc 24 49
	92 04		 mov	 DWORD PTR __Count$[ebp], 76695844 ; 04924924H

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L200702
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L200703
$L200702:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L200703:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@UAD_STRUCT@@@std@@QBEIXZ ENDP	; std::allocator<AD_STRUCT>::max_size
_TEXT	ENDS
PUBLIC	??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 44   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>

; 45   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QAE@PAUAD_STRUCT@@@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	99		 cdq
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	f7 f9		 idiv	 ecx

; 144  : 			}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUAD_STRUCT@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAD_STRUCT@@0@Z ; std::_Ptr_cat<AD_STRUCT *,AD_STRUCT *>
PUBLIC	??$_Uninit_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<AD_STRUCT *,unsigned int,AD_STRUCT,std::allocator<AD_STRUCT> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@@Z
_TEXT	SEGMENT
$T200714 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<AD_STRUCT *,unsigned int,AD_STRUCT,std::allocator<AD_STRUCT> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00004	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUAD_STRUCT@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAD_STRUCT@@0@Z ; std::_Ptr_cat<AD_STRUCT *,AD_STRUCT *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T200714[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T200714[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<AD_STRUCT *,unsigned int,AD_STRUCT,std::allocator<AD_STRUCT> >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@@Z ENDP ; std::_Uninitialized_fill_n<AD_STRUCT *,unsigned int,AD_STRUCT,std::allocator<AD_STRUCT> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z PROC NEAR ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<AD_STRUCT,std::allocator<AD_STRUCT> >
; Function compile flags: /Odt
;	COMDAT ??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@@Z
_TEXT	SEGMENT
$T200719 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@@Z PROC NEAR ; std::_Destroy_range<AD_STRUCT,std::allocator<AD_STRUCT> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUAD_STRUCT@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAD_STRUCT@@0@Z ; std::_Ptr_cat<AD_STRUCT *,AD_STRUCT *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T200719[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T200719[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<AD_STRUCT,std::allocator<AD_STRUCT> >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@@Z ENDP ; std::_Destroy_range<AD_STRUCT,std::allocator<AD_STRUCT> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@@Z ; std::_Uninitialized_copy<AD_STRUCT *,AD_STRUCT *,std::allocator<AD_STRUCT> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAUAD_STRUCT@@@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUAD_STRUCT@@@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU2@00@Z PROC NEAR ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ucopy<AD_STRUCT *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@@Z ; std::_Uninitialized_copy<AD_STRUCT *,AD_STRUCT *,std::allocator<AD_STRUCT> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAUAD_STRUCT@@@?$vector@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@IAEPAUAD_STRUCT@@PAU2@00@Z ENDP ; std::vector<AD_STRUCT,std::allocator<AD_STRUCT> >::_Ucopy<AD_STRUCT *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAUAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@0ABU1@@Z PROC NEAR ; std::fill<AD_STRUCT *,AD_STRUCT>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1135 : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L199601
$L199602:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 38	 add	 eax, 56			; 00000038H
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L199601:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L199600

; 1136 : 		*_First = _Val;

  00016	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001d	e8 00 00 00 00	 call	 ??4AD_STRUCT@@QAEAAU0@ABU0@@Z
  00022	eb e1		 jmp	 SHORT $L199602
$L199600:

; 1137 : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$fill@PAUAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@0ABU1@@Z ENDP ; std::fill<AD_STRUCT *,AD_STRUCT>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<AD_STRUCT *,AD_STRUCT *>
; Function compile flags: /Odt
;	COMDAT ??$copy_backward@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00@Z
_TEXT	SEGMENT
$T200726 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00@Z PROC NEAR ; std::copy_backward<AD_STRUCT *,AD_STRUCT *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUAD_STRUCT@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAD_STRUCT@@0@Z ; std::_Ptr_cat<AD_STRUCT *,AD_STRUCT *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T200726[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T200726[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<AD_STRUCT *,AD_STRUCT *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy_backward@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00@Z ENDP ; std::copy_backward<AD_STRUCT *,AD_STRUCT *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@UAD_STRUCT@@@std@@YAPAUAD_STRUCT@@IPAU1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UAD_STRUCT@@@std@@YAPAUAD_STRUCT@@IPAU1@@Z PROC NEAR ; std::_Allocate<AD_STRUCT>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 38	 imul	 eax, 56			; 00000038H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@UAD_STRUCT@@@std@@YAPAUAD_STRUCT@@IPAU1@@Z ENDP ; std::_Allocate<AD_STRUCT>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Odt
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
$T200735 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	50		 push	 eax
  0000a	6a 04		 push	 4
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00011	83 c4 08	 add	 esp, 8
  00014	89 45 fc	 mov	 DWORD PTR $T200735[ebp], eax
  00017	83 7d fc 00	 cmp	 DWORD PTR $T200735[ebp], 0
  0001b	74 12		 je	 SHORT $L200736
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T200735[ebp]
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	89 01		 mov	 DWORD PTR [ecx], eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR $T200735[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0002d	eb 07		 jmp	 SHORT $L199630
$L200736:
  0002f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L199630:

; 43   : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
$T200744 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T200744[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T200744[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUAD_STRUCT@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAD_STRUCT@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUAD_STRUCT@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAD_STRUCT@@0@Z PROC NEAR ; std::_Ptr_cat<AD_STRUCT *,AD_STRUCT *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAUAD_STRUCT@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAD_STRUCT@@0@Z ENDP ; std::_Ptr_cat<AD_STRUCT *,AD_STRUCT *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@ABU3@@Z ; std::allocator<AD_STRUCT>::construct
PUBLIC	?destroy@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@@Z ; std::allocator<AD_STRUCT>::destroy
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T200758 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T200760 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L200754
$T200759 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T200760
$T200756 DD	019930520H
	DD	02H
	DD	FLAT:$T200758
	DD	01H
	DD	FLAT:$T200759
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<AD_STRUCT *,unsigned int,AD_STRUCT,std::allocator<AD_STRUCT> >, COMDAT

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 208  : 	_FwdIt _Next = _First;

  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 209  : 
; 210  : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  0002d	eb 12		 jmp	 SHORT $L199667
$L199668:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00032	83 e9 01	 sub	 ecx, 1
  00035	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 38	 add	 edx, 56			; 00000038H
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L199667:
  00041	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00045	76 12		 jbe	 SHORT $L199669

; 212  : 		_Al.construct(_First, _Val);

  00047	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00052	e8 00 00 00 00	 call	 ?construct@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@ABU3@@Z ; std::allocator<AD_STRUCT>::construct
  00057	eb d6		 jmp	 SHORT $L199668
$L199669:
  00059	eb 2a		 jmp	 SHORT $L200753
$L200754:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

  0005b	eb 09		 jmp	 SHORT $L199670
$L199671:
  0005d	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00060	83 c2 38	 add	 edx, 56			; 00000038H
  00063	89 55 ec	 mov	 DWORD PTR __Next$[ebp], edx
$L199670:
  00066	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00069	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  0006c	74 0e		 je	 SHORT $L199672

; 215  : 		_Al.destroy(_Next);

  0006e	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00071	51		 push	 ecx
  00072	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00075	e8 00 00 00 00	 call	 ?destroy@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@@Z ; std::allocator<AD_STRUCT>::destroy
  0007a	eb e1		 jmp	 SHORT $L199671
$L199672:

; 216  : 	_RERAISE;

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200753:

; 217  : 	_CATCH_END

  00085	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$L200752:

; 218  : 	}

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200756
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAUAD_STRUCT@@IU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@IABU1@AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<AD_STRUCT *,unsigned int,AD_STRUCT,std::allocator<AD_STRUCT> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<AD_STRUCT,std::allocator<AD_STRUCT> >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L199674
$L199675:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 38	 add	 eax, 56			; 00000038H
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L199674:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L199673

; 226  : 		_Al.destroy(_First);

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001d	e8 00 00 00 00	 call	 ?destroy@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@@Z ; std::allocator<AD_STRUCT>::destroy
  00022	eb e1		 jmp	 SHORT $L199675
$L199673:

; 227  : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Destroy_range@UAD_STRUCT@@V?$allocator@UAD_STRUCT@@@std@@@std@@YAXPAUAD_STRUCT@@0AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<AD_STRUCT,std::allocator<AD_STRUCT> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<AD_STRUCT *,AD_STRUCT *,std::allocator<AD_STRUCT> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@@Z
_TEXT	SEGMENT
$T200767 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<AD_STRUCT *,AD_STRUCT *,std::allocator<AD_STRUCT> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUAD_STRUCT@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAD_STRUCT@@0@Z ; std::_Ptr_cat<AD_STRUCT *,AD_STRUCT *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T200767[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T200767[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<AD_STRUCT *,AD_STRUCT *,std::allocator<AD_STRUCT> >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@@Z ENDP ; std::_Uninitialized_copy<AD_STRUCT *,AD_STRUCT *,std::allocator<AD_STRUCT> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<AD_STRUCT *,AD_STRUCT *>, COMDAT

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L199719:

; 1049 : 	while (_First != _Last)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00009	74 20		 je	 SHORT $L199720

; 1050 : 		*--_Dest = *--_Last;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	83 e9 38	 sub	 ecx, 56			; 00000038H
  00011	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  00014	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00017	83 ea 38	 sub	 edx, 56			; 00000038H
  0001a	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0001d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00024	e8 00 00 00 00	 call	 ??4AD_STRUCT@@QAEAAU0@ABU0@@Z
  00029	eb d8		 jmp	 SHORT $L199719
$L199720:

; 1051 : 	return (_Dest);

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1052 : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Copy_backward_opt@PAUAD_STRUCT@@PAU1@@std@@YAPAUAD_STRUCT@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<AD_STRUCT *,AD_STRUCT *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC NEAR ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L199724
$L199725:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L199724:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L199723

; 226  : 		_Al.destroy(_First);

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001d	e8 00 00 00 00	 call	 ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
  00022	eb e1		 jmp	 SHORT $L199725
$L199723:

; 227  : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@UAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@ABU1@@Z ; std::_Construct<AD_STRUCT,AD_STRUCT>
; Function compile flags: /Odt
;	COMDAT ?construct@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@ABU3@@Z PROC NEAR ; std::allocator<AD_STRUCT>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@UAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@ABU1@@Z ; std::_Construct<AD_STRUCT,AD_STRUCT>
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@ABU3@@Z ENDP ; std::allocator<AD_STRUCT>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UAD_STRUCT@@@std@@YAXPAUAD_STRUCT@@@Z ; std::_Destroy<AD_STRUCT>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@@Z PROC NEAR ; std::allocator<AD_STRUCT>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@UAD_STRUCT@@@std@@YAXPAUAD_STRUCT@@@Z ; std::_Destroy<AD_STRUCT>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@@Z ENDP ; std::allocator<AD_STRUCT>::destroy
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T200787 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T200789 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L200783
$T200788 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T200789
$T200785 DD	019930520H
	DD	02H
	DD	FLAT:$T200787
	DD	01H
	DD	FLAT:$T200788
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<AD_STRUCT *,AD_STRUCT *,std::allocator<AD_STRUCT> >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 78   : 	_FwdIt _Next = _Dest;

  00020	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 79   : 
; 80   : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  0002d	eb 12		 jmp	 SHORT $L199750
$L199751:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	83 c1 38	 add	 ecx, 56			; 00000038H
  00035	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 38	 add	 edx, 56			; 00000038H
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L199750:
  00041	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00044	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00047	74 12		 je	 SHORT $L199752

; 82   : 		_Al.construct(_Dest, *_First);

  00049	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00050	52		 push	 edx
  00051	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00054	e8 00 00 00 00	 call	 ?construct@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@ABU3@@Z ; std::allocator<AD_STRUCT>::construct
  00059	eb d4		 jmp	 SHORT $L199751
$L199752:
  0005b	eb 2a		 jmp	 SHORT $L200782
$L200783:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  0005d	eb 09		 jmp	 SHORT $L199753
$L199754:
  0005f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00062	83 c0 38	 add	 eax, 56			; 00000038H
  00065	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$L199753:
  00068	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  0006b	3b 4d 10	 cmp	 ecx, DWORD PTR __Dest$[ebp]
  0006e	74 0e		 je	 SHORT $L199755

; 85   : 		_Al.destroy(_Next);

  00070	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00073	52		 push	 edx
  00074	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00077	e8 00 00 00 00	 call	 ?destroy@?$allocator@UAD_STRUCT@@@std@@QAEXPAUAD_STRUCT@@@Z ; std::allocator<AD_STRUCT>::destroy
  0007c	eb e1		 jmp	 SHORT $L199754
$L199755:

; 86   : 	_RERAISE;

  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200782:

; 87   : 	_CATCH_END

  00087	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 88   : 	return (_Dest);

  0008e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$L200781:

; 89   : 	}

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200785
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAUAD_STRUCT@@PAU1@V?$allocator@UAD_STRUCT@@@std@@@std@@YAPAUAD_STRUCT@@PAU1@00AAV?$allocator@UAD_STRUCT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<AD_STRUCT *,AD_STRUCT *,std::allocator<AD_STRUCT> >
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00003	6a 00		 push	 0
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z

; 50   : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200804 DD	0ffffffffH
	DD	FLAT:$L200800
$T200802 DD	019930520H
	DD	01H
	DD	FLAT:$T200804
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Construct@UAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -24						; size = 4
$T200797 = -20						; size = 4
$T200796 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@ABU1@@Z PROC NEAR ; std::_Construct<AD_STRUCT,AD_STRUCT>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001e	50		 push	 eax
  0001f	6a 38		 push	 56			; 00000038H
  00021	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00026	83 c4 08	 add	 esp, 8
  00029	89 45 ec	 mov	 DWORD PTR $T200797[ebp], eax
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	83 7d ec 00	 cmp	 DWORD PTR $T200797[ebp], 0
  00037	74 11		 je	 SHORT $L200798
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR $T200797[ebp]
  00040	e8 00 00 00 00	 call	 ??0AD_STRUCT@@QAE@ABU0@@Z
  00045	89 45 e8	 mov	 DWORD PTR tv74[ebp], eax
  00048	eb 07		 jmp	 SHORT $L200799
$L200798:
  0004a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L200799:
  00051	8b 55 e8	 mov	 edx, DWORD PTR tv74[ebp]
  00054	89 55 f0	 mov	 DWORD PTR $T200796[ebp], edx
  00057	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 43   : 	}

  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00061	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200800:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ec	 mov	 ecx, DWORD PTR $T200797[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@ABU1@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200802
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Construct@UAD_STRUCT@@U1@@std@@YAXPAUAD_STRUCT@@ABU1@@Z ENDP ; std::_Construct<AD_STRUCT,AD_STRUCT>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_GAD_STRUCT@@QAEPAXI@Z			; AD_STRUCT::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@UAD_STRUCT@@@std@@YAXPAUAD_STRUCT@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UAD_STRUCT@@@std@@YAXPAUAD_STRUCT@@@Z PROC NEAR ; std::_Destroy<AD_STRUCT>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00003	6a 00		 push	 0
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??_GAD_STRUCT@@QAEPAXI@Z

; 50   : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy@UAD_STRUCT@@@std@@YAXPAUAD_STRUCT@@@Z ENDP	; std::_Destroy<AD_STRUCT>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00010	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	74 0c		 je	 SHORT $L199769
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00021	83 c4 04	 add	 esp, 4
$L199769:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GAD_STRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAD_STRUCT@@QAEPAXI@Z PROC NEAR			; AD_STRUCT::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1AD_STRUCT@@QAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L199772
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L199772:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GAD_STRUCT@@QAEPAXI@Z ENDP				; AD_STRUCT::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCDownAD@@UAEPAXI@Z				; CDownAD::`scalar deleting destructor'
EXTRN	??_ECDownAD@@UAEPAXI@Z:NEAR			; CDownAD::`vector deleting destructor'
; Function compile flags: /Odt
;	COMDAT ??_ECDownAD@@W7AEPAXI@Z
_TEXT	SEGMENT
??_ECDownAD@@W7AEPAXI@Z PROC NEAR			; [thunk]:CDownAD::`vector deleting destructor', COMDAT
  00000	83 e9 08	 sub	 ecx, 8
  00003	e9 00 00 00 00	 jmp	 ??_ECDownAD@@UAEPAXI@Z
??_ECDownAD@@W7AEPAXI@Z ENDP				; [thunk]:CDownAD::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_DCDownAD@@QAEXXZ				; CDownAD::`vbase destructor'
; Function compile flags: /Odt
;	COMDAT ??_GCDownAD@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCDownAD@@UAEPAXI@Z PROC NEAR			; CDownAD::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??_DCDownAD@@QAEXXZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L198003
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L198003:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCDownAD@@UAEPAXI@Z ENDP				; CDownAD::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_DCDownAD@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??_DCDownAD@@QAEXXZ PROC NEAR				; CDownAD::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDownAD@@UAE@XZ	; CDownAD::~CDownAD
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 28	 add	 ecx, 40			; 00000028H
  00015	e8 00 00 00 00	 call	 ??1IMessageObserver@@UAE@XZ ; IMessageObserver::~IMessageObserver
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??_DCDownAD@@QAEXXZ ENDP				; CDownAD::`vbase destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_ECDownAD@@WCI@AEPAXI@Z
_TEXT	SEGMENT
??_ECDownAD@@WCI@AEPAXI@Z PROC NEAR			; [thunk]:CDownAD::`vector deleting destructor', COMDAT
  00000	83 e9 28	 sub	 ecx, 40			; 00000028H
  00003	e9 00 00 00 00	 jmp	 ??_ECDownAD@@UAEPAXI@Z
??_ECDownAD@@WCI@AEPAXI@Z ENDP				; [thunk]:CDownAD::`vector deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 28   : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200835 DD	0ffffffffH
	DD	FLAT:$L200830
$T200833 DD	019930520H
	DD	01H
	DD	FLAT:$T200835
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 20   : 		}

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200830:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200833
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102266
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102266:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200847 DD	0ffffffffH
	DD	FLAT:$L200842
$T200845 DD	019930520H
	DD	01H
	DD	FLAT:$T200847
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200842:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200845
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102332
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102332:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\core\imessageobserver.h
_TEXT	ENDS
;	COMDAT ??1IMessageObserver@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1IMessageObserver@@UAE@XZ PROC NEAR			; IMessageObserver::~IMessageObserver, COMDAT
; _this$ = ecx

; 16   : 	virtual ~IMessageObserver(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IMessageObserver@@6B@
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1IMessageObserver@@UAE@XZ ENDP			; IMessageObserver::~IMessageObserver
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GIMessageObserver@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIMessageObserver@@UAEPAXI@Z PROC NEAR		; IMessageObserver::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1IMessageObserver@@UAE@XZ ; IMessageObserver::~IMessageObserver
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L109524
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L109524:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GIMessageObserver@@UAEPAXI@Z ENDP			; IMessageObserver::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200866 DD	0ffffffffH
	DD	FLAT:$L200861
$T200864 DD	019930520H
	DD	01H
	DD	FLAT:$T200866
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0003f	52		 push	 edx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200861:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200864
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T200879 DD	0ffffffffH
	DD	FLAT:$L200873
	DD	00H
	DD	FLAT:$L200872
$T200877 DD	019930520H
	DD	02H
	DD	FLAT:$T200879
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T200874 = -44						; size = 4
$T200871 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T200874[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T200871[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T200874[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T200874[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T200871[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200872:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T200871[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200873:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T200874[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L200875
  00015	83 65 d4 fe	 and	 DWORD PTR $T200874[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200875:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200877
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
END
