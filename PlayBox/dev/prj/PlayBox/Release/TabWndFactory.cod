; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\module\TabMan\TabWndFactory.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0P@CLMBAKJD@JSCall?5Error?3?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??1HTTPObserver@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HTTPOb_DownStart@HTTPObserver@@UAEXPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HTTPOb_DownFinish@HTTPObserver@@UAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HTTPOb_DownFailed@HTTPObserver@@UAEXPBDW4HTTP_DOWN_FAILED_REASON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HTTPOb_DownProgress@HTTPObserver@@UAEXPBDII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HTTPOb_DownloadPause@HTTPObserver@@UAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GHTTPObserver@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClsid@CShockwaveFlash@@QAEABU_GUID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCustomControlSite@@QAE@PAVCOleControlContainer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCustomControlSite@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XDocHostShowUI@CCustomControlSite@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XDocHostUIHandler@CCustomControlSite@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCustomControlSite@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDocHostShowUI@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDocHostUIHandler@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateSite@CCustomOccManager@@UAEPAVCOleControlSite@@PAVCOleControlContainer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCustomOccManager@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0COccManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1COccManager@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCustomOccManager@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCOccManager@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNoTrackObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CSyncObject@@UAEHJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CCriticalSection@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCriticalSection@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCriticalSection@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CCriticalSection@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CCriticalSection@@UAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CCriticalSection@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_tagLMCItemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1BCMenuMemDC@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GBCMenuMemDC@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGdiPlusBitmap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@CGdiPlusBitmap@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CGdiPlusBitmap@@QAE_NPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCGdiPlusBitmap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GTabWndFactory@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIHTMLDocument2@@@ATL@@QBEPAUIHTMLDocument2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXPAPAVCWnd@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE@V?$allocator@PAVCWnd@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVCWnd@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEABQAVCWnd@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVCWnd@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVCWnd@@@std@@QAEXPAPAVCWnd@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVCWnd@@@std@@QAEPAPAVCWnd@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVCWnd@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CArray@HAAH@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CArray@HAAH@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCWnd@@@std@@YAPAPAVCWnd@@IPAPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CArray@HAAH@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSize@?$CArray@HAAH@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$SerializeElements@H@@YGXAAVCArchive@@PAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@VCWnd@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCWnd@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3XDocHostShowUI@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CCustomOccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IDocHostShowUI@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IDocHostUIHandler@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3BCMenuMemDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CGdiPlusBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@HAAH@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3COccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3HTTPObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3XDocHostUIHandler@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2XDocHostShowUI@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CCustomOccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IDocHostShowUI@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IDocHostUIHandler@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2BCMenuMemDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CGdiPlusBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@HAAH@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2COccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2HTTPObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2XDocHostUIHandler@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSyncObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@XDocHostShowUI@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCmdTarget@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@COleControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCustomOccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IDocHostShowUI@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCDC@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@BCMenuMemDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiPlusBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$CArray@HAAH@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CNoTrackObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCNoTrackObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@COccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@HTTPObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IUnknown@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknown@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@IDocHostUIHandler@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@XDocHostUIHandler@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCSyncObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCCriticalSection@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVXDocHostShowUI@CCustomControlSite@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCOleControlSite@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCCustomControlSite@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCCustomOccManager@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AUIDocHostShowUI@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVBCMenuMemDC@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCGdiPlusBitmap@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$CArray@HAAH@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCOccManager@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVHTTPObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AUIDocHostUIHandler@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVXDocHostUIHandler@CCustomControlSite@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CCriticalSection@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4XDocHostShowUI@CCustomControlSite@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CCustomControlSite@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CCustomOccManager@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IDocHostShowUI@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IDocHostUIHandler@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?Escape@CDC@@UAEHHHPBDPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrayStringA@CDC@@UAEHPAVCBrush@@P6GHPAUHDC__@@JH@ZJHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHandle@CGdiObject@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawTextExA@CDC@@UAEHPADHPAUtagRECT@@IPAUtagDRAWTEXTPARAMS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawTextA@CDC@@UAEHPBDHPAUtagRECT@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TabbedTextOutA@CDC@@UAE?AVCSize@@HHPBDHHPAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtTextOutA@CDC@@UAEHHHIPBUtagRECT@@PBDIPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TextOutA@CDC@@UAEHHHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RectVisible@CDC@@UBEHPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PtVisible@CDC@@UBEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4BCMenuMemDC@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CGdiPlusBitmap@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$CArray@HAAH@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4COccManager@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4HTTPObserver@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4XDocHostUIHandler@CCustomControlSite@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CArchive@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CArray@HAAH@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0?AVMyWebBrowserWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVWebGamePanelWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVGamePanelWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0?AVCWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVPlayedGameWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetLastStatus@Image@Gdiplus@@QBE?AW4Status@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FromFile@Bitmap@Gdiplus@@SAPAV12@PB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2GdiplusBase@Gdiplus@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3GdiplusBase@Gdiplus@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@Gdiplus@@QAE@PB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Image@Gdiplus@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7Image@Gdiplus@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4Image@Gdiplus@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVImage@Gdiplus@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3Image@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2Image@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@Image@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R13?0A@A@GdiplusBase@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVGdiplusBase@Gdiplus@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GImage@Gdiplus@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@Image@Gdiplus@@UAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatus@Image@Gdiplus@@IBE?AW4Status@2@W432@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Image@Gdiplus@@IAE@PAVGpImage@1@W4Status@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Image@Gdiplus@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7Bitmap@Gdiplus@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4Bitmap@Gdiplus@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVBitmap@Gdiplus@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3Bitmap@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2Bitmap@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@Bitmap@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GBitmap@Gdiplus@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Bitmap@Gdiplus@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNativeImage@Image@Gdiplus@@IAEXPAVGpImage@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CGdiPlusBitmap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCompatibleBitmap@CBitmap@@QAEHPAVCDC@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPrinting@CDC@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyRect@CRect@@QAEXPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBitmap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBitmap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CBitmap@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCBitmap@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GCBitmap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBitmap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7BCMenuMemDC@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CCriticalSection@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7COccManager@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CNoTrackObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CObject@@SGPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CCustomOccManager@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XDocHostUIHandler@CCustomControlSite@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7XDocHostShowUI@CCustomControlSite@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CCustomControlSite@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?clsid@?1??GetClsid@CShockwaveFlash@@QAEABU_GUID@@XZ@4U3@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7HTTPObserver@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	?m_pSelf@TabWndFactory@@2PAV1@A			; TabWndFactory::m_pSelf
_BSS	SEGMENT
?m_pSelf@TabWndFactory@@2PAV1@A DD 01H DUP (?)		; TabWndFactory::m_pSelf
_BSS	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -160						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

  00011	c7 85 60 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _ver$[ebp], 148 ; 00000094H

; 139  : 	::GetVersionEx( &ver );

  0001b	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _ver$[ebp]
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00028	83 bd 70 ff ff
	ff 02		 cmp	 DWORD PTR _ver$[ebp+16], 2
  0002f	75 15		 jne	 SHORT $L24173
  00031	83 bd 64 ff ff
	ff 05		 cmp	 DWORD PTR _ver$[ebp+4], 5
  00038	72 0c		 jb	 SHORT $L24173

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  0003a	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

  00044	eb 0a		 jmp	 SHORT $L24174
$L24173:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00046	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L24174:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  00050	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pfnGetThreadACP$[ebp]
  00056	51		 push	 ecx
  00057	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0005c	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pNew$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pp$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 93   : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$24161 = -24					; size = 4
_lcidThread$ = -20					; size = 4
_szACP$ = -16						; size = 7
__$ArrayPad$ = -8					; size = 4
_nACP$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0
  0001b	89 45 ec	 mov	 DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  0001e	6a 07		 push	 7
  00020	8d 45 f0	 lea	 eax, DWORD PTR _szACP$[ebp]
  00023	50		 push	 eax
  00024	68 04 10 00 00	 push	 4100			; 00001004H
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _lcidThread$[ebp]
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00033	85 c0		 test	 eax, eax
  00035	74 34		 je	 SHORT $L24160

; 111  : 	{
; 112  : 		char* pch = szACP;

  00037	8d 55 f0	 lea	 edx, DWORD PTR _szACP$[ebp]
  0003a	89 55 e8	 mov	 DWORD PTR _pch$24161[ebp], edx
$L24163:

; 113  : 		while (*pch != '\0')

  0003d	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00040	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00043	85 c9		 test	 ecx, ecx
  00045	74 24		 je	 SHORT $L24160

; 114  : 		{
; 115  : 			nACP *= 10;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  0004a	6b d2 0a	 imul	 edx, 10			; 0000000aH
  0004d	89 55 fc	 mov	 DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

  00050	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  00059	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  0005d	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
  00060	8b 4d e8	 mov	 ecx, DWORD PTR _pch$24161[ebp]
  00063	83 c1 01	 add	 ecx, 1
  00066	89 4d e8	 mov	 DWORD PTR _pch$24161[ebp], ecx

; 117  : 		}

  00069	eb d2		 jmp	 SHORT $L24163
$L24160:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  0006b	83 7d fc 00	 cmp	 DWORD PTR _nACP$[ebp], 0
  0006f	75 09		 jne	 SHORT $L24165

; 121  : 		nACP = ::GetACP();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  00077	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
$L24165:

; 122  : 
; 123  : 	return nACP;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _nACP$[ebp]

; 124  : }

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  : 	return( CP_THREAD_ACP );

  00003	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
PUBLIC	?GetInstance@TabWndFactory@@SAPAV1@XZ		; TabWndFactory::GetInstance
PUBLIC	??0TabWndFactory@@QAE@XZ			; TabWndFactory::TabWndFactory
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T202594 DD	0ffffffffH
	DD	FLAT:$L202587
$T202591 DD	019930520H
	DD	01H
	DD	FLAT:$T202594
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabwndfactory.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv72 = -24						; size = 4
$T202584 = -20						; size = 4
$T202583 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?GetInstance@TabWndFactory@@SAPAV1@XZ PROC NEAR		; TabWndFactory::GetInstance

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetInstance@TabWndFactory@@SAPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 12   : 	if( m_pSelf == NULL )

  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pSelf@TabWndFactory@@2PAV1@A, 0 ; TabWndFactory::m_pSelf
  00022	75 44		 jne	 SHORT $L201170

; 13   : 	{
; 14   : 		m_pSelf = new TabWndFactory;

  00024	6a 18		 push	 24			; 00000018H
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 45 ec	 mov	 DWORD PTR $T202584[ebp], eax
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	83 7d ec 00	 cmp	 DWORD PTR $T202584[ebp], 0
  0003c	74 0d		 je	 SHORT $L202585
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR $T202584[ebp]
  00041	e8 00 00 00 00	 call	 ??0TabWndFactory@@QAE@XZ ; TabWndFactory::TabWndFactory
  00046	89 45 e8	 mov	 DWORD PTR tv72[ebp], eax
  00049	eb 07		 jmp	 SHORT $L202586
$L202585:
  0004b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L202586:
  00052	8b 45 e8	 mov	 eax, DWORD PTR tv72[ebp]
  00055	89 45 f0	 mov	 DWORD PTR $T202583[ebp], eax
  00058	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR $T202583[ebp]
  00062	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_pSelf@TabWndFactory@@2PAV1@A, ecx ; TabWndFactory::m_pSelf
$L201170:

; 15   : 	}
; 16   : 	return m_pSelf;

  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pSelf@TabWndFactory@@2PAV1@A ; TabWndFactory::m_pSelf

; 17   : }

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202587:
  00000	8b 45 ec	 mov	 eax, DWORD PTR $T202584[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?GetInstance@TabWndFactory@@SAPAV1@XZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202591
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetInstance@TabWndFactory@@SAPAV1@XZ ENDP		; TabWndFactory::GetInstance
PUBLIC	??_GTabWndFactory@@QAEPAXI@Z			; TabWndFactory::`scalar deleting destructor'
PUBLIC	?DelInstance@TabWndFactory@@SAXXZ		; TabWndFactory::DelInstance
; Function compile flags: /Odt
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T202598 = -8						; size = 4
$T202597 = -4						; size = 4
?DelInstance@TabWndFactory@@SAXXZ PROC NEAR		; TabWndFactory::DelInstance

; 20   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 21   : 	if( m_pSelf != NULL )

  00086	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pSelf@TabWndFactory@@2PAV1@A, 0 ; TabWndFactory::m_pSelf
  0008d	74 34		 je	 SHORT $L201176

; 22   : 	{
; 23   : 		delete m_pSelf;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pSelf@TabWndFactory@@2PAV1@A ; TabWndFactory::m_pSelf
  00094	89 45 f8	 mov	 DWORD PTR $T202598[ebp], eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR $T202598[ebp]
  0009a	89 4d fc	 mov	 DWORD PTR $T202597[ebp], ecx
  0009d	83 7d fc 00	 cmp	 DWORD PTR $T202597[ebp], 0
  000a1	74 0f		 je	 SHORT $L202599
  000a3	6a 01		 push	 1
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR $T202597[ebp]
  000a8	e8 00 00 00 00	 call	 ??_GTabWndFactory@@QAEPAXI@Z
  000ad	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  000b0	eb 07		 jmp	 SHORT $L202600
$L202599:
  000b2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L202600:

; 24   : 		m_pSelf = NULL;

  000b9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_pSelf@TabWndFactory@@2PAV1@A, 0 ; TabWndFactory::m_pSelf
$L201176:

; 25   : 	}
; 26   : }

  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
?DelInstance@TabWndFactory@@SAXXZ ENDP			; TabWndFactory::DelInstance
_TEXT	ENDS
PUBLIC	??1TabWndFactory@@QAE@XZ			; TabWndFactory::~TabWndFactory
; Function compile flags: /Odt
;	COMDAT ??_GTabWndFactory@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTabWndFactory@@QAEPAXI@Z PROC NEAR			; TabWndFactory::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1TabWndFactory@@QAE@XZ ; TabWndFactory::~TabWndFactory
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L201183
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L201183:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GTabWndFactory@@QAEPAXI@Z ENDP			; TabWndFactory::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::vector<CWnd *,std::allocator<CWnd *> >
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TabWndFactory@@QAE@XZ PROC NEAR			; TabWndFactory::TabWndFactory
; _this$ = ecx

; 29   : {

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	51		 push	 ecx
  000d4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	e8 00 00 00 00	 call	 ??0?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::vector<CWnd *,std::allocator<CWnd *> >

; 30   : 	m_idWnd = 1000;

  000df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	c7 40 14 e8 03
	00 00		 mov	 DWORD PTR [eax+20], 1000 ; 000003e8H

; 31   : }

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
??0TabWndFactory@@QAE@XZ ENDP				; TabWndFactory::TabWndFactory
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::~vector<CWnd *,std::allocator<CWnd *> >
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TabWndFactory@@QAE@XZ PROC NEAR			; TabWndFactory::~TabWndFactory
; _this$ = ecx

; 34   : {

  000f0	55		 push	 ebp
  000f1	8b ec		 mov	 ebp, esp
  000f3	51		 push	 ecx
  000f4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 	//m_vecWnd
; 36   : 	//for( vector<CWnd*>::iterator it1 = m_vecWnd.begin(); 
; 37   : 	//	it1 != m_vecWnd.end(); it1++ )
; 38   : 	//{
; 39   : 	//	CWnd* pWnd = (CWnd*)(*it1);
; 40   : 	//	if( dynamic_cast<PlayedGameWnd*>(pWnd) )
; 41   : 	//	{
; 42   : 	//		PlayedGameWnd* pWnd1 = (PlayedGameWnd*)pWnd;
; 43   : 	//		pWnd1->DestroyWindow();
; 44   : 	//		delete pWnd1;
; 45   : 	//	}else
; 46   : 	//	if( dynamic_cast<GamePanelWnd*>(pWnd) )
; 47   : 	//	{
; 48   : 	//		GamePanelWnd* pWnd1 = (GamePanelWnd*)pWnd;
; 49   : 	//		pWnd1->DestroyWindow();
; 50   : 	//		delete pWnd1;
; 51   : 	//	}else
; 52   : 	//	if( dynamic_cast<WebGamePanelWnd*>(pWnd) )
; 53   : 	//	{
; 54   : 	//		WebGamePanelWnd* pWnd1 = (WebGamePanelWnd*)pWnd;
; 55   : 	//		pWnd1->DestroyWindow();
; 56   : 	//		delete pWnd1;
; 57   : 	//	}else
; 58   : 	//	if( dynamic_cast<MyWebBrowserWnd*>(pWnd) )
; 59   : 	//	{
; 60   : 	//		MyWebBrowserWnd* pWnd1 = (MyWebBrowserWnd*)pWnd;
; 61   : 	//		pWnd1->DestroyWindow();
; 62   : 	//	}
; 63   : 	//}
; 64   : }

  000f7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	e8 00 00 00 00	 call	 ??1?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::~vector<CWnd *,std::allocator<CWnd *> >
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
??1TabWndFactory@@QAE@XZ ENDP				; TabWndFactory::~TabWndFactory
_TEXT	ENDS
PUBLIC	?SetParent@TabWndFactory@@QAEXPAVCWnd@@@Z	; TabWndFactory::SetParent
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pWnd$ = 8						; size = 4
?SetParent@TabWndFactory@@QAEXPAVCWnd@@@Z PROC NEAR	; TabWndFactory::SetParent
; _this$ = ecx

; 67   : {

  00110	55		 push	 ebp
  00111	8b ec		 mov	 ebp, esp
  00113	51		 push	 ecx
  00114	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 68   : 	m_pWndParent = pWnd;

  00117	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  0011d	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 69   : }

  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 04 00	 ret	 4
?SetParent@TabWndFactory@@QAEXPAVCWnd@@@Z ENDP		; TabWndFactory::SetParent
_TEXT	ENDS
PUBLIC	?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z		; CWnd::GetClientRect
PUBLIC	??0CRect@@QAE@XZ				; CRect::CRect
PUBLIC	??_R0?AVCWnd@@@8				; CWnd `RTTI Type Descriptor'
PUBLIC	??2CObject@@SGPAXI@Z				; CObject::operator new
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
PUBLIC	??9const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator!=
PUBLIC	??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator*
PUBLIC	??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AV012@H@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator++
PUBLIC	??_R0?AVPlayedGameWnd@@@8			; PlayedGameWnd `RTTI Type Descriptor'
PUBLIC	?begin@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::begin
PUBLIC	?end@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::end
PUBLIC	?erase@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::erase
PUBLIC	?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z		; CWnd::MoveWindow
PUBLIC	?CreateWndPlayedGame@TabWndFactory@@QAEPAVPlayedGameWnd@@XZ ; TabWndFactory::CreateWndPlayedGame
EXTRN	?ShowWindow@CWnd@@QAEHH@Z:NEAR			; CWnd::ShowWindow
EXTRN	___RTDynamicCast:NEAR
EXTRN	??0PlayedGameWnd@@QAE@XZ:NEAR			; PlayedGameWnd::PlayedGameWnd
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
xdata$x	SEGMENT
$T202620 DD	0ffffffffH
	DD	FLAT:$L202616
$T202618 DD	019930520H
	DD	01H
	DD	FLAT:$T202620
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0?AVPlayedGameWnd@@@8
_DATA	SEGMENT
??_R0?AVPlayedGameWnd@@@8 DD FLAT:??_7type_info@@6B@	; PlayedGameWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPlayedGameWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVCWnd@@@8
_DATA	SEGMENT
??_R0?AVCWnd@@@8 DD FLAT:??_7type_info@@6B@		; CWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWnd@@', 00H
	ORG $-19
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVCWnd@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
tv151 = -68						; size = 4
tv142 = -64						; size = 4
_this$ = -60						; size = 4
$T202613 = -56						; size = 4
$T202612 = -52						; size = 4
$T202611 = -48						; size = 4
$T202610 = -44						; size = 4
$T202609 = -40						; size = 4
_it1$201315 = -36					; size = 4
_pWnd$ = -32						; size = 4
_rc$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
?CreateWndPlayedGame@TabWndFactory@@QAEPAVPlayedGameWnd@@XZ PROC NEAR ; TabWndFactory::CreateWndPlayedGame
; _this$ = ecx

; 72   : {

  00130	55		 push	 ebp
  00131	8b ec		 mov	 ebp, esp
  00133	6a ff		 push	 -1
  00135	68 00 00 00 00	 push	 __ehhandler$?CreateWndPlayedGame@TabWndFactory@@QAEPAVPlayedGameWnd@@XZ
  0013a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00140	50		 push	 eax
  00141	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00148	83 ec 38	 sub	 esp, 56			; 00000038H
  0014b	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 73   : 	PlayedGameWnd* pWnd = NULL;

  0014e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pWnd$[ebp], 0

; 74   : 	for( vector<CWnd*>::iterator it1 = m_vecWnd.begin();

  00155	8d 45 dc	 lea	 eax, DWORD PTR _it1$201315[ebp]
  00158	50		 push	 eax
  00159	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	e8 00 00 00 00	 call	 ?begin@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::begin

; 75   : 		it1 != m_vecWnd.end(); it1++ )

  00161	eb 0e		 jmp	 SHORT $L201319
$L201320:
  00163	6a 00		 push	 0
  00165	8d 4d d8	 lea	 ecx, DWORD PTR $T202609[ebp]
  00168	51		 push	 ecx
  00169	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201315[ebp]
  0016c	e8 00 00 00 00	 call	 ??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AV012@H@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator++
$L201319:
  00171	8d 55 d4	 lea	 edx, DWORD PTR $T202610[ebp]
  00174	52		 push	 edx
  00175	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00178	e8 00 00 00 00	 call	 ?end@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::end
  0017d	50		 push	 eax
  0017e	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201315[ebp]
  00181	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator!=
  00186	0f b6 c0	 movzx	 eax, al
  00189	85 c0		 test	 eax, eax
  0018b	74 46		 je	 SHORT $L201321

; 76   : 	{
; 77   : 		if( dynamic_cast<PlayedGameWnd*>(*it1) )

  0018d	6a 00		 push	 0
  0018f	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVPlayedGameWnd@@@8
  00194	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVCWnd@@@8
  00199	6a 00		 push	 0
  0019b	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201315[ebp]
  0019e	e8 00 00 00 00	 call	 ??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator*
  001a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a5	51		 push	 ecx
  001a6	e8 00 00 00 00	 call	 ___RTDynamicCast
  001ab	83 c4 14	 add	 esp, 20			; 00000014H
  001ae	85 c0		 test	 eax, eax
  001b0	74 1f		 je	 SHORT $L201324

; 78   : 		{
; 79   : 			pWnd = (PlayedGameWnd*)(*it1);

  001b2	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201315[ebp]
  001b5	e8 00 00 00 00	 call	 ??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator*
  001ba	8b 10		 mov	 edx, DWORD PTR [eax]
  001bc	89 55 e0	 mov	 DWORD PTR _pWnd$[ebp], edx

; 80   : 			m_vecWnd.erase( it1 );

  001bf	8b 45 dc	 mov	 eax, DWORD PTR _it1$201315[ebp]
  001c2	50		 push	 eax
  001c3	8d 4d d0	 lea	 ecx, DWORD PTR $T202611[ebp]
  001c6	51		 push	 ecx
  001c7	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ca	e8 00 00 00 00	 call	 ?erase@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::erase

; 81   : 			break;

  001cf	eb 02		 jmp	 SHORT $L201321
$L201324:

; 82   : 		}
; 83   : 	}

  001d1	eb 90		 jmp	 SHORT $L201320
$L201321:

; 84   : 
; 85   : 	CRect rc;

  001d3	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  001d6	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 86   : 	m_pWndParent->GetClientRect( &rc );

  001db	8d 55 e4	 lea	 edx, DWORD PTR _rc$[ebp]
  001de	52		 push	 edx
  001df	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  001e2	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001e5	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 87   : 
; 88   : 	rc.top += 24;

  001ea	8b 4d e8	 mov	 ecx, DWORD PTR _rc$[ebp+4]
  001ed	83 c1 18	 add	 ecx, 24			; 00000018H
  001f0	89 4d e8	 mov	 DWORD PTR _rc$[ebp+4], ecx

; 89   : 
; 90   : 	if( pWnd )

  001f3	83 7d e0 00	 cmp	 DWORD PTR _pWnd$[ebp], 0
  001f7	74 1d		 je	 SHORT $L201328

; 91   : 	{
; 92   : 		pWnd->MoveWindow( &rc );

  001f9	6a 01		 push	 1
  001fb	8d 55 e4	 lea	 edx, DWORD PTR _rc$[ebp]
  001fe	52		 push	 edx
  001ff	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00202	e8 00 00 00 00	 call	 ?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::MoveWindow

; 93   : 		pWnd->ShowWindow( SW_SHOW ); 

  00207	6a 05		 push	 5
  00209	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  0020c	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 94   : 	}else

  00211	e9 88 00 00 00	 jmp	 $L201329
$L201328:

; 95   : 	{
; 96   : 		pWnd = new PlayedGameWnd();

  00216	68 5c 02 00 00	 push	 604			; 0000025cH
  0021b	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  00220	89 45 c8	 mov	 DWORD PTR $T202613[ebp], eax
  00223	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0022a	83 7d c8 00	 cmp	 DWORD PTR $T202613[ebp], 0
  0022e	74 0d		 je	 SHORT $L202614
  00230	8b 4d c8	 mov	 ecx, DWORD PTR $T202613[ebp]
  00233	e8 00 00 00 00	 call	 ??0PlayedGameWnd@@QAE@XZ ; PlayedGameWnd::PlayedGameWnd
  00238	89 45 c0	 mov	 DWORD PTR tv142[ebp], eax
  0023b	eb 07		 jmp	 SHORT $L202615
$L202614:
  0023d	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
$L202615:
  00244	8b 45 c0	 mov	 eax, DWORD PTR tv142[ebp]
  00247	89 45 cc	 mov	 DWORD PTR $T202612[ebp], eax
  0024a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00251	8b 4d cc	 mov	 ecx, DWORD PTR $T202612[ebp]
  00254	89 4d e0	 mov	 DWORD PTR _pWnd$[ebp], ecx

; 97   : 		pWnd->Create(NULL,NULL,WS_CHILD|WS_VISIBLE|WS_CLIPCHILDREN|WS_CLIPSIBLINGS,rc,m_pWndParent, m_idWnd++);

  00257	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0025a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0025d	89 45 bc	 mov	 DWORD PTR tv151[ebp], eax
  00260	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00263	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00266	83 c2 01	 add	 edx, 1
  00269	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0026c	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0026f	6a 00		 push	 0
  00271	8b 4d bc	 mov	 ecx, DWORD PTR tv151[ebp]
  00274	51		 push	 ecx
  00275	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  00278	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0027b	50		 push	 eax
  0027c	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  0027f	51		 push	 ecx
  00280	68 00 00 00 56	 push	 1442840576		; 56000000H
  00285	6a 00		 push	 0
  00287	6a 00		 push	 0
  00289	8b 55 e0	 mov	 edx, DWORD PTR _pWnd$[ebp]
  0028c	8b 02		 mov	 eax, DWORD PTR [edx]
  0028e	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00291	ff 50 5c	 call	 DWORD PTR [eax+92]

; 98   : 	
; 99   : 		pWnd->ShowWindow (SW_SHOW);

  00294	6a 05		 push	 5
  00296	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00299	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow
$L201329:

; 100  : 	}
; 101  : 	return pWnd;

  0029e	8b 45 e0	 mov	 eax, DWORD PTR _pWnd$[ebp]

; 102  : }

  002a1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002a4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202616:
  00015	8b 45 c8	 mov	 eax, DWORD PTR $T202613[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  0001e	c3		 ret	 0
__ehhandler$?CreateWndPlayedGame@TabWndFactory@@QAEPAVPlayedGameWnd@@XZ:
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202618
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreateWndPlayedGame@TabWndFactory@@QAEPAVPlayedGameWnd@@XZ ENDP ; TabWndFactory::CreateWndPlayedGame
PUBLIC	??_R0?AVGamePanelWnd@@@8			; GamePanelWnd `RTTI Type Descriptor'
PUBLIC	?CreateWndGamePanel@TabWndFactory@@QAEPAVGamePanelWnd@@XZ ; TabWndFactory::CreateWndGamePanel
EXTRN	??0GamePanelWnd@@QAE@XZ:NEAR			; GamePanelWnd::GamePanelWnd
xdata$x	SEGMENT
$T202633 DD	0ffffffffH
	DD	FLAT:$L202629
$T202631 DD	019930520H
	DD	01H
	DD	FLAT:$T202633
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0?AVGamePanelWnd@@@8
_DATA	SEGMENT
??_R0?AVGamePanelWnd@@@8 DD FLAT:??_7type_info@@6B@	; GamePanelWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVGamePanelWnd@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
tv150 = -68						; size = 4
tv141 = -64						; size = 4
_this$ = -60						; size = 4
$T202626 = -56						; size = 4
$T202625 = -52						; size = 4
$T202624 = -48						; size = 4
$T202623 = -44						; size = 4
$T202622 = -40						; size = 4
_it1$201339 = -36					; size = 4
_pWnd$ = -32						; size = 4
_rc$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
?CreateWndGamePanel@TabWndFactory@@QAEPAVGamePanelWnd@@XZ PROC NEAR ; TabWndFactory::CreateWndGamePanel
; _this$ = ecx

; 105  : {

  002b0	55		 push	 ebp
  002b1	8b ec		 mov	 ebp, esp
  002b3	6a ff		 push	 -1
  002b5	68 00 00 00 00	 push	 __ehhandler$?CreateWndGamePanel@TabWndFactory@@QAEPAVGamePanelWnd@@XZ
  002ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  002c0	50		 push	 eax
  002c1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  002c8	83 ec 38	 sub	 esp, 56			; 00000038H
  002cb	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	GamePanelWnd* pWnd = NULL;

  002ce	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pWnd$[ebp], 0

; 107  : 	for( vector<CWnd*>::iterator it1 = m_vecWnd.begin();

  002d5	8d 45 dc	 lea	 eax, DWORD PTR _it1$201339[ebp]
  002d8	50		 push	 eax
  002d9	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  002dc	e8 00 00 00 00	 call	 ?begin@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::begin

; 108  : 		it1 != m_vecWnd.end(); it1++ )

  002e1	eb 0e		 jmp	 SHORT $L201343
$L201344:
  002e3	6a 00		 push	 0
  002e5	8d 4d d8	 lea	 ecx, DWORD PTR $T202622[ebp]
  002e8	51		 push	 ecx
  002e9	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201339[ebp]
  002ec	e8 00 00 00 00	 call	 ??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AV012@H@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator++
$L201343:
  002f1	8d 55 d4	 lea	 edx, DWORD PTR $T202623[ebp]
  002f4	52		 push	 edx
  002f5	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  002f8	e8 00 00 00 00	 call	 ?end@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::end
  002fd	50		 push	 eax
  002fe	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201339[ebp]
  00301	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator!=
  00306	0f b6 c0	 movzx	 eax, al
  00309	85 c0		 test	 eax, eax
  0030b	74 46		 je	 SHORT $L201345

; 109  : 	{
; 110  : 		if( dynamic_cast<GamePanelWnd*>(*it1) )

  0030d	6a 00		 push	 0
  0030f	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVGamePanelWnd@@@8
  00314	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVCWnd@@@8
  00319	6a 00		 push	 0
  0031b	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201339[ebp]
  0031e	e8 00 00 00 00	 call	 ??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator*
  00323	8b 08		 mov	 ecx, DWORD PTR [eax]
  00325	51		 push	 ecx
  00326	e8 00 00 00 00	 call	 ___RTDynamicCast
  0032b	83 c4 14	 add	 esp, 20			; 00000014H
  0032e	85 c0		 test	 eax, eax
  00330	74 1f		 je	 SHORT $L201348

; 111  : 		{
; 112  : 			pWnd = (GamePanelWnd*)(*it1);

  00332	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201339[ebp]
  00335	e8 00 00 00 00	 call	 ??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator*
  0033a	8b 10		 mov	 edx, DWORD PTR [eax]
  0033c	89 55 e0	 mov	 DWORD PTR _pWnd$[ebp], edx

; 113  : 			m_vecWnd.erase( it1 );

  0033f	8b 45 dc	 mov	 eax, DWORD PTR _it1$201339[ebp]
  00342	50		 push	 eax
  00343	8d 4d d0	 lea	 ecx, DWORD PTR $T202624[ebp]
  00346	51		 push	 ecx
  00347	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0034a	e8 00 00 00 00	 call	 ?erase@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::erase

; 114  : 			break;

  0034f	eb 02		 jmp	 SHORT $L201345
$L201348:

; 115  : 		}
; 116  : 	}

  00351	eb 90		 jmp	 SHORT $L201344
$L201345:

; 117  : 
; 118  : 	CRect rc;

  00353	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  00356	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 119  : 	m_pWndParent->GetClientRect( &rc );

  0035b	8d 55 e4	 lea	 edx, DWORD PTR _rc$[ebp]
  0035e	52		 push	 edx
  0035f	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00362	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00365	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 120  : 	if( pWnd )

  0036a	83 7d e0 00	 cmp	 DWORD PTR _pWnd$[ebp], 0
  0036e	74 1a		 je	 SHORT $L201352

; 121  : 	{
; 122  : 		pWnd->MoveWindow( &rc );

  00370	6a 01		 push	 1
  00372	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  00375	51		 push	 ecx
  00376	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00379	e8 00 00 00 00	 call	 ?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::MoveWindow

; 123  : 		pWnd->ShowWindow( SW_SHOW ); 

  0037e	6a 05		 push	 5
  00380	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00383	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 124  : 	}else

  00388	eb 7e		 jmp	 SHORT $L201353
$L201352:

; 125  : 	{
; 126  : 		pWnd = new GamePanelWnd();

  0038a	68 64 01 00 00	 push	 356			; 00000164H
  0038f	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  00394	89 45 c8	 mov	 DWORD PTR $T202626[ebp], eax
  00397	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0039e	83 7d c8 00	 cmp	 DWORD PTR $T202626[ebp], 0
  003a2	74 0d		 je	 SHORT $L202627
  003a4	8b 4d c8	 mov	 ecx, DWORD PTR $T202626[ebp]
  003a7	e8 00 00 00 00	 call	 ??0GamePanelWnd@@QAE@XZ	; GamePanelWnd::GamePanelWnd
  003ac	89 45 c0	 mov	 DWORD PTR tv141[ebp], eax
  003af	eb 07		 jmp	 SHORT $L202628
$L202627:
  003b1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
$L202628:
  003b8	8b 55 c0	 mov	 edx, DWORD PTR tv141[ebp]
  003bb	89 55 cc	 mov	 DWORD PTR $T202625[ebp], edx
  003be	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003c5	8b 45 cc	 mov	 eax, DWORD PTR $T202625[ebp]
  003c8	89 45 e0	 mov	 DWORD PTR _pWnd$[ebp], eax

; 127  : 		pWnd->Create(NULL,NULL,WS_CHILD|WS_VISIBLE|WS_CLIPCHILDREN|WS_CLIPSIBLINGS,rc,m_pWndParent, m_idWnd++);

  003cb	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  003ce	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  003d1	89 55 bc	 mov	 DWORD PTR tv150[ebp], edx
  003d4	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  003d7	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  003da	83 c1 01	 add	 ecx, 1
  003dd	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  003e0	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
  003e3	6a 00		 push	 0
  003e5	8b 45 bc	 mov	 eax, DWORD PTR tv150[ebp]
  003e8	50		 push	 eax
  003e9	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  003ec	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  003ef	52		 push	 edx
  003f0	8d 45 e4	 lea	 eax, DWORD PTR _rc$[ebp]
  003f3	50		 push	 eax
  003f4	68 00 00 00 56	 push	 1442840576		; 56000000H
  003f9	6a 00		 push	 0
  003fb	6a 00		 push	 0
  003fd	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00400	8b 11		 mov	 edx, DWORD PTR [ecx]
  00402	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00405	ff 52 5c	 call	 DWORD PTR [edx+92]
$L201353:

; 128  : 	}
; 129  : 	return pWnd;

  00408	8b 45 e0	 mov	 eax, DWORD PTR _pWnd$[ebp]

; 130  : }

  0040b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0040e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00415	8b e5		 mov	 esp, ebp
  00417	5d		 pop	 ebp
  00418	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202629:
  00029	8b 45 c8	 mov	 eax, DWORD PTR $T202626[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00032	c3		 ret	 0
__ehhandler$?CreateWndGamePanel@TabWndFactory@@QAEPAVGamePanelWnd@@XZ:
  00033	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202631
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreateWndGamePanel@TabWndFactory@@QAEPAVGamePanelWnd@@XZ ENDP ; TabWndFactory::CreateWndGamePanel
PUBLIC	??_R0?AVWebGamePanelWnd@@@8			; WebGamePanelWnd `RTTI Type Descriptor'
PUBLIC	?CreateWndWebGamePanel@TabWndFactory@@QAEPAVWebGamePanelWnd@@XZ ; TabWndFactory::CreateWndWebGamePanel
EXTRN	??0WebGamePanelWnd@@QAE@XZ:NEAR			; WebGamePanelWnd::WebGamePanelWnd
xdata$x	SEGMENT
$T202646 DD	0ffffffffH
	DD	FLAT:$L202642
$T202644 DD	019930520H
	DD	01H
	DD	FLAT:$T202646
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0?AVWebGamePanelWnd@@@8
_DATA	SEGMENT
??_R0?AVWebGamePanelWnd@@@8 DD FLAT:??_7type_info@@6B@	; WebGamePanelWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWebGamePanelWnd@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
tv150 = -68						; size = 4
tv141 = -64						; size = 4
_this$ = -60						; size = 4
$T202639 = -56						; size = 4
$T202638 = -52						; size = 4
$T202637 = -48						; size = 4
$T202636 = -44						; size = 4
$T202635 = -40						; size = 4
_it1$201363 = -36					; size = 4
_pWnd$ = -32						; size = 4
_rc$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
?CreateWndWebGamePanel@TabWndFactory@@QAEPAVWebGamePanelWnd@@XZ PROC NEAR ; TabWndFactory::CreateWndWebGamePanel
; _this$ = ecx

; 133  : {

  00420	55		 push	 ebp
  00421	8b ec		 mov	 ebp, esp
  00423	6a ff		 push	 -1
  00425	68 00 00 00 00	 push	 __ehhandler$?CreateWndWebGamePanel@TabWndFactory@@QAEPAVWebGamePanelWnd@@XZ
  0042a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00430	50		 push	 eax
  00431	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00438	83 ec 38	 sub	 esp, 56			; 00000038H
  0043b	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 134  : 	WebGamePanelWnd* pWnd = NULL;

  0043e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pWnd$[ebp], 0

; 135  : 	for( vector<CWnd*>::iterator it1 = m_vecWnd.begin();

  00445	8d 45 dc	 lea	 eax, DWORD PTR _it1$201363[ebp]
  00448	50		 push	 eax
  00449	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0044c	e8 00 00 00 00	 call	 ?begin@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::begin

; 136  : 		it1 != m_vecWnd.end(); it1++ )

  00451	eb 0e		 jmp	 SHORT $L201367
$L201368:
  00453	6a 00		 push	 0
  00455	8d 4d d8	 lea	 ecx, DWORD PTR $T202635[ebp]
  00458	51		 push	 ecx
  00459	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201363[ebp]
  0045c	e8 00 00 00 00	 call	 ??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AV012@H@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator++
$L201367:
  00461	8d 55 d4	 lea	 edx, DWORD PTR $T202636[ebp]
  00464	52		 push	 edx
  00465	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00468	e8 00 00 00 00	 call	 ?end@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::end
  0046d	50		 push	 eax
  0046e	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201363[ebp]
  00471	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator!=
  00476	0f b6 c0	 movzx	 eax, al
  00479	85 c0		 test	 eax, eax
  0047b	74 46		 je	 SHORT $L201369

; 137  : 	{
; 138  : 		if( dynamic_cast<WebGamePanelWnd*>(*it1) )

  0047d	6a 00		 push	 0
  0047f	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVWebGamePanelWnd@@@8
  00484	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVCWnd@@@8
  00489	6a 00		 push	 0
  0048b	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201363[ebp]
  0048e	e8 00 00 00 00	 call	 ??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator*
  00493	8b 08		 mov	 ecx, DWORD PTR [eax]
  00495	51		 push	 ecx
  00496	e8 00 00 00 00	 call	 ___RTDynamicCast
  0049b	83 c4 14	 add	 esp, 20			; 00000014H
  0049e	85 c0		 test	 eax, eax
  004a0	74 1f		 je	 SHORT $L201372

; 139  : 		{
; 140  : 			pWnd = (WebGamePanelWnd*)(*it1);

  004a2	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201363[ebp]
  004a5	e8 00 00 00 00	 call	 ??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator*
  004aa	8b 10		 mov	 edx, DWORD PTR [eax]
  004ac	89 55 e0	 mov	 DWORD PTR _pWnd$[ebp], edx

; 141  : 			m_vecWnd.erase( it1 );

  004af	8b 45 dc	 mov	 eax, DWORD PTR _it1$201363[ebp]
  004b2	50		 push	 eax
  004b3	8d 4d d0	 lea	 ecx, DWORD PTR $T202637[ebp]
  004b6	51		 push	 ecx
  004b7	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  004ba	e8 00 00 00 00	 call	 ?erase@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::erase

; 142  : 			break;

  004bf	eb 02		 jmp	 SHORT $L201369
$L201372:

; 143  : 		}
; 144  : 	}

  004c1	eb 90		 jmp	 SHORT $L201368
$L201369:

; 145  : 
; 146  : 	CRect rc;

  004c3	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  004c6	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 147  : 	m_pWndParent->GetClientRect( &rc );

  004cb	8d 55 e4	 lea	 edx, DWORD PTR _rc$[ebp]
  004ce	52		 push	 edx
  004cf	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  004d2	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  004d5	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 148  : 	if( pWnd )

  004da	83 7d e0 00	 cmp	 DWORD PTR _pWnd$[ebp], 0
  004de	74 1a		 je	 SHORT $L201376

; 149  : 	{
; 150  : 		pWnd->MoveWindow( &rc );

  004e0	6a 01		 push	 1
  004e2	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  004e5	51		 push	 ecx
  004e6	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  004e9	e8 00 00 00 00	 call	 ?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::MoveWindow

; 151  : 		pWnd->ShowWindow( SW_SHOW ); 

  004ee	6a 05		 push	 5
  004f0	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  004f3	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 152  : 	}else

  004f8	eb 7e		 jmp	 SHORT $L201377
$L201376:

; 153  : 	{
; 154  : 		pWnd = new WebGamePanelWnd();

  004fa	68 dc 00 00 00	 push	 220			; 000000dcH
  004ff	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  00504	89 45 c8	 mov	 DWORD PTR $T202639[ebp], eax
  00507	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0050e	83 7d c8 00	 cmp	 DWORD PTR $T202639[ebp], 0
  00512	74 0d		 je	 SHORT $L202640
  00514	8b 4d c8	 mov	 ecx, DWORD PTR $T202639[ebp]
  00517	e8 00 00 00 00	 call	 ??0WebGamePanelWnd@@QAE@XZ ; WebGamePanelWnd::WebGamePanelWnd
  0051c	89 45 c0	 mov	 DWORD PTR tv141[ebp], eax
  0051f	eb 07		 jmp	 SHORT $L202641
$L202640:
  00521	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
$L202641:
  00528	8b 55 c0	 mov	 edx, DWORD PTR tv141[ebp]
  0052b	89 55 cc	 mov	 DWORD PTR $T202638[ebp], edx
  0052e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00535	8b 45 cc	 mov	 eax, DWORD PTR $T202638[ebp]
  00538	89 45 e0	 mov	 DWORD PTR _pWnd$[ebp], eax

; 155  : 		pWnd->Create(NULL,NULL,WS_CHILD|WS_VISIBLE|WS_CLIPCHILDREN|WS_CLIPSIBLINGS,rc,m_pWndParent, m_idWnd++);

  0053b	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0053e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00541	89 55 bc	 mov	 DWORD PTR tv150[ebp], edx
  00544	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00547	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0054a	83 c1 01	 add	 ecx, 1
  0054d	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  00550	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
  00553	6a 00		 push	 0
  00555	8b 45 bc	 mov	 eax, DWORD PTR tv150[ebp]
  00558	50		 push	 eax
  00559	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0055c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0055f	52		 push	 edx
  00560	8d 45 e4	 lea	 eax, DWORD PTR _rc$[ebp]
  00563	50		 push	 eax
  00564	68 00 00 00 56	 push	 1442840576		; 56000000H
  00569	6a 00		 push	 0
  0056b	6a 00		 push	 0
  0056d	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00570	8b 11		 mov	 edx, DWORD PTR [ecx]
  00572	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00575	ff 52 5c	 call	 DWORD PTR [edx+92]
$L201377:

; 156  : 	}
; 157  : 	return pWnd;

  00578	8b 45 e0	 mov	 eax, DWORD PTR _pWnd$[ebp]

; 158  : }

  0057b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0057e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00585	8b e5		 mov	 esp, ebp
  00587	5d		 pop	 ebp
  00588	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202642:
  0003d	8b 45 c8	 mov	 eax, DWORD PTR $T202639[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00046	c3		 ret	 0
__ehhandler$?CreateWndWebGamePanel@TabWndFactory@@QAEPAVWebGamePanelWnd@@XZ:
  00047	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202644
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreateWndWebGamePanel@TabWndFactory@@QAEPAVWebGamePanelWnd@@XZ ENDP ; TabWndFactory::CreateWndWebGamePanel
PUBLIC	??0CRect@@QAE@HHHH@Z				; CRect::CRect
PUBLIC	??_R0?AVMyWebBrowserWnd@@@8			; MyWebBrowserWnd `RTTI Type Descriptor'
PUBLIC	?CreateWndMyWebBrowser@TabWndFactory@@QAEPAVMyWebBrowserWnd@@XZ ; TabWndFactory::CreateWndMyWebBrowser
EXTRN	??0MyWebBrowserWnd@@QAE@H@Z:NEAR		; MyWebBrowserWnd::MyWebBrowserWnd
xdata$x	SEGMENT
$T202659 DD	0ffffffffH
	DD	FLAT:$L202655
$T202657 DD	019930520H
	DD	01H
	DD	FLAT:$T202659
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0?AVMyWebBrowserWnd@@@8
_DATA	SEGMENT
??_R0?AVMyWebBrowserWnd@@@8 DD FLAT:??_7type_info@@6B@	; MyWebBrowserWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMyWebBrowserWnd@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
tv151 = -84						; size = 4
tv137 = -80						; size = 4
_this$ = -76						; size = 4
$T202652 = -72						; size = 4
$T202651 = -68						; size = 4
$T202650 = -64						; size = 4
$T202649 = -60						; size = 4
$T202648 = -56						; size = 4
_rcNull$201405 = -52					; size = 16
_it1$201387 = -36					; size = 4
_pWnd$ = -32						; size = 4
_rc$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
?CreateWndMyWebBrowser@TabWndFactory@@QAEPAVMyWebBrowserWnd@@XZ PROC NEAR ; TabWndFactory::CreateWndMyWebBrowser
; _this$ = ecx

; 161  : {

  00590	55		 push	 ebp
  00591	8b ec		 mov	 ebp, esp
  00593	6a ff		 push	 -1
  00595	68 00 00 00 00	 push	 __ehhandler$?CreateWndMyWebBrowser@TabWndFactory@@QAEPAVMyWebBrowserWnd@@XZ
  0059a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  005a0	50		 push	 eax
  005a1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  005a8	83 ec 48	 sub	 esp, 72			; 00000048H
  005ab	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	MyWebBrowserWnd* pWnd = NULL;

  005ae	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pWnd$[ebp], 0

; 163  : 	for( vector<CWnd*>::iterator it1 = m_vecWnd.begin();

  005b5	8d 45 dc	 lea	 eax, DWORD PTR _it1$201387[ebp]
  005b8	50		 push	 eax
  005b9	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  005bc	e8 00 00 00 00	 call	 ?begin@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::begin

; 164  : 		it1 != m_vecWnd.end(); it1++ )

  005c1	eb 0e		 jmp	 SHORT $L201391
$L201392:
  005c3	6a 00		 push	 0
  005c5	8d 4d c8	 lea	 ecx, DWORD PTR $T202648[ebp]
  005c8	51		 push	 ecx
  005c9	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201387[ebp]
  005cc	e8 00 00 00 00	 call	 ??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AV012@H@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator++
$L201391:
  005d1	8d 55 c4	 lea	 edx, DWORD PTR $T202649[ebp]
  005d4	52		 push	 edx
  005d5	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  005d8	e8 00 00 00 00	 call	 ?end@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::end
  005dd	50		 push	 eax
  005de	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201387[ebp]
  005e1	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator!=
  005e6	0f b6 c0	 movzx	 eax, al
  005e9	85 c0		 test	 eax, eax
  005eb	74 46		 je	 SHORT $L201393

; 165  : 	{
; 166  : 		if( dynamic_cast<MyWebBrowserWnd*>(*it1) )

  005ed	6a 00		 push	 0
  005ef	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVMyWebBrowserWnd@@@8
  005f4	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVCWnd@@@8
  005f9	6a 00		 push	 0
  005fb	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201387[ebp]
  005fe	e8 00 00 00 00	 call	 ??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator*
  00603	8b 08		 mov	 ecx, DWORD PTR [eax]
  00605	51		 push	 ecx
  00606	e8 00 00 00 00	 call	 ___RTDynamicCast
  0060b	83 c4 14	 add	 esp, 20			; 00000014H
  0060e	85 c0		 test	 eax, eax
  00610	74 1f		 je	 SHORT $L201396

; 167  : 		{
; 168  : 			pWnd = (MyWebBrowserWnd*)(*it1);

  00612	8d 4d dc	 lea	 ecx, DWORD PTR _it1$201387[ebp]
  00615	e8 00 00 00 00	 call	 ??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator*
  0061a	8b 10		 mov	 edx, DWORD PTR [eax]
  0061c	89 55 e0	 mov	 DWORD PTR _pWnd$[ebp], edx

; 169  : 			m_vecWnd.erase( it1 );

  0061f	8b 45 dc	 mov	 eax, DWORD PTR _it1$201387[ebp]
  00622	50		 push	 eax
  00623	8d 4d c0	 lea	 ecx, DWORD PTR $T202650[ebp]
  00626	51		 push	 ecx
  00627	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0062a	e8 00 00 00 00	 call	 ?erase@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::erase

; 170  : 			break;

  0062f	eb 02		 jmp	 SHORT $L201393
$L201396:

; 171  : 		}
; 172  : 	}

  00631	eb 90		 jmp	 SHORT $L201392
$L201393:

; 173  : 
; 174  : 	CRect rc;

  00633	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  00636	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 175  : 	m_pWndParent->GetClientRect( &rc );

  0063b	8d 55 e4	 lea	 edx, DWORD PTR _rc$[ebp]
  0063e	52		 push	 edx
  0063f	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00642	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00645	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 176  : 	if( pWnd == NULL )

  0064a	83 7d e0 00	 cmp	 DWORD PTR _pWnd$[ebp], 0
  0064e	0f 85 90 00 00
	00		 jne	 $L201400

; 177  : 	{
; 178  : 		pWnd = new MyWebBrowserWnd();

  00654	68 e8 01 00 00	 push	 488			; 000001e8H
  00659	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  0065e	89 45 b8	 mov	 DWORD PTR $T202652[ebp], eax
  00661	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00668	83 7d b8 00	 cmp	 DWORD PTR $T202652[ebp], 0
  0066c	74 0f		 je	 SHORT $L202653
  0066e	6a 01		 push	 1
  00670	8b 4d b8	 mov	 ecx, DWORD PTR $T202652[ebp]
  00673	e8 00 00 00 00	 call	 ??0MyWebBrowserWnd@@QAE@H@Z ; MyWebBrowserWnd::MyWebBrowserWnd
  00678	89 45 b0	 mov	 DWORD PTR tv137[ebp], eax
  0067b	eb 07		 jmp	 SHORT $L202654
$L202653:
  0067d	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], 0
$L202654:
  00684	8b 4d b0	 mov	 ecx, DWORD PTR tv137[ebp]
  00687	89 4d bc	 mov	 DWORD PTR $T202651[ebp], ecx
  0068a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00691	8b 55 bc	 mov	 edx, DWORD PTR $T202651[ebp]
  00694	89 55 e0	 mov	 DWORD PTR _pWnd$[ebp], edx

; 179  : 		CRect rcNull(0,0,0,0);

  00697	6a 00		 push	 0
  00699	6a 00		 push	 0
  0069b	6a 00		 push	 0
  0069d	6a 00		 push	 0
  0069f	8d 4d cc	 lea	 ecx, DWORD PTR _rcNull$201405[ebp]
  006a2	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect

; 180  : 		pWnd->Create(NULL,NULL,WS_CHILD|WS_VISIBLE|WS_CLIPCHILDREN|WS_CLIPSIBLINGS,rcNull,m_pWndParent, m_idWnd++);

  006a7	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  006aa	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  006ad	89 4d ac	 mov	 DWORD PTR tv151[ebp], ecx
  006b0	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  006b3	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  006b6	83 c0 01	 add	 eax, 1
  006b9	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  006bc	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  006bf	6a 00		 push	 0
  006c1	8b 55 ac	 mov	 edx, DWORD PTR tv151[ebp]
  006c4	52		 push	 edx
  006c5	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  006c8	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  006cb	51		 push	 ecx
  006cc	8d 55 cc	 lea	 edx, DWORD PTR _rcNull$201405[ebp]
  006cf	52		 push	 edx
  006d0	68 00 00 00 56	 push	 1442840576		; 56000000H
  006d5	6a 00		 push	 0
  006d7	6a 00		 push	 0
  006d9	8b 45 e0	 mov	 eax, DWORD PTR _pWnd$[ebp]
  006dc	8b 10		 mov	 edx, DWORD PTR [eax]
  006de	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  006e1	ff 52 5c	 call	 DWORD PTR [edx+92]
$L201400:

; 181  : 	}
; 182  : 	pWnd->MoveWindow( &rc );

  006e4	6a 01		 push	 1
  006e6	8d 45 e4	 lea	 eax, DWORD PTR _rc$[ebp]
  006e9	50		 push	 eax
  006ea	8b 4d e0	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  006ed	e8 00 00 00 00	 call	 ?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::MoveWindow

; 183  : 	return pWnd;

  006f2	8b 45 e0	 mov	 eax, DWORD PTR _pWnd$[ebp]

; 184  : }

  006f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  006ff	8b e5		 mov	 esp, ebp
  00701	5d		 pop	 ebp
  00702	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202655:
  00051	8b 45 b8	 mov	 eax, DWORD PTR $T202652[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  0005a	c3		 ret	 0
__ehhandler$?CreateWndMyWebBrowser@TabWndFactory@@QAEPAVMyWebBrowserWnd@@XZ:
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202657
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreateWndMyWebBrowser@TabWndFactory@@QAEPAVMyWebBrowserWnd@@XZ ENDP ; TabWndFactory::CreateWndMyWebBrowser
PUBLIC	?Recycle@TabWndFactory@@QAEXPAVCWnd@@@Z		; TabWndFactory::Recycle
; Function compile flags: /Odt
_TEXT	SEGMENT
tv156 = -56						; size = 4
tv129 = -52						; size = 4
tv80 = -48						; size = 4
_this$ = -44						; size = 4
$T202670 = -40						; size = 4
$T202669 = -36						; size = 4
$T202666 = -32						; size = 4
$T202665 = -28						; size = 4
$T202662 = -24						; size = 4
$T202661 = -20						; size = 4
_pWnd1$201431 = -16					; size = 4
_pWnd1$201426 = -12					; size = 4
_pWnd1$201419 = -8					; size = 4
_pWnd1$201412 = -4					; size = 4
_pWnd$ = 8						; size = 4
?Recycle@TabWndFactory@@QAEXPAVCWnd@@@Z PROC NEAR	; TabWndFactory::Recycle
; _this$ = ecx

; 187  : {

  00710	55		 push	 ebp
  00711	8b ec		 mov	 ebp, esp
  00713	83 ec 38	 sub	 esp, 56			; 00000038H
  00716	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 188  : 	//m_vecWnd
; 189  : 	if( dynamic_cast<GamePanelWnd*>(pWnd) )

  00719	6a 00		 push	 0
  0071b	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVGamePanelWnd@@@8
  00720	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVCWnd@@@8
  00725	6a 00		 push	 0
  00727	8b 45 08	 mov	 eax, DWORD PTR _pWnd$[ebp]
  0072a	50		 push	 eax
  0072b	e8 00 00 00 00	 call	 ___RTDynamicCast
  00730	83 c4 14	 add	 esp, 20			; 00000014H
  00733	85 c0		 test	 eax, eax
  00735	74 41		 je	 SHORT $L201411

; 190  : 	{
; 191  : 		GamePanelWnd* pWnd1 = (GamePanelWnd*)pWnd;

  00737	8b 4d 08	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  0073a	89 4d fc	 mov	 DWORD PTR _pWnd1$201412[ebp], ecx

; 192  : 		//pWnd1->Recycle();
; 193  : 		pWnd1->DestroyWindow();

  0073d	8b 55 fc	 mov	 edx, DWORD PTR _pWnd1$201412[ebp]
  00740	8b 02		 mov	 eax, DWORD PTR [edx]
  00742	8b 4d fc	 mov	 ecx, DWORD PTR _pWnd1$201412[ebp]
  00745	ff 50 68	 call	 DWORD PTR [eax+104]

; 194  : 		delete pWnd1;

  00748	8b 4d fc	 mov	 ecx, DWORD PTR _pWnd1$201412[ebp]
  0074b	89 4d e8	 mov	 DWORD PTR $T202662[ebp], ecx
  0074e	8b 55 e8	 mov	 edx, DWORD PTR $T202662[ebp]
  00751	89 55 ec	 mov	 DWORD PTR $T202661[ebp], edx
  00754	83 7d ec 00	 cmp	 DWORD PTR $T202661[ebp], 0
  00758	74 12		 je	 SHORT $L202663
  0075a	6a 01		 push	 1
  0075c	8b 45 ec	 mov	 eax, DWORD PTR $T202661[ebp]
  0075f	8b 10		 mov	 edx, DWORD PTR [eax]
  00761	8b 4d ec	 mov	 ecx, DWORD PTR $T202661[ebp]
  00764	ff 52 04	 call	 DWORD PTR [edx+4]
  00767	89 45 d0	 mov	 DWORD PTR tv80[ebp], eax
  0076a	eb 07		 jmp	 SHORT $L202664
$L202663:
  0076c	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$L202664:

; 195  : 	}else

  00773	e9 ea 00 00 00	 jmp	 $L201409
$L201411:

; 196  : 	if( dynamic_cast<WebGamePanelWnd*>(pWnd) )

  00778	6a 00		 push	 0
  0077a	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVWebGamePanelWnd@@@8
  0077f	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVCWnd@@@8
  00784	6a 00		 push	 0
  00786	8b 45 08	 mov	 eax, DWORD PTR _pWnd$[ebp]
  00789	50		 push	 eax
  0078a	e8 00 00 00 00	 call	 ___RTDynamicCast
  0078f	83 c4 14	 add	 esp, 20			; 00000014H
  00792	85 c0		 test	 eax, eax
  00794	74 41		 je	 SHORT $L201418

; 197  : 	{
; 198  : 		WebGamePanelWnd* pWnd1 = (WebGamePanelWnd*)pWnd;

  00796	8b 4d 08	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00799	89 4d f8	 mov	 DWORD PTR _pWnd1$201419[ebp], ecx

; 199  : 		//pWnd1->Recycle();
; 200  : 		pWnd1->DestroyWindow();

  0079c	8b 55 f8	 mov	 edx, DWORD PTR _pWnd1$201419[ebp]
  0079f	8b 02		 mov	 eax, DWORD PTR [edx]
  007a1	8b 4d f8	 mov	 ecx, DWORD PTR _pWnd1$201419[ebp]
  007a4	ff 50 68	 call	 DWORD PTR [eax+104]

; 201  : 		delete pWnd1;

  007a7	8b 4d f8	 mov	 ecx, DWORD PTR _pWnd1$201419[ebp]
  007aa	89 4d e0	 mov	 DWORD PTR $T202666[ebp], ecx
  007ad	8b 55 e0	 mov	 edx, DWORD PTR $T202666[ebp]
  007b0	89 55 e4	 mov	 DWORD PTR $T202665[ebp], edx
  007b3	83 7d e4 00	 cmp	 DWORD PTR $T202665[ebp], 0
  007b7	74 12		 je	 SHORT $L202667
  007b9	6a 01		 push	 1
  007bb	8b 45 e4	 mov	 eax, DWORD PTR $T202665[ebp]
  007be	8b 10		 mov	 edx, DWORD PTR [eax]
  007c0	8b 4d e4	 mov	 ecx, DWORD PTR $T202665[ebp]
  007c3	ff 52 04	 call	 DWORD PTR [edx+4]
  007c6	89 45 cc	 mov	 DWORD PTR tv129[ebp], eax
  007c9	eb 07		 jmp	 SHORT $L202668
$L202667:
  007cb	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
$L202668:

; 202  : 	}else

  007d2	e9 8b 00 00 00	 jmp	 $L201409
$L201418:

; 203  : 	if( dynamic_cast<MyWebBrowserWnd*>(pWnd) )

  007d7	6a 00		 push	 0
  007d9	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVMyWebBrowserWnd@@@8
  007de	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVCWnd@@@8
  007e3	6a 00		 push	 0
  007e5	8b 45 08	 mov	 eax, DWORD PTR _pWnd$[ebp]
  007e8	50		 push	 eax
  007e9	e8 00 00 00 00	 call	 ___RTDynamicCast
  007ee	83 c4 14	 add	 esp, 20			; 00000014H
  007f1	85 c0		 test	 eax, eax
  007f3	74 13		 je	 SHORT $L201425

; 204  : 	{
; 205  : 		MyWebBrowserWnd* pWnd1 = (MyWebBrowserWnd*)pWnd;

  007f5	8b 4d 08	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  007f8	89 4d f4	 mov	 DWORD PTR _pWnd1$201426[ebp], ecx

; 206  : 		//pWnd1->Recycle();
; 207  : 		pWnd1->DestroyWindow();

  007fb	8b 55 f4	 mov	 edx, DWORD PTR _pWnd1$201426[ebp]
  007fe	8b 02		 mov	 eax, DWORD PTR [edx]
  00800	8b 4d f4	 mov	 ecx, DWORD PTR _pWnd1$201426[ebp]
  00803	ff 50 68	 call	 DWORD PTR [eax+104]

; 208  : 		//delete
; 209  : 	}else

  00806	eb 5a		 jmp	 SHORT $L201409
$L201425:

; 210  : 	if( dynamic_cast<PlayedGameWnd*>(pWnd) )

  00808	6a 00		 push	 0
  0080a	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVPlayedGameWnd@@@8
  0080f	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVCWnd@@@8
  00814	6a 00		 push	 0
  00816	8b 4d 08	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00819	51		 push	 ecx
  0081a	e8 00 00 00 00	 call	 ___RTDynamicCast
  0081f	83 c4 14	 add	 esp, 20			; 00000014H
  00822	85 c0		 test	 eax, eax
  00824	74 3c		 je	 SHORT $L201409

; 211  : 	{
; 212  : 		PlayedGameWnd* pWnd1 = (PlayedGameWnd*)pWnd;

  00826	8b 55 08	 mov	 edx, DWORD PTR _pWnd$[ebp]
  00829	89 55 f0	 mov	 DWORD PTR _pWnd1$201431[ebp], edx

; 213  : 		//pWnd1->Recycle();
; 214  : 		pWnd1->DestroyWindow();

  0082c	8b 45 f0	 mov	 eax, DWORD PTR _pWnd1$201431[ebp]
  0082f	8b 10		 mov	 edx, DWORD PTR [eax]
  00831	8b 4d f0	 mov	 ecx, DWORD PTR _pWnd1$201431[ebp]
  00834	ff 52 68	 call	 DWORD PTR [edx+104]

; 215  : 		delete pWnd1;

  00837	8b 45 f0	 mov	 eax, DWORD PTR _pWnd1$201431[ebp]
  0083a	89 45 d8	 mov	 DWORD PTR $T202670[ebp], eax
  0083d	8b 4d d8	 mov	 ecx, DWORD PTR $T202670[ebp]
  00840	89 4d dc	 mov	 DWORD PTR $T202669[ebp], ecx
  00843	83 7d dc 00	 cmp	 DWORD PTR $T202669[ebp], 0
  00847	74 12		 je	 SHORT $L202671
  00849	6a 01		 push	 1
  0084b	8b 55 dc	 mov	 edx, DWORD PTR $T202669[ebp]
  0084e	8b 02		 mov	 eax, DWORD PTR [edx]
  00850	8b 4d dc	 mov	 ecx, DWORD PTR $T202669[ebp]
  00853	ff 50 04	 call	 DWORD PTR [eax+4]
  00856	89 45 c8	 mov	 DWORD PTR tv156[ebp], eax
  00859	eb 07		 jmp	 SHORT $L201409
$L202671:
  0085b	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv156[ebp], 0
$L201409:

; 216  : 	}
; 217  : 	//m_vecWnd.push_back( pWnd );
; 218  : 	//pWnd->MoveWindow(0,0,0,0);
; 219  : }

  00862	8b e5		 mov	 esp, ebp
  00864	5d		 pop	 ebp
  00865	c2 04 00	 ret	 4
?Recycle@TabWndFactory@@QAEXPAVCWnd@@@Z ENDP		; TabWndFactory::Recycle
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE@V?$allocator@PAVCWnd@@@1@@Z ; std::_Vector_val<CWnd *,std::allocator<CWnd *> >::_Vector_val<CWnd *,std::allocator<CWnd *> >
PUBLIC	??0?$allocator@PAVCWnd@@@std@@QAE@XZ		; std::allocator<CWnd *>::allocator<CWnd *>
PUBLIC	?_Buy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE_NI@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::_Buy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::vector<CWnd *,std::allocator<CWnd *> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@PAVCWnd@@@std@@QAE@XZ ; std::allocator<CWnd *>::allocator<CWnd *>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE@V?$allocator@PAVCWnd@@@1@@Z ; std::_Vector_val<CWnd *,std::allocator<CWnd *> >::_Vector_val<CWnd *,std::allocator<CWnd *> >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE_NI@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::vector<CWnd *,std::allocator<CWnd *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXXZ ; std::vector<CWnd *,std::allocator<CWnd *> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::~vector<CWnd *,std::allocator<CWnd *> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXXZ ; std::vector<CWnd *,std::allocator<CWnd *> >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@XZ ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::~vector<CWnd *,std::allocator<CWnd *> >
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::end
_TEXT	ENDS
PUBLIC	??$copy@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00@Z ; std::copy<CWnd * *,CWnd * *>
PUBLIC	?_Destroy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXPAPAVCWnd@@0@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::_Destroy
; Function compile flags: /Odt
;	COMDAT ?erase@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::erase, COMDAT
; _this$ = ecx

; 723  : 		{	// erase element at where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 724  : 		copy(_ITER_BASE(_Where) + 1, _Mylast, _ITER_BASE(_Where));

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00011	52		 push	 edx
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$copy@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00@Z ; std::copy<CWnd * *,CWnd * *>
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  : 		_Destroy(_Mylast - 1, _Mylast);

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00027	52		 push	 edx
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002e	83 e9 04	 sub	 ecx, 4
  00031	51		 push	 ecx
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXPAPAVCWnd@@0@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::_Destroy

; 726  : 		--_Mylast;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00040	83 e8 04	 sub	 eax, 4
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 727  : 		return (_Where);

  00049	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0004c	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0004f	89 02		 mov	 DWORD PTR [edx], eax
  00051	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 728  : 		}

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?erase@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::erase
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEABQAVCWnd@@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEABQAVCWnd@@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEAAPAVCWnd@@XZ ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAEAAV012@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 236  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 237  : 			++*this;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAEAAV012@XZ ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator++

; 238  : 			return (_Tmp);

  00019	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 239  : 			}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator==
; Function compile flags: /Odt
;	COMDAT ??9const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 159  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 161  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCWnd@@@std@@QAEPAPAVCWnd@@I@Z ; std::allocator<CWnd *>::allocate
PUBLIC	?max_size@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEIXZ ; std::vector<CWnd *,std::allocator<CWnd *> >::max_size
PUBLIC	?_Xlen@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IBEXXZ ; std::vector<CWnd *,std::allocator<CWnd *> >::_Xlen
; Function compile flags: /Odt
;	COMDAT ?_Buy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L201546

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 49		 jmp	 SHORT $L201545
$L201546:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEIXZ ; std::vector<CWnd *,std::allocator<CWnd *> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L201548

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IBEXXZ ; std::vector<CWnd *,std::allocator<CWnd *> >::_Xlen

; 776  : 		else

  00044	eb 30		 jmp	 SHORT $L201547
$L201548:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAVCWnd@@@std@@QAEPAPAVCWnd@@I@Z ; std::allocator<CWnd *>::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00067	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0006d	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L201547:

; 781  : 			}
; 782  : 		return (true);

  00076	b0 01		 mov	 al, 1
$L201545:

; 783  : 		}

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Buy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@@Z ; std::_Destroy_range<CWnd *,std::allocator<CWnd *> >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXPAPAVCWnd@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXPAPAVCWnd@@0@Z PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@@Z ; std::_Destroy_range<CWnd *,std::allocator<CWnd *> >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXPAPAVCWnd@@0@Z ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::_Destroy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCWnd@@@std@@QAEXPAPAVCWnd@@I@Z ; std::allocator<CWnd *>::deallocate
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 35		 je	 SHORT $L201561

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXPAPAVCWnd@@0@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	c1 f9 02	 sar	 ecx, 2
  00035	51		 push	 ecx
  00036	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00039	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003c	50		 push	 eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCWnd@@@std@@QAEXPAPAVCWnd@@I@Z ; std::allocator<CWnd *>::deallocate
$L201561:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?_Tidy@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAEXXZ ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCWnd@@@std@@QAE@ABV01@@Z	; std::allocator<CWnd *>::allocator<CWnd *>
; Function compile flags: /Odt
;	COMDAT ??0?$_Vector_val@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE@V?$allocator@PAVCWnd@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE@V?$allocator@PAVCWnd@@@1@@Z PROC NEAR ; std::_Vector_val<CWnd *,std::allocator<CWnd *> >::_Vector_val<CWnd *,std::allocator<CWnd *> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@PAVCWnd@@@std@@QAE@ABV01@@Z ; std::allocator<CWnd *>::allocator<CWnd *>

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IAE@V?$allocator@PAVCWnd@@@1@@Z ENDP ; std::_Vector_val<CWnd *,std::allocator<CWnd *> >::_Vector_val<CWnd *,std::allocator<CWnd *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVCWnd@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVCWnd@@@std@@QAE@XZ PROC NEAR		; std::allocator<CWnd *>::allocator<CWnd *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@PAVCWnd@@@std@@QAE@XZ ENDP		; std::allocator<CWnd *>::allocator<CWnd *>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 			++this->_Myptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	83 c1 04	 add	 ecx, 4
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 232  : 			}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??Eiterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::iterator::operator++
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEABQAVCWnd@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEABQAVCWnd@@XZ PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEABQAVCWnd@@XZ ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 152  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 156  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCWnd@@@std@@QBEIXZ	; std::allocator<CWnd *>::max_size
; Function compile flags: /Odt
;	COMDAT ?max_size@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@PAVCWnd@@@std@@QBEIXZ ; std::allocator<CWnd *>::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QBEIXZ ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::max_size
_TEXT	ENDS
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202718 DD	0ffffffffH
	DD	FLAT:$L202714
$T202716 DD	019930520H
	DD	01H
	DD	FLAT:$T202718
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
	ORG $-30
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T202712 = -80						; size = 28
$T202711 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T202712[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T202712[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T202711[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T202711[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L202710:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202714:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T202712[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202716
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@IBEXXZ ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@PAVCWnd@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVCWnd@@@std@@QAE@ABV01@@Z PROC NEAR	; std::allocator<CWnd *>::allocator<CWnd *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@PAVCWnd@@@std@@QAE@ABV01@@Z ENDP		; std::allocator<CWnd *>::allocator<CWnd *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVCWnd@@@std@@QAEXPAPAVCWnd@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCWnd@@@std@@QAEXPAPAVCWnd@@I@Z PROC NEAR ; std::allocator<CWnd *>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCWnd@@@std@@QAEXPAPAVCWnd@@I@Z ENDP ; std::allocator<CWnd *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCWnd@@@std@@YAPAPAVCWnd@@IPAPAV1@@Z ; std::_Allocate<CWnd *>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@PAVCWnd@@@std@@QAEPAPAVCWnd@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCWnd@@@std@@QAEPAPAVCWnd@@I@Z PROC NEAR ; std::allocator<CWnd *>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@PAVCWnd@@@std@@YAPAPAVCWnd@@IPAPAV1@@Z ; std::_Allocate<CWnd *>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@PAVCWnd@@@std@@QAEPAPAVCWnd@@I@Z ENDP ; std::allocator<CWnd *>::allocate
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z PROC NEAR ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@QAE@PAPAVCWnd@@@Z ENDP ; std::vector<CWnd *,std::allocator<CWnd *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVCWnd@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVCWnd@@@std@@QBEIXZ PROC NEAR	; std::allocator<CWnd *>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc ff ff
	ff 3f		 mov	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L202734
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L202735
$L202734:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L202735:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@PAVCWnd@@@std@@QBEIXZ ENDP	; std::allocator<CWnd *>::max_size
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@VCWnd@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCWnd@@0@Z ; std::_Ptr_cat<CWnd>
PUBLIC	??$_Copy_opt@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<CWnd * *,CWnd * *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00@Z
_TEXT	SEGMENT
$T202738 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00@Z PROC NEAR ; std::copy<CWnd * *,CWnd * *>, COMDAT

; 1039 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00004	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@VCWnd@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCWnd@@0@Z ; std::_Ptr_cat<CWnd>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T202738[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T202738[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_opt@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<CWnd * *,CWnd * *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1041 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00@Z ENDP ; std::copy<CWnd * *,CWnd * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CWnd *,std::allocator<CWnd *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@@Z
_TEXT	SEGMENT
$T202741 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@@Z PROC NEAR ; std::_Destroy_range<CWnd *,std::allocator<CWnd *> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@VCWnd@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCWnd@@0@Z ; std::_Ptr_cat<CWnd>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T202741[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T202741[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CWnd *,std::allocator<CWnd *> >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@@Z ENDP ; std::_Destroy_range<CWnd *,std::allocator<CWnd *> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCWnd@@@std@@YAPAPAVCWnd@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCWnd@@@std@@YAPAPAVCWnd@@IPAPAV1@@Z PROC NEAR ; std::_Allocate<CWnd *>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@PAVCWnd@@@std@@YAPAPAVCWnd@@IPAPAV1@@Z ENDP ; std::_Allocate<CWnd *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@VCWnd@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCWnd@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@VCWnd@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCWnd@@0@Z PROC NEAR ; std::_Ptr_cat<CWnd>, COMDAT

; 218  : 	{	// return pointer category from pointer to pointer arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 219  : 	_Scalar_ptr_iterator_tag _Cat;
; 220  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 221  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@VCWnd@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCWnd@@0@Z ENDP ; std::_Ptr_cat<CWnd>
_TEXT	ENDS
EXTRN	__imp__memmove:NEAR
; Function compile flags: /Odt
;	COMDAT ??$_Copy_opt@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_opt@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<CWnd * *,CWnd * *>, COMDAT

; 1030 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1031 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	89 45 fc	 mov	 DWORD PTR __Off$[ebp], eax

; 1032 : 	return ((_OutIt)::memmove(&*_Dest, &*_First,
; 1033 : 		_Off * sizeof (*_First)) + _Off);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00013	c1 e1 02	 shl	 ecx, 2
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  0002b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 1034 : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$_Copy_opt@PAPAVCWnd@@PAPAV1@@std@@YAPAPAVCWnd@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CWnd * *,CWnd * *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CWnd *,std::allocator<CWnd *> >, COMDAT

; 233  : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@PAVCWnd@@V?$allocator@PAVCWnd@@@std@@@std@@YAXPAPAVCWnd@@0AAV?$allocator@PAVCWnd@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CWnd *,std::allocator<CWnd *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRect@@QAE@XZ PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 110  : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CRect@@QAE@XZ ENDP					; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
??0CRect@@QAE@HHHH@Z PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 112  : 	{ left = l; top = t; right = r; bottom = b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _r$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _b$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
??0CRect@@QAE@HHHH@Z ENDP				; CRect::CRect
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC NEAR				; CObject::operator delete, COMDAT

; 31   : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??2CObject@@SGPAXI@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
??2CObject@@SGPAXI@Z PROC NEAR				; CObject::operator new, COMDAT

; 37   : 	{ return ::operator new(nSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _nSize$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??2CObject@@SGPAXI@Z ENDP				; CObject::operator new
_TEXT	ENDS
EXTRN	?MoveWindow@CWnd@@QAEXHHHHH@Z:NEAR		; CWnd::MoveWindow
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin2.inl
;	COMDAT ?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
_bRepaint$ = 12						; size = 4
?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z PROC NEAR		; CWnd::MoveWindow, COMDAT
; _this$ = ecx

; 89   : 	{ MoveWindow(lpRect->left, lpRect->top, lpRect->right - lpRect->left,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   : 		lpRect->bottom - lpRect->top, bRepaint); }

  00007	8b 45 0c	 mov	 eax, DWORD PTR _bRepaint$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _lpRect$[ebp]
  00011	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00014	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _lpRect$[ebp]
  0001e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00021	2b 02		 sub	 eax, DWORD PTR [edx]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  00027	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002a	52		 push	 edx
  0002b	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	51		 push	 ecx
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?MoveWindow@CWnd@@QAEXHHHHH@Z ; CWnd::MoveWindow
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z ENDP		; CWnd::MoveWindow
_TEXT	ENDS
EXTRN	__imp__GetClientRect@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z PROC NEAR	; CWnd::GetClientRect, COMDAT
; _this$ = ecx

; 107  : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ENDP		; CWnd::GetClientRect
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 28   : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202774 DD	0ffffffffH
	DD	FLAT:$L202769
$T202772 DD	019930520H
	DD	01H
	DD	FLAT:$T202774
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 20   : 		}

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202769:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202772
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102266
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102266:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202786 DD	0ffffffffH
	DD	FLAT:$L202781
$T202784 DD	019930520H
	DD	01H
	DD	FLAT:$T202786
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202781:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202784
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102332
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102332:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202801 DD	0ffffffffH
	DD	FLAT:$L202796
$T202799 DD	019930520H
	DD	01H
	DD	FLAT:$T202801
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0003f	52		 push	 edx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202796:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202799
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
END
