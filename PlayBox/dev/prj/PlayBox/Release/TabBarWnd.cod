; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\module\TabMan\TabBarWnd.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??1IData@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppStart@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppExit@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIData@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@OneLocalGame@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCTabBarWnd@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBasicSkinWnd@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ITabBarObserver@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ITabBarObserver@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GITabBarObserver@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IMessageObserver@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXABVCRect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@V312@ABVCRect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV3@IABV3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE@V?$allocator@VCRect@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@VCRect@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEAAVCRect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXPAVCRect@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXViterator@12@IABVCRect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@VCRect@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VCRect@@@std@@QAEXPAVCRect@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@VCRect@@@std@@QAEPAVCRect@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEABVCRect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VCRect@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAVCRect@@@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV2@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAVCRect@@V1@@std@@YAXPAVCRect@@0ABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@VCRect@@@std@@YAPAVCRect@@IPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVCRect@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCRect@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@VCRect@@@std@@QAEXPAVCRect@@ABV3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VCRect@@@std@@QAEXPAVCRect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@VCRect@@V1@@std@@YAXPAVCRect@@ABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@VCRect@@@std@@YAXPAVCRect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GTAB_ITEM@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_ECTabBarWnd@@WFE@AEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_ECTabBarWnd@@WFI@AEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CTabBarWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ITabBarObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CTabBarWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ITabBarObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1FI@?0A@A@IMessageObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1FI@?0A@A@ITabBarObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1FE@?0A@A@CBasicSkinWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CCmdTarget@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CBasicWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTabBarWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IMessageObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ITabBarObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVIData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCBasicSkinWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCBasicWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCTabBarWnd@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVITabBarObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4IData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CTabBarWnd@@6BITabBarObserver@@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CTabBarWnd@@6BCBasicSkinWnd@@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?EndModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BeginModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4CTabBarWnd@@6BCBasicWnd@@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ITabBarObserver@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9CPoint@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PtInRect@CRect@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRectEmpty@CRect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClientToScreen@CWnd@@QBEXPAUtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Invalidate@CWnd@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTextColor@CDC@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRectEmpty@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectObject@CDC@@QAEPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParent@CWnd@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_messageEntries@CTabBarWnd@@0QBUAFX_MSGMAP_ENTRY@@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messageMap@CTabBarWnd@@1UAFX_MSGMAP@@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IMessageObserver@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4IMessageObserver@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IMessageObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IMessageObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GIMessageObserver@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ITabBarObserver@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1IMessageObserver@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBasicSkinWnd@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CBasicSkinWnd@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CBasicSkinWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CBasicSkinWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBasicSkinWnd@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCBasicSkinWnd@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CObject@@SGPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFont@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CFont@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCFont@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GCFont@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFont@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CTabBarWnd@@6BITabBarObserver@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CTabBarWnd@@6BCBasicSkinWnd@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CTabBarWnd@@6BCBasicWnd@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CBasicSkinWnd@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?classCTabBarWnd@CTabBarWnd@@2UCRuntimeClass@@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	?classCTabBarWnd@CTabBarWnd@@2UCRuntimeClass@@B	; CTabBarWnd::classCTabBarWnd
PUBLIC	?_messageEntries@CTabBarWnd@@0QBUAFX_MSGMAP_ENTRY@@B ; CTabBarWnd::_messageEntries
PUBLIC	?messageMap@CTabBarWnd@@1UAFX_MSGMAP@@B		; CTabBarWnd::messageMap
PUBLIC	?OnPaint@CTabBarWnd@@IAEXXZ			; CTabBarWnd::OnPaint
PUBLIC	?OnSize@CTabBarWnd@@IAEXIHH@Z			; CTabBarWnd::OnSize
PUBLIC	?OnCreate@CTabBarWnd@@IAEHPAUtagCREATESTRUCTA@@@Z ; CTabBarWnd::OnCreate
PUBLIC	?OnLButtonDown@CTabBarWnd@@IAEXIVCPoint@@@Z	; CTabBarWnd::OnLButtonDown
PUBLIC	?OnMouseMove@CTabBarWnd@@IAEXIVCPoint@@@Z	; CTabBarWnd::OnMouseMove
PUBLIC	?OnDestroy@CTabBarWnd@@IAEXXZ			; CTabBarWnd::OnDestroy
EXTRN	?GetThisClass@CBasicWnd@@SGPAUCRuntimeClass@@XZ:NEAR ; CBasicWnd::GetThisClass
EXTRN	?GetThisMessageMap@CBasicWnd@@KGPBUAFX_MSGMAP@@XZ:NEAR ; CBasicWnd::GetThisMessageMap
CONST	SEGMENT
$SG199728 DB	'CTabBarWnd', 00H
CONST	ENDS
;	COMDAT ?classCTabBarWnd@CTabBarWnd@@2UCRuntimeClass@@B
CONST	SEGMENT
?classCTabBarWnd@CTabBarWnd@@2UCRuntimeClass@@B DD FLAT:$SG199728 ; CTabBarWnd::classCTabBarWnd
	DD	0140H
	DD	0ffffH
	DD	00H
	DD	FLAT:?GetThisClass@CBasicWnd@@SGPAUCRuntimeClass@@XZ
	DD	00H
	DD	00H
CONST	ENDS
CONST	SEGMENT
	ORG $+1
$SG199761 DB	0cbH, 0ceH, 0ccH, 0e5H, 00H
CONST	ENDS
;	COMDAT ?_messageEntries@CTabBarWnd@@0QBUAFX_MSGMAP_ENTRY@@B
CONST	SEGMENT
?_messageEntries@CTabBarWnd@@0QBUAFX_MSGMAP_ENTRY@@B DD 05H ; CTabBarWnd::_messageEntries
	DD	00H
	DD	00H
	DD	00H
	DD	016H
	DD	FLAT:?OnSize@CTabBarWnd@@IAEXIHH@Z
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	0dH
	DD	FLAT:?OnCreate@CTabBarWnd@@IAEHPAUtagCREATESTRUCTA@@@Z
	DD	0fH
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	FLAT:?OnPaint@CTabBarWnd@@IAEXXZ
	DD	0201H
	DD	00H
	DD	00H
	DD	00H
	DD	032H
	DD	FLAT:?OnLButtonDown@CTabBarWnd@@IAEXIVCPoint@@@Z
	DD	0200H
	DD	00H
	DD	00H
	DD	00H
	DD	032H
	DD	FLAT:?OnMouseMove@CTabBarWnd@@IAEXIVCPoint@@@Z
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	FLAT:?OnDestroy@CTabBarWnd@@IAEXXZ
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?messageMap@CTabBarWnd@@1UAFX_MSGMAP@@B
CONST	SEGMENT
?messageMap@CTabBarWnd@@1UAFX_MSGMAP@@B DD FLAT:?GetThisMessageMap@CBasicWnd@@KGPBUAFX_MSGMAP@@XZ ; CTabBarWnd::messageMap
	DD	FLAT:?_messageEntries@CTabBarWnd@@0QBUAFX_MSGMAP_ENTRY@@B
CONST	ENDS
CONST	SEGMENT
$SG199835 DB	00H
	ORG $+2
$SG199836 DB	'tooltips_class32', 00H
	ORG $+3
$SG199846 DB	'normal', 00H
	ORG $+1
$SG199847 DB	'tabbarWnd', 00H
	ORG $+2
$SG199850 DB	'normal', 00H
	ORG $+1
$SG199851 DB	'tabbarWnd', 00H
	ORG $+2
$SG199856 DB	'TabBarRectLeftNormal', 00H
	ORG $+3
$SG199857 DB	'TabBarRectMiddleNormal', 00H
	ORG $+1
$SG199858 DB	'TabBarRectRightNormal', 00H
	ORG $+2
$SG199859 DB	'TabBarRectLeftOver', 00H
	ORG $+1
$SG199860 DB	'TabBarRectMiddleOver', 00H
	ORG $+3
$SG199861 DB	'TabBarRectRightOver', 00H
$SG199862 DB	'TabBarRectLeftDown', 00H
	ORG $+1
$SG199863 DB	'TabBarRectMiddleDown', 00H
	ORG $+3
$SG199864 DB	'TabBarRectRightDown', 00H
$SG199865 DB	'TabBarCloseNormal', 00H
	ORG $+2
$SG199866 DB	'TabBarCloseOver', 00H
$SG199867 DB	'TabBarCloseDown', 00H
$SG199868 DB	'TabBarSelCloseNormal', 00H
	ORG $+3
$SG199869 DB	'TabBarSelCloseOver', 00H
	ORG $+1
$SG199870 DB	'TabBarSelCloseDown', 00H
	ORG $+1
$SG199871 DB	'TabbarNewWindowNormal', 00H
	ORG $+2
$SG199872 DB	'TabbarNewWindowOver', 00H
$SG199873 DB	'TabbarNewWindowDown', 00H
$SG199874 DB	'TabBarNormalTextColor', 00H
	ORG $+2
$SG199875 DB	'TabBarDownTextColor', 00H
$SG199898 DB	'TabBarBK', 00H
$SG199967 DB	00H
	ORG $+2
$SG199968 DB	0b4H, 0f2H, 0bfH, 0aaH, 0b4H, 0b0H, 0bfH, 0daH, 0b9H, 0fdH
	DB	0b6H, 0e0H, 0a3H, 0acH, 0c7H, 0ebH, 0b9H, 0d8H, 0b1H, 0d5H, 0ceH
	DB	0deH, 0d3H, 0c3H, 0b4H, 0b0H, 0bfH, 0daH, 00H
	ORG $+3
$SG199969 DB	0ccH, 0e1H, 0caH, 0beH, 00H
	ORG $+3
$SG200006 DB	'test', 00H
	ORG $+3
$SG200007 DB	'test', 00H
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
_ID_MESSAGE_TABBAR DD 0bH
_ID_DATA_TABBAR DD 07H
CONST	ENDS
PUBLIC	?GetThisClass@CTabBarWnd@@SGPAUCRuntimeClass@@XZ ; CTabBarWnd::GetThisClass
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabbarwnd.cpp
_TEXT	SEGMENT
?GetThisClass@CTabBarWnd@@SGPAUCRuntimeClass@@XZ PROC NEAR ; CTabBarWnd::GetThisClass

; 13   : IMPLEMENT_DYNAMIC(CTabBarWnd, CBasicWnd)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?classCTabBarWnd@CTabBarWnd@@2UCRuntimeClass@@B ; CTabBarWnd::classCTabBarWnd
  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetThisClass@CTabBarWnd@@SGPAUCRuntimeClass@@XZ ENDP	; CTabBarWnd::GetThisClass
_TEXT	ENDS
PUBLIC	?GetRuntimeClass@CTabBarWnd@@UBEPAUCRuntimeClass@@XZ ; CTabBarWnd::GetRuntimeClass
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRuntimeClass@CTabBarWnd@@UBEPAUCRuntimeClass@@XZ PROC NEAR ; CTabBarWnd::GetRuntimeClass
; _this$ = ecx

; 13   : IMPLEMENT_DYNAMIC(CTabBarWnd, CBasicWnd)

  00010	55		 push	 ebp
  00011	8b ec		 mov	 ebp, esp
  00013	51		 push	 ecx
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?classCTabBarWnd@CTabBarWnd@@2UCRuntimeClass@@B ; CTabBarWnd::classCTabBarWnd
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?GetRuntimeClass@CTabBarWnd@@UBEPAUCRuntimeClass@@XZ ENDP ; CTabBarWnd::GetRuntimeClass
_TEXT	ENDS
PUBLIC	??1?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ; std::vector<CRect,std::allocator<CRect> >::~vector<CRect,std::allocator<CRect> >
PUBLIC	??0CRect@@QAE@XZ				; CRect::CRect
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >
PUBLIC	??_R1A@?0A@A@CWnd@@8				; CWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >
PUBLIC	??_R0?AVCWnd@@@8				; CWnd `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CCmdTarget@@8			; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCCmdTarget@@@8				; CCmdTarget `RTTI Type Descriptor'
PUBLIC	??_R0?AVITabBarObserver@@@8			; ITabBarObserver `RTTI Type Descriptor'
PUBLIC	??_R4CTabBarWnd@@6BCBasicWnd@@@			; CTabBarWnd::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTabBarWnd@@@8				; CTabBarWnd `RTTI Type Descriptor'
PUBLIC	??_R3CTabBarWnd@@8				; CTabBarWnd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTabBarWnd@@8				; CTabBarWnd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CTabBarWnd@@8			; CTabBarWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@CBasicWnd@@8			; CBasicWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCBasicWnd@@@8				; CBasicWnd `RTTI Type Descriptor'
PUBLIC	??_R1FE@?0A@A@CBasicSkinWnd@@8			; CBasicSkinWnd::`RTTI Base Class Descriptor at (84,-1,0,0)'
PUBLIC	??_R1FI@?0A@A@ITabBarObserver@@8		; ITabBarObserver::`RTTI Base Class Descriptor at (88,-1,0,0)'
PUBLIC	??_R1FI@?0A@A@IMessageObserver@@8		; IMessageObserver::`RTTI Base Class Descriptor at (88,-1,0,0)'
PUBLIC	??_ECTabBarWnd@@WFE@AEPAXI@Z			; [thunk]:CTabBarWnd::`vector deleting destructor'
PUBLIC	??_R4CTabBarWnd@@6BCBasicSkinWnd@@@		; CTabBarWnd::`RTTI Complete Object Locator'
PUBLIC	??_ECTabBarWnd@@WFI@AEPAXI@Z			; [thunk]:CTabBarWnd::`vector deleting destructor'
PUBLIC	??_R4CTabBarWnd@@6BITabBarObserver@@@		; CTabBarWnd::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBasicSkinWnd@@@8			; CBasicSkinWnd `RTTI Type Descriptor'
PUBLIC	??1CBasicSkinWnd@@UAE@XZ			; CBasicSkinWnd::~CBasicSkinWnd
PUBLIC	??0CBasicSkinWnd@@QAE@XZ			; CBasicSkinWnd::CBasicSkinWnd
PUBLIC	??2CObject@@SGPAXI@Z				; CObject::operator new
PUBLIC	??_R0?AVIMessageObserver@@@8			; IMessageObserver `RTTI Type Descriptor'
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	??_7CTabBarWnd@@6BCBasicWnd@@@			; CTabBarWnd::`vftable'
PUBLIC	??_7CTabBarWnd@@6BCBasicSkinWnd@@@		; CTabBarWnd::`vftable'
PUBLIC	??_7CTabBarWnd@@6BITabBarObserver@@@		; CTabBarWnd::`vftable'
PUBLIC	??_GCTabBarWnd@@UAEPAXI@Z			; CTabBarWnd::`scalar deleting destructor'
PUBLIC	??0CFont@@QAE@XZ				; CFont::CFont
PUBLIC	?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z ; CFont::CreateFontIndirectA
PUBLIC	??1CFont@@UAE@XZ				; CFont::~CFont
PUBLIC	??0ITabBarObserver@@QAE@XZ			; ITabBarObserver::ITabBarObserver
PUBLIC	??1ITabBarObserver@@UAE@XZ			; ITabBarObserver::~ITabBarObserver
PUBLIC	??0CTabBarWnd@@QAE@XZ				; CTabBarWnd::CTabBarWnd
PUBLIC	?LoadSkin@CTabBarWnd@@UAEXXZ			; CTabBarWnd::LoadSkin
PUBLIC	?GetMessageMap@CTabBarWnd@@MBEPBUAFX_MSGMAP@@XZ	; CTabBarWnd::GetMessageMap
PUBLIC	?ITabBarOb_CreateNewTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z ; CTabBarWnd::ITabBarOb_CreateNewTab
PUBLIC	?ITabBarOb_OpenExistTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z ; CTabBarWnd::ITabBarOb_OpenExistTab
PUBLIC	?ITabBarOb_DelTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z ; CTabBarWnd::ITabBarOb_DelTab
PUBLIC	?ITabBarOb_OpenTabError@CTabBarWnd@@UAEXH@Z	; CTabBarWnd::ITabBarOb_OpenTabError
PUBLIC	?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z	; CWnd::DoDataExchange
PUBLIC	?BeginModalState@CWnd@@UAEXXZ			; CWnd::BeginModalState
PUBLIC	?EndModalState@CWnd@@UAEXXZ			; CWnd::EndModalState
PUBLIC	??0?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ; std::vector<CRect,std::allocator<CRect> >::vector<CRect,std::allocator<CRect> >
EXTRN	?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z:NEAR ; CWnd::CreateControlContainer
EXTRN	?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z:NEAR ; CWnd::CreateControlSite
EXTRN	?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:NEAR ; CWnd::SetOccDialogInfo
EXTRN	?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z:NEAR ; CWnd::OnToolHitTest
EXTRN	?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z:NEAR ; CWnd::GetScrollBarCtrl
EXTRN	?WinHelpA@CWnd@@UAEXKI@Z:NEAR			; CWnd::WinHelpA
EXTRN	?HtmlHelpA@CWnd@@UAEXKI@Z:NEAR			; CWnd::HtmlHelpA
EXTRN	?WinHelpInternal@CWnd@@UAEXKI@Z:NEAR		; CWnd::WinHelpInternal
EXTRN	?ContinueModal@CWnd@@UAEHXZ:NEAR		; CWnd::ContinueModal
EXTRN	?EndModalLoop@CWnd@@UAEXH@Z:NEAR		; CWnd::EndModalLoop
EXTRN	?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ:NEAR ; CWnd::GetInterfaceMap
EXTRN	??_ECTabBarWnd@@UAEPAXI@Z:NEAR			; CTabBarWnd::`vector deleting destructor'
EXTRN	?EnsureStdObj@CWnd@@UAEJXZ:NEAR			; CWnd::EnsureStdObj
EXTRN	?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z:NEAR ; CWnd::get_accParent
EXTRN	?get_accChildCount@CWnd@@UAEJPAJ@Z:NEAR		; CWnd::get_accChildCount
EXTRN	?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:NEAR ; CCmdTarget::OnCmdMsg
EXTRN	?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z:NEAR ; CWnd::get_accChild
EXTRN	?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z:NEAR	; CCmdTarget::IsInvokeAllowed
EXTRN	?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accName
EXTRN	?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accValue
EXTRN	?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accDescription
EXTRN	?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z:NEAR ; CCmdTarget::GetDispatchIID
EXTRN	?GetTypeInfoCount@CCmdTarget@@UAEIXZ:NEAR	; CCmdTarget::GetTypeInfoCount
EXTRN	?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ:NEAR ; CCmdTarget::GetTypeLibCache
EXTRN	?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:NEAR ; CWnd::get_accRole
EXTRN	?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z:NEAR ; CCmdTarget::GetTypeLib
EXTRN	?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:NEAR ; CWnd::get_accState
EXTRN	?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accHelp
EXTRN	?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z:NEAR ; CWnd::get_accHelpTopic
EXTRN	?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accKeyboardShortcut
EXTRN	?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z:NEAR	; CWnd::get_accFocus
EXTRN	?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z:NEAR ; CWnd::get_accSelection
EXTRN	?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:NEAR ; CWnd::get_accDefaultAction
EXTRN	?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ:NEAR ; CCmdTarget::GetCommandMap
EXTRN	?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z:NEAR	; CWnd::accSelect
EXTRN	?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z:NEAR ; CWnd::accLocation
EXTRN	?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ:NEAR ; CCmdTarget::GetDispatchMap
EXTRN	?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z:NEAR ; CWnd::accNavigate
EXTRN	?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z:NEAR	; CWnd::accHitTest
EXTRN	?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ:NEAR ; CCmdTarget::GetConnectionMap
EXTRN	?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z:NEAR ; CWnd::accDoDefaultAction
EXTRN	?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z:NEAR	; CWnd::put_accName
EXTRN	?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z:NEAR ; CWnd::put_accValue
EXTRN	?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z:NEAR ; CWnd::SetProxy
EXTRN	?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z:NEAR	; CWnd::CreateAccessibleProxy
EXTRN	?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ:NEAR ; CCmdTarget::GetEventSinkMap
EXTRN	?OnCreateAggregates@CCmdTarget@@UAEHXZ:NEAR	; CCmdTarget::OnCreateAggregates
EXTRN	?OnCommand@CWnd@@MAEHIJ@Z:NEAR			; CWnd::OnCommand
EXTRN	?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z:NEAR ; CCmdTarget::GetInterfaceHook
EXTRN	?OnNotify@CWnd@@MAEHIJPAJ@Z:NEAR		; CWnd::OnNotify
EXTRN	?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z:NEAR ; CCmdTarget::GetExtraConnectionPoints
EXTRN	?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z:NEAR ; CCmdTarget::GetConnectionHook
EXTRN	_memset:NEAR
EXTRN	_strcpy:NEAR
EXTRN	??0CBasicWnd@@QAE@XZ:NEAR			; CBasicWnd::CBasicWnd
EXTRN	??1CBasicWnd@@UAE@XZ:NEAR			; CBasicWnd::~CBasicWnd
EXTRN	?PreSubclassWindow@CWnd@@UAEXXZ:NEAR		; CWnd::PreSubclassWindow
EXTRN	?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z:NEAR ; CWnd::Create
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z:NEAR ; CWnd::CreateEx
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z:NEAR ; CWnd::CreateEx
EXTRN	__except_list:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?DestroyWindow@CWnd@@UAEHXZ:NEAR		; CWnd::DestroyWindow
EXTRN	?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z:NEAR ; CWnd::PreCreateWindow
EXTRN	?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z:NEAR	; CWnd::CalcWindowRect
EXTRN	?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ:NEAR ; CWnd::GetSuperWndProcAddr
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z:NEAR ; CWnd::PreTranslateMessage
EXTRN	?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z:NEAR ; CWnd::OnAmbientProperty
EXTRN	?WindowProc@CWnd@@MAEJIIJ@Z:NEAR		; CWnd::WindowProc
EXTRN	?OnWndMsg@CWnd@@MAEHIIJPAJ@Z:NEAR		; CWnd::OnWndMsg
EXTRN	?DefWindowProcA@CWnd@@MAEJIIJ@Z:NEAR		; CWnd::DefWindowProcA
EXTRN	?PostNcDestroy@CWnd@@MAEXXZ:NEAR		; CWnd::PostNcDestroy
EXTRN	?OnChildNotify@CWnd@@MAEHIIJPAJ@Z:NEAR		; CWnd::OnChildNotify
EXTRN	?AfxGetMessageManager@@YAPAVIMessageManager@@XZ:NEAR ; AfxGetMessageManager
EXTRN	?CheckAutoCenter@CWnd@@UAEHXZ:NEAR		; CWnd::CheckAutoCenter
EXTRN	?IsFrameWnd@CWnd@@UBEHXZ:NEAR			; CWnd::IsFrameWnd
EXTRN	?OnFinalRelease@CWnd@@UAEXXZ:NEAR		; CWnd::OnFinalRelease
EXTRN	??0CCWToolTips@@QAE@XZ:NEAR			; CCWToolTips::CCWToolTips
xdata$x	SEGMENT
$T201599 DD	0ffffffffH
	DD	FLAT:$L201581
	DD	00H
	DD	FLAT:$L201582
	DD	01H
	DD	FLAT:$L201583
	DD	02H
	DD	FLAT:$L201584
	DD	03H
	DD	FLAT:$L201585
	DD	04H
	DD	FLAT:$L201586
	DD	05H
	DD	FLAT:$L201587
	DD	06H
	DD	FLAT:$L201588
	DD	07H
	DD	FLAT:$L201589
$T201593 DD	019930520H
	DD	09H
	DD	FLAT:$T201599
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CTabBarWnd@@6BCBasicWnd@@@
CONST	SEGMENT
??_7CTabBarWnd@@6BCBasicWnd@@@ DD FLAT:??_R4CTabBarWnd@@6BCBasicWnd@@@ ; CTabBarWnd::`vftable'
	DD	FLAT:?GetRuntimeClass@CTabBarWnd@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECTabBarWnd@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CTabBarWnd@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?CheckAutoCenter@CWnd@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
CONST	ENDS
;	COMDAT ??_7CTabBarWnd@@6BCBasicSkinWnd@@@
CONST	SEGMENT
??_7CTabBarWnd@@6BCBasicSkinWnd@@@ DD FLAT:??_R4CTabBarWnd@@6BCBasicSkinWnd@@@ ; CTabBarWnd::`vftable'
	DD	FLAT:??_ECTabBarWnd@@WFE@AEPAXI@Z
	DD	FLAT:?LoadSkin@CTabBarWnd@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7CTabBarWnd@@6BITabBarObserver@@@
CONST	SEGMENT
??_7CTabBarWnd@@6BITabBarObserver@@@ DD FLAT:??_R4CTabBarWnd@@6BITabBarObserver@@@ ; CTabBarWnd::`vftable'
	DD	FLAT:??_ECTabBarWnd@@WFI@AEPAXI@Z
	DD	FLAT:?ITabBarOb_CreateNewTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBarOb_OpenExistTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBarOb_DelTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBarOb_OpenTabError@CTabBarWnd@@UAEXH@Z
CONST	ENDS
;	COMDAT ??_R4CTabBarWnd@@6BCBasicWnd@@@
rdata$r	SEGMENT
??_R4CTabBarWnd@@6BCBasicWnd@@@ DD 00H			; CTabBarWnd::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTabBarWnd@@@8
	DD	FLAT:??_R3CTabBarWnd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTabBarWnd@@@8
_DATA	SEGMENT
??_R0?AVCTabBarWnd@@@8 DD FLAT:??_7type_info@@6B@	; CTabBarWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTabBarWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CTabBarWnd@@8
rdata$r	SEGMENT
??_R3CTabBarWnd@@8 DD 00H				; CTabBarWnd::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	08H
	DD	FLAT:??_R2CTabBarWnd@@8
rdata$r	ENDS
;	COMDAT ??_R2CTabBarWnd@@8
rdata$r	SEGMENT
??_R2CTabBarWnd@@8 DD FLAT:??_R1A@?0A@A@CTabBarWnd@@8	; CTabBarWnd::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CBasicWnd@@8
	DD	FLAT:??_R1A@?0A@A@CWnd@@8
	DD	FLAT:??_R1A@?0A@A@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
	DD	FLAT:??_R1FE@?0A@A@CBasicSkinWnd@@8
	DD	FLAT:??_R1FI@?0A@A@ITabBarObserver@@8
	DD	FLAT:??_R1FI@?0A@A@IMessageObserver@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTabBarWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CTabBarWnd@@8 DD FLAT:??_R0?AVCTabBarWnd@@@8 ; CTabBarWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	07H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBasicWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CBasicWnd@@8 DD FLAT:??_R0?AVCBasicWnd@@@8	; CBasicWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCBasicWnd@@@8
_DATA	SEGMENT
??_R0?AVCBasicWnd@@@8 DD FLAT:??_7type_info@@6B@	; CBasicWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBasicWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CWnd@@8 DD FLAT:??_R0?AVCWnd@@@8		; CWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCWnd@@@8
_DATA	SEGMENT
??_R0?AVCWnd@@@8 DD FLAT:??_7type_info@@6B@		; CWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CCmdTarget@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CCmdTarget@@8 DD FLAT:??_R0?AVCCmdTarget@@@8 ; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
_DATA	SEGMENT
??_R0?AVCCmdTarget@@@8 DD FLAT:??_7type_info@@6B@	; CCmdTarget `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCmdTarget@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
_DATA	ENDS
;	COMDAT ??_R1FE@?0A@A@CBasicSkinWnd@@8
rdata$r	SEGMENT
??_R1FE@?0A@A@CBasicSkinWnd@@8 DD FLAT:??_R0?AVCBasicSkinWnd@@@8 ; CBasicSkinWnd::`RTTI Base Class Descriptor at (84,-1,0,0)'
	DD	00H
	DD	054H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCBasicSkinWnd@@@8
_DATA	SEGMENT
??_R0?AVCBasicSkinWnd@@@8 DD FLAT:??_7type_info@@6B@	; CBasicSkinWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBasicSkinWnd@@', 00H
	ORG $-28
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVCBasicSkinWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R1FI@?0A@A@ITabBarObserver@@8
rdata$r	SEGMENT
??_R1FI@?0A@A@ITabBarObserver@@8 DD FLAT:??_R0?AVITabBarObserver@@@8 ; ITabBarObserver::`RTTI Base Class Descriptor at (88,-1,0,0)'
	DD	01H
	DD	058H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVITabBarObserver@@@8
_DATA	SEGMENT
??_R0?AVITabBarObserver@@@8 DD FLAT:??_7type_info@@6B@	; ITabBarObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVITabBarObserver@@', 00H
_DATA	ENDS
;	COMDAT ??_R1FI@?0A@A@IMessageObserver@@8
rdata$r	SEGMENT
??_R1FI@?0A@A@IMessageObserver@@8 DD FLAT:??_R0?AVIMessageObserver@@@8 ; IMessageObserver::`RTTI Base Class Descriptor at (88,-1,0,0)'
	DD	00H
	DD	058H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT
??_R0?AVIMessageObserver@@@8 DD FLAT:??_7type_info@@6B@	; IMessageObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIMessageObserver@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVIMessageObserver@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CTabBarWnd@@6BCBasicSkinWnd@@@
rdata$r	SEGMENT
??_R4CTabBarWnd@@6BCBasicSkinWnd@@@ DD 00H		; CTabBarWnd::`RTTI Complete Object Locator'
	DD	054H
	DD	00H
	DD	FLAT:??_R0?AVCTabBarWnd@@@8
	DD	FLAT:??_R3CTabBarWnd@@8
rdata$r	ENDS
;	COMDAT ??_R4CTabBarWnd@@6BITabBarObserver@@@
rdata$r	SEGMENT
??_R4CTabBarWnd@@6BITabBarObserver@@@ DD 00H		; CTabBarWnd::`RTTI Complete Object Locator'
	DD	058H
	DD	00H
	DD	FLAT:??_R0?AVCTabBarWnd@@@8
	DD	FLAT:??_R3CTabBarWnd@@8
; Function compile flags: /Odt
rdata$r	ENDS
_TEXT	SEGMENT
tv220 = -100						; size = 4
tv226 = -96						; size = 4
tv218 = -92						; size = 4
_this$ = -88						; size = 4
$T201576 = -84						; size = 4
$T201575 = -80						; size = 4
_lf$ = -76						; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
??0CTabBarWnd@@QAE@XZ PROC NEAR				; CTabBarWnd::CTabBarWnd
; _this$ = ecx

; 15   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	6a ff		 push	 -1
  00025	68 00 00 00 00	 push	 __ehhandler$??0CTabBarWnd@@QAE@XZ
  0002a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00030	50		 push	 eax
  00031	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00038	83 ec 58	 sub	 esp, 88			; 00000058H
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00040	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00043	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx
  00046	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??0CBasicWnd@@QAE@XZ	; CBasicWnd::CBasicWnd
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 54	 add	 ecx, 84			; 00000054H
  0005b	e8 00 00 00 00	 call	 ??0CBasicSkinWnd@@QAE@XZ
  00060	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00064	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	83 c1 58	 add	 ecx, 88			; 00000058H
  0006a	e8 00 00 00 00	 call	 ??0ITabBarObserver@@QAE@XZ
  0006f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00073	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00076	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTabBarWnd@@6BCBasicWnd@@@
  0007c	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET FLAT:??_7CTabBarWnd@@6BCBasicSkinWnd@@@
  00086	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00089	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], OFFSET FLAT:??_7CTabBarWnd@@6BITabBarObserver@@@
  00090	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	83 c1 60	 add	 ecx, 96			; 00000060H
  00096	e8 00 00 00 00	 call	 ??0CFont@@QAE@XZ	; CFont::CFont
  0009b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0009f	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	83 c1 68	 add	 ecx, 104		; 00000068H
  000a5	e8 00 00 00 00	 call	 ??0CFont@@QAE@XZ	; CFont::CFont
  000aa	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000ae	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	83 c1 70	 add	 ecx, 112		; 00000070H
  000b4	e8 00 00 00 00	 call	 ??0?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ; std::vector<CRect,std::allocator<CRect> >::vector<CRect,std::allocator<CRect> >
  000b9	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000bd	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000c6	e8 00 00 00 00	 call	 ??0?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ; std::vector<CRect,std::allocator<CRect> >::vector<CRect,std::allocator<CRect> >
  000cb	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  000cf	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  000d8	e8 00 00 00 00	 call	 ??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >
  000dd	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  000e1	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  000ea	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 16   : 	m_iTabCur    = -1;

  000ef	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	c7 80 b4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+180], -1

; 17   : 	m_iTabOver   = -1;

  000fc	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	c7 81 b8 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+184], -1

; 18   : 	m_iCloseOver = -1;

  00109	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  0010c	c7 82 bc 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+188], -1

; 19   : 	m_bOverNewWindow = false;

  00116	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00119	c6 80 b0 00 00
	00 00		 mov	 BYTE PTR [eax+176], 0

; 20   : 
; 21   : 	m_pBmpRectNormalLeft   = NULL;

  00120	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	c7 81 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+204], 0

; 22   : 	m_pBmpRectNormalMiddle = NULL;

  0012d	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00130	c7 82 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+208], 0

; 23   : 	m_pBmpRectNormalRight  = NULL;

  0013a	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0013d	c7 80 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+212], 0

; 24   : 
; 25   : 	m_pBmpRectOverLeft   = NULL;

  00147	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	c7 81 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+216], 0

; 26   : 	m_pBmpRectOverMiddle = NULL;

  00154	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00157	c7 82 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+220], 0

; 27   : 	m_pBmpRectOverRight  = NULL;

  00161	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00164	c7 80 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+224], 0

; 28   : 
; 29   : 	m_pBmpRectDownLeft   = NULL;

  0016e	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	c7 81 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+228], 0

; 30   : 	m_pBmpRectDownMiddle = NULL;

  0017b	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  0017e	c7 82 e8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+232], 0

; 31   : 	m_pBmpRectDownRight  = NULL;

  00188	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0018b	c7 80 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+236], 0

; 32   : 
; 33   : 	m_pBmpCloseNormal = NULL;

  00195	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	c7 81 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+240], 0

; 34   : 	m_pBmpCloseOver   = NULL;

  001a2	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  001a5	c7 82 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+244], 0

; 35   : 	m_pBmpCloseDown	  = NULL;

  001af	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	c7 80 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+248], 0

; 36   : 
; 37   : 	m_pBmpSelCloseNormal = NULL;

  001bc	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  001bf	c7 81 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+252], 0

; 38   : 	m_pBmpSelCloseOver   = NULL;

  001c9	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  001cc	c7 82 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+256], 0

; 39   : 	m_pBmpSelCloseDown   = NULL;

  001d6	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001d9	c7 80 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+260], 0

; 40   : 
; 41   : 	m_pBmpNewWindowNormal = NULL;

  001e3	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e6	c7 81 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+264], 0

; 42   : 	m_pBmpNewWindowOver   = NULL;

  001f0	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  001f3	c7 82 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+268], 0

; 43   : 	m_pBmpNewWindowDown   = NULL;

  001fd	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00200	c7 80 10 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+272], 0

; 44   : 
; 45   : 	m_colNormalTextColor = RGB(205,205,205);

  0020a	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0020d	c7 81 c0 00 00
	00 cd cd cd 00	 mov	 DWORD PTR [ecx+192], 13487565 ; 00cdcdcdH

; 46   : 	m_colDownTextColor	 = RGB(255,175,38);

  00217	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  0021a	c7 82 c4 00 00
	00 ff af 26 00	 mov	 DWORD PTR [edx+196], 2535423 ; 0026afffH

; 47   : 	m_colMask            = RGB(0,255,0);

  00224	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00227	c7 80 c8 00 00
	00 00 ff 00 00	 mov	 DWORD PTR [eax+200], 65280 ; 0000ff00H

; 48   : 
; 49   : 	ZeroMemory( &m_bmih, sizeof( BITMAPINFOHEADER ) ); 

  00231	6a 28		 push	 40			; 00000028H
  00233	6a 00		 push	 0
  00235	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00238	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  0023e	51		 push	 ecx
  0023f	e8 00 00 00 00	 call	 _memset
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH

; 50   : 	m_bmih.biSize                  = sizeof (BITMAPINFOHEADER) ; 

  00247	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  0024a	c7 82 14 01 00
	00 28 00 00 00	 mov	 DWORD PTR [edx+276], 40	; 00000028H

; 51   : 	m_bmih.biPlanes                = 1 ; 

  00254	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00257	66 c7 80 20 01
	00 00 01 00	 mov	 WORD PTR [eax+288], 1

; 52   : 	m_bmih.biBitCount              = 32;        //32 

  00260	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00263	66 c7 81 22 01
	00 00 20 00	 mov	 WORD PTR [ecx+290], 32	; 00000020H

; 53   : 	m_bmih.biCompression          = BI_RGB ; 

  0026c	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  0026f	c7 82 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+292], 0

; 54   : 	m_bmih.biSizeImage            = 0 ; 

  00279	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0027c	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 55   : 	m_bmih.biXPelsPerMeter        = 0 ; 

  00286	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00289	c7 81 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+300], 0

; 56   : 	m_bmih.biYPelsPerMeter        = 0 ; 

  00293	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00296	c7 82 30 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+304], 0

; 57   : 	m_bmih.biClrUsed              = 0 ; 

  002a0	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  002a3	c7 80 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+308], 0

; 58   : 	m_bmih.biClrImportant         = 0 ; 

  002ad	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b0	c7 81 38 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+312], 0

; 59   : 
; 60   : 	//
; 61   : 	LOGFONT  lf;
; 62   : 	ZeroMemory(&lf,sizeof(lf));

  002ba	6a 3c		 push	 60			; 0000003cH
  002bc	6a 00		 push	 0
  002be	8d 55 b4	 lea	 edx, DWORD PTR _lf$[ebp]
  002c1	52		 push	 edx
  002c2	e8 00 00 00 00	 call	 _memset
  002c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 63   : 
; 64   : 	lf.lfHeight = 12;

  002ca	c7 45 b4 0c 00
	00 00		 mov	 DWORD PTR _lf$[ebp], 12	; 0000000cH

; 65   : 	lf.lfWidth  = 0;

  002d1	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _lf$[ebp+4], 0

; 66   : 	lf.lfCharSet = GB2312_CHARSET;

  002d8	c6 45 cb 86	 mov	 BYTE PTR _lf$[ebp+23], 134 ; 00000086H

; 67   : 	lf.lfStrikeOut = FALSE;

  002dc	c6 45 ca 00	 mov	 BYTE PTR _lf$[ebp+22], 0

; 68   : 	lf.lfOutPrecision = OUT_DEFAULT_PRECIS;

  002e0	c6 45 cc 00	 mov	 BYTE PTR _lf$[ebp+24], 0

; 69   : 	lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;

  002e4	c6 45 cd 00	 mov	 BYTE PTR _lf$[ebp+25], 0

; 70   : 	lf.lfQuality = DEFAULT_QUALITY;

  002e8	c6 45 ce 00	 mov	 BYTE PTR _lf$[ebp+26], 0

; 71   : 	lf.lfPitchAndFamily = FF_DONTCARE | DEFAULT_PITCH;

  002ec	c6 45 cf 00	 mov	 BYTE PTR _lf$[ebp+27], 0

; 72   : 	lf.lfUnderline = false;

  002f0	c6 45 c9 00	 mov	 BYTE PTR _lf$[ebp+21], 0

; 73   : 	strcpy(lf.lfFaceName, "");

  002f4	68 00 00 00 00	 push	 OFFSET FLAT:$SG199761
  002f9	8d 45 d0	 lea	 eax, DWORD PTR _lf$[ebp+28]
  002fc	50		 push	 eax
  002fd	e8 00 00 00 00	 call	 _strcpy
  00302	83 c4 08	 add	 esp, 8

; 74   : 
; 75   : 	lf.lfWeight = FW_NORMAL;

  00305	c7 45 c4 90 01
	00 00		 mov	 DWORD PTR _lf$[ebp+16], 400 ; 00000190H

; 76   : 	m_fontNormal.CreateFontIndirect(&lf);

  0030c	8d 4d b4	 lea	 ecx, DWORD PTR _lf$[ebp]
  0030f	51		 push	 ecx
  00310	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00313	83 c1 60	 add	 ecx, 96			; 00000060H
  00316	e8 00 00 00 00	 call	 ?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z ; CFont::CreateFontIndirectA

; 77   : 
; 78   : 	lf.lfWeight = FW_BOLD;

  0031b	c7 45 c4 bc 02
	00 00		 mov	 DWORD PTR _lf$[ebp+16], 700 ; 000002bcH

; 79   : 	m_fontDown.CreateFontIndirect(&lf);

  00322	8d 55 b4	 lea	 edx, DWORD PTR _lf$[ebp]
  00325	52		 push	 edx
  00326	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00329	83 c1 68	 add	 ecx, 104		; 00000068H
  0032c	e8 00 00 00 00	 call	 ?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z ; CFont::CreateFontIndirectA

; 80   : 
; 81   : 	m_pToolTip = new CCWToolTips();

  00331	68 90 00 00 00	 push	 144			; 00000090H
  00336	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  0033b	89 45 ac	 mov	 DWORD PTR $T201576[ebp], eax
  0033e	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00342	83 7d ac 00	 cmp	 DWORD PTR $T201576[ebp], 0
  00346	74 0d		 je	 SHORT $L201577
  00348	8b 4d ac	 mov	 ecx, DWORD PTR $T201576[ebp]
  0034b	e8 00 00 00 00	 call	 ??0CCWToolTips@@QAE@XZ	; CCWToolTips::CCWToolTips
  00350	89 45 a4	 mov	 DWORD PTR tv218[ebp], eax
  00353	eb 07		 jmp	 SHORT $L201578
$L201577:
  00355	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv218[ebp], 0
$L201578:
  0035c	8b 45 a4	 mov	 eax, DWORD PTR tv218[ebp]
  0035f	89 45 b0	 mov	 DWORD PTR $T201575[ebp], eax
  00362	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00366	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00369	8b 55 b0	 mov	 edx, DWORD PTR $T201575[ebp]
  0036c	89 51 5c	 mov	 DWORD PTR [ecx+92], edx

; 82   : 
; 83   : 	AfxGetMessageManager()->AttachMessage( ID_MESSAGE_TABBAR,(ITabBarObserver*) this);

  0036f	83 7d a8 00	 cmp	 DWORD PTR _this$[ebp], 0
  00373	74 0b		 je	 SHORT $L201579
  00375	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00378	83 c0 58	 add	 eax, 88			; 00000058H
  0037b	89 45 a0	 mov	 DWORD PTR tv226[ebp], eax
  0037e	eb 07		 jmp	 SHORT $L201580
$L201579:
  00380	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv226[ebp], 0
$L201580:
  00387	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  0038c	89 45 9c	 mov	 DWORD PTR tv220[ebp], eax
  0038f	6a 02		 push	 2
  00391	8b 4d a0	 mov	 ecx, DWORD PTR tv226[ebp]
  00394	51		 push	 ecx
  00395	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  0039a	8b 55 9c	 mov	 edx, DWORD PTR tv220[ebp]
  0039d	8b 02		 mov	 eax, DWORD PTR [edx]
  0039f	8b 4d 9c	 mov	 ecx, DWORD PTR tv220[ebp]
  003a2	ff 50 04	 call	 DWORD PTR [eax+4]

; 84   : }

  003a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003ac	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  003af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  003b9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c1	8b e5		 mov	 esp, ebp
  003c3	5d		 pop	 ebp
  003c4	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L201581:
  00000	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CBasicWnd@@UAE@XZ	; CBasicWnd::~CBasicWnd
$L201582:
  00008	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 54	 add	 ecx, 84			; 00000054H
  0000e	e9 00 00 00 00	 jmp	 ??1CBasicSkinWnd@@UAE@XZ ; CBasicSkinWnd::~CBasicSkinWnd
$L201583:
  00013	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 58	 add	 ecx, 88			; 00000058H
  00019	e9 00 00 00 00	 jmp	 ??1ITabBarObserver@@UAE@XZ
$L201584:
  0001e	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 60	 add	 ecx, 96			; 00000060H
  00024	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
$L201585:
  00029	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 68	 add	 ecx, 104		; 00000068H
  0002f	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
$L201586:
  00034	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 70	 add	 ecx, 112		; 00000070H
  0003a	e9 00 00 00 00	 jmp	 ??1?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ; std::vector<CRect,std::allocator<CRect> >::~vector<CRect,std::allocator<CRect> >
$L201587:
  0003f	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00048	e9 00 00 00 00	 jmp	 ??1?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ; std::vector<CRect,std::allocator<CRect> >::~vector<CRect,std::allocator<CRect> >
$L201588:
  0004d	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00056	e9 00 00 00 00	 jmp	 ??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >
$L201589:
  0005b	8b 45 ac	 mov	 eax, DWORD PTR $T201576[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00064	c3		 ret	 0
__ehhandler$??0CTabBarWnd@@QAE@XZ:
  00065	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201593
  0006a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CTabBarWnd@@QAE@XZ ENDP				; CTabBarWnd::CTabBarWnd
PUBLIC	??1CTabBarWnd@@UAE@XZ				; CTabBarWnd::~CTabBarWnd
; Function compile flags: /Odt
;	COMDAT ??_GCTabBarWnd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTabBarWnd@@UAEPAXI@Z PROC NEAR			; CTabBarWnd::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTabBarWnd@@UAE@XZ	; CTabBarWnd::~CTabBarWnd
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L199770
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L199770:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCTabBarWnd@@UAEPAXI@Z ENDP				; CTabBarWnd::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4CBasicSkinWnd@@6B@				; CBasicSkinWnd::`RTTI Complete Object Locator'
PUBLIC	??_R3CBasicSkinWnd@@8				; CBasicSkinWnd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBasicSkinWnd@@8				; CBasicSkinWnd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CBasicSkinWnd@@8			; CBasicSkinWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_7CBasicSkinWnd@@6B@				; CBasicSkinWnd::`vftable'
PUBLIC	??_GCBasicSkinWnd@@UAEPAXI@Z			; CBasicSkinWnd::`scalar deleting destructor'
EXTRN	__purecall:NEAR
EXTRN	??_ECBasicSkinWnd@@UAEPAXI@Z:NEAR		; CBasicSkinWnd::`vector deleting destructor'
;	COMDAT ??_7CBasicSkinWnd@@6B@
CONST	SEGMENT
??_7CBasicSkinWnd@@6B@ DD FLAT:??_R4CBasicSkinWnd@@6B@	; CBasicSkinWnd::`vftable'
	DD	FLAT:??_ECBasicSkinWnd@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4CBasicSkinWnd@@6B@
rdata$r	SEGMENT
??_R4CBasicSkinWnd@@6B@ DD 00H				; CBasicSkinWnd::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBasicSkinWnd@@@8
	DD	FLAT:??_R3CBasicSkinWnd@@8
rdata$r	ENDS
;	COMDAT ??_R3CBasicSkinWnd@@8
rdata$r	SEGMENT
??_R3CBasicSkinWnd@@8 DD 00H				; CBasicSkinWnd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CBasicSkinWnd@@8
rdata$r	ENDS
;	COMDAT ??_R2CBasicSkinWnd@@8
rdata$r	SEGMENT
??_R2CBasicSkinWnd@@8 DD FLAT:??_R1A@?0A@A@CBasicSkinWnd@@8 ; CBasicSkinWnd::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBasicSkinWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CBasicSkinWnd@@8 DD FLAT:??_R0?AVCBasicSkinWnd@@@8 ; CBasicSkinWnd::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CBasicSkinWnd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CBasicSkinWnd@@QAE@XZ PROC NEAR			; CBasicSkinWnd::CBasicSkinWnd, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBasicSkinWnd@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0CBasicSkinWnd@@QAE@XZ ENDP				; CBasicSkinWnd::CBasicSkinWnd
_TEXT	ENDS
PUBLIC	??_R4ITabBarObserver@@6B@			; ITabBarObserver::`RTTI Complete Object Locator'
PUBLIC	??_R3ITabBarObserver@@8				; ITabBarObserver::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITabBarObserver@@8				; ITabBarObserver::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@ITabBarObserver@@8			; ITabBarObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@IMessageObserver@@8		; IMessageObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_7ITabBarObserver@@6B@			; ITabBarObserver::`vftable'
PUBLIC	??_GITabBarObserver@@UAEPAXI@Z			; ITabBarObserver::`scalar deleting destructor'
PUBLIC	??0IMessageObserver@@QAE@XZ			; IMessageObserver::IMessageObserver
EXTRN	??_EITabBarObserver@@UAEPAXI@Z:NEAR		; ITabBarObserver::`vector deleting destructor'
;	COMDAT ??_7ITabBarObserver@@6B@
CONST	SEGMENT
??_7ITabBarObserver@@6B@ DD FLAT:??_R4ITabBarObserver@@6B@ ; ITabBarObserver::`vftable'
	DD	FLAT:??_EITabBarObserver@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4ITabBarObserver@@6B@
rdata$r	SEGMENT
??_R4ITabBarObserver@@6B@ DD 00H			; ITabBarObserver::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVITabBarObserver@@@8
	DD	FLAT:??_R3ITabBarObserver@@8
rdata$r	ENDS
;	COMDAT ??_R3ITabBarObserver@@8
rdata$r	SEGMENT
??_R3ITabBarObserver@@8 DD 00H				; ITabBarObserver::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITabBarObserver@@8
rdata$r	ENDS
;	COMDAT ??_R2ITabBarObserver@@8
rdata$r	SEGMENT
??_R2ITabBarObserver@@8 DD FLAT:??_R1A@?0A@A@ITabBarObserver@@8 ; ITabBarObserver::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@IMessageObserver@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ITabBarObserver@@8
rdata$r	SEGMENT
??_R1A@?0A@A@ITabBarObserver@@8 DD FLAT:??_R0?AVITabBarObserver@@@8 ; ITabBarObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IMessageObserver@@8
rdata$r	SEGMENT
??_R1A@?0A@A@IMessageObserver@@8 DD FLAT:??_R0?AVIMessageObserver@@@8 ; IMessageObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0ITabBarObserver@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ITabBarObserver@@QAE@XZ PROC NEAR			; ITabBarObserver::ITabBarObserver, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IMessageObserver@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ITabBarObserver@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0ITabBarObserver@@QAE@XZ ENDP				; ITabBarObserver::ITabBarObserver
_TEXT	ENDS
PUBLIC	??1IMessageObserver@@UAE@XZ			; IMessageObserver::~IMessageObserver
; Function compile flags: /Odt
;	COMDAT ??1ITabBarObserver@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ITabBarObserver@@UAE@XZ PROC NEAR			; ITabBarObserver::~ITabBarObserver, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1IMessageObserver@@UAE@XZ ; IMessageObserver::~IMessageObserver
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1ITabBarObserver@@UAE@XZ ENDP				; ITabBarObserver::~ITabBarObserver
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt
;	COMDAT ??_GITabBarObserver@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GITabBarObserver@@UAEPAXI@Z PROC NEAR		; ITabBarObserver::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1ITabBarObserver@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L199780
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L199780:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GITabBarObserver@@UAEPAXI@Z ENDP			; ITabBarObserver::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4IMessageObserver@@6B@			; IMessageObserver::`RTTI Complete Object Locator'
PUBLIC	??_R3IMessageObserver@@8			; IMessageObserver::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IMessageObserver@@8			; IMessageObserver::`RTTI Base Class Array'
PUBLIC	??_7IMessageObserver@@6B@			; IMessageObserver::`vftable'
PUBLIC	??_GIMessageObserver@@UAEPAXI@Z			; IMessageObserver::`scalar deleting destructor'
EXTRN	??_EIMessageObserver@@UAEPAXI@Z:NEAR		; IMessageObserver::`vector deleting destructor'
;	COMDAT ??_7IMessageObserver@@6B@
CONST	SEGMENT
??_7IMessageObserver@@6B@ DD FLAT:??_R4IMessageObserver@@6B@ ; IMessageObserver::`vftable'
	DD	FLAT:??_EIMessageObserver@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4IMessageObserver@@6B@
rdata$r	SEGMENT
??_R4IMessageObserver@@6B@ DD 00H			; IMessageObserver::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIMessageObserver@@@8
	DD	FLAT:??_R3IMessageObserver@@8
rdata$r	ENDS
;	COMDAT ??_R3IMessageObserver@@8
rdata$r	SEGMENT
??_R3IMessageObserver@@8 DD 00H				; IMessageObserver::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IMessageObserver@@8
rdata$r	ENDS
;	COMDAT ??_R2IMessageObserver@@8
rdata$r	SEGMENT
??_R2IMessageObserver@@8 DD FLAT:??_R1A@?0A@A@IMessageObserver@@8 ; IMessageObserver::`RTTI Base Class Array'
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0IMessageObserver@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IMessageObserver@@QAE@XZ PROC NEAR			; IMessageObserver::IMessageObserver, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IMessageObserver@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0IMessageObserver@@QAE@XZ ENDP			; IMessageObserver::IMessageObserver
_TEXT	ENDS
EXTRN	?DeleteObject@CGdiObject@@QAEHXZ:NEAR		; CGdiObject::DeleteObject
xdata$x	SEGMENT
$T201640 DD	0ffffffffH
	DD	FLAT:$L201625
	DD	00H
	DD	FLAT:$L201628
	DD	01H
	DD	FLAT:$L201631
	DD	02H
	DD	FLAT:$L201632
	DD	03H
	DD	FLAT:$L201633
	DD	04H
	DD	FLAT:$L201634
	DD	05H
	DD	FLAT:$L201635
	DD	06H
	DD	FLAT:$L201636
$T201638 DD	019930520H
	DD	08H
	DD	FLAT:$T201640
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv69 = -44						; size = 4
tv73 = -40						; size = 4
tv143 = -36						; size = 4
tv148 = -32						; size = 4
tv140 = -28						; size = 4
_this$ = -24						; size = 4
$T201620 = -20						; size = 4
$T201619 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CTabBarWnd@@UAE@XZ PROC NEAR				; CTabBarWnd::~CTabBarWnd
; _this$ = ecx

; 87   : {

  003d0	55		 push	 ebp
  003d1	8b ec		 mov	 ebp, esp
  003d3	6a ff		 push	 -1
  003d5	68 00 00 00 00	 push	 __ehhandler$??1CTabBarWnd@@UAE@XZ
  003da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  003e0	50		 push	 eax
  003e1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  003e8	83 ec 20	 sub	 esp, 32			; 00000020H
  003eb	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  003ee	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  003f1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTabBarWnd@@6BCBasicWnd@@@
  003f7	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  003fa	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET FLAT:??_7CTabBarWnd@@6BCBasicSkinWnd@@@
  00401	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00404	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], OFFSET FLAT:??_7CTabBarWnd@@6BITabBarObserver@@@
  0040b	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7

; 88   : 	m_fontNormal.DeleteObject();

  00412	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00415	83 c1 60	 add	 ecx, 96			; 00000060H
  00418	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject

; 89   : 	m_fontDown.DeleteObject();

  0041d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00420	83 c1 68	 add	 ecx, 104		; 00000068H
  00423	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject

; 90   : 	delete m_pToolTip;

  00428	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0042b	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0042e	89 4d ec	 mov	 DWORD PTR $T201620[ebp], ecx
  00431	8b 55 ec	 mov	 edx, DWORD PTR $T201620[ebp]
  00434	89 55 f0	 mov	 DWORD PTR $T201619[ebp], edx
  00437	83 7d f0 00	 cmp	 DWORD PTR $T201619[ebp], 0
  0043b	74 12		 je	 SHORT $L201621
  0043d	6a 01		 push	 1
  0043f	8b 45 f0	 mov	 eax, DWORD PTR $T201619[ebp]
  00442	8b 10		 mov	 edx, DWORD PTR [eax]
  00444	8b 4d f0	 mov	 ecx, DWORD PTR $T201619[ebp]
  00447	ff 52 04	 call	 DWORD PTR [edx+4]
  0044a	89 45 e4	 mov	 DWORD PTR tv140[ebp], eax
  0044d	eb 07		 jmp	 SHORT $L201622
$L201621:
  0044f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$L201622:

; 91   : 	AfxGetMessageManager()->DetachMessage( ID_MESSAGE_TABBAR,(ITabBarObserver*) this);

  00456	83 7d e8 00	 cmp	 DWORD PTR _this$[ebp], 0
  0045a	74 0b		 je	 SHORT $L201623
  0045c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0045f	83 c0 58	 add	 eax, 88			; 00000058H
  00462	89 45 e0	 mov	 DWORD PTR tv148[ebp], eax
  00465	eb 07		 jmp	 SHORT $L201624
$L201623:
  00467	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv148[ebp], 0
$L201624:
  0046e	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  00473	89 45 dc	 mov	 DWORD PTR tv143[ebp], eax
  00476	8b 4d e0	 mov	 ecx, DWORD PTR tv148[ebp]
  00479	51		 push	 ecx
  0047a	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  0047f	8b 55 dc	 mov	 edx, DWORD PTR tv143[ebp]
  00482	8b 02		 mov	 eax, DWORD PTR [edx]
  00484	8b 4d dc	 mov	 ecx, DWORD PTR tv143[ebp]
  00487	ff 50 08	 call	 DWORD PTR [eax+8]

; 92   : }

  0048a	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0048e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00491	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00497	e8 00 00 00 00	 call	 ??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >
  0049c	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  004a0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  004a3	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  004a9	e8 00 00 00 00	 call	 ??1?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ; std::vector<CRect,std::allocator<CRect> >::~vector<CRect,std::allocator<CRect> >
  004ae	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  004b2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  004b5	83 c1 70	 add	 ecx, 112		; 00000070H
  004b8	e8 00 00 00 00	 call	 ??1?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ; std::vector<CRect,std::allocator<CRect> >::~vector<CRect,std::allocator<CRect> >
  004bd	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  004c1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  004c4	83 c1 68	 add	 ecx, 104		; 00000068H
  004c7	e8 00 00 00 00	 call	 ??1CFont@@UAE@XZ	; CFont::~CFont
  004cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  004d0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  004d3	83 c1 60	 add	 ecx, 96			; 00000060H
  004d6	e8 00 00 00 00	 call	 ??1CFont@@UAE@XZ	; CFont::~CFont
  004db	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  004df	83 7d e8 00	 cmp	 DWORD PTR _this$[ebp], 0
  004e3	74 0b		 je	 SHORT $L201617
  004e5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  004e8	83 c1 58	 add	 ecx, 88			; 00000058H
  004eb	89 4d d8	 mov	 DWORD PTR tv73[ebp], ecx
  004ee	eb 07		 jmp	 SHORT $L201618
$L201617:
  004f0	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$L201618:
  004f7	8b 4d d8	 mov	 ecx, DWORD PTR tv73[ebp]
  004fa	e8 00 00 00 00	 call	 ??1ITabBarObserver@@UAE@XZ
  004ff	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00503	83 7d e8 00	 cmp	 DWORD PTR _this$[ebp], 0
  00507	74 0b		 je	 SHORT $L201615
  00509	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0050c	83 c2 54	 add	 edx, 84			; 00000054H
  0050f	89 55 d4	 mov	 DWORD PTR tv69[ebp], edx
  00512	eb 07		 jmp	 SHORT $L201616
$L201615:
  00514	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L201616:
  0051b	8b 4d d4	 mov	 ecx, DWORD PTR tv69[ebp]
  0051e	e8 00 00 00 00	 call	 ??1CBasicSkinWnd@@UAE@XZ ; CBasicSkinWnd::~CBasicSkinWnd
  00523	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0052a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0052d	e8 00 00 00 00	 call	 ??1CBasicWnd@@UAE@XZ	; CBasicWnd::~CBasicWnd
  00532	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00535	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0053c	8b e5		 mov	 esp, ebp
  0053e	5d		 pop	 ebp
  0053f	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L201625:
  0006f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e9 00 00 00 00	 jmp	 ??1CBasicWnd@@UAE@XZ	; CBasicWnd::~CBasicWnd
$L201628:
  00077	83 7d e8 00	 cmp	 DWORD PTR _this$[ebp], 0
  0007b	0f 84 0e 00 00
	00		 je	 $L201626
  00081	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	83 c0 54	 add	 eax, 84			; 00000054H
  00087	89 45 d4	 mov	 DWORD PTR tv69[ebp], eax
  0008a	e9 07 00 00 00	 jmp	 $L201627
$L201626:
  0008f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L201627:
  00096	8b 4d d4	 mov	 ecx, DWORD PTR tv69[ebp]
  00099	e9 00 00 00 00	 jmp	 ??1CBasicSkinWnd@@UAE@XZ ; CBasicSkinWnd::~CBasicSkinWnd
$L201631:
  0009e	83 7d e8 00	 cmp	 DWORD PTR _this$[ebp], 0
  000a2	0f 84 0e 00 00
	00		 je	 $L201629
  000a8	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	83 c0 58	 add	 eax, 88			; 00000058H
  000ae	89 45 d8	 mov	 DWORD PTR tv73[ebp], eax
  000b1	e9 07 00 00 00	 jmp	 $L201630
$L201629:
  000b6	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$L201630:
  000bd	8b 4d d8	 mov	 ecx, DWORD PTR tv73[ebp]
  000c0	e9 00 00 00 00	 jmp	 ??1ITabBarObserver@@UAE@XZ
$L201632:
  000c5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	83 c1 60	 add	 ecx, 96			; 00000060H
  000cb	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
$L201633:
  000d0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	83 c1 68	 add	 ecx, 104		; 00000068H
  000d6	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
$L201634:
  000db	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	83 c1 70	 add	 ecx, 112		; 00000070H
  000e1	e9 00 00 00 00	 jmp	 ??1?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ; std::vector<CRect,std::allocator<CRect> >::~vector<CRect,std::allocator<CRect> >
$L201635:
  000e6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000ef	e9 00 00 00 00	 jmp	 ??1?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ; std::vector<CRect,std::allocator<CRect> >::~vector<CRect,std::allocator<CRect> >
$L201636:
  000f4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  000fd	e9 00 00 00 00	 jmp	 ??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >
__ehhandler$??1CTabBarWnd@@UAE@XZ:
  00102	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201638
  00107	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CTabBarWnd@@UAE@XZ ENDP				; CTabBarWnd::~CTabBarWnd
PUBLIC	?GetThisMessageMap@CTabBarWnd@@KGPBUAFX_MSGMAP@@XZ ; CTabBarWnd::GetThisMessageMap
; Function compile flags: /Odt
_TEXT	SEGMENT
?GetThisMessageMap@CTabBarWnd@@KGPBUAFX_MSGMAP@@XZ PROC NEAR ; CTabBarWnd::GetThisMessageMap

; 94   : BEGIN_MESSAGE_MAP(CTabBarWnd, CBasicWnd)

  00540	55		 push	 ebp
  00541	8b ec		 mov	 ebp, esp
  00543	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?messageMap@CTabBarWnd@@1UAFX_MSGMAP@@B ; CTabBarWnd::messageMap
  00548	5d		 pop	 ebp
  00549	c3		 ret	 0
?GetThisMessageMap@CTabBarWnd@@KGPBUAFX_MSGMAP@@XZ ENDP	; CTabBarWnd::GetThisMessageMap
; Function compile flags: /Odt
_this$ = -4						; size = 4
?GetMessageMap@CTabBarWnd@@MBEPBUAFX_MSGMAP@@XZ PROC NEAR ; CTabBarWnd::GetMessageMap
; _this$ = ecx

; 94   : BEGIN_MESSAGE_MAP(CTabBarWnd, CBasicWnd)

  00550	55		 push	 ebp
  00551	8b ec		 mov	 ebp, esp
  00553	51		 push	 ecx
  00554	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00557	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?messageMap@CTabBarWnd@@1UAFX_MSGMAP@@B ; CTabBarWnd::messageMap
  0055c	8b e5		 mov	 esp, ebp
  0055e	5d		 pop	 ebp
  0055f	c3		 ret	 0
?GetMessageMap@CTabBarWnd@@MBEPBUAFX_MSGMAP@@XZ ENDP	; CTabBarWnd::GetMessageMap
_TEXT	ENDS
PUBLIC	??0CRect@@QAE@HHHH@Z				; CRect::CRect
PUBLIC	?GetParent@CWnd@@QBEPAV1@XZ			; CWnd::GetParent
PUBLIC	?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z	; CWnd::OnCreate
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	?AfxGetUIManager@@YAPAVIUIManager@@XZ:NEAR	; AfxGetUIManager
xdata$x	SEGMENT
$T201658 DD	0ffffffffH
	DD	FLAT:$L201651
	DD	0ffffffffH
	DD	FLAT:$L201653
$T201656 DD	019930520H
	DD	02H
	DD	FLAT:$T201658
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv205 = -92						; size = 4
tv200 = -88						; size = 4
tv210 = -84						; size = 4
tv221 = -80						; size = 4
tv218 = -76						; size = 4
tv223 = -72						; size = 4
tv216 = -68						; size = 4
tv213 = -64						; size = 4
tv222 = -60						; size = 4
tv132 = -56						; size = 4
_this$ = -52						; size = 4
$T201648 = -48						; size = 4
$T201647 = -44						; size = 4
$T201646 = -40						; size = 4
$T201645 = -36						; size = 4
$T201644 = -32						; size = 16
_pLayoutMgr$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpCreateStruct$ = 8					; size = 4
?OnCreate@CTabBarWnd@@IAEHPAUtagCREATESTRUCTA@@@Z PROC NEAR ; CTabBarWnd::OnCreate
; _this$ = ecx

; 105  : {

  00560	55		 push	 ebp
  00561	8b ec		 mov	 ebp, esp
  00563	6a ff		 push	 -1
  00565	68 00 00 00 00	 push	 __ehhandler$?OnCreate@CTabBarWnd@@IAEHPAUtagCREATESTRUCTA@@@Z
  0056a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00570	50		 push	 eax
  00571	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00578	83 ec 50	 sub	 esp, 80			; 00000050H
  0057b	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	if(__super::OnCreate(lpCreateStruct) == -1)

  0057e	8b 45 08	 mov	 eax, DWORD PTR _lpCreateStruct$[ebp]
  00581	50		 push	 eax
  00582	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00585	e8 00 00 00 00	 call	 ?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z ; CWnd::OnCreate
  0058a	83 f8 ff	 cmp	 eax, -1
  0058d	75 08		 jne	 SHORT $L199833

; 107  : 	{
; 108  : 		return -1;

  0058f	83 c8 ff	 or	 eax, -1
  00592	e9 54 01 00 00	 jmp	 $L199832
$L199833:

; 109  : 	}
; 110  : 	m_pToolTip->m_pClientWnd = GetParent();

  00597	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0059a	e8 00 00 00 00	 call	 ?GetParent@CWnd@@QBEPAV1@XZ ; CWnd::GetParent
  0059f	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  005a2	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  005a5	89 42 60	 mov	 DWORD PTR [edx+96], eax

; 111  : 	m_pToolTip->m_hParent	 = m_hWnd;

  005a8	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  005ab	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  005ae	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  005b1	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  005b4	89 81 88 00 00
	00		 mov	 DWORD PTR [ecx+136], eax

; 112  : 	m_pToolTip->CreateEx(WS_EX_TOOLWINDOW|WS_EX_TOPMOST,TOOLTIPS_CLASS,"",TTS_ALWAYSTIP,CRect(0,0,0,0),NULL,0);	

  005ba	6a 00		 push	 0
  005bc	6a 00		 push	 0
  005be	6a 00		 push	 0
  005c0	6a 00		 push	 0
  005c2	6a 00		 push	 0
  005c4	6a 00		 push	 0
  005c6	6a 00		 push	 0
  005c8	8d 4d e0	 lea	 ecx, DWORD PTR $T201644[ebp]
  005cb	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  005d0	50		 push	 eax
  005d1	6a 01		 push	 1
  005d3	68 00 00 00 00	 push	 OFFSET FLAT:$SG199835
  005d8	68 00 00 00 00	 push	 OFFSET FLAT:$SG199836
  005dd	68 88 00 00 00	 push	 136			; 00000088H
  005e2	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  005e5	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  005e8	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  005eb	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  005ee	8b 12		 mov	 edx, DWORD PTR [edx]
  005f0	ff 52 60	 call	 DWORD PTR [edx+96]

; 113  : 	m_pToolTip->m_clrBK = RGB(255, 255, 225);

  005f3	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  005f6	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  005f9	c7 41 5c ff ff
	e1 00		 mov	 DWORD PTR [ecx+92], 14811135 ; 00e1ffffH

; 114  : 
; 115  : 	ILayoutMgr* pLayoutMgr =  AfxGetUIManager()->UIGetLayoutMgr();

  00600	e8 00 00 00 00	 call	 ?AfxGetUIManager@@YAPAVIUIManager@@XZ ; AfxGetUIManager
  00605	89 45 c8	 mov	 DWORD PTR tv132[ebp], eax
  00608	8b 55 c8	 mov	 edx, DWORD PTR tv132[ebp]
  0060b	8b 02		 mov	 eax, DWORD PTR [edx]
  0060d	8b 4d c8	 mov	 ecx, DWORD PTR tv132[ebp]
  00610	ff 50 24	 call	 DWORD PTR [eax+36]
  00613	89 45 f0	 mov	 DWORD PTR _pLayoutMgr$[ebp], eax

; 116  : 	pLayoutMgr->CreateControlPane( this,"tabbarWnd","normal");

  00616	51		 push	 ecx
  00617	8b cc		 mov	 ecx, esp
  00619	89 65 dc	 mov	 DWORD PTR $T201645[ebp], esp
  0061c	68 00 00 00 00	 push	 OFFSET FLAT:$SG199846
  00621	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00627	89 45 c4	 mov	 DWORD PTR tv222[ebp], eax
  0062a	8b 4d c4	 mov	 ecx, DWORD PTR tv222[ebp]
  0062d	89 4d c0	 mov	 DWORD PTR tv213[ebp], ecx
  00630	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00637	51		 push	 ecx
  00638	8b cc		 mov	 ecx, esp
  0063a	89 65 d8	 mov	 DWORD PTR $T201646[ebp], esp
  0063d	68 00 00 00 00	 push	 OFFSET FLAT:$SG199847
  00642	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00648	89 45 bc	 mov	 DWORD PTR tv216[ebp], eax
  0064b	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0064e	52		 push	 edx
  0064f	8b 45 f0	 mov	 eax, DWORD PTR _pLayoutMgr$[ebp]
  00652	8b 10		 mov	 edx, DWORD PTR [eax]
  00654	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0065b	8b 4d f0	 mov	 ecx, DWORD PTR _pLayoutMgr$[ebp]
  0065e	ff 52 38	 call	 DWORD PTR [edx+56]

; 117  : 	pLayoutMgr->CreateBmpPane( this,"tabbarWnd","normal" );

  00661	51		 push	 ecx
  00662	8b cc		 mov	 ecx, esp
  00664	89 65 d4	 mov	 DWORD PTR $T201647[ebp], esp
  00667	68 00 00 00 00	 push	 OFFSET FLAT:$SG199850
  0066c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00672	89 45 b8	 mov	 DWORD PTR tv223[ebp], eax
  00675	8b 45 b8	 mov	 eax, DWORD PTR tv223[ebp]
  00678	89 45 b4	 mov	 DWORD PTR tv218[ebp], eax
  0067b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00682	51		 push	 ecx
  00683	8b cc		 mov	 ecx, esp
  00685	89 65 d0	 mov	 DWORD PTR $T201648[ebp], esp
  00688	68 00 00 00 00	 push	 OFFSET FLAT:$SG199851
  0068d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00693	89 45 b0	 mov	 DWORD PTR tv221[ebp], eax
  00696	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00699	51		 push	 ecx
  0069a	8b 55 f0	 mov	 edx, DWORD PTR _pLayoutMgr$[ebp]
  0069d	8b 02		 mov	 eax, DWORD PTR [edx]
  0069f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  006a6	8b 4d f0	 mov	 ecx, DWORD PTR _pLayoutMgr$[ebp]
  006a9	ff 50 58	 call	 DWORD PTR [eax+88]

; 118  : 
; 119  : 	AfxGetUIManager()->UIGetSkinMgr()->AddSkinWnd( this );

  006ac	83 7d cc 00	 cmp	 DWORD PTR _this$[ebp], 0
  006b0	74 0b		 je	 SHORT $L201649
  006b2	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  006b5	83 c1 54	 add	 ecx, 84			; 00000054H
  006b8	89 4d ac	 mov	 DWORD PTR tv210[ebp], ecx
  006bb	eb 07		 jmp	 SHORT $L201650
$L201649:
  006bd	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv210[ebp], 0
$L201650:
  006c4	e8 00 00 00 00	 call	 ?AfxGetUIManager@@YAPAVIUIManager@@XZ ; AfxGetUIManager
  006c9	89 45 a8	 mov	 DWORD PTR tv200[ebp], eax
  006cc	8b 55 a8	 mov	 edx, DWORD PTR tv200[ebp]
  006cf	8b 02		 mov	 eax, DWORD PTR [edx]
  006d1	8b 4d a8	 mov	 ecx, DWORD PTR tv200[ebp]
  006d4	ff 50 28	 call	 DWORD PTR [eax+40]
  006d7	89 45 a4	 mov	 DWORD PTR tv205[ebp], eax
  006da	8b 4d ac	 mov	 ecx, DWORD PTR tv210[ebp]
  006dd	51		 push	 ecx
  006de	8b 55 a4	 mov	 edx, DWORD PTR tv205[ebp]
  006e1	8b 02		 mov	 eax, DWORD PTR [edx]
  006e3	8b 4d a4	 mov	 ecx, DWORD PTR tv205[ebp]
  006e6	ff 50 14	 call	 DWORD PTR [eax+20]

; 120  : 	return 0;

  006e9	33 c0		 xor	 eax, eax
$L199832:

; 121  : }

  006eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  006f5	8b e5		 mov	 esp, ebp
  006f7	5d		 pop	 ebp
  006f8	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L201651:
  0010c	8b 4d dc	 mov	 ecx, DWORD PTR $T201645[ebp]
  0010f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L201653:
  00115	8b 4d d4	 mov	 ecx, DWORD PTR $T201647[ebp]
  00118	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnCreate@CTabBarWnd@@IAEHPAUtagCREATESTRUCTA@@@Z:
  0011e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201656
  00123	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OnCreate@CTabBarWnd@@IAEHPAUtagCREATESTRUCTA@@@Z ENDP	; CTabBarWnd::OnCreate
; Function compile flags: /Odt
_TEXT	SEGMENT
tv66 = -12						; size = 4
_this$ = -8						; size = 4
_pSkinMgr$ = -4						; size = 4
?LoadSkin@CTabBarWnd@@UAEXXZ PROC NEAR			; CTabBarWnd::LoadSkin
; _this$ = ecx

; 124  : {

  00700	55		 push	 ebp
  00701	8b ec		 mov	 ebp, esp
  00703	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00706	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 	ISkinMgr* pSkinMgr = AfxGetUIManager()->UIGetSkinMgr();

  00709	e8 00 00 00 00	 call	 ?AfxGetUIManager@@YAPAVIUIManager@@XZ ; AfxGetUIManager
  0070e	89 45 f4	 mov	 DWORD PTR tv66[ebp], eax
  00711	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  00714	8b 10		 mov	 edx, DWORD PTR [eax]
  00716	8b 4d f4	 mov	 ecx, DWORD PTR tv66[ebp]
  00719	ff 52 28	 call	 DWORD PTR [edx+40]
  0071c	89 45 fc	 mov	 DWORD PTR _pSkinMgr$[ebp], eax

; 126  : 	m_pBmpRectNormalLeft   = pSkinMgr->GetDibBmp( "TabBarRectLeftNormal" );

  0071f	68 00 00 00 00	 push	 OFFSET FLAT:$SG199856
  00724	8b 45 fc	 mov	 eax, DWORD PTR _pSkinMgr$[ebp]
  00727	8b 10		 mov	 edx, DWORD PTR [eax]
  00729	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  0072c	ff 52 04	 call	 DWORD PTR [edx+4]
  0072f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00732	89 41 78	 mov	 DWORD PTR [ecx+120], eax

; 127  : 	m_pBmpRectNormalMiddle = pSkinMgr->GetDibBmp( "TabBarRectMiddleNormal" );

  00735	68 00 00 00 00	 push	 OFFSET FLAT:$SG199857
  0073a	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  0073d	8b 02		 mov	 eax, DWORD PTR [edx]
  0073f	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  00742	ff 50 04	 call	 DWORD PTR [eax+4]
  00745	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00748	89 41 7c	 mov	 DWORD PTR [ecx+124], eax

; 128  : 	m_pBmpRectNormalRight  = pSkinMgr->GetDibBmp( "TabBarRectRightNormal" );

  0074b	68 00 00 00 00	 push	 OFFSET FLAT:$SG199858
  00750	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  00753	8b 02		 mov	 eax, DWORD PTR [edx]
  00755	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  00758	ff 50 04	 call	 DWORD PTR [eax+4]
  0075b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0075e	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax

; 129  : 
; 130  : 	m_pBmpRectOverLeft   = pSkinMgr->GetDibBmp( "TabBarRectLeftOver" );

  00764	68 00 00 00 00	 push	 OFFSET FLAT:$SG199859
  00769	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  0076c	8b 02		 mov	 eax, DWORD PTR [edx]
  0076e	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  00771	ff 50 04	 call	 DWORD PTR [eax+4]
  00774	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00777	89 81 84 00 00
	00		 mov	 DWORD PTR [ecx+132], eax

; 131  : 	m_pBmpRectOverMiddle = pSkinMgr->GetDibBmp( "TabBarRectMiddleOver" );

  0077d	68 00 00 00 00	 push	 OFFSET FLAT:$SG199860
  00782	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  00785	8b 02		 mov	 eax, DWORD PTR [edx]
  00787	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  0078a	ff 50 04	 call	 DWORD PTR [eax+4]
  0078d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00790	89 81 88 00 00
	00		 mov	 DWORD PTR [ecx+136], eax

; 132  : 	m_pBmpRectOverRight  = pSkinMgr->GetDibBmp( "TabBarRectRightOver" );

  00796	68 00 00 00 00	 push	 OFFSET FLAT:$SG199861
  0079b	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  0079e	8b 02		 mov	 eax, DWORD PTR [edx]
  007a0	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  007a3	ff 50 04	 call	 DWORD PTR [eax+4]
  007a6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007a9	89 81 8c 00 00
	00		 mov	 DWORD PTR [ecx+140], eax

; 133  : 
; 134  : 	m_pBmpRectDownLeft   = pSkinMgr->GetDibBmp( "TabBarRectLeftDown" );

  007af	68 00 00 00 00	 push	 OFFSET FLAT:$SG199862
  007b4	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  007b7	8b 02		 mov	 eax, DWORD PTR [edx]
  007b9	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  007bc	ff 50 04	 call	 DWORD PTR [eax+4]
  007bf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007c2	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax

; 135  : 	m_pBmpRectDownMiddle = pSkinMgr->GetDibBmp( "TabBarRectMiddleDown" );

  007c8	68 00 00 00 00	 push	 OFFSET FLAT:$SG199863
  007cd	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  007d0	8b 02		 mov	 eax, DWORD PTR [edx]
  007d2	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  007d5	ff 50 04	 call	 DWORD PTR [eax+4]
  007d8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007db	89 81 94 00 00
	00		 mov	 DWORD PTR [ecx+148], eax

; 136  : 	m_pBmpRectDownRight  = pSkinMgr->GetDibBmp( "TabBarRectRightDown" );

  007e1	68 00 00 00 00	 push	 OFFSET FLAT:$SG199864
  007e6	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  007e9	8b 02		 mov	 eax, DWORD PTR [edx]
  007eb	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  007ee	ff 50 04	 call	 DWORD PTR [eax+4]
  007f1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007f4	89 81 98 00 00
	00		 mov	 DWORD PTR [ecx+152], eax

; 137  : 
; 138  : 	m_pBmpCloseNormal = pSkinMgr->GetDibBmp( "TabBarCloseNormal" );

  007fa	68 00 00 00 00	 push	 OFFSET FLAT:$SG199865
  007ff	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  00802	8b 02		 mov	 eax, DWORD PTR [edx]
  00804	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  00807	ff 50 04	 call	 DWORD PTR [eax+4]
  0080a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0080d	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 139  : 	m_pBmpCloseOver   = pSkinMgr->GetDibBmp( "TabBarCloseOver" );

  00813	68 00 00 00 00	 push	 OFFSET FLAT:$SG199866
  00818	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  0081b	8b 02		 mov	 eax, DWORD PTR [edx]
  0081d	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  00820	ff 50 04	 call	 DWORD PTR [eax+4]
  00823	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00826	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax

; 140  : 	m_pBmpCloseDown   = pSkinMgr->GetDibBmp( "TabBarCloseDown" );

  0082c	68 00 00 00 00	 push	 OFFSET FLAT:$SG199867
  00831	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  00834	8b 02		 mov	 eax, DWORD PTR [edx]
  00836	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  00839	ff 50 04	 call	 DWORD PTR [eax+4]
  0083c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0083f	89 81 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], eax

; 141  : 
; 142  : 	m_pBmpSelCloseNormal = pSkinMgr->GetDibBmp( "TabBarSelCloseNormal" );

  00845	68 00 00 00 00	 push	 OFFSET FLAT:$SG199868
  0084a	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  0084d	8b 02		 mov	 eax, DWORD PTR [edx]
  0084f	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  00852	ff 50 04	 call	 DWORD PTR [eax+4]
  00855	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00858	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax

; 143  : 	m_pBmpSelCloseOver   = pSkinMgr->GetDibBmp( "TabBarSelCloseOver" );

  0085e	68 00 00 00 00	 push	 OFFSET FLAT:$SG199869
  00863	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  00866	8b 02		 mov	 eax, DWORD PTR [edx]
  00868	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  0086b	ff 50 04	 call	 DWORD PTR [eax+4]
  0086e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00871	89 81 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], eax

; 144  : 	m_pBmpSelCloseDown   = pSkinMgr->GetDibBmp( "TabBarSelCloseDown" );

  00877	68 00 00 00 00	 push	 OFFSET FLAT:$SG199870
  0087c	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  0087f	8b 02		 mov	 eax, DWORD PTR [edx]
  00881	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  00884	ff 50 04	 call	 DWORD PTR [eax+4]
  00887	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0088a	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax

; 145  : 
; 146  : 	m_pBmpNewWindowNormal = pSkinMgr->GetDibBmp( "TabbarNewWindowNormal" );

  00890	68 00 00 00 00	 push	 OFFSET FLAT:$SG199871
  00895	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  00898	8b 02		 mov	 eax, DWORD PTR [edx]
  0089a	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  0089d	ff 50 04	 call	 DWORD PTR [eax+4]
  008a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008a3	89 81 b4 00 00
	00		 mov	 DWORD PTR [ecx+180], eax

; 147  : 	m_pBmpNewWindowOver = pSkinMgr->GetDibBmp( "TabbarNewWindowOver" );

  008a9	68 00 00 00 00	 push	 OFFSET FLAT:$SG199872
  008ae	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  008b1	8b 02		 mov	 eax, DWORD PTR [edx]
  008b3	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  008b6	ff 50 04	 call	 DWORD PTR [eax+4]
  008b9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008bc	89 81 b8 00 00
	00		 mov	 DWORD PTR [ecx+184], eax

; 148  : 	m_pBmpNewWindowDown = pSkinMgr->GetDibBmp( "TabbarNewWindowDown" );		

  008c2	68 00 00 00 00	 push	 OFFSET FLAT:$SG199873
  008c7	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  008ca	8b 02		 mov	 eax, DWORD PTR [edx]
  008cc	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  008cf	ff 50 04	 call	 DWORD PTR [eax+4]
  008d2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008d5	89 81 bc 00 00
	00		 mov	 DWORD PTR [ecx+188], eax

; 149  : 
; 150  : 	m_colNormalTextColor = pSkinMgr->GetColor( "TabBarNormalTextColor" );

  008db	68 00 00 00 00	 push	 OFFSET FLAT:$SG199874
  008e0	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  008e3	8b 02		 mov	 eax, DWORD PTR [edx]
  008e5	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  008e8	ff 50 08	 call	 DWORD PTR [eax+8]
  008eb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008ee	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 151  : 	m_colDownTextColor	 = pSkinMgr->GetColor( "TabBarDownTextColor" );

  008f1	68 00 00 00 00	 push	 OFFSET FLAT:$SG199875
  008f6	8b 55 fc	 mov	 edx, DWORD PTR _pSkinMgr$[ebp]
  008f9	8b 02		 mov	 eax, DWORD PTR [edx]
  008fb	8b 4d fc	 mov	 ecx, DWORD PTR _pSkinMgr$[ebp]
  008fe	ff 50 08	 call	 DWORD PTR [eax+8]
  00901	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00904	89 41 70	 mov	 DWORD PTR [ecx+112], eax

; 152  : }

  00907	8b e5		 mov	 esp, ebp
  00909	5d		 pop	 ebp
  0090a	c3		 ret	 0
?LoadSkin@CTabBarWnd@@UAEXXZ ENDP			; CTabBarWnd::LoadSkin
_TEXT	ENDS
PUBLIC	?CalcTabPosition@CTabBarWnd@@AAEXXZ		; CTabBarWnd::CalcTabPosition
EXTRN	?OnSize@CBasicWnd@@IAEXIHH@Z:NEAR		; CBasicWnd::OnSize
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nType$ = 8						; size = 4
_cx$ = 12						; size = 4
_cy$ = 16						; size = 4
?OnSize@CTabBarWnd@@IAEXIHH@Z PROC NEAR			; CTabBarWnd::OnSize
; _this$ = ecx

; 155  : {

  00910	55		 push	 ebp
  00911	8b ec		 mov	 ebp, esp
  00913	51		 push	 ecx
  00914	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 156  : 	CalcTabPosition();

  00917	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0091a	e8 00 00 00 00	 call	 ?CalcTabPosition@CTabBarWnd@@AAEXXZ ; CTabBarWnd::CalcTabPosition

; 157  : 	__super::OnSize(nType,cx,cy);

  0091f	8b 45 10	 mov	 eax, DWORD PTR _cy$[ebp]
  00922	50		 push	 eax
  00923	8b 4d 0c	 mov	 ecx, DWORD PTR _cx$[ebp]
  00926	51		 push	 ecx
  00927	8b 55 08	 mov	 edx, DWORD PTR _nType$[ebp]
  0092a	52		 push	 edx
  0092b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0092e	e8 00 00 00 00	 call	 ?OnSize@CBasicWnd@@IAEXIHH@Z ; CBasicWnd::OnSize

; 158  : }

  00933	8b e5		 mov	 esp, ebp
  00935	5d		 pop	 ebp
  00936	c2 0c 00	 ret	 12			; 0000000cH
?OnSize@CTabBarWnd@@IAEXIHH@Z ENDP			; CTabBarWnd::OnSize
_TEXT	ENDS
PUBLIC	?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z		; CWnd::GetClientRect
PUBLIC	?CreateCompatibleDC@CDC@@QAEHPAV1@@Z		; CDC::CreateCompatibleDC
PUBLIC	?Width@CRect@@QBEHXZ				; CRect::Width
PUBLIC	?Height@CRect@@QBEHXZ				; CRect::Height
PUBLIC	?DrawBar@CTabBarWnd@@AAEXPAVCDC@@@Z		; CTabBarWnd::DrawBar
PUBLIC	?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z			; CDC::BitBlt
PUBLIC	?SelectObject@CDC@@QAEPAXPAX@Z			; CDC::SelectObject
EXTRN	??0CDC@@QAE@XZ:NEAR				; CDC::CDC
EXTRN	?DeleteDC@CDC@@QAEHXZ:NEAR			; CDC::DeleteDC
EXTRN	__imp__DeleteObject@4:NEAR
EXTRN	__imp__CreateDIBSection@24:NEAR
EXTRN	??1CDC@@UAE@XZ:NEAR				; CDC::~CDC
EXTRN	??0CPaintDC@@QAE@PAVCWnd@@@Z:NEAR		; CPaintDC::CPaintDC
EXTRN	??1CPaintDC@@UAE@XZ:NEAR			; CPaintDC::~CPaintDC
xdata$x	SEGMENT
$T201669 DD	0ffffffffH
	DD	FLAT:$L201663
	DD	00H
	DD	FLAT:$L201664
$T201666 DD	019930520H
	DD	02H
	DD	FLAT:$T201669
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -152						; size = 4
_dcMem$ = -148						; size = 16
_rcClient$ = -132					; size = 16
_bmp$ = -116						; size = 4
_pBits$ = -112						; size = 4
_dc$ = -108						; size = 84
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?OnPaint@CTabBarWnd@@IAEXXZ PROC NEAR			; CTabBarWnd::OnPaint
; _this$ = ecx

; 161  : {		

  00940	55		 push	 ebp
  00941	8b ec		 mov	 ebp, esp
  00943	6a ff		 push	 -1
  00945	68 00 00 00 00	 push	 __ehhandler$?OnPaint@CTabBarWnd@@IAEXXZ
  0094a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00950	50		 push	 eax
  00951	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00958	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  0095e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00963	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00966	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	CPaintDC dc(this);

  0096c	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00972	50		 push	 eax
  00973	8d 4d 94	 lea	 ecx, DWORD PTR _dc$[ebp]
  00976	e8 00 00 00 00	 call	 ??0CPaintDC@@QAE@PAVCWnd@@@Z ; CPaintDC::CPaintDC
  0097b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 163  : 	
; 164  : 	CRect rcClient;

  00982	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _rcClient$[ebp]
  00988	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 165  : 	GetClientRect( &rcClient );

  0098d	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _rcClient$[ebp]
  00993	51		 push	 ecx
  00994	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0099a	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 166  : 	CDC dcMem;

  0099f	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _dcMem$[ebp]
  009a5	e8 00 00 00 00	 call	 ??0CDC@@QAE@XZ		; CDC::CDC
  009aa	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 167  : 	dcMem.CreateCompatibleDC( &dc );

  009ae	8d 55 94	 lea	 edx, DWORD PTR _dc$[ebp]
  009b1	52		 push	 edx
  009b2	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _dcMem$[ebp]
  009b8	e8 00 00 00 00	 call	 ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z ; CDC::CreateCompatibleDC

; 168  : 	
; 169  : 	BYTE * pBits = NULL; 

  009bd	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _pBits$[ebp], 0

; 170  : 	m_bmih.biWidth  = rcClient.Width(); 

  009c4	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _rcClient$[ebp]
  009ca	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  009cf	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009d5	89 81 18 01 00
	00		 mov	 DWORD PTR [ecx+280], eax

; 171  : 	m_bmih.biHeight = rcClient.Height(); 

  009db	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _rcClient$[ebp]
  009e1	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  009e6	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  009ec	89 82 1c 01 00
	00		 mov	 DWORD PTR [edx+284], eax

; 172  : 	HBITMAP bmp = CreateDIBSection(NULL, (BITMAPINFO*)&m_bmih, 
; 173  : 		0, (VOID**)&pBits, NULL, 0) ; 

  009f2	6a 00		 push	 0
  009f4	6a 00		 push	 0
  009f6	8d 45 90	 lea	 eax, DWORD PTR _pBits$[ebp]
  009f9	50		 push	 eax
  009fa	6a 00		 push	 0
  009fc	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a02	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00a08	51		 push	 ecx
  00a09	6a 00		 push	 0
  00a0b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBSection@24
  00a11	89 45 8c	 mov	 DWORD PTR _bmp$[ebp], eax

; 174  : 
; 175  : 	dcMem.SelectObject( bmp );

  00a14	8b 55 8c	 mov	 edx, DWORD PTR _bmp$[ebp]
  00a17	52		 push	 edx
  00a18	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _dcMem$[ebp]
  00a1e	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAXPAX@Z ; CDC::SelectObject

; 176  : 	::DeleteObject( bmp );

  00a23	8b 45 8c	 mov	 eax, DWORD PTR _bmp$[ebp]
  00a26	50		 push	 eax
  00a27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 177  : 	DrawBar( &dcMem );

  00a2d	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _dcMem$[ebp]
  00a33	51		 push	 ecx
  00a34	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a3a	e8 00 00 00 00	 call	 ?DrawBar@CTabBarWnd@@AAEXPAVCDC@@@Z ; CTabBarWnd::DrawBar

; 178  : 	dc.BitBlt( 0, 0, rcClient.Width(), rcClient.Height(), &dcMem, 0, 0, SRCCOPY );

  00a3f	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00a44	6a 00		 push	 0
  00a46	6a 00		 push	 0
  00a48	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _dcMem$[ebp]
  00a4e	52		 push	 edx
  00a4f	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _rcClient$[ebp]
  00a55	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00a5a	50		 push	 eax
  00a5b	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _rcClient$[ebp]
  00a61	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00a66	50		 push	 eax
  00a67	6a 00		 push	 0
  00a69	6a 00		 push	 0
  00a6b	8d 4d 94	 lea	 ecx, DWORD PTR _dc$[ebp]
  00a6e	e8 00 00 00 00	 call	 ?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z ; CDC::BitBlt

; 179  : 	dcMem.DeleteDC();

  00a73	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _dcMem$[ebp]
  00a79	e8 00 00 00 00	 call	 ?DeleteDC@CDC@@QAEHXZ	; CDC::DeleteDC

; 180  : }

  00a7e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00a82	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _dcMem$[ebp]
  00a88	e8 00 00 00 00	 call	 ??1CDC@@UAE@XZ		; CDC::~CDC
  00a8d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00a94	8d 4d 94	 lea	 ecx, DWORD PTR _dc$[ebp]
  00a97	e8 00 00 00 00	 call	 ??1CPaintDC@@UAE@XZ	; CPaintDC::~CPaintDC
  00a9c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00a9f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00aa6	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00aa9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00aae	8b e5		 mov	 esp, ebp
  00ab0	5d		 pop	 ebp
  00ab1	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L201663:
  00128	8d 4d 94	 lea	 ecx, DWORD PTR _dc$[ebp]
  0012b	e9 00 00 00 00	 jmp	 ??1CPaintDC@@UAE@XZ	; CPaintDC::~CPaintDC
$L201664:
  00130	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _dcMem$[ebp]
  00136	e9 00 00 00 00	 jmp	 ??1CDC@@UAE@XZ		; CDC::~CDC
__ehhandler$?OnPaint@CTabBarWnd@@IAEXXZ:
  0013b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201666
  00140	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OnPaint@CTabBarWnd@@IAEXXZ ENDP			; CTabBarWnd::OnPaint
PUBLIC	?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
PUBLIC	??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
PUBLIC	??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
PUBLIC	?DrawTabItemRect@CTabBarWnd@@AAEXPAVCDC@@AAVCRect@@PAVCDibBitmap@@2212V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CTabBarWnd::DrawTabItemRect
EXTRN	?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z:NEAR	; CDibBitmap::Draw
EXTRN	?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z:NEAR	; CDibBitmap::SetCDibRect
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
xdata$x	SEGMENT
$T201680 DD	0ffffffffH
	DD	FLAT:$L201674
	DD	0ffffffffH
	DD	FLAT:$L201675
	DD	0ffffffffH
	DD	FLAT:$L201676
$T201678 DD	019930520H
	DD	03H
	DD	FLAT:$T201680
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv350 = -92						; size = 4
tv353 = -88						; size = 4
tv347 = -84						; size = 4
tv352 = -80						; size = 4
tv344 = -76						; size = 4
tv351 = -72						; size = 4
tv85 = -68						; size = 4
tv80 = -64						; size = 4
tv71 = -60						; size = 4
tv66 = -56						; size = 4
_this$ = -52						; size = 4
$T201673 = -48						; size = 4
$T201672 = -44						; size = 4
$T201671 = -40						; size = 4
_i$199902 = -36						; size = 4
_rc$199900 = -32					; size = 16
_pBmp$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pDc$ = 8						; size = 4
?DrawBar@CTabBarWnd@@AAEXPAVCDC@@@Z PROC NEAR		; CTabBarWnd::DrawBar
; _this$ = ecx

; 183  : {

  00ac0	55		 push	 ebp
  00ac1	8b ec		 mov	 ebp, esp
  00ac3	6a ff		 push	 -1
  00ac5	68 00 00 00 00	 push	 __ehhandler$?DrawBar@CTabBarWnd@@AAEXPAVCDC@@@Z
  00aca	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00ad0	50		 push	 eax
  00ad1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00ad8	83 ec 50	 sub	 esp, 80			; 00000050H
  00adb	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 	//1
; 185  : 	AfxGetUIManager()->UIGetLayoutMgr()->PaintBkGround( m_hWnd ,pDc,true );

  00ade	e8 00 00 00 00	 call	 ?AfxGetUIManager@@YAPAVIUIManager@@XZ ; AfxGetUIManager
  00ae3	89 45 c8	 mov	 DWORD PTR tv66[ebp], eax
  00ae6	8b 45 c8	 mov	 eax, DWORD PTR tv66[ebp]
  00ae9	8b 10		 mov	 edx, DWORD PTR [eax]
  00aeb	8b 4d c8	 mov	 ecx, DWORD PTR tv66[ebp]
  00aee	ff 52 24	 call	 DWORD PTR [edx+36]
  00af1	89 45 c4	 mov	 DWORD PTR tv71[ebp], eax
  00af4	6a 01		 push	 1
  00af6	8b 45 08	 mov	 eax, DWORD PTR _pDc$[ebp]
  00af9	50		 push	 eax
  00afa	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00afd	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00b00	52		 push	 edx
  00b01	8b 45 c4	 mov	 eax, DWORD PTR tv71[ebp]
  00b04	8b 10		 mov	 edx, DWORD PTR [eax]
  00b06	8b 4d c4	 mov	 ecx, DWORD PTR tv71[ebp]
  00b09	ff 52 5c	 call	 DWORD PTR [edx+92]

; 186  : 	CDibBitmap* pBmp = AfxGetUIManager()->UIGetSkinMgr()->GetDibBmp( "TabBarBK" );

  00b0c	e8 00 00 00 00	 call	 ?AfxGetUIManager@@YAPAVIUIManager@@XZ ; AfxGetUIManager
  00b11	89 45 c0	 mov	 DWORD PTR tv80[ebp], eax
  00b14	8b 45 c0	 mov	 eax, DWORD PTR tv80[ebp]
  00b17	8b 10		 mov	 edx, DWORD PTR [eax]
  00b19	8b 4d c0	 mov	 ecx, DWORD PTR tv80[ebp]
  00b1c	ff 52 28	 call	 DWORD PTR [edx+40]
  00b1f	89 45 bc	 mov	 DWORD PTR tv85[ebp], eax
  00b22	68 00 00 00 00	 push	 OFFSET FLAT:$SG199898
  00b27	8b 45 bc	 mov	 eax, DWORD PTR tv85[ebp]
  00b2a	8b 10		 mov	 edx, DWORD PTR [eax]
  00b2c	8b 4d bc	 mov	 ecx, DWORD PTR tv85[ebp]
  00b2f	ff 52 04	 call	 DWORD PTR [edx+4]
  00b32	89 45 f0	 mov	 DWORD PTR _pBmp$[ebp], eax

; 187  : 	if( pBmp != NULL )

  00b35	83 7d f0 00	 cmp	 DWORD PTR _pBmp$[ebp], 0
  00b39	74 4a		 je	 SHORT $L199899

; 188  : 	{
; 189  : 		CRect rc;

  00b3b	8d 4d e0	 lea	 ecx, DWORD PTR _rc$199900[ebp]
  00b3e	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 190  : 		GetClientRect( &rc );

  00b43	8d 45 e0	 lea	 eax, DWORD PTR _rc$199900[ebp]
  00b46	50		 push	 eax
  00b47	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b4a	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 191  : 		pBmp->SetCDibRect( rc );

  00b4f	83 ec 10	 sub	 esp, 16			; 00000010H
  00b52	8b cc		 mov	 ecx, esp
  00b54	8b 55 e0	 mov	 edx, DWORD PTR _rc$199900[ebp]
  00b57	89 11		 mov	 DWORD PTR [ecx], edx
  00b59	8b 45 e4	 mov	 eax, DWORD PTR _rc$199900[ebp+4]
  00b5c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00b5f	8b 55 e8	 mov	 edx, DWORD PTR _rc$199900[ebp+8]
  00b62	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00b65	8b 45 ec	 mov	 eax, DWORD PTR _rc$199900[ebp+12]
  00b68	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00b6b	8b 4d f0	 mov	 ecx, DWORD PTR _pBmp$[ebp]
  00b6e	e8 00 00 00 00	 call	 ?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ; CDibBitmap::SetCDibRect

; 192  : 		pBmp->Draw( pDc, FALSE );

  00b73	6a 01		 push	 1
  00b75	6a 00		 push	 0
  00b77	6a 00		 push	 0
  00b79	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  00b7c	51		 push	 ecx
  00b7d	8b 4d f0	 mov	 ecx, DWORD PTR _pBmp$[ebp]
  00b80	e8 00 00 00 00	 call	 ?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ; CDibBitmap::Draw
$L199899:

; 193  : 	}
; 194  : 	if( m_vecTab.size() == 0 )

  00b85	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b88	83 c1 70	 add	 ecx, 112		; 00000070H
  00b8b	e8 00 00 00 00	 call	 ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
  00b90	85 c0		 test	 eax, eax
  00b92	75 05		 jne	 SHORT $L199901

; 195  : 	{
; 196  : 		return;

  00b94	e9 e6 03 00 00	 jmp	 $L199896
$L199901:

; 197  : 	}
; 198  : 	//2rectclose
; 199  : 	for( int i = 0; i < m_vecTab.size(); i++ )

  00b99	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$199902[ebp], 0
  00ba0	eb 09		 jmp	 SHORT $L199903
$L199904:
  00ba2	8b 55 dc	 mov	 edx, DWORD PTR _i$199902[ebp]
  00ba5	83 c2 01	 add	 edx, 1
  00ba8	89 55 dc	 mov	 DWORD PTR _i$199902[ebp], edx
$L199903:
  00bab	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bae	83 c1 70	 add	 ecx, 112		; 00000070H
  00bb1	e8 00 00 00 00	 call	 ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
  00bb6	39 45 dc	 cmp	 DWORD PTR _i$199902[ebp], eax
  00bb9	0f 83 96 00 00
	00		 jae	 $L199905

; 200  : 	{
; 201  : 		DrawTabItemRect( pDc, m_vecTab[i], m_pBmpRectNormalLeft,
; 202  : 			m_pBmpRectNormalMiddle, m_pBmpRectNormalRight, 
; 203  : 			m_vecClose[i], m_pBmpCloseNormal,
; 204  : 			m_vecTi[i].strName, false );

  00bbf	6a 00		 push	 0
  00bc1	8b 45 dc	 mov	 eax, DWORD PTR _i$199902[ebp]
  00bc4	50		 push	 eax
  00bc5	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bc8	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00bce	e8 00 00 00 00	 call	 ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
  00bd3	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00bd6	8b cc		 mov	 ecx, esp
  00bd8	89 65 d8	 mov	 DWORD PTR $T201671[ebp], esp
  00bdb	50		 push	 eax
  00bdc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00be2	89 45 b8	 mov	 DWORD PTR tv351[ebp], eax
  00be5	8b 4d b8	 mov	 ecx, DWORD PTR tv351[ebp]
  00be8	89 4d b4	 mov	 DWORD PTR tv344[ebp], ecx
  00beb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00bf2	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00bf5	8b 82 f0 00 00
	00		 mov	 eax, DWORD PTR [edx+240]
  00bfb	50		 push	 eax
  00bfc	8b 4d dc	 mov	 ecx, DWORD PTR _i$199902[ebp]
  00bff	51		 push	 ecx
  00c00	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c03	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00c09	e8 00 00 00 00	 call	 ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
  00c0e	50		 push	 eax
  00c0f	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00c12	8b 82 d4 00 00
	00		 mov	 eax, DWORD PTR [edx+212]
  00c18	50		 push	 eax
  00c19	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c1c	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  00c22	52		 push	 edx
  00c23	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00c26	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00c2c	51		 push	 ecx
  00c2d	8b 55 dc	 mov	 edx, DWORD PTR _i$199902[ebp]
  00c30	52		 push	 edx
  00c31	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c34	83 c1 70	 add	 ecx, 112		; 00000070H
  00c37	e8 00 00 00 00	 call	 ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
  00c3c	50		 push	 eax
  00c3d	8b 45 08	 mov	 eax, DWORD PTR _pDc$[ebp]
  00c40	50		 push	 eax
  00c41	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c48	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c4b	e8 00 00 00 00	 call	 ?DrawTabItemRect@CTabBarWnd@@AAEXPAVCDC@@AAVCRect@@PAVCDibBitmap@@2212V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CTabBarWnd::DrawTabItemRect

; 205  : 	}

  00c50	e9 4d ff ff ff	 jmp	 $L199904
$L199905:

; 206  : 	//2rectclose
; 207  : 	if( m_iTabCur != -1 )

  00c55	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c58	83 b9 b4 00 00
	00 ff		 cmp	 DWORD PTR [ecx+180], -1
  00c5f	0f 84 a3 00 00
	00		 je	 $L199907

; 208  : 	{
; 209  : 		DrawTabItemRect( pDc, m_vecTab[m_iTabCur], m_pBmpRectDownLeft,
; 210  : 			m_pBmpRectDownMiddle, m_pBmpRectDownRight, 
; 211  : 			m_vecClose[m_iTabCur], m_pBmpSelCloseNormal, 
; 212  : 			m_vecTi[m_iTabCur].strName, true );

  00c65	6a 01		 push	 1
  00c67	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00c6a	8b 82 b4 00 00
	00		 mov	 eax, DWORD PTR [edx+180]
  00c70	50		 push	 eax
  00c71	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c74	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00c7a	e8 00 00 00 00	 call	 ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
  00c7f	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00c82	8b cc		 mov	 ecx, esp
  00c84	89 65 d4	 mov	 DWORD PTR $T201672[ebp], esp
  00c87	50		 push	 eax
  00c88	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00c8e	89 45 b0	 mov	 DWORD PTR tv352[ebp], eax
  00c91	8b 4d b0	 mov	 ecx, DWORD PTR tv352[ebp]
  00c94	89 4d ac	 mov	 DWORD PTR tv347[ebp], ecx
  00c97	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00c9e	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00ca1	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  00ca7	50		 push	 eax
  00ca8	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cab	8b 91 b4 00 00
	00		 mov	 edx, DWORD PTR [ecx+180]
  00cb1	52		 push	 edx
  00cb2	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cb5	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00cbb	e8 00 00 00 00	 call	 ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
  00cc0	50		 push	 eax
  00cc1	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00cc4	8b 88 ec 00 00
	00		 mov	 ecx, DWORD PTR [eax+236]
  00cca	51		 push	 ecx
  00ccb	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00cce	8b 82 e8 00 00
	00		 mov	 eax, DWORD PTR [edx+232]
  00cd4	50		 push	 eax
  00cd5	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cd8	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  00cde	52		 push	 edx
  00cdf	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00ce2	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [eax+180]
  00ce8	51		 push	 ecx
  00ce9	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cec	83 c1 70	 add	 ecx, 112		; 00000070H
  00cef	e8 00 00 00 00	 call	 ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
  00cf4	50		 push	 eax
  00cf5	8b 55 08	 mov	 edx, DWORD PTR _pDc$[ebp]
  00cf8	52		 push	 edx
  00cf9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d00	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d03	e8 00 00 00 00	 call	 ?DrawTabItemRect@CTabBarWnd@@AAEXPAVCDC@@AAVCRect@@PAVCDibBitmap@@2212V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CTabBarWnd::DrawTabItemRect
$L199907:

; 213  : 	}
; 214  : 	//3overrect
; 215  : 	if( m_iTabOver != -1 && m_iTabOver != m_iTabCur )

  00d08	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00d0b	83 b8 b8 00 00
	00 ff		 cmp	 DWORD PTR [eax+184], -1
  00d12	0f 84 bb 00 00
	00		 je	 $L199909
  00d18	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d1b	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00d1e	8b 81 b8 00 00
	00		 mov	 eax, DWORD PTR [ecx+184]
  00d24	3b 82 b4 00 00
	00		 cmp	 eax, DWORD PTR [edx+180]
  00d2a	0f 84 a3 00 00
	00		 je	 $L199909

; 216  : 	{
; 217  : 		DrawTabItemRect( pDc, m_vecTab[m_iTabOver], m_pBmpRectOverLeft,
; 218  : 			m_pBmpRectOverMiddle, m_pBmpRectOverRight, 
; 219  : 			m_vecClose[m_iTabOver], m_pBmpCloseNormal, 
; 220  : 			m_vecTi[m_iTabOver].strName, false );

  00d30	6a 00		 push	 0
  00d32	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d35	8b 91 b8 00 00
	00		 mov	 edx, DWORD PTR [ecx+184]
  00d3b	52		 push	 edx
  00d3c	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d3f	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00d45	e8 00 00 00 00	 call	 ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
  00d4a	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00d4d	8b cc		 mov	 ecx, esp
  00d4f	89 65 d0	 mov	 DWORD PTR $T201673[ebp], esp
  00d52	50		 push	 eax
  00d53	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00d59	89 45 a8	 mov	 DWORD PTR tv353[ebp], eax
  00d5c	8b 45 a8	 mov	 eax, DWORD PTR tv353[ebp]
  00d5f	89 45 a4	 mov	 DWORD PTR tv350[ebp], eax
  00d62	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00d69	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d6c	8b 91 f0 00 00
	00		 mov	 edx, DWORD PTR [ecx+240]
  00d72	52		 push	 edx
  00d73	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00d76	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [eax+184]
  00d7c	51		 push	 ecx
  00d7d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d80	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00d86	e8 00 00 00 00	 call	 ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
  00d8b	50		 push	 eax
  00d8c	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00d8f	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  00d95	50		 push	 eax
  00d96	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d99	8b 91 dc 00 00
	00		 mov	 edx, DWORD PTR [ecx+220]
  00d9f	52		 push	 edx
  00da0	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00da3	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [eax+216]
  00da9	51		 push	 ecx
  00daa	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00dad	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  00db3	50		 push	 eax
  00db4	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00db7	83 c1 70	 add	 ecx, 112		; 00000070H
  00dba	e8 00 00 00 00	 call	 ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
  00dbf	50		 push	 eax
  00dc0	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  00dc3	51		 push	 ecx
  00dc4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00dcb	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00dce	e8 00 00 00 00	 call	 ?DrawTabItemRect@CTabBarWnd@@AAEXPAVCDC@@AAVCRect@@PAVCDibBitmap@@2212V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CTabBarWnd::DrawTabItemRect
$L199909:

; 221  : 	}
; 222  : 	//4overclose
; 223  : 	if( m_iCloseOver != -1 && m_iCloseOver != 0 )

  00dd3	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00dd6	83 ba bc 00 00
	00 ff		 cmp	 DWORD PTR [edx+188], -1
  00ddd	0f 84 e8 00 00
	00		 je	 $L199911
  00de3	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00de6	83 b8 bc 00 00
	00 00		 cmp	 DWORD PTR [eax+188], 0
  00ded	0f 84 d8 00 00
	00		 je	 $L199911

; 224  : 	{
; 225  : 		if (m_iCloseOver == m_iTabCur)

  00df3	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00df6	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00df9	8b 81 bc 00 00
	00		 mov	 eax, DWORD PTR [ecx+188]
  00dff	3b 82 b4 00 00
	00		 cmp	 eax, DWORD PTR [edx+180]
  00e05	75 63		 jne	 SHORT $L199912

; 226  : 		{
; 227  : 			m_pBmpSelCloseOver->SetCDibRect( m_vecClose[m_iCloseOver] );

  00e07	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e0a	8b 91 bc 00 00
	00		 mov	 edx, DWORD PTR [ecx+188]
  00e10	52		 push	 edx
  00e11	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e14	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00e1a	e8 00 00 00 00	 call	 ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
  00e1f	83 ec 10	 sub	 esp, 16			; 00000010H
  00e22	8b cc		 mov	 ecx, esp
  00e24	8b 10		 mov	 edx, DWORD PTR [eax]
  00e26	89 11		 mov	 DWORD PTR [ecx], edx
  00e28	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00e2b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00e2e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00e31	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00e34	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00e37	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00e3a	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e3d	8b 89 00 01 00
	00		 mov	 ecx, DWORD PTR [ecx+256]
  00e43	e8 00 00 00 00	 call	 ?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ; CDibBitmap::SetCDibRect

; 228  : 			m_pBmpSelCloseOver->Draw( pDc, TRUE, m_colMask );

  00e48	6a 01		 push	 1
  00e4a	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00e4d	8b 82 c8 00 00
	00		 mov	 eax, DWORD PTR [edx+200]
  00e53	50		 push	 eax
  00e54	6a 01		 push	 1
  00e56	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  00e59	51		 push	 ecx
  00e5a	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00e5d	8b 8a 00 01 00
	00		 mov	 ecx, DWORD PTR [edx+256]
  00e63	e8 00 00 00 00	 call	 ?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ; CDibBitmap::Draw

; 229  : 		}else

  00e68	eb 61		 jmp	 SHORT $L199911
$L199912:

; 230  : 		{
; 231  : 			m_pBmpCloseOver->SetCDibRect( m_vecClose[m_iCloseOver] );

  00e6a	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00e6d	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR [eax+188]
  00e73	51		 push	 ecx
  00e74	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e77	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00e7d	e8 00 00 00 00	 call	 ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
  00e82	83 ec 10	 sub	 esp, 16			; 00000010H
  00e85	8b d4		 mov	 edx, esp
  00e87	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e89	89 0a		 mov	 DWORD PTR [edx], ecx
  00e8b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00e8e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00e91	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00e94	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00e97	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00e9a	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00e9d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ea0	8b 89 f4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+244]
  00ea6	e8 00 00 00 00	 call	 ?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ; CDibBitmap::SetCDibRect

; 232  : 			m_pBmpCloseOver->Draw( pDc, TRUE, m_colMask );

  00eab	6a 01		 push	 1
  00ead	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00eb0	8b 82 c8 00 00
	00		 mov	 eax, DWORD PTR [edx+200]
  00eb6	50		 push	 eax
  00eb7	6a 01		 push	 1
  00eb9	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  00ebc	51		 push	 ecx
  00ebd	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00ec0	8b 8a f4 00 00
	00		 mov	 ecx, DWORD PTR [edx+244]
  00ec6	e8 00 00 00 00	 call	 ?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ; CDibBitmap::Draw
$L199911:

; 233  : 		}
; 234  : 	}
; 235  : 	//5newwindow
; 236  : 	if (m_bOverNewWindow)

  00ecb	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00ece	0f b6 88 b0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+176]
  00ed5	85 c9		 test	 ecx, ecx
  00ed7	74 54		 je	 SHORT $L199914

; 237  : 	{
; 238  : 		m_pBmpNewWindowOver->SetCDibRect( m_rectNewWindow );

  00ed9	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00edc	81 c2 a0 00 00
	00		 add	 edx, 160		; 000000a0H
  00ee2	83 ec 10	 sub	 esp, 16			; 00000010H
  00ee5	8b c4		 mov	 eax, esp
  00ee7	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00ee9	89 08		 mov	 DWORD PTR [eax], ecx
  00eeb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00eee	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00ef1	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00ef4	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00ef7	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00efa	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00efd	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00f00	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  00f06	e8 00 00 00 00	 call	 ?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ; CDibBitmap::SetCDibRect

; 239  : 		m_pBmpNewWindowOver->Draw( pDc, TRUE, m_colMask );

  00f0b	6a 01		 push	 1
  00f0d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f10	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  00f16	52		 push	 edx
  00f17	6a 01		 push	 1
  00f19	8b 45 08	 mov	 eax, DWORD PTR _pDc$[ebp]
  00f1c	50		 push	 eax
  00f1d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f20	8b 89 0c 01 00
	00		 mov	 ecx, DWORD PTR [ecx+268]
  00f26	e8 00 00 00 00	 call	 ?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ; CDibBitmap::Draw

; 240  : 	}else

  00f2b	eb 52		 jmp	 SHORT $L199896
$L199914:

; 241  : 	{
; 242  : 		m_pBmpNewWindowNormal->SetCDibRect( m_rectNewWindow );

  00f2d	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00f30	81 c2 a0 00 00
	00		 add	 edx, 160		; 000000a0H
  00f36	83 ec 10	 sub	 esp, 16			; 00000010H
  00f39	8b c4		 mov	 eax, esp
  00f3b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00f3d	89 08		 mov	 DWORD PTR [eax], ecx
  00f3f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00f42	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00f45	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00f48	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00f4b	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00f4e	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00f51	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00f54	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  00f5a	e8 00 00 00 00	 call	 ?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ; CDibBitmap::SetCDibRect

; 243  : 		m_pBmpNewWindowNormal->Draw( pDc, TRUE, m_colMask );

  00f5f	6a 01		 push	 1
  00f61	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f64	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  00f6a	52		 push	 edx
  00f6b	6a 01		 push	 1
  00f6d	8b 45 08	 mov	 eax, DWORD PTR _pDc$[ebp]
  00f70	50		 push	 eax
  00f71	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f74	8b 89 08 01 00
	00		 mov	 ecx, DWORD PTR [ecx+264]
  00f7a	e8 00 00 00 00	 call	 ?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ; CDibBitmap::Draw
$L199896:

; 244  : 	}
; 245  : }

  00f7f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00f82	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00f89	8b e5		 mov	 esp, ebp
  00f8b	5d		 pop	 ebp
  00f8c	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L201674:
  00145	8b 4d d8	 mov	 ecx, DWORD PTR $T201671[ebp]
  00148	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L201675:
  0014e	8b 4d d4	 mov	 ecx, DWORD PTR $T201672[ebp]
  00151	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L201676:
  00157	8b 4d d0	 mov	 ecx, DWORD PTR $T201673[ebp]
  0015a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?DrawBar@CTabBarWnd@@AAEXPAVCDC@@@Z:
  00160	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201678
  00165	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DrawBar@CTabBarWnd@@AAEXPAVCDC@@@Z ENDP		; CTabBarWnd::DrawBar
PUBLIC	?GetTextColor@CDC@@QBEKXZ			; CDC::GetTextColor
PUBLIC	?IsRectEmpty@CRect@@QBEHXZ			; CRect::IsRectEmpty
EXTRN	?SetBkMode@CDC@@QAEHH@Z:NEAR			; CDC::SetBkMode
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
EXTRN	?GetWidth@CDibBitmap@@QAEHXZ:NEAR		; CDibBitmap::GetWidth
xdata$x	SEGMENT
$T201686 DD	0ffffffffH
	DD	FLAT:$L201682
$T201684 DD	019930520H
	DD	01H
	DD	FLAT:$T201686
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -88						; size = 4
_colOld$199935 = -84					; size = 4
_fontOld$199936 = -80					; size = 4
_rcMiddle$ = -76					; size = 16
_rcRight$ = -60						; size = 16
_rcText$ = -44						; size = 16
_rcLeft$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
_pDc$ = 8						; size = 4
_rcRect$ = 12						; size = 4
_pRectLeft$ = 16					; size = 4
_pRectMiddle$ = 20					; size = 4
_pRectRight$ = 24					; size = 4
_rcClose$ = 28						; size = 4
_pClose$ = 32						; size = 4
_strText$ = 36						; size = 28
_bDown$ = 64						; size = 1
?DrawTabItemRect@CTabBarWnd@@AAEXPAVCDC@@AAVCRect@@PAVCDibBitmap@@2212V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC NEAR ; CTabBarWnd::DrawTabItemRect
; _this$ = ecx

; 250  : {

  00f90	55		 push	 ebp
  00f91	8b ec		 mov	 ebp, esp
  00f93	6a ff		 push	 -1
  00f95	68 00 00 00 00	 push	 __ehhandler$?DrawTabItemRect@CTabBarWnd@@AAEXPAVCDC@@AAVCRect@@PAVCDibBitmap@@2212V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
  00f9a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00fa0	50		 push	 eax
  00fa1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00fa8	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00fab	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx
  00fae	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 251  : 	if( pRectLeft == NULL || pRectMiddle == NULL || pRectRight == NULL || pClose == NULL )

  00fb5	83 7d 10 00	 cmp	 DWORD PTR _pRectLeft$[ebp], 0
  00fb9	74 12		 je	 SHORT $L199929
  00fbb	83 7d 14 00	 cmp	 DWORD PTR _pRectMiddle$[ebp], 0
  00fbf	74 0c		 je	 SHORT $L199929
  00fc1	83 7d 18 00	 cmp	 DWORD PTR _pRectRight$[ebp], 0
  00fc5	74 06		 je	 SHORT $L199929
  00fc7	83 7d 20 00	 cmp	 DWORD PTR _pClose$[ebp], 0
  00fcb	75 15		 jne	 SHORT $L199928
$L199929:

; 252  : 		return;

  00fcd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00fd4	8d 4d 24	 lea	 ecx, DWORD PTR _strText$[ebp]
  00fd7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00fdd	e9 7b 02 00 00	 jmp	 $L199927
$L199928:

; 253  : 	CRect rcLeft(rcRect);

  00fe2	8b 45 0c	 mov	 eax, DWORD PTR _rcRect$[ebp]
  00fe5	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fe7	89 4d e4	 mov	 DWORD PTR _rcLeft$[ebp], ecx
  00fea	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00fed	89 55 e8	 mov	 DWORD PTR _rcLeft$[ebp+4], edx
  00ff0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00ff3	89 4d ec	 mov	 DWORD PTR _rcLeft$[ebp+8], ecx
  00ff6	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00ff9	89 55 f0	 mov	 DWORD PTR _rcLeft$[ebp+12], edx

; 254  : 	rcLeft.right = rcLeft.left + pRectLeft->GetWidth();

  00ffc	8b 4d 10	 mov	 ecx, DWORD PTR _pRectLeft$[ebp]
  00fff	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  01004	03 45 e4	 add	 eax, DWORD PTR _rcLeft$[ebp]
  01007	89 45 ec	 mov	 DWORD PTR _rcLeft$[ebp+8], eax

; 255  : 	pRectLeft->SetCDibRect( rcLeft );

  0100a	83 ec 10	 sub	 esp, 16			; 00000010H
  0100d	8b c4		 mov	 eax, esp
  0100f	8b 4d e4	 mov	 ecx, DWORD PTR _rcLeft$[ebp]
  01012	89 08		 mov	 DWORD PTR [eax], ecx
  01014	8b 55 e8	 mov	 edx, DWORD PTR _rcLeft$[ebp+4]
  01017	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0101a	8b 4d ec	 mov	 ecx, DWORD PTR _rcLeft$[ebp+8]
  0101d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  01020	8b 55 f0	 mov	 edx, DWORD PTR _rcLeft$[ebp+12]
  01023	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  01026	8b 4d 10	 mov	 ecx, DWORD PTR _pRectLeft$[ebp]
  01029	e8 00 00 00 00	 call	 ?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ; CDibBitmap::SetCDibRect

; 256  : 	pRectLeft->Draw( pDc, TRUE, m_colMask );

  0102e	6a 01		 push	 1
  01030	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  01033	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  01039	51		 push	 ecx
  0103a	6a 01		 push	 1
  0103c	8b 55 08	 mov	 edx, DWORD PTR _pDc$[ebp]
  0103f	52		 push	 edx
  01040	8b 4d 10	 mov	 ecx, DWORD PTR _pRectLeft$[ebp]
  01043	e8 00 00 00 00	 call	 ?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ; CDibBitmap::Draw

; 257  : 
; 258  : 	CRect rcRight(rcRect);

  01048	8b 45 0c	 mov	 eax, DWORD PTR _rcRect$[ebp]
  0104b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0104d	89 4d c4	 mov	 DWORD PTR _rcRight$[ebp], ecx
  01050	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01053	89 55 c8	 mov	 DWORD PTR _rcRight$[ebp+4], edx
  01056	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01059	89 4d cc	 mov	 DWORD PTR _rcRight$[ebp+8], ecx
  0105c	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0105f	89 55 d0	 mov	 DWORD PTR _rcRight$[ebp+12], edx

; 259  : 	rcRight.left = rcRight.right - pRectRight->GetWidth();

  01062	8b 4d 18	 mov	 ecx, DWORD PTR _pRectRight$[ebp]
  01065	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  0106a	8b 4d cc	 mov	 ecx, DWORD PTR _rcRight$[ebp+8]
  0106d	2b c8		 sub	 ecx, eax
  0106f	89 4d c4	 mov	 DWORD PTR _rcRight$[ebp], ecx

; 260  : 	pRectRight->SetCDibRect( rcRight );

  01072	83 ec 10	 sub	 esp, 16			; 00000010H
  01075	8b d4		 mov	 edx, esp
  01077	8b 45 c4	 mov	 eax, DWORD PTR _rcRight$[ebp]
  0107a	89 02		 mov	 DWORD PTR [edx], eax
  0107c	8b 4d c8	 mov	 ecx, DWORD PTR _rcRight$[ebp+4]
  0107f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  01082	8b 45 cc	 mov	 eax, DWORD PTR _rcRight$[ebp+8]
  01085	89 42 08	 mov	 DWORD PTR [edx+8], eax
  01088	8b 4d d0	 mov	 ecx, DWORD PTR _rcRight$[ebp+12]
  0108b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0108e	8b 4d 18	 mov	 ecx, DWORD PTR _pRectRight$[ebp]
  01091	e8 00 00 00 00	 call	 ?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ; CDibBitmap::SetCDibRect

; 261  : 	pRectRight->Draw( pDc, TRUE, m_colMask );	

  01096	6a 01		 push	 1
  01098	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  0109b	8b 82 c8 00 00
	00		 mov	 eax, DWORD PTR [edx+200]
  010a1	50		 push	 eax
  010a2	6a 01		 push	 1
  010a4	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  010a7	51		 push	 ecx
  010a8	8b 4d 18	 mov	 ecx, DWORD PTR _pRectRight$[ebp]
  010ab	e8 00 00 00 00	 call	 ?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ; CDibBitmap::Draw

; 262  : 
; 263  : 	CRect rcMiddle(rcRect);

  010b0	8b 55 0c	 mov	 edx, DWORD PTR _rcRect$[ebp]
  010b3	8b 02		 mov	 eax, DWORD PTR [edx]
  010b5	89 45 b4	 mov	 DWORD PTR _rcMiddle$[ebp], eax
  010b8	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  010bb	89 4d b8	 mov	 DWORD PTR _rcMiddle$[ebp+4], ecx
  010be	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  010c1	89 45 bc	 mov	 DWORD PTR _rcMiddle$[ebp+8], eax
  010c4	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  010c7	89 4d c0	 mov	 DWORD PTR _rcMiddle$[ebp+12], ecx

; 264  : 	rcMiddle.left  = rcLeft.right;

  010ca	8b 55 ec	 mov	 edx, DWORD PTR _rcLeft$[ebp+8]
  010cd	89 55 b4	 mov	 DWORD PTR _rcMiddle$[ebp], edx

; 265  : 	rcMiddle.right = rcRight.left;

  010d0	8b 45 c4	 mov	 eax, DWORD PTR _rcRight$[ebp]
  010d3	89 45 bc	 mov	 DWORD PTR _rcMiddle$[ebp+8], eax

; 266  : 	pRectMiddle->SetCDibRect( rcMiddle );

  010d6	83 ec 10	 sub	 esp, 16			; 00000010H
  010d9	8b cc		 mov	 ecx, esp
  010db	8b 55 b4	 mov	 edx, DWORD PTR _rcMiddle$[ebp]
  010de	89 11		 mov	 DWORD PTR [ecx], edx
  010e0	8b 45 b8	 mov	 eax, DWORD PTR _rcMiddle$[ebp+4]
  010e3	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  010e6	8b 55 bc	 mov	 edx, DWORD PTR _rcMiddle$[ebp+8]
  010e9	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  010ec	8b 45 c0	 mov	 eax, DWORD PTR _rcMiddle$[ebp+12]
  010ef	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  010f2	8b 4d 14	 mov	 ecx, DWORD PTR _pRectMiddle$[ebp]
  010f5	e8 00 00 00 00	 call	 ?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ; CDibBitmap::SetCDibRect

; 267  : 	pRectMiddle->Draw( pDc, TRUE, m_colMask );	

  010fa	6a 01		 push	 1
  010fc	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  010ff	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  01105	52		 push	 edx
  01106	6a 01		 push	 1
  01108	8b 45 08	 mov	 eax, DWORD PTR _pDc$[ebp]
  0110b	50		 push	 eax
  0110c	8b 4d 14	 mov	 ecx, DWORD PTR _pRectMiddle$[ebp]
  0110f	e8 00 00 00 00	 call	 ?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ; CDibBitmap::Draw

; 268  : 
; 269  : 	//
; 270  : 	CRect rcText( rcRect );

  01114	8b 4d 0c	 mov	 ecx, DWORD PTR _rcRect$[ebp]
  01117	8b 11		 mov	 edx, DWORD PTR [ecx]
  01119	89 55 d4	 mov	 DWORD PTR _rcText$[ebp], edx
  0111c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0111f	89 45 d8	 mov	 DWORD PTR _rcText$[ebp+4], eax
  01122	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01125	89 55 dc	 mov	 DWORD PTR _rcText$[ebp+8], edx
  01128	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0112b	89 45 e0	 mov	 DWORD PTR _rcText$[ebp+12], eax

; 271  : 	rcText.left  = rcText.left + WIDTH_TEXT_LEFT_MARGIN;

  0112e	8b 4d d4	 mov	 ecx, DWORD PTR _rcText$[ebp]
  01131	83 c1 05	 add	 ecx, 5
  01134	89 4d d4	 mov	 DWORD PTR _rcText$[ebp], ecx

; 272  : 	rcText.right = rcClose.left;

  01137	8b 55 1c	 mov	 edx, DWORD PTR _rcClose$[ebp]
  0113a	8b 02		 mov	 eax, DWORD PTR [edx]
  0113c	89 45 dc	 mov	 DWORD PTR _rcText$[ebp+8], eax

; 273  : 	if( !rcText.IsRectEmpty() )

  0113f	8d 4d d4	 lea	 ecx, DWORD PTR _rcText$[ebp]
  01142	e8 00 00 00 00	 call	 ?IsRectEmpty@CRect@@QBEHXZ ; CRect::IsRectEmpty
  01147	85 c0		 test	 eax, eax
  01149	0f 85 be 00 00
	00		 jne	 $L199934

; 274  : 	{
; 275  : 		pDc->SetBkMode( TRANSPARENT );

  0114f	6a 01		 push	 1
  01151	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  01154	e8 00 00 00 00	 call	 ?SetBkMode@CDC@@QAEHH@Z	; CDC::SetBkMode

; 276  : 
; 277  : 		COLORREF colOld = pDc->GetTextColor();

  01159	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  0115c	e8 00 00 00 00	 call	 ?GetTextColor@CDC@@QBEKXZ ; CDC::GetTextColor
  01161	89 45 ac	 mov	 DWORD PTR _colOld$199935[ebp], eax

; 278  : 		CFont* fontOld = NULL;

  01164	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _fontOld$199936[ebp], 0

; 279  : 		if( bDown )

  0116b	0f b6 4d 40	 movzx	 ecx, BYTE PTR _bDown$[ebp]
  0116f	85 c9		 test	 ecx, ecx
  01171	74 2c		 je	 SHORT $L199937

; 280  : 		{
; 281  : 			pDc->SetTextColor( m_colDownTextColor );

  01173	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  01176	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  0117c	50		 push	 eax
  0117d	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  01180	8b 11		 mov	 edx, DWORD PTR [ecx]
  01182	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  01185	ff 52 38	 call	 DWORD PTR [edx+56]

; 282  : 			fontOld = pDc->SelectObject( &m_fontDown );

  01188	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0118b	83 c0 68	 add	 eax, 104		; 00000068H
  0118e	50		 push	 eax
  0118f	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  01192	8b 11		 mov	 edx, DWORD PTR [ecx]
  01194	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  01197	ff 52 30	 call	 DWORD PTR [edx+48]
  0119a	89 45 b0	 mov	 DWORD PTR _fontOld$199936[ebp], eax

; 283  : 		}else

  0119d	eb 2a		 jmp	 SHORT $L199938
$L199937:

; 284  : 		{
; 285  : 			pDc->SetTextColor( m_colNormalTextColor );

  0119f	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  011a2	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  011a8	51		 push	 ecx
  011a9	8b 55 08	 mov	 edx, DWORD PTR _pDc$[ebp]
  011ac	8b 02		 mov	 eax, DWORD PTR [edx]
  011ae	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  011b1	ff 50 38	 call	 DWORD PTR [eax+56]

; 286  : 			fontOld = pDc->SelectObject( &m_fontNormal );

  011b4	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  011b7	83 c1 60	 add	 ecx, 96			; 00000060H
  011ba	51		 push	 ecx
  011bb	8b 55 08	 mov	 edx, DWORD PTR _pDc$[ebp]
  011be	8b 02		 mov	 eax, DWORD PTR [edx]
  011c0	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  011c3	ff 50 30	 call	 DWORD PTR [eax+48]
  011c6	89 45 b0	 mov	 DWORD PTR _fontOld$199936[ebp], eax
$L199938:

; 287  : 		}
; 288  : 		pDc->DrawText( strText.c_str(), -1, &rcText, /*DT_LEFT*/DT_CENTER|DT_VCENTER|DT_SINGLELINE|DT_END_ELLIPSIS );

  011c9	68 25 80 00 00	 push	 32805			; 00008025H
  011ce	8d 4d d4	 lea	 ecx, DWORD PTR _rcText$[ebp]
  011d1	51		 push	 ecx
  011d2	6a ff		 push	 -1
  011d4	8d 4d 24	 lea	 ecx, DWORD PTR _strText$[ebp]
  011d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  011dd	50		 push	 eax
  011de	8b 55 08	 mov	 edx, DWORD PTR _pDc$[ebp]
  011e1	8b 02		 mov	 eax, DWORD PTR [edx]
  011e3	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  011e6	ff 50 70	 call	 DWORD PTR [eax+112]

; 289  : 
; 290  : 		pDc->SetTextColor( colOld );

  011e9	8b 4d ac	 mov	 ecx, DWORD PTR _colOld$199935[ebp]
  011ec	51		 push	 ecx
  011ed	8b 55 08	 mov	 edx, DWORD PTR _pDc$[ebp]
  011f0	8b 02		 mov	 eax, DWORD PTR [edx]
  011f2	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  011f5	ff 50 38	 call	 DWORD PTR [eax+56]

; 291  : 		if( fontOld != NULL )

  011f8	83 7d b0 00	 cmp	 DWORD PTR _fontOld$199936[ebp], 0
  011fc	74 0f		 je	 SHORT $L199934

; 292  : 		{
; 293  : 			pDc->SelectObject( fontOld );

  011fe	8b 4d b0	 mov	 ecx, DWORD PTR _fontOld$199936[ebp]
  01201	51		 push	 ecx
  01202	8b 55 08	 mov	 edx, DWORD PTR _pDc$[ebp]
  01205	8b 02		 mov	 eax, DWORD PTR [edx]
  01207	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  0120a	ff 50 30	 call	 DWORD PTR [eax+48]
$L199934:

; 294  : 		}
; 295  : 	}
; 296  : 	//
; 297  : 	pClose->SetCDibRect( rcClose );

  0120d	8b 4d 1c	 mov	 ecx, DWORD PTR _rcClose$[ebp]
  01210	83 ec 10	 sub	 esp, 16			; 00000010H
  01213	8b d4		 mov	 edx, esp
  01215	8b 01		 mov	 eax, DWORD PTR [ecx]
  01217	89 02		 mov	 DWORD PTR [edx], eax
  01219	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0121c	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0121f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  01222	89 42 08	 mov	 DWORD PTR [edx+8], eax
  01225	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  01228	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0122b	8b 4d 20	 mov	 ecx, DWORD PTR _pClose$[ebp]
  0122e	e8 00 00 00 00	 call	 ?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ; CDibBitmap::SetCDibRect

; 298  : 	pClose->Draw( pDc, TRUE, m_colMask );

  01233	6a 01		 push	 1
  01235	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  01238	8b 82 c8 00 00
	00		 mov	 eax, DWORD PTR [edx+200]
  0123e	50		 push	 eax
  0123f	6a 01		 push	 1
  01241	8b 4d 08	 mov	 ecx, DWORD PTR _pDc$[ebp]
  01244	51		 push	 ecx
  01245	8b 4d 20	 mov	 ecx, DWORD PTR _pClose$[ebp]
  01248	e8 00 00 00 00	 call	 ?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ; CDibBitmap::Draw

; 299  : }

  0124d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01254	8d 4d 24	 lea	 ecx, DWORD PTR _strText$[ebp]
  01257	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L199927:
  0125d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01260	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01267	8b e5		 mov	 esp, ebp
  01269	5d		 pop	 ebp
  0126a	c2 3c 00	 ret	 60			; 0000003cH
_TEXT	ENDS
text$x	SEGMENT
$L201682:
  0016a	8d 4d 24	 lea	 ecx, DWORD PTR _strText$[ebp]
  0016d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?DrawTabItemRect@CTabBarWnd@@AAEXPAVCDC@@AAVCRect@@PAVCDibBitmap@@2212V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:
  00173	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201684
  00178	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DrawTabItemRect@CTabBarWnd@@AAEXPAVCDC@@AAVCRect@@PAVCDibBitmap@@2212V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; CTabBarWnd::DrawTabItemRect
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -160						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

  00011	c7 85 60 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _ver$[ebp], 148 ; 00000094H

; 139  : 	::GetVersionEx( &ver );

  0001b	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _ver$[ebp]
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00028	83 bd 70 ff ff
	ff 02		 cmp	 DWORD PTR _ver$[ebp+16], 2
  0002f	75 15		 jne	 SHORT $L24173
  00031	83 bd 64 ff ff
	ff 05		 cmp	 DWORD PTR _ver$[ebp+4], 5
  00038	72 0c		 jb	 SHORT $L24173

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  0003a	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

  00044	eb 0a		 jmp	 SHORT $L24174
$L24173:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00046	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L24174:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  00050	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pfnGetThreadACP$[ebp]
  00056	51		 push	 ecx
  00057	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0005c	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pNew$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pp$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 93   : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$24161 = -24					; size = 4
_lcidThread$ = -20					; size = 4
_szACP$ = -16						; size = 7
__$ArrayPad$ = -8					; size = 4
_nACP$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0
  0001b	89 45 ec	 mov	 DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  0001e	6a 07		 push	 7
  00020	8d 45 f0	 lea	 eax, DWORD PTR _szACP$[ebp]
  00023	50		 push	 eax
  00024	68 04 10 00 00	 push	 4100			; 00001004H
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _lcidThread$[ebp]
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00033	85 c0		 test	 eax, eax
  00035	74 34		 je	 SHORT $L24160

; 111  : 	{
; 112  : 		char* pch = szACP;

  00037	8d 55 f0	 lea	 edx, DWORD PTR _szACP$[ebp]
  0003a	89 55 e8	 mov	 DWORD PTR _pch$24161[ebp], edx
$L24163:

; 113  : 		while (*pch != '\0')

  0003d	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00040	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00043	85 c9		 test	 ecx, ecx
  00045	74 24		 je	 SHORT $L24160

; 114  : 		{
; 115  : 			nACP *= 10;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  0004a	6b d2 0a	 imul	 edx, 10			; 0000000aH
  0004d	89 55 fc	 mov	 DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

  00050	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  00059	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  0005d	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
  00060	8b 4d e8	 mov	 ecx, DWORD PTR _pch$24161[ebp]
  00063	83 c1 01	 add	 ecx, 1
  00066	89 4d e8	 mov	 DWORD PTR _pch$24161[ebp], ecx

; 117  : 		}

  00069	eb d2		 jmp	 SHORT $L24163
$L24160:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  0006b	83 7d fc 00	 cmp	 DWORD PTR _nACP$[ebp], 0
  0006f	75 09		 jne	 SHORT $L24165

; 121  : 		nACP = ::GetACP();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  00077	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
$L24165:

; 122  : 
; 123  : 	return nACP;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _nACP$[ebp]

; 124  : }

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  : 	return( CP_THREAD_ACP );

  00003	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
PUBLIC	?Invalidate@CWnd@@QAEXH@Z			; CWnd::Invalidate
EXTRN	?AfxGetMainWindow@@YAPAVCWnd@@XZ:NEAR		; AfxGetMainWindow
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabbarwnd.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_item$ = 8						; size = 4
?ITabBarOb_CreateNewTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarWnd::ITabBarOb_CreateNewTab
; _this$ = ecx

; 302  : {

  01270	55		 push	 ebp
  01271	8b ec		 mov	 ebp, esp
  01273	51		 push	 ecx
  01274	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 303  : 	AfxGetMainWindow()->Invalidate ();

  01277	6a 01		 push	 1
  01279	e8 00 00 00 00	 call	 ?AfxGetMainWindow@@YAPAVCWnd@@XZ ; AfxGetMainWindow
  0127e	8b c8		 mov	 ecx, eax
  01280	e8 00 00 00 00	 call	 ?Invalidate@CWnd@@QAEXH@Z ; CWnd::Invalidate

; 304  : 
; 305  : 	CalcTabPosition();

  01285	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01288	83 e9 58	 sub	 ecx, 88			; 00000058H
  0128b	e8 00 00 00 00	 call	 ?CalcTabPosition@CTabBarWnd@@AAEXXZ ; CTabBarWnd::CalcTabPosition

; 306  : 	Invalidate();

  01290	6a 01		 push	 1
  01292	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01295	83 e9 58	 sub	 ecx, 88			; 00000058H
  01298	e8 00 00 00 00	 call	 ?Invalidate@CWnd@@QAEXH@Z ; CWnd::Invalidate

; 307  : }

  0129d	8b e5		 mov	 esp, ebp
  0129f	5d		 pop	 ebp
  012a0	c2 04 00	 ret	 4
?ITabBarOb_CreateNewTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z ENDP ; CTabBarWnd::ITabBarOb_CreateNewTab
; Function compile flags: /Odt
_this$ = -4						; size = 4
_item$ = 8						; size = 4
?ITabBarOb_OpenExistTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarWnd::ITabBarOb_OpenExistTab
; _this$ = ecx

; 310  : {

  012b0	55		 push	 ebp
  012b1	8b ec		 mov	 ebp, esp
  012b3	51		 push	 ecx
  012b4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 311  : 	AfxGetMainWindow ()->Invalidate ();

  012b7	6a 01		 push	 1
  012b9	e8 00 00 00 00	 call	 ?AfxGetMainWindow@@YAPAVCWnd@@XZ ; AfxGetMainWindow
  012be	8b c8		 mov	 ecx, eax
  012c0	e8 00 00 00 00	 call	 ?Invalidate@CWnd@@QAEXH@Z ; CWnd::Invalidate

; 312  : 
; 313  : 	CalcTabPosition();

  012c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012c8	83 e9 58	 sub	 ecx, 88			; 00000058H
  012cb	e8 00 00 00 00	 call	 ?CalcTabPosition@CTabBarWnd@@AAEXXZ ; CTabBarWnd::CalcTabPosition

; 314  : 	Invalidate();

  012d0	6a 01		 push	 1
  012d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012d5	83 e9 58	 sub	 ecx, 88			; 00000058H
  012d8	e8 00 00 00 00	 call	 ?Invalidate@CWnd@@QAEXH@Z ; CWnd::Invalidate

; 315  : }

  012dd	8b e5		 mov	 esp, ebp
  012df	5d		 pop	 ebp
  012e0	c2 04 00	 ret	 4
?ITabBarOb_OpenExistTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z ENDP ; CTabBarWnd::ITabBarOb_OpenExistTab
; Function compile flags: /Odt
_this$ = -4						; size = 4
_item$ = 8						; size = 4
?ITabBarOb_DelTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarWnd::ITabBarOb_DelTab
; _this$ = ecx

; 318  : {

  012f0	55		 push	 ebp
  012f1	8b ec		 mov	 ebp, esp
  012f3	51		 push	 ecx
  012f4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 319  : 	CalcTabPosition();

  012f7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012fa	83 e9 58	 sub	 ecx, 88			; 00000058H
  012fd	e8 00 00 00 00	 call	 ?CalcTabPosition@CTabBarWnd@@AAEXXZ ; CTabBarWnd::CalcTabPosition

; 320  : 	Invalidate();

  01302	6a 01		 push	 1
  01304	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01307	83 e9 58	 sub	 ecx, 88			; 00000058H
  0130a	e8 00 00 00 00	 call	 ?Invalidate@CWnd@@QAEXH@Z ; CWnd::Invalidate

; 321  : }

  0130f	8b e5		 mov	 esp, ebp
  01311	5d		 pop	 ebp
  01312	c2 04 00	 ret	 4
?ITabBarOb_DelTab@CTabBarWnd@@UAEXAAUTAB_ITEM@@@Z ENDP	; CTabBarWnd::ITabBarOb_DelTab
_TEXT	ENDS
PUBLIC	?ClientToScreen@CWnd@@QBEXPAUtagPOINT@@@Z	; CWnd::ClientToScreen
PUBLIC	?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z	; CWnd::ScreenToClient
PUBLIC	??0CPoint@@QAE@XZ				; CPoint::CPoint
EXTRN	?unSHOW_CLOSE_BUTTON@CBalloonHelp@@2IB:DWORD	; CBalloonHelp::unSHOW_CLOSE_BUTTON
EXTRN	?unDISABLE_XP_SHADOW@CBalloonHelp@@2IB:DWORD	; CBalloonHelp::unDISABLE_XP_SHADOW
EXTRN	?LaunchBalloon@CBalloonHelp@@SAXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0ABVCPoint@@PBDIPAVCWnd@@V23@I@Z:NEAR ; CBalloonHelp::LaunchBalloon
EXTRN	?AfxGetDataManager2@@YAPAVIDataManager@@XZ:NEAR	; AfxGetDataManager2
xdata$x	SEGMENT
$T201712 DD	0ffffffffH
	DD	FLAT:$L201706
	DD	00H
	DD	FLAT:$L201707
	DD	01H
	DD	FLAT:$L201708
$T201710 DD	019930520H
	DD	03H
	DD	FLAT:$T201712
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv161 = -72						; size = 4
tv152 = -68						; size = 4
tv72 = -64						; size = 4
tv66 = -60						; size = 4
_this$ = -56						; size = 4
$T201705 = -52						; size = 4
$T201704 = -48						; size = 4
$T201703 = -44						; size = 4
_rcClose$ = -40						; size = 16
_iCur$ = -24						; size = 4
_point$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_iErrorCode$ = 8					; size = 4
?ITabBarOb_OpenTabError@CTabBarWnd@@UAEXH@Z PROC NEAR	; CTabBarWnd::ITabBarOb_OpenTabError
; _this$ = ecx

; 324  : {

  01320	55		 push	 ebp
  01321	8b ec		 mov	 ebp, esp
  01323	6a ff		 push	 -1
  01325	68 00 00 00 00	 push	 __ehhandler$?ITabBarOb_OpenTabError@CTabBarWnd@@UAEXH@Z
  0132a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01330	50		 push	 eax
  01331	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01338	83 ec 3c	 sub	 esp, 60			; 0000003cH
  0133b	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 325  : 	//
; 326  : 	int iCur = GLOBAL_TABBARDATA->ITabBar_GetCurPos();

  0133e	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  01343	89 45 c4	 mov	 DWORD PTR tv66[ebp], eax
  01346	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_TABBAR
  0134b	8b 45 c4	 mov	 eax, DWORD PTR tv66[ebp]
  0134e	8b 10		 mov	 edx, DWORD PTR [eax]
  01350	8b 4d c4	 mov	 ecx, DWORD PTR tv66[ebp]
  01353	ff 52 0c	 call	 DWORD PTR [edx+12]
  01356	89 45 c0	 mov	 DWORD PTR tv72[ebp], eax
  01359	8b 45 c0	 mov	 eax, DWORD PTR tv72[ebp]
  0135c	8b 10		 mov	 edx, DWORD PTR [eax]
  0135e	8b 4d c0	 mov	 ecx, DWORD PTR tv72[ebp]
  01361	ff 52 14	 call	 DWORD PTR [edx+20]
  01364	89 45 e8	 mov	 DWORD PTR _iCur$[ebp], eax

; 327  : 	if( iCur == 0 )

  01367	83 7d e8 00	 cmp	 DWORD PTR _iCur$[ebp], 0
  0136b	75 07		 jne	 SHORT $L199958

; 328  : 	{
; 329  : 		iCur = 1;

  0136d	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _iCur$[ebp], 1
$L199958:

; 330  : 	}
; 331  : 	CRect rcClose = m_vecClose[iCur];

  01374	8b 45 e8	 mov	 eax, DWORD PTR _iCur$[ebp]
  01377	50		 push	 eax
  01378	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0137b	83 c1 28	 add	 ecx, 40			; 00000028H
  0137e	e8 00 00 00 00	 call	 ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
  01383	8b 08		 mov	 ecx, DWORD PTR [eax]
  01385	89 4d d8	 mov	 DWORD PTR _rcClose$[ebp], ecx
  01388	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0138b	89 55 dc	 mov	 DWORD PTR _rcClose$[ebp+4], edx
  0138e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01391	89 4d e0	 mov	 DWORD PTR _rcClose$[ebp+8], ecx
  01394	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01397	89 55 e4	 mov	 DWORD PTR _rcClose$[ebp+12], edx

; 332  : 	CPoint point;

  0139a	8d 4d ec	 lea	 ecx, DWORD PTR _point$[ebp]
  0139d	e8 00 00 00 00	 call	 ??0CPoint@@QAE@XZ	; CPoint::CPoint

; 333  : 	point.x = rcClose.right - (rcClose.Width()/2);

  013a2	8d 4d d8	 lea	 ecx, DWORD PTR _rcClose$[ebp]
  013a5	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  013aa	99		 cdq
  013ab	2b c2		 sub	 eax, edx
  013ad	d1 f8		 sar	 eax, 1
  013af	8b 4d e0	 mov	 ecx, DWORD PTR _rcClose$[ebp+8]
  013b2	2b c8		 sub	 ecx, eax
  013b4	89 4d ec	 mov	 DWORD PTR _point$[ebp], ecx

; 334  : 	point.y = rcClose.bottom;

  013b7	8b 55 e4	 mov	 edx, DWORD PTR _rcClose$[ebp+12]
  013ba	89 55 f0	 mov	 DWORD PTR _point$[ebp+4], edx

; 335  : 	ClientToScreen( &point );

  013bd	8d 45 ec	 lea	 eax, DWORD PTR _point$[ebp]
  013c0	50		 push	 eax
  013c1	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  013c4	83 e9 58	 sub	 ecx, 88			; 00000058H
  013c7	e8 00 00 00 00	 call	 ?ClientToScreen@CWnd@@QBEXPAUtagPOINT@@@Z ; CWnd::ClientToScreen

; 336  : 	AfxGetMainWindow()->ScreenToClient(&point);

  013cc	8d 4d ec	 lea	 ecx, DWORD PTR _point$[ebp]
  013cf	51		 push	 ecx
  013d0	e8 00 00 00 00	 call	 ?AfxGetMainWindow@@YAPAVCWnd@@XZ ; AfxGetMainWindow
  013d5	8b c8		 mov	 ecx, eax
  013d7	e8 00 00 00 00	 call	 ?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z ; CWnd::ScreenToClient

; 337  : 	CBalloonHelp::LaunchBalloon( "","",
; 338  : 		point,IDI_INFORMATION,CBalloonHelp::unSHOW_CLOSE_BUTTON|CBalloonHelp::unDISABLE_XP_SHADOW,
; 339  : 		AfxGetMainWindow(),"",5000);

  013dc	68 00 00 00 00	 push	 OFFSET FLAT:$SG199968
  013e1	8d 4d d0	 lea	 ecx, DWORD PTR $T201704[ebp]
  013e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  013ea	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  013f1	68 00 00 00 00	 push	 OFFSET FLAT:$SG199969
  013f6	8d 4d cc	 lea	 ecx, DWORD PTR $T201705[ebp]
  013f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  013ff	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01403	68 88 13 00 00	 push	 5000			; 00001388H
  01408	51		 push	 ecx
  01409	8b cc		 mov	 ecx, esp
  0140b	89 65 d4	 mov	 DWORD PTR $T201703[ebp], esp
  0140e	68 00 00 00 00	 push	 OFFSET FLAT:$SG199967
  01413	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  01419	89 45 bc	 mov	 DWORD PTR tv152[ebp], eax
  0141c	8b 55 bc	 mov	 edx, DWORD PTR tv152[ebp]
  0141f	89 55 b8	 mov	 DWORD PTR tv161[ebp], edx
  01422	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01426	e8 00 00 00 00	 call	 ?AfxGetMainWindow@@YAPAVCWnd@@XZ ; AfxGetMainWindow
  0142b	50		 push	 eax
  0142c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?unSHOW_CLOSE_BUTTON@CBalloonHelp@@2IB ; CBalloonHelp::unSHOW_CLOSE_BUTTON
  01431	0b 05 00 00 00
	00		 or	 eax, DWORD PTR ?unDISABLE_XP_SHADOW@CBalloonHelp@@2IB ; CBalloonHelp::unDISABLE_XP_SHADOW
  01437	50		 push	 eax
  01438	68 04 7f 00 00	 push	 32516			; 00007f04H
  0143d	8d 4d ec	 lea	 ecx, DWORD PTR _point$[ebp]
  01440	51		 push	 ecx
  01441	8d 55 d0	 lea	 edx, DWORD PTR $T201704[ebp]
  01444	52		 push	 edx
  01445	8d 45 cc	 lea	 eax, DWORD PTR $T201705[ebp]
  01448	50		 push	 eax
  01449	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0144d	e8 00 00 00 00	 call	 ?LaunchBalloon@CBalloonHelp@@SAXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0ABVCPoint@@PBDIPAVCWnd@@V23@I@Z ; CBalloonHelp::LaunchBalloon
  01452	83 c4 20	 add	 esp, 32			; 00000020H
  01455	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01459	8d 4d cc	 lea	 ecx, DWORD PTR $T201705[ebp]
  0145c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  01462	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01469	8d 4d d0	 lea	 ecx, DWORD PTR $T201704[ebp]
  0146c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 340  : }

  01472	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01475	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0147c	8b e5		 mov	 esp, ebp
  0147e	5d		 pop	 ebp
  0147f	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L201706:
  0017d	8d 4d d0	 lea	 ecx, DWORD PTR $T201704[ebp]
  00180	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L201707:
  00186	8d 4d cc	 lea	 ecx, DWORD PTR $T201705[ebp]
  00189	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L201708:
  0018f	8b 4d d4	 mov	 ecx, DWORD PTR $T201703[ebp]
  00192	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?ITabBarOb_OpenTabError@CTabBarWnd@@UAEXH@Z:
  00198	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201710
  0019d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ITabBarOb_OpenTabError@CTabBarWnd@@UAEXH@Z ENDP	; CTabBarWnd::ITabBarOb_OpenTabError
PUBLIC	?push_back@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXABVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::push_back
PUBLIC	?clear@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXXZ ; std::vector<CRect,std::allocator<CRect> >::clear
PUBLIC	?SetRectEmpty@CRect@@QAEXXZ			; CRect::SetRectEmpty
PUBLIC	?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
PUBLIC	?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear
EXTRN	?GetHeight@CDibBitmap@@QAEHXZ:NEAR		; CDibBitmap::GetHeight
; Function compile flags: /Odt
_TEXT	SEGMENT
tv93 = -84						; size = 4
tv87 = -80						; size = 4
tv73 = -76						; size = 4
tv67 = -72						; size = 4
_this$ = -68						; size = 4
_i$199985 = -64						; size = 4
_rcClose$ = -60						; size = 16
_iNewWindowStartPos$ = -44				; size = 4
_rcBtn$ = -40						; size = 16
_iStartPos$ = -24					; size = 4
_iWidth$ = -20						; size = 4
_rc$ = -16						; size = 16
?CalcTabPosition@CTabBarWnd@@AAEXXZ PROC NEAR		; CTabBarWnd::CalcTabPosition
; _this$ = ecx

; 343  : {

  01490	55		 push	 ebp
  01491	8b ec		 mov	 ebp, esp
  01493	83 ec 54	 sub	 esp, 84			; 00000054H
  01496	56		 push	 esi
  01497	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 344  : 	m_iTabCur = GLOBAL_TABBARDATA->ITabBar_GetCurPos();

  0149a	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  0149f	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
  014a2	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_TABBAR
  014a7	8b 45 b8	 mov	 eax, DWORD PTR tv67[ebp]
  014aa	8b 10		 mov	 edx, DWORD PTR [eax]
  014ac	8b 4d b8	 mov	 ecx, DWORD PTR tv67[ebp]
  014af	ff 52 0c	 call	 DWORD PTR [edx+12]
  014b2	89 45 b4	 mov	 DWORD PTR tv73[ebp], eax
  014b5	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  014b8	8b 10		 mov	 edx, DWORD PTR [eax]
  014ba	8b 4d b4	 mov	 ecx, DWORD PTR tv73[ebp]
  014bd	ff 52 14	 call	 DWORD PTR [edx+20]
  014c0	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  014c3	89 81 b4 00 00
	00		 mov	 DWORD PTR [ecx+180], eax

; 345  : 
; 346  : 	m_vecTab.clear();

  014c9	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  014cc	83 c1 70	 add	 ecx, 112		; 00000070H
  014cf	e8 00 00 00 00	 call	 ?clear@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXXZ ; std::vector<CRect,std::allocator<CRect> >::clear

; 347  : 	m_vecClose.clear();

  014d4	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  014d7	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  014dd	e8 00 00 00 00	 call	 ?clear@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXXZ ; std::vector<CRect,std::allocator<CRect> >::clear

; 348  : 	m_vecTi.clear();

  014e2	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  014e5	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  014eb	e8 00 00 00 00	 call	 ?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear

; 349  : 	m_rectNewWindow.SetRectEmpty();

  014f0	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  014f3	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  014f9	e8 00 00 00 00	 call	 ?SetRectEmpty@CRect@@QAEXXZ ; CRect::SetRectEmpty

; 350  : 	GLOBAL_TABBARDATA->ITabBar_GetTabBarData( m_vecTi );

  014fe	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  01503	89 45 b0	 mov	 DWORD PTR tv87[ebp], eax
  01506	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_TABBAR
  0150b	8b 55 b0	 mov	 edx, DWORD PTR tv87[ebp]
  0150e	8b 02		 mov	 eax, DWORD PTR [edx]
  01510	8b 4d b0	 mov	 ecx, DWORD PTR tv87[ebp]
  01513	ff 50 0c	 call	 DWORD PTR [eax+12]
  01516	89 45 ac	 mov	 DWORD PTR tv93[ebp], eax
  01519	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0151c	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  01522	51		 push	 ecx
  01523	8b 55 ac	 mov	 edx, DWORD PTR tv93[ebp]
  01526	8b 02		 mov	 eax, DWORD PTR [edx]
  01528	8b 4d ac	 mov	 ecx, DWORD PTR tv93[ebp]
  0152b	ff 50 1c	 call	 DWORD PTR [eax+28]

; 351  : 
; 352  : 	CRect rc;

  0152e	8d 4d f0	 lea	 ecx, DWORD PTR _rc$[ebp]
  01531	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 353  : 	GetClientRect( &rc );

  01536	8d 4d f0	 lea	 ecx, DWORD PTR _rc$[ebp]
  01539	51		 push	 ecx
  0153a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0153d	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 354  : 	if( rc.Width() == 0 || rc.Height() == 0 || m_vecTi.size() == 0 )

  01542	8d 4d f0	 lea	 ecx, DWORD PTR _rc$[ebp]
  01545	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  0154a	85 c0		 test	 eax, eax
  0154c	74 1e		 je	 SHORT $L199977
  0154e	8d 4d f0	 lea	 ecx, DWORD PTR _rc$[ebp]
  01551	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01556	85 c0		 test	 eax, eax
  01558	74 12		 je	 SHORT $L199977
  0155a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0155d	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  01563	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  01568	85 c0		 test	 eax, eax
  0156a	75 05		 jne	 SHORT $L199976
$L199977:

; 355  : 		return;

  0156c	e9 d5 01 00 00	 jmp	 $L199972
$L199976:

; 356  : 
; 357  : 	//rc
; 358  : 	rc.left += 5;

  01571	8b 55 f0	 mov	 edx, DWORD PTR _rc$[ebp]
  01574	83 c2 05	 add	 edx, 5
  01577	89 55 f0	 mov	 DWORD PTR _rc$[ebp], edx

; 359  : 	rc.right -= 5;

  0157a	8b 45 f8	 mov	 eax, DWORD PTR _rc$[ebp+8]
  0157d	83 e8 05	 sub	 eax, 5
  01580	89 45 f8	 mov	 DWORD PTR _rc$[ebp+8], eax

; 360  : 	
; 361  : 	//iWidth	btn
; 362  : 	int iWidth = (int)(rc.Width() / m_vecTi.size());

  01583	8d 4d f0	 lea	 ecx, DWORD PTR _rc$[ebp]
  01586	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  0158b	8b f0		 mov	 esi, eax
  0158d	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  01590	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  01596	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  0159b	8b c8		 mov	 ecx, eax
  0159d	8b c6		 mov	 eax, esi
  0159f	33 d2		 xor	 edx, edx
  015a1	f7 f1		 div	 ecx
  015a3	89 45 ec	 mov	 DWORD PTR _iWidth$[ebp], eax

; 363  : 	if( iWidth > ONE_TAB_MAX_WIDTH )

  015a6	81 7d ec 96 00
	00 00		 cmp	 DWORD PTR _iWidth$[ebp], 150 ; 00000096H
  015ad	7e 07		 jle	 SHORT $L199980

; 364  : 	{
; 365  : 		iWidth = ONE_TAB_MAX_WIDTH;

  015af	c7 45 ec 96 00
	00 00		 mov	 DWORD PTR _iWidth$[ebp], 150 ; 00000096H
$L199980:

; 366  : 	}
; 367  : 
; 368  : 	CRect rcBtn( rc );

  015b6	8b 55 f0	 mov	 edx, DWORD PTR _rc$[ebp]
  015b9	89 55 d8	 mov	 DWORD PTR _rcBtn$[ebp], edx
  015bc	8b 45 f4	 mov	 eax, DWORD PTR _rc$[ebp+4]
  015bf	89 45 dc	 mov	 DWORD PTR _rcBtn$[ebp+4], eax
  015c2	8b 4d f8	 mov	 ecx, DWORD PTR _rc$[ebp+8]
  015c5	89 4d e0	 mov	 DWORD PTR _rcBtn$[ebp+8], ecx
  015c8	8b 55 fc	 mov	 edx, DWORD PTR _rc$[ebp+12]
  015cb	89 55 e4	 mov	 DWORD PTR _rcBtn$[ebp+12], edx

; 369  : 	CRect rcClose;

  015ce	8d 4d c4	 lea	 ecx, DWORD PTR _rcClose$[ebp]
  015d1	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 370  : 	int iStartPos = 5; //5

  015d6	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR _iStartPos$[ebp], 5

; 371  : 	int iNewWindowStartPos = iStartPos;

  015dd	8b 45 e8	 mov	 eax, DWORD PTR _iStartPos$[ebp]
  015e0	89 45 d4	 mov	 DWORD PTR _iNewWindowStartPos$[ebp], eax

; 372  : 	//btnbtn
; 373  : 	for( int i = 0; i < m_vecTi.size(); i++ )

  015e3	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$199985[ebp], 0
  015ea	eb 09		 jmp	 SHORT $L199986
$L199987:
  015ec	8b 4d c0	 mov	 ecx, DWORD PTR _i$199985[ebp]
  015ef	83 c1 01	 add	 ecx, 1
  015f2	89 4d c0	 mov	 DWORD PTR _i$199985[ebp], ecx
$L199986:
  015f5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  015f8	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  015fe	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  01603	39 45 c0	 cmp	 DWORD PTR _i$199985[ebp], eax
  01606	0f 83 e0 00 00
	00		 jae	 $L199988

; 374  : 	{
; 375  : 		rcBtn.left = i * iWidth + iStartPos;

  0160c	8b 55 c0	 mov	 edx, DWORD PTR _i$199985[ebp]
  0160f	0f af 55 ec	 imul	 edx, DWORD PTR _iWidth$[ebp]
  01613	03 55 e8	 add	 edx, DWORD PTR _iStartPos$[ebp]
  01616	89 55 d8	 mov	 DWORD PTR _rcBtn$[ebp], edx

; 376  : 		rcBtn.right = rcBtn.left + iWidth;

  01619	8b 45 d8	 mov	 eax, DWORD PTR _rcBtn$[ebp]
  0161c	03 45 ec	 add	 eax, DWORD PTR _iWidth$[ebp]
  0161f	89 45 e0	 mov	 DWORD PTR _rcBtn$[ebp+8], eax

; 377  : 		iNewWindowStartPos = rcBtn.right;

  01622	8b 4d e0	 mov	 ecx, DWORD PTR _rcBtn$[ebp+8]
  01625	89 4d d4	 mov	 DWORD PTR _iNewWindowStartPos$[ebp], ecx

; 378  : 		if( i == m_iTabCur )

  01628	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  0162b	8b 45 c0	 mov	 eax, DWORD PTR _i$199985[ebp]
  0162e	3b 82 b4 00 00
	00		 cmp	 eax, DWORD PTR [edx+180]
  01634	75 18		 jne	 SHORT $L199989

; 379  : 		{
; 380  : 			rcBtn.top = rcBtn.bottom - m_pBmpRectDownMiddle->GetHeight();

  01636	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  01639	8b 89 e8 00 00
	00		 mov	 ecx, DWORD PTR [ecx+232]
  0163f	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  01644	8b 55 e4	 mov	 edx, DWORD PTR _rcBtn$[ebp+12]
  01647	2b d0		 sub	 edx, eax
  01649	89 55 dc	 mov	 DWORD PTR _rcBtn$[ebp+4], edx

; 381  : 		}else

  0164c	eb 16		 jmp	 SHORT $L199990
$L199989:

; 382  : 		{
; 383  : 			rcBtn.top = rcBtn.bottom - m_pBmpRectNormalMiddle->GetHeight();

  0164e	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  01651	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  01657	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  0165c	8b 4d e4	 mov	 ecx, DWORD PTR _rcBtn$[ebp+12]
  0165f	2b c8		 sub	 ecx, eax
  01661	89 4d dc	 mov	 DWORD PTR _rcBtn$[ebp+4], ecx
$L199990:

; 384  : 		}
; 385  : 		
; 386  : 		m_vecTab.push_back( rcBtn );

  01664	8d 55 d8	 lea	 edx, DWORD PTR _rcBtn$[ebp]
  01667	52		 push	 edx
  01668	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0166b	83 c1 70	 add	 ecx, 112		; 00000070H
  0166e	e8 00 00 00 00	 call	 ?push_back@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXABVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::push_back

; 387  : 	
; 388  : 		//if( i == 0 || i == 1 || i == 2 ) //3
; 389  : 		if( i == 0 )

  01673	83 7d c0 00	 cmp	 DWORD PTR _i$199985[ebp], 0
  01677	75 20		 jne	 SHORT $L199991

; 390  : 		{
; 391  : 			rcClose.right = rcBtn.right - WIDTH_CLOSE_TO_RIGHT;

  01679	8b 45 e0	 mov	 eax, DWORD PTR _rcBtn$[ebp+8]
  0167c	83 e8 04	 sub	 eax, 4
  0167f	89 45 cc	 mov	 DWORD PTR _rcClose$[ebp+8], eax

; 392  : 			rcClose.left  = rcClose.right;	

  01682	8b 4d cc	 mov	 ecx, DWORD PTR _rcClose$[ebp+8]
  01685	89 4d c4	 mov	 DWORD PTR _rcClose$[ebp], ecx

; 393  : 			rcClose.top   = rcBtn.top + HEITH_CLOSE_TO_TOP;			

  01688	8b 55 dc	 mov	 edx, DWORD PTR _rcBtn$[ebp+4]
  0168b	83 c2 06	 add	 edx, 6
  0168e	89 55 c8	 mov	 DWORD PTR _rcClose$[ebp+4], edx

; 394  : 			rcClose.bottom = rcClose.top;

  01691	8b 45 c8	 mov	 eax, DWORD PTR _rcClose$[ebp+4]
  01694	89 45 d0	 mov	 DWORD PTR _rcClose$[ebp+12], eax

; 395  : 		}else

  01697	eb 3c		 jmp	 SHORT $L199992
$L199991:

; 396  : 		{
; 397  : 			rcClose.right = rcBtn.right - WIDTH_CLOSE_TO_RIGHT;

  01699	8b 4d e0	 mov	 ecx, DWORD PTR _rcBtn$[ebp+8]
  0169c	83 e9 04	 sub	 ecx, 4
  0169f	89 4d cc	 mov	 DWORD PTR _rcClose$[ebp+8], ecx

; 398  : 			rcClose.left  = rcClose.right - m_pBmpCloseNormal->GetWidth();	

  016a2	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  016a5	8b 8a f0 00 00
	00		 mov	 ecx, DWORD PTR [edx+240]
  016ab	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  016b0	8b 4d cc	 mov	 ecx, DWORD PTR _rcClose$[ebp+8]
  016b3	2b c8		 sub	 ecx, eax
  016b5	89 4d c4	 mov	 DWORD PTR _rcClose$[ebp], ecx

; 399  : 			rcClose.top   = rcBtn.top + HEITH_CLOSE_TO_TOP;			

  016b8	8b 55 dc	 mov	 edx, DWORD PTR _rcBtn$[ebp+4]
  016bb	83 c2 06	 add	 edx, 6
  016be	89 55 c8	 mov	 DWORD PTR _rcClose$[ebp+4], edx

; 400  : 			rcClose.bottom = rcClose.top + m_pBmpCloseNormal->GetHeight();

  016c1	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  016c4	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  016ca	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  016cf	03 45 c8	 add	 eax, DWORD PTR _rcClose$[ebp+4]
  016d2	89 45 d0	 mov	 DWORD PTR _rcClose$[ebp+12], eax
$L199992:

; 401  : 		}
; 402  : 		m_vecClose.push_back( rcClose );

  016d5	8d 4d c4	 lea	 ecx, DWORD PTR _rcClose$[ebp]
  016d8	51		 push	 ecx
  016d9	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  016dc	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  016e2	e8 00 00 00 00	 call	 ?push_back@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXABVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::push_back

; 403  : 	}

  016e7	e9 00 ff ff ff	 jmp	 $L199987
$L199988:

; 404  : 	m_rectNewWindow.left = iNewWindowStartPos;

  016ec	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  016ef	8b 45 d4	 mov	 eax, DWORD PTR _iNewWindowStartPos$[ebp]
  016f2	89 82 a0 00 00
	00		 mov	 DWORD PTR [edx+160], eax

; 405  : 	m_rectNewWindow.right = m_rectNewWindow.left + m_pBmpNewWindowNormal->GetWidth();

  016f8	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  016fb	8b 89 08 01 00
	00		 mov	 ecx, DWORD PTR [ecx+264]
  01701	e8 00 00 00 00	 call	 ?GetWidth@CDibBitmap@@QAEHXZ ; CDibBitmap::GetWidth
  01706	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  01709	03 82 a0 00 00
	00		 add	 eax, DWORD PTR [edx+160]
  0170f	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  01712	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax

; 406  : 	m_rectNewWindow.bottom = rcBtn.bottom;

  01718	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  0171b	8b 45 e4	 mov	 eax, DWORD PTR _rcBtn$[ebp+12]
  0171e	89 82 ac 00 00
	00		 mov	 DWORD PTR [edx+172], eax

; 407  : 	m_rectNewWindow.top = m_rectNewWindow.bottom - m_pBmpNewWindowNormal->GetHeight();

  01724	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  01727	8b 89 08 01 00
	00		 mov	 ecx, DWORD PTR [ecx+264]
  0172d	e8 00 00 00 00	 call	 ?GetHeight@CDibBitmap@@QAEHXZ ; CDibBitmap::GetHeight
  01732	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  01735	8b 8a ac 00 00
	00		 mov	 ecx, DWORD PTR [edx+172]
  0173b	2b c8		 sub	 ecx, eax
  0173d	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  01740	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx
$L199972:

; 408  : }

  01746	5e		 pop	 esi
  01747	8b e5		 mov	 esp, ebp
  01749	5d		 pop	 ebp
  0174a	c3		 ret	 0
?CalcTabPosition@CTabBarWnd@@AAEXXZ ENDP		; CTabBarWnd::CalcTabPosition
_TEXT	ENDS
PUBLIC	??0TAB_ITEM@@QAE@XZ				; TAB_ITEM::TAB_ITEM
PUBLIC	??1TAB_ITEM@@QAE@XZ				; TAB_ITEM::~TAB_ITEM
PUBLIC	??0TAB_ITEM@@QAE@ABU0@@Z			; TAB_ITEM::TAB_ITEM
EXTRN	?OnLButtonDown@CBasicWnd@@IAEXIVCPoint@@@Z:NEAR	; CBasicWnd::OnLButtonDown
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
xdata$x	SEGMENT
$T201723 DD	0ffffffffH
	DD	FLAT:$L201716
	DD	0ffffffffH
	DD	FLAT:$L201717
	DD	0ffffffffH
	DD	FLAT:$L201718
$T201720 DD	019930520H
	DD	03H
	DD	FLAT:$T201723
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv170 = -224						; size = 4
tv164 = -220						; size = 4
tv148 = -216						; size = 4
tv142 = -212						; size = 4
tv88 = -208						; size = 4
tv82 = -204						; size = 4
_this$ = -200						; size = 4
_tItem$200005 = -196					; size = 60
_tmpTI$200002 = -136					; size = 60
_tmpTI$199999 = -76					; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_nFlags$ = 8						; size = 4
_point$ = 12						; size = 8
?OnLButtonDown@CTabBarWnd@@IAEXIVCPoint@@@Z PROC NEAR	; CTabBarWnd::OnLButtonDown
; _this$ = ecx

; 411  : {

  01750	55		 push	 ebp
  01751	8b ec		 mov	 ebp, esp
  01753	6a ff		 push	 -1
  01755	68 00 00 00 00	 push	 __ehhandler$?OnLButtonDown@CTabBarWnd@@IAEXIVCPoint@@@Z
  0175a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01760	50		 push	 eax
  01761	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01768	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0176e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  01773	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01776	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 412  : 	AfxGetMainWindow()->Invalidate();

  0177c	6a 01		 push	 1
  0177e	e8 00 00 00 00	 call	 ?AfxGetMainWindow@@YAPAVCWnd@@XZ ; AfxGetMainWindow
  01783	8b c8		 mov	 ecx, eax
  01785	e8 00 00 00 00	 call	 ?Invalidate@CWnd@@QAEXH@Z ; CWnd::Invalidate

; 413  : 
; 414  : 	//close
; 415  : 	if( m_iCloseOver != -1 
; 416  : 		&& m_iCloseOver != 0 )

  0178a	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01790	83 b8 bc 00 00
	00 ff		 cmp	 DWORD PTR [eax+188], -1
  01797	0f 84 c9 00 00
	00		 je	 $L199998
  0179d	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  017a3	83 b9 bc 00 00
	00 00		 cmp	 DWORD PTR [ecx+188], 0
  017aa	0f 84 b6 00 00
	00		 je	 $L199998

; 417  : 	{
; 418  : 		TAB_ITEM tmpTI = m_vecTi[m_iCloseOver];

  017b0	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  017b6	8b 82 bc 00 00
	00		 mov	 eax, DWORD PTR [edx+188]
  017bc	50		 push	 eax
  017bd	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  017c3	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  017c9	e8 00 00 00 00	 call	 ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
  017ce	50		 push	 eax
  017cf	8d 4d b4	 lea	 ecx, DWORD PTR _tmpTI$199999[ebp]
  017d2	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@ABU0@@Z
  017d7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 419  : 		GLOBAL_TABBARDATA->ITabBar_DeleteTab( tmpTI );

  017de	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  017e3	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv82[ebp], eax
  017e9	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_TABBAR
  017ee	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv82[ebp]
  017f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  017f6	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv82[ebp]
  017fc	ff 52 0c	 call	 DWORD PTR [edx+12]
  017ff	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv88[ebp], eax
  01805	8d 45 b4	 lea	 eax, DWORD PTR _tmpTI$199999[ebp]
  01808	50		 push	 eax
  01809	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv88[ebp]
  0180f	8b 11		 mov	 edx, DWORD PTR [ecx]
  01811	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv88[ebp]
  01817	ff 52 10	 call	 DWORD PTR [edx+16]

; 420  : 
; 421  : 		m_iCloseOver = -1;

  0181a	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01820	c7 80 bc 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+188], -1

; 422  : 		m_iTabOver = -1;

  0182a	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01830	c7 81 b8 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+184], -1

; 423  : 
; 424  : 		CalcTabPosition ();

  0183a	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01840	e8 00 00 00 00	 call	 ?CalcTabPosition@CTabBarWnd@@AAEXXZ ; CTabBarWnd::CalcTabPosition

; 425  : 		Invalidate ();

  01845	6a 01		 push	 1
  01847	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0184d	e8 00 00 00 00	 call	 ?Invalidate@CWnd@@QAEXH@Z ; CWnd::Invalidate

; 426  : 		return;

  01852	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01859	8d 4d b4	 lea	 ecx, DWORD PTR _tmpTI$199999[ebp]
  0185c	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
  01861	e9 50 01 00 00	 jmp	 $L199997
$L199998:

; 427  : 	}
; 428  : 	//tab
; 429  : 	if( m_iTabOver != -1 )

  01866	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0186c	83 ba b8 00 00
	00 ff		 cmp	 DWORD PTR [edx+184], -1
  01873	0f 84 82 00 00
	00		 je	 $L200001

; 430  : 	{
; 431  : 		TAB_ITEM tmpTI = m_vecTi[m_iTabOver];

  01879	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0187f	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [eax+184]
  01885	51		 push	 ecx
  01886	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0188c	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  01892	e8 00 00 00 00	 call	 ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
  01897	50		 push	 eax
  01898	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _tmpTI$200002[ebp]
  0189e	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@ABU0@@Z
  018a3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 432  : 		GLOBAL_TABBARDATA->ITabBar_ChangeTab( tmpTI );

  018aa	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  018af	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv142[ebp], eax
  018b5	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_TABBAR
  018ba	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv142[ebp]
  018c0	8b 02		 mov	 eax, DWORD PTR [edx]
  018c2	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv142[ebp]
  018c8	ff 50 0c	 call	 DWORD PTR [eax+12]
  018cb	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv148[ebp], eax
  018d1	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _tmpTI$200002[ebp]
  018d7	51		 push	 ecx
  018d8	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR tv148[ebp]
  018de	8b 02		 mov	 eax, DWORD PTR [edx]
  018e0	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR tv148[ebp]
  018e6	ff 50 0c	 call	 DWORD PTR [eax+12]

; 433  : 	}

  018e9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  018f0	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _tmpTI$200002[ebp]
  018f6	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
$L200001:

; 434  : 	//newwindow
; 435  : 	if ( m_bOverNewWindow )

  018fb	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01901	0f b6 91 b0 00
	00 00		 movzx	 edx, BYTE PTR [ecx+176]
  01908	85 d2		 test	 edx, edx
  0190a	0f 84 8f 00 00
	00		 je	 $L200004

; 436  : 	{
; 437  : 		TAB_ITEM tItem;

  01910	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _tItem$200005[ebp]
  01916	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@XZ
  0191b	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 438  : 		tItem.eumType = TAB_GAME;

  01922	c7 85 58 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR _tItem$200005[ebp+28], 3

; 439  : 		tItem.strName = "test";

  0192c	68 00 00 00 00	 push	 OFFSET FLAT:$SG200006
  01931	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _tItem$200005[ebp]
  01937	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 440  : 		tItem.strParam = "test";

  0193d	68 00 00 00 00	 push	 OFFSET FLAT:$SG200007
  01942	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _tItem$200005[ebp+32]
  01948	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 441  : 		GLOBAL_TABBARDATA->ITabBar_ChangeTab(tItem);

  0194e	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  01953	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv164[ebp], eax
  01959	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_TABBAR
  0195e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv164[ebp]
  01964	8b 10		 mov	 edx, DWORD PTR [eax]
  01966	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv164[ebp]
  0196c	ff 52 0c	 call	 DWORD PTR [edx+12]
  0196f	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv170[ebp], eax
  01975	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _tItem$200005[ebp]
  0197b	50		 push	 eax
  0197c	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv170[ebp]
  01982	8b 11		 mov	 edx, DWORD PTR [ecx]
  01984	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv170[ebp]
  0198a	ff 52 0c	 call	 DWORD PTR [edx+12]

; 442  : 	}

  0198d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01994	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _tItem$200005[ebp]
  0199a	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
$L200004:

; 443  : 	__super::OnLButtonDown(nFlags, point);

  0199f	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp+4]
  019a2	50		 push	 eax
  019a3	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  019a6	51		 push	 ecx
  019a7	8b 55 08	 mov	 edx, DWORD PTR _nFlags$[ebp]
  019aa	52		 push	 edx
  019ab	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  019b1	e8 00 00 00 00	 call	 ?OnLButtonDown@CBasicWnd@@IAEXIVCPoint@@@Z ; CBasicWnd::OnLButtonDown
$L199997:

; 444  : }

  019b6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  019b9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  019c0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  019c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  019c8	8b e5		 mov	 esp, ebp
  019ca	5d		 pop	 ebp
  019cb	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L201716:
  001a2	8d 4d b4	 lea	 ecx, DWORD PTR _tmpTI$199999[ebp]
  001a5	e9 00 00 00 00	 jmp	 ??1TAB_ITEM@@QAE@XZ
$L201717:
  001aa	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _tmpTI$200002[ebp]
  001b0	e9 00 00 00 00	 jmp	 ??1TAB_ITEM@@QAE@XZ
$L201718:
  001b5	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _tItem$200005[ebp]
  001bb	e9 00 00 00 00	 jmp	 ??1TAB_ITEM@@QAE@XZ
__ehhandler$?OnLButtonDown@CTabBarWnd@@IAEXIVCPoint@@@Z:
  001c0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201720
  001c5	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OnLButtonDown@CTabBarWnd@@IAEXIVCPoint@@@Z ENDP	; CTabBarWnd::OnLButtonDown
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201730 DD	0ffffffffH
	DD	FLAT:$L201725
$T201728 DD	019930520H
	DD	01H
	DD	FLAT:$T201730
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0TAB_ITEM@@QAE@ABU0@@Z PROC NEAR			; TAB_ITEM::TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0TAB_ITEM@@QAE@ABU0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00036	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00039	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0003f	83 c1 20	 add	 ecx, 32			; 00000020H
  00042	51		 push	 ecx
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 20	 add	 ecx, 32			; 00000020H
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201725:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0TAB_ITEM@@QAE@ABU0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201728
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0TAB_ITEM@@QAE@ABU0@@Z ENDP				; TAB_ITEM::TAB_ITEM
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201740 DD	0ffffffffH
	DD	FLAT:$L201735
$T201738 DD	019930520H
	DD	01H
	DD	FLAT:$T201740
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TAB_ITEM@@QAE@XZ PROC NEAR				; TAB_ITEM::~TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1TAB_ITEM@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 20	 add	 ecx, 32			; 00000020H
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201735:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1TAB_ITEM@@QAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201738
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1TAB_ITEM@@QAE@XZ ENDP				; TAB_ITEM::~TAB_ITEM
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201750 DD	0ffffffffH
	DD	FLAT:$L201745
$T201748 DD	019930520H
	DD	01H
	DD	FLAT:$T201750
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0TAB_ITEM@@QAE@XZ PROC NEAR				; TAB_ITEM::TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0TAB_ITEM@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 20	 add	 ecx, 32			; 00000020H
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00045	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201745:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0TAB_ITEM@@QAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201748
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0TAB_ITEM@@QAE@XZ ENDP				; TAB_ITEM::TAB_ITEM
PUBLIC	??0CPoint@@QAE@HH@Z				; CPoint::CPoint
PUBLIC	??9CPoint@@QBEHUtagPOINT@@@Z			; CPoint::operator!=
PUBLIC	?PtInRect@CRect@@QBEHUtagPOINT@@@Z		; CRect::PtInRect
PUBLIC	?GetOverTab@CTabBarWnd@@AAEHVCPoint@@@Z		; CTabBarWnd::GetOverTab
PUBLIC	?GetOverClose@CTabBarWnd@@AAEHVCPoint@@@Z	; CTabBarWnd::GetOverClose
EXTRN	?ShowToolTips@CCWToolTips@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@VCPoint@@H@Z:NEAR ; CCWToolTips::ShowToolTips
EXTRN	?HideTooTips@CCWToolTips@@QAEXXZ:NEAR		; CCWToolTips::HideTooTips
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:NEAR
EXTRN	__imp__GetCursorPos@4:NEAR
EXTRN	?OnMouseMove@CBasicWnd@@IAEXIVCPoint@@@Z:NEAR	; CBasicWnd::OnMouseMove
xdata$x	SEGMENT
$T201763 DD	0ffffffffH
	DD	FLAT:$L201758
$T201761 DD	019930520H
	DD	01H
	DD	FLAT:$T201763
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv173 = -56						; size = 4
_this$ = -52						; size = 4
$T201757 = -48						; size = 4
$T201756 = -44						; size = 8
$T201755 = -36						; size = 8
_info$200029 = -28					; size = 4
_pt$200026 = -24					; size = 8
_iOver$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_nFlags$ = 8						; size = 4
_point$ = 12						; size = 8
?OnMouseMove@CTabBarWnd@@IAEXIVCPoint@@@Z PROC NEAR	; CTabBarWnd::OnMouseMove
; _this$ = ecx

; 447  : {

  019d0	55		 push	 ebp
  019d1	8b ec		 mov	 ebp, esp
  019d3	6a ff		 push	 -1
  019d5	68 00 00 00 00	 push	 __ehhandler$?OnMouseMove@CTabBarWnd@@IAEXIVCPoint@@@Z
  019da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  019e0	50		 push	 eax
  019e1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  019e8	83 ec 2c	 sub	 esp, 44			; 0000002cH
  019eb	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 448  : 	int iOver = GetOverClose( point );

  019ee	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp+4]
  019f1	50		 push	 eax
  019f2	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  019f5	51		 push	 ecx
  019f6	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  019f9	e8 00 00 00 00	 call	 ?GetOverClose@CTabBarWnd@@AAEHVCPoint@@@Z ; CTabBarWnd::GetOverClose
  019fe	89 45 f0	 mov	 DWORD PTR _iOver$[ebp], eax

; 449  : 	if( iOver != m_iCloseOver )

  01a01	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  01a04	8b 45 f0	 mov	 eax, DWORD PTR _iOver$[ebp]
  01a07	3b 82 bc 00 00
	00		 cmp	 eax, DWORD PTR [edx+188]
  01a0d	74 1e		 je	 SHORT $L200022

; 450  : 	{
; 451  : 		m_iCloseOver = iOver;

  01a0f	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a12	8b 55 f0	 mov	 edx, DWORD PTR _iOver$[ebp]
  01a15	89 91 bc 00 00
	00		 mov	 DWORD PTR [ecx+188], edx

; 452  : 		CalcTabPosition ();

  01a1b	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a1e	e8 00 00 00 00	 call	 ?CalcTabPosition@CTabBarWnd@@AAEXXZ ; CTabBarWnd::CalcTabPosition

; 453  : 		Invalidate();

  01a23	6a 01		 push	 1
  01a25	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a28	e8 00 00 00 00	 call	 ?Invalidate@CWnd@@QAEXH@Z ; CWnd::Invalidate
$L200022:

; 454  : 	}
; 455  : 
; 456  : 	iOver = GetOverTab( point );

  01a2d	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp+4]
  01a30	50		 push	 eax
  01a31	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  01a34	51		 push	 ecx
  01a35	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a38	e8 00 00 00 00	 call	 ?GetOverTab@CTabBarWnd@@AAEHVCPoint@@@Z ; CTabBarWnd::GetOverTab
  01a3d	89 45 f0	 mov	 DWORD PTR _iOver$[ebp], eax

; 457  : 	if( iOver != m_iTabOver )

  01a40	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  01a43	8b 45 f0	 mov	 eax, DWORD PTR _iOver$[ebp]
  01a46	3b 82 b8 00 00
	00		 cmp	 eax, DWORD PTR [edx+184]
  01a4c	74 1e		 je	 SHORT $L200023

; 458  : 	{
; 459  : 		m_iTabOver = iOver;

  01a4e	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a51	8b 55 f0	 mov	 edx, DWORD PTR _iOver$[ebp]
  01a54	89 91 b8 00 00
	00		 mov	 DWORD PTR [ecx+184], edx

; 460  : 		CalcTabPosition();

  01a5a	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a5d	e8 00 00 00 00	 call	 ?CalcTabPosition@CTabBarWnd@@AAEXXZ ; CTabBarWnd::CalcTabPosition

; 461  : 		Invalidate();

  01a62	6a 01		 push	 1
  01a64	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a67	e8 00 00 00 00	 call	 ?Invalidate@CWnd@@QAEXH@Z ; CWnd::Invalidate
$L200023:

; 462  : 	}
; 463  : 	m_bOverNewWindow = m_rectNewWindow.PtInRect(point);

  01a6c	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  01a6f	89 45 dc	 mov	 DWORD PTR $T201755[ebp], eax
  01a72	8b 4d 10	 mov	 ecx, DWORD PTR _point$[ebp+4]
  01a75	89 4d e0	 mov	 DWORD PTR $T201755[ebp+4], ecx
  01a78	8b 55 e0	 mov	 edx, DWORD PTR $T201755[ebp+4]
  01a7b	52		 push	 edx
  01a7c	8b 45 dc	 mov	 eax, DWORD PTR $T201755[ebp]
  01a7f	50		 push	 eax
  01a80	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a83	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  01a89	e8 00 00 00 00	 call	 ?PtInRect@CRect@@QBEHUtagPOINT@@@Z ; CRect::PtInRect
  01a8e	85 c0		 test	 eax, eax
  01a90	0f 95 c1	 setne	 cl
  01a93	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  01a96	88 8a b0 00 00
	00		 mov	 BYTE PTR [edx+176], cl

; 464  : 
; 465  : 	if( m_iTabOver != -1 )

  01a9c	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  01a9f	83 b8 b8 00 00
	00 ff		 cmp	 DWORD PTR [eax+184], -1
  01aa6	0f 84 b0 00 00
	00		 je	 $L200025

; 466  : 	{
; 467  : 		CPoint pt(0,0);

  01aac	6a 00		 push	 0
  01aae	6a 00		 push	 0
  01ab0	8d 4d e8	 lea	 ecx, DWORD PTR _pt$200026[ebp]
  01ab3	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint

; 468  : 		GetCursorPos(&pt);

  01ab8	8d 4d e8	 lea	 ecx, DWORD PTR _pt$200026[ebp]
  01abb	51		 push	 ecx
  01abc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4

; 469  : 		if( m_pToolTip->m_lastPoint != pt )

  01ac2	8b 55 e8	 mov	 edx, DWORD PTR _pt$200026[ebp]
  01ac5	89 55 d4	 mov	 DWORD PTR $T201756[ebp], edx
  01ac8	8b 45 ec	 mov	 eax, DWORD PTR _pt$200026[ebp+4]
  01acb	89 45 d8	 mov	 DWORD PTR $T201756[ebp+4], eax
  01ace	8b 4d d8	 mov	 ecx, DWORD PTR $T201756[ebp+4]
  01ad1	51		 push	 ecx
  01ad2	8b 55 d4	 mov	 edx, DWORD PTR $T201756[ebp]
  01ad5	52		 push	 edx
  01ad6	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  01ad9	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  01adc	83 c1 68	 add	 ecx, 104		; 00000068H
  01adf	e8 00 00 00 00	 call	 ??9CPoint@@QBEHUtagPOINT@@@Z ; CPoint::operator!=
  01ae4	85 c0		 test	 eax, eax
  01ae6	74 0b		 je	 SHORT $L200028

; 470  : 		{
; 471  : 			m_pToolTip->HideTooTips();

  01ae8	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01aeb	8b 49 5c	 mov	 ecx, DWORD PTR [ecx+92]
  01aee	e8 00 00 00 00	 call	 ?HideTooTips@CCWToolTips@@QAEXXZ ; CCWToolTips::HideTooTips
$L200028:

; 472  : 		}
; 473  : 		CString info = m_vecTi[m_iTabOver].strName.c_str();

  01af3	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  01af6	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  01afc	50		 push	 eax
  01afd	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b00	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  01b06	e8 00 00 00 00	 call	 ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
  01b0b	8b c8		 mov	 ecx, eax
  01b0d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  01b13	50		 push	 eax
  01b14	8d 4d e4	 lea	 ecx, DWORD PTR _info$200029[ebp]
  01b17	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  01b1d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 474  : 		m_pToolTip->ShowToolTips( info,pt);

  01b24	6a 00		 push	 0
  01b26	8b 4d ec	 mov	 ecx, DWORD PTR _pt$200026[ebp+4]
  01b29	51		 push	 ecx
  01b2a	8b 55 e8	 mov	 edx, DWORD PTR _pt$200026[ebp]
  01b2d	52		 push	 edx
  01b2e	51		 push	 ecx
  01b2f	8b cc		 mov	 ecx, esp
  01b31	89 65 d0	 mov	 DWORD PTR $T201757[ebp], esp
  01b34	8d 45 e4	 lea	 eax, DWORD PTR _info$200029[ebp]
  01b37	50		 push	 eax
  01b38	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  01b3e	89 45 c8	 mov	 DWORD PTR tv173[ebp], eax
  01b41	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b44	8b 49 5c	 mov	 ecx, DWORD PTR [ecx+92]
  01b47	e8 00 00 00 00	 call	 ?ShowToolTips@CCWToolTips@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@VCPoint@@H@Z ; CCWToolTips::ShowToolTips

; 475  : 	}

  01b4c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01b53	8d 4d e4	 lea	 ecx, DWORD PTR _info$200029[ebp]
  01b56	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L200025:

; 476  : 	__super::OnMouseMove(nFlags, point);

  01b5c	8b 55 10	 mov	 edx, DWORD PTR _point$[ebp+4]
  01b5f	52		 push	 edx
  01b60	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  01b63	50		 push	 eax
  01b64	8b 4d 08	 mov	 ecx, DWORD PTR _nFlags$[ebp]
  01b67	51		 push	 ecx
  01b68	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b6b	e8 00 00 00 00	 call	 ?OnMouseMove@CBasicWnd@@IAEXIVCPoint@@@Z ; CBasicWnd::OnMouseMove

; 477  : }

  01b70	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01b73	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01b7a	8b e5		 mov	 esp, ebp
  01b7c	5d		 pop	 ebp
  01b7d	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L201758:
  001ca	8d 4d e4	 lea	 ecx, DWORD PTR _info$200029[ebp]
  001cd	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnMouseMove@CTabBarWnd@@IAEXIVCPoint@@@Z:
  001d3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201761
  001d8	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OnMouseMove@CTabBarWnd@@IAEXIVCPoint@@@Z ENDP		; CTabBarWnd::OnMouseMove
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T201765 = -12						; size = 8
_i$200035 = -4						; size = 4
_pt$ = 8						; size = 8
?GetOverTab@CTabBarWnd@@AAEHVCPoint@@@Z PROC NEAR	; CTabBarWnd::GetOverTab
; _this$ = ecx

; 480  : {

  01b80	55		 push	 ebp
  01b81	8b ec		 mov	 ebp, esp
  01b83	83 ec 10	 sub	 esp, 16			; 00000010H
  01b86	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 481  : 	for( int i=0; i<m_vecTab.size(); i++ )

  01b89	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$200035[ebp], 0
  01b90	eb 09		 jmp	 SHORT $L200036
$L200037:
  01b92	8b 45 fc	 mov	 eax, DWORD PTR _i$200035[ebp]
  01b95	83 c0 01	 add	 eax, 1
  01b98	89 45 fc	 mov	 DWORD PTR _i$200035[ebp], eax
$L200036:
  01b9b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01b9e	83 c1 70	 add	 ecx, 112		; 00000070H
  01ba1	e8 00 00 00 00	 call	 ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
  01ba6	39 45 fc	 cmp	 DWORD PTR _i$200035[ebp], eax
  01ba9	73 35		 jae	 SHORT $L200038

; 482  : 	{
; 483  : 		if( m_vecTab[i].PtInRect( pt ) )

  01bab	8b 4d 08	 mov	 ecx, DWORD PTR _pt$[ebp]
  01bae	89 4d f4	 mov	 DWORD PTR $T201765[ebp], ecx
  01bb1	8b 55 0c	 mov	 edx, DWORD PTR _pt$[ebp+4]
  01bb4	89 55 f8	 mov	 DWORD PTR $T201765[ebp+4], edx
  01bb7	8b 45 f8	 mov	 eax, DWORD PTR $T201765[ebp+4]
  01bba	50		 push	 eax
  01bbb	8b 4d f4	 mov	 ecx, DWORD PTR $T201765[ebp]
  01bbe	51		 push	 ecx
  01bbf	8b 55 fc	 mov	 edx, DWORD PTR _i$200035[ebp]
  01bc2	52		 push	 edx
  01bc3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01bc6	83 c1 70	 add	 ecx, 112		; 00000070H
  01bc9	e8 00 00 00 00	 call	 ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
  01bce	8b c8		 mov	 ecx, eax
  01bd0	e8 00 00 00 00	 call	 ?PtInRect@CRect@@QBEHUtagPOINT@@@Z ; CRect::PtInRect
  01bd5	85 c0		 test	 eax, eax
  01bd7	74 05		 je	 SHORT $L200040

; 484  : 			return i;

  01bd9	8b 45 fc	 mov	 eax, DWORD PTR _i$200035[ebp]
  01bdc	eb 05		 jmp	 SHORT $L200034
$L200040:

; 485  : 	}

  01bde	eb b2		 jmp	 SHORT $L200037
$L200038:

; 486  : 	return -1;

  01be0	83 c8 ff	 or	 eax, -1
$L200034:

; 487  : }

  01be3	8b e5		 mov	 esp, ebp
  01be5	5d		 pop	 ebp
  01be6	c2 08 00	 ret	 8
?GetOverTab@CTabBarWnd@@AAEHVCPoint@@@Z ENDP		; CTabBarWnd::GetOverTab
; Function compile flags: /Odt
_this$ = -16						; size = 4
$T201767 = -12						; size = 8
_i$200045 = -4						; size = 4
_pt$ = 8						; size = 8
?GetOverClose@CTabBarWnd@@AAEHVCPoint@@@Z PROC NEAR	; CTabBarWnd::GetOverClose
; _this$ = ecx

; 490  : {	

  01bf0	55		 push	 ebp
  01bf1	8b ec		 mov	 ebp, esp
  01bf3	83 ec 10	 sub	 esp, 16			; 00000010H
  01bf6	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 491  : 	for( int i=0; i<m_vecClose.size(); i++ )

  01bf9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$200045[ebp], 0
  01c00	eb 09		 jmp	 SHORT $L200046
$L200047:
  01c02	8b 45 fc	 mov	 eax, DWORD PTR _i$200045[ebp]
  01c05	83 c0 01	 add	 eax, 1
  01c08	89 45 fc	 mov	 DWORD PTR _i$200045[ebp], eax
$L200046:
  01c0b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01c0e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01c14	e8 00 00 00 00	 call	 ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
  01c19	39 45 fc	 cmp	 DWORD PTR _i$200045[ebp], eax
  01c1c	73 38		 jae	 SHORT $L200048

; 492  : 	{
; 493  : 		if( m_vecClose[i].PtInRect( pt ) )

  01c1e	8b 4d 08	 mov	 ecx, DWORD PTR _pt$[ebp]
  01c21	89 4d f4	 mov	 DWORD PTR $T201767[ebp], ecx
  01c24	8b 55 0c	 mov	 edx, DWORD PTR _pt$[ebp+4]
  01c27	89 55 f8	 mov	 DWORD PTR $T201767[ebp+4], edx
  01c2a	8b 45 f8	 mov	 eax, DWORD PTR $T201767[ebp+4]
  01c2d	50		 push	 eax
  01c2e	8b 4d f4	 mov	 ecx, DWORD PTR $T201767[ebp]
  01c31	51		 push	 ecx
  01c32	8b 55 fc	 mov	 edx, DWORD PTR _i$200045[ebp]
  01c35	52		 push	 edx
  01c36	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01c39	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01c3f	e8 00 00 00 00	 call	 ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ; std::vector<CRect,std::allocator<CRect> >::operator[]
  01c44	8b c8		 mov	 ecx, eax
  01c46	e8 00 00 00 00	 call	 ?PtInRect@CRect@@QBEHUtagPOINT@@@Z ; CRect::PtInRect
  01c4b	85 c0		 test	 eax, eax
  01c4d	74 05		 je	 SHORT $L200050

; 494  : 			return i;

  01c4f	8b 45 fc	 mov	 eax, DWORD PTR _i$200045[ebp]
  01c52	eb 05		 jmp	 SHORT $L200044
$L200050:

; 495  : 	}

  01c54	eb ac		 jmp	 SHORT $L200047
$L200048:

; 496  : 	return -1;

  01c56	83 c8 ff	 or	 eax, -1
$L200044:

; 497  : }

  01c59	8b e5		 mov	 esp, ebp
  01c5b	5d		 pop	 ebp
  01c5c	c2 08 00	 ret	 8
?GetOverClose@CTabBarWnd@@AAEHVCPoint@@@Z ENDP		; CTabBarWnd::GetOverClose
_TEXT	ENDS
EXTRN	?OnDestroy@CWnd@@IAEXXZ:NEAR			; CWnd::OnDestroy
; Function compile flags: /Odt
_TEXT	SEGMENT
tv71 = -16						; size = 4
tv66 = -12						; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?OnDestroy@CTabBarWnd@@IAEXXZ PROC NEAR			; CTabBarWnd::OnDestroy
; _this$ = ecx

; 500  : {

  01c60	55		 push	 ebp
  01c61	8b ec		 mov	 ebp, esp
  01c63	83 ec 10	 sub	 esp, 16			; 00000010H
  01c66	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 501  : 	AfxGetUIManager()->UIGetSkinMgr()->RemoveSkinWnd( this );

  01c69	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  01c6d	74 0b		 je	 SHORT $L201769
  01c6f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01c72	83 c0 54	 add	 eax, 84			; 00000054H
  01c75	89 45 f8	 mov	 DWORD PTR tv76[ebp], eax
  01c78	eb 07		 jmp	 SHORT $L201770
$L201769:
  01c7a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$L201770:
  01c81	e8 00 00 00 00	 call	 ?AfxGetUIManager@@YAPAVIUIManager@@XZ ; AfxGetUIManager
  01c86	89 45 f4	 mov	 DWORD PTR tv66[ebp], eax
  01c89	8b 4d f4	 mov	 ecx, DWORD PTR tv66[ebp]
  01c8c	8b 11		 mov	 edx, DWORD PTR [ecx]
  01c8e	8b 4d f4	 mov	 ecx, DWORD PTR tv66[ebp]
  01c91	ff 52 28	 call	 DWORD PTR [edx+40]
  01c94	89 45 f0	 mov	 DWORD PTR tv71[ebp], eax
  01c97	8b 45 f8	 mov	 eax, DWORD PTR tv76[ebp]
  01c9a	50		 push	 eax
  01c9b	8b 4d f0	 mov	 ecx, DWORD PTR tv71[ebp]
  01c9e	8b 11		 mov	 edx, DWORD PTR [ecx]
  01ca0	8b 4d f0	 mov	 ecx, DWORD PTR tv71[ebp]
  01ca3	ff 52 18	 call	 DWORD PTR [edx+24]

; 502  : 	m_pToolTip->DestroyWindow();

  01ca6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ca9	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  01cac	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01caf	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  01cb2	8b 11		 mov	 edx, DWORD PTR [ecx]
  01cb4	8b c8		 mov	 ecx, eax
  01cb6	ff 52 68	 call	 DWORD PTR [edx+104]

; 503  : 	__super::OnDestroy();

  01cb9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cbc	e8 00 00 00 00	 call	 ?OnDestroy@CWnd@@IAEXXZ	; CWnd::OnDestroy

; 504  : }

  01cc1	8b e5		 mov	 esp, ebp
  01cc3	5d		 pop	 ebp
  01cc4	c3		 ret	 0
?OnDestroy@CTabBarWnd@@IAEXXZ ENDP			; CTabBarWnd::OnDestroy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE_NI@Z ; std::vector<CRect,std::allocator<CRect> >::_Buy
PUBLIC	??0?$_Vector_val@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE@V?$allocator@VCRect@@@1@@Z ; std::_Vector_val<CRect,std::allocator<CRect> >::_Vector_val<CRect,std::allocator<CRect> >
PUBLIC	??0?$allocator@VCRect@@@std@@QAE@XZ		; std::allocator<CRect>::allocator<CRect>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::vector<CRect,std::allocator<CRect> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@VCRect@@@std@@QAE@XZ ; std::allocator<CRect>::allocator<CRect>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE@V?$allocator@VCRect@@@1@@Z ; std::_Vector_val<CRect,std::allocator<CRect> >::_Vector_val<CRect,std::allocator<CRect> >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE_NI@Z ; std::vector<CRect,std::allocator<CRect> >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ENDP ; std::vector<CRect,std::allocator<CRect> >::vector<CRect,std::allocator<CRect> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXXZ ; std::vector<CRect,std::allocator<CRect> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::~vector<CRect,std::allocator<CRect> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXXZ ; std::vector<CRect,std::allocator<CRect> >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@XZ ENDP ; std::vector<CRect,std::allocator<CRect> >::~vector<CRect,std::allocator<CRect> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L201777
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 12		 jmp	 SHORT $L201778
$L201777:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	c1 f8 04	 sar	 eax, 4
  0002a	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L201778:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ENDP ; std::vector<CRect,std::allocator<CRect> >::size
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CRect,std::allocator<CRect> >::begin
PUBLIC	??Diterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEAAVCRect@@XZ ; std::vector<CRect,std::allocator<CRect> >::iterator::operator*
PUBLIC	??Hiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CRect,std::allocator<CRect> >::iterator::operator+
; Function compile flags: /Odt
;	COMDAT ??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T201782 = -8						; size = 4
$T201781 = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::operator[], COMDAT
; _this$ = ecx

; 554  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		return (*(begin() + _Pos));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d f8	 lea	 ecx, DWORD PTR $T201782[ebp]
  00010	51		 push	 ecx
  00011	8d 55 fc	 lea	 edx, DWORD PTR $T201781[ebp]
  00014	52		 push	 edx
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?begin@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CRect,std::allocator<CRect> >::begin
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ??Hiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CRect,std::allocator<CRect> >::iterator::operator+
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??Diterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEAAVCRect@@XZ ; std::vector<CRect,std::allocator<CRect> >::iterator::operator*

; 556  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??A?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAVCRect@@I@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::operator[]
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::capacity
PUBLIC	?end@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CRect,std::allocator<CRect> >::end
PUBLIC	?insert@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@V312@ABVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::insert
PUBLIC	?_Ufill@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV3@IABV3@@Z ; std::vector<CRect,std::allocator<CRect> >::_Ufill
; Function compile flags: /Odt
;	COMDAT ?push_back@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXABVCRect@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T201786 = -8						; size = 4
$T201785 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXABVCRect@@@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0000a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
  00012	8b f0		 mov	 esi, eax
  00014	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?capacity@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::capacity
  0001c	3b f0		 cmp	 esi, eax
  0001e	73 1d		 jae	 SHORT $L200242

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	50		 push	 eax
  00024	6a 01		 push	 1
  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	52		 push	 edx
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Ufill@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV3@IABV3@@Z ; std::vector<CRect,std::allocator<CRect> >::_Ufill
  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  0003b	eb 1f		 jmp	 SHORT $L200241
$L200242:

; 583  : 			insert(end(), _Val);

  0003d	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00040	52		 push	 edx
  00041	8d 45 fc	 lea	 eax, DWORD PTR $T201785[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?end@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CRect,std::allocator<CRect> >::end
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	51		 push	 ecx
  00050	8d 55 f8	 lea	 edx, DWORD PTR $T201786[ebp]
  00053	52		 push	 edx
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?insert@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@V312@ABVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::insert
$L200241:

; 584  : 		}

  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?push_back@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXABVCRect@@@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::push_back
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?clear@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXXZ ; std::vector<CRect,std::allocator<CRect> >::_Tidy

; 745  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?clear@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEXXZ ENDP ; std::vector<CRect,std::allocator<CRect> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >
PUBLIC	??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ		; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
PUBLIC	?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy
; Function compile flags: /Odt
;	COMDAT ??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ ; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L201796
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L201797
$L201796:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L201797:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
_TEXT	ENDS
PUBLIC	?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
PUBLIC	??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*
PUBLIC	??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+
; Function compile flags: /Odt
;	COMDAT ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T201801 = -8						; size = 4
$T201800 = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[], COMDAT
; _this$ = ecx

; 554  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		return (*(begin() + _Pos));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d f8	 lea	 ecx, DWORD PTR $T201801[ebp]
  00010	51		 push	 ecx
  00011	8d 55 fc	 lea	 edx, DWORD PTR $T201800[ebp]
  00014	52		 push	 edx
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*

; 556  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy

; 745  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L201806
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 12		 jmp	 SHORT $L201807
$L201806:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	c1 f8 04	 sar	 eax, 4
  0002a	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L201807:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?capacity@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ENDP ; std::vector<CRect,std::allocator<CRect> >::capacity
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CRect,std::allocator<CRect> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CRect,std::allocator<CRect> >::end
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXViterator@12@IABVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::_Insert_n
PUBLIC	??Giterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CRect,std::allocator<CRect> >::iterator::operator-
; Function compile flags: /Odt
;	COMDAT ?insert@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@V312@ABVCRect@@@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
_this$ = -16						; size = 4
$T201817 = -12						; size = 4
$T201814 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@V312@ABVCRect@@@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
  00011	85 c0		 test	 eax, eax
  00013	75 09		 jne	 SHORT $L201815
  00015	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0001c	eb 18		 jmp	 SHORT $L201816
$L201815:
  0001e	8d 45 f8	 lea	 eax, DWORD PTR $T201814[ebp]
  00021	50		 push	 eax
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?begin@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CRect,std::allocator<CRect> >::begin
  0002a	50		 push	 eax
  0002b	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002e	e8 00 00 00 00	 call	 ??Giterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CRect,std::allocator<CRect> >::iterator::operator-
  00033	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$L201816:
  00036	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00039	89 4d fc	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0003c	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0003f	52		 push	 edx
  00040	6a 01		 push	 1
  00042	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00045	50		 push	 eax
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXViterator@12@IABVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::_Insert_n

; 623  : 		return (begin() + _Off);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	52		 push	 edx
  00056	8d 45 f4	 lea	 eax, DWORD PTR $T201817[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?begin@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CRect,std::allocator<CRect> >::begin
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ??Hiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CRect,std::allocator<CRect> >::iterator::operator+
  00069	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE?AViterator@12@V312@ABVCRect@@@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::insert
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::max_size
PUBLIC	?_Xlen@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IBEXXZ ; std::vector<CRect,std::allocator<CRect> >::_Xlen
PUBLIC	?allocate@?$allocator@VCRect@@@std@@QAEPAVCRect@@I@Z ; std::allocator<CRect>::allocate
; Function compile flags: /Odt
;	COMDAT ?_Buy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L200430

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 49		 jmp	 SHORT $L200429
$L200430:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L200432

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IBEXXZ ; std::vector<CRect,std::allocator<CRect> >::_Xlen

; 776  : 		else

  00044	eb 30		 jmp	 SHORT $L200431
$L200432:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@VCRect@@@std@@QAEPAVCRect@@I@Z ; std::allocator<CRect>::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00067	c1 e2 04	 shl	 edx, 4
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L200431:

; 781  : 			}
; 782  : 		return (true);

  00076	b0 01		 mov	 al, 1
$L200429:

; 783  : 		}

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Buy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXPAVCRect@@0@Z ; std::vector<CRect,std::allocator<CRect> >::_Destroy
PUBLIC	?deallocate@?$allocator@VCRect@@@std@@QAEXPAVCRect@@I@Z ; std::allocator<CRect>::deallocate
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 35		 je	 SHORT $L200436

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXPAVCRect@@0@Z ; std::vector<CRect,std::allocator<CRect> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	c1 f9 04	 sar	 ecx, 4
  00035	51		 push	 ecx
  00036	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00039	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003c	50		 push	 eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?deallocate@?$allocator@VCRect@@@std@@QAEXPAVCRect@@I@Z ; std::allocator<CRect>::deallocate
$L200436:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?_Tidy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXXZ ENDP ; std::vector<CRect,std::allocator<CRect> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@@Z ; std::_Uninitialized_fill_n<CRect *,unsigned int,CRect,std::allocator<CRect> >
; Function compile flags: /Odt
;	COMDAT ?_Ufill@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV3@IABV3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV3@IABV3@@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@@Z ; std::_Uninitialized_fill_n<CRect *,unsigned int,CRect,std::allocator<CRect> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	c1 e0 04	 shl	 eax, 4
  00025	03 45 08	 add	 eax, DWORD PTR __Ptr$[ebp]

; 880  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV3@IABV3@@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$allocator@VCRect@@@std@@QAE@ABV01@@Z	; std::allocator<CRect>::allocator<CRect>
; Function compile flags: /Odt
;	COMDAT ??0?$_Vector_val@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE@V?$allocator@VCRect@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE@V?$allocator@VCRect@@@1@@Z PROC NEAR ; std::_Vector_val<CRect,std::allocator<CRect> >::_Vector_val<CRect,std::allocator<CRect> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@VCRect@@@std@@QAE@ABV01@@Z ; std::allocator<CRect>::allocator<CRect>

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAE@V?$allocator@VCRect@@@1@@Z ENDP ; std::_Vector_val<CRect,std::allocator<CRect> >::_Vector_val<CRect,std::allocator<CRect> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@VCRect@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@VCRect@@@std@@QAE@XZ PROC NEAR		; std::allocator<CRect>::allocator<CRect>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@VCRect@@@std@@QAE@XZ ENDP		; std::allocator<CRect>::allocator<CRect>
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::allocate
PUBLIC	?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
PUBLIC	?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen
; Function compile flags: /Odt
;	COMDAT ?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L200459

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 49		 jmp	 SHORT $L200458
$L200459:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L200461

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen

; 776  : 		else

  00044	eb 30		 jmp	 SHORT $L200460
$L200461:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00067	6b d2 3c	 imul	 edx, 60			; 0000003cH
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L200460:

; 781  : 			}
; 782  : 		return (true);

  00076	b0 01		 mov	 al, 1
$L200458:

; 783  : 		}

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::deallocate
PUBLIC	?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 3c		 je	 SHORT $L200465

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	8b c1		 mov	 eax, ecx
  00034	99		 cdq
  00035	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0003a	f7 f9		 idiv	 ecx
  0003c	50		 push	 eax
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::deallocate
$L200465:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
; Function compile flags: /Odt
;	COMDAT ??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z PROC NEAR ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z ; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z ENDP ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ PROC NEAR	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ ENDP		; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEABVCRect@@XZ ; std::vector<CRect,std::allocator<CRect> >::const_iterator::operator*
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Diterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEAAVCRect@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEAAVCRect@@XZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEABVCRect@@XZ ; std::vector<CRect,std::allocator<CRect> >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEAAVCRect@@XZ ENDP ; std::vector<CRect,std::allocator<CRect> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CRect,std::allocator<CRect> >::iterator::operator+=
; Function compile flags: /Odt
;	COMDAT ??Hiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CRect,std::allocator<CRect> >::iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=
; Function compile flags: /Odt
;	COMDAT ??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCRect@@@std@@QBEIXZ	; std::allocator<CRect>::max_size
; Function compile flags: /Odt
;	COMDAT ?max_size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@VCRect@@@std@@QBEIXZ ; std::allocator<CRect>::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ENDP ; std::vector<CRect,std::allocator<CRect> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@@Z ; std::_Destroy_range<CRect,std::allocator<CRect> >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXPAVCRect@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXPAVCRect@@0@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@@Z ; std::_Destroy_range<CRect,std::allocator<CRect> >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXPAVCRect@@0@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAVCRect@@@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV2@00@Z ; std::vector<CRect,std::allocator<CRect> >::_Ucopy<CRect *>
PUBLIC	??$fill@PAVCRect@@V1@@std@@YAXPAVCRect@@0ABV1@@Z ; std::fill<CRect *,CRect>
PUBLIC	??$copy_backward@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00@Z ; std::copy_backward<CRect *,CRect *>
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201862 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T201864 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L201856
$T201865 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L201858
$T201863 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T201864
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T201865
$T201860 DD	019930520H
	DD	04H
	DD	FLAT:$T201862
	DD	02H
	DD	FLAT:$T201863
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXViterator@12@IABVCRect@@@Z
_TEXT	SEGMENT
tv241 = -64						; size = 4
tv240 = -60						; size = 4
tv86 = -56						; size = 4
_this$ = -52						; size = 4
__Oldend$200571 = -48					; size = 4
__Newvec$200550 = -44					; size = 4
__Ptr$200551 = -40					; size = 4
__Capacity$ = -36					; size = 4
__Tmp$ = -32						; size = 16
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXViterator@12@IABVCRect@@@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXViterator@12@IABVCRect@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 30	 sub	 esp, 48			; 00000030H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00025	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d e0	 mov	 DWORD PTR __Tmp$[ebp], ecx
  0002d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00030	89 55 e4	 mov	 DWORD PTR __Tmp$[ebp+4], edx
  00033	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00036	89 4d e8	 mov	 DWORD PTR __Tmp$[ebp+8], ecx
  00039	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0003c	89 55 ec	 mov	 DWORD PTR __Tmp$[ebp+12], edx

; 811  : 		size_type _Capacity = capacity();

  0003f	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?capacity@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::capacity
  00047	89 45 dc	 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  0004a	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0004e	75 05		 jne	 SHORT $L200544

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00050	e9 c6 02 00 00	 jmp	 $L201851
$L200544:
  00055	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?max_size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::max_size
  00067	2b c6		 sub	 eax, esi
  00069	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0006c	73 0d		 jae	 SHORT $L200546

; 816  : 			_Xlen();	// result too long

  0006e	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Xlen@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IBEXXZ ; std::vector<CRect,std::allocator<CRect> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  00076	e9 a0 02 00 00	 jmp	 $L201851
$L200546:
  0007b	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
  00083	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00086	39 45 dc	 cmp	 DWORD PTR __Capacity$[ebp], eax
  00089	0f 83 66 01 00
	00		 jae	 $L200548

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0008f	8b 75 dc	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00092	d1 ee		 shr	 esi, 1
  00094	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?max_size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::max_size
  0009c	2b c6		 sub	 eax, esi
  0009e	3b 45 dc	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  000a1	73 09		 jae	 SHORT $L201852
  000a3	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
  000aa	eb 0b		 jmp	 SHORT $L201853
$L201852:
  000ac	8b 45 dc	 mov	 eax, DWORD PTR __Capacity$[ebp]
  000af	d1 e8		 shr	 eax, 1
  000b1	03 45 dc	 add	 eax, DWORD PTR __Capacity$[ebp]
  000b4	89 45 c8	 mov	 DWORD PTR tv86[ebp], eax
$L201853:
  000b7	8b 4d c8	 mov	 ecx, DWORD PTR tv86[ebp]
  000ba	89 4d dc	 mov	 DWORD PTR __Capacity$[ebp], ecx

; 821  : 			if (_Capacity < size() + _Count)

  000bd	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
  000c5	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000c8	39 45 dc	 cmp	 DWORD PTR __Capacity$[ebp], eax
  000cb	73 0e		 jae	 SHORT $L200549

; 822  : 				_Capacity = size() + _Count;

  000cd	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	e8 00 00 00 00	 call	 ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
  000d5	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000d8	89 45 dc	 mov	 DWORD PTR __Capacity$[ebp], eax
$L200549:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000db	8b 55 dc	 mov	 edx, DWORD PTR __Capacity$[ebp]
  000de	52		 push	 edx
  000df	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	e8 00 00 00 00	 call	 ?allocate@?$allocator@VCRect@@@std@@QAEPAVCRect@@I@Z ; std::allocator<CRect>::allocate
  000e7	89 45 d4	 mov	 DWORD PTR __Newvec$200550[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  000ea	8b 45 d4	 mov	 eax, DWORD PTR __Newvec$200550[ebp]
  000ed	89 45 d8	 mov	 DWORD PTR __Ptr$200551[ebp], eax

; 825  : 
; 826  : 			_TRY_BEGIN

  000f0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000f7	8b 4d d4	 mov	 ecx, DWORD PTR __Newvec$200550[ebp]
  000fa	51		 push	 ecx
  000fb	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  000fe	52		 push	 edx
  000ff	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00102	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00105	51		 push	 ecx
  00106	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ??$_Ucopy@PAVCRect@@@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV2@00@Z ; std::vector<CRect,std::allocator<CRect> >::_Ucopy<CRect *>
  0010e	89 45 c4	 mov	 DWORD PTR tv240[ebp], eax
  00111	8b 55 c4	 mov	 edx, DWORD PTR tv240[ebp]
  00114	89 55 d8	 mov	 DWORD PTR __Ptr$200551[ebp], edx

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00117	8d 45 e0	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0011a	50		 push	 eax
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0011e	51		 push	 ecx
  0011f	8b 55 d8	 mov	 edx, DWORD PTR __Ptr$200551[ebp]
  00122	52		 push	 edx
  00123	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	e8 00 00 00 00	 call	 ?_Ufill@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV3@IABV3@@Z ; std::vector<CRect,std::allocator<CRect> >::_Ufill
  0012b	89 45 c0	 mov	 DWORD PTR tv241[ebp], eax
  0012e	8b 45 c0	 mov	 eax, DWORD PTR tv241[ebp]
  00131	89 45 d8	 mov	 DWORD PTR __Ptr$200551[ebp], eax

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00134	8b 4d d8	 mov	 ecx, DWORD PTR __Ptr$200551[ebp]
  00137	51		 push	 ecx
  00138	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0013b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0013e	50		 push	 eax
  0013f	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00142	51		 push	 ecx
  00143	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	e8 00 00 00 00	 call	 ??$_Ucopy@PAVCRect@@@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV2@00@Z ; std::vector<CRect,std::allocator<CRect> >::_Ucopy<CRect *>
  0014b	eb 29		 jmp	 SHORT $L201855
$L201856:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  0014d	8b 55 d8	 mov	 edx, DWORD PTR __Ptr$200551[ebp]
  00150	52		 push	 edx
  00151	8b 45 d4	 mov	 eax, DWORD PTR __Newvec$200550[ebp]
  00154	50		 push	 eax
  00155	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00158	e8 00 00 00 00	 call	 ?_Destroy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXPAVCRect@@0@Z ; std::vector<CRect,std::allocator<CRect> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  0015d	8b 4d dc	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00160	51		 push	 ecx
  00161	8b 55 d4	 mov	 edx, DWORD PTR __Newvec$200550[ebp]
  00164	52		 push	 edx
  00165	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	e8 00 00 00 00	 call	 ?deallocate@?$allocator@VCRect@@@std@@QAEXPAVCRect@@I@Z ; std::allocator<CRect>::deallocate

; 834  : 			_RERAISE;

  0016d	6a 00		 push	 0
  0016f	6a 00		 push	 0
  00171	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201855:

; 835  : 			_CATCH_END

  00176	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 836  : 
; 837  : 			_Count += size();

  0017d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00180	e8 00 00 00 00	 call	 ?size@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEIXZ ; std::vector<CRect,std::allocator<CRect> >::size
  00185	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00188	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  0018b	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0018e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00192	74 35		 je	 SHORT $L200558

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  00194	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0019a	52		 push	 edx
  0019b	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0019e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001a1	51		 push	 ecx
  001a2	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	e8 00 00 00 00	 call	 ?_Destroy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXPAVCRect@@0@Z ; std::vector<CRect,std::allocator<CRect> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  001aa	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  001ad	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  001b0	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  001b3	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  001b6	c1 f9 04	 sar	 ecx, 4
  001b9	51		 push	 ecx
  001ba	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  001bd	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001c0	50		 push	 eax
  001c1	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c4	e8 00 00 00 00	 call	 ?deallocate@?$allocator@VCRect@@@std@@QAEXPAVCRect@@I@Z ; std::allocator<CRect>::deallocate
$L200558:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001c9	8b 4d dc	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  001cc	c1 e1 04	 shl	 ecx, 4
  001cf	03 4d d4	 add	 ecx, DWORD PTR __Newvec$200550[ebp]
  001d2	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  001d5	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 844  : 			_Mylast = _Newvec + _Count;

  001d8	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001db	c1 e0 04	 shl	 eax, 4
  001de	03 45 d4	 add	 eax, DWORD PTR __Newvec$200550[ebp]
  001e1	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

  001e7	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  001ea	8b 45 d4	 mov	 eax, DWORD PTR __Newvec$200550[ebp]
  001ed	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001f0	e9 26 01 00 00	 jmp	 $L201851
$L200548:
  001f5	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001fb	2b 55 08	 sub	 edx, DWORD PTR __Where$[ebp]
  001fe	c1 fa 04	 sar	 edx, 4
  00201	3b 55 0c	 cmp	 edx, DWORD PTR __Count$[ebp]
  00204	0f 83 ad 00 00
	00		 jae	 $L200561

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  0020a	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0020d	c1 e0 04	 shl	 eax, 4
  00210	03 45 08	 add	 eax, DWORD PTR __Where$[ebp]
  00213	50		 push	 eax
  00214	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00217	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0021a	52		 push	 edx
  0021b	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0021e	50		 push	 eax
  0021f	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00222	e8 00 00 00 00	 call	 ??$_Ucopy@PAVCRect@@@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV2@00@Z ; std::vector<CRect,std::allocator<CRect> >::_Ucopy<CRect *>

; 851  : 
; 852  : 			_TRY_BEGIN

  00227	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0022e	8d 4d e0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00231	51		 push	 ecx
  00232	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00235	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00238	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00241	2b c8		 sub	 ecx, eax
  00243	51		 push	 ecx
  00244	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00247	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0024a	50		 push	 eax
  0024b	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0024e	e8 00 00 00 00	 call	 ?_Ufill@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV3@IABV3@@Z ; std::vector<CRect,std::allocator<CRect> >::_Ufill
  00253	eb 28		 jmp	 SHORT $L201857
$L201858:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  00255	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00258	c1 e1 04	 shl	 ecx, 4
  0025b	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0025e	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  00261	51		 push	 ecx
  00262	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00265	c1 e0 04	 shl	 eax, 4
  00268	03 45 08	 add	 eax, DWORD PTR __Where$[ebp]
  0026b	50		 push	 eax
  0026c	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0026f	e8 00 00 00 00	 call	 ?_Destroy@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXPAVCRect@@0@Z ; std::vector<CRect,std::allocator<CRect> >::_Destroy

; 857  : 			_RERAISE;

  00274	6a 00		 push	 0
  00276	6a 00		 push	 0
  00278	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201857:

; 858  : 			_CATCH_END

  0027d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 859  : 
; 860  : 			_Mylast += _Count;

  00284	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00287	c1 e1 04	 shl	 ecx, 4
  0028a	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0028d	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  00290	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00293	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00296	8d 4d e0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00299	51		 push	 ecx
  0029a	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0029d	c1 e2 04	 shl	 edx, 4
  002a0	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  002a3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002a6	2b ca		 sub	 ecx, edx
  002a8	51		 push	 ecx
  002a9	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  002ac	52		 push	 edx
  002ad	e8 00 00 00 00	 call	 ??$fill@PAVCRect@@V1@@std@@YAXPAVCRect@@0ABV1@@Z ; std::fill<CRect *,CRect>
  002b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002b5	eb 64		 jmp	 SHORT $L201851
$L200561:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  002b7	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  002ba	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002bd	89 4d d0	 mov	 DWORD PTR __Oldend$200571[ebp], ecx

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002c0	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  002c3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002c6	50		 push	 eax
  002c7	8b 4d d0	 mov	 ecx, DWORD PTR __Oldend$200571[ebp]
  002ca	51		 push	 ecx
  002cb	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  002ce	c1 e2 04	 shl	 edx, 4
  002d1	8b 45 d0	 mov	 eax, DWORD PTR __Oldend$200571[ebp]
  002d4	2b c2		 sub	 eax, edx
  002d6	50		 push	 eax
  002d7	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  002da	e8 00 00 00 00	 call	 ??$_Ucopy@PAVCRect@@@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV2@00@Z ; std::vector<CRect,std::allocator<CRect> >::_Ucopy<CRect *>
  002df	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  002e2	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  002e5	8b 55 d0	 mov	 edx, DWORD PTR __Oldend$200571[ebp]
  002e8	52		 push	 edx
  002e9	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002ec	c1 e0 04	 shl	 eax, 4
  002ef	8b 4d d0	 mov	 ecx, DWORD PTR __Oldend$200571[ebp]
  002f2	2b c8		 sub	 ecx, eax
  002f4	51		 push	 ecx
  002f5	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  002f8	52		 push	 edx
  002f9	e8 00 00 00 00	 call	 ??$copy_backward@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00@Z ; std::copy_backward<CRect *,CRect *>
  002fe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  00301	8d 45 e0	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00304	50		 push	 eax
  00305	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00308	c1 e1 04	 shl	 ecx, 4
  0030b	03 4d 08	 add	 ecx, DWORD PTR __Where$[ebp]
  0030e	51		 push	 ecx
  0030f	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00312	52		 push	 edx
  00313	e8 00 00 00 00	 call	 ??$fill@PAVCRect@@V1@@std@@YAXPAVCRect@@0ABV1@@Z ; std::fill<CRect *,CRect>
  00318	83 c4 0c	 add	 esp, 12			; 0000000cH
$L201851:

; 873  : 			}
; 874  : 		}

  0031b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0031e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00325	5f		 pop	 edi
  00326	5e		 pop	 esi
  00327	5b		 pop	 ebx
  00328	8b e5		 mov	 esp, ebp
  0032a	5d		 pop	 ebp
  0032b	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXViterator@12@IABVCRect@@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201860
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEXViterator@12@IABVCRect@@@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::_Insert_n
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201876 DD	0ffffffffH
	DD	FLAT:$L201872
$T201874 DD	019930520H
	DD	01H
	DD	FLAT:$T201876
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
	ORG $-30
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T201871 = -80						; size = 28
$T201870 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T201871[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T201871[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T201870[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T201870[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201869:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201872:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T201871[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201874
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IBEXXZ ENDP ; std::vector<CRect,std::allocator<CRect> >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@VCRect@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@VCRect@@@std@@QAE@ABV01@@Z PROC NEAR	; std::allocator<CRect>::allocator<CRect>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@VCRect@@@std@@QAE@ABV01@@Z ENDP		; std::allocator<CRect>::allocator<CRect>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VCRect@@@std@@QAEXPAVCRect@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCRect@@@std@@QAEXPAVCRect@@I@Z PROC NEAR ; std::allocator<CRect>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@VCRect@@@std@@QAEXPAVCRect@@I@Z ENDP ; std::allocator<CRect>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@VCRect@@@std@@YAPAVCRect@@IPAV1@@Z	; std::_Allocate<CRect>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@VCRect@@@std@@QAEPAVCRect@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@VCRect@@@std@@QAEPAVCRect@@I@Z PROC NEAR ; std::allocator<CRect>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@VCRect@@@std@@YAPAVCRect@@IPAV1@@Z ; std::_Allocate<CRect>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@VCRect@@@std@@QAEPAVCRect@@I@Z ENDP ; std::allocator<CRect>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ	; std::allocator<TAB_ITEM>::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ ; std::allocator<TAB_ITEM>::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T201897 DD	0ffffffffH
	DD	FLAT:$L201893
$T201895 DD	019930520H
	DD	01H
	DD	FLAT:$T201897
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T201892 = -80						; size = 28
$T201891 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T201892[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T201892[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T201891[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T201891[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201890:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L201893:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T201892[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201895
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z PROC NEAR	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z PROC NEAR ; std::allocator<TAB_ITEM>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ENDP ; std::allocator<TAB_ITEM>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z ; std::_Allocate<TAB_ITEM>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z PROC NEAR ; std::allocator<TAB_ITEM>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z ; std::_Allocate<TAB_ITEM>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z ENDP ; std::allocator<TAB_ITEM>::allocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z ; std::vector<CRect,std::allocator<CRect> >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::iterator::iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	c1 e0 04	 shl	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 01		 add	 eax, DWORD PTR [ecx]
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	89 02		 mov	 DWORD PTR [edx], eax

; 257  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??Yiterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABV012@@Z ; std::vector<CRect,std::allocator<CRect> >::const_iterator::operator-
; Function compile flags: /Odt
;	COMDAT ??Giterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T201912 = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR $T201912[ebp], ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR $T201912[ebp]
  00018	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABV012@@Z ; std::vector<CRect,std::allocator<CRect> >::const_iterator::operator-

; 280  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Giterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::iterator::operator-
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEABVCRect@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEABVCRect@@XZ PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEABVCRect@@XZ ENDP ; std::vector<CRect,std::allocator<CRect> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator
; Function compile flags: /Odt
;	COMDAT ??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	6b c0 3c	 imul	 eax, 60			; 0000003cH
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 01		 add	 eax, DWORD PTR [ecx]
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	89 02		 mov	 DWORD PTR [edx], eax

; 257  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VCRect@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@VCRect@@@std@@QBEIXZ PROC NEAR	; std::allocator<CRect>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc ff ff
	ff 0f		 mov	 DWORD PTR __Count$[ebp], 268435455 ; 0fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L201926
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L201927
$L201926:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L201927:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@VCRect@@@std@@QBEIXZ ENDP		; std::allocator<CRect>::max_size
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ PROC NEAR	; std::allocator<TAB_ITEM>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc 44 44
	44 04		 mov	 DWORD PTR __Count$[ebp], 71582788 ; 04444444H

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L201930
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L201931
$L201930:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L201931:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ ENDP	; std::allocator<TAB_ITEM>::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QAE@PAVCRect@@@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	c1 f8 04	 sar	 eax, 4

; 144  : 			}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::const_iterator::operator-
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CRect *,unsigned int,CRect,std::allocator<CRect> >
PUBLIC	??$_Ptr_cat@PAVCRect@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCRect@@0@Z ; std::_Ptr_cat<CRect *,CRect *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@@Z
_TEXT	SEGMENT
$T201940 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<CRect *,unsigned int,CRect,std::allocator<CRect> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00004	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVCRect@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCRect@@0@Z ; std::_Ptr_cat<CRect *,CRect *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T201940[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T201940[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CRect *,unsigned int,CRect,std::allocator<CRect> >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CRect *,unsigned int,CRect,std::allocator<CRect> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CRect,std::allocator<CRect> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@@Z
_TEXT	SEGMENT
$T201943 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@@Z PROC NEAR ; std::_Destroy_range<CRect,std::allocator<CRect> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVCRect@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCRect@@0@Z ; std::_Ptr_cat<CRect *,CRect *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T201943[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T201943[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CRect,std::allocator<CRect> >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@@Z ENDP ; std::_Destroy_range<CRect,std::allocator<CRect> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@@Z ; std::_Uninitialized_copy<CRect *,CRect *,std::allocator<CRect> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAVCRect@@@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAVCRect@@@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV2@00@Z PROC NEAR ; std::vector<CRect,std::allocator<CRect> >::_Ucopy<CRect *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@@Z ; std::_Uninitialized_copy<CRect *,CRect *,std::allocator<CRect> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAVCRect@@@?$vector@VCRect@@V?$allocator@VCRect@@@std@@@std@@IAEPAVCRect@@PAV2@00@Z ENDP ; std::vector<CRect,std::allocator<CRect> >::_Ucopy<CRect *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAVCRect@@V1@@std@@YAXPAVCRect@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCRect@@V1@@std@@YAXPAVCRect@@0ABV1@@Z PROC NEAR ; std::fill<CRect *,CRect>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1135 : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L200816
$L200817:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 10	 add	 eax, 16			; 00000010H
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L200816:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 1e		 je	 SHORT $L200815

; 1136 : 		*_First = _Val;

  00016	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0001e	89 08		 mov	 DWORD PTR [eax], ecx
  00020	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00023	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00026	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00029	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0002c	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  0002f	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00032	eb d1		 jmp	 SHORT $L200817
$L200815:

; 1137 : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$fill@PAVCRect@@V1@@std@@YAXPAVCRect@@0ABV1@@Z ENDP	; std::fill<CRect *,CRect>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CRect *,CRect *>
; Function compile flags: /Odt
;	COMDAT ??$copy_backward@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00@Z
_TEXT	SEGMENT
$T201950 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00@Z PROC NEAR ; std::copy_backward<CRect *,CRect *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVCRect@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCRect@@0@Z ; std::_Ptr_cat<CRect *,CRect *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T201950[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T201950[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CRect *,CRect *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy_backward@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00@Z ENDP ; std::copy_backward<CRect *,CRect *>
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@VCRect@@@std@@YAPAVCRect@@IPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCRect@@@std@@YAPAVCRect@@IPAV1@@Z PROC NEAR ; std::_Allocate<CRect>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 04	 shl	 eax, 4
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@VCRect@@@std@@YAPAVCRect@@IPAV1@@Z ENDP	; std::_Allocate<CRect>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
PUBLIC	??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT
$T201955 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z PROC NEAR ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T201955[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T201955[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z ENDP ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z PROC NEAR ; std::_Allocate<TAB_ITEM>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z ENDP ; std::_Allocate<TAB_ITEM>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVCRect@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCRect@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCRect@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCRect@@0@Z PROC NEAR ; std::_Ptr_cat<CRect *,CRect *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCRect@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCRect@@0@Z ENDP ; std::_Ptr_cat<CRect *,CRect *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCRect@@@std@@QAEXPAVCRect@@ABV3@@Z ; std::allocator<CRect>::construct
PUBLIC	?destroy@?$allocator@VCRect@@@std@@QAEXPAVCRect@@@Z ; std::allocator<CRect>::destroy
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T201967 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T201969 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L201963
$T201968 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T201969
$T201965 DD	019930520H
	DD	02H
	DD	FLAT:$T201967
	DD	01H
	DD	FLAT:$T201968
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<CRect *,unsigned int,CRect,std::allocator<CRect> >, COMDAT

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 208  : 	_FwdIt _Next = _First;

  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 209  : 
; 210  : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  0002d	eb 12		 jmp	 SHORT $L200872
$L200873:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00032	83 e9 01	 sub	 ecx, 1
  00035	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 10	 add	 edx, 16			; 00000010H
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L200872:
  00041	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00045	76 12		 jbe	 SHORT $L200874

; 212  : 		_Al.construct(_First, _Val);

  00047	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00052	e8 00 00 00 00	 call	 ?construct@?$allocator@VCRect@@@std@@QAEXPAVCRect@@ABV3@@Z ; std::allocator<CRect>::construct
  00057	eb d6		 jmp	 SHORT $L200873
$L200874:
  00059	eb 2a		 jmp	 SHORT $L201962
$L201963:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

  0005b	eb 09		 jmp	 SHORT $L200875
$L200876:
  0005d	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00060	83 c2 10	 add	 edx, 16			; 00000010H
  00063	89 55 ec	 mov	 DWORD PTR __Next$[ebp], edx
$L200875:
  00066	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00069	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  0006c	74 0e		 je	 SHORT $L200877

; 215  : 		_Al.destroy(_Next);

  0006e	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00071	51		 push	 ecx
  00072	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00075	e8 00 00 00 00	 call	 ?destroy@?$allocator@VCRect@@@std@@QAEXPAVCRect@@@Z ; std::allocator<CRect>::destroy
  0007a	eb e1		 jmp	 SHORT $L200876
$L200877:

; 216  : 	_RERAISE;

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201962:

; 217  : 	_CATCH_END

  00085	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$L201961:

; 218  : 	}

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201965
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAVCRect@@IV1@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@IABV1@AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CRect *,unsigned int,CRect,std::allocator<CRect> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CRect,std::allocator<CRect> >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L200879
$L200880:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 10	 add	 eax, 16			; 00000010H
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L200879:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L200878

; 226  : 		_Al.destroy(_First);

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001d	e8 00 00 00 00	 call	 ?destroy@?$allocator@VCRect@@@std@@QAEXPAVCRect@@@Z ; std::allocator<CRect>::destroy
  00022	eb e1		 jmp	 SHORT $L200880
$L200878:

; 227  : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Destroy_range@VCRect@@V?$allocator@VCRect@@@std@@@std@@YAXPAVCRect@@0AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CRect,std::allocator<CRect> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CRect *,CRect *,std::allocator<CRect> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@@Z
_TEXT	SEGMENT
$T201976 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<CRect *,CRect *,std::allocator<CRect> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVCRect@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCRect@@0@Z ; std::_Ptr_cat<CRect *,CRect *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T201976[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T201976[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CRect *,CRect *,std::allocator<CRect> >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@@Z ENDP ; std::_Uninitialized_copy<CRect *,CRect *,std::allocator<CRect> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<CRect *,CRect *>, COMDAT

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L200924:

; 1049 : 	while (_First != _Last)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00009	74 30		 je	 SHORT $L200925

; 1050 : 		*--_Dest = *--_Last;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	83 e9 10	 sub	 ecx, 16			; 00000010H
  00011	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  00014	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00017	83 ea 10	 sub	 edx, 16			; 00000010H
  0001a	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0001d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	89 11		 mov	 DWORD PTR [ecx], edx
  00027	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0002d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00030	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00033	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00036	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00039	eb c8		 jmp	 SHORT $L200924
$L200925:

; 1051 : 	return (_Dest);

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1052 : 	}

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Copy_backward_opt@PAVCRect@@PAV1@@std@@YAPAVCRect@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CRect *,CRect *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z PROC NEAR ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ENDP ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ; std::allocator<TAB_ITEM>::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L200929
$L200930:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 3c	 add	 eax, 60			; 0000003cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L200929:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L200928

; 226  : 		_Al.destroy(_First);

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001d	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ; std::allocator<TAB_ITEM>::destroy
  00022	eb e1		 jmp	 SHORT $L200930
$L200928:

; 227  : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	??$_Construct@VCRect@@V1@@std@@YAXPAVCRect@@ABV1@@Z ; std::_Construct<CRect,CRect>
; Function compile flags: /Odt
;	COMDAT ?construct@?$allocator@VCRect@@@std@@QAEXPAVCRect@@ABV3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCRect@@@std@@QAEXPAVCRect@@ABV3@@Z PROC NEAR ; std::allocator<CRect>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@VCRect@@V1@@std@@YAXPAVCRect@@ABV1@@Z ; std::_Construct<CRect,CRect>
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@VCRect@@@std@@QAEXPAVCRect@@ABV3@@Z ENDP ; std::allocator<CRect>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@VCRect@@@std@@YAXPAVCRect@@@Z	; std::_Destroy<CRect>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@VCRect@@@std@@QAEXPAVCRect@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCRect@@@std@@QAEXPAVCRect@@@Z PROC NEAR ; std::allocator<CRect>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@VCRect@@@std@@YAXPAVCRect@@@Z ; std::_Destroy<CRect>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@VCRect@@@std@@QAEXPAVCRect@@@Z ENDP ; std::allocator<CRect>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z	; std::_Destroy<TAB_ITEM>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z PROC NEAR ; std::allocator<TAB_ITEM>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z ; std::_Destroy<TAB_ITEM>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ENDP ; std::allocator<TAB_ITEM>::destroy
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T201996 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T201998 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L201992
$T201997 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T201998
$T201994 DD	019930520H
	DD	02H
	DD	FLAT:$T201996
	DD	01H
	DD	FLAT:$T201997
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<CRect *,CRect *,std::allocator<CRect> >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 78   : 	_FwdIt _Next = _Dest;

  00020	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 79   : 
; 80   : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  0002d	eb 12		 jmp	 SHORT $L200955
$L200956:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	83 c1 10	 add	 ecx, 16			; 00000010H
  00035	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 10	 add	 edx, 16			; 00000010H
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L200955:
  00041	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00044	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00047	74 12		 je	 SHORT $L200957

; 82   : 		_Al.construct(_Dest, *_First);

  00049	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00050	52		 push	 edx
  00051	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00054	e8 00 00 00 00	 call	 ?construct@?$allocator@VCRect@@@std@@QAEXPAVCRect@@ABV3@@Z ; std::allocator<CRect>::construct
  00059	eb d4		 jmp	 SHORT $L200956
$L200957:
  0005b	eb 2a		 jmp	 SHORT $L201991
$L201992:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  0005d	eb 09		 jmp	 SHORT $L200958
$L200959:
  0005f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00062	83 c0 10	 add	 eax, 16			; 00000010H
  00065	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$L200958:
  00068	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  0006b	3b 4d 10	 cmp	 ecx, DWORD PTR __Dest$[ebp]
  0006e	74 0e		 je	 SHORT $L200960

; 85   : 		_Al.destroy(_Next);

  00070	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00073	52		 push	 edx
  00074	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00077	e8 00 00 00 00	 call	 ?destroy@?$allocator@VCRect@@@std@@QAEXPAVCRect@@@Z ; std::allocator<CRect>::destroy
  0007c	eb e1		 jmp	 SHORT $L200959
$L200960:

; 86   : 	_RERAISE;

  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	e8 00 00 00 00	 call	 __CxxThrowException@8
$L201991:

; 87   : 	_CATCH_END

  00087	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 88   : 	return (_Dest);

  0008e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$L201990:

; 89   : 	}

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T201994
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAVCRect@@PAV1@V?$allocator@VCRect@@@std@@@std@@YAPAVCRect@@PAV1@00AAV?$allocator@VCRect@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CRect *,CRect *,std::allocator<CRect> >
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Construct@VCRect@@V1@@std@@YAXPAVCRect@@ABV1@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
$T202003 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCRect@@V1@@std@@YAXPAVCRect@@ABV1@@Z PROC NEAR ; std::_Construct<CRect,CRect>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	50		 push	 eax
  0000a	6a 10		 push	 16			; 00000010H
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00011	83 c4 08	 add	 esp, 8
  00014	89 45 fc	 mov	 DWORD PTR $T202003[ebp], eax
  00017	83 7d fc 00	 cmp	 DWORD PTR $T202003[ebp], 0
  0001b	74 24		 je	 SHORT $L202004
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00020	8b 55 fc	 mov	 edx, DWORD PTR $T202003[ebp]
  00023	8b 01		 mov	 eax, DWORD PTR [ecx]
  00025	89 02		 mov	 DWORD PTR [edx], eax
  00027	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002a	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0002d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00030	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00033	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00036	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00039	8b 55 fc	 mov	 edx, DWORD PTR $T202003[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv69[ebp], edx
  0003f	eb 07		 jmp	 SHORT $L200961
$L202004:
  00041	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L200961:

; 43   : 	}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??$_Construct@VCRect@@V1@@std@@YAXPAVCRect@@ABV1@@Z ENDP ; std::_Construct<CRect,CRect>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@VCRect@@@std@@YAXPAVCRect@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCRect@@@std@@YAXPAVCRect@@@Z PROC NEAR	; std::_Destroy<CRect>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@VCRect@@@std@@YAXPAVCRect@@@Z ENDP		; std::_Destroy<CRect>
_TEXT	ENDS
PUBLIC	??_GTAB_ITEM@@QAEPAXI@Z				; TAB_ITEM::`scalar deleting destructor'
; Function compile flags: /Odt
;	COMDAT ??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z PROC NEAR ; std::_Destroy<TAB_ITEM>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00003	6a 00		 push	 0
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??_GTAB_ITEM@@QAEPAXI@Z

; 50   : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z ENDP	; std::_Destroy<TAB_ITEM>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GTAB_ITEM@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTAB_ITEM@@QAEPAXI@Z PROC NEAR			; TAB_ITEM::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L200970
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L200970:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GTAB_ITEM@@QAEPAXI@Z ENDP				; TAB_ITEM::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_ECTabBarWnd@@WFE@AEPAXI@Z
_TEXT	SEGMENT
??_ECTabBarWnd@@WFE@AEPAXI@Z PROC NEAR			; [thunk]:CTabBarWnd::`vector deleting destructor', COMDAT
  00000	83 e9 54	 sub	 ecx, 84			; 00000054H
  00003	e9 00 00 00 00	 jmp	 ??_ECTabBarWnd@@UAEPAXI@Z
??_ECTabBarWnd@@WFE@AEPAXI@Z ENDP			; [thunk]:CTabBarWnd::`vector deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_ECTabBarWnd@@WFI@AEPAXI@Z
_TEXT	SEGMENT
??_ECTabBarWnd@@WFI@AEPAXI@Z PROC NEAR			; [thunk]:CTabBarWnd::`vector deleting destructor', COMDAT
  00000	83 e9 58	 sub	 ecx, 88			; 00000058H
  00003	e9 00 00 00 00	 jmp	 ??_ECTabBarWnd@@UAEPAXI@Z
??_ECTabBarWnd@@WFI@AEPAXI@Z ENDP			; [thunk]:CTabBarWnd::`vector deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CPoint@@QAE@XZ PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 61   : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CPoint@@QAE@XZ ENDP					; CPoint::CPoint
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initX$ = 8						; size = 4
_initY$ = 12						; size = 4
??0CPoint@@QAE@HH@Z PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 63   : 	{ x = initX; y = initY; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _initX$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _initY$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0CPoint@@QAE@HH@Z ENDP				; CPoint::CPoint
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??9CPoint@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
_point$ = 8						; size = 8
??9CPoint@@QBEHUtagPOINT@@@Z PROC NEAR			; CPoint::operator!=, COMDAT
; _this$ = ecx

; 84   : 	{ return (x != point.x || y != point.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	3b 4d 08	 cmp	 ecx, DWORD PTR _point$[ebp]
  00011	75 14		 jne	 SHORT $L202024
  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00019	3b 45 0c	 cmp	 eax, DWORD PTR _point$[ebp+4]
  0001c	75 09		 jne	 SHORT $L202024
  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00025	eb 07		 jmp	 SHORT $L202025
$L202024:
  00027	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
$L202025:
  0002e	8b 45 f8	 mov	 eax, DWORD PTR tv67[ebp]
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??9CPoint@@QBEHUtagPOINT@@@Z ENDP			; CPoint::operator!=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRect@@QAE@XZ PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 110  : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CRect@@QAE@XZ ENDP					; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
??0CRect@@QAE@HHHH@Z PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 112  : 	{ left = l; top = t; right = r; bottom = b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _r$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _b$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
??0CRect@@QAE@HHHH@Z ENDP				; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Width@CRect@@QBEHXZ PROC NEAR				; CRect::Width, COMDAT
; _this$ = ecx

; 123  : 	{ return right - left; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Width@CRect@@QBEHXZ ENDP				; CRect::Width
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Height@CRect@@QBEHXZ PROC NEAR				; CRect::Height, COMDAT
; _this$ = ecx

; 125  : 	{ return bottom - top; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?Height@CRect@@QBEHXZ ENDP				; CRect::Height
_TEXT	ENDS
EXTRN	__imp__IsRectEmpty@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?IsRectEmpty@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRectEmpty@CRect@@QBEHXZ PROC NEAR			; CRect::IsRectEmpty, COMDAT
; _this$ = ecx

; 147  : 	{ return ::IsRectEmpty(this); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsRectEmpty@4
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?IsRectEmpty@CRect@@QBEHXZ ENDP				; CRect::IsRectEmpty
_TEXT	ENDS
EXTRN	__imp__PtInRect@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?PtInRect@CRect@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_point$ = 8						; size = 8
?PtInRect@CRect@@QBEHUtagPOINT@@@Z PROC NEAR		; CRect::PtInRect, COMDAT
; _this$ = ecx

; 151  : 	{ return ::PtInRect(this, point); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp+4]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _point$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	52		 push	 edx
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?PtInRect@CRect@@QBEHUtagPOINT@@@Z ENDP			; CRect::PtInRect
_TEXT	ENDS
EXTRN	__imp__SetRectEmpty@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?SetRectEmpty@CRect@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetRectEmpty@CRect@@QAEXXZ PROC NEAR			; CRect::SetRectEmpty, COMDAT
; _this$ = ecx

; 157  : 	{ ::SetRectEmpty(this); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRectEmpty@4
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?SetRectEmpty@CRect@@QAEXXZ ENDP			; CRect::SetRectEmpty
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC NEAR	; CObject::Serialize, COMDAT
; _this$ = ecx

; 25   : 	{ /* CObject does not serialize anything by default */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC NEAR				; CObject::operator delete, COMDAT

; 31   : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??2CObject@@SGPAXI@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
??2CObject@@SGPAXI@Z PROC NEAR				; CObject::operator new, COMDAT

; 37   : 	{ return ::operator new(nSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _nSize$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??2CObject@@SGPAXI@Z ENDP				; CObject::operator new
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AssertValid@CObject@@UBEXXZ PROC NEAR			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 41   : 	{ /* no asserts in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC NEAR	; CObject::Dump, COMDAT
; _this$ = ecx

; 43   : 	{ /* no dumping in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
PUBLIC	??_R0?AVCGdiObject@@@8				; CGdiObject `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CGdiObject@@8			; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4CFont@@6B@					; CFont::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCFont@@@8				; CFont `RTTI Type Descriptor'
PUBLIC	??_R3CFont@@8					; CFont::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CFont@@8					; CFont::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CFont@@8				; CFont::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0CGdiObject@@QAE@XZ				; CGdiObject::CGdiObject
PUBLIC	??_7CFont@@6B@					; CFont::`vftable'
PUBLIC	??_GCFont@@UAEPAXI@Z				; CFont::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CFont@@UBEPAUCRuntimeClass@@XZ:NEAR ; CFont::GetRuntimeClass
EXTRN	??_ECFont@@UAEPAXI@Z:NEAR			; CFont::`vector deleting destructor'
;	COMDAT ??_7CFont@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
CONST	SEGMENT
??_7CFont@@6B@ DD FLAT:??_R4CFont@@6B@			; CFont::`vftable'
	DD	FLAT:?GetRuntimeClass@CFont@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECFont@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CFont@@6B@
rdata$r	SEGMENT
??_R4CFont@@6B@ DD 00H					; CFont::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCFont@@@8
	DD	FLAT:??_R3CFont@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFont@@@8
_DATA	SEGMENT
??_R0?AVCFont@@@8 DD FLAT:??_7type_info@@6B@		; CFont `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFont@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CFont@@8
rdata$r	SEGMENT
??_R3CFont@@8 DD 00H					; CFont::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CFont@@8
rdata$r	ENDS
;	COMDAT ??_R2CFont@@8
rdata$r	SEGMENT
??_R2CFont@@8 DD FLAT:??_R1A@?0A@A@CFont@@8		; CFont::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CFont@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CFont@@8 DD FLAT:??_R0?AVCFont@@@8		; CFont::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CGdiObject@@8 DD FLAT:??_R0?AVCGdiObject@@@8 ; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
_DATA	SEGMENT
??_R0?AVCGdiObject@@@8 DD FLAT:??_7type_info@@6B@	; CGdiObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGdiObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0CFont@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CFont@@QAE@XZ PROC NEAR				; CFont::CFont, COMDAT
; _this$ = ecx

; 153  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CGdiObject@@QAE@XZ	; CGdiObject::CGdiObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CFont@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CFont@@QAE@XZ ENDP					; CFont::CFont
_TEXT	ENDS
PUBLIC	??_R4CGdiObject@@6B@				; CGdiObject::`RTTI Complete Object Locator'
PUBLIC	??_R3CGdiObject@@8				; CGdiObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGdiObject@@8				; CGdiObject::`RTTI Base Class Array'
PUBLIC	??0CObject@@IAE@XZ				; CObject::CObject
PUBLIC	??_7CGdiObject@@6B@				; CGdiObject::`vftable'
PUBLIC	??_GCGdiObject@@UAEPAXI@Z			; CGdiObject::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ:NEAR ; CGdiObject::GetRuntimeClass
EXTRN	??_ECGdiObject@@UAEPAXI@Z:NEAR			; CGdiObject::`vector deleting destructor'
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT
??_7CGdiObject@@6B@ DD FLAT:??_R4CGdiObject@@6B@	; CGdiObject::`vftable'
	DD	FLAT:?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECGdiObject@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT
??_R4CGdiObject@@6B@ DD 00H				; CGdiObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGdiObject@@@8
	DD	FLAT:??_R3CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT
??_R3CGdiObject@@8 DD 00H				; CGdiObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT
??_R2CGdiObject@@8 DD FLAT:??_R1A@?0A@A@CGdiObject@@8	; CGdiObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CObject@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CGdiObject@@QAE@XZ PROC NEAR				; CGdiObject::CGdiObject, COMDAT
; _this$ = ecx

; 82   : 	{ m_hObject = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CObject@@IAE@XZ	; CObject::CObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CGdiObject@@6B@
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0CGdiObject@@QAE@XZ ENDP				; CGdiObject::CGdiObject
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CObject@@IAE@XZ PROC NEAR				; CObject::CObject, COMDAT
; _this$ = ecx

; 21   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CObject@@IAE@XZ ENDP					; CObject::CObject
_TEXT	ENDS
PUBLIC	??1CGdiObject@@UAE@XZ				; CGdiObject::~CGdiObject
; Function compile flags: /Odt
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGdiObject@@UAEPAXI@Z PROC NEAR			; CGdiObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41495
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41495:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCGdiObject@@UAEPAXI@Z ENDP				; CGdiObject::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
xdata$x	SEGMENT
$T202066 DD	0ffffffffH
	DD	FLAT:$L202062
$T202064 DD	019930520H
	DD	01H
	DD	FLAT:$T202066
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CGdiObject@@UAE@XZ PROC NEAR				; CGdiObject::~CGdiObject, COMDAT
; _this$ = ecx

; 84   : 	{ DeleteObject(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGdiObject@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CGdiObject@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject
  00034	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CObject@@UAE@XZ	; CObject::~CObject
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202062:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CObject@@UAE@XZ	; CObject::~CObject
__ehhandler$??1CGdiObject@@UAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202064
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CGdiObject@@UAE@XZ ENDP				; CGdiObject::~CGdiObject
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CObject@@UAE@XZ PROC NEAR				; CObject::~CObject, COMDAT
; _this$ = ecx

; 23   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCFont@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCFont@@UAEPAXI@Z PROC NEAR				; CFont::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CFont@@UAE@XZ	; CFont::~CFont
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41640
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41640:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCFont@@UAEPAXI@Z ENDP				; CFont::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
_TEXT	ENDS
;	COMDAT ??1CFont@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CFont@@UAE@XZ PROC NEAR				; CFont::~CFont, COMDAT
; _this$ = ecx

; 155  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CFont@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CFont@@UAE@XZ ENDP					; CFont::~CFont
_TEXT	ENDS
EXTRN	__imp__CreateFontIndirectA@4:NEAR
EXTRN	?Attach@CGdiObject@@QAEHPAX@Z:NEAR		; CGdiObject::Attach
; Function compile flags: /Odt
;	COMDAT ?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpLogFont$ = 8						; size = 4
?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z PROC NEAR ; CFont::CreateFontIndirectA, COMDAT
; _this$ = ecx

; 157  : 	{ return Attach(::CreateFontIndirect(lpLogFont)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpLogFont$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFontIndirectA@4
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z ENDP	; CFont::CreateFontIndirectA
_TEXT	ENDS
PUBLIC	?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ		; CDC::GetSafeHdc
EXTRN	?Attach@CDC@@QAEHPAUHDC__@@@Z:NEAR		; CDC::Attach
EXTRN	__imp__CreateCompatibleDC@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?CreateCompatibleDC@CDC@@QAEHPAV1@@Z PROC NEAR		; CDC::CreateCompatibleDC, COMDAT
; _this$ = ecx

; 330  : 	{ return Attach(::CreateCompatibleDC(pDC->GetSafeHdc())); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?Attach@CDC@@QAEHPAUHDC__@@@Z ; CDC::Attach
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?CreateCompatibleDC@CDC@@QAEHPAV1@@Z ENDP		; CDC::CreateCompatibleDC
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ PROC NEAR		; CDC::GetSafeHdc, COMDAT
; _this$ = ecx

; 316  : 	{ return this == NULL ? NULL : m_hDC; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  0000d	75 09		 jne	 SHORT $L202082
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00016	eb 09		 jmp	 SHORT $L202083
$L202082:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	89 4d f8	 mov	 DWORD PTR tv66[ebp], ecx
$L202083:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ENDP			; CDC::GetSafeHdc
_TEXT	ENDS
EXTRN	__imp__SelectObject@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?SelectObject@CDC@@QAEPAXPAX@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_hObject$ = 8						; size = 4
?SelectObject@CDC@@QAEPAXPAX@Z PROC NEAR		; CDC::SelectObject, COMDAT
; _this$ = ecx

; 365  : 	{ ASSERT(m_hDC == m_hAttribDC); // ASSERT a simple CDC object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 366  : 		return (hObject != NULL) ? ::SelectObject(m_hDC, hObject) : NULL; }

  00009	83 7d 08 00	 cmp	 DWORD PTR _hObject$[ebp], 0
  0000d	74 16		 je	 SHORT $L202086
  0000f	8b 45 08	 mov	 eax, DWORD PTR _hObject$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00019	52		 push	 edx
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  00020	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  00023	eb 07		 jmp	 SHORT $L202087
$L202086:
  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L202087:
  0002c	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?SelectObject@CDC@@QAEPAXPAX@Z ENDP			; CDC::SelectObject
_TEXT	ENDS
EXTRN	__imp__GetTextColor@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetTextColor@CDC@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTextColor@CDC@@QBEKXZ PROC NEAR			; CDC::GetTextColor, COMDAT
; _this$ = ecx

; 384  : 	{ ASSERT(m_hAttribDC != NULL); return ::GetTextColor(m_hAttribDC); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextColor@4
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetTextColor@CDC@@QBEKXZ ENDP				; CDC::GetTextColor
_TEXT	ENDS
EXTRN	__imp__BitBlt@36:NEAR
; Function compile flags: /Odt
;	COMDAT ?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_nWidth$ = 16						; size = 4
_nHeight$ = 20						; size = 4
_pSrcDC$ = 24						; size = 4
_xSrc$ = 28						; size = 4
_ySrc$ = 32						; size = 4
_dwRop$ = 36						; size = 4
?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z PROC NEAR		; CDC::BitBlt, COMDAT
; _this$ = ecx

; 548  : 	{ ASSERT(m_hDC != NULL); return ::BitBlt(m_hDC, x, y, nWidth, nHeight,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 549  : 		pSrcDC->GetSafeHdc(), xSrc, ySrc, dwRop); }

  00007	8b 45 24	 mov	 eax, DWORD PTR _dwRop$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 20	 mov	 ecx, DWORD PTR _ySrc$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 1c	 mov	 edx, DWORD PTR _xSrc$[ebp]
  00012	52		 push	 edx
  00013	8b 4d 18	 mov	 ecx, DWORD PTR _pSrcDC$[ebp]
  00016	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0001b	50		 push	 eax
  0001c	8b 45 14	 mov	 eax, DWORD PTR _nHeight$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR _nWidth$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	52		 push	 edx
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 20 00	 ret	 32			; 00000020H
?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z ENDP			; CDC::BitBlt
_TEXT	ENDS
EXTRN	__imp__GetClientRect@8:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin2.inl
;	COMDAT ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z PROC NEAR	; CWnd::GetClientRect, COMDAT
; _this$ = ecx

; 107  : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ENDP		; CWnd::GetClientRect
_TEXT	ENDS
EXTRN	__imp__ClientToScreen@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?ClientToScreen@CWnd@@QBEXPAUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpPoint$ = 8						; size = 4
?ClientToScreen@CWnd@@QBEXPAUtagPOINT@@@Z PROC NEAR	; CWnd::ClientToScreen, COMDAT
; _this$ = ecx

; 113  : 	{ ASSERT(::IsWindow(m_hWnd)); ::ClientToScreen(m_hWnd, lpPoint); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpPoint$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClientToScreen@8
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?ClientToScreen@CWnd@@QBEXPAUtagPOINT@@@Z ENDP		; CWnd::ClientToScreen
_TEXT	ENDS
EXTRN	__imp__ScreenToClient@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpPoint$ = 8						; size = 4
?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z PROC NEAR	; CWnd::ScreenToClient, COMDAT
; _this$ = ecx

; 115  : 	{ ASSERT(::IsWindow(m_hWnd)); ::ScreenToClient(m_hWnd, lpPoint); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpPoint$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ScreenToClient@8
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z ENDP		; CWnd::ScreenToClient
_TEXT	ENDS
EXTRN	__imp__InvalidateRect@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?Invalidate@CWnd@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bErase$ = 8						; size = 4
?Invalidate@CWnd@@QAEXH@Z PROC NEAR			; CWnd::Invalidate, COMDAT
; _this$ = ecx

; 135  : 	{ ASSERT(::IsWindow(m_hWnd)); ::InvalidateRect(m_hWnd, NULL, bErase); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _bErase$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00013	52		 push	 edx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?Invalidate@CWnd@@QAEXH@Z ENDP				; CWnd::Invalidate
_TEXT	ENDS
EXTRN	__imp__GetParent@4:NEAR
EXTRN	?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z:NEAR	; CWnd::FromHandle
; Function compile flags: /Odt
;	COMDAT ?GetParent@CWnd@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetParent@CWnd@@QBEPAV1@XZ PROC NEAR			; CWnd::GetParent, COMDAT
; _this$ = ecx

; 282  : 	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetParent(m_hWnd)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z ; CWnd::FromHandle
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?GetParent@CWnd@@QBEPAV1@XZ ENDP			; CWnd::GetParent
_TEXT	ENDS
EXTRN	?Default@CWnd@@IAEJXZ:NEAR			; CWnd::Default
; Function compile flags: /Odt
;	COMDAT ?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z PROC NEAR	; CWnd::OnCreate, COMDAT
; _this$ = ecx

; 360  : 	{ return (int)Default(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?OnCreate@CWnd@@IAEHPAUtagCREATESTRUCTA@@@Z ENDP	; CWnd::OnCreate
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z PROC NEAR ; CWnd::DoDataExchange, COMDAT
; _this$ = ecx

; 545  : 	{ } // default does nothing

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z ENDP	; CWnd::DoDataExchange
_TEXT	ENDS
EXTRN	__imp__EnableWindow@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?BeginModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BeginModalState@CWnd@@UAEXXZ PROC NEAR			; CWnd::BeginModalState, COMDAT
; _this$ = ecx

; 549  : 	{ ::EnableWindow(m_hWnd, FALSE); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	51		 push	 ecx
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?BeginModalState@CWnd@@UAEXXZ ENDP			; CWnd::BeginModalState
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?EndModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EndModalState@CWnd@@UAEXXZ PROC NEAR			; CWnd::EndModalState, COMDAT
; _this$ = ecx

; 551  : 	{ ::EnableWindow(m_hWnd, TRUE); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 01		 push	 1
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	51		 push	 ecx
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?EndModalState@CWnd@@UAEXXZ ENDP			; CWnd::EndModalState
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 28   : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202122 DD	0ffffffffH
	DD	FLAT:$L202117
$T202120 DD	019930520H
	DD	01H
	DD	FLAT:$T202122
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 20   : 		}

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202117:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202120
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102266
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102266:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202134 DD	0ffffffffH
	DD	FLAT:$L202129
$T202132 DD	019930520H
	DD	01H
	DD	FLAT:$T202134
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202129:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202132
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102332
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102332:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\basicskinwnd.h
_TEXT	ENDS
;	COMDAT ??1CBasicSkinWnd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CBasicSkinWnd@@UAE@XZ PROC NEAR			; CBasicSkinWnd::~CBasicSkinWnd, COMDAT
; _this$ = ecx

; 7    : 	virtual ~CBasicSkinWnd(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBasicSkinWnd@@6B@
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1CBasicSkinWnd@@UAE@XZ ENDP				; CBasicSkinWnd::~CBasicSkinWnd
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCBasicSkinWnd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCBasicSkinWnd@@UAEPAXI@Z PROC NEAR			; CBasicSkinWnd::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CBasicSkinWnd@@UAE@XZ ; CBasicSkinWnd::~CBasicSkinWnd
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L107858
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L107858:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCBasicSkinWnd@@UAEPAXI@Z ENDP			; CBasicSkinWnd::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\core\imessageobserver.h
_TEXT	ENDS
;	COMDAT ??1IMessageObserver@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1IMessageObserver@@UAE@XZ PROC NEAR			; IMessageObserver::~IMessageObserver, COMDAT
; _this$ = ecx

; 16   : 	virtual ~IMessageObserver(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IMessageObserver@@6B@
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1IMessageObserver@@UAE@XZ ENDP			; IMessageObserver::~IMessageObserver
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GIMessageObserver@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIMessageObserver@@UAEPAXI@Z PROC NEAR		; IMessageObserver::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1IMessageObserver@@UAE@XZ ; IMessageObserver::~IMessageObserver
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L109524
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L109524:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GIMessageObserver@@UAEPAXI@Z ENDP			; IMessageObserver::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202157 DD	0ffffffffH
	DD	FLAT:$L202152
$T202155 DD	019930520H
	DD	01H
	DD	FLAT:$T202157
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0003f	52		 push	 edx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202152:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202155
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
END
