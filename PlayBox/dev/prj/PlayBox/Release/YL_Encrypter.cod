; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\boxgit\PlayBox\CommonLib\common\YL_Encrypter.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG1194	DB	'KoOtOiTvINGwd', 00H
	ORG $+2
$SG1196	DB	'_Y8g2E6n0E1i7L5t2IoOoNk', 00H
$SG1208	DB	'_Y8g2E6n0E1i7L5t2IoOoNk', 00H
$SG1210	DB	'KoOtOiTvINGwd', 00H
CONST	ENDS
PUBLIC	?XOR@@YAXPAD0HH@Z				; XOR
; Function compile flags: /Odt
; File d:\boxgit\playbox\commonlib\common\yl_encrypter.cpp
_TEXT	SEGMENT
_i$1155 = -4						; size = 4
_data$ = 8						; size = 4
_key$ = 12						; size = 4
_datalen$ = 16						; size = 4
_keylen$ = 20						; size = 4
?XOR@@YAXPAD0HH@Z PROC NEAR				; XOR

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 21   : 	for (int i=0; i<datalen; i++)

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1155[ebp], 0
  0000b	eb 09		 jmp	 SHORT $L1156
$L1157:
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _i$1155[ebp]
  00010	83 c0 01	 add	 eax, 1
  00013	89 45 fc	 mov	 DWORD PTR _i$1155[ebp], eax
$L1156:
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _i$1155[ebp]
  00019	3b 4d 10	 cmp	 ecx, DWORD PTR _datalen$[ebp]
  0001c	7d 23		 jge	 SHORT $L1154

; 22   : 		*(data+i) ^= *(key+i%keylen);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _i$1155[ebp]
  00021	99		 cdq
  00022	f7 7d 14	 idiv	 DWORD PTR _keylen$[ebp]
  00025	8b 45 0c	 mov	 eax, DWORD PTR _key$[ebp]
  00028	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0002c	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  0002f	03 55 fc	 add	 edx, DWORD PTR _i$1155[ebp]
  00032	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00035	33 c1		 xor	 eax, ecx
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0003a	03 4d fc	 add	 ecx, DWORD PTR _i$1155[ebp]
  0003d	88 01		 mov	 BYTE PTR [ecx], al
  0003f	eb cc		 jmp	 SHORT $L1157
$L1154:

; 23   : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?XOR@@YAXPAD0HH@Z ENDP					; XOR
_TEXT	ENDS
PUBLIC	?MOVE@@YAXPADHH@Z				; MOVE
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	_memcpy:NEAR
EXTRN	_abs:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
$T1312 = -20						; size = 4
$T1311 = -16						; size = 4
_realpos$ = -12						; size = 4
_tmp$ = -8						; size = 4
_ptr$ = -4						; size = 4
_data$ = 8						; size = 4
_datalen$ = 12						; size = 4
_pos$ = 16						; size = 4
?MOVE@@YAXPADHH@Z PROC NEAR				; MOVE

; 26   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	83 ec 14	 sub	 esp, 20			; 00000014H

; 27   : 	if (pos == 0 || pos%datalen == 0)

  00056	83 7d 10 00	 cmp	 DWORD PTR _pos$[ebp], 0
  0005a	74 0b		 je	 SHORT $L1165
  0005c	8b 45 10	 mov	 eax, DWORD PTR _pos$[ebp]
  0005f	99		 cdq
  00060	f7 7d 0c	 idiv	 DWORD PTR _datalen$[ebp]
  00063	85 d2		 test	 edx, edx
  00065	75 05		 jne	 SHORT $L1164
$L1165:

; 28   : 		return;

  00067	e9 11 01 00 00	 jmp	 $L1163
$L1164:

; 29   : 
; 30   : 	int realpos = abs(pos);

  0006c	8b 45 10	 mov	 eax, DWORD PTR _pos$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _abs
  00075	83 c4 04	 add	 esp, 4
  00078	89 45 f4	 mov	 DWORD PTR _realpos$[ebp], eax
$L1168:

; 31   : 	while (realpos > datalen)

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _realpos$[ebp]
  0007e	3b 4d 0c	 cmp	 ecx, DWORD PTR _datalen$[ebp]
  00081	7e 0b		 jle	 SHORT $L1169

; 32   : 		realpos -= datalen;

  00083	8b 55 f4	 mov	 edx, DWORD PTR _realpos$[ebp]
  00086	2b 55 0c	 sub	 edx, DWORD PTR _datalen$[ebp]
  00089	89 55 f4	 mov	 DWORD PTR _realpos$[ebp], edx
  0008c	eb ed		 jmp	 SHORT $L1168
$L1169:

; 33   : 	
; 34   : 	char* tmp = new char[realpos];

  0008e	8b 45 f4	 mov	 eax, DWORD PTR _realpos$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00097	83 c4 04	 add	 esp, 4
  0009a	89 45 f0	 mov	 DWORD PTR $T1311[ebp], eax
  0009d	8b 4d f0	 mov	 ecx, DWORD PTR $T1311[ebp]
  000a0	89 4d f8	 mov	 DWORD PTR _tmp$[ebp], ecx

; 35   : 	char* ptr;
; 36   : 	if (pos > 0)

  000a3	83 7d 10 00	 cmp	 DWORD PTR _pos$[ebp], 0
  000a7	7e 66		 jle	 SHORT $L1174

; 37   : 	{
; 38   : 		memcpy( tmp, data+datalen-realpos, realpos );

  000a9	8b 55 f4	 mov	 edx, DWORD PTR _realpos$[ebp]
  000ac	52		 push	 edx
  000ad	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000b0	03 45 0c	 add	 eax, DWORD PTR _datalen$[ebp]
  000b3	2b 45 f4	 sub	 eax, DWORD PTR _realpos$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _memcpy
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 39   : 		ptr = data+datalen-1;

  000c3	8b 55 0c	 mov	 edx, DWORD PTR _datalen$[ebp]
  000c6	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000c9	8d 4c 10 ff	 lea	 ecx, DWORD PTR [eax+edx-1]
  000cd	89 4d fc	 mov	 DWORD PTR _ptr$[ebp], ecx

; 40   : 		for (; ptr>data+realpos-1; ptr--)

  000d0	eb 09		 jmp	 SHORT $L1175
$L1176:
  000d2	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  000d5	83 ea 01	 sub	 edx, 1
  000d8	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
$L1175:
  000db	8b 45 f4	 mov	 eax, DWORD PTR _realpos$[ebp]
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000e1	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  000e5	39 55 fc	 cmp	 DWORD PTR _ptr$[ebp], edx
  000e8	76 0f		 jbe	 SHORT $L1177

; 41   : 			*ptr = *(ptr-realpos);

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  000ed	2b 45 f4	 sub	 eax, DWORD PTR _realpos$[ebp]
  000f0	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000f3	8a 10		 mov	 dl, BYTE PTR [eax]
  000f5	88 11		 mov	 BYTE PTR [ecx], dl
  000f7	eb d9		 jmp	 SHORT $L1176
$L1177:

; 42   : 		memcpy( data, tmp, realpos );

  000f9	8b 45 f4	 mov	 eax, DWORD PTR _realpos$[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  00100	51		 push	 ecx
  00101	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00104	52		 push	 edx
  00105	e8 00 00 00 00	 call	 _memcpy
  0010a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 43   : 	}
; 44   : 	else

  0010d	eb 5c		 jmp	 SHORT $L1178
$L1174:

; 45   : 	{
; 46   : 		memcpy( tmp, data, realpos );

  0010f	8b 45 f4	 mov	 eax, DWORD PTR _realpos$[ebp]
  00112	50		 push	 eax
  00113	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00116	51		 push	 ecx
  00117	8b 55 f8	 mov	 edx, DWORD PTR _tmp$[ebp]
  0011a	52		 push	 edx
  0011b	e8 00 00 00 00	 call	 _memcpy
  00120	83 c4 0c	 add	 esp, 12			; 0000000cH

; 47   : 		ptr = data;

  00123	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00126	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 48   : 		for (; ptr<data+datalen-realpos; ptr++)

  00129	eb 09		 jmp	 SHORT $L1179
$L1180:
  0012b	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0012e	83 c1 01	 add	 ecx, 1
  00131	89 4d fc	 mov	 DWORD PTR _ptr$[ebp], ecx
$L1179:
  00134	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00137	03 55 0c	 add	 edx, DWORD PTR _datalen$[ebp]
  0013a	2b 55 f4	 sub	 edx, DWORD PTR _realpos$[ebp]
  0013d	39 55 fc	 cmp	 DWORD PTR _ptr$[ebp], edx
  00140	73 0f		 jae	 SHORT $L1181

; 49   : 			*ptr = *(ptr+realpos);

  00142	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00145	03 45 f4	 add	 eax, DWORD PTR _realpos$[ebp]
  00148	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0014b	8a 10		 mov	 dl, BYTE PTR [eax]
  0014d	88 11		 mov	 BYTE PTR [ecx], dl
  0014f	eb da		 jmp	 SHORT $L1180
$L1181:

; 50   : 		memcpy( data + datalen - realpos, tmp, realpos );

  00151	8b 45 f4	 mov	 eax, DWORD PTR _realpos$[ebp]
  00154	50		 push	 eax
  00155	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  00158	51		 push	 ecx
  00159	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  0015c	03 55 0c	 add	 edx, DWORD PTR _datalen$[ebp]
  0015f	2b 55 f4	 sub	 edx, DWORD PTR _realpos$[ebp]
  00162	52		 push	 edx
  00163	e8 00 00 00 00	 call	 _memcpy
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1178:

; 51   : 	}
; 52   : 	delete []tmp;

  0016b	8b 45 f8	 mov	 eax, DWORD PTR _tmp$[ebp]
  0016e	89 45 ec	 mov	 DWORD PTR $T1312[ebp], eax
  00171	8b 4d ec	 mov	 ecx, DWORD PTR $T1312[ebp]
  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0017a	83 c4 04	 add	 esp, 4
$L1163:

; 53   : }

  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c3		 ret	 0
?MOVE@@YAXPADHH@Z ENDP					; MOVE
_TEXT	ENDS
PUBLIC	?Encrypt@YL_Encrypter@@SAXPADHH@Z		; YL_Encrypter::Encrypt
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv64 = -48						; size = 4
_key2$1195 = -44					; size = 23
_key1$1193 = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_memptr$ = 8						; size = 4
_memlen$ = 12						; size = 4
_algorithmType$ = 16					; size = 4
?Encrypt@YL_Encrypter@@SAXPADHH@Z PROC NEAR		; YL_Encrypter::Encrypt

; 56   : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp
  00193	83 ec 30	 sub	 esp, 48			; 00000030H
  00196	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0019b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 57   : 	switch (algorithmType)

  0019e	8b 45 10	 mov	 eax, DWORD PTR _algorithmType$[ebp]
  001a1	89 45 d0	 mov	 DWORD PTR tv64[ebp], eax
  001a4	83 7d d0 00	 cmp	 DWORD PTR tv64[ebp], 0
  001a8	74 02		 je	 SHORT $L1192
  001aa	eb 79		 jmp	 SHORT $L1187
$L1192:

; 58   : 	{
; 59   : 	case 0:						//取前16个字节与后面的部分分别异或
; 60   : 		{
; 61   : 			char key1[XOR_KEY1_LEN];
; 62   : 			memcpy(key1,KT_ECRP_KEY1,XOR_KEY1_LEN);

  001ac	6a 0d		 push	 13			; 0000000dH
  001ae	68 00 00 00 00	 push	 OFFSET FLAT:$SG1194
  001b3	8d 4d ec	 lea	 ecx, DWORD PTR _key1$1193[ebp]
  001b6	51		 push	 ecx
  001b7	e8 00 00 00 00	 call	 _memcpy
  001bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 63   : 			MOVE( memptr, memlen,MOVE_POS1);		

  001bf	68 85 00 00 00	 push	 133			; 00000085H
  001c4	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  001c7	52		 push	 edx
  001c8	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 ?MOVE@@YAXPADHH@Z	; MOVE
  001d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 64   : 			XOR( memptr, key1, memlen, XOR_KEY1_LEN );

  001d4	6a 0d		 push	 13			; 0000000dH
  001d6	8b 4d 0c	 mov	 ecx, DWORD PTR _memlen$[ebp]
  001d9	51		 push	 ecx
  001da	8d 55 ec	 lea	 edx, DWORD PTR _key1$1193[ebp]
  001dd	52		 push	 edx
  001de	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 ?XOR@@YAXPAD0HH@Z	; XOR
  001e7	83 c4 10	 add	 esp, 16			; 00000010H

; 65   : 			char key2[XOR_KEY2_LEN];
; 66   : 			memcpy(key2,KT_ECRP_KEY2,XOR_KEY2_LEN);

  001ea	6a 17		 push	 23			; 00000017H
  001ec	68 00 00 00 00	 push	 OFFSET FLAT:$SG1196
  001f1	8d 4d d4	 lea	 ecx, DWORD PTR _key2$1195[ebp]
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _memcpy
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 67   : 			MOVE( memptr, memlen,-MOVE_POS2);

  001fd	6a b9		 push	 -71			; ffffffb9H
  001ff	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  00202	52		 push	 edx
  00203	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  00206	50		 push	 eax
  00207	e8 00 00 00 00	 call	 ?MOVE@@YAXPADHH@Z	; MOVE
  0020c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 68   : 			XOR( memptr, key2, memlen, XOR_KEY2_LEN );

  0020f	6a 17		 push	 23			; 00000017H
  00211	8b 4d 0c	 mov	 ecx, DWORD PTR _memlen$[ebp]
  00214	51		 push	 ecx
  00215	8d 55 d4	 lea	 edx, DWORD PTR _key2$1195[ebp]
  00218	52		 push	 edx
  00219	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  0021c	50		 push	 eax
  0021d	e8 00 00 00 00	 call	 ?XOR@@YAXPAD0HH@Z	; XOR
  00222	83 c4 10	 add	 esp, 16			; 00000010H
$L1187:

; 69   : 			break;
; 70   : 		}
; 71   : 	}
; 72   : }

  00225	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00228	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022d	8b e5		 mov	 esp, ebp
  0022f	5d		 pop	 ebp
  00230	c3		 ret	 0
?Encrypt@YL_Encrypter@@SAXPADHH@Z ENDP			; YL_Encrypter::Encrypt
_TEXT	ENDS
PUBLIC	?Decrypt@YL_Encrypter@@SAXPADHH@Z		; YL_Encrypter::Decrypt
; Function compile flags: /Odt
_TEXT	SEGMENT
tv64 = -48						; size = 4
_key2$1207 = -44					; size = 23
_key1$1209 = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_memptr$ = 8						; size = 4
_memlen$ = 12						; size = 4
_algorithmType$ = 16					; size = 4
?Decrypt@YL_Encrypter@@SAXPADHH@Z PROC NEAR		; YL_Encrypter::Decrypt

; 75   : {

  00240	55		 push	 ebp
  00241	8b ec		 mov	 ebp, esp
  00243	83 ec 30	 sub	 esp, 48			; 00000030H
  00246	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0024b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 76   : 	switch (algorithmType)

  0024e	8b 45 10	 mov	 eax, DWORD PTR _algorithmType$[ebp]
  00251	89 45 d0	 mov	 DWORD PTR tv64[ebp], eax
  00254	83 7d d0 00	 cmp	 DWORD PTR tv64[ebp], 0
  00258	74 02		 je	 SHORT $L1206
  0025a	eb 79		 jmp	 SHORT $L1201
$L1206:

; 77   : 	{
; 78   : 	case 0:						//取前16个字节与后面的部分分别异或
; 79   : 		{
; 80   : 			char key2[XOR_KEY2_LEN];
; 81   : 			memcpy(key2,KT_ECRP_KEY2,XOR_KEY2_LEN);	

  0025c	6a 17		 push	 23			; 00000017H
  0025e	68 00 00 00 00	 push	 OFFSET FLAT:$SG1208
  00263	8d 4d d4	 lea	 ecx, DWORD PTR _key2$1207[ebp]
  00266	51		 push	 ecx
  00267	e8 00 00 00 00	 call	 _memcpy
  0026c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 82   : 			XOR( memptr, key2, memlen, XOR_KEY2_LEN );

  0026f	6a 17		 push	 23			; 00000017H
  00271	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  00274	52		 push	 edx
  00275	8d 45 d4	 lea	 eax, DWORD PTR _key2$1207[ebp]
  00278	50		 push	 eax
  00279	8b 4d 08	 mov	 ecx, DWORD PTR _memptr$[ebp]
  0027c	51		 push	 ecx
  0027d	e8 00 00 00 00	 call	 ?XOR@@YAXPAD0HH@Z	; XOR
  00282	83 c4 10	 add	 esp, 16			; 00000010H

; 83   : 			MOVE( memptr, memlen,MOVE_POS2);	

  00285	6a 47		 push	 71			; 00000047H
  00287	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  0028a	52		 push	 edx
  0028b	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  0028e	50		 push	 eax
  0028f	e8 00 00 00 00	 call	 ?MOVE@@YAXPADHH@Z	; MOVE
  00294	83 c4 0c	 add	 esp, 12			; 0000000cH

; 84   : 
; 85   : 			char key1[XOR_KEY1_LEN];
; 86   : 			memcpy(key1,KT_ECRP_KEY1,XOR_KEY1_LEN);

  00297	6a 0d		 push	 13			; 0000000dH
  00299	68 00 00 00 00	 push	 OFFSET FLAT:$SG1210
  0029e	8d 4d ec	 lea	 ecx, DWORD PTR _key1$1209[ebp]
  002a1	51		 push	 ecx
  002a2	e8 00 00 00 00	 call	 _memcpy
  002a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 87   : 			XOR( memptr, key1, memlen, XOR_KEY1_LEN );

  002aa	6a 0d		 push	 13			; 0000000dH
  002ac	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  002af	52		 push	 edx
  002b0	8d 45 ec	 lea	 eax, DWORD PTR _key1$1209[ebp]
  002b3	50		 push	 eax
  002b4	8b 4d 08	 mov	 ecx, DWORD PTR _memptr$[ebp]
  002b7	51		 push	 ecx
  002b8	e8 00 00 00 00	 call	 ?XOR@@YAXPAD0HH@Z	; XOR
  002bd	83 c4 10	 add	 esp, 16			; 00000010H

; 88   : 			MOVE( memptr, memlen,-MOVE_POS1);	

  002c0	68 7b ff ff ff	 push	 -133			; ffffff7bH
  002c5	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  002c8	52		 push	 edx
  002c9	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  002cc	50		 push	 eax
  002cd	e8 00 00 00 00	 call	 ?MOVE@@YAXPADHH@Z	; MOVE
  002d2	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1201:

; 89   : 
; 90   : 			break;
; 91   : 		}
; 92   : 	}
; 93   : }

  002d5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002dd	8b e5		 mov	 esp, ebp
  002df	5d		 pop	 ebp
  002e0	c3		 ret	 0
?Decrypt@YL_Encrypter@@SAXPADHH@Z ENDP			; YL_Encrypter::Decrypt
_TEXT	ENDS
END
