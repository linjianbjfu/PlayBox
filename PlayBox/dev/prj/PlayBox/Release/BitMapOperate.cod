; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\LayoutMgr\ChangeColor\BitMapOperate.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??0DIBINFO@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1DIBINFO@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GDIBINFO@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBitMapOperate@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RGBtoHSL@CBitMapOperate@@QAEXMMMPAM00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HLStoRGB@CBitMapOperate@@QAEXABM00PAE11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HuetoRGB@CBitMapOperate@@QAEMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E5
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E6
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3DIBINFO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CBitMapOperate@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2DIBINFO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CBitMapOperate@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@DIBINFO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBitMapOperate@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVDIBINFO@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCBitMapOperate@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4DIBINFO@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CBitMapOperate@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFont@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CFont@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCFont@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CFont@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GCFont@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFont@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTextColor@CDC@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Polygon@CDC@@QAEHPAUtagPOINT@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreatePen@CPen@@QAEHHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPen@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CPen@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CPen@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCPen@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CPen@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CPen@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CPen@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCPen@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPen@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateSolidBrush@CBrush@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBrush@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBrush@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CBrush@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCBrush@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CBrush@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CBrush@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBrush@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCBrush@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBrush@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPixel@CDC@@QBEKHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectObject@CDC@@QAEPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMemoryException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMemoryException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CMemoryException@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCMemoryException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CMemoryException@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CMemoryException@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMemoryException@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSimpleException@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCSimpleException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CException@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GCMemoryException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSimpleException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMemoryException@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSimpleException@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?count@?9??ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV3@AAIAAK21@Z@4HA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?count1@?9??ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV3@AAIAAK21@Z@4HA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7CBitMapOperate@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7DIBINFO@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG199089 DB	0c1H, 0a5H, 0caH, 0e9H, 00H
CONST	ENDS
PUBLIC	??_R4CBitMapOperate@@6B@			; CBitMapOperate::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBitMapOperate@@@8			; CBitMapOperate `RTTI Type Descriptor'
PUBLIC	??_R3CBitMapOperate@@8				; CBitMapOperate::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBitMapOperate@@8				; CBitMapOperate::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CBitMapOperate@@8			; CBitMapOperate::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@DIBINFO@@8				; DIBINFO::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVDIBINFO@@@8				; DIBINFO `RTTI Type Descriptor'
PUBLIC	??0DIBINFO@@QAE@XZ				; DIBINFO::DIBINFO
PUBLIC	??0CBitMapOperate@@QAE@XZ			; CBitMapOperate::CBitMapOperate
PUBLIC	?FillRectangle@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKW4ENUM_DrawOrientation@1@HI@Z ; CBitMapOperate::FillRectangle
PUBLIC	?FillRectangleHue@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKW4ENUM_DrawOrientation@1@HI@Z ; CBitMapOperate::FillRectangleHue
PUBLIC	?FillRectangleLight@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKIW4ENUM_DrawOrientation@1@HI@Z ; CBitMapOperate::FillRectangleLight
PUBLIC	?FillRectangle@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KH@Z ; CBitMapOperate::FillRectangle
PUBLIC	?DrawLine@CBitMapOperate@@UAEXPAUHDC__@@KMHHHHH@Z ; CBitMapOperate::DrawLine
PUBLIC	?DrawArrow@CBitMapOperate@@UAEXPAUHDC__@@KHHHHHHH@Z ; CBitMapOperate::DrawArrow
PUBLIC	?DrawTextA@CBitMapOperate@@UAEXPAVCDC@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@KAAUtagRECT@@I_NIIIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CBitMapOperate::DrawTextA
PUBLIC	??_7CBitMapOperate@@6B@				; CBitMapOperate::`vftable'
PUBLIC	??_GCBitMapOperate@@UAEPAXI@Z			; CBitMapOperate::`scalar deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECBitMapOperate@@UAEPAXI@Z:NEAR		; CBitMapOperate::`vector deleting destructor'
;	COMDAT ??_7CBitMapOperate@@6B@
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\layoutmgr\changecolor\bitmapoperate.cpp
CONST	SEGMENT
??_7CBitMapOperate@@6B@ DD FLAT:??_R4CBitMapOperate@@6B@ ; CBitMapOperate::`vftable'
	DD	FLAT:??_ECBitMapOperate@@UAEPAXI@Z
	DD	FLAT:?FillRectangle@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KH@Z
	DD	FLAT:?FillRectangle@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKW4ENUM_DrawOrientation@1@HI@Z
	DD	FLAT:?FillRectangleHue@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKW4ENUM_DrawOrientation@1@HI@Z
	DD	FLAT:?FillRectangleLight@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKIW4ENUM_DrawOrientation@1@HI@Z
	DD	FLAT:?DrawLine@CBitMapOperate@@UAEXPAUHDC__@@KMHHHHH@Z
	DD	FLAT:?DrawArrow@CBitMapOperate@@UAEXPAUHDC__@@KHHHHHHH@Z
	DD	FLAT:?DrawTextA@CBitMapOperate@@UAEXPAVCDC@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@KAAUtagRECT@@I_NIIIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
CONST	ENDS
;	COMDAT ??_R4CBitMapOperate@@6B@
rdata$r	SEGMENT
??_R4CBitMapOperate@@6B@ DD 00H				; CBitMapOperate::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBitMapOperate@@@8
	DD	FLAT:??_R3CBitMapOperate@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBitMapOperate@@@8
_DATA	SEGMENT
??_R0?AVCBitMapOperate@@@8 DD FLAT:??_7type_info@@6B@	; CBitMapOperate `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBitMapOperate@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CBitMapOperate@@8
rdata$r	SEGMENT
??_R3CBitMapOperate@@8 DD 00H				; CBitMapOperate::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CBitMapOperate@@8
rdata$r	ENDS
;	COMDAT ??_R2CBitMapOperate@@8
rdata$r	SEGMENT
??_R2CBitMapOperate@@8 DD FLAT:??_R1A@?0A@A@CBitMapOperate@@8 ; CBitMapOperate::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@DIBINFO@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBitMapOperate@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CBitMapOperate@@8 DD FLAT:??_R0?AVCBitMapOperate@@@8 ; CBitMapOperate::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@DIBINFO@@8
rdata$r	SEGMENT
??_R1A@?0A@A@DIBINFO@@8 DD FLAT:??_R0?AVDIBINFO@@@8	; DIBINFO::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVDIBINFO@@@8
_DATA	SEGMENT
??_R0?AVDIBINFO@@@8 DD FLAT:??_7type_info@@6B@		; DIBINFO `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDIBINFO@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CBitMapOperate@@QAE@XZ PROC NEAR			; CBitMapOperate::CBitMapOperate
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0DIBINFO@@QAE@XZ	; DIBINFO::DIBINFO
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBitMapOperate@@6B@

; 24   : 	m_nLastLightPos = 120;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 18 78 00
	00 00		 mov	 DWORD PTR [ecx+24], 120	; 00000078H

; 25   : }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0CBitMapOperate@@QAE@XZ ENDP				; CBitMapOperate::CBitMapOperate
_TEXT	ENDS
PUBLIC	??_R4DIBINFO@@6B@				; DIBINFO::`RTTI Complete Object Locator'
PUBLIC	??_R3DIBINFO@@8					; DIBINFO::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DIBINFO@@8					; DIBINFO::`RTTI Base Class Array'
PUBLIC	??_7DIBINFO@@6B@				; DIBINFO::`vftable'
PUBLIC	??_GDIBINFO@@UAEPAXI@Z				; DIBINFO::`scalar deleting destructor'
EXTRN	_memset:NEAR
EXTRN	??_EDIBINFO@@UAEPAXI@Z:NEAR			; DIBINFO::`vector deleting destructor'
;	COMDAT ??_7DIBINFO@@6B@
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\layoutmgr\changecolor\bitmapoperate.h
CONST	SEGMENT
??_7DIBINFO@@6B@ DD FLAT:??_R4DIBINFO@@6B@		; DIBINFO::`vftable'
	DD	FLAT:??_EDIBINFO@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4DIBINFO@@6B@
rdata$r	SEGMENT
??_R4DIBINFO@@6B@ DD 00H				; DIBINFO::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDIBINFO@@@8
	DD	FLAT:??_R3DIBINFO@@8
rdata$r	ENDS
;	COMDAT ??_R3DIBINFO@@8
rdata$r	SEGMENT
??_R3DIBINFO@@8 DD 00H					; DIBINFO::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DIBINFO@@8
rdata$r	ENDS
;	COMDAT ??_R2DIBINFO@@8
rdata$r	SEGMENT
??_R2DIBINFO@@8 DD FLAT:??_R1A@?0A@A@DIBINFO@@8		; DIBINFO::`RTTI Base Class Array'
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0DIBINFO@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DIBINFO@@QAE@XZ PROC NEAR				; DIBINFO::DIBINFO, COMDAT
; _this$ = ecx

; 16   : 	DIBINFO()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7DIBINFO@@6B@

; 17   : 	{
; 18   : 		::ZeroMemory(this,sizeof(*this) );

  00010	6a 18		 push	 24			; 00000018H
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19   : 	};

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0DIBINFO@@QAE@XZ ENDP					; DIBINFO::DIBINFO
_TEXT	ENDS
PUBLIC	??1DIBINFO@@UAE@XZ				; DIBINFO::~DIBINFO
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt
;	COMDAT ??_GDIBINFO@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDIBINFO@@UAEPAXI@Z PROC NEAR			; DIBINFO::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1DIBINFO@@UAE@XZ	; DIBINFO::~DIBINFO
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L197411
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L197411:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GDIBINFO@@UAEPAXI@Z ENDP				; DIBINFO::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1DIBINFO@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DIBINFO@@UAE@XZ PROC NEAR				; DIBINFO::~DIBINFO, COMDAT
; _this$ = ecx

; 25   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7DIBINFO@@6B@

; 26   : 		::ZeroMemory(this,sizeof(*this) );

  00010	6a 18		 push	 24			; 00000018H
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27   : 	};

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1DIBINFO@@UAE@XZ ENDP					; DIBINFO::~DIBINFO
_TEXT	ENDS
PUBLIC	??1CBitMapOperate@@UAE@XZ			; CBitMapOperate::~CBitMapOperate
; Function compile flags: /Odt
;	COMDAT ??_GCBitMapOperate@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCBitMapOperate@@UAEPAXI@Z PROC NEAR			; CBitMapOperate::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CBitMapOperate@@UAE@XZ ; CBitMapOperate::~CBitMapOperate
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L197578
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L197578:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCBitMapOperate@@UAEPAXI@Z ENDP			; CBitMapOperate::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\layoutmgr\changecolor\bitmapoperate.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CBitMapOperate@@UAE@XZ PROC NEAR			; CBitMapOperate::~CBitMapOperate
; _this$ = ecx

; 28   : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	51		 push	 ecx
  00034	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBitMapOperate@@6B@

; 29   : }

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ??1DIBINFO@@UAE@XZ	; DIBINFO::~DIBINFO
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??1CBitMapOperate@@UAE@XZ ENDP				; CBitMapOperate::~CBitMapOperate
_TEXT	ENDS
PUBLIC	?SetHBS@CBitMapOperate@@QAEXKAAM00@Z		; CBitMapOperate::SetHBS
PUBLIC	__real@43ff0000
PUBLIC	__real@3f000000
PUBLIC	__real@40c00000
PUBLIC	__real@42700000
PUBLIC	__real@40000000
PUBLIC	__real@40800000
PUBLIC	__real@43b40000
EXTRN	__fltused:NEAR
;	COMDAT __real@43ff0000
CONST	SEGMENT
__real@43ff0000 DD 043ff0000r			; 510
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
; Function compile flags: /Odt
CONST	ENDS
_TEXT	SEGMENT
tv85 = -80						; size = 4
tv86 = -76						; size = 4
tv82 = -72						; size = 4
tv79 = -68						; size = 4
tv80 = -64						; size = 4
tv76 = -60						; size = 4
tv157 = -56						; size = 4
tv155 = -52						; size = 4
tv154 = -48						; size = 4
_this$ = -44						; size = 4
_lfMaxValue$ = -40					; size = 4
_lfMinValue$ = -36					; size = 4
_lfBlueTarget$ = -32					; size = 4
_lfRed$ = -28						; size = 4
_lfSum$ = -24						; size = 4
_lfGreenTarget$ = -20					; size = 4
_lfGreen$ = -16						; size = 4
_lfDiff$ = -12						; size = 4
_lfBlue$ = -8						; size = 4
_lfRedTarget$ = -4					; size = 4
_aSourceColor$ = 8					; size = 4
_afHue$ = 12						; size = 4
_afBrightness$ = 16					; size = 4
_afSaturation$ = 20					; size = 4
?SetHBS@CBitMapOperate@@QAEXKAAM00@Z PROC NEAR		; CBitMapOperate::SetHBS
; _this$ = ecx

; 170  : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	83 ec 50	 sub	 esp, 80			; 00000050H
  00056	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 	FLOAT lfRed   = GetRValue(aSourceColor);

  00059	0f b6 45 08	 movzx	 eax, BYTE PTR _aSourceColor$[ebp]
  0005d	89 45 d0	 mov	 DWORD PTR tv154[ebp], eax
  00060	db 45 d0	 fild	 DWORD PTR tv154[ebp]
  00063	d9 5d e4	 fstp	 DWORD PTR _lfRed$[ebp]

; 172  : 	FLOAT lfGreen = GetGValue(aSourceColor);

  00066	0f b7 4d 08	 movzx	 ecx, WORD PTR _aSourceColor$[ebp]
  0006a	c1 f9 08	 sar	 ecx, 8
  0006d	0f b6 d1	 movzx	 edx, cl
  00070	89 55 cc	 mov	 DWORD PTR tv155[ebp], edx
  00073	db 45 cc	 fild	 DWORD PTR tv155[ebp]
  00076	d9 5d f0	 fstp	 DWORD PTR _lfGreen$[ebp]

; 173  : 	FLOAT lfBlue  = GetBValue(aSourceColor);

  00079	8b 45 08	 mov	 eax, DWORD PTR _aSourceColor$[ebp]
  0007c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0007f	0f b6 c8	 movzx	 ecx, al
  00082	89 4d c8	 mov	 DWORD PTR tv157[ebp], ecx
  00085	db 45 c8	 fild	 DWORD PTR tv157[ebp]
  00088	d9 5d f8	 fstp	 DWORD PTR _lfBlue$[ebp]

; 174  : 
; 175  : 	FLOAT lfMaxValue = max(lfRed, max(lfGreen, lfBlue));

  0008b	d9 45 f0	 fld	 DWORD PTR _lfGreen$[ebp]
  0008e	d8 5d f8	 fcomp	 DWORD PTR _lfBlue$[ebp]
  00091	df e0		 fnstsw	 ax
  00093	f6 c4 41	 test	 ah, 65			; 00000041H
  00096	75 08		 jne	 SHORT $L199642
  00098	8b 55 f0	 mov	 edx, DWORD PTR _lfGreen$[ebp]
  0009b	89 55 c4	 mov	 DWORD PTR tv76[ebp], edx
  0009e	eb 06		 jmp	 SHORT $L199643
$L199642:
  000a0	8b 45 f8	 mov	 eax, DWORD PTR _lfBlue$[ebp]
  000a3	89 45 c4	 mov	 DWORD PTR tv76[ebp], eax
$L199643:
  000a6	d9 45 e4	 fld	 DWORD PTR _lfRed$[ebp]
  000a9	d8 5d c4	 fcomp	 DWORD PTR tv76[ebp]
  000ac	df e0		 fnstsw	 ax
  000ae	f6 c4 41	 test	 ah, 65			; 00000041H
  000b1	75 08		 jne	 SHORT $L199646
  000b3	8b 4d e4	 mov	 ecx, DWORD PTR _lfRed$[ebp]
  000b6	89 4d c0	 mov	 DWORD PTR tv80[ebp], ecx
  000b9	eb 21		 jmp	 SHORT $L199647
$L199646:
  000bb	d9 45 f0	 fld	 DWORD PTR _lfGreen$[ebp]
  000be	d8 5d f8	 fcomp	 DWORD PTR _lfBlue$[ebp]
  000c1	df e0		 fnstsw	 ax
  000c3	f6 c4 41	 test	 ah, 65			; 00000041H
  000c6	75 08		 jne	 SHORT $L199644
  000c8	8b 55 f0	 mov	 edx, DWORD PTR _lfGreen$[ebp]
  000cb	89 55 bc	 mov	 DWORD PTR tv79[ebp], edx
  000ce	eb 06		 jmp	 SHORT $L199645
$L199644:
  000d0	8b 45 f8	 mov	 eax, DWORD PTR _lfBlue$[ebp]
  000d3	89 45 bc	 mov	 DWORD PTR tv79[ebp], eax
$L199645:
  000d6	8b 4d bc	 mov	 ecx, DWORD PTR tv79[ebp]
  000d9	89 4d c0	 mov	 DWORD PTR tv80[ebp], ecx
$L199647:
  000dc	8b 55 c0	 mov	 edx, DWORD PTR tv80[ebp]
  000df	89 55 d8	 mov	 DWORD PTR _lfMaxValue$[ebp], edx

; 176  : 	FLOAT lfMinValue = min(lfRed, min(lfGreen, lfBlue));

  000e2	d9 45 f0	 fld	 DWORD PTR _lfGreen$[ebp]
  000e5	d8 5d f8	 fcomp	 DWORD PTR _lfBlue$[ebp]
  000e8	df e0		 fnstsw	 ax
  000ea	f6 c4 05	 test	 ah, 5
  000ed	7a 08		 jp	 SHORT $L199648
  000ef	8b 45 f0	 mov	 eax, DWORD PTR _lfGreen$[ebp]
  000f2	89 45 b8	 mov	 DWORD PTR tv82[ebp], eax
  000f5	eb 06		 jmp	 SHORT $L199649
$L199648:
  000f7	8b 4d f8	 mov	 ecx, DWORD PTR _lfBlue$[ebp]
  000fa	89 4d b8	 mov	 DWORD PTR tv82[ebp], ecx
$L199649:
  000fd	d9 45 e4	 fld	 DWORD PTR _lfRed$[ebp]
  00100	d8 5d b8	 fcomp	 DWORD PTR tv82[ebp]
  00103	df e0		 fnstsw	 ax
  00105	f6 c4 05	 test	 ah, 5
  00108	7a 08		 jp	 SHORT $L199652
  0010a	8b 55 e4	 mov	 edx, DWORD PTR _lfRed$[ebp]
  0010d	89 55 b4	 mov	 DWORD PTR tv86[ebp], edx
  00110	eb 21		 jmp	 SHORT $L199653
$L199652:
  00112	d9 45 f0	 fld	 DWORD PTR _lfGreen$[ebp]
  00115	d8 5d f8	 fcomp	 DWORD PTR _lfBlue$[ebp]
  00118	df e0		 fnstsw	 ax
  0011a	f6 c4 05	 test	 ah, 5
  0011d	7a 08		 jp	 SHORT $L199650
  0011f	8b 45 f0	 mov	 eax, DWORD PTR _lfGreen$[ebp]
  00122	89 45 b0	 mov	 DWORD PTR tv85[ebp], eax
  00125	eb 06		 jmp	 SHORT $L199651
$L199650:
  00127	8b 4d f8	 mov	 ecx, DWORD PTR _lfBlue$[ebp]
  0012a	89 4d b0	 mov	 DWORD PTR tv85[ebp], ecx
$L199651:
  0012d	8b 55 b0	 mov	 edx, DWORD PTR tv85[ebp]
  00130	89 55 b4	 mov	 DWORD PTR tv86[ebp], edx
$L199653:
  00133	8b 45 b4	 mov	 eax, DWORD PTR tv86[ebp]
  00136	89 45 dc	 mov	 DWORD PTR _lfMinValue$[ebp], eax

; 177  : 
; 178  : 	FLOAT lfDiff, lfSum, lfRedTarget, lfGreenTarget, lfBlueTarget;
; 179  : 
; 180  : 	lfDiff = lfMaxValue - lfMinValue;

  00139	d9 45 d8	 fld	 DWORD PTR _lfMaxValue$[ebp]
  0013c	d8 65 dc	 fsub	 DWORD PTR _lfMinValue$[ebp]
  0013f	d9 5d f4	 fstp	 DWORD PTR _lfDiff$[ebp]

; 181  : 	lfSum  = lfMaxValue + lfMinValue;

  00142	d9 45 d8	 fld	 DWORD PTR _lfMaxValue$[ebp]
  00145	d8 45 dc	 fadd	 DWORD PTR _lfMinValue$[ebp]
  00148	d9 55 e8	 fst	 DWORD PTR _lfSum$[ebp]

; 182  : 	afBrightness = lfSum / 510.0f;

  0014b	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@43ff0000
  00151	8b 4d 10	 mov	 ecx, DWORD PTR _afBrightness$[ebp]
  00154	d9 19		 fstp	 DWORD PTR [ecx]

; 183  : 
; 184  : 	if (lfMaxValue == lfMinValue)

  00156	d9 45 dc	 fld	 DWORD PTR _lfMinValue$[ebp]
  00159	d9 45 d8	 fld	 DWORD PTR _lfMaxValue$[ebp]
  0015c	da e9		 fucompp
  0015e	df e0		 fnstsw	 ax
  00160	f6 c4 44	 test	 ah, 68			; 00000044H
  00163	7a 17		 jp	 SHORT $L197735

; 185  : 	{
; 186  : 		afSaturation = 0.0f;

  00165	8b 55 14	 mov	 edx, DWORD PTR _afSaturation$[ebp]
  00168	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 187  : 		afHue = 0.0f;

  0016e	8b 45 0c	 mov	 eax, DWORD PTR _afHue$[ebp]
  00171	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 188  : 	}
; 189  : 	else

  00177	e9 e8 00 00 00	 jmp	 $L197720
$L197735:

; 190  : 	{
; 191  : 		lfRedTarget = (lfMaxValue - lfRed) / lfDiff;

  0017c	d9 45 d8	 fld	 DWORD PTR _lfMaxValue$[ebp]
  0017f	d8 65 e4	 fsub	 DWORD PTR _lfRed$[ebp]
  00182	d8 75 f4	 fdiv	 DWORD PTR _lfDiff$[ebp]
  00185	d9 5d fc	 fstp	 DWORD PTR _lfRedTarget$[ebp]

; 192  : 		lfGreenTarget = (lfMaxValue - lfGreen) / lfDiff;

  00188	d9 45 d8	 fld	 DWORD PTR _lfMaxValue$[ebp]
  0018b	d8 65 f0	 fsub	 DWORD PTR _lfGreen$[ebp]
  0018e	d8 75 f4	 fdiv	 DWORD PTR _lfDiff$[ebp]
  00191	d9 5d ec	 fstp	 DWORD PTR _lfGreenTarget$[ebp]

; 193  : 		lfBlueTarget = (lfMaxValue - lfBlue) / lfDiff;

  00194	d9 45 d8	 fld	 DWORD PTR _lfMaxValue$[ebp]
  00197	d8 65 f8	 fsub	 DWORD PTR _lfBlue$[ebp]
  0019a	d8 75 f4	 fdiv	 DWORD PTR _lfDiff$[ebp]
  0019d	d9 5d e0	 fstp	 DWORD PTR _lfBlueTarget$[ebp]

; 194  : 
; 195  : 		if (afBrightness <= 0.5f)

  001a0	8b 4d 10	 mov	 ecx, DWORD PTR _afBrightness$[ebp]
  001a3	d9 01		 fld	 DWORD PTR [ecx]
  001a5	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f000000
  001ab	df e0		 fnstsw	 ax
  001ad	f6 c4 41	 test	 ah, 65			; 00000041H
  001b0	7a 0d		 jp	 SHORT $L197737

; 196  : 			afSaturation = lfDiff / lfSum;

  001b2	d9 45 f4	 fld	 DWORD PTR _lfDiff$[ebp]
  001b5	d8 75 e8	 fdiv	 DWORD PTR _lfSum$[ebp]
  001b8	8b 55 14	 mov	 edx, DWORD PTR _afSaturation$[ebp]
  001bb	d9 1a		 fstp	 DWORD PTR [edx]

; 197  : 		else

  001bd	eb 11		 jmp	 SHORT $L197738
$L197737:

; 198  : 			afSaturation = lfDiff / (510.0f - lfSum);

  001bf	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@43ff0000
  001c5	d8 65 e8	 fsub	 DWORD PTR _lfSum$[ebp]
  001c8	d8 7d f4	 fdivr	 DWORD PTR _lfDiff$[ebp]
  001cb	8b 45 14	 mov	 eax, DWORD PTR _afSaturation$[ebp]
  001ce	d9 18		 fstp	 DWORD PTR [eax]
$L197738:

; 199  : 
; 200  : 		if (lfRed == lfMaxValue)

  001d0	d9 45 d8	 fld	 DWORD PTR _lfMaxValue$[ebp]
  001d3	d9 45 e4	 fld	 DWORD PTR _lfRed$[ebp]
  001d6	da e9		 fucompp
  001d8	df e0		 fnstsw	 ax
  001da	f6 c4 44	 test	 ah, 68			; 00000044H
  001dd	7a 17		 jp	 SHORT $L197739

; 201  : 			afHue = 60.0f * (6.0f + lfBlueTarget - lfGreenTarget);

  001df	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40c00000
  001e5	d8 45 e0	 fadd	 DWORD PTR _lfBlueTarget$[ebp]
  001e8	d8 65 ec	 fsub	 DWORD PTR _lfGreenTarget$[ebp]
  001eb	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@42700000
  001f1	8b 4d 0c	 mov	 ecx, DWORD PTR _afHue$[ebp]
  001f4	d9 19		 fstp	 DWORD PTR [ecx]
$L197739:

; 202  : 		if (lfGreen == lfMaxValue)

  001f6	d9 45 d8	 fld	 DWORD PTR _lfMaxValue$[ebp]
  001f9	d9 45 f0	 fld	 DWORD PTR _lfGreen$[ebp]
  001fc	da e9		 fucompp
  001fe	df e0		 fnstsw	 ax
  00200	f6 c4 44	 test	 ah, 68			; 00000044H
  00203	7a 17		 jp	 SHORT $L197740

; 203  : 			afHue = 60.0f * (2.0f + lfRedTarget - lfBlueTarget);

  00205	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40000000
  0020b	d8 45 fc	 fadd	 DWORD PTR _lfRedTarget$[ebp]
  0020e	d8 65 e0	 fsub	 DWORD PTR _lfBlueTarget$[ebp]
  00211	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@42700000
  00217	8b 55 0c	 mov	 edx, DWORD PTR _afHue$[ebp]
  0021a	d9 1a		 fstp	 DWORD PTR [edx]
$L197740:

; 204  : 		if (lfBlue == lfMaxValue)

  0021c	d9 45 d8	 fld	 DWORD PTR _lfMaxValue$[ebp]
  0021f	d9 45 f8	 fld	 DWORD PTR _lfBlue$[ebp]
  00222	da e9		 fucompp
  00224	df e0		 fnstsw	 ax
  00226	f6 c4 44	 test	 ah, 68			; 00000044H
  00229	7a 17		 jp	 SHORT $L197741

; 205  : 			afHue = 60.0f * (4.0f + lfGreenTarget - lfRedTarget);

  0022b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40800000
  00231	d8 45 ec	 fadd	 DWORD PTR _lfGreenTarget$[ebp]
  00234	d8 65 fc	 fsub	 DWORD PTR _lfRedTarget$[ebp]
  00237	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@42700000
  0023d	8b 45 0c	 mov	 eax, DWORD PTR _afHue$[ebp]
  00240	d9 18		 fstp	 DWORD PTR [eax]
$L197741:

; 206  : 		if (afHue > 360.0f)

  00242	8b 4d 0c	 mov	 ecx, DWORD PTR _afHue$[ebp]
  00245	d9 01		 fld	 DWORD PTR [ecx]
  00247	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@43b40000
  0024d	df e0		 fnstsw	 ax
  0024f	f6 c4 41	 test	 ah, 65			; 00000041H
  00252	75 10		 jne	 SHORT $L197720

; 207  : 			afHue = afHue - 360.0f;

  00254	8b 55 0c	 mov	 edx, DWORD PTR _afHue$[ebp]
  00257	d9 02		 fld	 DWORD PTR [edx]
  00259	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@43b40000
  0025f	8b 45 0c	 mov	 eax, DWORD PTR _afHue$[ebp]
  00262	d9 18		 fstp	 DWORD PTR [eax]
$L197720:

; 208  : 	}
; 209  : }

  00264	8b e5		 mov	 esp, ebp
  00266	5d		 pop	 ebp
  00267	c2 10 00	 ret	 16			; 00000010H
?SetHBS@CBitMapOperate@@QAEXKAAM00@Z ENDP		; CBitMapOperate::SetHBS
_TEXT	ENDS
PUBLIC	?HuetoRGB@CBitMapOperate@@QAEMMMM@Z		; CBitMapOperate::HuetoRGB
PUBLIC	?SetRGB@CBitMapOperate@@QAEXAAKMMM@Z		; CBitMapOperate::SetRGB
PUBLIC	__real@00000000
PUBLIC	__real@437f0000
PUBLIC	__real@42f00000
EXTRN	__ftol2:NEAR
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
; Function compile flags: /Odt
CONST	ENDS
_TEXT	SEGMENT
tv150 = -36						; size = 4
tv147 = -32						; size = 4
tv145 = -28						; size = 4
_this$ = -24						; size = 4
_lfValue1$197759 = -20					; size = 4
_lfValue2$197760 = -16					; size = 4
_lfRed$ = -12						; size = 4
_lfGreen$ = -8						; size = 4
_lfBlue$ = -4						; size = 4
_aSourceColor$ = 8					; size = 4
_afHue$ = 12						; size = 4
_afBrightness$ = 16					; size = 4
_afSaturation$ = 20					; size = 4
?SetRGB@CBitMapOperate@@QAEXAAKMMM@Z PROC NEAR		; CBitMapOperate::SetRGB
; _this$ = ecx

; 211  : {

  00270	55		 push	 ebp
  00271	8b ec		 mov	 ebp, esp
  00273	83 ec 24	 sub	 esp, 36			; 00000024H
  00276	56		 push	 esi
  00277	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 212  : 	FLOAT lfRed = GetRValue(aSourceColor);

  0027a	8b 45 08	 mov	 eax, DWORD PTR _aSourceColor$[ebp]
  0027d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00280	89 4d e4	 mov	 DWORD PTR tv145[ebp], ecx
  00283	db 45 e4	 fild	 DWORD PTR tv145[ebp]
  00286	d9 5d f4	 fstp	 DWORD PTR _lfRed$[ebp]

; 213  : 	FLOAT lfGreen = GetGValue(aSourceColor);

  00289	8b 55 08	 mov	 edx, DWORD PTR _aSourceColor$[ebp]
  0028c	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0028f	c1 f8 08	 sar	 eax, 8
  00292	0f b6 c8	 movzx	 ecx, al
  00295	89 4d e0	 mov	 DWORD PTR tv147[ebp], ecx
  00298	db 45 e0	 fild	 DWORD PTR tv147[ebp]
  0029b	d9 5d f8	 fstp	 DWORD PTR _lfGreen$[ebp]

; 214  : 	FLOAT lfBlue = GetBValue(aSourceColor);

  0029e	8b 55 08	 mov	 edx, DWORD PTR _aSourceColor$[ebp]
  002a1	8b 02		 mov	 eax, DWORD PTR [edx]
  002a3	c1 e8 10	 shr	 eax, 16			; 00000010H
  002a6	0f b6 c8	 movzx	 ecx, al
  002a9	89 4d dc	 mov	 DWORD PTR tv150[ebp], ecx
  002ac	db 45 dc	 fild	 DWORD PTR tv150[ebp]
  002af	d9 5d fc	 fstp	 DWORD PTR _lfBlue$[ebp]

; 215  : 
; 216  : 	if (afSaturation == 0.0f)

  002b2	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  002b8	d9 45 14	 fld	 DWORD PTR _afSaturation$[ebp]
  002bb	da e9		 fucompp
  002bd	df e0		 fnstsw	 ax
  002bf	f6 c4 44	 test	 ah, 68			; 00000044H
  002c2	7a 1d		 jp	 SHORT $L197757

; 217  : 	{
; 218  : 		lfRed = lfGreen = lfBlue = afBrightness * 255.0f;

  002c4	d9 45 10	 fld	 DWORD PTR _afBrightness$[ebp]
  002c7	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@437f0000
  002cd	d9 5d fc	 fstp	 DWORD PTR _lfBlue$[ebp]
  002d0	8b 55 fc	 mov	 edx, DWORD PTR _lfBlue$[ebp]
  002d3	89 55 f8	 mov	 DWORD PTR _lfGreen$[ebp], edx
  002d6	8b 45 f8	 mov	 eax, DWORD PTR _lfGreen$[ebp]
  002d9	89 45 f4	 mov	 DWORD PTR _lfRed$[ebp], eax

; 219  : 	}
; 220  : 	else

  002dc	e9 95 00 00 00	 jmp	 $L197758
$L197757:

; 221  : 	{
; 222  : 		FLOAT lfValue1, lfValue2;
; 223  : 
; 224  : 		if (afBrightness <= 0.5f)

  002e1	d9 45 10	 fld	 DWORD PTR _afBrightness$[ebp]
  002e4	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f000000
  002ea	df e0		 fnstsw	 ax
  002ec	f6 c4 41	 test	 ah, 65			; 00000041H
  002ef	7a 0e		 jp	 SHORT $L197761

; 225  : 			lfValue2 = afBrightness + afBrightness * afSaturation;

  002f1	d9 45 10	 fld	 DWORD PTR _afBrightness$[ebp]
  002f4	d8 4d 14	 fmul	 DWORD PTR _afSaturation$[ebp]
  002f7	d8 45 10	 fadd	 DWORD PTR _afBrightness$[ebp]
  002fa	d9 5d f0	 fstp	 DWORD PTR _lfValue2$197760[ebp]

; 226  : 		else

  002fd	eb 11		 jmp	 SHORT $L197762
$L197761:

; 227  : 			lfValue2 = afBrightness + afSaturation - afBrightness * afSaturation;

  002ff	d9 45 10	 fld	 DWORD PTR _afBrightness$[ebp]
  00302	d8 45 14	 fadd	 DWORD PTR _afSaturation$[ebp]
  00305	d9 45 10	 fld	 DWORD PTR _afBrightness$[ebp]
  00308	d8 4d 14	 fmul	 DWORD PTR _afSaturation$[ebp]
  0030b	de e9		 fsubp	 ST(1), ST(0)
  0030d	d9 5d f0	 fstp	 DWORD PTR _lfValue2$197760[ebp]
$L197762:

; 228  : 
; 229  : 		lfValue1 = 2.0f * afBrightness - lfValue2;

  00310	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40000000
  00316	d8 4d 10	 fmul	 DWORD PTR _afBrightness$[ebp]
  00319	d8 65 f0	 fsub	 DWORD PTR _lfValue2$197760[ebp]
  0031c	d9 5d ec	 fstp	 DWORD PTR _lfValue1$197759[ebp]

; 230  : 		lfRed = HuetoRGB(lfValue1, lfValue2, afHue + 120.0f);

  0031f	d9 45 0c	 fld	 DWORD PTR _afHue$[ebp]
  00322	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@42f00000
  00328	51		 push	 ecx
  00329	d9 1c 24	 fstp	 DWORD PTR [esp]
  0032c	8b 4d f0	 mov	 ecx, DWORD PTR _lfValue2$197760[ebp]
  0032f	51		 push	 ecx
  00330	8b 55 ec	 mov	 edx, DWORD PTR _lfValue1$197759[ebp]
  00333	52		 push	 edx
  00334	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00337	e8 00 00 00 00	 call	 ?HuetoRGB@CBitMapOperate@@QAEMMMM@Z ; CBitMapOperate::HuetoRGB
  0033c	d9 5d f4	 fstp	 DWORD PTR _lfRed$[ebp]

; 231  : 		lfGreen = HuetoRGB(lfValue1, lfValue2, afHue);

  0033f	8b 45 0c	 mov	 eax, DWORD PTR _afHue$[ebp]
  00342	50		 push	 eax
  00343	8b 4d f0	 mov	 ecx, DWORD PTR _lfValue2$197760[ebp]
  00346	51		 push	 ecx
  00347	8b 55 ec	 mov	 edx, DWORD PTR _lfValue1$197759[ebp]
  0034a	52		 push	 edx
  0034b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0034e	e8 00 00 00 00	 call	 ?HuetoRGB@CBitMapOperate@@QAEMMMM@Z ; CBitMapOperate::HuetoRGB
  00353	d9 5d f8	 fstp	 DWORD PTR _lfGreen$[ebp]

; 232  : 		lfBlue = HuetoRGB(lfValue1, lfValue2, afHue - 120.0f);

  00356	d9 45 0c	 fld	 DWORD PTR _afHue$[ebp]
  00359	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@42f00000
  0035f	51		 push	 ecx
  00360	d9 1c 24	 fstp	 DWORD PTR [esp]
  00363	8b 45 f0	 mov	 eax, DWORD PTR _lfValue2$197760[ebp]
  00366	50		 push	 eax
  00367	8b 4d ec	 mov	 ecx, DWORD PTR _lfValue1$197759[ebp]
  0036a	51		 push	 ecx
  0036b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0036e	e8 00 00 00 00	 call	 ?HuetoRGB@CBitMapOperate@@QAEMMMM@Z ; CBitMapOperate::HuetoRGB
  00373	d9 5d fc	 fstp	 DWORD PTR _lfBlue$[ebp]
$L197758:

; 233  : 	}
; 234  : 
; 235  : 	aSourceColor = RGB(lfRed, lfGreen, lfBlue);

  00376	d9 45 f4	 fld	 DWORD PTR _lfRed$[ebp]
  00379	e8 00 00 00 00	 call	 __ftol2
  0037e	0f b6 f0	 movzx	 esi, al
  00381	d9 45 f8	 fld	 DWORD PTR _lfGreen$[ebp]
  00384	e8 00 00 00 00	 call	 __ftol2
  00389	0f b6 d0	 movzx	 edx, al
  0038c	c1 e2 08	 shl	 edx, 8
  0038f	0b f2		 or	 esi, edx
  00391	d9 45 fc	 fld	 DWORD PTR _lfBlue$[ebp]
  00394	e8 00 00 00 00	 call	 __ftol2
  00399	0f b6 c0	 movzx	 eax, al
  0039c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0039f	0b f0		 or	 esi, eax
  003a1	8b 4d 08	 mov	 ecx, DWORD PTR _aSourceColor$[ebp]
  003a4	89 31		 mov	 DWORD PTR [ecx], esi

; 236  : }

  003a6	5e		 pop	 esi
  003a7	8b e5		 mov	 esp, ebp
  003a9	5d		 pop	 ebp
  003aa	c2 10 00	 ret	 16			; 00000010H
?SetRGB@CBitMapOperate@@QAEXAAKMMM@Z ENDP		; CBitMapOperate::SetRGB
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@3fc555555c7dda4b
PUBLIC	__real@4018000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe55555571f7693
PUBLIC	__real@3ff0000000000000
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3fc555555c7dda4b
CONST	SEGMENT
__real@3fc555555c7dda4b DQ 03fc555555c7dda4br	; 0.166667
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fe55555571f7693
CONST	SEGMENT
__real@3fe55555571f7693 DQ 03fe55555571f7693r	; 0.666667
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?HuetoRGB@CBitMapOperate@@QAEMMMM@Z
_TEXT	SEGMENT
tv155 = -12						; size = 4
tv146 = -8						; size = 4
_this$ = -4						; size = 4
_m1$ = 8						; size = 4
_m2$ = 12						; size = 4
_h$ = 16						; size = 4
?HuetoRGB@CBitMapOperate@@QAEMMMM@Z PROC NEAR		; CBitMapOperate::HuetoRGB, COMDAT
; _this$ = ecx

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 	if (h < 0)

  00009	d9 45 10	 fld	 DWORD PTR _h$[ebp]
  0000c	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00012	df e0		 fnstsw	 ax
  00014	f6 c4 05	 test	 ah, 5
  00017	7a 0e		 jp	 SHORT $L197708

; 158  : 		h += 1.0;

  00019	d9 45 10	 fld	 DWORD PTR _h$[ebp]
  0001c	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00022	d9 5d 10	 fstp	 DWORD PTR _h$[ebp]

; 159  : 	else if (h > 1)

  00025	eb 1c		 jmp	 SHORT $L197709
$L197708:
  00027	d9 45 10	 fld	 DWORD PTR _h$[ebp]
  0002a	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f800000
  00030	df e0		 fnstsw	 ax
  00032	f6 c4 41	 test	 ah, 65			; 00000041H
  00035	75 0c		 jne	 SHORT $L197709

; 160  : 		h -= 1.0;

  00037	d9 45 10	 fld	 DWORD PTR _h$[ebp]
  0003a	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  00040	d9 5d 10	 fstp	 DWORD PTR _h$[ebp]
$L197709:

; 161  : 	if (h < 0.16666667)

  00043	d9 45 10	 fld	 DWORD PTR _h$[ebp]
  00046	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3fc555555c7dda4b
  0004c	df e0		 fnstsw	 ax
  0004e	f6 c4 05	 test	 ah, 5
  00051	7a 19		 jp	 SHORT $L197711

; 162  : 		return (m1+(m2-m1)*h*6.0);

  00053	d9 45 08	 fld	 DWORD PTR _m1$[ebp]
  00056	d9 45 0c	 fld	 DWORD PTR _m2$[ebp]
  00059	d8 65 08	 fsub	 DWORD PTR _m1$[ebp]
  0005c	d8 4d 10	 fmul	 DWORD PTR _h$[ebp]
  0005f	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4018000000000000
  00065	de c1		 faddp	 ST(1), ST(0)
  00067	d9 55 f8	 fst	 DWORD PTR tv146[ebp]
  0006a	eb 49		 jmp	 SHORT $L197707
$L197711:

; 163  : 	if (h < 0.5)

  0006c	d9 45 10	 fld	 DWORD PTR _h$[ebp]
  0006f	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3fe0000000000000
  00075	df e0		 fnstsw	 ax
  00077	f6 c4 05	 test	 ah, 5
  0007a	7a 05		 jp	 SHORT $L197712

; 164  : 		return m2;

  0007c	d9 45 0c	 fld	 DWORD PTR _m2$[ebp]
  0007f	eb 34		 jmp	 SHORT $L197707
$L197712:

; 165  : 	if (h < 0.66666667)

  00081	d9 45 10	 fld	 DWORD PTR _h$[ebp]
  00084	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3fe55555571f7693
  0008a	df e0		 fnstsw	 ax
  0008c	f6 c4 05	 test	 ah, 5
  0008f	7a 21		 jp	 SHORT $L197713

; 166  : 		return (m1+(m2-m1)*(0.66666667-h)*6.0);

  00091	d9 45 08	 fld	 DWORD PTR _m1$[ebp]
  00094	d9 45 0c	 fld	 DWORD PTR _m2$[ebp]
  00097	d8 65 08	 fsub	 DWORD PTR _m1$[ebp]
  0009a	d9 45 10	 fld	 DWORD PTR _h$[ebp]
  0009d	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR __real@3fe55555571f7693
  000a3	de c9		 fmulp	 ST(1), ST(0)
  000a5	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4018000000000000
  000ab	de c1		 faddp	 ST(1), ST(0)
  000ad	d9 55 f4	 fst	 DWORD PTR tv155[ebp]
  000b0	eb 03		 jmp	 SHORT $L197707
$L197713:

; 167  : 	return m1;

  000b2	d9 45 08	 fld	 DWORD PTR _m1$[ebp]
$L197707:

; 168  : }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH
?HuetoRGB@CBitMapOperate@@QAEMMMM@Z ENDP		; CBitMapOperate::HuetoRGB
_TEXT	ENDS
PUBLIC	__real@405e000000000000
PUBLIC	?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z		; CBitMapOperate::RGBtoHSL
PUBLIC	?HLStoRGB@CBitMapOperate@@QAEKABN00@Z		; CBitMapOperate::HLStoRGB
PUBLIC	?ChangeBmpSkin@CBitMapOperate@@QAEPAUHBITMAP__@@AAPAU2@AAIAAK21@Z ; CBitMapOperate::ChangeBmpSkin
EXTRN	__imp__SelectObject@8:NEAR
EXTRN	__imp__BitBlt@36:NEAR
EXTRN	__imp__CreateCompatibleDC@4:NEAR
EXTRN	__imp__DeleteDC@4:NEAR
EXTRN	__imp__CreateDIBSection@24:NEAR
EXTRN	__imp__ColorRGBToHLS@16:NEAR
EXTRN	__imp__ColorHLSToRGB@12:NEAR
EXTRN	__imp__GetObjectA@12:NEAR
EXTRN	_abs:NEAR
;	COMDAT __real@405e000000000000
CONST	SEGMENT
__real@405e000000000000 DQ 0405e000000000000r	; 120
; Function compile flags: /Odt
CONST	ENDS
_TEXT	SEGMENT
tv352 = -240						; size = 4
tv345 = -236						; size = 8
tv224 = -228						; size = 8
_this$ = -220						; size = 4
_wL1$197843 = -216					; size = 2
_wS2$197848 = -212					; size = 2
_lH$197819 = -208					; size = 8
_c$197842 = -200					; size = 4
_wH1$197844 = -196					; size = 2
_wH2$197847 = -192					; size = 2
_wL2$197846 = -188					; size = 2
_lB$197818 = -184					; size = 4
_lR$197816 = -180					; size = 4
_lL$197821 = -176					; size = 8
_lAdjuest$197832 = -168					; size = 8
_wS1$197845 = -160					; size = 2
_lG$197817 = -156					; size = 4
_lS$197820 = -152					; size = 8
_i$197811 = -140					; size = 4
_lS2$197799 = -136					; size = 8
_lR2$197795 = -128					; size = 4
_lSourceObject$197793 = -124				; size = 4
_lL2$197800 = -120					; size = 8
_lG2$197796 = -108					; size = 4
_lH2$197798 = -104					; size = 8
_lB2$197797 = -96					; size = 4
_lDirectBitmap$197789 = -92				; size = 4
_lptPixels$197788 = -88					; size = 4
_lbMap$197784 = -84					; size = 24
_RGB24Bit$197785 = -60					; size = 44
_lDirectDC$197782 = -16					; size = 4
_lSourceBufferObject$197781 = -12			; size = 4
_lBufferDC$197779 = -8					; size = 4
_lhNewBmp$ = -4						; size = 4
_ahSourceBmp$ = 8					; size = 4
_aColorGroup$ = 12					; size = 4
_aBaseColor$ = 16					; size = 4
_aMaskColor$ = 20					; size = 4
_aiLightPos$ = 24					; size = 4
?ChangeBmpSkin@CBitMapOperate@@QAEPAUHBITMAP__@@AAPAU2@AAIAAK21@Z PROC NEAR ; CBitMapOperate::ChangeBmpSkin
; _this$ = ecx

; 238  : {

  003b0	55		 push	 ebp
  003b1	8b ec		 mov	 ebp, esp
  003b3	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  003b9	56		 push	 esi
  003ba	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 	HBITMAP lhNewBmp=NULL;

  003c0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lhNewBmp$[ebp], 0

; 240  : 	if (ahSourceBmp)

  003c7	8b 45 08	 mov	 eax, DWORD PTR _ahSourceBmp$[ebp]
  003ca	83 38 00	 cmp	 DWORD PTR [eax], 0
  003cd	0f 84 f8 03 00
	00		 je	 $L197778

; 241  : 	{	
; 242  : 		HDC lBufferDC=CreateCompatibleDC(NULL);	

  003d3	6a 00		 push	 0
  003d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  003db	89 45 f8	 mov	 DWORD PTR _lBufferDC$197779[ebp], eax

; 243  : 		if (lBufferDC)

  003de	83 7d f8 00	 cmp	 DWORD PTR _lBufferDC$197779[ebp], 0
  003e2	0f 84 e3 03 00
	00		 je	 $L197778

; 244  : 		{
; 245  : 			HGDIOBJ lSourceBufferObject = SelectObject(lBufferDC,ahSourceBmp);	

  003e8	8b 4d 08	 mov	 ecx, DWORD PTR _ahSourceBmp$[ebp]
  003eb	8b 11		 mov	 edx, DWORD PTR [ecx]
  003ed	52		 push	 edx
  003ee	8b 45 f8	 mov	 eax, DWORD PTR _lBufferDC$197779[ebp]
  003f1	50		 push	 eax
  003f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  003f8	89 45 f4	 mov	 DWORD PTR _lSourceBufferObject$197781[ebp], eax

; 246  : 			HDC lDirectDC=CreateCompatibleDC(NULL);

  003fb	6a 00		 push	 0
  003fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  00403	89 45 f0	 mov	 DWORD PTR _lDirectDC$197782[ebp], eax

; 247  : 			if (lDirectDC)

  00406	83 7d f0 00	 cmp	 DWORD PTR _lDirectDC$197782[ebp], 0
  0040a	0f 84 a3 03 00
	00		 je	 $L197783

; 248  : 			{
; 249  : 				BITMAP lbMap;
; 250  : 				GetObject(ahSourceBmp, sizeof(lbMap), &lbMap);

  00410	8d 4d ac	 lea	 ecx, DWORD PTR _lbMap$197784[ebp]
  00413	51		 push	 ecx
  00414	6a 18		 push	 24			; 00000018H
  00416	8b 55 08	 mov	 edx, DWORD PTR _ahSourceBmp$[ebp]
  00419	8b 02		 mov	 eax, DWORD PTR [edx]
  0041b	50		 push	 eax
  0041c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetObjectA@12

; 251  : 				BITMAPINFO RGB24Bit; 
; 252  : 				ZeroMemory(&RGB24Bit,sizeof(BITMAPINFO));

  00422	6a 2c		 push	 44			; 0000002cH
  00424	6a 00		 push	 0
  00426	8d 4d c4	 lea	 ecx, DWORD PTR _RGB24Bit$197785[ebp]
  00429	51		 push	 ecx
  0042a	e8 00 00 00 00	 call	 _memset
  0042f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 253  : 				RGB24Bit.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);

  00432	c7 45 c4 28 00
	00 00		 mov	 DWORD PTR _RGB24Bit$197785[ebp], 40 ; 00000028H

; 254  : 				RGB24Bit.bmiHeader.biWidth=lbMap.bmWidth;

  00439	8b 55 b0	 mov	 edx, DWORD PTR _lbMap$197784[ebp+4]
  0043c	89 55 c8	 mov	 DWORD PTR _RGB24Bit$197785[ebp+4], edx

; 255  : 				RGB24Bit.bmiHeader.biHeight=lbMap.bmHeight;

  0043f	8b 45 b4	 mov	 eax, DWORD PTR _lbMap$197784[ebp+8]
  00442	89 45 cc	 mov	 DWORD PTR _RGB24Bit$197785[ebp+8], eax

; 256  : 				RGB24Bit.bmiHeader.biPlanes=1;

  00445	66 c7 45 d0 01
	00		 mov	 WORD PTR _RGB24Bit$197785[ebp+12], 1

; 257  : 				RGB24Bit.bmiHeader.biBitCount=32;

  0044b	66 c7 45 d2 20
	00		 mov	 WORD PTR _RGB24Bit$197785[ebp+14], 32 ; 00000020H

; 258  : 				UINT * lptPixels;
; 259  : 				HBITMAP lDirectBitmap= CreateDIBSection(lDirectDC, (BITMAPINFO *)&RGB24Bit, DIB_RGB_COLORS,(void **)&lptPixels, NULL, 0);

  00451	6a 00		 push	 0
  00453	6a 00		 push	 0
  00455	8d 4d a8	 lea	 ecx, DWORD PTR _lptPixels$197788[ebp]
  00458	51		 push	 ecx
  00459	6a 00		 push	 0
  0045b	8d 55 c4	 lea	 edx, DWORD PTR _RGB24Bit$197785[ebp]
  0045e	52		 push	 edx
  0045f	8b 45 f0	 mov	 eax, DWORD PTR _lDirectDC$197782[ebp]
  00462	50		 push	 eax
  00463	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBSection@24
  00469	89 45 a4	 mov	 DWORD PTR _lDirectBitmap$197789[ebp], eax

; 260  : 				if (lDirectBitmap)

  0046c	83 7d a4 00	 cmp	 DWORD PTR _lDirectBitmap$197789[ebp], 0
  00470	0f 84 33 03 00
	00		 je	 $L197792

; 261  : 				{
; 262  : 					HGDIOBJ lSourceObject=SelectObject(lDirectDC, lDirectBitmap);

  00476	8b 4d a4	 mov	 ecx, DWORD PTR _lDirectBitmap$197789[ebp]
  00479	51		 push	 ecx
  0047a	8b 55 f0	 mov	 edx, DWORD PTR _lDirectDC$197782[ebp]
  0047d	52		 push	 edx
  0047e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  00484	89 45 84	 mov	 DWORD PTR _lSourceObject$197793[ebp], eax

; 263  : 					BitBlt(lDirectDC,0,0,lbMap.bmWidth,lbMap.bmHeight,lBufferDC,0,0,SRCCOPY);	

  00487	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  0048c	6a 00		 push	 0
  0048e	6a 00		 push	 0
  00490	8b 45 f8	 mov	 eax, DWORD PTR _lBufferDC$197779[ebp]
  00493	50		 push	 eax
  00494	8b 4d b4	 mov	 ecx, DWORD PTR _lbMap$197784[ebp+8]
  00497	51		 push	 ecx
  00498	8b 55 b0	 mov	 edx, DWORD PTR _lbMap$197784[ebp+4]
  0049b	52		 push	 edx
  0049c	6a 00		 push	 0
  0049e	6a 00		 push	 0
  004a0	8b 45 f0	 mov	 eax, DWORD PTR _lDirectDC$197782[ebp]
  004a3	50		 push	 eax
  004a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 264  : 
; 265  : 					int lR2,lG2,lB2;
; 266  : 					double  lH2,lS2,lL2;
; 267  : 					lR2 = GetRValue(aBaseColor);

  004aa	8b 4d 10	 mov	 ecx, DWORD PTR _aBaseColor$[ebp]
  004ad	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  004b0	89 55 80	 mov	 DWORD PTR _lR2$197795[ebp], edx

; 268  : 					lG2 = GetGValue(aBaseColor);

  004b3	8b 45 10	 mov	 eax, DWORD PTR _aBaseColor$[ebp]
  004b6	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  004b9	c1 f9 08	 sar	 ecx, 8
  004bc	0f b6 d1	 movzx	 edx, cl
  004bf	89 55 94	 mov	 DWORD PTR _lG2$197796[ebp], edx

; 269  : 					lB2 = GetBValue(aBaseColor);

  004c2	8b 45 10	 mov	 eax, DWORD PTR _aBaseColor$[ebp]
  004c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  004c7	c1 e9 10	 shr	 ecx, 16			; 00000010H
  004ca	0f b6 d1	 movzx	 edx, cl
  004cd	89 55 a0	 mov	 DWORD PTR _lB2$197797[ebp], edx

; 270  : 					RGBtoHSL(RGB(lR2,lG2,lB2),&lH2,&lS2,&lL2);

  004d0	8d 45 88	 lea	 eax, DWORD PTR _lL2$197800[ebp]
  004d3	50		 push	 eax
  004d4	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _lS2$197799[ebp]
  004da	51		 push	 ecx
  004db	8d 55 98	 lea	 edx, DWORD PTR _lH2$197798[ebp]
  004de	52		 push	 edx
  004df	0f b6 45 80	 movzx	 eax, BYTE PTR _lR2$197795[ebp]
  004e3	0f b6 4d 94	 movzx	 ecx, BYTE PTR _lG2$197796[ebp]
  004e7	c1 e1 08	 shl	 ecx, 8
  004ea	0b c1		 or	 eax, ecx
  004ec	0f b6 55 a0	 movzx	 edx, BYTE PTR _lB2$197797[ebp]
  004f0	c1 e2 10	 shl	 edx, 16			; 00000010H
  004f3	0b c2		 or	 eax, edx
  004f5	50		 push	 eax
  004f6	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004fc	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ; CBitMapOperate::RGBtoHSL

; 271  : 
; 272  : 					for (int i=((lbMap.bmWidth*lbMap.bmHeight)-1 );i>0;i--)

  00501	8b 45 b0	 mov	 eax, DWORD PTR _lbMap$197784[ebp+4]
  00504	0f af 45 b4	 imul	 eax, DWORD PTR _lbMap$197784[ebp+8]
  00508	83 e8 01	 sub	 eax, 1
  0050b	89 85 74 ff ff
	ff		 mov	 DWORD PTR _i$197811[ebp], eax
  00511	eb 0f		 jmp	 SHORT $L197812
$L197813:
  00513	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _i$197811[ebp]
  00519	83 e9 01	 sub	 ecx, 1
  0051c	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _i$197811[ebp], ecx
$L197812:
  00522	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _i$197811[ebp], 0
  00529	0f 8e 66 02 00
	00		 jle	 $L197814

; 273  : 					{
; 274  : 						if(  lptPixels[i] != aMaskColor ) 

  0052f	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _i$197811[ebp]
  00535	8b 45 a8	 mov	 eax, DWORD PTR _lptPixels$197788[ebp]
  00538	8b 4d 14	 mov	 ecx, DWORD PTR _aMaskColor$[ebp]
  0053b	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  0053e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00540	0f 84 4a 02 00
	00		 je	 $L197815

; 275  : 						{
; 276  : 							int    lR,lG,lB;
; 277  : 							double lH,lS,lL;
; 278  : 							lR =  GetBValue(lptPixels[i]);

  00546	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _i$197811[ebp]
  0054c	8b 4d a8	 mov	 ecx, DWORD PTR _lptPixels$197788[ebp]
  0054f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00552	c1 ea 10	 shr	 edx, 16			; 00000010H
  00555	0f b6 c2	 movzx	 eax, dl
  00558	89 85 4c ff ff
	ff		 mov	 DWORD PTR _lR$197816[ebp], eax

; 279  : 							lG =  GetGValue(lptPixels[i]);

  0055e	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _i$197811[ebp]
  00564	8b 55 a8	 mov	 edx, DWORD PTR _lptPixels$197788[ebp]
  00567	0f b7 04 8a	 movzx	 eax, WORD PTR [edx+ecx*4]
  0056b	c1 f8 08	 sar	 eax, 8
  0056e	0f b6 c8	 movzx	 ecx, al
  00571	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _lG$197817[ebp], ecx

; 280  : 							lB =  GetRValue(lptPixels[i]);

  00577	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _i$197811[ebp]
  0057d	8b 45 a8	 mov	 eax, DWORD PTR _lptPixels$197788[ebp]
  00580	0f b6 0c 90	 movzx	 ecx, BYTE PTR [eax+edx*4]
  00584	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _lB$197818[ebp], ecx

; 281  : 
; 282  : 							RGBtoHSL(RGB(lR,lG,lB),&lH,&lS,&lL);

  0058a	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR _lL$197821[ebp]
  00590	52		 push	 edx
  00591	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _lS$197820[ebp]
  00597	50		 push	 eax
  00598	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _lH$197819[ebp]
  0059e	51		 push	 ecx
  0059f	0f b6 95 4c ff
	ff ff		 movzx	 edx, BYTE PTR _lR$197816[ebp]
  005a6	0f b6 85 64 ff
	ff ff		 movzx	 eax, BYTE PTR _lG$197817[ebp]
  005ad	c1 e0 08	 shl	 eax, 8
  005b0	0b d0		 or	 edx, eax
  005b2	0f b6 8d 48 ff
	ff ff		 movzx	 ecx, BYTE PTR _lB$197818[ebp]
  005b9	c1 e1 10	 shl	 ecx, 16			; 00000010H
  005bc	0b d1		 or	 edx, ecx
  005be	52		 push	 edx
  005bf	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005c5	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ; CBitMapOperate::RGBtoHSL

; 283  : 							double lAdjuest = min( (double)(1.0 - lL), lL ); 

  005ca	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3ff0000000000000
  005d0	dc a5 50 ff ff
	ff		 fsub	 QWORD PTR _lL$197821[ebp]
  005d6	dc 9d 50 ff ff
	ff		 fcomp	 QWORD PTR _lL$197821[ebp]
  005dc	df e0		 fnstsw	 ax
  005de	f6 c4 05	 test	 ah, 5
  005e1	7a 14		 jp	 SHORT $L199692
  005e3	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3ff0000000000000
  005e9	dc a5 50 ff ff
	ff		 fsub	 QWORD PTR _lL$197821[ebp]
  005ef	dd 9d 1c ff ff
	ff		 fstp	 QWORD PTR tv224[ebp]
  005f5	eb 0c		 jmp	 SHORT $L199693
$L199692:
  005f7	dd 85 50 ff ff
	ff		 fld	 QWORD PTR _lL$197821[ebp]
  005fd	dd 9d 1c ff ff
	ff		 fstp	 QWORD PTR tv224[ebp]
$L199693:
  00603	dd 85 1c ff ff
	ff		 fld	 QWORD PTR tv224[ebp]
  00609	dd 9d 58 ff ff
	ff		 fstp	 QWORD PTR _lAdjuest$197832[ebp]

; 284  : 							if( aiLightPos>120 )

  0060f	8b 55 18	 mov	 edx, DWORD PTR _aiLightPos$[ebp]
  00612	83 3a 78	 cmp	 DWORD PTR [edx], 120	; 00000078H
  00615	76 44		 jbe	 SHORT $L197835

; 285  : 							{
; 286  : 								lAdjuest = ( ((double)(aiLightPos-120) )/ (double)120 ) * lAdjuest;

  00617	8b 45 18	 mov	 eax, DWORD PTR _aiLightPos$[ebp]
  0061a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0061c	83 e9 78	 sub	 ecx, 120		; 00000078H
  0061f	89 8d 14 ff ff
	ff		 mov	 DWORD PTR tv345[ebp], ecx
  00625	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv345[ebp+4], 0
  0062f	df ad 14 ff ff
	ff		 fild	 QWORD PTR tv345[ebp]
  00635	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@405e000000000000
  0063b	dc 8d 58 ff ff
	ff		 fmul	 QWORD PTR _lAdjuest$197832[ebp]
  00641	dd 9d 58 ff ff
	ff		 fstp	 QWORD PTR _lAdjuest$197832[ebp]

; 287  : 								lL += lAdjuest;

  00647	dd 85 50 ff ff
	ff		 fld	 QWORD PTR _lL$197821[ebp]
  0064d	dc 85 58 ff ff
	ff		 fadd	 QWORD PTR _lAdjuest$197832[ebp]
  00653	dd 9d 50 ff ff
	ff		 fstp	 QWORD PTR _lL$197821[ebp]

; 288  : 							}
; 289  : 							else

  00659	eb 49		 jmp	 SHORT $L197838
$L197835:

; 290  : 							{
; 291  : 								if( aiLightPos<120)

  0065b	8b 55 18	 mov	 edx, DWORD PTR _aiLightPos$[ebp]
  0065e	83 3a 78	 cmp	 DWORD PTR [edx], 120	; 00000078H
  00661	73 41		 jae	 SHORT $L197838

; 292  : 								{
; 293  : 									lAdjuest = ( ((double)(abs(int(aiLightPos-120) )) )/ (double)120 ) * lAdjuest;

  00663	8b 45 18	 mov	 eax, DWORD PTR _aiLightPos$[ebp]
  00666	8b 08		 mov	 ecx, DWORD PTR [eax]
  00668	83 e9 78	 sub	 ecx, 120		; 00000078H
  0066b	51		 push	 ecx
  0066c	e8 00 00 00 00	 call	 _abs
  00671	83 c4 04	 add	 esp, 4
  00674	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv352[ebp], eax
  0067a	db 85 10 ff ff
	ff		 fild	 DWORD PTR tv352[ebp]
  00680	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@405e000000000000
  00686	dc 8d 58 ff ff
	ff		 fmul	 QWORD PTR _lAdjuest$197832[ebp]
  0068c	dd 9d 58 ff ff
	ff		 fstp	 QWORD PTR _lAdjuest$197832[ebp]

; 294  : 									lL -= lAdjuest;

  00692	dd 85 50 ff ff
	ff		 fld	 QWORD PTR _lL$197821[ebp]
  00698	dc a5 58 ff ff
	ff		 fsub	 QWORD PTR _lAdjuest$197832[ebp]
  0069e	dd 9d 50 ff ff
	ff		 fstp	 QWORD PTR _lL$197821[ebp]
$L197838:

; 295  : 								}
; 296  : 							}
; 297  : 							/*int lgroup;
; 298  : 							if( lH!= 0)
; 299  : 							{
; 300  : 							lgroup = ( lH/0.125 + 1 );
; 301  : 							}
; 302  : 							else
; 303  : 							{
; 304  : 							lgroup = 1; 
; 305  : 							}*/
; 306  : 							COLORREF c   = COLORREF2RGB( HLStoRGB(lH2,lL,lS ) );

  006a4	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _lS$197820[ebp]
  006aa	52		 push	 edx
  006ab	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _lL$197821[ebp]
  006b1	50		 push	 eax
  006b2	8d 4d 98	 lea	 ecx, DWORD PTR _lH2$197798[ebp]
  006b5	51		 push	 ecx
  006b6	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006bc	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z ; CBitMapOperate::HLStoRGB
  006c1	8b f0		 mov	 esi, eax
  006c3	81 e6 00 ff 00
	00		 and	 esi, 65280		; 0000ff00H
  006c9	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _lS$197820[ebp]
  006cf	52		 push	 edx
  006d0	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _lL$197821[ebp]
  006d6	50		 push	 eax
  006d7	8d 4d 98	 lea	 ecx, DWORD PTR _lH2$197798[ebp]
  006da	51		 push	 ecx
  006db	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006e1	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z ; CBitMapOperate::HLStoRGB
  006e6	c1 e8 10	 shr	 eax, 16			; 00000010H
  006e9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006ee	0b f0		 or	 esi, eax
  006f0	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _lS$197820[ebp]
  006f6	52		 push	 edx
  006f7	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _lL$197821[ebp]
  006fd	50		 push	 eax
  006fe	8d 4d 98	 lea	 ecx, DWORD PTR _lH2$197798[ebp]
  00701	51		 push	 ecx
  00702	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00708	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z ; CBitMapOperate::HLStoRGB
  0070d	c1 e0 10	 shl	 eax, 16			; 00000010H
  00710	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00715	0b f0		 or	 esi, eax
  00717	89 b5 38 ff ff
	ff		 mov	 DWORD PTR _c$197842[ebp], esi

; 307  : //							lptPixels[i] = c;
; 308  : 
; 309  : //							int lR3 = GetRValue(aColor);
; 310  : //							int lG3 = GetGValue(aColor);
; 311  : //							int lB3 = GetBValue(aColor);
; 312  : 
; 313  : 							WORD wL1,wH1,wS1,wL2,wH2,wS2;
; 314  : 							ColorRGBToHLS(lptPixels[i],&wH1,&wL1,&wS1);

  0071d	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _wS1$197845[ebp]
  00723	52		 push	 edx
  00724	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _wL1$197843[ebp]
  0072a	50		 push	 eax
  0072b	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _wH1$197844[ebp]
  00731	51		 push	 ecx
  00732	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _i$197811[ebp]
  00738	8b 45 a8	 mov	 eax, DWORD PTR _lptPixels$197788[ebp]
  0073b	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0073e	51		 push	 ecx
  0073f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ColorRGBToHLS@16

; 315  : 							ColorRGBToHLS(aBaseColor,&wH2,&wL2,&wS2);

  00745	8d 95 2c ff ff
	ff		 lea	 edx, DWORD PTR _wS2$197848[ebp]
  0074b	52		 push	 edx
  0074c	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _wL2$197846[ebp]
  00752	50		 push	 eax
  00753	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _wH2$197847[ebp]
  00759	51		 push	 ecx
  0075a	8b 55 10	 mov	 edx, DWORD PTR _aBaseColor$[ebp]
  0075d	8b 02		 mov	 eax, DWORD PTR [edx]
  0075f	50		 push	 eax
  00760	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ColorRGBToHLS@16

; 316  : 
; 317  : 							lptPixels[i] = ColorHLSToRGB(wH2,wL1,wS1);							

  00766	66 8b 8d 60 ff
	ff ff		 mov	 cx, WORD PTR _wS1$197845[ebp]
  0076d	51		 push	 ecx
  0076e	66 8b 95 28 ff
	ff ff		 mov	 dx, WORD PTR _wL1$197843[ebp]
  00775	52		 push	 edx
  00776	66 8b 85 40 ff
	ff ff		 mov	 ax, WORD PTR _wH2$197847[ebp]
  0077d	50		 push	 eax
  0077e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ColorHLSToRGB@12
  00784	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _i$197811[ebp]
  0078a	8b 55 a8	 mov	 edx, DWORD PTR _lptPixels$197788[ebp]
  0078d	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$L197815:

; 318  : 
; 319  : 							//}
; 320  : 							/*	else
; 321  : 							{
; 322  : 							lptPixels[i] = COLORREF2RGB( HLStoRGB(lH,lL,lS2) );
; 323  : 							}*/
; 324  : 						}
; 325  : 					}

  00790	e9 7e fd ff ff	 jmp	 $L197813
$L197814:

; 326  : 					SelectObject(lDirectDC,lSourceObject);

  00795	8b 45 84	 mov	 eax, DWORD PTR _lSourceObject$197793[ebp]
  00798	50		 push	 eax
  00799	8b 4d f0	 mov	 ecx, DWORD PTR _lDirectDC$197782[ebp]
  0079c	51		 push	 ecx
  0079d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 327  : 					lhNewBmp=lDirectBitmap;

  007a3	8b 55 a4	 mov	 edx, DWORD PTR _lDirectBitmap$197789[ebp]
  007a6	89 55 fc	 mov	 DWORD PTR _lhNewBmp$[ebp], edx
$L197792:

; 328  : 				}
; 329  : 				DeleteDC(lDirectDC);

  007a9	8b 45 f0	 mov	 eax, DWORD PTR _lDirectDC$197782[ebp]
  007ac	50		 push	 eax
  007ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$L197783:

; 330  : 			}			
; 331  : 			SelectObject(lBufferDC,lSourceBufferObject);

  007b3	8b 4d f4	 mov	 ecx, DWORD PTR _lSourceBufferObject$197781[ebp]
  007b6	51		 push	 ecx
  007b7	8b 55 f8	 mov	 edx, DWORD PTR _lBufferDC$197779[ebp]
  007ba	52		 push	 edx
  007bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 332  : 			DeleteDC(lBufferDC);

  007c1	8b 45 f8	 mov	 eax, DWORD PTR _lBufferDC$197779[ebp]
  007c4	50		 push	 eax
  007c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$L197778:

; 333  : 		}
; 334  : 	}
; 335  : 	return lhNewBmp;

  007cb	8b 45 fc	 mov	 eax, DWORD PTR _lhNewBmp$[ebp]

; 336  : }

  007ce	5e		 pop	 esi
  007cf	8b e5		 mov	 esp, ebp
  007d1	5d		 pop	 ebp
  007d2	c2 14 00	 ret	 20			; 00000014H
?ChangeBmpSkin@CBitMapOperate@@QAEPAUHBITMAP__@@AAPAU2@AAIAAK21@Z ENDP ; CBitMapOperate::ChangeBmpSkin
_TEXT	ENDS
PUBLIC	__real@406fe00000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@4010000000000000
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z
_TEXT	SEGMENT
tv88 = -112						; size = 8
tv89 = -104						; size = 8
tv85 = -96						; size = 8
tv82 = -88						; size = 8
tv83 = -80						; size = 8
tv79 = -72						; size = 8
tv158 = -64						; size = 4
tv156 = -60						; size = 4
tv155 = -56						; size = 4
_this$ = -52						; size = 4
_delta$ = -48						; size = 8
_r$ = -40						; size = 8
_g$ = -32						; size = 8
_b$ = -24						; size = 8
_cmax$ = -16						; size = 8
_cmin$ = -8						; size = 8
_rgb$ = 8						; size = 4
_H$ = 12						; size = 4
_S$ = 16						; size = 4
_L$ = 20						; size = 4
?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z PROC NEAR	; CBitMapOperate::RGBtoHSL, COMDAT
; _this$ = ecx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 	double delta;
; 75   : 	double r = (double)GetRValue(rgb)/255;

  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _rgb$[ebp]
  0000d	89 45 c8	 mov	 DWORD PTR tv155[ebp], eax
  00010	db 45 c8	 fild	 DWORD PTR tv155[ebp]
  00013	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@406fe00000000000
  00019	dd 5d d8	 fstp	 QWORD PTR _r$[ebp]

; 76   : 	double g = (double)GetGValue(rgb)/255;

  0001c	0f b7 4d 08	 movzx	 ecx, WORD PTR _rgb$[ebp]
  00020	c1 f9 08	 sar	 ecx, 8
  00023	0f b6 d1	 movzx	 edx, cl
  00026	89 55 c4	 mov	 DWORD PTR tv156[ebp], edx
  00029	db 45 c4	 fild	 DWORD PTR tv156[ebp]
  0002c	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@406fe00000000000
  00032	dd 5d e0	 fstp	 QWORD PTR _g$[ebp]

; 77   : 	double b = (double)GetBValue(rgb)/255;

  00035	8b 45 08	 mov	 eax, DWORD PTR _rgb$[ebp]
  00038	c1 e8 10	 shr	 eax, 16			; 00000010H
  0003b	0f b6 c8	 movzx	 ecx, al
  0003e	89 4d c0	 mov	 DWORD PTR tv158[ebp], ecx
  00041	db 45 c0	 fild	 DWORD PTR tv158[ebp]
  00044	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@406fe00000000000
  0004a	dd 5d e8	 fstp	 QWORD PTR _b$[ebp]

; 78   : 	double cmax = max(r,max(g,b));

  0004d	dd 45 e0	 fld	 QWORD PTR _g$[ebp]
  00050	dc 5d e8	 fcomp	 QWORD PTR _b$[ebp]
  00053	df e0		 fnstsw	 ax
  00055	f6 c4 41	 test	 ah, 65			; 00000041H
  00058	75 08		 jne	 SHORT $L199697
  0005a	dd 45 e0	 fld	 QWORD PTR _g$[ebp]
  0005d	dd 5d b8	 fstp	 QWORD PTR tv79[ebp]
  00060	eb 06		 jmp	 SHORT $L199698
$L199697:
  00062	dd 45 e8	 fld	 QWORD PTR _b$[ebp]
  00065	dd 5d b8	 fstp	 QWORD PTR tv79[ebp]
$L199698:
  00068	dd 45 d8	 fld	 QWORD PTR _r$[ebp]
  0006b	dc 5d b8	 fcomp	 QWORD PTR tv79[ebp]
  0006e	df e0		 fnstsw	 ax
  00070	f6 c4 41	 test	 ah, 65			; 00000041H
  00073	75 08		 jne	 SHORT $L199701
  00075	dd 45 d8	 fld	 QWORD PTR _r$[ebp]
  00078	dd 5d b0	 fstp	 QWORD PTR tv83[ebp]
  0007b	eb 21		 jmp	 SHORT $L199702
$L199701:
  0007d	dd 45 e0	 fld	 QWORD PTR _g$[ebp]
  00080	dc 5d e8	 fcomp	 QWORD PTR _b$[ebp]
  00083	df e0		 fnstsw	 ax
  00085	f6 c4 41	 test	 ah, 65			; 00000041H
  00088	75 08		 jne	 SHORT $L199699
  0008a	dd 45 e0	 fld	 QWORD PTR _g$[ebp]
  0008d	dd 5d a8	 fstp	 QWORD PTR tv82[ebp]
  00090	eb 06		 jmp	 SHORT $L199700
$L199699:
  00092	dd 45 e8	 fld	 QWORD PTR _b$[ebp]
  00095	dd 5d a8	 fstp	 QWORD PTR tv82[ebp]
$L199700:
  00098	dd 45 a8	 fld	 QWORD PTR tv82[ebp]
  0009b	dd 5d b0	 fstp	 QWORD PTR tv83[ebp]
$L199702:
  0009e	dd 45 b0	 fld	 QWORD PTR tv83[ebp]
  000a1	dd 5d f0	 fstp	 QWORD PTR _cmax$[ebp]

; 79   : 	double cmin = min(r,min(g,b));

  000a4	dd 45 e0	 fld	 QWORD PTR _g$[ebp]
  000a7	dc 5d e8	 fcomp	 QWORD PTR _b$[ebp]
  000aa	df e0		 fnstsw	 ax
  000ac	f6 c4 05	 test	 ah, 5
  000af	7a 08		 jp	 SHORT $L199703
  000b1	dd 45 e0	 fld	 QWORD PTR _g$[ebp]
  000b4	dd 5d a0	 fstp	 QWORD PTR tv85[ebp]
  000b7	eb 06		 jmp	 SHORT $L199704
$L199703:
  000b9	dd 45 e8	 fld	 QWORD PTR _b$[ebp]
  000bc	dd 5d a0	 fstp	 QWORD PTR tv85[ebp]
$L199704:
  000bf	dd 45 d8	 fld	 QWORD PTR _r$[ebp]
  000c2	dc 5d a0	 fcomp	 QWORD PTR tv85[ebp]
  000c5	df e0		 fnstsw	 ax
  000c7	f6 c4 05	 test	 ah, 5
  000ca	7a 08		 jp	 SHORT $L199707
  000cc	dd 45 d8	 fld	 QWORD PTR _r$[ebp]
  000cf	dd 5d 98	 fstp	 QWORD PTR tv89[ebp]
  000d2	eb 21		 jmp	 SHORT $L199708
$L199707:
  000d4	dd 45 e0	 fld	 QWORD PTR _g$[ebp]
  000d7	dc 5d e8	 fcomp	 QWORD PTR _b$[ebp]
  000da	df e0		 fnstsw	 ax
  000dc	f6 c4 05	 test	 ah, 5
  000df	7a 08		 jp	 SHORT $L199705
  000e1	dd 45 e0	 fld	 QWORD PTR _g$[ebp]
  000e4	dd 5d 90	 fstp	 QWORD PTR tv88[ebp]
  000e7	eb 06		 jmp	 SHORT $L199706
$L199705:
  000e9	dd 45 e8	 fld	 QWORD PTR _b$[ebp]
  000ec	dd 5d 90	 fstp	 QWORD PTR tv88[ebp]
$L199706:
  000ef	dd 45 90	 fld	 QWORD PTR tv88[ebp]
  000f2	dd 5d 98	 fstp	 QWORD PTR tv89[ebp]
$L199708:
  000f5	dd 45 98	 fld	 QWORD PTR tv89[ebp]
  000f8	dd 5d f8	 fstp	 QWORD PTR _cmin$[ebp]

; 80   : 	*L = (cmax+cmin)/2.0;

  000fb	dd 45 f0	 fld	 QWORD PTR _cmax$[ebp]
  000fe	dc 45 f8	 fadd	 QWORD PTR _cmin$[ebp]
  00101	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4000000000000000
  00107	8b 55 14	 mov	 edx, DWORD PTR _L$[ebp]
  0010a	dd 1a		 fstp	 QWORD PTR [edx]

; 81   : 	if (cmax == cmin)

  0010c	dd 45 f8	 fld	 QWORD PTR _cmin$[ebp]
  0010f	dd 45 f0	 fld	 QWORD PTR _cmax$[ebp]
  00112	da e9		 fucompp
  00114	df e0		 fnstsw	 ax
  00116	f6 c4 44	 test	 ah, 68			; 00000044H
  00119	7a 1b		 jp	 SHORT $L197629

; 82   : 	{
; 83   : 		*S = 0;

  0011b	8b 45 10	 mov	 eax, DWORD PTR _S$[ebp]
  0011e	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  00124	dd 18		 fstp	 QWORD PTR [eax]

; 84   : 		*H = 0; // it's really undefined

  00126	8b 4d 0c	 mov	 ecx, DWORD PTR _H$[ebp]
  00129	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  0012f	dd 19		 fstp	 QWORD PTR [ecx]

; 85   : 	}
; 86   : 	else

  00131	e9 d3 00 00 00	 jmp	 $L197615
$L197629:

; 87   : 	{
; 88   : 		if (*L < 0.5)

  00136	8b 55 14	 mov	 edx, DWORD PTR _L$[ebp]
  00139	dd 02		 fld	 QWORD PTR [edx]
  0013b	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3fe0000000000000
  00141	df e0		 fnstsw	 ax
  00143	f6 c4 05	 test	 ah, 5
  00146	7a 15		 jp	 SHORT $L197631

; 89   : 			*S = (cmax-cmin)/(cmax+cmin);

  00148	dd 45 f0	 fld	 QWORD PTR _cmax$[ebp]
  0014b	dc 65 f8	 fsub	 QWORD PTR _cmin$[ebp]
  0014e	dd 45 f0	 fld	 QWORD PTR _cmax$[ebp]
  00151	dc 45 f8	 fadd	 QWORD PTR _cmin$[ebp]
  00154	de f9		 fdivp	 ST(1), ST(0)
  00156	8b 45 10	 mov	 eax, DWORD PTR _S$[ebp]
  00159	dd 18		 fstp	 QWORD PTR [eax]

; 90   : 		else

  0015b	eb 19		 jmp	 SHORT $L197632
$L197631:

; 91   : 			*S = (cmax-cmin)/(2.0-cmax-cmin);

  0015d	dd 45 f0	 fld	 QWORD PTR _cmax$[ebp]
  00160	dc 65 f8	 fsub	 QWORD PTR _cmin$[ebp]
  00163	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4000000000000000
  00169	dc 65 f0	 fsub	 QWORD PTR _cmax$[ebp]
  0016c	dc 65 f8	 fsub	 QWORD PTR _cmin$[ebp]
  0016f	de f9		 fdivp	 ST(1), ST(0)
  00171	8b 4d 10	 mov	 ecx, DWORD PTR _S$[ebp]
  00174	dd 19		 fstp	 QWORD PTR [ecx]
$L197632:

; 92   : 		delta = cmax - cmin;

  00176	dd 45 f0	 fld	 QWORD PTR _cmax$[ebp]
  00179	dc 65 f8	 fsub	 QWORD PTR _cmin$[ebp]
  0017c	dd 5d d0	 fstp	 QWORD PTR _delta$[ebp]

; 93   : 		if (r==cmax)

  0017f	dd 45 f0	 fld	 QWORD PTR _cmax$[ebp]
  00182	dd 45 d8	 fld	 QWORD PTR _r$[ebp]
  00185	da e9		 fucompp
  00187	df e0		 fnstsw	 ax
  00189	f6 c4 44	 test	 ah, 68			; 00000044H
  0018c	7a 10		 jp	 SHORT $L197633

; 94   : 			*H = (g-b)/delta;

  0018e	dd 45 e0	 fld	 QWORD PTR _g$[ebp]
  00191	dc 65 e8	 fsub	 QWORD PTR _b$[ebp]
  00194	dc 75 d0	 fdiv	 QWORD PTR _delta$[ebp]
  00197	8b 55 0c	 mov	 edx, DWORD PTR _H$[ebp]
  0019a	dd 1a		 fstp	 QWORD PTR [edx]

; 95   : 		else if (g==cmax)

  0019c	eb 39		 jmp	 SHORT $L197634
$L197633:
  0019e	dd 45 f0	 fld	 QWORD PTR _cmax$[ebp]
  001a1	dd 45 e0	 fld	 QWORD PTR _g$[ebp]
  001a4	da e9		 fucompp
  001a6	df e0		 fnstsw	 ax
  001a8	f6 c4 44	 test	 ah, 68			; 00000044H
  001ab	7a 16		 jp	 SHORT $L197635

; 96   : 			*H = 2.0 +(b-r)/delta;

  001ad	dd 45 e8	 fld	 QWORD PTR _b$[ebp]
  001b0	dc 65 d8	 fsub	 QWORD PTR _r$[ebp]
  001b3	dc 75 d0	 fdiv	 QWORD PTR _delta$[ebp]
  001b6	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4000000000000000
  001bc	8b 45 0c	 mov	 eax, DWORD PTR _H$[ebp]
  001bf	dd 18		 fstp	 QWORD PTR [eax]

; 97   : 		else

  001c1	eb 14		 jmp	 SHORT $L197634
$L197635:

; 98   : 			*H = 4.0+(r-g)/delta;

  001c3	dd 45 d8	 fld	 QWORD PTR _r$[ebp]
  001c6	dc 65 e0	 fsub	 QWORD PTR _g$[ebp]
  001c9	dc 75 d0	 fdiv	 QWORD PTR _delta$[ebp]
  001cc	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4010000000000000
  001d2	8b 4d 0c	 mov	 ecx, DWORD PTR _H$[ebp]
  001d5	dd 19		 fstp	 QWORD PTR [ecx]
$L197634:

; 99   : 		*H /= 6.0;

  001d7	8b 55 0c	 mov	 edx, DWORD PTR _H$[ebp]
  001da	dd 02		 fld	 QWORD PTR [edx]
  001dc	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4018000000000000
  001e2	8b 45 0c	 mov	 eax, DWORD PTR _H$[ebp]
  001e5	dd 18		 fstp	 QWORD PTR [eax]

; 100  : 		if (*H < 0.0)

  001e7	8b 4d 0c	 mov	 ecx, DWORD PTR _H$[ebp]
  001ea	dd 01		 fld	 QWORD PTR [ecx]
  001ec	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  001f2	df e0		 fnstsw	 ax
  001f4	f6 c4 05	 test	 ah, 5
  001f7	7a 10		 jp	 SHORT $L197615

; 101  : 			*H += 1;

  001f9	8b 55 0c	 mov	 edx, DWORD PTR _H$[ebp]
  001fc	dd 02		 fld	 QWORD PTR [edx]
  001fe	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00204	8b 45 0c	 mov	 eax, DWORD PTR _H$[ebp]
  00207	dd 18		 fstp	 QWORD PTR [eax]
$L197615:

; 102  : 	}
; 103  : }

  00209	8b e5		 mov	 esp, ebp
  0020b	5d		 pop	 ebp
  0020c	c2 10 00	 ret	 16			; 00000010H
?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ENDP		; CBitMapOperate::RGBtoHSL
_TEXT	ENDS
PUBLIC	?HLStoRGB@CBitMapOperate@@QAEXABM00PAE11@Z	; CBitMapOperate::HLStoRGB
; Function compile flags: /Odt
;	COMDAT ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z
_TEXT	SEGMENT
tv232 = -112						; size = 4
tv230 = -108						; size = 4
tv228 = -104						; size = 4
tv221 = -100						; size = 4
tv219 = -96						; size = 4
tv217 = -92						; size = 4
tv210 = -88						; size = 4
tv208 = -84						; size = 4
tv206 = -80						; size = 4
_this$ = -76						; size = 4
$T199721 = -72						; size = 4
$T199720 = -68						; size = 4
$T199719 = -64						; size = 4
_G$ = -57						; size = 1
_R$ = -41						; size = 1
_B$ = -9						; size = 1
_H$ = 8							; size = 4
_L$ = 12						; size = 4
_S$ = 16						; size = 4
?HLStoRGB@CBitMapOperate@@QAEKABN00@Z PROC NEAR		; CBitMapOperate::HLStoRGB, COMDAT
; _this$ = ecx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	56		 push	 esi
  00007	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 130  : 	unsigned char B, G, R;
; 131  : 	HLStoRGB(H,L,S, &R,&G,&B);

  0000a	8b 45 10	 mov	 eax, DWORD PTR _S$[ebp]
  0000d	dd 00		 fld	 QWORD PTR [eax]
  0000f	d9 5d c0	 fstp	 DWORD PTR $T199719[ebp]
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _L$[ebp]
  00015	dd 01		 fld	 QWORD PTR [ecx]
  00017	d9 5d bc	 fstp	 DWORD PTR $T199720[ebp]
  0001a	8b 55 08	 mov	 edx, DWORD PTR _H$[ebp]
  0001d	dd 02		 fld	 QWORD PTR [edx]
  0001f	d9 5d b8	 fstp	 DWORD PTR $T199721[ebp]
  00022	8d 45 f7	 lea	 eax, DWORD PTR _B$[ebp]
  00025	50		 push	 eax
  00026	8d 4d c7	 lea	 ecx, DWORD PTR _G$[ebp]
  00029	51		 push	 ecx
  0002a	8d 55 d7	 lea	 edx, DWORD PTR _R$[ebp]
  0002d	52		 push	 edx
  0002e	8d 45 c0	 lea	 eax, DWORD PTR $T199719[ebp]
  00031	50		 push	 eax
  00032	8d 4d bc	 lea	 ecx, DWORD PTR $T199720[ebp]
  00035	51		 push	 ecx
  00036	8d 55 b8	 lea	 edx, DWORD PTR $T199721[ebp]
  00039	52		 push	 edx
  0003a	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEXABM00PAE11@Z ; CBitMapOperate::HLStoRGB

; 132  : 
; 133  : 	return RGB(R,G,B);

  00042	0f b6 45 d7	 movzx	 eax, BYTE PTR _R$[ebp]
  00046	0f b6 4d c7	 movzx	 ecx, BYTE PTR _G$[ebp]
  0004a	c1 e1 08	 shl	 ecx, 8
  0004d	0b c1		 or	 eax, ecx
  0004f	0f b6 55 f7	 movzx	 edx, BYTE PTR _B$[ebp]
  00053	c1 e2 10	 shl	 edx, 16			; 00000010H
  00056	0b c2		 or	 eax, edx

; 134  : 	double r,g,b;
; 135  : 	double m1, m2;
; 136  : 
; 137  : 	if (S==0)
; 138  : 	{
; 139  : 		r=g=b=L;
; 140  : 	}
; 141  : 	else
; 142  : 	{
; 143  : 		if (L <= 0.5)
; 144  : 			m2 = L*(1.0+S);
; 145  : 		else
; 146  : 			m2 = L+S-L*S;
; 147  : 		m1 = 2.0*L-m2;
; 148  : 		r = HuetoRGB(m1, m2, H+1.0/3.0);
; 149  : 		g = HuetoRGB(m1, m2, H);
; 150  : 		b = HuetoRGB(m1, m2, H-1.0/3.0);
; 151  : 	}
; 152  : 	return RGB((BYTE)(r*255),(BYTE)(g*255),(BYTE)(b*255));
; 153  : }

  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
?HLStoRGB@CBitMapOperate@@QAEKABN00@Z ENDP		; CBitMapOperate::HLStoRGB
_TEXT	ENDS
PUBLIC	__real@3f2aaaab
;	COMDAT __real@3f2aaaab
CONST	SEGMENT
__real@3f2aaaab DD 03f2aaaabr			; 0.666667
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?HLStoRGB@CBitMapOperate@@QAEXABM00PAE11@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_r$ = -20						; size = 4
_m2$ = -16						; size = 4
_g$ = -12						; size = 4
_b$ = -8						; size = 4
_m1$ = -4						; size = 4
_H$ = 8							; size = 4
_L$ = 12						; size = 4
_S$ = 16						; size = 4
_B$ = 20						; size = 4
_G$ = 24						; size = 4
_R$ = 28						; size = 4
?HLStoRGB@CBitMapOperate@@QAEXABM00PAE11@Z PROC NEAR	; CBitMapOperate::HLStoRGB, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	float r,g,b;
; 107  : 	float m1, m2;
; 108  : 
; 109  : 	if (S==0)

  00009	8b 45 10	 mov	 eax, DWORD PTR _S$[ebp]
  0000c	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00012	d9 00		 fld	 DWORD PTR [eax]
  00014	da e9		 fucompp
  00016	df e0		 fnstsw	 ax
  00018	f6 c4 44	 test	 ah, 68			; 00000044H
  0001b	7a 40		 jp	 SHORT $L197652

; 110  : 	{
; 111  : 		r=g=b=L;

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _L$[ebp]
  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	89 55 f8	 mov	 DWORD PTR _b$[ebp], edx
  00025	8b 45 f8	 mov	 eax, DWORD PTR _b$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax
  0002b	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  0002e	89 4d ec	 mov	 DWORD PTR _r$[ebp], ecx

; 112  : 		*R = 255.0 * r;

  00031	d9 45 ec	 fld	 DWORD PTR _r$[ebp]
  00034	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@406fe00000000000
  0003a	e8 00 00 00 00	 call	 __ftol2
  0003f	8b 55 1c	 mov	 edx, DWORD PTR _R$[ebp]
  00042	88 02		 mov	 BYTE PTR [edx], al

; 113  : 		*G = *B = *R;

  00044	8b 45 14	 mov	 eax, DWORD PTR _B$[ebp]
  00047	8b 4d 1c	 mov	 ecx, DWORD PTR _R$[ebp]
  0004a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0004c	88 10		 mov	 BYTE PTR [eax], dl
  0004e	8b 45 18	 mov	 eax, DWORD PTR _G$[ebp]
  00051	8b 4d 14	 mov	 ecx, DWORD PTR _B$[ebp]
  00054	8a 11		 mov	 dl, BYTE PTR [ecx]
  00056	88 10		 mov	 BYTE PTR [eax], dl

; 114  : 	}
; 115  : 	else

  00058	e9 d5 00 00 00	 jmp	 $L197646
$L197652:

; 116  : 	{
; 117  : 		if (L <= 0.5)

  0005d	8b 45 0c	 mov	 eax, DWORD PTR _L$[ebp]
  00060	d9 00		 fld	 DWORD PTR [eax]
  00062	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3fe0000000000000
  00068	df e0		 fnstsw	 ax
  0006a	f6 c4 41	 test	 ah, 65			; 00000041H
  0006d	7a 15		 jp	 SHORT $L197654

; 118  : 			m2 = L*((float)1.0+S);

  0006f	8b 4d 10	 mov	 ecx, DWORD PTR _S$[ebp]
  00072	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  00078	d8 01		 fadd	 DWORD PTR [ecx]
  0007a	8b 55 0c	 mov	 edx, DWORD PTR _L$[ebp]
  0007d	d8 0a		 fmul	 DWORD PTR [edx]
  0007f	d9 5d f0	 fstp	 DWORD PTR _m2$[ebp]

; 119  : 		else

  00082	eb 19		 jmp	 SHORT $L197656
$L197654:

; 120  : 			m2 = L+S-L*S;

  00084	8b 45 0c	 mov	 eax, DWORD PTR _L$[ebp]
  00087	8b 4d 10	 mov	 ecx, DWORD PTR _S$[ebp]
  0008a	d9 00		 fld	 DWORD PTR [eax]
  0008c	d8 01		 fadd	 DWORD PTR [ecx]
  0008e	8b 55 0c	 mov	 edx, DWORD PTR _L$[ebp]
  00091	8b 45 10	 mov	 eax, DWORD PTR _S$[ebp]
  00094	d9 02		 fld	 DWORD PTR [edx]
  00096	d8 08		 fmul	 DWORD PTR [eax]
  00098	de e9		 fsubp	 ST(1), ST(0)
  0009a	d9 5d f0	 fstp	 DWORD PTR _m2$[ebp]
$L197656:

; 121  : 		m1 = (float)2.0*L-m2;

  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _L$[ebp]
  000a0	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40000000
  000a6	d8 09		 fmul	 DWORD PTR [ecx]
  000a8	d8 65 f0	 fsub	 DWORD PTR _m2$[ebp]
  000ab	d9 5d fc	 fstp	 DWORD PTR _m1$[ebp]

; 122  : 		*R = (unsigned char) (HuetoRGB(m1, m2, H+(float)0.66666667) * (float)255.0);

  000ae	8b 55 08	 mov	 edx, DWORD PTR _H$[ebp]
  000b1	d9 02		 fld	 DWORD PTR [edx]
  000b3	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f2aaaab
  000b9	51		 push	 ecx
  000ba	d9 1c 24	 fstp	 DWORD PTR [esp]
  000bd	8b 45 f0	 mov	 eax, DWORD PTR _m2$[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _m1$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?HuetoRGB@CBitMapOperate@@QAEMMMM@Z ; CBitMapOperate::HuetoRGB
  000cd	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@437f0000
  000d3	e8 00 00 00 00	 call	 __ftol2
  000d8	8b 55 1c	 mov	 edx, DWORD PTR _R$[ebp]
  000db	88 02		 mov	 BYTE PTR [edx], al

; 123  : 		*G = (unsigned char) (HuetoRGB(m1, m2, H) * (float)255.0);

  000dd	8b 45 08	 mov	 eax, DWORD PTR _H$[ebp]
  000e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e2	51		 push	 ecx
  000e3	8b 55 f0	 mov	 edx, DWORD PTR _m2$[ebp]
  000e6	52		 push	 edx
  000e7	8b 45 fc	 mov	 eax, DWORD PTR _m1$[ebp]
  000ea	50		 push	 eax
  000eb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	e8 00 00 00 00	 call	 ?HuetoRGB@CBitMapOperate@@QAEMMMM@Z ; CBitMapOperate::HuetoRGB
  000f3	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@437f0000
  000f9	e8 00 00 00 00	 call	 __ftol2
  000fe	8b 4d 18	 mov	 ecx, DWORD PTR _G$[ebp]
  00101	88 01		 mov	 BYTE PTR [ecx], al

; 124  : 		*B = (unsigned char )(HuetoRGB(m1, m2, H-(float)0.66666667) * (float)255.0);

  00103	8b 55 08	 mov	 edx, DWORD PTR _H$[ebp]
  00106	d9 02		 fld	 DWORD PTR [edx]
  00108	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3f2aaaab
  0010e	51		 push	 ecx
  0010f	d9 1c 24	 fstp	 DWORD PTR [esp]
  00112	8b 45 f0	 mov	 eax, DWORD PTR _m2$[ebp]
  00115	50		 push	 eax
  00116	8b 4d fc	 mov	 ecx, DWORD PTR _m1$[ebp]
  00119	51		 push	 ecx
  0011a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	e8 00 00 00 00	 call	 ?HuetoRGB@CBitMapOperate@@QAEMMMM@Z ; CBitMapOperate::HuetoRGB
  00122	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@437f0000
  00128	e8 00 00 00 00	 call	 __ftol2
  0012d	8b 55 14	 mov	 edx, DWORD PTR _B$[ebp]
  00130	88 02		 mov	 BYTE PTR [edx], al
$L197646:

; 125  : 	}
; 126  : }

  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 18 00	 ret	 24			; 00000018H
?HLStoRGB@CBitMapOperate@@QAEXABM00PAE11@Z ENDP		; CBitMapOperate::HLStoRGB
_TEXT	ENDS
PUBLIC	__real@4014000000000000
PUBLIC	??0CMemoryException@@QAE@XZ			; CMemoryException::CMemoryException
PUBLIC	??1CMemoryException@@UAE@XZ			; CMemoryException::~CMemoryException
PUBLIC	?RGBtoHSL@CBitMapOperate@@QAEXMMMPAM00@Z	; CBitMapOperate::RGBtoHSL
PUBLIC	?ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV2@AAIAAK21@Z ; CBitMapOperate::ChangeBmpSkin
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::iterator::iterator
EXTRN	__except_list:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?ReportError@CException@@UAEHII@Z:NEAR		; CException::ReportError
;	COMDAT ?count@?9??ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV3@AAIAAK21@Z@4HA
_BSS	SEGMENT
?count@?9??ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV3@AAIAAK21@Z@4HA DD 01H DUP (?) ; `CBitMapOperate::ChangeBmpSkin'::`10'::count
_BSS	ENDS
;	COMDAT ?count1@?9??ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV3@AAIAAK21@Z@4HA
_BSS	SEGMENT
?count1@?9??ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV3@AAIAAK21@Z@4HA DD 01H DUP (?) ; `CBitMapOperate::ChangeBmpSkin'::`10'::count1
_BSS	ENDS
xdata$x	SEGMENT
$T199747 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:$L199735
$T199749 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L199734
$T199748 DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	FLAT:$T199749
$T199739 DD	019930520H
	DD	03H
	DD	FLAT:$T199747
	DD	01H
	DD	FLAT:$T199748
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
; Function compile flags: /Odt
CONST	ENDS
_TEXT	SEGMENT
tv394 = -316						; size = 4
tv391 = -312						; size = 4
tv388 = -308						; size = 4
tv354 = -304						; size = 8
tv142 = -296						; size = 4
_this$ = -292						; size = 4
_lmemexcept$198560 = -288				; size = 152
__$ArrayPad$ = -132					; size = 4
_lWidthIndex$198547 = -128				; size = 4
_lHightIndex$198543 = -124				; size = 4
_lH$197910 = -120					; size = 4
_lL$197912 = -116					; size = 4
_lAdjust1$197906 = -112					; size = 4
_lRowStart$197905 = -108				; size = 4
_lLastAdjust$197908 = -104				; size = 4
_lRowWidth$197904 = -100				; size = 4
_lS$197911 = -96					; size = 4
_it$198542 = -92					; size = 4
_bJustLight$ = -88					; size = 4
_lMB$ = -84						; size = 4
_lS2$ = -80						; size = 8
_lR2$ = -68						; size = 4
_lMR$ = -64						; size = 4
_lMG$ = -60						; size = 4
_lnFillBit$ = -56					; size = 4
_lpBitTable$ = -52					; size = 4
_lL2$ = -48						; size = 8
_lG2$ = -36						; size = 4
_lH2$ = -32						; size = 8
_bJustBaseColor$ = -24					; size = 4
_lB2$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
_ahSourceDib$ = 8					; size = 4
_aColorGroup$ = 12					; size = 4
_aBaseColor$ = 16					; size = 4
_aMaskColor$ = 20					; size = 4
_aiLightPos$ = 24					; size = 4
?ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV2@AAIAAK21@Z PROC NEAR ; CBitMapOperate::ChangeBmpSkin
; _this$ = ecx

; 355  : {

  007e0	55		 push	 ebp
  007e1	8b ec		 mov	 ebp, esp
  007e3	6a ff		 push	 -1
  007e5	68 00 00 00 00	 push	 __ehhandler$?ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV2@AAIAAK21@Z
  007ea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  007f0	50		 push	 eax
  007f1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  007f8	51		 push	 ecx
  007f9	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  007ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00804	89 85 7c ff ff
	ff		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0080a	53		 push	 ebx
  0080b	56		 push	 esi
  0080c	57		 push	 edi
  0080d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00810	89 8d dc fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 356  : 	if( (0==ahSourceDib.m_hight) || (0 == ahSourceDib.m_width) ) return &ahSourceDib;

  00816	8b 45 08	 mov	 eax, DWORD PTR _ahSourceDib$[ebp]
  00819	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0081d	74 09		 je	 SHORT $L197867
  0081f	8b 4d 08	 mov	 ecx, DWORD PTR _ahSourceDib$[ebp]
  00822	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00826	75 08		 jne	 SHORT $L197866
$L197867:
  00828	8b 45 08	 mov	 eax, DWORD PTR _ahSourceDib$[ebp]
  0082b	e9 55 04 00 00	 jmp	 $L197865
$L197866:

; 357  : 
; 358  : 	if(aBaseColor == 0)

  00830	8b 55 10	 mov	 edx, DWORD PTR _aBaseColor$[ebp]
  00833	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00836	75 08		 jne	 SHORT $L197868

; 359  : 		return &ahSourceDib;

  00838	8b 45 08	 mov	 eax, DWORD PTR _ahSourceDib$[ebp]
  0083b	e9 45 04 00 00	 jmp	 $L197865
$L197868:

; 360  : 
; 361  : 	BOOL bJustBaseColor = false;

  00840	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bJustBaseColor$[ebp], 0

; 362  : 	BOOL bJustLight = false;

  00847	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _bJustLight$[ebp], 0

; 363  : 
; 364  : 	if(aiLightPos == m_nLastLightPos)

  0084e	8b 45 18	 mov	 eax, DWORD PTR _aiLightPos$[ebp]
  00851	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00857	8b 10		 mov	 edx, DWORD PTR [eax]
  00859	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  0085c	75 07		 jne	 SHORT $L197871

; 365  : 		bJustBaseColor = true;

  0085e	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bJustBaseColor$[ebp], 1
$L197871:

; 366  : 
; 367  : 	if( 24 != ahSourceDib.m_biBitCount ) return &ahSourceDib;

  00865	8b 45 08	 mov	 eax, DWORD PTR _ahSourceDib$[ebp]
  00868	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  0086c	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0086f	74 08		 je	 SHORT $L197872
  00871	8b 45 08	 mov	 eax, DWORD PTR _ahSourceDib$[ebp]
  00874	e9 0c 04 00 00	 jmp	 $L197865
$L197872:

; 368  : 	int lR2,lG2,lB2;
; 369  : 	int lMR, lMG, lMB;
; 370  : 	double lH2,lS2,lL2;
; 371  : 	lR2 = GetRValue(aBaseColor);

  00879	8b 55 10	 mov	 edx, DWORD PTR _aBaseColor$[ebp]
  0087c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0087f	89 45 bc	 mov	 DWORD PTR _lR2$[ebp], eax

; 372  : 	lG2 = GetGValue(aBaseColor);

  00882	8b 4d 10	 mov	 ecx, DWORD PTR _aBaseColor$[ebp]
  00885	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00888	c1 fa 08	 sar	 edx, 8
  0088b	0f b6 c2	 movzx	 eax, dl
  0088e	89 45 dc	 mov	 DWORD PTR _lG2$[ebp], eax

; 373  : 	lB2 = GetBValue(aBaseColor);

  00891	8b 4d 10	 mov	 ecx, DWORD PTR _aBaseColor$[ebp]
  00894	8b 11		 mov	 edx, DWORD PTR [ecx]
  00896	c1 ea 10	 shr	 edx, 16			; 00000010H
  00899	0f b6 c2	 movzx	 eax, dl
  0089c	89 45 ec	 mov	 DWORD PTR _lB2$[ebp], eax

; 374  : 
; 375  : 	lMR = GetRValue(aMaskColor);

  0089f	8b 4d 14	 mov	 ecx, DWORD PTR _aMaskColor$[ebp]
  008a2	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  008a5	89 55 c0	 mov	 DWORD PTR _lMR$[ebp], edx

; 376  : 	lMG = GetGValue(aMaskColor);

  008a8	8b 45 14	 mov	 eax, DWORD PTR _aMaskColor$[ebp]
  008ab	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  008ae	c1 f9 08	 sar	 ecx, 8
  008b1	0f b6 d1	 movzx	 edx, cl
  008b4	89 55 c4	 mov	 DWORD PTR _lMG$[ebp], edx

; 377  : 	lMB = GetBValue(aMaskColor);

  008b7	8b 45 14	 mov	 eax, DWORD PTR _aMaskColor$[ebp]
  008ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  008bc	c1 e9 10	 shr	 ecx, 16			; 00000010H
  008bf	0f b6 d1	 movzx	 edx, cl
  008c2	89 55 ac	 mov	 DWORD PTR _lMB$[ebp], edx

; 378  : 
; 379  : 	RGBtoHSL(RGB(lR2,lG2,lB2),&lH2,&lS2,&lL2);

  008c5	8d 45 d0	 lea	 eax, DWORD PTR _lL2$[ebp]
  008c8	50		 push	 eax
  008c9	8d 4d b0	 lea	 ecx, DWORD PTR _lS2$[ebp]
  008cc	51		 push	 ecx
  008cd	8d 55 e0	 lea	 edx, DWORD PTR _lH2$[ebp]
  008d0	52		 push	 edx
  008d1	0f b6 45 ec	 movzx	 eax, BYTE PTR _lB2$[ebp]
  008d5	c1 e0 10	 shl	 eax, 16			; 00000010H
  008d8	0f b6 4d dc	 movzx	 ecx, BYTE PTR _lG2$[ebp]
  008dc	c1 e1 08	 shl	 ecx, 8
  008df	0f b6 55 bc	 movzx	 edx, BYTE PTR _lR2$[ebp]
  008e3	0b d1		 or	 edx, ecx
  008e5	0b d0		 or	 edx, eax
  008e7	52		 push	 edx
  008e8	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  008ee	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ; CBitMapOperate::RGBtoHSL

; 380  : 
; 381  : 	int lnFillBit = ahSourceDib.m_width * 3%4 == 0 ? 0 : 4-ahSourceDib.m_width * 3%4;

  008f3	8b 45 08	 mov	 eax, DWORD PTR _ahSourceDib$[ebp]
  008f6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  008f9	6b c0 03	 imul	 eax, 3
  008fc	33 d2		 xor	 edx, edx
  008fe	b9 04 00 00 00	 mov	 ecx, 4
  00903	f7 f1		 div	 ecx
  00905	85 d2		 test	 edx, edx
  00907	75 0c		 jne	 SHORT $L199731
  00909	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv142[ebp], 0
  00913	eb 1f		 jmp	 SHORT $L199732
$L199731:
  00915	8b 55 08	 mov	 edx, DWORD PTR _ahSourceDib$[ebp]
  00918	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0091b	6b c0 03	 imul	 eax, 3
  0091e	33 d2		 xor	 edx, edx
  00920	b9 04 00 00 00	 mov	 ecx, 4
  00925	f7 f1		 div	 ecx
  00927	b8 04 00 00 00	 mov	 eax, 4
  0092c	2b c2		 sub	 eax, edx
  0092e	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv142[ebp], eax
$L199732:
  00934	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv142[ebp]
  0093a	89 4d c8	 mov	 DWORD PTR _lnFillBit$[ebp], ecx

; 382  : 	LPBYTE lpBitTable =  (LPBYTE)(ahSourceDib.m_lpvColorTable);

  0093d	8b 55 08	 mov	 edx, DWORD PTR _ahSourceDib$[ebp]
  00940	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00943	89 45 cc	 mov	 DWORD PTR _lpBitTable$[ebp], eax

; 383  : 		static int count = 0;
; 384  : 		static int count1 = 0;
; 385  : 
; 386  : 		count1 ++;

  00946	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?count1@?9??ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV3@AAIAAK21@Z@4HA
  0094c	83 c1 01	 add	 ecx, 1
  0094f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?count1@?9??ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV3@AAIAAK21@Z@4HA, ecx

; 387  : 
; 388  : 	try
; 389  : 	{

  00955	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 390  : 		int lRowWidth = ahSourceDib.m_width*3 + lnFillBit;

  0095c	8b 55 08	 mov	 edx, DWORD PTR _ahSourceDib$[ebp]
  0095f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00962	6b c0 03	 imul	 eax, 3
  00965	03 45 c8	 add	 eax, DWORD PTR _lnFillBit$[ebp]
  00968	89 45 9c	 mov	 DWORD PTR _lRowWidth$197904[ebp], eax

; 391  : 		int lRowStart = 0;

  0096b	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _lRowStart$197905[ebp], 0

; 392  : 
; 393  : 		float lAdjust1 = ((float)aiLightPos / 120.0 - 1.0);

  00972	8b 4d 18	 mov	 ecx, DWORD PTR _aiLightPos$[ebp]
  00975	8b 11		 mov	 edx, DWORD PTR [ecx]
  00977	89 95 d0 fe ff
	ff		 mov	 DWORD PTR tv354[ebp], edx
  0097d	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv354[ebp+4], 0
  00987	df ad d0 fe ff
	ff		 fild	 QWORD PTR tv354[ebp]
  0098d	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@405e000000000000
  00993	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  00999	d9 5d 90	 fstp	 DWORD PTR _lAdjust1$197906[ebp]

; 394  : 		float lLastAdjust = ((float)m_nLastLightPos / 120.0 - 1.0);

  0099c	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009a2	db 40 18	 fild	 DWORD PTR [eax+24]
  009a5	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@405e000000000000
  009ab	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  009b1	d9 5d 98	 fstp	 DWORD PTR _lLastAdjust$197908[ebp]

; 395  : 
; 396  : 		lAdjust1 /= 5.0;

  009b4	d9 45 90	 fld	 DWORD PTR _lAdjust1$197906[ebp]
  009b7	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4014000000000000
  009bd	d9 5d 90	 fstp	 DWORD PTR _lAdjust1$197906[ebp]

; 397  : 		lLastAdjust /= 5.0;

  009c0	d9 45 98	 fld	 DWORD PTR _lLastAdjust$197908[ebp]
  009c3	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4014000000000000
  009c9	d9 5d 98	 fstp	 DWORD PTR _lLastAdjust$197908[ebp]

; 398  : 
; 399  : 		float lH,lS,lL;
; 400  : 		//memset(&m_clrMap, 0, sizeof(COLORREF) * 65536);
; 401  : 
; 402  : 		CHANGE_COLOR_MAP::iterator it;

  009cc	8d 4d a4	 lea	 ecx, DWORD PTR _it$198542[ebp]
  009cf	e8 00 00 00 00	 call	 ??0iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::iterator::iterator

; 403  : 		for (int lHightIndex = 0; lHightIndex<ahSourceDib.m_hight;  lHightIndex++, lRowStart += lRowWidth  )

  009d4	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _lHightIndex$198543[ebp], 0
  009db	eb 12		 jmp	 SHORT $L198544
$L198545:
  009dd	8b 4d 84	 mov	 ecx, DWORD PTR _lHightIndex$198543[ebp]
  009e0	83 c1 01	 add	 ecx, 1
  009e3	89 4d 84	 mov	 DWORD PTR _lHightIndex$198543[ebp], ecx
  009e6	8b 55 94	 mov	 edx, DWORD PTR _lRowStart$197905[ebp]
  009e9	03 55 9c	 add	 edx, DWORD PTR _lRowWidth$197904[ebp]
  009ec	89 55 94	 mov	 DWORD PTR _lRowStart$197905[ebp], edx
$L198544:
  009ef	8b 45 08	 mov	 eax, DWORD PTR _ahSourceDib$[ebp]
  009f2	8b 4d 84	 mov	 ecx, DWORD PTR _lHightIndex$198543[ebp]
  009f5	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  009f8	0f 83 48 02 00
	00		 jae	 $L198546

; 404  : 		{
; 405  : 			for(int lWidthIndex = 0; lWidthIndex< lRowWidth ; lWidthIndex++  )

  009fe	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _lWidthIndex$198547[ebp], 0
  00a05	eb 09		 jmp	 SHORT $L198548
$L198549:
  00a07	8b 55 80	 mov	 edx, DWORD PTR _lWidthIndex$198547[ebp]
  00a0a	83 c2 01	 add	 edx, 1
  00a0d	89 55 80	 mov	 DWORD PTR _lWidthIndex$198547[ebp], edx
$L198548:
  00a10	8b 45 80	 mov	 eax, DWORD PTR _lWidthIndex$198547[ebp]
  00a13	3b 45 9c	 cmp	 eax, DWORD PTR _lRowWidth$197904[ebp]
  00a16	0f 8d 25 02 00
	00		 jge	 $L198550

; 406  : 			{
; 407  : 				if( lWidthIndex + 2 > lRowWidth - lnFillBit ) break; 

  00a1c	8b 4d 9c	 mov	 ecx, DWORD PTR _lRowWidth$197904[ebp]
  00a1f	2b 4d c8	 sub	 ecx, DWORD PTR _lnFillBit$[ebp]
  00a22	8b 55 80	 mov	 edx, DWORD PTR _lWidthIndex$198547[ebp]
  00a25	83 c2 02	 add	 edx, 2
  00a28	3b d1		 cmp	 edx, ecx
  00a2a	7e 05		 jle	 SHORT $L198551
  00a2c	e9 10 02 00 00	 jmp	 $L198550
$L198551:

; 408  : 
; 409  : 				if(lMR == lpBitTable[lRowStart + lWidthIndex + 2] && 
; 410  : 				   lMG ==  lpBitTable[lRowStart + lWidthIndex + 1] &&
; 411  : 				   lMB == lpBitTable[lRowStart + lWidthIndex])

  00a31	8b 45 94	 mov	 eax, DWORD PTR _lRowStart$197905[ebp]
  00a34	03 45 80	 add	 eax, DWORD PTR _lWidthIndex$198547[ebp]
  00a37	8b 4d cc	 mov	 ecx, DWORD PTR _lpBitTable$[ebp]
  00a3a	0f b6 54 01 02	 movzx	 edx, BYTE PTR [ecx+eax+2]
  00a3f	39 55 c0	 cmp	 DWORD PTR _lMR$[ebp], edx
  00a42	75 30		 jne	 SHORT $L198552
  00a44	8b 45 94	 mov	 eax, DWORD PTR _lRowStart$197905[ebp]
  00a47	03 45 80	 add	 eax, DWORD PTR _lWidthIndex$198547[ebp]
  00a4a	8b 4d cc	 mov	 ecx, DWORD PTR _lpBitTable$[ebp]
  00a4d	0f b6 54 01 01	 movzx	 edx, BYTE PTR [ecx+eax+1]
  00a52	39 55 c4	 cmp	 DWORD PTR _lMG$[ebp], edx
  00a55	75 1d		 jne	 SHORT $L198552
  00a57	8b 45 94	 mov	 eax, DWORD PTR _lRowStart$197905[ebp]
  00a5a	03 45 80	 add	 eax, DWORD PTR _lWidthIndex$198547[ebp]
  00a5d	8b 4d cc	 mov	 ecx, DWORD PTR _lpBitTable$[ebp]
  00a60	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00a64	39 55 ac	 cmp	 DWORD PTR _lMB$[ebp], edx
  00a67	75 0b		 jne	 SHORT $L198552

; 412  : 				{
; 413  : 					lWidthIndex += 2;

  00a69	8b 45 80	 mov	 eax, DWORD PTR _lWidthIndex$198547[ebp]
  00a6c	83 c0 02	 add	 eax, 2
  00a6f	89 45 80	 mov	 DWORD PTR _lWidthIndex$198547[ebp], eax

; 414  : 					continue;

  00a72	eb 93		 jmp	 SHORT $L198549
$L198552:

; 415  : 				}
; 416  : 				if(lpBitTable[lRowStart + lWidthIndex + 2] == 0
; 417  : 					&&  lpBitTable[lRowStart + lWidthIndex + 1] == 0
; 418  : 					&& lpBitTable[lRowStart + lWidthIndex ]  == 0)

  00a74	8b 4d 94	 mov	 ecx, DWORD PTR _lRowStart$197905[ebp]
  00a77	03 4d 80	 add	 ecx, DWORD PTR _lWidthIndex$198547[ebp]
  00a7a	8b 55 cc	 mov	 edx, DWORD PTR _lpBitTable$[ebp]
  00a7d	0f b6 44 0a 02	 movzx	 eax, BYTE PTR [edx+ecx+2]
  00a82	85 c0		 test	 eax, eax
  00a84	75 31		 jne	 SHORT $L198553
  00a86	8b 4d 94	 mov	 ecx, DWORD PTR _lRowStart$197905[ebp]
  00a89	03 4d 80	 add	 ecx, DWORD PTR _lWidthIndex$198547[ebp]
  00a8c	8b 55 cc	 mov	 edx, DWORD PTR _lpBitTable$[ebp]
  00a8f	0f b6 44 0a 01	 movzx	 eax, BYTE PTR [edx+ecx+1]
  00a94	85 c0		 test	 eax, eax
  00a96	75 1f		 jne	 SHORT $L198553
  00a98	8b 4d 94	 mov	 ecx, DWORD PTR _lRowStart$197905[ebp]
  00a9b	03 4d 80	 add	 ecx, DWORD PTR _lWidthIndex$198547[ebp]
  00a9e	8b 55 cc	 mov	 edx, DWORD PTR _lpBitTable$[ebp]
  00aa1	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00aa5	85 c0		 test	 eax, eax
  00aa7	75 0e		 jne	 SHORT $L198553

; 419  : 				{
; 420  : 					lWidthIndex += 2;

  00aa9	8b 4d 80	 mov	 ecx, DWORD PTR _lWidthIndex$198547[ebp]
  00aac	83 c1 02	 add	 ecx, 2
  00aaf	89 4d 80	 mov	 DWORD PTR _lWidthIndex$198547[ebp], ecx

; 421  : 					continue;

  00ab2	e9 50 ff ff ff	 jmp	 $L198549
$L198553:

; 422  : 				}
; 423  : 
; 424  : 
; 425  : 				RGBtoHSL(
; 426  : 					lpBitTable[lRowStart + lWidthIndex + 2],
; 427  : 					lpBitTable[lRowStart + lWidthIndex + 1],
; 428  : 					lpBitTable[lRowStart + lWidthIndex ],
; 429  : 				&lH,&lS,&lL);

  00ab7	8d 55 8c	 lea	 edx, DWORD PTR _lL$197912[ebp]
  00aba	52		 push	 edx
  00abb	8d 45 a0	 lea	 eax, DWORD PTR _lS$197911[ebp]
  00abe	50		 push	 eax
  00abf	8d 4d 88	 lea	 ecx, DWORD PTR _lH$197910[ebp]
  00ac2	51		 push	 ecx
  00ac3	8b 55 94	 mov	 edx, DWORD PTR _lRowStart$197905[ebp]
  00ac6	03 55 80	 add	 edx, DWORD PTR _lWidthIndex$198547[ebp]
  00ac9	8b 45 cc	 mov	 eax, DWORD PTR _lpBitTable$[ebp]
  00acc	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00ad0	89 8d cc fe ff
	ff		 mov	 DWORD PTR tv388[ebp], ecx
  00ad6	db 85 cc fe ff
	ff		 fild	 DWORD PTR tv388[ebp]
  00adc	51		 push	 ecx
  00add	d9 1c 24	 fstp	 DWORD PTR [esp]
  00ae0	8b 55 94	 mov	 edx, DWORD PTR _lRowStart$197905[ebp]
  00ae3	03 55 80	 add	 edx, DWORD PTR _lWidthIndex$198547[ebp]
  00ae6	8b 45 cc	 mov	 eax, DWORD PTR _lpBitTable$[ebp]
  00ae9	0f b6 4c 10 01	 movzx	 ecx, BYTE PTR [eax+edx+1]
  00aee	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv391[ebp], ecx
  00af4	db 85 c8 fe ff
	ff		 fild	 DWORD PTR tv391[ebp]
  00afa	51		 push	 ecx
  00afb	d9 1c 24	 fstp	 DWORD PTR [esp]
  00afe	8b 55 94	 mov	 edx, DWORD PTR _lRowStart$197905[ebp]
  00b01	03 55 80	 add	 edx, DWORD PTR _lWidthIndex$198547[ebp]
  00b04	8b 45 cc	 mov	 eax, DWORD PTR _lpBitTable$[ebp]
  00b07	0f b6 4c 10 02	 movzx	 ecx, BYTE PTR [eax+edx+2]
  00b0c	89 8d c4 fe ff
	ff		 mov	 DWORD PTR tv394[ebp], ecx
  00b12	db 85 c4 fe ff
	ff		 fild	 DWORD PTR tv394[ebp]
  00b18	51		 push	 ecx
  00b19	d9 1c 24	 fstp	 DWORD PTR [esp]
  00b1c	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b22	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXMMMPAM00@Z ; CBitMapOperate::RGBtoHSL

; 430  : 
; 431  : 				/*if(!bJustBaseColor)
; 432  : 				{
; 433  : 					lL = this->GetOriLValue(lL, lLastAdjust);
; 434  : 					float lAdjuest = (1.0 - lL > lL) ? lL: 1.0-lL; 
; 435  : 					lL += lAdjust1 * lAdjuest;
; 436  : 				}*/
; 437  : 	/*			lL = lL + lL2/2;
; 438  : 				if(lL > 1.0)
; 439  : 					lL = 1.0;*/
; 440  : 
; 441  : 				lH = lH2;

  00b27	dd 45 e0	 fld	 QWORD PTR _lH2$[ebp]
  00b2a	d9 5d 88	 fstp	 DWORD PTR _lH$197910[ebp]

; 442  : 				if(lH > 1.0)

  00b2d	d9 45 88	 fld	 DWORD PTR _lH$197910[ebp]
  00b30	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3ff0000000000000
  00b36	df e0		 fnstsw	 ax
  00b38	f6 c4 41	 test	 ah, 65			; 00000041H
  00b3b	75 0c		 jne	 SHORT $L198554

; 443  : 					lH -= 1.0;

  00b3d	d9 45 88	 fld	 DWORD PTR _lH$197910[ebp]
  00b40	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  00b46	d9 5d 88	 fstp	 DWORD PTR _lH$197910[ebp]
$L198554:

; 444  : 				if(lH < 0)

  00b49	d9 45 88	 fld	 DWORD PTR _lH$197910[ebp]
  00b4c	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00b52	df e0		 fnstsw	 ax
  00b54	f6 c4 05	 test	 ah, 5
  00b57	7a 0c		 jp	 SHORT $L198555

; 445  : 					lH += 1.0;

  00b59	d9 45 88	 fld	 DWORD PTR _lH$197910[ebp]
  00b5c	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00b62	d9 5d 88	 fstp	 DWORD PTR _lH$197910[ebp]
$L198555:

; 446  : 
; 447  : 				lL = lL + (lL2 - 0.5)/4;

  00b65	dd 45 d0	 fld	 QWORD PTR _lL2$[ebp]
  00b68	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3fe0000000000000
  00b6e	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4010000000000000
  00b74	d8 45 8c	 fadd	 DWORD PTR _lL$197912[ebp]
  00b77	d9 5d 8c	 fstp	 DWORD PTR _lL$197912[ebp]

; 448  : 				if(lL > 1.0)

  00b7a	d9 45 8c	 fld	 DWORD PTR _lL$197912[ebp]
  00b7d	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3ff0000000000000
  00b83	df e0		 fnstsw	 ax
  00b85	f6 c4 41	 test	 ah, 65			; 00000041H
  00b88	75 07		 jne	 SHORT $L198556

; 449  : 					lL = 1.0;

  00b8a	c7 45 8c 00 00
	80 3f		 mov	 DWORD PTR _lL$197912[ebp], 1065353216 ; 3f800000H
$L198556:

; 450  : 				if(lL <= 0)

  00b91	d9 45 8c	 fld	 DWORD PTR _lL$197912[ebp]
  00b94	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00b9a	df e0		 fnstsw	 ax
  00b9c	f6 c4 41	 test	 ah, 65			; 00000041H
  00b9f	7a 07		 jp	 SHORT $L198557

; 451  : 					lL = 0.1;

  00ba1	c7 45 8c cd cc
	cc 3d		 mov	 DWORD PTR _lL$197912[ebp], 1036831949 ; 3dcccccdH
$L198557:

; 452  : 				lS = lS + (lS2 - 0.5) * 2;

  00ba8	dd 45 b0	 fld	 QWORD PTR _lS2$[ebp]
  00bab	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3fe0000000000000
  00bb1	dc c0		 fadd	 ST(0), ST(0)
  00bb3	d8 45 a0	 fadd	 DWORD PTR _lS$197911[ebp]
  00bb6	d9 5d a0	 fstp	 DWORD PTR _lS$197911[ebp]

; 453  : 				if(lS > 1.0)

  00bb9	d9 45 a0	 fld	 DWORD PTR _lS$197911[ebp]
  00bbc	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3ff0000000000000
  00bc2	df e0		 fnstsw	 ax
  00bc4	f6 c4 41	 test	 ah, 65			; 00000041H
  00bc7	75 07		 jne	 SHORT $L198558

; 454  : 						lS = 1.0;

  00bc9	c7 45 a0 00 00
	80 3f		 mov	 DWORD PTR _lS$197911[ebp], 1065353216 ; 3f800000H
$L198558:

; 455  : 				if(lS <= 0)

  00bd0	d9 45 a0	 fld	 DWORD PTR _lS$197911[ebp]
  00bd3	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00bd9	df e0		 fnstsw	 ax
  00bdb	f6 c4 41	 test	 ah, 65			; 00000041H
  00bde	7a 07		 jp	 SHORT $L198559

; 456  : 						lS = 0.1;

  00be0	c7 45 a0 cd cc
	cc 3d		 mov	 DWORD PTR _lS$197911[ebp], 1036831949 ; 3dcccccdH
$L198559:

; 457  : 
; 458  : 				HLStoRGB(lH,lL,lS,
; 459  : 					lpBitTable +  lRowStart + lWidthIndex + 2,
; 460  : 					lpBitTable +  lRowStart + lWidthIndex + 1,
; 461  : 					lpBitTable +  lRowStart + lWidthIndex );

  00be7	8b 55 cc	 mov	 edx, DWORD PTR _lpBitTable$[ebp]
  00bea	03 55 94	 add	 edx, DWORD PTR _lRowStart$197905[ebp]
  00bed	03 55 80	 add	 edx, DWORD PTR _lWidthIndex$198547[ebp]
  00bf0	52		 push	 edx
  00bf1	8b 45 cc	 mov	 eax, DWORD PTR _lpBitTable$[ebp]
  00bf4	03 45 94	 add	 eax, DWORD PTR _lRowStart$197905[ebp]
  00bf7	8b 4d 80	 mov	 ecx, DWORD PTR _lWidthIndex$198547[ebp]
  00bfa	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  00bfe	52		 push	 edx
  00bff	8b 45 cc	 mov	 eax, DWORD PTR _lpBitTable$[ebp]
  00c02	03 45 94	 add	 eax, DWORD PTR _lRowStart$197905[ebp]
  00c05	8b 4d 80	 mov	 ecx, DWORD PTR _lWidthIndex$198547[ebp]
  00c08	8d 54 08 02	 lea	 edx, DWORD PTR [eax+ecx+2]
  00c0c	52		 push	 edx
  00c0d	8d 45 a0	 lea	 eax, DWORD PTR _lS$197911[ebp]
  00c10	50		 push	 eax
  00c11	8d 4d 8c	 lea	 ecx, DWORD PTR _lL$197912[ebp]
  00c14	51		 push	 ecx
  00c15	8d 55 88	 lea	 edx, DWORD PTR _lH$197910[ebp]
  00c18	52		 push	 edx
  00c19	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c1f	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEXABM00PAE11@Z ; CBitMapOperate::HLStoRGB

; 462  : 
; 463  : 				lWidthIndex += 2;

  00c24	8b 45 80	 mov	 eax, DWORD PTR _lWidthIndex$198547[ebp]
  00c27	83 c0 02	 add	 eax, 2
  00c2a	89 45 80	 mov	 DWORD PTR _lWidthIndex$198547[ebp], eax

; 464  : 					count ++;

  00c2d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?count@?9??ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV3@AAIAAK21@Z@4HA
  00c33	83 c1 01	 add	 ecx, 1
  00c36	89 0d 00 00 00
	00		 mov	 DWORD PTR ?count@?9??ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV3@AAIAAK21@Z@4HA, ecx

; 465  : 
; 466  : 			}

  00c3c	e9 c6 fd ff ff	 jmp	 $L198549
$L198550:

; 467  : 		}

  00c41	e9 97 fd ff ff	 jmp	 $L198545
$L198546:
  00c46	eb 33		 jmp	 SHORT $L199733
$L199734:

; 468  : 	}
; 469  : 	catch(...)
; 470  : 	{
; 471  : 		CMemoryException lmemexcept;

  00c48	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _lmemexcept$198560[ebp]
  00c4e	e8 00 00 00 00	 call	 ??0CMemoryException@@QAE@XZ ; CMemoryException::CMemoryException
  00c53	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 472  : 		lmemexcept.ReportError();

  00c57	6a 00		 push	 0
  00c59	6a 00		 push	 0
  00c5b	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _lmemexcept$198560[ebp]
  00c61	e8 00 00 00 00	 call	 ?ReportError@CException@@UAEHII@Z ; CException::ReportError

; 473  : 	}

  00c66	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00c6a	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _lmemexcept$198560[ebp]
  00c70	e8 00 00 00 00	 call	 ??1CMemoryException@@UAE@XZ ; CMemoryException::~CMemoryException
  00c75	b8 00 00 00 00	 mov	 eax, $L199733
  00c7a	c3		 ret	 0
$L199733:
  00c7b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 474  : 	
; 475  : 	//TRACE("<%d, %d> \n ", count, count1);
; 476  : 	return &ahSourceDib;

  00c82	8b 45 08	 mov	 eax, DWORD PTR _ahSourceDib$[ebp]
$L197865:

; 477  : }

  00c85	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00c88	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00c8f	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c95	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c9a	5f		 pop	 edi
  00c9b	5e		 pop	 esi
  00c9c	5b		 pop	 ebx
  00c9d	8b e5		 mov	 esp, ebp
  00c9f	5d		 pop	 ebp
  00ca0	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
text$x	SEGMENT
$L199735:
  00000	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _lmemexcept$198560[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CMemoryException@@UAE@XZ ; CMemoryException::~CMemoryException
__ehhandler$?ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV2@AAIAAK21@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199739
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ChangeBmpSkin@CBitMapOperate@@QAEPAVDIBINFO@@AAV2@AAIAAK21@Z ENDP ; CBitMapOperate::ChangeBmpSkin
; Function compile flags: /Odt
;	COMDAT ?RGBtoHSL@CBitMapOperate@@QAEXMMMPAM00@Z
_TEXT	SEGMENT
tv77 = -40						; size = 4
tv78 = -36						; size = 4
tv74 = -32						; size = 4
tv71 = -28						; size = 4
tv72 = -24						; size = 4
tv68 = -20						; size = 4
_this$ = -16						; size = 4
_delta$ = -12						; size = 4
_cmax$ = -8						; size = 4
_cmin$ = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_H$ = 20						; size = 4
_S$ = 24						; size = 4
_L$ = 28						; size = 4
?RGBtoHSL@CBitMapOperate@@QAEXMMMPAM00@Z PROC NEAR	; CBitMapOperate::RGBtoHSL, COMDAT
; _this$ = ecx

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 	float delta;
; 34   : 	//double r = (double)GetRValue(rgb)/255;
; 35   : 	//double g = (double)GetGValue(rgb)/255;
; 36   : 	//double b = (double)GetBValue(rgb)/255;
; 37   : 	r /= 255;

  00009	d9 45 08	 fld	 DWORD PTR _r$[ebp]
  0000c	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@437f0000
  00012	d9 5d 08	 fstp	 DWORD PTR _r$[ebp]

; 38   : 	g /=255;

  00015	d9 45 0c	 fld	 DWORD PTR _g$[ebp]
  00018	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@437f0000
  0001e	d9 5d 0c	 fstp	 DWORD PTR _g$[ebp]

; 39   : 	b /= 255;

  00021	d9 45 10	 fld	 DWORD PTR _b$[ebp]
  00024	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@437f0000
  0002a	d9 5d 10	 fstp	 DWORD PTR _b$[ebp]

; 40   : 
; 41   : 	float cmax = max(r,max(g,b));

  0002d	d9 45 0c	 fld	 DWORD PTR _g$[ebp]
  00030	d8 5d 10	 fcomp	 DWORD PTR _b$[ebp]
  00033	df e0		 fnstsw	 ax
  00035	f6 c4 41	 test	 ah, 65			; 00000041H
  00038	75 08		 jne	 SHORT $L199754
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR tv68[ebp], eax
  00040	eb 06		 jmp	 SHORT $L199755
$L199754:
  00042	8b 4d 10	 mov	 ecx, DWORD PTR _b$[ebp]
  00045	89 4d ec	 mov	 DWORD PTR tv68[ebp], ecx
$L199755:
  00048	d9 45 08	 fld	 DWORD PTR _r$[ebp]
  0004b	d8 5d ec	 fcomp	 DWORD PTR tv68[ebp]
  0004e	df e0		 fnstsw	 ax
  00050	f6 c4 41	 test	 ah, 65			; 00000041H
  00053	75 08		 jne	 SHORT $L199758
  00055	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00058	89 55 e8	 mov	 DWORD PTR tv72[ebp], edx
  0005b	eb 21		 jmp	 SHORT $L199759
$L199758:
  0005d	d9 45 0c	 fld	 DWORD PTR _g$[ebp]
  00060	d8 5d 10	 fcomp	 DWORD PTR _b$[ebp]
  00063	df e0		 fnstsw	 ax
  00065	f6 c4 41	 test	 ah, 65			; 00000041H
  00068	75 08		 jne	 SHORT $L199756
  0006a	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  0006d	89 45 e4	 mov	 DWORD PTR tv71[ebp], eax
  00070	eb 06		 jmp	 SHORT $L199757
$L199756:
  00072	8b 4d 10	 mov	 ecx, DWORD PTR _b$[ebp]
  00075	89 4d e4	 mov	 DWORD PTR tv71[ebp], ecx
$L199757:
  00078	8b 55 e4	 mov	 edx, DWORD PTR tv71[ebp]
  0007b	89 55 e8	 mov	 DWORD PTR tv72[ebp], edx
$L199759:
  0007e	8b 45 e8	 mov	 eax, DWORD PTR tv72[ebp]
  00081	89 45 f8	 mov	 DWORD PTR _cmax$[ebp], eax

; 42   : 	float cmin = min(r,min(g,b));

  00084	d9 45 0c	 fld	 DWORD PTR _g$[ebp]
  00087	d8 5d 10	 fcomp	 DWORD PTR _b$[ebp]
  0008a	df e0		 fnstsw	 ax
  0008c	f6 c4 05	 test	 ah, 5
  0008f	7a 08		 jp	 SHORT $L199760
  00091	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00094	89 4d e0	 mov	 DWORD PTR tv74[ebp], ecx
  00097	eb 06		 jmp	 SHORT $L199761
$L199760:
  00099	8b 55 10	 mov	 edx, DWORD PTR _b$[ebp]
  0009c	89 55 e0	 mov	 DWORD PTR tv74[ebp], edx
$L199761:
  0009f	d9 45 08	 fld	 DWORD PTR _r$[ebp]
  000a2	d8 5d e0	 fcomp	 DWORD PTR tv74[ebp]
  000a5	df e0		 fnstsw	 ax
  000a7	f6 c4 05	 test	 ah, 5
  000aa	7a 08		 jp	 SHORT $L199764
  000ac	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  000af	89 45 dc	 mov	 DWORD PTR tv78[ebp], eax
  000b2	eb 21		 jmp	 SHORT $L199765
$L199764:
  000b4	d9 45 0c	 fld	 DWORD PTR _g$[ebp]
  000b7	d8 5d 10	 fcomp	 DWORD PTR _b$[ebp]
  000ba	df e0		 fnstsw	 ax
  000bc	f6 c4 05	 test	 ah, 5
  000bf	7a 08		 jp	 SHORT $L199762
  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  000c4	89 4d d8	 mov	 DWORD PTR tv77[ebp], ecx
  000c7	eb 06		 jmp	 SHORT $L199763
$L199762:
  000c9	8b 55 10	 mov	 edx, DWORD PTR _b$[ebp]
  000cc	89 55 d8	 mov	 DWORD PTR tv77[ebp], edx
$L199763:
  000cf	8b 45 d8	 mov	 eax, DWORD PTR tv77[ebp]
  000d2	89 45 dc	 mov	 DWORD PTR tv78[ebp], eax
$L199765:
  000d5	8b 4d dc	 mov	 ecx, DWORD PTR tv78[ebp]
  000d8	89 4d fc	 mov	 DWORD PTR _cmin$[ebp], ecx

; 43   : 	*L = (cmax+cmin)/(float)2.0;

  000db	d9 45 f8	 fld	 DWORD PTR _cmax$[ebp]
  000de	d8 45 fc	 fadd	 DWORD PTR _cmin$[ebp]
  000e1	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@40000000
  000e7	8b 55 1c	 mov	 edx, DWORD PTR _L$[ebp]
  000ea	d9 1a		 fstp	 DWORD PTR [edx]

; 44   : 	if (cmax == cmin)

  000ec	d9 45 fc	 fld	 DWORD PTR _cmin$[ebp]
  000ef	d9 45 f8	 fld	 DWORD PTR _cmax$[ebp]
  000f2	da e9		 fucompp
  000f4	df e0		 fnstsw	 ax
  000f6	f6 c4 44	 test	 ah, 68			; 00000044H
  000f9	7a 17		 jp	 SHORT $L197596

; 45   : 	{
; 46   : 		*S = 0;

  000fb	8b 45 18	 mov	 eax, DWORD PTR _S$[ebp]
  000fe	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 47   : 		*H = 0; // it's really undefined

  00104	8b 4d 14	 mov	 ecx, DWORD PTR _H$[ebp]
  00107	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 48   : 	}
; 49   : 	else

  0010d	e9 d3 00 00 00	 jmp	 $L197591
$L197596:

; 50   : 	{
; 51   : 		if (*L < 0.5)

  00112	8b 55 1c	 mov	 edx, DWORD PTR _L$[ebp]
  00115	d9 02		 fld	 DWORD PTR [edx]
  00117	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3fe0000000000000
  0011d	df e0		 fnstsw	 ax
  0011f	f6 c4 05	 test	 ah, 5
  00122	7a 15		 jp	 SHORT $L197598

; 52   : 			*S = (cmax-cmin)/(cmax+cmin);

  00124	d9 45 f8	 fld	 DWORD PTR _cmax$[ebp]
  00127	d8 65 fc	 fsub	 DWORD PTR _cmin$[ebp]
  0012a	d9 45 f8	 fld	 DWORD PTR _cmax$[ebp]
  0012d	d8 45 fc	 fadd	 DWORD PTR _cmin$[ebp]
  00130	de f9		 fdivp	 ST(1), ST(0)
  00132	8b 45 18	 mov	 eax, DWORD PTR _S$[ebp]
  00135	d9 18		 fstp	 DWORD PTR [eax]

; 53   : 		else

  00137	eb 19		 jmp	 SHORT $L197599
$L197598:

; 54   : 			*S = (cmax-cmin)/((float)2.0-cmax-cmin);

  00139	d9 45 f8	 fld	 DWORD PTR _cmax$[ebp]
  0013c	d8 65 fc	 fsub	 DWORD PTR _cmin$[ebp]
  0013f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40000000
  00145	d8 65 f8	 fsub	 DWORD PTR _cmax$[ebp]
  00148	d8 65 fc	 fsub	 DWORD PTR _cmin$[ebp]
  0014b	de f9		 fdivp	 ST(1), ST(0)
  0014d	8b 4d 18	 mov	 ecx, DWORD PTR _S$[ebp]
  00150	d9 19		 fstp	 DWORD PTR [ecx]
$L197599:

; 55   : 
; 56   : 		//return ;
; 57   : 
; 58   : 		delta = cmax - cmin;

  00152	d9 45 f8	 fld	 DWORD PTR _cmax$[ebp]
  00155	d8 65 fc	 fsub	 DWORD PTR _cmin$[ebp]
  00158	d9 5d f4	 fstp	 DWORD PTR _delta$[ebp]

; 59   : 		if (r==cmax)

  0015b	d9 45 f8	 fld	 DWORD PTR _cmax$[ebp]
  0015e	d9 45 08	 fld	 DWORD PTR _r$[ebp]
  00161	da e9		 fucompp
  00163	df e0		 fnstsw	 ax
  00165	f6 c4 44	 test	 ah, 68			; 00000044H
  00168	7a 10		 jp	 SHORT $L197601

; 60   : 			*H = (g-b)/delta;

  0016a	d9 45 0c	 fld	 DWORD PTR _g$[ebp]
  0016d	d8 65 10	 fsub	 DWORD PTR _b$[ebp]
  00170	d8 75 f4	 fdiv	 DWORD PTR _delta$[ebp]
  00173	8b 55 14	 mov	 edx, DWORD PTR _H$[ebp]
  00176	d9 1a		 fstp	 DWORD PTR [edx]

; 61   : 		else if (g==cmax)

  00178	eb 39		 jmp	 SHORT $L197602
$L197601:
  0017a	d9 45 f8	 fld	 DWORD PTR _cmax$[ebp]
  0017d	d9 45 0c	 fld	 DWORD PTR _g$[ebp]
  00180	da e9		 fucompp
  00182	df e0		 fnstsw	 ax
  00184	f6 c4 44	 test	 ah, 68			; 00000044H
  00187	7a 16		 jp	 SHORT $L197603

; 62   : 			*H = (float)2.0 +(b-r)/delta;

  00189	d9 45 10	 fld	 DWORD PTR _b$[ebp]
  0018c	d8 65 08	 fsub	 DWORD PTR _r$[ebp]
  0018f	d8 75 f4	 fdiv	 DWORD PTR _delta$[ebp]
  00192	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@40000000
  00198	8b 45 14	 mov	 eax, DWORD PTR _H$[ebp]
  0019b	d9 18		 fstp	 DWORD PTR [eax]

; 63   : 		else

  0019d	eb 14		 jmp	 SHORT $L197602
$L197603:

; 64   : 			*H = (float)4.0+(r-g)/delta;

  0019f	d9 45 08	 fld	 DWORD PTR _r$[ebp]
  001a2	d8 65 0c	 fsub	 DWORD PTR _g$[ebp]
  001a5	d8 75 f4	 fdiv	 DWORD PTR _delta$[ebp]
  001a8	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@40800000
  001ae	8b 4d 14	 mov	 ecx, DWORD PTR _H$[ebp]
  001b1	d9 19		 fstp	 DWORD PTR [ecx]
$L197602:

; 65   : 		*H /= (float)6.0;

  001b3	8b 55 14	 mov	 edx, DWORD PTR _H$[ebp]
  001b6	d9 02		 fld	 DWORD PTR [edx]
  001b8	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@40c00000
  001be	8b 45 14	 mov	 eax, DWORD PTR _H$[ebp]
  001c1	d9 18		 fstp	 DWORD PTR [eax]

; 66   : 		if (*H < 0.0)

  001c3	8b 4d 14	 mov	 ecx, DWORD PTR _H$[ebp]
  001c6	d9 01		 fld	 DWORD PTR [ecx]
  001c8	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  001ce	df e0		 fnstsw	 ax
  001d0	f6 c4 05	 test	 ah, 5
  001d3	7a 10		 jp	 SHORT $L197591

; 67   : 			*H += 1;

  001d5	8b 55 14	 mov	 edx, DWORD PTR _H$[ebp]
  001d8	d9 02		 fld	 DWORD PTR [edx]
  001da	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  001e0	8b 45 14	 mov	 eax, DWORD PTR _H$[ebp]
  001e3	d9 18		 fstp	 DWORD PTR [eax]
$L197591:

; 68   : 	}
; 69   : }

  001e5	8b e5		 mov	 esp, ebp
  001e7	5d		 pop	 ebp
  001e8	c2 18 00	 ret	 24			; 00000018H
?RGBtoHSL@CBitMapOperate@@QAEXMMMPAM00@Z ENDP		; CBitMapOperate::RGBtoHSL
_TEXT	ENDS
PUBLIC	?changeColor@CBitMapOperate@@QAEXAAKKI@Z	; CBitMapOperate::changeColor
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -84						; size = 4
_lH$ = -80						; size = 8
_lS2$ = -72						; size = 8
_lR2$ = -64						; size = 4
_lB$ = -60						; size = 4
_c2$ = -56						; size = 4
_lR$ = -52						; size = 4
_lL2$ = -48						; size = 8
_lL$ = -40						; size = 8
_lG2$ = -28						; size = 4
_lH2$ = -24						; size = 8
_lB2$ = -16						; size = 4
_lG$ = -12						; size = 4
_lS$ = -8						; size = 8
_aColor$ = 8						; size = 4
_aBaseColor$ = 12					; size = 4
_anLightPos$ = 16					; size = 4
?changeColor@CBitMapOperate@@QAEXAAKKI@Z PROC NEAR	; CBitMapOperate::changeColor
; _this$ = ecx

; 480  : {

  00cb0	55		 push	 ebp
  00cb1	8b ec		 mov	 ebp, esp
  00cb3	83 ec 54	 sub	 esp, 84			; 00000054H
  00cb6	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 481  : 	COLORREF c2 = aColor;

  00cb9	8b 45 08	 mov	 eax, DWORD PTR _aColor$[ebp]
  00cbc	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cbe	89 4d c8	 mov	 DWORD PTR _c2$[ebp], ecx

; 482  : 
; 483  : 	int lR2,lG2,lB2;
; 484  : 	double lH2,lS2,lL2;
; 485  : 
; 486  : 	if(aColor == 0)

  00cc1	8b 55 08	 mov	 edx, DWORD PTR _aColor$[ebp]
  00cc4	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00cc7	75 05		 jne	 SHORT $L198574

; 487  : 		return;

  00cc9	e9 88 01 00 00	 jmp	 $L198566
$L198574:

; 488  : 
; 489  : 	if(aBaseColor == 0)

  00cce	83 7d 0c 00	 cmp	 DWORD PTR _aBaseColor$[ebp], 0
  00cd2	75 05		 jne	 SHORT $L198575

; 490  : 		return ;

  00cd4	e9 7d 01 00 00	 jmp	 $L198566
$L198575:

; 491  : 	lR2 = GetRValue(aBaseColor);

  00cd9	0f b6 45 0c	 movzx	 eax, BYTE PTR _aBaseColor$[ebp]
  00cdd	89 45 c0	 mov	 DWORD PTR _lR2$[ebp], eax

; 492  : 	lG2 = GetGValue(aBaseColor);

  00ce0	0f b7 4d 0c	 movzx	 ecx, WORD PTR _aBaseColor$[ebp]
  00ce4	c1 f9 08	 sar	 ecx, 8
  00ce7	0f b6 d1	 movzx	 edx, cl
  00cea	89 55 e4	 mov	 DWORD PTR _lG2$[ebp], edx

; 493  : 	lB2 = GetBValue(aBaseColor);

  00ced	8b 45 0c	 mov	 eax, DWORD PTR _aBaseColor$[ebp]
  00cf0	c1 e8 10	 shr	 eax, 16			; 00000010H
  00cf3	0f b6 c8	 movzx	 ecx, al
  00cf6	89 4d f0	 mov	 DWORD PTR _lB2$[ebp], ecx

; 494  : 	RGBtoHSL(RGB(lR2,lG2,lB2),&lH2,&lS2,&lL2);

  00cf9	8d 55 d0	 lea	 edx, DWORD PTR _lL2$[ebp]
  00cfc	52		 push	 edx
  00cfd	8d 45 b8	 lea	 eax, DWORD PTR _lS2$[ebp]
  00d00	50		 push	 eax
  00d01	8d 4d e8	 lea	 ecx, DWORD PTR _lH2$[ebp]
  00d04	51		 push	 ecx
  00d05	0f b6 55 c0	 movzx	 edx, BYTE PTR _lR2$[ebp]
  00d09	0f b6 45 e4	 movzx	 eax, BYTE PTR _lG2$[ebp]
  00d0d	c1 e0 08	 shl	 eax, 8
  00d10	0b d0		 or	 edx, eax
  00d12	0f b6 4d f0	 movzx	 ecx, BYTE PTR _lB2$[ebp]
  00d16	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00d19	0b d1		 or	 edx, ecx
  00d1b	52		 push	 edx
  00d1c	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00d1f	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ; CBitMapOperate::RGBtoHSL

; 495  : 
; 496  : 	int    lR,lG,lB;
; 497  : 	double lH,lS,lL;
; 498  : 	lR = GetRValue(aColor);

  00d24	8b 55 08	 mov	 edx, DWORD PTR _aColor$[ebp]
  00d27	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00d2a	89 45 cc	 mov	 DWORD PTR _lR$[ebp], eax

; 499  : 	lG = GetGValue(aColor);

  00d2d	8b 4d 08	 mov	 ecx, DWORD PTR _aColor$[ebp]
  00d30	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00d33	c1 fa 08	 sar	 edx, 8
  00d36	0f b6 c2	 movzx	 eax, dl
  00d39	89 45 f4	 mov	 DWORD PTR _lG$[ebp], eax

; 500  : 	lB = GetBValue(aColor);

  00d3c	8b 4d 08	 mov	 ecx, DWORD PTR _aColor$[ebp]
  00d3f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d41	c1 ea 10	 shr	 edx, 16			; 00000010H
  00d44	0f b6 c2	 movzx	 eax, dl
  00d47	89 45 c4	 mov	 DWORD PTR _lB$[ebp], eax

; 501  : 	RGBtoHSL(RGB(lR,lG,lB),&lH,&lS,&lL);

  00d4a	8d 4d d8	 lea	 ecx, DWORD PTR _lL$[ebp]
  00d4d	51		 push	 ecx
  00d4e	8d 55 f8	 lea	 edx, DWORD PTR _lS$[ebp]
  00d51	52		 push	 edx
  00d52	8d 45 b0	 lea	 eax, DWORD PTR _lH$[ebp]
  00d55	50		 push	 eax
  00d56	0f b6 4d cc	 movzx	 ecx, BYTE PTR _lR$[ebp]
  00d5a	0f b6 55 f4	 movzx	 edx, BYTE PTR _lG$[ebp]
  00d5e	c1 e2 08	 shl	 edx, 8
  00d61	0b ca		 or	 ecx, edx
  00d63	0f b6 45 c4	 movzx	 eax, BYTE PTR _lB$[ebp]
  00d67	c1 e0 10	 shl	 eax, 16			; 00000010H
  00d6a	0b c8		 or	 ecx, eax
  00d6c	51		 push	 ecx
  00d6d	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00d70	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ; CBitMapOperate::RGBtoHSL

; 502  : 
; 503  : 	lH = lH2;

  00d75	dd 45 e8	 fld	 QWORD PTR _lH2$[ebp]
  00d78	dd 5d b0	 fstp	 QWORD PTR _lH$[ebp]

; 504  : 	if(lH > 1.0)

  00d7b	dd 45 b0	 fld	 QWORD PTR _lH$[ebp]
  00d7e	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3ff0000000000000
  00d84	df e0		 fnstsw	 ax
  00d86	f6 c4 41	 test	 ah, 65			; 00000041H
  00d89	75 0c		 jne	 SHORT $L198602

; 505  : 		lH -= 1.0;

  00d8b	dd 45 b0	 fld	 QWORD PTR _lH$[ebp]
  00d8e	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  00d94	dd 5d b0	 fstp	 QWORD PTR _lH$[ebp]
$L198602:

; 506  : 	if(lH < 0)

  00d97	dd 45 b0	 fld	 QWORD PTR _lH$[ebp]
  00d9a	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  00da0	df e0		 fnstsw	 ax
  00da2	f6 c4 05	 test	 ah, 5
  00da5	7a 0c		 jp	 SHORT $L198603

; 507  : 		lH += 1.0;

  00da7	dd 45 b0	 fld	 QWORD PTR _lH$[ebp]
  00daa	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00db0	dd 5d b0	 fstp	 QWORD PTR _lH$[ebp]
$L198603:

; 508  : 
; 509  : 	lL = lL + (lL2 - 0.5)/4;

  00db3	dd 45 d0	 fld	 QWORD PTR _lL2$[ebp]
  00db6	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3fe0000000000000
  00dbc	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4010000000000000
  00dc2	dc 45 d8	 fadd	 QWORD PTR _lL$[ebp]
  00dc5	dd 5d d8	 fstp	 QWORD PTR _lL$[ebp]

; 510  : 	if(lL > 1.0)

  00dc8	dd 45 d8	 fld	 QWORD PTR _lL$[ebp]
  00dcb	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3ff0000000000000
  00dd1	df e0		 fnstsw	 ax
  00dd3	f6 c4 41	 test	 ah, 65			; 00000041H
  00dd6	75 09		 jne	 SHORT $L198604

; 511  : 		lL = 1.0;

  00dd8	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3ff0000000000000
  00dde	dd 5d d8	 fstp	 QWORD PTR _lL$[ebp]
$L198604:

; 512  : 	if(lL < 0)

  00de1	dd 45 d8	 fld	 QWORD PTR _lL$[ebp]
  00de4	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  00dea	df e0		 fnstsw	 ax
  00dec	f6 c4 05	 test	 ah, 5
  00def	7a 09		 jp	 SHORT $L198605

; 513  : 		lL = 0;

  00df1	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  00df7	dd 5d d8	 fstp	 QWORD PTR _lL$[ebp]
$L198605:

; 514  : 	lS = lS + (lS2 - 0.5) * 2;

  00dfa	dd 45 b8	 fld	 QWORD PTR _lS2$[ebp]
  00dfd	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3fe0000000000000
  00e03	dc c0		 fadd	 ST(0), ST(0)
  00e05	dc 45 f8	 fadd	 QWORD PTR _lS$[ebp]
  00e08	dd 5d f8	 fstp	 QWORD PTR _lS$[ebp]

; 515  : 	if(lS > 1.0)

  00e0b	dd 45 f8	 fld	 QWORD PTR _lS$[ebp]
  00e0e	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3ff0000000000000
  00e14	df e0		 fnstsw	 ax
  00e16	f6 c4 41	 test	 ah, 65			; 00000041H
  00e19	75 09		 jne	 SHORT $L198606

; 516  : 			lS = 1.0;

  00e1b	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3ff0000000000000
  00e21	dd 5d f8	 fstp	 QWORD PTR _lS$[ebp]
$L198606:

; 517  : 	if(lS < 0)

  00e24	dd 45 f8	 fld	 QWORD PTR _lS$[ebp]
  00e27	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  00e2d	df e0		 fnstsw	 ax
  00e2f	f6 c4 05	 test	 ah, 5
  00e32	7a 09		 jp	 SHORT $L198607

; 518  : 			lS = 0;

  00e34	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  00e3a	dd 5d f8	 fstp	 QWORD PTR _lS$[ebp]
$L198607:

; 519  : 
; 520  : 	aColor =  HLStoRGB(lH,lL,lS );

  00e3d	8d 4d f8	 lea	 ecx, DWORD PTR _lS$[ebp]
  00e40	51		 push	 ecx
  00e41	8d 55 d8	 lea	 edx, DWORD PTR _lL$[ebp]
  00e44	52		 push	 edx
  00e45	8d 45 b0	 lea	 eax, DWORD PTR _lH$[ebp]
  00e48	50		 push	 eax
  00e49	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00e4c	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z ; CBitMapOperate::HLStoRGB
  00e51	8b 4d 08	 mov	 ecx, DWORD PTR _aColor$[ebp]
  00e54	89 01		 mov	 DWORD PTR [ecx], eax
$L198566:

; 521  : }

  00e56	8b e5		 mov	 esp, ebp
  00e58	5d		 pop	 ebp
  00e59	c2 0c 00	 ret	 12			; 0000000cH
?changeColor@CBitMapOperate@@QAEXAAKKI@Z ENDP		; CBitMapOperate::changeColor
_TEXT	ENDS
PUBLIC	?CreateCompatibleDC@CDC@@QAEHPAV1@@Z		; CDC::CreateCompatibleDC
PUBLIC	??0CRect@@QAE@HHHH@Z				; CRect::CRect
PUBLIC	?GetPixel@CDC@@QBEKHH@Z				; CDC::GetPixel
PUBLIC	?SelectObject@CDC@@QAEPAXPAX@Z			; CDC::SelectObject
PUBLIC	?CreateRgnFromBitmap@CBitMapOperate@@QAEPAUHRGN__@@PAUHBITMAP__@@KPAVCWnd@@@Z ; CBitMapOperate::CreateRgnFromBitmap
EXTRN	?FromHandle@CDC@@SGPAV1@PAUHDC__@@@Z:NEAR	; CDC::FromHandle
EXTRN	??0CDC@@QAE@XZ:NEAR				; CDC::CDC
EXTRN	?DeleteDC@CDC@@QAEHXZ:NEAR			; CDC::DeleteDC
EXTRN	__imp__CombineRgn@16:NEAR
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	__imp__GetDC@4:NEAR
EXTRN	__imp__CreateRectRgn@16:NEAR
EXTRN	__imp__DeleteObject@4:NEAR
EXTRN	_memcpy:NEAR
EXTRN	??1CDC@@UAE@XZ:NEAR				; CDC::~CDC
xdata$x	SEGMENT
$T199779 DD	0ffffffffH
	DD	FLAT:$L199775
$T199777 DD	019930520H
	DD	01H
	DD	FLAT:$T199779
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -144						; size = 4
$T199774 = -140						; size = 4
$T199773 = -136						; size = 4
$T199772 = -132						; size = 4
$T199771 = -128						; size = 4
$T199770 = -124						; size = 16
$T199769 = -108						; size = 4
_hr$198665 = -104					; size = 4
_pRgnDataNew$198648 = -100				; size = 4
_j$ = -96						; size = 4
_RDHDR$ = -92						; size = 4
_bm$ = -88						; size = 24
_ismask$ = -61						; size = 1
_pRects$ = -60						; size = 4
_hRgn$ = -56						; size = 4
_dcBmp$ = -52						; size = 16
_MAXBUF$ = -36						; size = 4
_i$ = -32						; size = 4
_wasfirst$ = -25					; size = 1
_pRgnData$ = -24					; size = 4
_cBlocks$ = -20						; size = 4
_first$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hBmp$ = 8						; size = 4
_color$ = 12						; size = 4
_pWnd$ = 16						; size = 4
?CreateRgnFromBitmap@CBitMapOperate@@QAEPAUHRGN__@@PAUHBITMAP__@@KPAVCWnd@@@Z PROC NEAR ; CBitMapOperate::CreateRgnFromBitmap
; _this$ = ecx

; 524  : {

  00e60	55		 push	 ebp
  00e61	8b ec		 mov	 ebp, esp
  00e63	6a ff		 push	 -1
  00e65	68 00 00 00 00	 push	 __ehhandler$?CreateRgnFromBitmap@CBitMapOperate@@QAEPAUHRGN__@@PAUHBITMAP__@@KPAVCWnd@@@Z
  00e6a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00e70	50		 push	 eax
  00e71	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00e78	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00e7e	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 525  : 	if (!hBmp) return NULL;

  00e84	83 7d 08 00	 cmp	 DWORD PTR _hBmp$[ebp], 0
  00e88	75 07		 jne	 SHORT $L198614
  00e8a	33 c0		 xor	 eax, eax
  00e8c	e9 47 03 00 00	 jmp	 $L198613
$L198614:

; 526  : 	if(NULL == pWnd) return NULL;

  00e91	83 7d 10 00	 cmp	 DWORD PTR _pWnd$[ebp], 0
  00e95	75 07		 jne	 SHORT $L198615
  00e97	33 c0		 xor	 eax, eax
  00e99	e9 3a 03 00 00	 jmp	 $L198613
$L198615:

; 527  : 
; 528  : 	BITMAP bm;
; 529  : 	GetObject( hBmp, sizeof(BITMAP), &bm );	// get bitmap attributes

  00e9e	8d 45 a8	 lea	 eax, DWORD PTR _bm$[ebp]
  00ea1	50		 push	 eax
  00ea2	6a 18		 push	 24			; 00000018H
  00ea4	8b 4d 08	 mov	 ecx, DWORD PTR _hBmp$[ebp]
  00ea7	51		 push	 ecx
  00ea8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetObjectA@12

; 530  : 
; 531  : 	CDC dcBmp;

  00eae	8d 4d cc	 lea	 ecx, DWORD PTR _dcBmp$[ebp]
  00eb1	e8 00 00 00 00	 call	 ??0CDC@@QAE@XZ		; CDC::CDC
  00eb6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 532  : 	dcBmp.CreateCompatibleDC(CDC::FromHandle( GetDC(pWnd->m_hWnd) ));	//Creates a memory device context for the bitmap

  00ebd	8b 55 10	 mov	 edx, DWORD PTR _pWnd$[ebp]
  00ec0	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00ec3	50		 push	 eax
  00ec4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  00eca	50		 push	 eax
  00ecb	e8 00 00 00 00	 call	 ?FromHandle@CDC@@SGPAV1@PAUHDC__@@@Z ; CDC::FromHandle
  00ed0	50		 push	 eax
  00ed1	8d 4d cc	 lea	 ecx, DWORD PTR _dcBmp$[ebp]
  00ed4	e8 00 00 00 00	 call	 ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z ; CDC::CreateCompatibleDC

; 533  : 	dcBmp.SelectObject(hBmp);			//selects the bitmap in the device context

  00ed9	8b 4d 08	 mov	 ecx, DWORD PTR _hBmp$[ebp]
  00edc	51		 push	 ecx
  00edd	8d 4d cc	 lea	 ecx, DWORD PTR _dcBmp$[ebp]
  00ee0	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAXPAX@Z ; CDC::SelectObject

; 534  : 
; 535  : 	const DWORD RDHDR = sizeof(RGNDATAHEADER);

  00ee5	c7 45 a4 20 00
	00 00		 mov	 DWORD PTR _RDHDR$[ebp], 32 ; 00000020H

; 536  : 	const DWORD MAXBUF = 40;		// size of one block in RECTs

  00eec	c7 45 dc 28 00
	00 00		 mov	 DWORD PTR _MAXBUF$[ebp], 40 ; 00000028H

; 537  : 	// (i.e. MAXBUF*sizeof(RECT) in bytes)
; 538  : 	LPRECT	pRects;								
; 539  : 	DWORD	cBlocks = 0;			// number of allocated blocks

  00ef3	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _cBlocks$[ebp], 0

; 540  : 
; 541  : 	INT		i, j;					// current position in mask image
; 542  : 	INT		first = 0;				// left position of current scan line

  00efa	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _first$[ebp], 0

; 543  : 	// where mask was found
; 544  : 	bool	wasfirst = false;		// set when if mask was found in current scan line

  00f01	c6 45 e7 00	 mov	 BYTE PTR _wasfirst$[ebp], 0

; 545  : 	bool	ismask;					// set when current color is mask color
; 546  : 
; 547  : 	// allocate memory for region data
; 548  : 	RGNDATAHEADER* pRgnData = (RGNDATAHEADER*)new BYTE[ RDHDR + ++cBlocks * MAXBUF * sizeof(RECT) ];

  00f05	8b 55 ec	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  00f08	83 c2 01	 add	 edx, 1
  00f0b	89 55 ec	 mov	 DWORD PTR _cBlocks$[ebp], edx
  00f0e	8b 45 ec	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00f11	6b c0 28	 imul	 eax, 40			; 00000028H
  00f14	c1 e0 04	 shl	 eax, 4
  00f17	83 c0 20	 add	 eax, 32			; 00000020H
  00f1a	50		 push	 eax
  00f1b	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00f20	83 c4 04	 add	 esp, 4
  00f23	89 45 94	 mov	 DWORD PTR $T199769[ebp], eax
  00f26	8b 4d 94	 mov	 ecx, DWORD PTR $T199769[ebp]
  00f29	89 4d e8	 mov	 DWORD PTR _pRgnData$[ebp], ecx

; 549  : 	memset( pRgnData, 0, RDHDR + cBlocks * MAXBUF * sizeof(RECT) );

  00f2c	8b 55 ec	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  00f2f	6b d2 28	 imul	 edx, 40			; 00000028H
  00f32	c1 e2 04	 shl	 edx, 4
  00f35	83 c2 20	 add	 edx, 32			; 00000020H
  00f38	52		 push	 edx
  00f39	6a 00		 push	 0
  00f3b	8b 45 e8	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00f3e	50		 push	 eax
  00f3f	e8 00 00 00 00	 call	 _memset
  00f44	83 c4 0c	 add	 esp, 12			; 0000000cH

; 550  : 	// fill it by default
; 551  : 	pRgnData->dwSize	= RDHDR;

  00f47	8b 4d e8	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00f4a	c7 01 20 00 00
	00		 mov	 DWORD PTR [ecx], 32	; 00000020H

; 552  : 	pRgnData->iType		= RDH_RECTANGLES;

  00f50	8b 55 e8	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00f53	c7 42 04 01 00
	00 00		 mov	 DWORD PTR [edx+4], 1

; 553  : 	pRgnData->nCount	= 0;

  00f5a	8b 45 e8	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00f5d	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 554  : 	for ( i = 0; i < bm.bmHeight; i++ )

  00f64	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00f6b	eb 09		 jmp	 SHORT $L198635
$L198636:
  00f6d	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  00f70	83 c1 01	 add	 ecx, 1
  00f73	89 4d e0	 mov	 DWORD PTR _i$[ebp], ecx
$L198635:
  00f76	8b 55 e0	 mov	 edx, DWORD PTR _i$[ebp]
  00f79	3b 55 b0	 cmp	 edx, DWORD PTR _bm$[ebp+8]
  00f7c	0f 8d 7b 01 00
	00		 jge	 $L198637

; 555  : 		for ( j = 0; j < bm.bmWidth; j++ ){

  00f82	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00f89	eb 09		 jmp	 SHORT $L198638
$L198639:
  00f8b	8b 45 a0	 mov	 eax, DWORD PTR _j$[ebp]
  00f8e	83 c0 01	 add	 eax, 1
  00f91	89 45 a0	 mov	 DWORD PTR _j$[ebp], eax
$L198638:
  00f94	8b 4d a0	 mov	 ecx, DWORD PTR _j$[ebp]
  00f97	3b 4d ac	 cmp	 ecx, DWORD PTR _bm$[ebp+4]
  00f9a	0f 8d 58 01 00
	00		 jge	 $L198640

; 556  : 			// get color
; 557  : 			ismask=(dcBmp.GetPixel(j,bm.bmHeight-i-1)!=color);

  00fa0	8b 55 b0	 mov	 edx, DWORD PTR _bm$[ebp+8]
  00fa3	2b 55 e0	 sub	 edx, DWORD PTR _i$[ebp]
  00fa6	83 ea 01	 sub	 edx, 1
  00fa9	52		 push	 edx
  00faa	8b 45 a0	 mov	 eax, DWORD PTR _j$[ebp]
  00fad	50		 push	 eax
  00fae	8d 4d cc	 lea	 ecx, DWORD PTR _dcBmp$[ebp]
  00fb1	e8 00 00 00 00	 call	 ?GetPixel@CDC@@QBEKHH@Z	; CDC::GetPixel
  00fb6	33 c9		 xor	 ecx, ecx
  00fb8	3b 45 0c	 cmp	 eax, DWORD PTR _color$[ebp]
  00fbb	0f 95 c1	 setne	 cl
  00fbe	88 4d c3	 mov	 BYTE PTR _ismask$[ebp], cl

; 558  : 			// place part of scan line as RECT region if transparent color found after mask color or
; 559  : 			// mask color found at the end of mask image
; 560  : 			if (wasfirst && ((ismask && (j==(bm.bmWidth-1)))||(ismask ^ (j<bm.bmWidth)))){

  00fc1	0f b6 55 e7	 movzx	 edx, BYTE PTR _wasfirst$[ebp]
  00fc5	85 d2		 test	 edx, edx
  00fc7	0f 84 0c 01 00
	00		 je	 $L198641
  00fcd	0f b6 45 c3	 movzx	 eax, BYTE PTR _ismask$[ebp]
  00fd1	85 c0		 test	 eax, eax
  00fd3	74 0b		 je	 SHORT $L198643
  00fd5	8b 4d ac	 mov	 ecx, DWORD PTR _bm$[ebp+4]
  00fd8	83 e9 01	 sub	 ecx, 1
  00fdb	39 4d a0	 cmp	 DWORD PTR _j$[ebp], ecx
  00fde	74 17		 je	 SHORT $L198642
$L198643:
  00fe0	0f b6 55 c3	 movzx	 edx, BYTE PTR _ismask$[ebp]
  00fe4	8b 45 a0	 mov	 eax, DWORD PTR _j$[ebp]
  00fe7	33 c9		 xor	 ecx, ecx
  00fe9	3b 45 ac	 cmp	 eax, DWORD PTR _bm$[ebp+4]
  00fec	0f 9c c1	 setl	 cl
  00fef	33 d1		 xor	 edx, ecx
  00ff1	0f 84 e2 00 00
	00		 je	 $L198641
$L198642:

; 561  : 				// get offset to RECT array if RGNDATA buffer
; 562  : 				pRects = (LPRECT)((LPBYTE)pRgnData + RDHDR);

  00ff7	8b 55 e8	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00ffa	83 c2 20	 add	 edx, 32			; 00000020H
  00ffd	89 55 c4	 mov	 DWORD PTR _pRects$[ebp], edx

; 563  : 				// save current RECT
; 564  : 				pRects[ pRgnData->nCount++ ] = CRect( first, bm.bmHeight - i - 1, j+(j==(bm.bmWidth-1)), bm.bmHeight - i );

  01000	8b 45 b0	 mov	 eax, DWORD PTR _bm$[ebp+8]
  01003	2b 45 e0	 sub	 eax, DWORD PTR _i$[ebp]
  01006	50		 push	 eax
  01007	8b 4d ac	 mov	 ecx, DWORD PTR _bm$[ebp+4]
  0100a	83 e9 01	 sub	 ecx, 1
  0100d	33 d2		 xor	 edx, edx
  0100f	39 4d a0	 cmp	 DWORD PTR _j$[ebp], ecx
  01012	0f 94 c2	 sete	 dl
  01015	03 55 a0	 add	 edx, DWORD PTR _j$[ebp]
  01018	52		 push	 edx
  01019	8b 45 b0	 mov	 eax, DWORD PTR _bm$[ebp+8]
  0101c	2b 45 e0	 sub	 eax, DWORD PTR _i$[ebp]
  0101f	83 e8 01	 sub	 eax, 1
  01022	50		 push	 eax
  01023	8b 4d f0	 mov	 ecx, DWORD PTR _first$[ebp]
  01026	51		 push	 ecx
  01027	8d 4d 84	 lea	 ecx, DWORD PTR $T199770[ebp]
  0102a	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  0102f	8b 55 e8	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  01032	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  01035	c1 e1 04	 shl	 ecx, 4
  01038	03 4d c4	 add	 ecx, DWORD PTR _pRects$[ebp]
  0103b	8b 10		 mov	 edx, DWORD PTR [eax]
  0103d	89 11		 mov	 DWORD PTR [ecx], edx
  0103f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01042	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  01045	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  01048	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0104b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0104e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  01051	8b 4d e8	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  01054	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01057	83 c2 01	 add	 edx, 1
  0105a	8b 45 e8	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  0105d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 				// if buffer full reallocate it
; 566  : 				if ( pRgnData->nCount >= cBlocks * MAXBUF ){

  01060	8b 4d ec	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  01063	6b c9 28	 imul	 ecx, 40			; 00000028H
  01066	8b 55 e8	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  01069	39 4a 08	 cmp	 DWORD PTR [edx+8], ecx
  0106c	72 65		 jb	 SHORT $L198647

; 567  : 					LPBYTE pRgnDataNew = new BYTE[ RDHDR + ++cBlocks * MAXBUF * sizeof(RECT) ];

  0106e	8b 45 ec	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  01071	83 c0 01	 add	 eax, 1
  01074	89 45 ec	 mov	 DWORD PTR _cBlocks$[ebp], eax
  01077	8b 4d ec	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  0107a	6b c9 28	 imul	 ecx, 40			; 00000028H
  0107d	c1 e1 04	 shl	 ecx, 4
  01080	83 c1 20	 add	 ecx, 32			; 00000020H
  01083	51		 push	 ecx
  01084	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  01089	83 c4 04	 add	 esp, 4
  0108c	89 45 80	 mov	 DWORD PTR $T199771[ebp], eax
  0108f	8b 55 80	 mov	 edx, DWORD PTR $T199771[ebp]
  01092	89 55 9c	 mov	 DWORD PTR _pRgnDataNew$198648[ebp], edx

; 568  : 					memcpy( pRgnDataNew, pRgnData, RDHDR + (cBlocks - 1) * MAXBUF * sizeof(RECT) );

  01095	8b 45 ec	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  01098	83 e8 01	 sub	 eax, 1
  0109b	6b c0 28	 imul	 eax, 40			; 00000028H
  0109e	c1 e0 04	 shl	 eax, 4
  010a1	83 c0 20	 add	 eax, 32			; 00000020H
  010a4	50		 push	 eax
  010a5	8b 4d e8	 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  010a8	51		 push	 ecx
  010a9	8b 55 9c	 mov	 edx, DWORD PTR _pRgnDataNew$198648[ebp]
  010ac	52		 push	 edx
  010ad	e8 00 00 00 00	 call	 _memcpy
  010b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 569  : 					delete pRgnData;

  010b5	8b 45 e8	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  010b8	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T199772[ebp], eax
  010be	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR $T199772[ebp]
  010c4	51		 push	 ecx
  010c5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  010ca	83 c4 04	 add	 esp, 4

; 570  : 					pRgnData = (RGNDATAHEADER*)pRgnDataNew;

  010cd	8b 55 9c	 mov	 edx, DWORD PTR _pRgnDataNew$198648[ebp]
  010d0	89 55 e8	 mov	 DWORD PTR _pRgnData$[ebp], edx
$L198647:

; 571  : 				}
; 572  : 				wasfirst = false;

  010d3	c6 45 e7 00	 mov	 BYTE PTR _wasfirst$[ebp], 0

; 573  : 			} else if ( !wasfirst && ismask ){		// set wasfirst when mask is found

  010d7	eb 1a		 jmp	 SHORT $L198655
$L198641:
  010d9	0f b6 45 e7	 movzx	 eax, BYTE PTR _wasfirst$[ebp]
  010dd	85 c0		 test	 eax, eax
  010df	75 12		 jne	 SHORT $L198655
  010e1	0f b6 4d c3	 movzx	 ecx, BYTE PTR _ismask$[ebp]
  010e5	85 c9		 test	 ecx, ecx
  010e7	74 0a		 je	 SHORT $L198655

; 574  : 				first = j;

  010e9	8b 55 a0	 mov	 edx, DWORD PTR _j$[ebp]
  010ec	89 55 f0	 mov	 DWORD PTR _first$[ebp], edx

; 575  : 				wasfirst = true;

  010ef	c6 45 e7 01	 mov	 BYTE PTR _wasfirst$[ebp], 1
$L198655:

; 576  : 			}
; 577  : 		}

  010f3	e9 93 fe ff ff	 jmp	 $L198639
$L198640:
  010f8	e9 70 fe ff ff	 jmp	 $L198636
$L198637:

; 578  : 		dcBmp.DeleteDC();	//release the bitmap

  010fd	8d 4d cc	 lea	 ecx, DWORD PTR _dcBmp$[ebp]
  01100	e8 00 00 00 00	 call	 ?DeleteDC@CDC@@QAEHXZ	; CDC::DeleteDC

; 579  : 		// create region
; 580  : 		/*  Under WinNT the ExtCreateRegion returns NULL (by Fable@aramszu.net) */
; 581  : 		//	HRGN hRgn = ExtCreateRegion( NULL, RDHDR + pRgnData->nCount * sizeof(RECT), (LPRGNDATA)pRgnData );
; 582  : 		/* ExtCreateRegion replacement { */
; 583  : 		HRGN hRgn=CreateRectRgn(0, 0, 0, 0);

  01105	6a 00		 push	 0
  01107	6a 00		 push	 0
  01109	6a 00		 push	 0
  0110b	6a 00		 push	 0
  0110d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateRectRgn@16
  01113	89 45 c8	 mov	 DWORD PTR _hRgn$[ebp], eax

; 584  : 		ASSERT( hRgn!=NULL );
; 585  : 		pRects = (LPRECT)((LPBYTE)pRgnData + RDHDR);

  01116	8b 45 e8	 mov	 eax, DWORD PTR _pRgnData$[ebp]
  01119	83 c0 20	 add	 eax, 32			; 00000020H
  0111c	89 45 c4	 mov	 DWORD PTR _pRects$[ebp], eax

; 586  : 		for(i=0;i<(int)pRgnData->nCount;i++)

  0111f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01126	eb 09		 jmp	 SHORT $L198662
$L198663:
  01128	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  0112b	83 c1 01	 add	 ecx, 1
  0112e	89 4d e0	 mov	 DWORD PTR _i$[ebp], ecx
$L198662:
  01131	8b 55 e8	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  01134	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  01137	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0113a	7d 66		 jge	 SHORT $L198664

; 587  : 		{
; 588  : 			HRGN hr=CreateRectRgn(pRects[i].left, pRects[i].top, pRects[i].right, pRects[i].bottom);

  0113c	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  0113f	c1 e1 04	 shl	 ecx, 4
  01142	8b 55 c4	 mov	 edx, DWORD PTR _pRects$[ebp]
  01145	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  01149	50		 push	 eax
  0114a	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  0114d	c1 e1 04	 shl	 ecx, 4
  01150	8b 55 c4	 mov	 edx, DWORD PTR _pRects$[ebp]
  01153	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  01157	50		 push	 eax
  01158	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  0115b	c1 e1 04	 shl	 ecx, 4
  0115e	8b 55 c4	 mov	 edx, DWORD PTR _pRects$[ebp]
  01161	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  01165	50		 push	 eax
  01166	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  01169	c1 e1 04	 shl	 ecx, 4
  0116c	8b 55 c4	 mov	 edx, DWORD PTR _pRects$[ebp]
  0116f	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  01172	50		 push	 eax
  01173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateRectRgn@16
  01179	89 45 98	 mov	 DWORD PTR _hr$198665[ebp], eax

; 589  : 			VERIFY(CombineRgn(hRgn, hRgn, hr, RGN_OR)!=ERROR);

  0117c	6a 02		 push	 2
  0117e	8b 4d 98	 mov	 ecx, DWORD PTR _hr$198665[ebp]
  01181	51		 push	 ecx
  01182	8b 55 c8	 mov	 edx, DWORD PTR _hRgn$[ebp]
  01185	52		 push	 edx
  01186	8b 45 c8	 mov	 eax, DWORD PTR _hRgn$[ebp]
  01189	50		 push	 eax
  0118a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CombineRgn@16

; 590  : 			if (hr) DeleteObject(hr);

  01190	83 7d 98 00	 cmp	 DWORD PTR _hr$198665[ebp], 0
  01194	74 0a		 je	 SHORT $L198667
  01196	8b 4d 98	 mov	 ecx, DWORD PTR _hr$198665[ebp]
  01199	51		 push	 ecx
  0119a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$L198667:

; 591  : 		}

  011a0	eb 86		 jmp	 SHORT $L198663
$L198664:

; 592  : 		ASSERT( hRgn!=NULL );
; 593  : 		/* } ExtCreateRegion replacement */
; 594  : 
; 595  : 		delete pRgnData;

  011a2	8b 55 e8	 mov	 edx, DWORD PTR _pRgnData$[ebp]
  011a5	89 95 78 ff ff
	ff		 mov	 DWORD PTR $T199773[ebp], edx
  011ab	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T199773[ebp]
  011b1	50		 push	 eax
  011b2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  011b7	83 c4 04	 add	 esp, 4

; 596  : 		return hRgn;

  011ba	8b 4d c8	 mov	 ecx, DWORD PTR _hRgn$[ebp]
  011bd	89 8d 74 ff ff
	ff		 mov	 DWORD PTR $T199774[ebp], ecx
  011c3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  011ca	8d 4d cc	 lea	 ecx, DWORD PTR _dcBmp$[ebp]
  011cd	e8 00 00 00 00	 call	 ??1CDC@@UAE@XZ		; CDC::~CDC
  011d2	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T199774[ebp]
$L198613:

; 597  : }

  011d8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  011db	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  011e2	8b e5		 mov	 esp, ebp
  011e4	5d		 pop	 ebp
  011e5	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L199775:
  00015	8d 4d cc	 lea	 ecx, DWORD PTR _dcBmp$[ebp]
  00018	e9 00 00 00 00	 jmp	 ??1CDC@@UAE@XZ		; CDC::~CDC
__ehhandler$?CreateRgnFromBitmap@CBitMapOperate@@QAEPAUHRGN__@@PAUHBITMAP__@@KPAVCWnd@@@Z:
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199777
  00022	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreateRgnFromBitmap@CBitMapOperate@@QAEPAUHRGN__@@PAUHBITMAP__@@KPAVCWnd@@@Z ENDP ; CBitMapOperate::CreateRgnFromBitmap
EXTRN	__imp__CreateCompatibleBitmap@12:NEAR
EXTRN	__imp__CreateSolidBrush@4:NEAR
EXTRN	__imp__FillRect@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv373 = -152						; size = 4
tv367 = -148						; size = 8
tv350 = -140						; size = 4
tv344 = -136						; size = 8
tv329 = -128						; size = 8
tv327 = -120						; size = 4
tv322 = -116						; size = 8
tv320 = -108						; size = 4
tv317 = -104						; size = 8
tv315 = -96						; size = 4
tv83 = -92						; size = 4
tv81 = -88						; size = 4
tv77 = -84						; size = 4
_this$ = -80						; size = 4
_nCount$198734 = -76					; size = 4
_nCount$198719 = -72					; size = 4
_fRStep$198699 = -68					; size = 4
_hbrFill$198688 = -64					; size = 4
_fStep$198686 = -60					; size = 4
_fGStep$198703 = -56					; size = 4
_nR$198692 = -52					; size = 4
_nB$198697 = -48					; size = 4
_rect$198687 = -44					; size = 16
_fBStep$198709 = -28					; size = 4
_hdcMem$198713 = -24					; size = 4
_hbmpMem$198714 = -20					; size = 4
_hobjOld$198715 = -16					; size = 4
_nG$198694 = -12					; size = 4
_nHeight$198684 = -8					; size = 4
_nWidth$198683 = -4					; size = 4
_DC$ = 8						; size = 4
_aRect$ = 12						; size = 16
_aBeginColor$ = 28					; size = 4
_aEndColor$ = 32					; size = 4
_Orientation$ = 36					; size = 4
_abEclosion$ = 40					; size = 4
_anStep$ = 44						; size = 4
?FillRectangle@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKW4ENUM_DrawOrientation@1@HI@Z PROC NEAR ; CBitMapOperate::FillRectangle
; _this$ = ecx

; 599  : {

  011f0	55		 push	 ebp
  011f1	8b ec		 mov	 ebp, esp
  011f3	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  011f9	56		 push	 esi
  011fa	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 600  : 	if(aBeginColor == aEndColor)

  011fd	8b 45 1c	 mov	 eax, DWORD PTR _aBeginColor$[ebp]
  01200	3b 45 20	 cmp	 eax, DWORD PTR _aEndColor$[ebp]
  01203	75 38		 jne	 SHORT $L198681

; 601  : 	{
; 602  : 		FillRectangle(DC, aRect, aBeginColor,  abEclosion);

  01205	8b 4d 28	 mov	 ecx, DWORD PTR _abEclosion$[ebp]
  01208	51		 push	 ecx
  01209	8b 55 1c	 mov	 edx, DWORD PTR _aBeginColor$[ebp]
  0120c	52		 push	 edx
  0120d	83 ec 10	 sub	 esp, 16			; 00000010H
  01210	8b c4		 mov	 eax, esp
  01212	8b 4d 0c	 mov	 ecx, DWORD PTR _aRect$[ebp]
  01215	89 08		 mov	 DWORD PTR [eax], ecx
  01217	8b 55 10	 mov	 edx, DWORD PTR _aRect$[ebp+4]
  0121a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0121d	8b 4d 14	 mov	 ecx, DWORD PTR _aRect$[ebp+8]
  01220	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  01223	8b 55 18	 mov	 edx, DWORD PTR _aRect$[ebp+12]
  01226	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  01229	8b 45 08	 mov	 eax, DWORD PTR _DC$[ebp]
  0122c	50		 push	 eax
  0122d	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  01230	8b 11		 mov	 edx, DWORD PTR [ecx]
  01232	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  01235	ff 52 04	 call	 DWORD PTR [edx+4]

; 603  : 	}
; 604  : 	else

  01238	e9 6e 03 00 00	 jmp	 $L198680
$L198681:

; 605  : 	{
; 606  : 		int nWidth  = aRect.right  - aRect.left;

  0123d	8b 45 14	 mov	 eax, DWORD PTR _aRect$[ebp+8]
  01240	2b 45 0c	 sub	 eax, DWORD PTR _aRect$[ebp]
  01243	89 45 fc	 mov	 DWORD PTR _nWidth$198683[ebp], eax

; 607  : 		int nHeight = aRect.bottom - aRect.top;  

  01246	8b 4d 18	 mov	 ecx, DWORD PTR _aRect$[ebp+12]
  01249	2b 4d 10	 sub	 ecx, DWORD PTR _aRect$[ebp+4]
  0124c	89 4d f8	 mov	 DWORD PTR _nHeight$198684[ebp], ecx

; 608  : 		if(!(nWidth<=0|| nHeight<= 0))

  0124f	83 7d fc 00	 cmp	 DWORD PTR _nWidth$198683[ebp], 0
  01253	0f 8e 52 03 00
	00		 jle	 $L198680
  01259	83 7d f8 00	 cmp	 DWORD PTR _nHeight$198684[ebp], 0
  0125d	0f 8e 48 03 00
	00		 jle	 $L198680

; 609  : 		{
; 610  : 			float fStep;
; 611  : 			RECT rect;
; 612  : 			HBRUSH hbrFill;
; 613  : 			anStep = anStep == 1 ?  10:anStep;

  01263	83 7d 2c 01	 cmp	 DWORD PTR _anStep$[ebp], 1
  01267	75 09		 jne	 SHORT $L199781
  01269	c7 45 ac 0a 00
	00 00		 mov	 DWORD PTR tv77[ebp], 10	; 0000000aH
  01270	eb 06		 jmp	 SHORT $L199782
$L199781:
  01272	8b 55 2c	 mov	 edx, DWORD PTR _anStep$[ebp]
  01275	89 55 ac	 mov	 DWORD PTR tv77[ebp], edx
$L199782:
  01278	8b 45 ac	 mov	 eax, DWORD PTR tv77[ebp]
  0127b	89 45 2c	 mov	 DWORD PTR _anStep$[ebp], eax

; 614  : 			if( -1 == anStep)

  0127e	83 7d 2c ff	 cmp	 DWORD PTR _anStep$[ebp], -1
  01282	75 3e		 jne	 SHORT $L198689

; 615  : 			{
; 616  : 				if(true == Orientation)

  01284	83 7d 24 01	 cmp	 DWORD PTR _Orientation$[ebp], 1
  01288	75 1d		 jne	 SHORT $L198690

; 617  : 				{
; 618  : 					anStep = nHeight > 10 ? 10 : nHeight;

  0128a	83 7d f8 0a	 cmp	 DWORD PTR _nHeight$198684[ebp], 10 ; 0000000aH
  0128e	7e 09		 jle	 SHORT $L199783
  01290	c7 45 a8 0a 00
	00 00		 mov	 DWORD PTR tv81[ebp], 10	; 0000000aH
  01297	eb 06		 jmp	 SHORT $L199784
$L199783:
  01299	8b 4d f8	 mov	 ecx, DWORD PTR _nHeight$198684[ebp]
  0129c	89 4d a8	 mov	 DWORD PTR tv81[ebp], ecx
$L199784:
  0129f	8b 55 a8	 mov	 edx, DWORD PTR tv81[ebp]
  012a2	89 55 2c	 mov	 DWORD PTR _anStep$[ebp], edx

; 619  : 
; 620  : 				}
; 621  : 				else

  012a5	eb 1b		 jmp	 SHORT $L198689
$L198690:

; 622  : 				{
; 623  : 					anStep = nWidth >= 10 ? 10: nWidth;

  012a7	83 7d fc 0a	 cmp	 DWORD PTR _nWidth$198683[ebp], 10 ; 0000000aH
  012ab	7c 09		 jl	 SHORT $L199785
  012ad	c7 45 a4 0a 00
	00 00		 mov	 DWORD PTR tv83[ebp], 10	; 0000000aH
  012b4	eb 06		 jmp	 SHORT $L199786
$L199785:
  012b6	8b 45 fc	 mov	 eax, DWORD PTR _nWidth$198683[ebp]
  012b9	89 45 a4	 mov	 DWORD PTR tv83[ebp], eax
$L199786:
  012bc	8b 4d a4	 mov	 ecx, DWORD PTR tv83[ebp]
  012bf	89 4d 2c	 mov	 DWORD PTR _anStep$[ebp], ecx
$L198689:

; 624  : 				}
; 625  : 			}
; 626  : 
; 627  : 			int nR = GetRValue( aBeginColor );

  012c2	0f b6 55 1c	 movzx	 edx, BYTE PTR _aBeginColor$[ebp]
  012c6	89 55 cc	 mov	 DWORD PTR _nR$198692[ebp], edx

; 628  : 			int nG = GetGValue( aBeginColor );

  012c9	0f b7 45 1c	 movzx	 eax, WORD PTR _aBeginColor$[ebp]
  012cd	c1 f8 08	 sar	 eax, 8
  012d0	0f b6 c8	 movzx	 ecx, al
  012d3	89 4d f4	 mov	 DWORD PTR _nG$198694[ebp], ecx

; 629  : 			int nB = GetBValue( aBeginColor );

  012d6	8b 55 1c	 mov	 edx, DWORD PTR _aBeginColor$[ebp]
  012d9	c1 ea 10	 shr	 edx, 16			; 00000010H
  012dc	0f b6 c2	 movzx	 eax, dl
  012df	89 45 d0	 mov	 DWORD PTR _nB$198697[ebp], eax

; 630  : 
; 631  : 			float fRStep = ( GetRValue( aEndColor ) - GetRValue( aBeginColor ) ) / (float)anStep;

  012e2	0f b6 4d 20	 movzx	 ecx, BYTE PTR _aEndColor$[ebp]
  012e6	0f b6 55 1c	 movzx	 edx, BYTE PTR _aBeginColor$[ebp]
  012ea	2b ca		 sub	 ecx, edx
  012ec	89 4d a0	 mov	 DWORD PTR tv315[ebp], ecx
  012ef	db 45 a0	 fild	 DWORD PTR tv315[ebp]
  012f2	8b 45 2c	 mov	 eax, DWORD PTR _anStep$[ebp]
  012f5	89 45 98	 mov	 DWORD PTR tv317[ebp], eax
  012f8	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv317[ebp+4], 0
  012ff	df 6d 98	 fild	 QWORD PTR tv317[ebp]
  01302	de f9		 fdivp	 ST(1), ST(0)
  01304	d9 5d bc	 fstp	 DWORD PTR _fRStep$198699[ebp]

; 632  : 			float fGStep = ( GetGValue( aEndColor ) - GetGValue( aBeginColor ) ) / (float)anStep;

  01307	0f b7 4d 20	 movzx	 ecx, WORD PTR _aEndColor$[ebp]
  0130b	c1 f9 08	 sar	 ecx, 8
  0130e	0f b6 d1	 movzx	 edx, cl
  01311	0f b7 45 1c	 movzx	 eax, WORD PTR _aBeginColor$[ebp]
  01315	c1 f8 08	 sar	 eax, 8
  01318	0f b6 c8	 movzx	 ecx, al
  0131b	2b d1		 sub	 edx, ecx
  0131d	89 55 94	 mov	 DWORD PTR tv320[ebp], edx
  01320	db 45 94	 fild	 DWORD PTR tv320[ebp]
  01323	8b 55 2c	 mov	 edx, DWORD PTR _anStep$[ebp]
  01326	89 55 8c	 mov	 DWORD PTR tv322[ebp], edx
  01329	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv322[ebp+4], 0
  01330	df 6d 8c	 fild	 QWORD PTR tv322[ebp]
  01333	de f9		 fdivp	 ST(1), ST(0)
  01335	d9 5d c8	 fstp	 DWORD PTR _fGStep$198703[ebp]

; 633  : 			float fBStep = ( GetBValue( aEndColor ) - GetBValue( aBeginColor ) ) / (float)anStep;

  01338	8b 45 20	 mov	 eax, DWORD PTR _aEndColor$[ebp]
  0133b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0133e	0f b6 c8	 movzx	 ecx, al
  01341	8b 55 1c	 mov	 edx, DWORD PTR _aBeginColor$[ebp]
  01344	c1 ea 10	 shr	 edx, 16			; 00000010H
  01347	0f b6 c2	 movzx	 eax, dl
  0134a	2b c8		 sub	 ecx, eax
  0134c	89 4d 88	 mov	 DWORD PTR tv327[ebp], ecx
  0134f	db 45 88	 fild	 DWORD PTR tv327[ebp]
  01352	8b 4d 2c	 mov	 ecx, DWORD PTR _anStep$[ebp]
  01355	89 4d 80	 mov	 DWORD PTR tv329[ebp], ecx
  01358	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv329[ebp+4], 0
  0135f	df 6d 80	 fild	 QWORD PTR tv329[ebp]
  01362	de f9		 fdivp	 ST(1), ST(0)
  01364	d9 5d e4	 fstp	 DWORD PTR _fBStep$198709[ebp]

; 634  : 
; 635  : 			HDC hdcMem   = ::CreateCompatibleDC( DC );

  01367	8b 55 08	 mov	 edx, DWORD PTR _DC$[ebp]
  0136a	52		 push	 edx
  0136b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  01371	89 45 e8	 mov	 DWORD PTR _hdcMem$198713[ebp], eax

; 636  : 			HBITMAP hbmpMem  = ::CreateCompatibleBitmap( DC, nWidth, nHeight );

  01374	8b 45 f8	 mov	 eax, DWORD PTR _nHeight$198684[ebp]
  01377	50		 push	 eax
  01378	8b 4d fc	 mov	 ecx, DWORD PTR _nWidth$198683[ebp]
  0137b	51		 push	 ecx
  0137c	8b 55 08	 mov	 edx, DWORD PTR _DC$[ebp]
  0137f	52		 push	 edx
  01380	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  01386	89 45 ec	 mov	 DWORD PTR _hbmpMem$198714[ebp], eax

; 637  : 			HGDIOBJ hobjOld  = ::SelectObject( hdcMem, hbmpMem );

  01389	8b 45 ec	 mov	 eax, DWORD PTR _hbmpMem$198714[ebp]
  0138c	50		 push	 eax
  0138d	8b 4d e8	 mov	 ecx, DWORD PTR _hdcMem$198713[ebp]
  01390	51		 push	 ecx
  01391	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01397	89 45 f0	 mov	 DWORD PTR _hobjOld$198715[ebp], eax

; 638  : 
; 639  : 			rect.top = rect.left = 0;

  0139a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _rect$198687[ebp], 0
  013a1	8b 55 d4	 mov	 edx, DWORD PTR _rect$198687[ebp]
  013a4	89 55 d8	 mov	 DWORD PTR _rect$198687[ebp+4], edx

; 640  : 
; 641  : 			if ( Orientation )

  013a7	83 7d 24 00	 cmp	 DWORD PTR _Orientation$[ebp], 0
  013ab	0f 84 db 00 00
	00		 je	 $L198716

; 642  : 			{
; 643  : 				rect.right= nWidth;

  013b1	8b 45 fc	 mov	 eax, DWORD PTR _nWidth$198683[ebp]
  013b4	89 45 dc	 mov	 DWORD PTR _rect$198687[ebp+8], eax

; 644  : 				fStep= (float)nHeight / (float)anStep;

  013b7	db 45 f8	 fild	 DWORD PTR _nHeight$198684[ebp]
  013ba	8b 4d 2c	 mov	 ecx, DWORD PTR _anStep$[ebp]
  013bd	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv344[ebp], ecx
  013c3	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv344[ebp+4], 0
  013cd	df ad 78 ff ff
	ff		 fild	 QWORD PTR tv344[ebp]
  013d3	de f9		 fdivp	 ST(1), ST(0)
  013d5	d9 5d c4	 fstp	 DWORD PTR _fStep$198686[ebp]

; 645  : 
; 646  : 				for ( int nCount=0; nCount<=(int)anStep; nCount++ )

  013d8	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _nCount$198719[ebp], 0
  013df	eb 09		 jmp	 SHORT $L198721
$L198722:
  013e1	8b 55 b8	 mov	 edx, DWORD PTR _nCount$198719[ebp]
  013e4	83 c2 01	 add	 edx, 1
  013e7	89 55 b8	 mov	 DWORD PTR _nCount$198719[ebp], edx
$L198721:
  013ea	8b 45 b8	 mov	 eax, DWORD PTR _nCount$198719[ebp]
  013ed	3b 45 2c	 cmp	 eax, DWORD PTR _anStep$[ebp]
  013f0	0f 8f 91 00 00
	00		 jg	 $L198723

; 647  : 				{
; 648  : 					rect.bottom = (int)( (nCount+1) * fStep );

  013f6	8b 4d b8	 mov	 ecx, DWORD PTR _nCount$198719[ebp]
  013f9	83 c1 01	 add	 ecx, 1
  013fc	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv350[ebp], ecx
  01402	db 85 74 ff ff
	ff		 fild	 DWORD PTR tv350[ebp]
  01408	d8 4d c4	 fmul	 DWORD PTR _fStep$198686[ebp]
  0140b	e8 00 00 00 00	 call	 __ftol2
  01410	89 45 e0	 mov	 DWORD PTR _rect$198687[ebp+12], eax

; 649  : 
; 650  : 					hbrFill = ::CreateSolidBrush( RGB( nR+fRStep*nCount, nG+fGStep*nCount, nB+fBStep*nCount ) );

  01413	db 45 cc	 fild	 DWORD PTR _nR$198692[ebp]
  01416	db 45 b8	 fild	 DWORD PTR _nCount$198719[ebp]
  01419	d8 4d bc	 fmul	 DWORD PTR _fRStep$198699[ebp]
  0141c	de c1		 faddp	 ST(1), ST(0)
  0141e	e8 00 00 00 00	 call	 __ftol2
  01423	0f b6 f0	 movzx	 esi, al
  01426	db 45 f4	 fild	 DWORD PTR _nG$198694[ebp]
  01429	db 45 b8	 fild	 DWORD PTR _nCount$198719[ebp]
  0142c	d8 4d c8	 fmul	 DWORD PTR _fGStep$198703[ebp]
  0142f	de c1		 faddp	 ST(1), ST(0)
  01431	e8 00 00 00 00	 call	 __ftol2
  01436	0f b6 d0	 movzx	 edx, al
  01439	c1 e2 08	 shl	 edx, 8
  0143c	0b f2		 or	 esi, edx
  0143e	db 45 d0	 fild	 DWORD PTR _nB$198697[ebp]
  01441	db 45 b8	 fild	 DWORD PTR _nCount$198719[ebp]
  01444	d8 4d e4	 fmul	 DWORD PTR _fBStep$198709[ebp]
  01447	de c1		 faddp	 ST(1), ST(0)
  01449	e8 00 00 00 00	 call	 __ftol2
  0144e	0f b6 c0	 movzx	 eax, al
  01451	c1 e0 10	 shl	 eax, 16			; 00000010H
  01454	0b f0		 or	 esi, eax
  01456	56		 push	 esi
  01457	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  0145d	89 45 c0	 mov	 DWORD PTR _hbrFill$198688[ebp], eax

; 651  : 					::FillRect( hdcMem, &rect, hbrFill );

  01460	8b 4d c0	 mov	 ecx, DWORD PTR _hbrFill$198688[ebp]
  01463	51		 push	 ecx
  01464	8d 55 d4	 lea	 edx, DWORD PTR _rect$198687[ebp]
  01467	52		 push	 edx
  01468	8b 45 e8	 mov	 eax, DWORD PTR _hdcMem$198713[ebp]
  0146b	50		 push	 eax
  0146c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 652  : 					::DeleteObject( hbrFill );

  01472	8b 4d c0	 mov	 ecx, DWORD PTR _hbrFill$198688[ebp]
  01475	51		 push	 ecx
  01476	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 653  : 
; 654  : 					rect.top = rect.bottom;

  0147c	8b 55 e0	 mov	 edx, DWORD PTR _rect$198687[ebp+12]
  0147f	89 55 d8	 mov	 DWORD PTR _rect$198687[ebp+4], edx

; 655  : 				}

  01482	e9 5a ff ff ff	 jmp	 $L198722
$L198723:

; 656  : 			}
; 657  : 			else

  01487	e9 d6 00 00 00	 jmp	 $L198731
$L198716:

; 658  : 			{
; 659  : 				rect.bottom = nHeight;

  0148c	8b 45 f8	 mov	 eax, DWORD PTR _nHeight$198684[ebp]
  0148f	89 45 e0	 mov	 DWORD PTR _rect$198687[ebp+12], eax

; 660  : 				fStep= (float)nWidth / (float)anStep;

  01492	db 45 fc	 fild	 DWORD PTR _nWidth$198683[ebp]
  01495	8b 4d 2c	 mov	 ecx, DWORD PTR _anStep$[ebp]
  01498	89 8d 6c ff ff
	ff		 mov	 DWORD PTR tv367[ebp], ecx
  0149e	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv367[ebp+4], 0
  014a8	df ad 6c ff ff
	ff		 fild	 QWORD PTR tv367[ebp]
  014ae	de f9		 fdivp	 ST(1), ST(0)
  014b0	d9 5d c4	 fstp	 DWORD PTR _fStep$198686[ebp]

; 661  : 
; 662  : 				for ( int nCount=0; nCount<=(int)anStep; nCount++ )

  014b3	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _nCount$198734[ebp], 0
  014ba	eb 09		 jmp	 SHORT $L198736
$L198737:
  014bc	8b 55 b4	 mov	 edx, DWORD PTR _nCount$198734[ebp]
  014bf	83 c2 01	 add	 edx, 1
  014c2	89 55 b4	 mov	 DWORD PTR _nCount$198734[ebp], edx
$L198736:
  014c5	8b 45 b4	 mov	 eax, DWORD PTR _nCount$198734[ebp]
  014c8	3b 45 2c	 cmp	 eax, DWORD PTR _anStep$[ebp]
  014cb	0f 8f 91 00 00
	00		 jg	 $L198731

; 663  : 				{
; 664  : 					rect.right= (int)( (nCount+1) * fStep );

  014d1	8b 4d b4	 mov	 ecx, DWORD PTR _nCount$198734[ebp]
  014d4	83 c1 01	 add	 ecx, 1
  014d7	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv373[ebp], ecx
  014dd	db 85 68 ff ff
	ff		 fild	 DWORD PTR tv373[ebp]
  014e3	d8 4d c4	 fmul	 DWORD PTR _fStep$198686[ebp]
  014e6	e8 00 00 00 00	 call	 __ftol2
  014eb	89 45 dc	 mov	 DWORD PTR _rect$198687[ebp+8], eax

; 665  : 
; 666  : 					hbrFill = ::CreateSolidBrush( RGB( nR+fRStep*nCount, nG+fGStep*nCount, nB+fBStep*nCount ) );

  014ee	db 45 cc	 fild	 DWORD PTR _nR$198692[ebp]
  014f1	db 45 b4	 fild	 DWORD PTR _nCount$198734[ebp]
  014f4	d8 4d bc	 fmul	 DWORD PTR _fRStep$198699[ebp]
  014f7	de c1		 faddp	 ST(1), ST(0)
  014f9	e8 00 00 00 00	 call	 __ftol2
  014fe	0f b6 f0	 movzx	 esi, al
  01501	db 45 f4	 fild	 DWORD PTR _nG$198694[ebp]
  01504	db 45 b4	 fild	 DWORD PTR _nCount$198734[ebp]
  01507	d8 4d c8	 fmul	 DWORD PTR _fGStep$198703[ebp]
  0150a	de c1		 faddp	 ST(1), ST(0)
  0150c	e8 00 00 00 00	 call	 __ftol2
  01511	0f b6 d0	 movzx	 edx, al
  01514	c1 e2 08	 shl	 edx, 8
  01517	0b f2		 or	 esi, edx
  01519	db 45 d0	 fild	 DWORD PTR _nB$198697[ebp]
  0151c	db 45 b4	 fild	 DWORD PTR _nCount$198734[ebp]
  0151f	d8 4d e4	 fmul	 DWORD PTR _fBStep$198709[ebp]
  01522	de c1		 faddp	 ST(1), ST(0)
  01524	e8 00 00 00 00	 call	 __ftol2
  01529	0f b6 c0	 movzx	 eax, al
  0152c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0152f	0b f0		 or	 esi, eax
  01531	56		 push	 esi
  01532	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  01538	89 45 c0	 mov	 DWORD PTR _hbrFill$198688[ebp], eax

; 667  : 					::FillRect( hdcMem, &rect, hbrFill );

  0153b	8b 4d c0	 mov	 ecx, DWORD PTR _hbrFill$198688[ebp]
  0153e	51		 push	 ecx
  0153f	8d 55 d4	 lea	 edx, DWORD PTR _rect$198687[ebp]
  01542	52		 push	 edx
  01543	8b 45 e8	 mov	 eax, DWORD PTR _hdcMem$198713[ebp]
  01546	50		 push	 eax
  01547	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 668  : 					::DeleteObject( hbrFill );

  0154d	8b 4d c0	 mov	 ecx, DWORD PTR _hbrFill$198688[ebp]
  01550	51		 push	 ecx
  01551	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 669  : 
; 670  : 					rect.left = rect.right;

  01557	8b 55 dc	 mov	 edx, DWORD PTR _rect$198687[ebp+8]
  0155a	89 55 d4	 mov	 DWORD PTR _rect$198687[ebp], edx

; 671  : 				}

  0155d	e9 5a ff ff ff	 jmp	 $L198737
$L198731:

; 672  : 			}
; 673  : 
; 674  : 			::BitBlt( DC, aRect.left, aRect.top, nWidth, nHeight, hdcMem, 0, 0, SRCCOPY );

  01562	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01567	6a 00		 push	 0
  01569	6a 00		 push	 0
  0156b	8b 45 e8	 mov	 eax, DWORD PTR _hdcMem$198713[ebp]
  0156e	50		 push	 eax
  0156f	8b 4d f8	 mov	 ecx, DWORD PTR _nHeight$198684[ebp]
  01572	51		 push	 ecx
  01573	8b 55 fc	 mov	 edx, DWORD PTR _nWidth$198683[ebp]
  01576	52		 push	 edx
  01577	8b 45 10	 mov	 eax, DWORD PTR _aRect$[ebp+4]
  0157a	50		 push	 eax
  0157b	8b 4d 0c	 mov	 ecx, DWORD PTR _aRect$[ebp]
  0157e	51		 push	 ecx
  0157f	8b 55 08	 mov	 edx, DWORD PTR _DC$[ebp]
  01582	52		 push	 edx
  01583	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 675  : 
; 676  : 			::SelectObject( hdcMem, hobjOld );

  01589	8b 45 f0	 mov	 eax, DWORD PTR _hobjOld$198715[ebp]
  0158c	50		 push	 eax
  0158d	8b 4d e8	 mov	 ecx, DWORD PTR _hdcMem$198713[ebp]
  01590	51		 push	 ecx
  01591	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 677  : 			::DeleteObject( hbmpMem );

  01597	8b 55 ec	 mov	 edx, DWORD PTR _hbmpMem$198714[ebp]
  0159a	52		 push	 edx
  0159b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 678  : 			::DeleteDC( hdcMem );

  015a1	8b 45 e8	 mov	 eax, DWORD PTR _hdcMem$198713[ebp]
  015a4	50		 push	 eax
  015a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$L198680:

; 679  : 		}
; 680  : 	}
; 681  : }

  015ab	5e		 pop	 esi
  015ac	8b e5		 mov	 esp, ebp
  015ae	5d		 pop	 ebp
  015af	c2 28 00	 ret	 40			; 00000028H
?FillRectangle@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKW4ENUM_DrawOrientation@1@HI@Z ENDP ; CBitMapOperate::FillRectangle
_TEXT	ENDS
PUBLIC	__real@406e000000000000
PUBLIC	__real@43700000
;	COMDAT __real@406e000000000000
CONST	SEGMENT
__real@406e000000000000 DQ 0406e000000000000r	; 240
CONST	ENDS
;	COMDAT __real@43700000
CONST	SEGMENT
__real@43700000 DD 043700000r			; 240
; Function compile flags: /Odt
CONST	ENDS
_TEXT	SEGMENT
tv348 = -232						; size = 4
tv342 = -228						; size = 8
tv324 = -220						; size = 4
tv318 = -216						; size = 8
tv301 = -208						; size = 8
tv83 = -200						; size = 4
tv81 = -196						; size = 4
tv77 = -192						; size = 4
_this$ = -188						; size = 4
$T199799 = -184						; size = 8
$T199798 = -176						; size = 8
$T199797 = -168						; size = 8
$T199796 = -160						; size = 8
$T199795 = -152						; size = 8
$T199794 = -144						; size = 8
_col$198826 = -136					; size = 4
_nCount$198821 = -132					; size = 4
_nCount$198808 = -128					; size = 4
_fHStep$198800 = -124					; size = 4
_lH1$198771 = -120					; size = 8
_lS2$198788 = -112					; size = 8
_hbrFill$198764 = -104					; size = 4
_lR2$198784 = -100					; size = 4
_fStep$198762 = -96					; size = 4
_lR1$198768 = -92					; size = 4
_lL1$198773 = -88					; size = 8
_lS1$198772 = -80					; size = 8
_lL2$198789 = -72					; size = 8
_lG2$198785 = -64					; size = 4
_lB1$198770 = -60					; size = 4
_lH2$198787 = -56					; size = 8
_rect$198763 = -44					; size = 16
_lG1$198769 = -28					; size = 4
_hdcMem$198802 = -24					; size = 4
_hbmpMem$198803 = -20					; size = 4
_hobjOld$198804 = -16					; size = 4
_lB2$198786 = -12					; size = 4
_nHeight$198760 = -8					; size = 4
_nWidth$198759 = -4					; size = 4
_DC$ = 8						; size = 4
_aRect$ = 12						; size = 16
_aBeginColor$ = 28					; size = 4
_aEndColor$ = 32					; size = 4
_Orientation$ = 36					; size = 4
_abEclosion$ = 40					; size = 4
_anStep$ = 44						; size = 4
?FillRectangleHue@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKW4ENUM_DrawOrientation@1@HI@Z PROC NEAR ; CBitMapOperate::FillRectangleHue
; _this$ = ecx

; 683  : {

  015c0	55		 push	 ebp
  015c1	8b ec		 mov	 ebp, esp
  015c3	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  015c9	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 684  : 	if(aBeginColor == aEndColor)

  015cf	8b 45 1c	 mov	 eax, DWORD PTR _aBeginColor$[ebp]
  015d2	3b 45 20	 cmp	 eax, DWORD PTR _aEndColor$[ebp]
  015d5	75 3e		 jne	 SHORT $L198757

; 685  : 	{
; 686  : 		FillRectangle(DC, aRect, aBeginColor,  abEclosion);

  015d7	8b 4d 28	 mov	 ecx, DWORD PTR _abEclosion$[ebp]
  015da	51		 push	 ecx
  015db	8b 55 1c	 mov	 edx, DWORD PTR _aBeginColor$[ebp]
  015de	52		 push	 edx
  015df	83 ec 10	 sub	 esp, 16			; 00000010H
  015e2	8b c4		 mov	 eax, esp
  015e4	8b 4d 0c	 mov	 ecx, DWORD PTR _aRect$[ebp]
  015e7	89 08		 mov	 DWORD PTR [eax], ecx
  015e9	8b 55 10	 mov	 edx, DWORD PTR _aRect$[ebp+4]
  015ec	89 50 04	 mov	 DWORD PTR [eax+4], edx
  015ef	8b 4d 14	 mov	 ecx, DWORD PTR _aRect$[ebp+8]
  015f2	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  015f5	8b 55 18	 mov	 edx, DWORD PTR _aRect$[ebp+12]
  015f8	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  015fb	8b 45 08	 mov	 eax, DWORD PTR _DC$[ebp]
  015fe	50		 push	 eax
  015ff	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01605	8b 11		 mov	 edx, DWORD PTR [ecx]
  01607	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0160d	ff 52 04	 call	 DWORD PTR [edx+4]

; 687  : 	}
; 688  : 	else

  01610	e9 d4 03 00 00	 jmp	 $L198756
$L198757:

; 689  : 	{
; 690  : 		int nWidth  = aRect.right  - aRect.left;

  01615	8b 45 14	 mov	 eax, DWORD PTR _aRect$[ebp+8]
  01618	2b 45 0c	 sub	 eax, DWORD PTR _aRect$[ebp]
  0161b	89 45 fc	 mov	 DWORD PTR _nWidth$198759[ebp], eax

; 691  : 		int nHeight = aRect.bottom - aRect.top;  

  0161e	8b 4d 18	 mov	 ecx, DWORD PTR _aRect$[ebp+12]
  01621	2b 4d 10	 sub	 ecx, DWORD PTR _aRect$[ebp+4]
  01624	89 4d f8	 mov	 DWORD PTR _nHeight$198760[ebp], ecx

; 692  : 		if(!(nWidth<=0|| nHeight<= 0))

  01627	83 7d fc 00	 cmp	 DWORD PTR _nWidth$198759[ebp], 0
  0162b	0f 8e b8 03 00
	00		 jle	 $L198756
  01631	83 7d f8 00	 cmp	 DWORD PTR _nHeight$198760[ebp], 0
  01635	0f 8e ae 03 00
	00		 jle	 $L198756

; 693  : 		{
; 694  : 			float fStep;
; 695  : 			RECT rect;
; 696  : 			HBRUSH hbrFill;
; 697  : 			anStep = anStep == 1 ?  10:anStep;

  0163b	83 7d 2c 01	 cmp	 DWORD PTR _anStep$[ebp], 1
  0163f	75 0c		 jne	 SHORT $L199788
  01641	c7 85 40 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv77[ebp], 10	; 0000000aH
  0164b	eb 09		 jmp	 SHORT $L199789
$L199788:
  0164d	8b 55 2c	 mov	 edx, DWORD PTR _anStep$[ebp]
  01650	89 95 40 ff ff
	ff		 mov	 DWORD PTR tv77[ebp], edx
$L199789:
  01656	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv77[ebp]
  0165c	89 45 2c	 mov	 DWORD PTR _anStep$[ebp], eax

; 698  : 			if( -1 == anStep)

  0165f	83 7d 2c ff	 cmp	 DWORD PTR _anStep$[ebp], -1
  01663	75 50		 jne	 SHORT $L198765

; 699  : 			{
; 700  : 				if(true == Orientation)

  01665	83 7d 24 01	 cmp	 DWORD PTR _Orientation$[ebp], 1
  01669	75 26		 jne	 SHORT $L198766

; 701  : 				{
; 702  : 					anStep = nHeight > 10 ? 10 : nHeight;

  0166b	83 7d f8 0a	 cmp	 DWORD PTR _nHeight$198760[ebp], 10 ; 0000000aH
  0166f	7e 0c		 jle	 SHORT $L199790
  01671	c7 85 3c ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv81[ebp], 10	; 0000000aH
  0167b	eb 09		 jmp	 SHORT $L199791
$L199790:
  0167d	8b 4d f8	 mov	 ecx, DWORD PTR _nHeight$198760[ebp]
  01680	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
$L199791:
  01686	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv81[ebp]
  0168c	89 55 2c	 mov	 DWORD PTR _anStep$[ebp], edx

; 703  : 
; 704  : 				}
; 705  : 				else

  0168f	eb 24		 jmp	 SHORT $L198765
$L198766:

; 706  : 				{
; 707  : 					anStep = nWidth >= 10 ? 10: nWidth;

  01691	83 7d fc 0a	 cmp	 DWORD PTR _nWidth$198759[ebp], 10 ; 0000000aH
  01695	7c 0c		 jl	 SHORT $L199792
  01697	c7 85 38 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv83[ebp], 10	; 0000000aH
  016a1	eb 09		 jmp	 SHORT $L199793
$L199792:
  016a3	8b 45 fc	 mov	 eax, DWORD PTR _nWidth$198759[ebp]
  016a6	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv83[ebp], eax
$L199793:
  016ac	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv83[ebp]
  016b2	89 4d 2c	 mov	 DWORD PTR _anStep$[ebp], ecx
$L198765:

; 708  : 				}
; 709  : 			}
; 710  : 
; 711  : 			int    lR1,lG1,lB1;
; 712  : 			double lH1,lS1,lL1;
; 713  : 			lR1 = GetRValue( aBeginColor );

  016b5	0f b6 55 1c	 movzx	 edx, BYTE PTR _aBeginColor$[ebp]
  016b9	89 55 a4	 mov	 DWORD PTR _lR1$198768[ebp], edx

; 714  : 			lG1 = GetGValue( aBeginColor );

  016bc	0f b7 45 1c	 movzx	 eax, WORD PTR _aBeginColor$[ebp]
  016c0	c1 f8 08	 sar	 eax, 8
  016c3	0f b6 c8	 movzx	 ecx, al
  016c6	89 4d e4	 mov	 DWORD PTR _lG1$198769[ebp], ecx

; 715  : 			lB1 = GetBValue( aBeginColor );

  016c9	8b 55 1c	 mov	 edx, DWORD PTR _aBeginColor$[ebp]
  016cc	c1 ea 10	 shr	 edx, 16			; 00000010H
  016cf	0f b6 c2	 movzx	 eax, dl
  016d2	89 45 c4	 mov	 DWORD PTR _lB1$198770[ebp], eax

; 716  : 			RGBtoHSL(RGB(lR1,lG1,lB1),&lH1,&lS1,&lL1);

  016d5	8d 4d a8	 lea	 ecx, DWORD PTR _lL1$198773[ebp]
  016d8	51		 push	 ecx
  016d9	8d 55 b0	 lea	 edx, DWORD PTR _lS1$198772[ebp]
  016dc	52		 push	 edx
  016dd	8d 45 88	 lea	 eax, DWORD PTR _lH1$198771[ebp]
  016e0	50		 push	 eax
  016e1	0f b6 4d a4	 movzx	 ecx, BYTE PTR _lR1$198768[ebp]
  016e5	0f b6 55 e4	 movzx	 edx, BYTE PTR _lG1$198769[ebp]
  016e9	c1 e2 08	 shl	 edx, 8
  016ec	0b ca		 or	 ecx, edx
  016ee	0f b6 45 c4	 movzx	 eax, BYTE PTR _lB1$198770[ebp]
  016f2	c1 e0 10	 shl	 eax, 16			; 00000010H
  016f5	0b c8		 or	 ecx, eax
  016f7	51		 push	 ecx
  016f8	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  016fe	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ; CBitMapOperate::RGBtoHSL

; 717  : 
; 718  : 			int    lR2,lG2,lB2;
; 719  : 			double lH2,lS2,lL2;
; 720  : 			lR2 = GetRValue( aEndColor );

  01703	0f b6 4d 20	 movzx	 ecx, BYTE PTR _aEndColor$[ebp]
  01707	89 4d 9c	 mov	 DWORD PTR _lR2$198784[ebp], ecx

; 721  : 			lG2 = GetGValue( aEndColor );

  0170a	0f b7 55 20	 movzx	 edx, WORD PTR _aEndColor$[ebp]
  0170e	c1 fa 08	 sar	 edx, 8
  01711	0f b6 c2	 movzx	 eax, dl
  01714	89 45 c0	 mov	 DWORD PTR _lG2$198785[ebp], eax

; 722  : 			lB2 = GetBValue( aEndColor );

  01717	8b 4d 20	 mov	 ecx, DWORD PTR _aEndColor$[ebp]
  0171a	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0171d	0f b6 d1	 movzx	 edx, cl
  01720	89 55 f4	 mov	 DWORD PTR _lB2$198786[ebp], edx

; 723  : 			RGBtoHSL(RGB(lR2,lG2,lB2),&lH2,&lS2,&lL2);

  01723	8d 45 b8	 lea	 eax, DWORD PTR _lL2$198789[ebp]
  01726	50		 push	 eax
  01727	8d 4d 90	 lea	 ecx, DWORD PTR _lS2$198788[ebp]
  0172a	51		 push	 ecx
  0172b	8d 55 c8	 lea	 edx, DWORD PTR _lH2$198787[ebp]
  0172e	52		 push	 edx
  0172f	0f b6 45 9c	 movzx	 eax, BYTE PTR _lR2$198784[ebp]
  01733	0f b6 4d c0	 movzx	 ecx, BYTE PTR _lG2$198785[ebp]
  01737	c1 e1 08	 shl	 ecx, 8
  0173a	0b c1		 or	 eax, ecx
  0173c	0f b6 55 f4	 movzx	 edx, BYTE PTR _lB2$198786[ebp]
  01740	c1 e2 10	 shl	 edx, 16			; 00000010H
  01743	0b c2		 or	 eax, edx
  01745	50		 push	 eax
  01746	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0174c	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ; CBitMapOperate::RGBtoHSL

; 724  : 
; 725  : 			float fHStep = (1.0 )*240 / (float)anStep;

  01751	8b 45 2c	 mov	 eax, DWORD PTR _anStep$[ebp]
  01754	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv301[ebp], eax
  0175a	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv301[ebp+4], 0
  01764	df ad 30 ff ff
	ff		 fild	 QWORD PTR tv301[ebp]
  0176a	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@406e000000000000
  01770	d9 5d 84	 fstp	 DWORD PTR _fHStep$198800[ebp]

; 726  : 			HDC hdcMem   = ::CreateCompatibleDC( DC );

  01773	8b 4d 08	 mov	 ecx, DWORD PTR _DC$[ebp]
  01776	51		 push	 ecx
  01777	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  0177d	89 45 e8	 mov	 DWORD PTR _hdcMem$198802[ebp], eax

; 727  : 			HBITMAP hbmpMem  = ::CreateCompatibleBitmap( DC, nWidth, nHeight );

  01780	8b 55 f8	 mov	 edx, DWORD PTR _nHeight$198760[ebp]
  01783	52		 push	 edx
  01784	8b 45 fc	 mov	 eax, DWORD PTR _nWidth$198759[ebp]
  01787	50		 push	 eax
  01788	8b 4d 08	 mov	 ecx, DWORD PTR _DC$[ebp]
  0178b	51		 push	 ecx
  0178c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  01792	89 45 ec	 mov	 DWORD PTR _hbmpMem$198803[ebp], eax

; 728  : 			HGDIOBJ hobjOld  = ::SelectObject( hdcMem, hbmpMem );

  01795	8b 55 ec	 mov	 edx, DWORD PTR _hbmpMem$198803[ebp]
  01798	52		 push	 edx
  01799	8b 45 e8	 mov	 eax, DWORD PTR _hdcMem$198802[ebp]
  0179c	50		 push	 eax
  0179d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  017a3	89 45 f0	 mov	 DWORD PTR _hobjOld$198804[ebp], eax

; 729  : 
; 730  : 			rect.top = rect.left = 0;

  017a6	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _rect$198763[ebp], 0
  017ad	8b 4d d4	 mov	 ecx, DWORD PTR _rect$198763[ebp]
  017b0	89 4d d8	 mov	 DWORD PTR _rect$198763[ebp+4], ecx

; 731  : 
; 732  : 			if ( Orientation )

  017b3	83 7d 24 00	 cmp	 DWORD PTR _Orientation$[ebp], 0
  017b7	0f 84 e5 00 00
	00		 je	 $L198805

; 733  : 			{
; 734  : 				rect.right= nWidth;

  017bd	8b 55 fc	 mov	 edx, DWORD PTR _nWidth$198759[ebp]
  017c0	89 55 dc	 mov	 DWORD PTR _rect$198763[ebp+8], edx

; 735  : 				fStep= (float)nHeight / (float)anStep;

  017c3	db 45 f8	 fild	 DWORD PTR _nHeight$198760[ebp]
  017c6	8b 45 2c	 mov	 eax, DWORD PTR _anStep$[ebp]
  017c9	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv318[ebp], eax
  017cf	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv318[ebp+4], 0
  017d9	df ad 28 ff ff
	ff		 fild	 QWORD PTR tv318[ebp]
  017df	de f9		 fdivp	 ST(1), ST(0)
  017e1	d9 5d a0	 fstp	 DWORD PTR _fStep$198762[ebp]

; 736  : 
; 737  : 				for ( int nCount=0; nCount<=(int)anStep; nCount++ )

  017e4	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _nCount$198808[ebp], 0
  017eb	eb 09		 jmp	 SHORT $L198810
$L198811:
  017ed	8b 4d 80	 mov	 ecx, DWORD PTR _nCount$198808[ebp]
  017f0	83 c1 01	 add	 ecx, 1
  017f3	89 4d 80	 mov	 DWORD PTR _nCount$198808[ebp], ecx
$L198810:
  017f6	8b 55 80	 mov	 edx, DWORD PTR _nCount$198808[ebp]
  017f9	3b 55 2c	 cmp	 edx, DWORD PTR _anStep$[ebp]
  017fc	0f 8f 9b 00 00
	00		 jg	 $L198812

; 738  : 				{
; 739  : 					rect.bottom = (int)( (nCount+1) * fStep );

  01802	8b 45 80	 mov	 eax, DWORD PTR _nCount$198808[ebp]
  01805	83 c0 01	 add	 eax, 1
  01808	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv324[ebp], eax
  0180e	db 85 24 ff ff
	ff		 fild	 DWORD PTR tv324[ebp]
  01814	d8 4d a0	 fmul	 DWORD PTR _fStep$198762[ebp]
  01817	e8 00 00 00 00	 call	 __ftol2
  0181c	89 45 e0	 mov	 DWORD PTR _rect$198763[ebp+12], eax

; 740  : 
; 741  : 					hbrFill = ::CreateSolidBrush( HLStoRGB(lH1+fHStep*nCount/(float)(240) ,0.5,1.0 )  );

  0181f	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3ff0000000000000
  01825	dd 9d 70 ff ff
	ff		 fstp	 QWORD PTR $T199794[ebp]
  0182b	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe0000000000000
  01831	dd 9d 68 ff ff
	ff		 fstp	 QWORD PTR $T199795[ebp]
  01837	db 45 80	 fild	 DWORD PTR _nCount$198808[ebp]
  0183a	d8 4d 84	 fmul	 DWORD PTR _fHStep$198800[ebp]
  0183d	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@43700000
  01843	dc 45 88	 fadd	 QWORD PTR _lH1$198771[ebp]
  01846	dd 9d 60 ff ff
	ff		 fstp	 QWORD PTR $T199796[ebp]
  0184c	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T199794[ebp]
  01852	51		 push	 ecx
  01853	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T199795[ebp]
  01859	52		 push	 edx
  0185a	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T199796[ebp]
  01860	50		 push	 eax
  01861	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01867	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z ; CBitMapOperate::HLStoRGB
  0186c	50		 push	 eax
  0186d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  01873	89 45 98	 mov	 DWORD PTR _hbrFill$198764[ebp], eax

; 742  : 					::FillRect( hdcMem, &rect, hbrFill );

  01876	8b 4d 98	 mov	 ecx, DWORD PTR _hbrFill$198764[ebp]
  01879	51		 push	 ecx
  0187a	8d 55 d4	 lea	 edx, DWORD PTR _rect$198763[ebp]
  0187d	52		 push	 edx
  0187e	8b 45 e8	 mov	 eax, DWORD PTR _hdcMem$198802[ebp]
  01881	50		 push	 eax
  01882	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 743  : 					::DeleteObject( hbrFill );

  01888	8b 4d 98	 mov	 ecx, DWORD PTR _hbrFill$198764[ebp]
  0188b	51		 push	 ecx
  0188c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 744  : 
; 745  : 					rect.top = rect.bottom;

  01892	8b 55 e0	 mov	 edx, DWORD PTR _rect$198763[ebp+12]
  01895	89 55 d8	 mov	 DWORD PTR _rect$198763[ebp+4], edx

; 746  : 				}

  01898	e9 50 ff ff ff	 jmp	 $L198811
$L198812:

; 747  : 			}
; 748  : 			else

  0189d	e9 fe 00 00 00	 jmp	 $L198818
$L198805:

; 749  : 			{
; 750  : 				rect.bottom = nHeight;

  018a2	8b 45 f8	 mov	 eax, DWORD PTR _nHeight$198760[ebp]
  018a5	89 45 e0	 mov	 DWORD PTR _rect$198763[ebp+12], eax

; 751  : 				fStep= (float)nWidth / (float)anStep;

  018a8	db 45 fc	 fild	 DWORD PTR _nWidth$198759[ebp]
  018ab	8b 4d 2c	 mov	 ecx, DWORD PTR _anStep$[ebp]
  018ae	89 8d 1c ff ff
	ff		 mov	 DWORD PTR tv342[ebp], ecx
  018b4	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv342[ebp+4], 0
  018be	df ad 1c ff ff
	ff		 fild	 QWORD PTR tv342[ebp]
  018c4	de f9		 fdivp	 ST(1), ST(0)
  018c6	d9 5d a0	 fstp	 DWORD PTR _fStep$198762[ebp]

; 752  : 
; 753  : 				for ( int nCount=0; nCount<=anStep; nCount++ )

  018c9	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _nCount$198821[ebp], 0
  018d3	eb 0f		 jmp	 SHORT $L198822
$L198823:
  018d5	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _nCount$198821[ebp]
  018db	83 c2 01	 add	 edx, 1
  018de	89 95 7c ff ff
	ff		 mov	 DWORD PTR _nCount$198821[ebp], edx
$L198822:
  018e4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _nCount$198821[ebp]
  018ea	3b 45 2c	 cmp	 eax, DWORD PTR _anStep$[ebp]
  018ed	0f 87 ad 00 00
	00		 ja	 $L198818

; 754  : 				{
; 755  : 					rect.right= (int)( (nCount+1) * fStep );

  018f3	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _nCount$198821[ebp]
  018f9	83 c1 01	 add	 ecx, 1
  018fc	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv348[ebp], ecx
  01902	db 85 18 ff ff
	ff		 fild	 DWORD PTR tv348[ebp]
  01908	d8 4d a0	 fmul	 DWORD PTR _fStep$198762[ebp]
  0190b	e8 00 00 00 00	 call	 __ftol2
  01910	89 45 dc	 mov	 DWORD PTR _rect$198763[ebp+8], eax

; 756  : 					COLORREF col = HLStoRGB(lH1+fHStep*nCount/(float)(240) ,0.5,1.0 );

  01913	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3ff0000000000000
  01919	dd 9d 58 ff ff
	ff		 fstp	 QWORD PTR $T199797[ebp]
  0191f	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe0000000000000
  01925	dd 9d 50 ff ff
	ff		 fstp	 QWORD PTR $T199798[ebp]
  0192b	db 85 7c ff ff
	ff		 fild	 DWORD PTR _nCount$198821[ebp]
  01931	d8 4d 84	 fmul	 DWORD PTR _fHStep$198800[ebp]
  01934	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@43700000
  0193a	dc 45 88	 fadd	 QWORD PTR _lH1$198771[ebp]
  0193d	dd 9d 48 ff ff
	ff		 fstp	 QWORD PTR $T199799[ebp]
  01943	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T199797[ebp]
  01949	52		 push	 edx
  0194a	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T199798[ebp]
  01950	50		 push	 eax
  01951	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T199799[ebp]
  01957	51		 push	 ecx
  01958	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0195e	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z ; CBitMapOperate::HLStoRGB
  01963	89 85 78 ff ff
	ff		 mov	 DWORD PTR _col$198826[ebp], eax

; 757  : 					hbrFill = ::CreateSolidBrush( col );

  01969	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _col$198826[ebp]
  0196f	52		 push	 edx
  01970	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  01976	89 45 98	 mov	 DWORD PTR _hbrFill$198764[ebp], eax

; 758  : 					::FillRect( hdcMem, &rect, hbrFill );

  01979	8b 45 98	 mov	 eax, DWORD PTR _hbrFill$198764[ebp]
  0197c	50		 push	 eax
  0197d	8d 4d d4	 lea	 ecx, DWORD PTR _rect$198763[ebp]
  01980	51		 push	 ecx
  01981	8b 55 e8	 mov	 edx, DWORD PTR _hdcMem$198802[ebp]
  01984	52		 push	 edx
  01985	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 759  : 					::DeleteObject( hbrFill );

  0198b	8b 45 98	 mov	 eax, DWORD PTR _hbrFill$198764[ebp]
  0198e	50		 push	 eax
  0198f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 760  : 
; 761  : 					rect.left = rect.right;

  01995	8b 4d dc	 mov	 ecx, DWORD PTR _rect$198763[ebp+8]
  01998	89 4d d4	 mov	 DWORD PTR _rect$198763[ebp], ecx

; 762  : 				}

  0199b	e9 35 ff ff ff	 jmp	 $L198823
$L198818:

; 763  : 			}
; 764  : 
; 765  : 			::BitBlt( DC, aRect.left, aRect.top, nWidth, nHeight, hdcMem, 0, 0, SRCCOPY );

  019a0	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  019a5	6a 00		 push	 0
  019a7	6a 00		 push	 0
  019a9	8b 55 e8	 mov	 edx, DWORD PTR _hdcMem$198802[ebp]
  019ac	52		 push	 edx
  019ad	8b 45 f8	 mov	 eax, DWORD PTR _nHeight$198760[ebp]
  019b0	50		 push	 eax
  019b1	8b 4d fc	 mov	 ecx, DWORD PTR _nWidth$198759[ebp]
  019b4	51		 push	 ecx
  019b5	8b 55 10	 mov	 edx, DWORD PTR _aRect$[ebp+4]
  019b8	52		 push	 edx
  019b9	8b 45 0c	 mov	 eax, DWORD PTR _aRect$[ebp]
  019bc	50		 push	 eax
  019bd	8b 4d 08	 mov	 ecx, DWORD PTR _DC$[ebp]
  019c0	51		 push	 ecx
  019c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 766  : 
; 767  : 			::SelectObject( hdcMem, hobjOld );

  019c7	8b 55 f0	 mov	 edx, DWORD PTR _hobjOld$198804[ebp]
  019ca	52		 push	 edx
  019cb	8b 45 e8	 mov	 eax, DWORD PTR _hdcMem$198802[ebp]
  019ce	50		 push	 eax
  019cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 768  : 			::DeleteObject( hbmpMem );

  019d5	8b 4d ec	 mov	 ecx, DWORD PTR _hbmpMem$198803[ebp]
  019d8	51		 push	 ecx
  019d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 769  : 			::DeleteDC( hdcMem );

  019df	8b 55 e8	 mov	 edx, DWORD PTR _hdcMem$198802[ebp]
  019e2	52		 push	 edx
  019e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$L198756:

; 770  : 		}
; 771  : 	}
; 772  : }

  019e9	8b e5		 mov	 esp, ebp
  019eb	5d		 pop	 ebp
  019ec	c2 28 00	 ret	 40			; 00000028H
?FillRectangleHue@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKW4ENUM_DrawOrientation@1@HI@Z ENDP ; CBitMapOperate::FillRectangleHue
_TEXT	ENDS
PUBLIC	__real@436f0000
PUBLIC	?FillRectangleS@CBitMapOperate@@QAEXPAUHDC__@@UtagRECT@@KKIW4ENUM_DrawOrientation@1@HI@Z ; CBitMapOperate::FillRectangleS
;	COMDAT __real@436f0000
CONST	SEGMENT
__real@436f0000 DD 0436f0000r			; 239
; Function compile flags: /Odt
CONST	ENDS
_TEXT	SEGMENT
tv375 = -252						; size = 8
tv369 = -244						; size = 4
tv363 = -240						; size = 8
tv346 = -232						; size = 8
tv340 = -224						; size = 4
tv334 = -220						; size = 8
tv317 = -212						; size = 8
tv85 = -204						; size = 4
tv83 = -200						; size = 4
tv79 = -196						; size = 4
tv65 = -192						; size = 4
_this$ = -188						; size = 4
$T199818 = -184						; size = 8
$T199817 = -176						; size = 8
$T199816 = -168						; size = 8
$T199815 = -160						; size = 8
$T199814 = -152						; size = 8
$T199813 = -144						; size = 8
_col$198914 = -136					; size = 4
_nCount$198909 = -132					; size = 4
_col$198899 = -128					; size = 4
_nCount$198894 = -124					; size = 4
_lH1$198857 = -120					; size = 8
_lS2$198874 = -112					; size = 8
_hbrFill$198850 = -104					; size = 4
_lR2$198870 = -100					; size = 4
_fStep$198848 = -96					; size = 4
_lR1$198854 = -92					; size = 4
_lL1$198859 = -88					; size = 8
_lS1$198858 = -80					; size = 8
_lL2$198875 = -72					; size = 8
_lG2$198871 = -64					; size = 4
_lB1$198856 = -60					; size = 4
_lH2$198873 = -56					; size = 8
_fLStep$198886 = -48					; size = 4
_rect$198849 = -44					; size = 16
_lG1$198855 = -28					; size = 4
_hdcMem$198888 = -24					; size = 4
_hbmpMem$198889 = -20					; size = 4
_hobjOld$198890 = -16					; size = 4
_lB2$198872 = -12					; size = 4
_nHeight$198846 = -8					; size = 4
_nWidth$198845 = -4					; size = 4
_DC$ = 8						; size = 4
_aRect$ = 12						; size = 16
_aBeginColor$ = 28					; size = 4
_aEndColor$ = 32					; size = 4
_aHue$ = 36						; size = 4
_Orientation$ = 40					; size = 4
_abEclosion$ = 44					; size = 4
_anStep$ = 48						; size = 4
?FillRectangleS@CBitMapOperate@@QAEXPAUHDC__@@UtagRECT@@KKIW4ENUM_DrawOrientation@1@HI@Z PROC NEAR ; CBitMapOperate::FillRectangleS
; _this$ = ecx

; 774  : {

  019f0	55		 push	 ebp
  019f1	8b ec		 mov	 ebp, esp
  019f3	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  019f9	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 775  : 	aHue = aHue > 239 ? 239 : aHue;

  019ff	81 7d 24 ef 00
	00 00		 cmp	 DWORD PTR _aHue$[ebp], 239 ; 000000efH
  01a06	76 0c		 jbe	 SHORT $L199805
  01a08	c7 85 40 ff ff
	ff ef 00 00 00	 mov	 DWORD PTR tv65[ebp], 239 ; 000000efH
  01a12	eb 09		 jmp	 SHORT $L199806
$L199805:
  01a14	8b 45 24	 mov	 eax, DWORD PTR _aHue$[ebp]
  01a17	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
$L199806:
  01a1d	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  01a23	89 4d 24	 mov	 DWORD PTR _aHue$[ebp], ecx

; 776  : 	if(aBeginColor == aEndColor)

  01a26	8b 55 1c	 mov	 edx, DWORD PTR _aBeginColor$[ebp]
  01a29	3b 55 20	 cmp	 edx, DWORD PTR _aEndColor$[ebp]
  01a2c	75 3e		 jne	 SHORT $L198843

; 777  : 	{
; 778  : 		FillRectangle(DC, aRect, aBeginColor,  abEclosion);

  01a2e	8b 45 2c	 mov	 eax, DWORD PTR _abEclosion$[ebp]
  01a31	50		 push	 eax
  01a32	8b 4d 1c	 mov	 ecx, DWORD PTR _aBeginColor$[ebp]
  01a35	51		 push	 ecx
  01a36	83 ec 10	 sub	 esp, 16			; 00000010H
  01a39	8b d4		 mov	 edx, esp
  01a3b	8b 45 0c	 mov	 eax, DWORD PTR _aRect$[ebp]
  01a3e	89 02		 mov	 DWORD PTR [edx], eax
  01a40	8b 4d 10	 mov	 ecx, DWORD PTR _aRect$[ebp+4]
  01a43	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  01a46	8b 45 14	 mov	 eax, DWORD PTR _aRect$[ebp+8]
  01a49	89 42 08	 mov	 DWORD PTR [edx+8], eax
  01a4c	8b 4d 18	 mov	 ecx, DWORD PTR _aRect$[ebp+12]
  01a4f	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  01a52	8b 55 08	 mov	 edx, DWORD PTR _DC$[ebp]
  01a55	52		 push	 edx
  01a56	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01a5c	8b 10		 mov	 edx, DWORD PTR [eax]
  01a5e	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01a64	ff 52 04	 call	 DWORD PTR [edx+4]

; 779  : 	}
; 780  : 	else

  01a67	e9 14 04 00 00	 jmp	 $L198842
$L198843:

; 781  : 	{
; 782  : 		int nWidth  = aRect.right  - aRect.left;

  01a6c	8b 45 14	 mov	 eax, DWORD PTR _aRect$[ebp+8]
  01a6f	2b 45 0c	 sub	 eax, DWORD PTR _aRect$[ebp]
  01a72	89 45 fc	 mov	 DWORD PTR _nWidth$198845[ebp], eax

; 783  : 		int nHeight = aRect.bottom - aRect.top;  

  01a75	8b 4d 18	 mov	 ecx, DWORD PTR _aRect$[ebp+12]
  01a78	2b 4d 10	 sub	 ecx, DWORD PTR _aRect$[ebp+4]
  01a7b	89 4d f8	 mov	 DWORD PTR _nHeight$198846[ebp], ecx

; 784  : 		if(!(nWidth<=0|| nHeight<= 0))

  01a7e	83 7d fc 00	 cmp	 DWORD PTR _nWidth$198845[ebp], 0
  01a82	0f 8e f8 03 00
	00		 jle	 $L198842
  01a88	83 7d f8 00	 cmp	 DWORD PTR _nHeight$198846[ebp], 0
  01a8c	0f 8e ee 03 00
	00		 jle	 $L198842

; 785  : 		{
; 786  : 			float fStep;
; 787  : 			RECT rect;
; 788  : 			HBRUSH hbrFill;
; 789  : 			anStep = anStep == 1 ?  10:anStep;

  01a92	83 7d 30 01	 cmp	 DWORD PTR _anStep$[ebp], 1
  01a96	75 0c		 jne	 SHORT $L199807
  01a98	c7 85 3c ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv79[ebp], 10	; 0000000aH
  01aa2	eb 09		 jmp	 SHORT $L199808
$L199807:
  01aa4	8b 55 30	 mov	 edx, DWORD PTR _anStep$[ebp]
  01aa7	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv79[ebp], edx
$L199808:
  01aad	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv79[ebp]
  01ab3	89 45 30	 mov	 DWORD PTR _anStep$[ebp], eax

; 790  : 			if( -1 == anStep)

  01ab6	83 7d 30 ff	 cmp	 DWORD PTR _anStep$[ebp], -1
  01aba	75 50		 jne	 SHORT $L198851

; 791  : 			{
; 792  : 				if(true == Orientation)

  01abc	83 7d 28 01	 cmp	 DWORD PTR _Orientation$[ebp], 1
  01ac0	75 26		 jne	 SHORT $L198852

; 793  : 				{
; 794  : 					anStep = nHeight > 10 ? 10 : nHeight;

  01ac2	83 7d f8 0a	 cmp	 DWORD PTR _nHeight$198846[ebp], 10 ; 0000000aH
  01ac6	7e 0c		 jle	 SHORT $L199809
  01ac8	c7 85 38 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv83[ebp], 10	; 0000000aH
  01ad2	eb 09		 jmp	 SHORT $L199810
$L199809:
  01ad4	8b 4d f8	 mov	 ecx, DWORD PTR _nHeight$198846[ebp]
  01ad7	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv83[ebp], ecx
$L199810:
  01add	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv83[ebp]
  01ae3	89 55 30	 mov	 DWORD PTR _anStep$[ebp], edx

; 795  : 
; 796  : 				}
; 797  : 				else

  01ae6	eb 24		 jmp	 SHORT $L198851
$L198852:

; 798  : 				{
; 799  : 					anStep = nWidth >= 10 ? 10: nWidth;

  01ae8	83 7d fc 0a	 cmp	 DWORD PTR _nWidth$198845[ebp], 10 ; 0000000aH
  01aec	7c 0c		 jl	 SHORT $L199811
  01aee	c7 85 34 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv85[ebp], 10	; 0000000aH
  01af8	eb 09		 jmp	 SHORT $L199812
$L199811:
  01afa	8b 45 fc	 mov	 eax, DWORD PTR _nWidth$198845[ebp]
  01afd	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
$L199812:
  01b03	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv85[ebp]
  01b09	89 4d 30	 mov	 DWORD PTR _anStep$[ebp], ecx
$L198851:

; 800  : 				}
; 801  : 			}
; 802  : 
; 803  : 			int    lR1,lG1,lB1;
; 804  : 			double lH1,lS1,lL1;
; 805  : 			lR1 = GetRValue( aBeginColor );

  01b0c	0f b6 55 1c	 movzx	 edx, BYTE PTR _aBeginColor$[ebp]
  01b10	89 55 a4	 mov	 DWORD PTR _lR1$198854[ebp], edx

; 806  : 			lG1 = GetGValue( aBeginColor );

  01b13	0f b7 45 1c	 movzx	 eax, WORD PTR _aBeginColor$[ebp]
  01b17	c1 f8 08	 sar	 eax, 8
  01b1a	0f b6 c8	 movzx	 ecx, al
  01b1d	89 4d e4	 mov	 DWORD PTR _lG1$198855[ebp], ecx

; 807  : 			lB1 = GetBValue( aBeginColor );

  01b20	8b 55 1c	 mov	 edx, DWORD PTR _aBeginColor$[ebp]
  01b23	c1 ea 10	 shr	 edx, 16			; 00000010H
  01b26	0f b6 c2	 movzx	 eax, dl
  01b29	89 45 c4	 mov	 DWORD PTR _lB1$198856[ebp], eax

; 808  : 			RGBtoHSL(RGB(lR1,lG1,lB1),&lH1,&lS1,&lL1);

  01b2c	8d 4d a8	 lea	 ecx, DWORD PTR _lL1$198859[ebp]
  01b2f	51		 push	 ecx
  01b30	8d 55 b0	 lea	 edx, DWORD PTR _lS1$198858[ebp]
  01b33	52		 push	 edx
  01b34	8d 45 88	 lea	 eax, DWORD PTR _lH1$198857[ebp]
  01b37	50		 push	 eax
  01b38	0f b6 4d a4	 movzx	 ecx, BYTE PTR _lR1$198854[ebp]
  01b3c	0f b6 55 e4	 movzx	 edx, BYTE PTR _lG1$198855[ebp]
  01b40	c1 e2 08	 shl	 edx, 8
  01b43	0b ca		 or	 ecx, edx
  01b45	0f b6 45 c4	 movzx	 eax, BYTE PTR _lB1$198856[ebp]
  01b49	c1 e0 10	 shl	 eax, 16			; 00000010H
  01b4c	0b c8		 or	 ecx, eax
  01b4e	51		 push	 ecx
  01b4f	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01b55	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ; CBitMapOperate::RGBtoHSL

; 809  : 
; 810  : 			int    lR2,lG2,lB2;
; 811  : 			double lH2,lS2,lL2;
; 812  : 			lR2 = GetRValue( aEndColor );

  01b5a	0f b6 4d 20	 movzx	 ecx, BYTE PTR _aEndColor$[ebp]
  01b5e	89 4d 9c	 mov	 DWORD PTR _lR2$198870[ebp], ecx

; 813  : 			lG2 = GetGValue( aEndColor );

  01b61	0f b7 55 20	 movzx	 edx, WORD PTR _aEndColor$[ebp]
  01b65	c1 fa 08	 sar	 edx, 8
  01b68	0f b6 c2	 movzx	 eax, dl
  01b6b	89 45 c0	 mov	 DWORD PTR _lG2$198871[ebp], eax

; 814  : 			lB2 = GetBValue( aEndColor );

  01b6e	8b 4d 20	 mov	 ecx, DWORD PTR _aEndColor$[ebp]
  01b71	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01b74	0f b6 d1	 movzx	 edx, cl
  01b77	89 55 f4	 mov	 DWORD PTR _lB2$198872[ebp], edx

; 815  : 			RGBtoHSL(RGB(lR2,lG2,lB2),&lH2,&lS2,&lL2);

  01b7a	8d 45 b8	 lea	 eax, DWORD PTR _lL2$198875[ebp]
  01b7d	50		 push	 eax
  01b7e	8d 4d 90	 lea	 ecx, DWORD PTR _lS2$198874[ebp]
  01b81	51		 push	 ecx
  01b82	8d 55 c8	 lea	 edx, DWORD PTR _lH2$198873[ebp]
  01b85	52		 push	 edx
  01b86	0f b6 45 9c	 movzx	 eax, BYTE PTR _lR2$198870[ebp]
  01b8a	0f b6 4d c0	 movzx	 ecx, BYTE PTR _lG2$198871[ebp]
  01b8e	c1 e1 08	 shl	 ecx, 8
  01b91	0b c1		 or	 eax, ecx
  01b93	0f b6 55 f4	 movzx	 edx, BYTE PTR _lB2$198872[ebp]
  01b97	c1 e2 10	 shl	 edx, 16			; 00000010H
  01b9a	0b c2		 or	 eax, edx
  01b9c	50		 push	 eax
  01b9d	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01ba3	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ; CBitMapOperate::RGBtoHSL

; 816  : 
; 817  : 			float fLStep = ( lS2 - lS1 )*240 / (float)anStep;

  01ba8	dd 45 90	 fld	 QWORD PTR _lS2$198874[ebp]
  01bab	dc 65 b0	 fsub	 QWORD PTR _lS1$198858[ebp]
  01bae	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@406e000000000000
  01bb4	8b 45 30	 mov	 eax, DWORD PTR _anStep$[ebp]
  01bb7	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv317[ebp], eax
  01bbd	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv317[ebp+4], 0
  01bc7	df ad 2c ff ff
	ff		 fild	 QWORD PTR tv317[ebp]
  01bcd	de f9		 fdivp	 ST(1), ST(0)
  01bcf	d9 5d d0	 fstp	 DWORD PTR _fLStep$198886[ebp]

; 818  : 			HDC hdcMem   = ::CreateCompatibleDC( DC );

  01bd2	8b 4d 08	 mov	 ecx, DWORD PTR _DC$[ebp]
  01bd5	51		 push	 ecx
  01bd6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  01bdc	89 45 e8	 mov	 DWORD PTR _hdcMem$198888[ebp], eax

; 819  : 			HBITMAP hbmpMem  = ::CreateCompatibleBitmap( DC, nWidth, nHeight );

  01bdf	8b 55 f8	 mov	 edx, DWORD PTR _nHeight$198846[ebp]
  01be2	52		 push	 edx
  01be3	8b 45 fc	 mov	 eax, DWORD PTR _nWidth$198845[ebp]
  01be6	50		 push	 eax
  01be7	8b 4d 08	 mov	 ecx, DWORD PTR _DC$[ebp]
  01bea	51		 push	 ecx
  01beb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  01bf1	89 45 ec	 mov	 DWORD PTR _hbmpMem$198889[ebp], eax

; 820  : 			HGDIOBJ hobjOld  = ::SelectObject( hdcMem, hbmpMem );

  01bf4	8b 55 ec	 mov	 edx, DWORD PTR _hbmpMem$198889[ebp]
  01bf7	52		 push	 edx
  01bf8	8b 45 e8	 mov	 eax, DWORD PTR _hdcMem$198888[ebp]
  01bfb	50		 push	 eax
  01bfc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01c02	89 45 f0	 mov	 DWORD PTR _hobjOld$198890[ebp], eax

; 821  : 
; 822  : 			rect.top = rect.left = 0;

  01c05	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _rect$198849[ebp], 0
  01c0c	8b 4d d4	 mov	 ecx, DWORD PTR _rect$198849[ebp]
  01c0f	89 4d d8	 mov	 DWORD PTR _rect$198849[ebp+4], ecx

; 823  : 
; 824  : 			if ( Orientation )

  01c12	83 7d 28 00	 cmp	 DWORD PTR _Orientation$[ebp], 0
  01c16	0f 84 04 01 00
	00		 je	 $L198891

; 825  : 			{
; 826  : 				rect.right= nWidth;

  01c1c	8b 55 fc	 mov	 edx, DWORD PTR _nWidth$198845[ebp]
  01c1f	89 55 dc	 mov	 DWORD PTR _rect$198849[ebp+8], edx

; 827  : 				fStep= (float)nHeight / (float)anStep;

  01c22	db 45 f8	 fild	 DWORD PTR _nHeight$198846[ebp]
  01c25	8b 45 30	 mov	 eax, DWORD PTR _anStep$[ebp]
  01c28	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv334[ebp], eax
  01c2e	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv334[ebp+4], 0
  01c38	df ad 24 ff ff
	ff		 fild	 QWORD PTR tv334[ebp]
  01c3e	de f9		 fdivp	 ST(1), ST(0)
  01c40	d9 5d a0	 fstp	 DWORD PTR _fStep$198848[ebp]

; 828  : 
; 829  : 				for ( int nCount=0; nCount<=anStep; nCount++ )

  01c43	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _nCount$198894[ebp], 0
  01c4a	eb 09		 jmp	 SHORT $L198895
$L198896:
  01c4c	8b 4d 84	 mov	 ecx, DWORD PTR _nCount$198894[ebp]
  01c4f	83 c1 01	 add	 ecx, 1
  01c52	89 4d 84	 mov	 DWORD PTR _nCount$198894[ebp], ecx
$L198895:
  01c55	8b 55 84	 mov	 edx, DWORD PTR _nCount$198894[ebp]
  01c58	3b 55 30	 cmp	 edx, DWORD PTR _anStep$[ebp]
  01c5b	0f 87 ba 00 00
	00		 ja	 $L198897

; 830  : 				{
; 831  : 					rect.bottom = (int)( (nCount+1) * fStep );

  01c61	8b 45 84	 mov	 eax, DWORD PTR _nCount$198894[ebp]
  01c64	83 c0 01	 add	 eax, 1
  01c67	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv340[ebp], eax
  01c6d	db 85 20 ff ff
	ff		 fild	 DWORD PTR tv340[ebp]
  01c73	d8 4d a0	 fmul	 DWORD PTR _fStep$198848[ebp]
  01c76	e8 00 00 00 00	 call	 __ftol2
  01c7b	89 45 e0	 mov	 DWORD PTR _rect$198849[ebp+12], eax

; 832  : 
; 833  : 					COLORREF col = HLStoRGB((double)(aHue/(float)(239) ) ,0.5, lS1+fLStep*nCount/(float)(240) );

  01c7e	db 45 84	 fild	 DWORD PTR _nCount$198894[ebp]
  01c81	d8 4d d0	 fmul	 DWORD PTR _fLStep$198886[ebp]
  01c84	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@43700000
  01c8a	dc 45 b0	 fadd	 QWORD PTR _lS1$198858[ebp]
  01c8d	dd 9d 70 ff ff
	ff		 fstp	 QWORD PTR $T199813[ebp]
  01c93	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe0000000000000
  01c99	dd 9d 68 ff ff
	ff		 fstp	 QWORD PTR $T199814[ebp]
  01c9f	8b 4d 24	 mov	 ecx, DWORD PTR _aHue$[ebp]
  01ca2	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv346[ebp], ecx
  01ca8	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv346[ebp+4], 0
  01cb2	df ad 18 ff ff
	ff		 fild	 QWORD PTR tv346[ebp]
  01cb8	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@436f0000
  01cbe	dd 9d 60 ff ff
	ff		 fstp	 QWORD PTR $T199815[ebp]
  01cc4	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR $T199813[ebp]
  01cca	52		 push	 edx
  01ccb	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T199814[ebp]
  01cd1	50		 push	 eax
  01cd2	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T199815[ebp]
  01cd8	51		 push	 ecx
  01cd9	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01cdf	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z ; CBitMapOperate::HLStoRGB
  01ce4	89 45 80	 mov	 DWORD PTR _col$198899[ebp], eax

; 834  : 					hbrFill = ::CreateSolidBrush( col );

  01ce7	8b 55 80	 mov	 edx, DWORD PTR _col$198899[ebp]
  01cea	52		 push	 edx
  01ceb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  01cf1	89 45 98	 mov	 DWORD PTR _hbrFill$198850[ebp], eax

; 835  : 					::FillRect( hdcMem, &rect, hbrFill );

  01cf4	8b 45 98	 mov	 eax, DWORD PTR _hbrFill$198850[ebp]
  01cf7	50		 push	 eax
  01cf8	8d 4d d4	 lea	 ecx, DWORD PTR _rect$198849[ebp]
  01cfb	51		 push	 ecx
  01cfc	8b 55 e8	 mov	 edx, DWORD PTR _hdcMem$198888[ebp]
  01cff	52		 push	 edx
  01d00	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 836  : 					::DeleteObject( hbrFill );

  01d06	8b 45 98	 mov	 eax, DWORD PTR _hbrFill$198850[ebp]
  01d09	50		 push	 eax
  01d0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 837  : 
; 838  : 					rect.top = rect.bottom;

  01d10	8b 4d e0	 mov	 ecx, DWORD PTR _rect$198849[ebp+12]
  01d13	89 4d d8	 mov	 DWORD PTR _rect$198849[ebp+4], ecx

; 839  : 				}

  01d16	e9 31 ff ff ff	 jmp	 $L198896
$L198897:

; 840  : 			}
; 841  : 			else

  01d1b	e9 17 01 00 00	 jmp	 $L198906
$L198891:

; 842  : 			{
; 843  : 				rect.bottom = nHeight;

  01d20	8b 55 f8	 mov	 edx, DWORD PTR _nHeight$198846[ebp]
  01d23	89 55 e0	 mov	 DWORD PTR _rect$198849[ebp+12], edx

; 844  : 				fStep= (float)nWidth / (float)anStep;

  01d26	db 45 fc	 fild	 DWORD PTR _nWidth$198845[ebp]
  01d29	8b 45 30	 mov	 eax, DWORD PTR _anStep$[ebp]
  01d2c	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv363[ebp], eax
  01d32	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv363[ebp+4], 0
  01d3c	df ad 10 ff ff
	ff		 fild	 QWORD PTR tv363[ebp]
  01d42	de f9		 fdivp	 ST(1), ST(0)
  01d44	d9 5d a0	 fstp	 DWORD PTR _fStep$198848[ebp]

; 845  : 
; 846  : 				for ( int nCount=0; nCount<=anStep; nCount++ )

  01d47	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _nCount$198909[ebp], 0
  01d51	eb 0f		 jmp	 SHORT $L198910
$L198911:
  01d53	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _nCount$198909[ebp]
  01d59	83 c1 01	 add	 ecx, 1
  01d5c	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _nCount$198909[ebp], ecx
$L198910:
  01d62	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _nCount$198909[ebp]
  01d68	3b 55 30	 cmp	 edx, DWORD PTR _anStep$[ebp]
  01d6b	0f 87 c6 00 00
	00		 ja	 $L198906

; 847  : 				{				
; 848  : 					rect.right= (int)( (nCount+1) * fStep );

  01d71	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _nCount$198909[ebp]
  01d77	83 c0 01	 add	 eax, 1
  01d7a	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv369[ebp], eax
  01d80	db 85 0c ff ff
	ff		 fild	 DWORD PTR tv369[ebp]
  01d86	d8 4d a0	 fmul	 DWORD PTR _fStep$198848[ebp]
  01d89	e8 00 00 00 00	 call	 __ftol2
  01d8e	89 45 dc	 mov	 DWORD PTR _rect$198849[ebp+8], eax

; 849  : 					COLORREF col = HLStoRGB((double)(aHue/(float)(239)) ,0.5,lS1+fLStep*nCount/(float)(240));

  01d91	db 85 7c ff ff
	ff		 fild	 DWORD PTR _nCount$198909[ebp]
  01d97	d8 4d d0	 fmul	 DWORD PTR _fLStep$198886[ebp]
  01d9a	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@43700000
  01da0	dc 45 b0	 fadd	 QWORD PTR _lS1$198858[ebp]
  01da3	dd 9d 58 ff ff
	ff		 fstp	 QWORD PTR $T199816[ebp]
  01da9	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe0000000000000
  01daf	dd 9d 50 ff ff
	ff		 fstp	 QWORD PTR $T199817[ebp]
  01db5	8b 4d 24	 mov	 ecx, DWORD PTR _aHue$[ebp]
  01db8	89 8d 04 ff ff
	ff		 mov	 DWORD PTR tv375[ebp], ecx
  01dbe	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv375[ebp+4], 0
  01dc8	df ad 04 ff ff
	ff		 fild	 QWORD PTR tv375[ebp]
  01dce	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@436f0000
  01dd4	dd 9d 48 ff ff
	ff		 fstp	 QWORD PTR $T199818[ebp]
  01dda	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T199816[ebp]
  01de0	52		 push	 edx
  01de1	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T199817[ebp]
  01de7	50		 push	 eax
  01de8	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T199818[ebp]
  01dee	51		 push	 ecx
  01def	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01df5	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z ; CBitMapOperate::HLStoRGB
  01dfa	89 85 78 ff ff
	ff		 mov	 DWORD PTR _col$198914[ebp], eax

; 850  : 					hbrFill = ::CreateSolidBrush( col );

  01e00	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _col$198914[ebp]
  01e06	52		 push	 edx
  01e07	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  01e0d	89 45 98	 mov	 DWORD PTR _hbrFill$198850[ebp], eax

; 851  : 					::FillRect( hdcMem, &rect, hbrFill );

  01e10	8b 45 98	 mov	 eax, DWORD PTR _hbrFill$198850[ebp]
  01e13	50		 push	 eax
  01e14	8d 4d d4	 lea	 ecx, DWORD PTR _rect$198849[ebp]
  01e17	51		 push	 ecx
  01e18	8b 55 e8	 mov	 edx, DWORD PTR _hdcMem$198888[ebp]
  01e1b	52		 push	 edx
  01e1c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 852  : 					::DeleteObject( hbrFill );

  01e22	8b 45 98	 mov	 eax, DWORD PTR _hbrFill$198850[ebp]
  01e25	50		 push	 eax
  01e26	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 853  : 
; 854  : 					rect.left = rect.right;

  01e2c	8b 4d dc	 mov	 ecx, DWORD PTR _rect$198849[ebp+8]
  01e2f	89 4d d4	 mov	 DWORD PTR _rect$198849[ebp], ecx

; 855  : 				}

  01e32	e9 1c ff ff ff	 jmp	 $L198911
$L198906:

; 856  : 			}
; 857  : 
; 858  : 			::BitBlt( DC, aRect.left, aRect.top, nWidth, nHeight, hdcMem, 0, 0, SRCCOPY );

  01e37	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01e3c	6a 00		 push	 0
  01e3e	6a 00		 push	 0
  01e40	8b 55 e8	 mov	 edx, DWORD PTR _hdcMem$198888[ebp]
  01e43	52		 push	 edx
  01e44	8b 45 f8	 mov	 eax, DWORD PTR _nHeight$198846[ebp]
  01e47	50		 push	 eax
  01e48	8b 4d fc	 mov	 ecx, DWORD PTR _nWidth$198845[ebp]
  01e4b	51		 push	 ecx
  01e4c	8b 55 10	 mov	 edx, DWORD PTR _aRect$[ebp+4]
  01e4f	52		 push	 edx
  01e50	8b 45 0c	 mov	 eax, DWORD PTR _aRect$[ebp]
  01e53	50		 push	 eax
  01e54	8b 4d 08	 mov	 ecx, DWORD PTR _DC$[ebp]
  01e57	51		 push	 ecx
  01e58	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 859  : 
; 860  : 			::SelectObject( hdcMem, hobjOld );

  01e5e	8b 55 f0	 mov	 edx, DWORD PTR _hobjOld$198890[ebp]
  01e61	52		 push	 edx
  01e62	8b 45 e8	 mov	 eax, DWORD PTR _hdcMem$198888[ebp]
  01e65	50		 push	 eax
  01e66	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 861  : 			::DeleteObject( hbmpMem );

  01e6c	8b 4d ec	 mov	 ecx, DWORD PTR _hbmpMem$198889[ebp]
  01e6f	51		 push	 ecx
  01e70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 862  : 			::DeleteDC( hdcMem );

  01e76	8b 55 e8	 mov	 edx, DWORD PTR _hdcMem$198888[ebp]
  01e79	52		 push	 edx
  01e7a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$L198842:

; 863  : 		}
; 864  : 	}
; 865  : }

  01e80	8b e5		 mov	 esp, ebp
  01e82	5d		 pop	 ebp
  01e83	c2 2c 00	 ret	 44			; 0000002cH
?FillRectangleS@CBitMapOperate@@QAEXPAUHDC__@@UtagRECT@@KKIW4ENUM_DrawOrientation@1@HI@Z ENDP ; CBitMapOperate::FillRectangleS
; Function compile flags: /Odt
tv375 = -252						; size = 8
tv369 = -244						; size = 4
tv363 = -240						; size = 8
tv346 = -232						; size = 8
tv340 = -224						; size = 4
tv334 = -220						; size = 8
tv317 = -212						; size = 8
tv85 = -204						; size = 4
tv83 = -200						; size = 4
tv79 = -196						; size = 4
tv65 = -192						; size = 4
_this$ = -188						; size = 4
$T199835 = -184						; size = 8
$T199834 = -176						; size = 8
$T199833 = -168						; size = 8
$T199832 = -160						; size = 8
$T199831 = -152						; size = 8
$T199830 = -144						; size = 8
_col$199004 = -136					; size = 4
_nCount$198999 = -132					; size = 4
_col$198989 = -128					; size = 4
_nCount$198984 = -124					; size = 4
_lH1$198947 = -120					; size = 8
_lS2$198964 = -112					; size = 8
_hbrFill$198940 = -104					; size = 4
_lR2$198960 = -100					; size = 4
_fStep$198938 = -96					; size = 4
_lR1$198944 = -92					; size = 4
_lL1$198949 = -88					; size = 8
_lS1$198948 = -80					; size = 8
_lL2$198965 = -72					; size = 8
_lG2$198961 = -64					; size = 4
_lB1$198946 = -60					; size = 4
_lH2$198963 = -56					; size = 8
_fLStep$198976 = -48					; size = 4
_rect$198939 = -44					; size = 16
_lG1$198945 = -28					; size = 4
_hdcMem$198978 = -24					; size = 4
_hbmpMem$198979 = -20					; size = 4
_hobjOld$198980 = -16					; size = 4
_lB2$198962 = -12					; size = 4
_nHeight$198936 = -8					; size = 4
_nWidth$198935 = -4					; size = 4
_DC$ = 8						; size = 4
_aRect$ = 12						; size = 16
_aBeginColor$ = 28					; size = 4
_aEndColor$ = 32					; size = 4
_aHue$ = 36						; size = 4
_Orientation$ = 40					; size = 4
_abEclosion$ = 44					; size = 4
_anStep$ = 48						; size = 4
?FillRectangleLight@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKIW4ENUM_DrawOrientation@1@HI@Z PROC NEAR ; CBitMapOperate::FillRectangleLight
; _this$ = ecx

; 867  : {

  01e90	55		 push	 ebp
  01e91	8b ec		 mov	 ebp, esp
  01e93	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  01e99	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 868  : 	aHue = aHue > 239 ? 239 : aHue;

  01e9f	81 7d 24 ef 00
	00 00		 cmp	 DWORD PTR _aHue$[ebp], 239 ; 000000efH
  01ea6	76 0c		 jbe	 SHORT $L199822
  01ea8	c7 85 40 ff ff
	ff ef 00 00 00	 mov	 DWORD PTR tv65[ebp], 239 ; 000000efH
  01eb2	eb 09		 jmp	 SHORT $L199823
$L199822:
  01eb4	8b 45 24	 mov	 eax, DWORD PTR _aHue$[ebp]
  01eb7	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
$L199823:
  01ebd	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  01ec3	89 4d 24	 mov	 DWORD PTR _aHue$[ebp], ecx

; 869  : 	if(aBeginColor == aEndColor)

  01ec6	8b 55 1c	 mov	 edx, DWORD PTR _aBeginColor$[ebp]
  01ec9	3b 55 20	 cmp	 edx, DWORD PTR _aEndColor$[ebp]
  01ecc	75 3e		 jne	 SHORT $L198933

; 870  : 	{
; 871  : 		FillRectangle(DC, aRect, aBeginColor,  abEclosion);

  01ece	8b 45 2c	 mov	 eax, DWORD PTR _abEclosion$[ebp]
  01ed1	50		 push	 eax
  01ed2	8b 4d 1c	 mov	 ecx, DWORD PTR _aBeginColor$[ebp]
  01ed5	51		 push	 ecx
  01ed6	83 ec 10	 sub	 esp, 16			; 00000010H
  01ed9	8b d4		 mov	 edx, esp
  01edb	8b 45 0c	 mov	 eax, DWORD PTR _aRect$[ebp]
  01ede	89 02		 mov	 DWORD PTR [edx], eax
  01ee0	8b 4d 10	 mov	 ecx, DWORD PTR _aRect$[ebp+4]
  01ee3	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  01ee6	8b 45 14	 mov	 eax, DWORD PTR _aRect$[ebp+8]
  01ee9	89 42 08	 mov	 DWORD PTR [edx+8], eax
  01eec	8b 4d 18	 mov	 ecx, DWORD PTR _aRect$[ebp+12]
  01eef	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  01ef2	8b 55 08	 mov	 edx, DWORD PTR _DC$[ebp]
  01ef5	52		 push	 edx
  01ef6	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01efc	8b 10		 mov	 edx, DWORD PTR [eax]
  01efe	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01f04	ff 52 04	 call	 DWORD PTR [edx+4]

; 872  : 	}
; 873  : 	else

  01f07	e9 14 04 00 00	 jmp	 $L198932
$L198933:

; 874  : 	{
; 875  : 		int nWidth  = aRect.right  - aRect.left;

  01f0c	8b 45 14	 mov	 eax, DWORD PTR _aRect$[ebp+8]
  01f0f	2b 45 0c	 sub	 eax, DWORD PTR _aRect$[ebp]
  01f12	89 45 fc	 mov	 DWORD PTR _nWidth$198935[ebp], eax

; 876  : 		int nHeight = aRect.bottom - aRect.top;  

  01f15	8b 4d 18	 mov	 ecx, DWORD PTR _aRect$[ebp+12]
  01f18	2b 4d 10	 sub	 ecx, DWORD PTR _aRect$[ebp+4]
  01f1b	89 4d f8	 mov	 DWORD PTR _nHeight$198936[ebp], ecx

; 877  : 		if(!(nWidth<=0|| nHeight<= 0))

  01f1e	83 7d fc 00	 cmp	 DWORD PTR _nWidth$198935[ebp], 0
  01f22	0f 8e f8 03 00
	00		 jle	 $L198932
  01f28	83 7d f8 00	 cmp	 DWORD PTR _nHeight$198936[ebp], 0
  01f2c	0f 8e ee 03 00
	00		 jle	 $L198932

; 878  : 		{
; 879  : 			float fStep;
; 880  : 			RECT rect;
; 881  : 			HBRUSH hbrFill;
; 882  : 			anStep = anStep == 1 ?  10:anStep;

  01f32	83 7d 30 01	 cmp	 DWORD PTR _anStep$[ebp], 1
  01f36	75 0c		 jne	 SHORT $L199824
  01f38	c7 85 3c ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv79[ebp], 10	; 0000000aH
  01f42	eb 09		 jmp	 SHORT $L199825
$L199824:
  01f44	8b 55 30	 mov	 edx, DWORD PTR _anStep$[ebp]
  01f47	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv79[ebp], edx
$L199825:
  01f4d	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv79[ebp]
  01f53	89 45 30	 mov	 DWORD PTR _anStep$[ebp], eax

; 883  : 			if( -1 == anStep)

  01f56	83 7d 30 ff	 cmp	 DWORD PTR _anStep$[ebp], -1
  01f5a	75 50		 jne	 SHORT $L198941

; 884  : 			{
; 885  : 				if(true == Orientation)

  01f5c	83 7d 28 01	 cmp	 DWORD PTR _Orientation$[ebp], 1
  01f60	75 26		 jne	 SHORT $L198942

; 886  : 				{
; 887  : 					anStep = nHeight > 10 ? 10 : nHeight;

  01f62	83 7d f8 0a	 cmp	 DWORD PTR _nHeight$198936[ebp], 10 ; 0000000aH
  01f66	7e 0c		 jle	 SHORT $L199826
  01f68	c7 85 38 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv83[ebp], 10	; 0000000aH
  01f72	eb 09		 jmp	 SHORT $L199827
$L199826:
  01f74	8b 4d f8	 mov	 ecx, DWORD PTR _nHeight$198936[ebp]
  01f77	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv83[ebp], ecx
$L199827:
  01f7d	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv83[ebp]
  01f83	89 55 30	 mov	 DWORD PTR _anStep$[ebp], edx

; 888  : 
; 889  : 				}
; 890  : 				else

  01f86	eb 24		 jmp	 SHORT $L198941
$L198942:

; 891  : 				{
; 892  : 					anStep = nWidth >= 10 ? 10: nWidth;

  01f88	83 7d fc 0a	 cmp	 DWORD PTR _nWidth$198935[ebp], 10 ; 0000000aH
  01f8c	7c 0c		 jl	 SHORT $L199828
  01f8e	c7 85 34 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv85[ebp], 10	; 0000000aH
  01f98	eb 09		 jmp	 SHORT $L199829
$L199828:
  01f9a	8b 45 fc	 mov	 eax, DWORD PTR _nWidth$198935[ebp]
  01f9d	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
$L199829:
  01fa3	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv85[ebp]
  01fa9	89 4d 30	 mov	 DWORD PTR _anStep$[ebp], ecx
$L198941:

; 893  : 				}
; 894  : 			}
; 895  : 
; 896  : 			int    lR1,lG1,lB1;
; 897  : 			double lH1,lS1,lL1;
; 898  : 			lR1 = GetRValue( aBeginColor );

  01fac	0f b6 55 1c	 movzx	 edx, BYTE PTR _aBeginColor$[ebp]
  01fb0	89 55 a4	 mov	 DWORD PTR _lR1$198944[ebp], edx

; 899  : 			lG1 = GetGValue( aBeginColor );

  01fb3	0f b7 45 1c	 movzx	 eax, WORD PTR _aBeginColor$[ebp]
  01fb7	c1 f8 08	 sar	 eax, 8
  01fba	0f b6 c8	 movzx	 ecx, al
  01fbd	89 4d e4	 mov	 DWORD PTR _lG1$198945[ebp], ecx

; 900  : 			lB1 = GetBValue( aBeginColor );

  01fc0	8b 55 1c	 mov	 edx, DWORD PTR _aBeginColor$[ebp]
  01fc3	c1 ea 10	 shr	 edx, 16			; 00000010H
  01fc6	0f b6 c2	 movzx	 eax, dl
  01fc9	89 45 c4	 mov	 DWORD PTR _lB1$198946[ebp], eax

; 901  : 			RGBtoHSL(RGB(lR1,lG1,lB1),&lH1,&lS1,&lL1);

  01fcc	8d 4d a8	 lea	 ecx, DWORD PTR _lL1$198949[ebp]
  01fcf	51		 push	 ecx
  01fd0	8d 55 b0	 lea	 edx, DWORD PTR _lS1$198948[ebp]
  01fd3	52		 push	 edx
  01fd4	8d 45 88	 lea	 eax, DWORD PTR _lH1$198947[ebp]
  01fd7	50		 push	 eax
  01fd8	0f b6 4d a4	 movzx	 ecx, BYTE PTR _lR1$198944[ebp]
  01fdc	0f b6 55 e4	 movzx	 edx, BYTE PTR _lG1$198945[ebp]
  01fe0	c1 e2 08	 shl	 edx, 8
  01fe3	0b ca		 or	 ecx, edx
  01fe5	0f b6 45 c4	 movzx	 eax, BYTE PTR _lB1$198946[ebp]
  01fe9	c1 e0 10	 shl	 eax, 16			; 00000010H
  01fec	0b c8		 or	 ecx, eax
  01fee	51		 push	 ecx
  01fef	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01ff5	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ; CBitMapOperate::RGBtoHSL

; 902  : 
; 903  : 			int    lR2,lG2,lB2;
; 904  : 			double lH2,lS2,lL2;
; 905  : 			lR2 = GetRValue( aEndColor );

  01ffa	0f b6 4d 20	 movzx	 ecx, BYTE PTR _aEndColor$[ebp]
  01ffe	89 4d 9c	 mov	 DWORD PTR _lR2$198960[ebp], ecx

; 906  : 			lG2 = GetGValue( aEndColor );

  02001	0f b7 55 20	 movzx	 edx, WORD PTR _aEndColor$[ebp]
  02005	c1 fa 08	 sar	 edx, 8
  02008	0f b6 c2	 movzx	 eax, dl
  0200b	89 45 c0	 mov	 DWORD PTR _lG2$198961[ebp], eax

; 907  : 			lB2 = GetBValue( aEndColor );

  0200e	8b 4d 20	 mov	 ecx, DWORD PTR _aEndColor$[ebp]
  02011	c1 e9 10	 shr	 ecx, 16			; 00000010H
  02014	0f b6 d1	 movzx	 edx, cl
  02017	89 55 f4	 mov	 DWORD PTR _lB2$198962[ebp], edx

; 908  : 			RGBtoHSL(RGB(lR2,lG2,lB2),&lH2,&lS2,&lL2);

  0201a	8d 45 b8	 lea	 eax, DWORD PTR _lL2$198965[ebp]
  0201d	50		 push	 eax
  0201e	8d 4d 90	 lea	 ecx, DWORD PTR _lS2$198964[ebp]
  02021	51		 push	 ecx
  02022	8d 55 c8	 lea	 edx, DWORD PTR _lH2$198963[ebp]
  02025	52		 push	 edx
  02026	0f b6 45 9c	 movzx	 eax, BYTE PTR _lR2$198960[ebp]
  0202a	0f b6 4d c0	 movzx	 ecx, BYTE PTR _lG2$198961[ebp]
  0202e	c1 e1 08	 shl	 ecx, 8
  02031	0b c1		 or	 eax, ecx
  02033	0f b6 55 f4	 movzx	 edx, BYTE PTR _lB2$198962[ebp]
  02037	c1 e2 10	 shl	 edx, 16			; 00000010H
  0203a	0b c2		 or	 eax, edx
  0203c	50		 push	 eax
  0203d	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  02043	e8 00 00 00 00	 call	 ?RGBtoHSL@CBitMapOperate@@QAEXKPAN00@Z ; CBitMapOperate::RGBtoHSL

; 909  : 
; 910  : 			float fLStep = ( lL2 - lL1 )*240 / (float)anStep;

  02048	dd 45 b8	 fld	 QWORD PTR _lL2$198965[ebp]
  0204b	dc 65 a8	 fsub	 QWORD PTR _lL1$198949[ebp]
  0204e	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@406e000000000000
  02054	8b 45 30	 mov	 eax, DWORD PTR _anStep$[ebp]
  02057	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv317[ebp], eax
  0205d	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv317[ebp+4], 0
  02067	df ad 2c ff ff
	ff		 fild	 QWORD PTR tv317[ebp]
  0206d	de f9		 fdivp	 ST(1), ST(0)
  0206f	d9 5d d0	 fstp	 DWORD PTR _fLStep$198976[ebp]

; 911  : 			HDC hdcMem   = ::CreateCompatibleDC( DC );

  02072	8b 4d 08	 mov	 ecx, DWORD PTR _DC$[ebp]
  02075	51		 push	 ecx
  02076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  0207c	89 45 e8	 mov	 DWORD PTR _hdcMem$198978[ebp], eax

; 912  : 			HBITMAP hbmpMem  = ::CreateCompatibleBitmap( DC, nWidth, nHeight );

  0207f	8b 55 f8	 mov	 edx, DWORD PTR _nHeight$198936[ebp]
  02082	52		 push	 edx
  02083	8b 45 fc	 mov	 eax, DWORD PTR _nWidth$198935[ebp]
  02086	50		 push	 eax
  02087	8b 4d 08	 mov	 ecx, DWORD PTR _DC$[ebp]
  0208a	51		 push	 ecx
  0208b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  02091	89 45 ec	 mov	 DWORD PTR _hbmpMem$198979[ebp], eax

; 913  : 			HGDIOBJ hobjOld  = ::SelectObject( hdcMem, hbmpMem );

  02094	8b 55 ec	 mov	 edx, DWORD PTR _hbmpMem$198979[ebp]
  02097	52		 push	 edx
  02098	8b 45 e8	 mov	 eax, DWORD PTR _hdcMem$198978[ebp]
  0209b	50		 push	 eax
  0209c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  020a2	89 45 f0	 mov	 DWORD PTR _hobjOld$198980[ebp], eax

; 914  : 
; 915  : 			rect.top = rect.left = 0;

  020a5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _rect$198939[ebp], 0
  020ac	8b 4d d4	 mov	 ecx, DWORD PTR _rect$198939[ebp]
  020af	89 4d d8	 mov	 DWORD PTR _rect$198939[ebp+4], ecx

; 916  : 
; 917  : 			if ( Orientation )

  020b2	83 7d 28 00	 cmp	 DWORD PTR _Orientation$[ebp], 0
  020b6	0f 84 04 01 00
	00		 je	 $L198981

; 918  : 			{
; 919  : 				rect.right= nWidth;

  020bc	8b 55 fc	 mov	 edx, DWORD PTR _nWidth$198935[ebp]
  020bf	89 55 dc	 mov	 DWORD PTR _rect$198939[ebp+8], edx

; 920  : 				fStep= (float)nHeight / (float)anStep;

  020c2	db 45 f8	 fild	 DWORD PTR _nHeight$198936[ebp]
  020c5	8b 45 30	 mov	 eax, DWORD PTR _anStep$[ebp]
  020c8	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv334[ebp], eax
  020ce	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv334[ebp+4], 0
  020d8	df ad 24 ff ff
	ff		 fild	 QWORD PTR tv334[ebp]
  020de	de f9		 fdivp	 ST(1), ST(0)
  020e0	d9 5d a0	 fstp	 DWORD PTR _fStep$198938[ebp]

; 921  : 
; 922  : 				for ( int nCount=0; nCount<=anStep; nCount++ )

  020e3	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _nCount$198984[ebp], 0
  020ea	eb 09		 jmp	 SHORT $L198985
$L198986:
  020ec	8b 4d 84	 mov	 ecx, DWORD PTR _nCount$198984[ebp]
  020ef	83 c1 01	 add	 ecx, 1
  020f2	89 4d 84	 mov	 DWORD PTR _nCount$198984[ebp], ecx
$L198985:
  020f5	8b 55 84	 mov	 edx, DWORD PTR _nCount$198984[ebp]
  020f8	3b 55 30	 cmp	 edx, DWORD PTR _anStep$[ebp]
  020fb	0f 87 ba 00 00
	00		 ja	 $L198987

; 923  : 				{
; 924  : 					rect.bottom = (int)( (nCount+1) * fStep );

  02101	8b 45 84	 mov	 eax, DWORD PTR _nCount$198984[ebp]
  02104	83 c0 01	 add	 eax, 1
  02107	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv340[ebp], eax
  0210d	db 85 20 ff ff
	ff		 fild	 DWORD PTR tv340[ebp]
  02113	d8 4d a0	 fmul	 DWORD PTR _fStep$198938[ebp]
  02116	e8 00 00 00 00	 call	 __ftol2
  0211b	89 45 e0	 mov	 DWORD PTR _rect$198939[ebp+12], eax

; 925  : 
; 926  : 					COLORREF col = HLStoRGB((double)(aHue/(float)(239) ) ,lL1+fLStep*nCount/(float)(240),0 );

  0211e	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  02124	dd 9d 70 ff ff
	ff		 fstp	 QWORD PTR $T199830[ebp]
  0212a	db 45 84	 fild	 DWORD PTR _nCount$198984[ebp]
  0212d	d8 4d d0	 fmul	 DWORD PTR _fLStep$198976[ebp]
  02130	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@43700000
  02136	dc 45 a8	 fadd	 QWORD PTR _lL1$198949[ebp]
  02139	dd 9d 68 ff ff
	ff		 fstp	 QWORD PTR $T199831[ebp]
  0213f	8b 4d 24	 mov	 ecx, DWORD PTR _aHue$[ebp]
  02142	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv346[ebp], ecx
  02148	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv346[ebp+4], 0
  02152	df ad 18 ff ff
	ff		 fild	 QWORD PTR tv346[ebp]
  02158	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@436f0000
  0215e	dd 9d 60 ff ff
	ff		 fstp	 QWORD PTR $T199832[ebp]
  02164	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR $T199830[ebp]
  0216a	52		 push	 edx
  0216b	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T199831[ebp]
  02171	50		 push	 eax
  02172	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T199832[ebp]
  02178	51		 push	 ecx
  02179	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0217f	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z ; CBitMapOperate::HLStoRGB
  02184	89 45 80	 mov	 DWORD PTR _col$198989[ebp], eax

; 927  : 					hbrFill = ::CreateSolidBrush( col );

  02187	8b 55 80	 mov	 edx, DWORD PTR _col$198989[ebp]
  0218a	52		 push	 edx
  0218b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  02191	89 45 98	 mov	 DWORD PTR _hbrFill$198940[ebp], eax

; 928  : 					::FillRect( hdcMem, &rect, hbrFill );

  02194	8b 45 98	 mov	 eax, DWORD PTR _hbrFill$198940[ebp]
  02197	50		 push	 eax
  02198	8d 4d d4	 lea	 ecx, DWORD PTR _rect$198939[ebp]
  0219b	51		 push	 ecx
  0219c	8b 55 e8	 mov	 edx, DWORD PTR _hdcMem$198978[ebp]
  0219f	52		 push	 edx
  021a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 929  : 					::DeleteObject( hbrFill );

  021a6	8b 45 98	 mov	 eax, DWORD PTR _hbrFill$198940[ebp]
  021a9	50		 push	 eax
  021aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 930  : 
; 931  : 					rect.top = rect.bottom;

  021b0	8b 4d e0	 mov	 ecx, DWORD PTR _rect$198939[ebp+12]
  021b3	89 4d d8	 mov	 DWORD PTR _rect$198939[ebp+4], ecx

; 932  : 				}

  021b6	e9 31 ff ff ff	 jmp	 $L198986
$L198987:

; 933  : 			}
; 934  : 			else

  021bb	e9 17 01 00 00	 jmp	 $L198996
$L198981:

; 935  : 			{
; 936  : 				rect.bottom = nHeight;

  021c0	8b 55 f8	 mov	 edx, DWORD PTR _nHeight$198936[ebp]
  021c3	89 55 e0	 mov	 DWORD PTR _rect$198939[ebp+12], edx

; 937  : 				fStep= (float)nWidth / (float)anStep;

  021c6	db 45 fc	 fild	 DWORD PTR _nWidth$198935[ebp]
  021c9	8b 45 30	 mov	 eax, DWORD PTR _anStep$[ebp]
  021cc	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv363[ebp], eax
  021d2	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv363[ebp+4], 0
  021dc	df ad 10 ff ff
	ff		 fild	 QWORD PTR tv363[ebp]
  021e2	de f9		 fdivp	 ST(1), ST(0)
  021e4	d9 5d a0	 fstp	 DWORD PTR _fStep$198938[ebp]

; 938  : 
; 939  : 				for ( int nCount=0; nCount<=anStep; nCount++ )

  021e7	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _nCount$198999[ebp], 0
  021f1	eb 0f		 jmp	 SHORT $L199000
$L199001:
  021f3	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _nCount$198999[ebp]
  021f9	83 c1 01	 add	 ecx, 1
  021fc	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _nCount$198999[ebp], ecx
$L199000:
  02202	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _nCount$198999[ebp]
  02208	3b 55 30	 cmp	 edx, DWORD PTR _anStep$[ebp]
  0220b	0f 87 c6 00 00
	00		 ja	 $L198996

; 940  : 				{				
; 941  : 					rect.right= (int)( (nCount+1) * fStep );

  02211	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _nCount$198999[ebp]
  02217	83 c0 01	 add	 eax, 1
  0221a	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv369[ebp], eax
  02220	db 85 0c ff ff
	ff		 fild	 DWORD PTR tv369[ebp]
  02226	d8 4d a0	 fmul	 DWORD PTR _fStep$198938[ebp]
  02229	e8 00 00 00 00	 call	 __ftol2
  0222e	89 45 dc	 mov	 DWORD PTR _rect$198939[ebp+8], eax

; 942  : 					COLORREF col = HLStoRGB((double)(aHue/(float)(239)) ,lL1+fLStep*nCount/(float)(240),0);

  02231	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  02237	dd 9d 58 ff ff
	ff		 fstp	 QWORD PTR $T199833[ebp]
  0223d	db 85 7c ff ff
	ff		 fild	 DWORD PTR _nCount$198999[ebp]
  02243	d8 4d d0	 fmul	 DWORD PTR _fLStep$198976[ebp]
  02246	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@43700000
  0224c	dc 45 a8	 fadd	 QWORD PTR _lL1$198949[ebp]
  0224f	dd 9d 50 ff ff
	ff		 fstp	 QWORD PTR $T199834[ebp]
  02255	8b 4d 24	 mov	 ecx, DWORD PTR _aHue$[ebp]
  02258	89 8d 04 ff ff
	ff		 mov	 DWORD PTR tv375[ebp], ecx
  0225e	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv375[ebp+4], 0
  02268	df ad 04 ff ff
	ff		 fild	 QWORD PTR tv375[ebp]
  0226e	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@436f0000
  02274	dd 9d 48 ff ff
	ff		 fstp	 QWORD PTR $T199835[ebp]
  0227a	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T199833[ebp]
  02280	52		 push	 edx
  02281	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T199834[ebp]
  02287	50		 push	 eax
  02288	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T199835[ebp]
  0228e	51		 push	 ecx
  0228f	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  02295	e8 00 00 00 00	 call	 ?HLStoRGB@CBitMapOperate@@QAEKABN00@Z ; CBitMapOperate::HLStoRGB
  0229a	89 85 78 ff ff
	ff		 mov	 DWORD PTR _col$199004[ebp], eax

; 943  : 					hbrFill = ::CreateSolidBrush( col );

  022a0	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _col$199004[ebp]
  022a6	52		 push	 edx
  022a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  022ad	89 45 98	 mov	 DWORD PTR _hbrFill$198940[ebp], eax

; 944  : 					::FillRect( hdcMem, &rect, hbrFill );

  022b0	8b 45 98	 mov	 eax, DWORD PTR _hbrFill$198940[ebp]
  022b3	50		 push	 eax
  022b4	8d 4d d4	 lea	 ecx, DWORD PTR _rect$198939[ebp]
  022b7	51		 push	 ecx
  022b8	8b 55 e8	 mov	 edx, DWORD PTR _hdcMem$198978[ebp]
  022bb	52		 push	 edx
  022bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 945  : 					::DeleteObject( hbrFill );

  022c2	8b 45 98	 mov	 eax, DWORD PTR _hbrFill$198940[ebp]
  022c5	50		 push	 eax
  022c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 946  : 
; 947  : 					rect.left = rect.right;

  022cc	8b 4d dc	 mov	 ecx, DWORD PTR _rect$198939[ebp+8]
  022cf	89 4d d4	 mov	 DWORD PTR _rect$198939[ebp], ecx

; 948  : 				}

  022d2	e9 1c ff ff ff	 jmp	 $L199001
$L198996:

; 949  : 			}
; 950  : 
; 951  : 			::BitBlt( DC, aRect.left, aRect.top, nWidth, nHeight, hdcMem, 0, 0, SRCCOPY );

  022d7	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  022dc	6a 00		 push	 0
  022de	6a 00		 push	 0
  022e0	8b 55 e8	 mov	 edx, DWORD PTR _hdcMem$198978[ebp]
  022e3	52		 push	 edx
  022e4	8b 45 f8	 mov	 eax, DWORD PTR _nHeight$198936[ebp]
  022e7	50		 push	 eax
  022e8	8b 4d fc	 mov	 ecx, DWORD PTR _nWidth$198935[ebp]
  022eb	51		 push	 ecx
  022ec	8b 55 10	 mov	 edx, DWORD PTR _aRect$[ebp+4]
  022ef	52		 push	 edx
  022f0	8b 45 0c	 mov	 eax, DWORD PTR _aRect$[ebp]
  022f3	50		 push	 eax
  022f4	8b 4d 08	 mov	 ecx, DWORD PTR _DC$[ebp]
  022f7	51		 push	 ecx
  022f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 952  : 
; 953  : 			::SelectObject( hdcMem, hobjOld );

  022fe	8b 55 f0	 mov	 edx, DWORD PTR _hobjOld$198980[ebp]
  02301	52		 push	 edx
  02302	8b 45 e8	 mov	 eax, DWORD PTR _hdcMem$198978[ebp]
  02305	50		 push	 eax
  02306	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 954  : 			::DeleteObject( hbmpMem );

  0230c	8b 4d ec	 mov	 ecx, DWORD PTR _hbmpMem$198979[ebp]
  0230f	51		 push	 ecx
  02310	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 955  : 			::DeleteDC( hdcMem );

  02316	8b 55 e8	 mov	 edx, DWORD PTR _hdcMem$198978[ebp]
  02319	52		 push	 edx
  0231a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$L198932:

; 956  : 		}
; 957  : 	}
; 958  : }

  02320	8b e5		 mov	 esp, ebp
  02322	5d		 pop	 ebp
  02323	c2 2c 00	 ret	 44			; 0000002cH
?FillRectangleLight@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KKIW4ENUM_DrawOrientation@1@HI@Z ENDP ; CBitMapOperate::FillRectangleLight
_TEXT	ENDS
PUBLIC	??0CBrush@@QAE@XZ				; CBrush::CBrush
PUBLIC	?CreateSolidBrush@CBrush@@QAEHK@Z		; CBrush::CreateSolidBrush
PUBLIC	??1CBrush@@UAE@XZ				; CBrush::~CBrush
EXTRN	?SelectObject@CDC@@QAEPAVCBrush@@PAV2@@Z:NEAR	; CDC::SelectObject
EXTRN	?DeleteObject@CGdiObject@@QAEHXZ:NEAR		; CGdiObject::DeleteObject
EXTRN	?FillSolidRect@CDC@@QAEXHHHHK@Z:NEAR		; CDC::FillSolidRect
xdata$x	SEGMENT
$T199841 DD	0ffffffffH
	DD	FLAT:$L199837
$T199839 DD	019930520H
	DD	01H
	DD	FLAT:$T199841
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -32						; size = 4
_pOldBrush$ = -28					; size = 4
_pDC$ = -24						; size = 4
_Brush$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_DC$ = 8						; size = 4
_aRect$ = 12						; size = 16
_aColor$ = 28						; size = 4
_abEclosion$ = 32					; size = 4
?FillRectangle@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KH@Z PROC NEAR ; CBitMapOperate::FillRectangle
; _this$ = ecx

; 960  : {

  02330	55		 push	 ebp
  02331	8b ec		 mov	 ebp, esp
  02333	6a ff		 push	 -1
  02335	68 00 00 00 00	 push	 __ehhandler$?FillRectangle@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KH@Z
  0233a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02340	50		 push	 eax
  02341	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02348	83 ec 14	 sub	 esp, 20			; 00000014H
  0234b	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 961  : 	CDC * pDC = CDC::FromHandle(DC);

  0234e	8b 45 08	 mov	 eax, DWORD PTR _DC$[ebp]
  02351	50		 push	 eax
  02352	e8 00 00 00 00	 call	 ?FromHandle@CDC@@SGPAV1@PAUHDC__@@@Z ; CDC::FromHandle
  02357	89 45 e8	 mov	 DWORD PTR _pDC$[ebp], eax

; 962  : 	CBrush Brush, *pOldBrush;

  0235a	8d 4d ec	 lea	 ecx, DWORD PTR _Brush$[ebp]
  0235d	e8 00 00 00 00	 call	 ??0CBrush@@QAE@XZ	; CBrush::CBrush
  02362	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 963  : 	Brush.CreateSolidBrush(aColor);

  02369	8b 4d 1c	 mov	 ecx, DWORD PTR _aColor$[ebp]
  0236c	51		 push	 ecx
  0236d	8d 4d ec	 lea	 ecx, DWORD PTR _Brush$[ebp]
  02370	e8 00 00 00 00	 call	 ?CreateSolidBrush@CBrush@@QAEHK@Z ; CBrush::CreateSolidBrush

; 964  : 	pOldBrush = pDC->SelectObject(&Brush);

  02375	8d 55 ec	 lea	 edx, DWORD PTR _Brush$[ebp]
  02378	52		 push	 edx
  02379	8b 4d e8	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0237c	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCBrush@@PAV2@@Z ; CDC::SelectObject
  02381	89 45 e4	 mov	 DWORD PTR _pOldBrush$[ebp], eax

; 965  : 	pDC->FillSolidRect(aRect.left, aRect.top, aRect.right - aRect.left, aRect.bottom - aRect.top,aColor);

  02384	8b 45 1c	 mov	 eax, DWORD PTR _aColor$[ebp]
  02387	50		 push	 eax
  02388	8b 4d 18	 mov	 ecx, DWORD PTR _aRect$[ebp+12]
  0238b	2b 4d 10	 sub	 ecx, DWORD PTR _aRect$[ebp+4]
  0238e	51		 push	 ecx
  0238f	8b 55 14	 mov	 edx, DWORD PTR _aRect$[ebp+8]
  02392	2b 55 0c	 sub	 edx, DWORD PTR _aRect$[ebp]
  02395	52		 push	 edx
  02396	8b 45 10	 mov	 eax, DWORD PTR _aRect$[ebp+4]
  02399	50		 push	 eax
  0239a	8b 4d 0c	 mov	 ecx, DWORD PTR _aRect$[ebp]
  0239d	51		 push	 ecx
  0239e	8b 4d e8	 mov	 ecx, DWORD PTR _pDC$[ebp]
  023a1	e8 00 00 00 00	 call	 ?FillSolidRect@CDC@@QAEXHHHHK@Z ; CDC::FillSolidRect

; 966  : 	pDC->SelectObject(pOldBrush);

  023a6	8b 55 e4	 mov	 edx, DWORD PTR _pOldBrush$[ebp]
  023a9	52		 push	 edx
  023aa	8b 4d e8	 mov	 ecx, DWORD PTR _pDC$[ebp]
  023ad	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCBrush@@PAV2@@Z ; CDC::SelectObject

; 967  : 	Brush.DeleteObject();

  023b2	8d 4d ec	 lea	 ecx, DWORD PTR _Brush$[ebp]
  023b5	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject

; 968  : 
; 969  : }

  023ba	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  023c1	8d 4d ec	 lea	 ecx, DWORD PTR _Brush$[ebp]
  023c4	e8 00 00 00 00	 call	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
  023c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  023cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  023d3	8b e5		 mov	 esp, ebp
  023d5	5d		 pop	 ebp
  023d6	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
text$x	SEGMENT
$L199837:
  00027	8d 4d ec	 lea	 ecx, DWORD PTR _Brush$[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
__ehhandler$?FillRectangle@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KH@Z:
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199839
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FillRectangle@CBitMapOperate@@UAEXPAUHDC__@@UtagRECT@@KH@Z ENDP ; CBitMapOperate::FillRectangle
PUBLIC	??0CPen@@QAE@XZ					; CPen::CPen
PUBLIC	?CreatePen@CPen@@QAEHHHK@Z			; CPen::CreatePen
PUBLIC	??1CPen@@UAE@XZ					; CPen::~CPen
EXTRN	?SelectObject@CDC@@QAEPAVCPen@@PAV2@@Z:NEAR	; CDC::SelectObject
EXTRN	?MoveTo@CDC@@QAE?AVCPoint@@HH@Z:NEAR		; CDC::MoveTo
EXTRN	?LineTo@CDC@@QAEHHH@Z:NEAR			; CDC::LineTo
xdata$x	SEGMENT
$T199848 DD	0ffffffffH
	DD	FLAT:$L199844
$T199846 DD	019930520H
	DD	01H
	DD	FLAT:$T199848
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T199843 = -36						; size = 8
_pOldPen$ = -28						; size = 4
_Pen$ = -24						; size = 8
_pDC$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_DC$ = 8						; size = 4
_aColor$ = 12						; size = 4
_afPenWidth$ = 16					; size = 4
_aiBeginLeft$ = 20					; size = 4
_aiBeginTop$ = 24					; size = 4
_aiEndLeft$ = 28					; size = 4
_aiEndTop$ = 32						; size = 4
_abEclosion$ = 36					; size = 4
?DrawLine@CBitMapOperate@@UAEXPAUHDC__@@KMHHHHH@Z PROC NEAR ; CBitMapOperate::DrawLine
; _this$ = ecx

; 971  : {

  023e0	55		 push	 ebp
  023e1	8b ec		 mov	 ebp, esp
  023e3	6a ff		 push	 -1
  023e5	68 00 00 00 00	 push	 __ehhandler$?DrawLine@CBitMapOperate@@UAEXPAUHDC__@@KMHHHHH@Z
  023ea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  023f0	50		 push	 eax
  023f1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  023f8	83 ec 1c	 sub	 esp, 28			; 0000001cH
  023fb	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 972  : 	CDC * pDC = CDC::FromHandle(DC);

  023fe	8b 45 08	 mov	 eax, DWORD PTR _DC$[ebp]
  02401	50		 push	 eax
  02402	e8 00 00 00 00	 call	 ?FromHandle@CDC@@SGPAV1@PAUHDC__@@@Z ; CDC::FromHandle
  02407	89 45 f0	 mov	 DWORD PTR _pDC$[ebp], eax

; 973  : 	CPen Pen, *pOldPen;

  0240a	8d 4d e8	 lea	 ecx, DWORD PTR _Pen$[ebp]
  0240d	e8 00 00 00 00	 call	 ??0CPen@@QAE@XZ		; CPen::CPen
  02412	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 974  : 	Pen.CreatePen(PS_SOLID, afPenWidth, aColor);	

  02419	8b 4d 0c	 mov	 ecx, DWORD PTR _aColor$[ebp]
  0241c	51		 push	 ecx
  0241d	d9 45 10	 fld	 DWORD PTR _afPenWidth$[ebp]
  02420	e8 00 00 00 00	 call	 __ftol2
  02425	50		 push	 eax
  02426	6a 00		 push	 0
  02428	8d 4d e8	 lea	 ecx, DWORD PTR _Pen$[ebp]
  0242b	e8 00 00 00 00	 call	 ?CreatePen@CPen@@QAEHHHK@Z ; CPen::CreatePen

; 975  : 	pOldPen = pDC->SelectObject(&Pen);

  02430	8d 55 e8	 lea	 edx, DWORD PTR _Pen$[ebp]
  02433	52		 push	 edx
  02434	8b 4d f0	 mov	 ecx, DWORD PTR _pDC$[ebp]
  02437	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCPen@@PAV2@@Z ; CDC::SelectObject
  0243c	89 45 e4	 mov	 DWORD PTR _pOldPen$[ebp], eax

; 976  : 
; 977  : 	pDC->MoveTo(aiBeginLeft, aiBeginTop);

  0243f	8b 45 18	 mov	 eax, DWORD PTR _aiBeginTop$[ebp]
  02442	50		 push	 eax
  02443	8b 4d 14	 mov	 ecx, DWORD PTR _aiBeginLeft$[ebp]
  02446	51		 push	 ecx
  02447	8d 55 dc	 lea	 edx, DWORD PTR $T199843[ebp]
  0244a	52		 push	 edx
  0244b	8b 4d f0	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0244e	e8 00 00 00 00	 call	 ?MoveTo@CDC@@QAE?AVCPoint@@HH@Z ; CDC::MoveTo

; 978  : 	pDC->LineTo(aiEndLeft, aiEndTop);

  02453	8b 45 20	 mov	 eax, DWORD PTR _aiEndTop$[ebp]
  02456	50		 push	 eax
  02457	8b 4d 1c	 mov	 ecx, DWORD PTR _aiEndLeft$[ebp]
  0245a	51		 push	 ecx
  0245b	8b 4d f0	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0245e	e8 00 00 00 00	 call	 ?LineTo@CDC@@QAEHHH@Z	; CDC::LineTo

; 979  : 	pDC->SelectObject(pOldPen);

  02463	8b 55 e4	 mov	 edx, DWORD PTR _pOldPen$[ebp]
  02466	52		 push	 edx
  02467	8b 4d f0	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0246a	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCPen@@PAV2@@Z ; CDC::SelectObject

; 980  : 	Pen.DeleteObject();

  0246f	8d 4d e8	 lea	 ecx, DWORD PTR _Pen$[ebp]
  02472	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject

; 981  : }

  02477	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0247e	8d 4d e8	 lea	 ecx, DWORD PTR _Pen$[ebp]
  02481	e8 00 00 00 00	 call	 ??1CPen@@UAE@XZ		; CPen::~CPen
  02486	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02489	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02490	8b e5		 mov	 esp, ebp
  02492	5d		 pop	 ebp
  02493	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
text$x	SEGMENT
$L199844:
  00039	8d 4d e8	 lea	 ecx, DWORD PTR _Pen$[ebp]
  0003c	e9 00 00 00 00	 jmp	 ??1CPen@@UAE@XZ		; CPen::~CPen
__ehhandler$?DrawLine@CBitMapOperate@@UAEXPAUHDC__@@KMHHHHH@Z:
  00041	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199846
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DrawLine@CBitMapOperate@@UAEXPAUHDC__@@KMHHHHH@Z ENDP	; CBitMapOperate::DrawLine
PUBLIC	??0CPoint@@QAE@HH@Z				; CPoint::CPoint
PUBLIC	?Polygon@CDC@@QAEHPAUtagPOINT@@H@Z		; CDC::Polygon
xdata$x	SEGMENT
$T199855 DD	0ffffffffH
	DD	FLAT:$L199850
	DD	00H
	DD	FLAT:$L199851
$T199853 DD	019930520H
	DD	02H
	DD	FLAT:$T199855
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -68						; size = 4
_pOldPen$ = -64						; size = 4
_pOldBrush$ = -60					; size = 4
_Pen$ = -56						; size = 8
_Points$ = -48						; size = 24
_pDC$ = -24						; size = 4
_Brush$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_DC$ = 8						; size = 4
_aColor$ = 12						; size = 4
_aiFirstLeft$ = 16					; size = 4
_aiFirstTop$ = 20					; size = 4
_aiSecondLeft$ = 24					; size = 4
_aiSecondTop$ = 28					; size = 4
_aiThirdLeft$ = 32					; size = 4
_aiThirdTop$ = 36					; size = 4
_aEclosion$ = 40					; size = 4
?DrawArrow@CBitMapOperate@@UAEXPAUHDC__@@KHHHHHHH@Z PROC NEAR ; CBitMapOperate::DrawArrow
; _this$ = ecx

; 984  : {

  024a0	55		 push	 ebp
  024a1	8b ec		 mov	 ebp, esp
  024a3	6a ff		 push	 -1
  024a5	68 00 00 00 00	 push	 __ehhandler$?DrawArrow@CBitMapOperate@@UAEXPAUHDC__@@KHHHHHHH@Z
  024aa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  024b0	50		 push	 eax
  024b1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  024b8	83 ec 38	 sub	 esp, 56			; 00000038H
  024bb	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 985  : 	CPoint Points[] = {CPoint(aiFirstLeft, aiFirstTop),

  024be	8b 45 14	 mov	 eax, DWORD PTR _aiFirstTop$[ebp]
  024c1	50		 push	 eax
  024c2	8b 4d 10	 mov	 ecx, DWORD PTR _aiFirstLeft$[ebp]
  024c5	51		 push	 ecx
  024c6	8d 4d d0	 lea	 ecx, DWORD PTR _Points$[ebp]
  024c9	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint

; 986  : 		CPoint(aiSecondLeft, aiSecondTop),

  024ce	8b 55 1c	 mov	 edx, DWORD PTR _aiSecondTop$[ebp]
  024d1	52		 push	 edx
  024d2	8b 45 18	 mov	 eax, DWORD PTR _aiSecondLeft$[ebp]
  024d5	50		 push	 eax
  024d6	8d 4d d8	 lea	 ecx, DWORD PTR _Points$[ebp+8]
  024d9	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint

; 987  : 		CPoint(aiThirdLeft, aiThirdTop),

  024de	8b 4d 24	 mov	 ecx, DWORD PTR _aiThirdTop$[ebp]
  024e1	51		 push	 ecx
  024e2	8b 55 20	 mov	 edx, DWORD PTR _aiThirdLeft$[ebp]
  024e5	52		 push	 edx
  024e6	8d 4d e0	 lea	 ecx, DWORD PTR _Points$[ebp+16]
  024e9	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint

; 988  : 	};
; 989  : 
; 990  : 	CDC * pDC = CDC::FromHandle(DC);

  024ee	8b 45 08	 mov	 eax, DWORD PTR _DC$[ebp]
  024f1	50		 push	 eax
  024f2	e8 00 00 00 00	 call	 ?FromHandle@CDC@@SGPAV1@PAUHDC__@@@Z ; CDC::FromHandle
  024f7	89 45 e8	 mov	 DWORD PTR _pDC$[ebp], eax

; 991  : 	CBrush Brush, *pOldBrush;

  024fa	8d 4d ec	 lea	 ecx, DWORD PTR _Brush$[ebp]
  024fd	e8 00 00 00 00	 call	 ??0CBrush@@QAE@XZ	; CBrush::CBrush
  02502	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 992  : 	Brush.CreateSolidBrush(aColor);

  02509	8b 4d 0c	 mov	 ecx, DWORD PTR _aColor$[ebp]
  0250c	51		 push	 ecx
  0250d	8d 4d ec	 lea	 ecx, DWORD PTR _Brush$[ebp]
  02510	e8 00 00 00 00	 call	 ?CreateSolidBrush@CBrush@@QAEHK@Z ; CBrush::CreateSolidBrush

; 993  : 	pOldBrush = pDC->SelectObject(&Brush);

  02515	8d 55 ec	 lea	 edx, DWORD PTR _Brush$[ebp]
  02518	52		 push	 edx
  02519	8b 4d e8	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0251c	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCBrush@@PAV2@@Z ; CDC::SelectObject
  02521	89 45 c4	 mov	 DWORD PTR _pOldBrush$[ebp], eax

; 994  : 	CPen Pen, *pOldPen;

  02524	8d 4d c8	 lea	 ecx, DWORD PTR _Pen$[ebp]
  02527	e8 00 00 00 00	 call	 ??0CPen@@QAE@XZ		; CPen::CPen
  0252c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 995  : 	Pen.CreatePen(PS_SOLID, 1, aColor);	

  02530	8b 45 0c	 mov	 eax, DWORD PTR _aColor$[ebp]
  02533	50		 push	 eax
  02534	6a 01		 push	 1
  02536	6a 00		 push	 0
  02538	8d 4d c8	 lea	 ecx, DWORD PTR _Pen$[ebp]
  0253b	e8 00 00 00 00	 call	 ?CreatePen@CPen@@QAEHHHK@Z ; CPen::CreatePen

; 996  : 	pOldPen = pDC->SelectObject(&Pen);

  02540	8d 4d c8	 lea	 ecx, DWORD PTR _Pen$[ebp]
  02543	51		 push	 ecx
  02544	8b 4d e8	 mov	 ecx, DWORD PTR _pDC$[ebp]
  02547	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCPen@@PAV2@@Z ; CDC::SelectObject
  0254c	89 45 c0	 mov	 DWORD PTR _pOldPen$[ebp], eax

; 997  : 
; 998  : 	pDC->Polygon(Points, 3);

  0254f	6a 03		 push	 3
  02551	8d 55 d0	 lea	 edx, DWORD PTR _Points$[ebp]
  02554	52		 push	 edx
  02555	8b 4d e8	 mov	 ecx, DWORD PTR _pDC$[ebp]
  02558	e8 00 00 00 00	 call	 ?Polygon@CDC@@QAEHPAUtagPOINT@@H@Z ; CDC::Polygon

; 999  : 	pDC->SelectObject(pOldBrush);

  0255d	8b 45 c4	 mov	 eax, DWORD PTR _pOldBrush$[ebp]
  02560	50		 push	 eax
  02561	8b 4d e8	 mov	 ecx, DWORD PTR _pDC$[ebp]
  02564	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCBrush@@PAV2@@Z ; CDC::SelectObject

; 1000 : 	pDC->SelectObject(pOldPen);

  02569	8b 4d c0	 mov	 ecx, DWORD PTR _pOldPen$[ebp]
  0256c	51		 push	 ecx
  0256d	8b 4d e8	 mov	 ecx, DWORD PTR _pDC$[ebp]
  02570	e8 00 00 00 00	 call	 ?SelectObject@CDC@@QAEPAVCPen@@PAV2@@Z ; CDC::SelectObject

; 1001 : 
; 1002 : 	Pen.DeleteObject();

  02575	8d 4d c8	 lea	 ecx, DWORD PTR _Pen$[ebp]
  02578	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject

; 1003 : 	Brush.DeleteObject();

  0257d	8d 4d ec	 lea	 ecx, DWORD PTR _Brush$[ebp]
  02580	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject

; 1004 : }

  02585	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02589	8d 4d c8	 lea	 ecx, DWORD PTR _Pen$[ebp]
  0258c	e8 00 00 00 00	 call	 ??1CPen@@UAE@XZ		; CPen::~CPen
  02591	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02598	8d 4d ec	 lea	 ecx, DWORD PTR _Brush$[ebp]
  0259b	e8 00 00 00 00	 call	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
  025a0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  025a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  025aa	8b e5		 mov	 esp, ebp
  025ac	5d		 pop	 ebp
  025ad	c2 24 00	 ret	 36			; 00000024H
_TEXT	ENDS
text$x	SEGMENT
$L199850:
  0004b	8d 4d ec	 lea	 ecx, DWORD PTR _Brush$[ebp]
  0004e	e9 00 00 00 00	 jmp	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
$L199851:
  00053	8d 4d c8	 lea	 ecx, DWORD PTR _Pen$[ebp]
  00056	e9 00 00 00 00	 jmp	 ??1CPen@@UAE@XZ		; CPen::~CPen
__ehhandler$?DrawArrow@CBitMapOperate@@UAEXPAUHDC__@@KHHHHHHH@Z:
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199853
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DrawArrow@CBitMapOperate@@UAEXPAUHDC__@@KHHHHHHH@Z ENDP ; CBitMapOperate::DrawArrow
PUBLIC	?BeforeChangeColor@CBitMapOperate@@QAEXXZ	; CBitMapOperate::BeforeChangeColor
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BeforeChangeColor@CBitMapOperate@@QAEXXZ PROC NEAR	; CBitMapOperate::BeforeChangeColor
; _this$ = ecx

; 1006 : {

  025b0	55		 push	 ebp
  025b1	8b ec		 mov	 ebp, esp
  025b3	51		 push	 ecx
  025b4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1007 : 	memset(&m_clrMap, 0, sizeof(COLORREF) * 65535);

  025b7	68 fc ff 03 00	 push	 262140			; 0003fffcH
  025bc	6a 00		 push	 0
  025be	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  025c1	83 c0 1c	 add	 eax, 28			; 0000001cH
  025c4	50		 push	 eax
  025c5	e8 00 00 00 00	 call	 _memset
  025ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1008 : }

  025cd	8b e5		 mov	 esp, ebp
  025cf	5d		 pop	 ebp
  025d0	c3		 ret	 0
?BeforeChangeColor@CBitMapOperate@@QAEXXZ ENDP		; CBitMapOperate::BeforeChangeColor
_TEXT	ENDS
PUBLIC	?BrightColor@CBitMapOperate@@QAEKKM@Z		; CBitMapOperate::BrightColor
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -20						; size = 4
_lColor$ = -16						; size = 4
_lfSaturation$ = -12					; size = 4
_lfBrightness$ = -8					; size = 4
_lfHue$ = -4						; size = 4
_aSourceColor$ = 8					; size = 4
_afAmount$ = 12						; size = 4
?BrightColor@CBitMapOperate@@QAEKKM@Z PROC NEAR		; CBitMapOperate::BrightColor
; _this$ = ecx

; 1010 : {

  025e0	55		 push	 ebp
  025e1	8b ec		 mov	 ebp, esp
  025e3	83 ec 14	 sub	 esp, 20			; 00000014H
  025e6	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1011 : 	FLOAT lfHue, lfBrightness, lfSaturation;
; 1012 : 	COLORREF lColor = aSourceColor;

  025e9	8b 45 08	 mov	 eax, DWORD PTR _aSourceColor$[ebp]
  025ec	89 45 f0	 mov	 DWORD PTR _lColor$[ebp], eax

; 1013 : 
; 1014 : 	SetHBS(lColor, lfHue, lfBrightness, lfSaturation);

  025ef	8d 4d f4	 lea	 ecx, DWORD PTR _lfSaturation$[ebp]
  025f2	51		 push	 ecx
  025f3	8d 55 f8	 lea	 edx, DWORD PTR _lfBrightness$[ebp]
  025f6	52		 push	 edx
  025f7	8d 45 fc	 lea	 eax, DWORD PTR _lfHue$[ebp]
  025fa	50		 push	 eax
  025fb	8b 4d f0	 mov	 ecx, DWORD PTR _lColor$[ebp]
  025fe	51		 push	 ecx
  025ff	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02602	e8 00 00 00 00	 call	 ?SetHBS@CBitMapOperate@@QAEXKAAM00@Z ; CBitMapOperate::SetHBS

; 1015 : 	if (afAmount > 0 && afAmount < 1)

  02607	d9 45 0c	 fld	 DWORD PTR _afAmount$[ebp]
  0260a	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  02610	df e0		 fnstsw	 ax
  02612	f6 c4 41	 test	 ah, 65			; 00000041H
  02615	75 2e		 jne	 SHORT $L199071
  02617	d9 45 0c	 fld	 DWORD PTR _afAmount$[ebp]
  0261a	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f800000
  02620	df e0		 fnstsw	 ax
  02622	f6 c4 05	 test	 ah, 5
  02625	7a 1e		 jp	 SHORT $L199071

; 1016 : 	{
; 1017 : 		lfBrightness = afAmount;

  02627	8b 55 0c	 mov	 edx, DWORD PTR _afAmount$[ebp]
  0262a	89 55 f8	 mov	 DWORD PTR _lfBrightness$[ebp], edx

; 1018 : 		SetRGB(lColor, lfHue, lfBrightness, lfSaturation);

  0262d	8b 45 f4	 mov	 eax, DWORD PTR _lfSaturation$[ebp]
  02630	50		 push	 eax
  02631	8b 4d f8	 mov	 ecx, DWORD PTR _lfBrightness$[ebp]
  02634	51		 push	 ecx
  02635	8b 55 fc	 mov	 edx, DWORD PTR _lfHue$[ebp]
  02638	52		 push	 edx
  02639	8d 45 f0	 lea	 eax, DWORD PTR _lColor$[ebp]
  0263c	50		 push	 eax
  0263d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02640	e8 00 00 00 00	 call	 ?SetRGB@CBitMapOperate@@QAEXAAKMMM@Z ; CBitMapOperate::SetRGB
$L199071:

; 1019 : 	}
; 1020 : 
; 1021 : 	return lColor;

  02645	8b 45 f0	 mov	 eax, DWORD PTR _lColor$[ebp]

; 1022 : }

  02648	8b e5		 mov	 esp, ebp
  0264a	5d		 pop	 ebp
  0264b	c2 08 00	 ret	 8
?BrightColor@CBitMapOperate@@QAEKKM@Z ENDP		; CBitMapOperate::BrightColor
_TEXT	ENDS
PUBLIC	?GetTextColor@CDC@@QBEKXZ			; CDC::GetTextColor
PUBLIC	??0CFont@@QAE@XZ				; CFont::CFont
PUBLIC	?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z ; CFont::CreateFontIndirectA
PUBLIC	??1CFont@@UAE@XZ				; CFont::~CFont
EXTRN	__imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:NEAR
EXTRN	__imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ:NEAR
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp__SetBkMode@8:NEAR
EXTRN	__imp__DrawTextA@20:NEAR
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	__imp__GetDeviceCaps@8:NEAR
EXTRN	_strcpy:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__imp__MulDiv@12:NEAR
xdata$x	SEGMENT
$T199867 DD	0ffffffffH
	DD	FLAT:$L199860
	DD	00H
	DD	FLAT:$L199861
	DD	01H
	DD	FLAT:$L199862
$T199864 DD	019930520H
	DD	03H
	DD	FLAT:$T199867
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -96						; size = 4
_oldFont$ = -92						; size = 4
_font$ = -88						; size = 8
_lf$ = -80						; size = 60
__$ArrayPad$ = -20					; size = 4
_ltempColor$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_apDC$ = 8						; size = 4
_astrText$ = 12						; size = 4
_acolText$ = 16						; size = 4
_lrectText$ = 20					; size = 4
_anFormat$ = 24						; size = 4
_abUnderLine$ = 28					; size = 1
_anWidth$ = 32						; size = 4
_anSize$ = 36						; size = 4
_anSet$ = 40						; size = 4
_strTextName$ = 44					; size = 28
?DrawTextA@CBitMapOperate@@UAEXPAVCDC@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@KAAUtagRECT@@I_NIIIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; CBitMapOperate::DrawTextA
; _this$ = ecx

; 1024 : {

  02650	55		 push	 ebp
  02651	8b ec		 mov	 ebp, esp
  02653	6a ff		 push	 -1
  02655	68 00 00 00 00	 push	 __ehhandler$?DrawTextA@CBitMapOperate@@UAEXPAVCDC@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@KAAUtagRECT@@I_NIIIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0265a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02660	50		 push	 eax
  02661	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02668	83 ec 54	 sub	 esp, 84			; 00000054H
  0266b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02670	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02673	89 4d a0	 mov	 DWORD PTR _this$[ebp], ecx
  02676	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1025 : 	if( !(apDC->m_hDC) ) return; 

  0267d	8b 45 08	 mov	 eax, DWORD PTR _apDC$[ebp]
  02680	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  02684	75 22		 jne	 SHORT $L199085
  02686	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0268a	8d 4d 0c	 lea	 ecx, DWORD PTR _astrText$[ebp]
  0268d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  02693	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0269a	8d 4d 2c	 lea	 ecx, DWORD PTR _strTextName$[ebp]
  0269d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  026a3	e9 89 01 00 00	 jmp	 $L199084
$L199085:

; 1026 : 	apDC->SetTextColor(acolText);

  026a8	8b 4d 10	 mov	 ecx, DWORD PTR _acolText$[ebp]
  026ab	51		 push	 ecx
  026ac	8b 55 08	 mov	 edx, DWORD PTR _apDC$[ebp]
  026af	8b 02		 mov	 eax, DWORD PTR [edx]
  026b1	8b 4d 08	 mov	 ecx, DWORD PTR _apDC$[ebp]
  026b4	ff 50 38	 call	 DWORD PTR [eax+56]

; 1027 : 	SetBkMode(apDC->m_hDC, TRANSPARENT);

  026b7	6a 01		 push	 1
  026b9	8b 4d 08	 mov	 ecx, DWORD PTR _apDC$[ebp]
  026bc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  026bf	52		 push	 edx
  026c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkMode@8

; 1028 : 	COLORREF ltempColor = apDC->GetTextColor();

  026c6	8b 4d 08	 mov	 ecx, DWORD PTR _apDC$[ebp]
  026c9	e8 00 00 00 00	 call	 ?GetTextColor@CDC@@QBEKXZ ; CDC::GetTextColor
  026ce	89 45 f0	 mov	 DWORD PTR _ltempColor$[ebp], eax

; 1029 : 	LOGFONT  lf;
; 1030 : 	ZeroMemory(&lf,sizeof(lf));

  026d1	6a 3c		 push	 60			; 0000003cH
  026d3	6a 00		 push	 0
  026d5	8d 45 b0	 lea	 eax, DWORD PTR _lf$[ebp]
  026d8	50		 push	 eax
  026d9	e8 00 00 00 00	 call	 _memset
  026de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1031 : 	lf.lfHeight=-MulDiv(anSize,GetDeviceCaps(apDC->m_hDC,LOGPIXELSY),72); // 12

  026e1	6a 48		 push	 72			; 00000048H
  026e3	6a 5a		 push	 90			; 0000005aH
  026e5	8b 4d 08	 mov	 ecx, DWORD PTR _apDC$[ebp]
  026e8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  026eb	52		 push	 edx
  026ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8
  026f2	50		 push	 eax
  026f3	8b 45 24	 mov	 eax, DWORD PTR _anSize$[ebp]
  026f6	50		 push	 eax
  026f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  026fd	f7 d8		 neg	 eax
  026ff	89 45 b0	 mov	 DWORD PTR _lf$[ebp], eax

; 1032 : 	lf.lfWeight= anWidth;//FW_NORMAL

  02702	8b 4d 20	 mov	 ecx, DWORD PTR _anWidth$[ebp]
  02705	89 4d c0	 mov	 DWORD PTR _lf$[ebp+16], ecx

; 1033 : 	lf.lfWidth =0;

  02708	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _lf$[ebp+4], 0

; 1034 : 	lf.lfStrikeOut = FALSE;

  0270f	c6 45 c6 00	 mov	 BYTE PTR _lf$[ebp+22], 0

; 1035 : 	lf.lfCharSet=anSet;

  02713	8a 55 28	 mov	 dl, BYTE PTR _anSet$[ebp]
  02716	88 55 c7	 mov	 BYTE PTR _lf$[ebp+23], dl

; 1036 : 	lf.lfOutPrecision=OUT_DEFAULT_PRECIS;

  02719	c6 45 c8 00	 mov	 BYTE PTR _lf$[ebp+24], 0

; 1037 : 	lf.lfClipPrecision=CLIP_DEFAULT_PRECIS;

  0271d	c6 45 c9 00	 mov	 BYTE PTR _lf$[ebp+25], 0

; 1038 : 	lf.lfQuality=DEFAULT_QUALITY;

  02721	c6 45 ca 00	 mov	 BYTE PTR _lf$[ebp+26], 0

; 1039 : 	lf.lfPitchAndFamily=FF_DONTCARE | DEFAULT_PITCH;

  02725	c6 45 cb 00	 mov	 BYTE PTR _lf$[ebp+27], 0

; 1040 : 	lf.lfUnderline = abUnderLine;

  02729	8a 45 1c	 mov	 al, BYTE PTR _abUnderLine$[ebp]
  0272c	88 45 c5	 mov	 BYTE PTR _lf$[ebp+21], al

; 1041 : 	if( 0 != strTextName.size() )

  0272f	8d 4d 2c	 lea	 ecx, DWORD PTR _strTextName$[ebp]
  02732	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  02738	85 c0		 test	 eax, eax
  0273a	74 11		 je	 SHORT $L199088

; 1042 : 	{
; 1043 : 		strcpy(lf.lfFaceName, ""/*strTextName.c_str()*/ );

  0273c	68 00 00 00 00	 push	 OFFSET FLAT:$SG199089
  02741	8d 4d cc	 lea	 ecx, DWORD PTR _lf$[ebp+28]
  02744	51		 push	 ecx
  02745	e8 00 00 00 00	 call	 _strcpy
  0274a	83 c4 08	 add	 esp, 8
$L199088:

; 1044 : 	}
; 1045 : 
; 1046 : 	CFont font;

  0274d	8d 4d a8	 lea	 ecx, DWORD PTR _font$[ebp]
  02750	e8 00 00 00 00	 call	 ??0CFont@@QAE@XZ	; CFont::CFont
  02755	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 1047 : 	font.CreateFontIndirect(&lf);

  02759	8d 55 b0	 lea	 edx, DWORD PTR _lf$[ebp]
  0275c	52		 push	 edx
  0275d	8d 4d a8	 lea	 ecx, DWORD PTR _font$[ebp]
  02760	e8 00 00 00 00	 call	 ?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z ; CFont::CreateFontIndirectA

; 1048 : 	CFont* oldFont = (CFont*)apDC->SelectObject(&font);

  02765	8d 45 a8	 lea	 eax, DWORD PTR _font$[ebp]
  02768	50		 push	 eax
  02769	8b 4d 08	 mov	 ecx, DWORD PTR _apDC$[ebp]
  0276c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0276e	8b 4d 08	 mov	 ecx, DWORD PTR _apDC$[ebp]
  02771	ff 52 30	 call	 DWORD PTR [edx+48]
  02774	89 45 a4	 mov	 DWORD PTR _oldFont$[ebp], eax

; 1049 : 	if ( abUnderLine )

  02777	0f b6 45 1c	 movzx	 eax, BYTE PTR _abUnderLine$[ebp]
  0277b	85 c0		 test	 eax, eax
  0277d	74 34		 je	 SHORT $L199093

; 1050 : 	{
; 1051 : 		::DrawText(
; 1052 : 			apDC->m_hDC,
; 1053 : 			astrText,
; 1054 : 			astrText.GetLength(),
; 1055 : 			&lrectText,
; 1056 : 			anFormat|DT_WORDBREAK|DT_END_ELLIPSIS
; 1057 : 			);

  0277f	8b 4d 18	 mov	 ecx, DWORD PTR _anFormat$[ebp]
  02782	83 c9 10	 or	 ecx, 16			; 00000010H
  02785	81 c9 00 80 00
	00		 or	 ecx, 32768		; 00008000H
  0278b	51		 push	 ecx
  0278c	8b 55 14	 mov	 edx, DWORD PTR _lrectText$[ebp]
  0278f	52		 push	 edx
  02790	8d 4d 0c	 lea	 ecx, DWORD PTR _astrText$[ebp]
  02793	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  02799	50		 push	 eax
  0279a	8d 4d 0c	 lea	 ecx, DWORD PTR _astrText$[ebp]
  0279d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  027a3	50		 push	 eax
  027a4	8b 45 08	 mov	 eax, DWORD PTR _apDC$[ebp]
  027a7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  027aa	51		 push	 ecx
  027ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawTextA@20

; 1058 : 	}
; 1059 : 	else

  027b1	eb 2f		 jmp	 SHORT $L199094
$L199093:

; 1060 : 	{
; 1061 : 		::DrawText(
; 1062 : 			apDC->m_hDC,
; 1063 : 			astrText,
; 1064 : 			astrText.GetLength(),
; 1065 : 			&lrectText,
; 1066 : 			anFormat|DT_END_ELLIPSIS
; 1067 : 			);

  027b3	8b 55 18	 mov	 edx, DWORD PTR _anFormat$[ebp]
  027b6	81 ca 00 80 00
	00		 or	 edx, 32768		; 00008000H
  027bc	52		 push	 edx
  027bd	8b 45 14	 mov	 eax, DWORD PTR _lrectText$[ebp]
  027c0	50		 push	 eax
  027c1	8d 4d 0c	 lea	 ecx, DWORD PTR _astrText$[ebp]
  027c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  027ca	50		 push	 eax
  027cb	8d 4d 0c	 lea	 ecx, DWORD PTR _astrText$[ebp]
  027ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  027d4	50		 push	 eax
  027d5	8b 4d 08	 mov	 ecx, DWORD PTR _apDC$[ebp]
  027d8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  027db	52		 push	 edx
  027dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawTextA@20
$L199094:

; 1068 : 	}
; 1069 : 	apDC->SetTextColor(ltempColor);

  027e2	8b 45 f0	 mov	 eax, DWORD PTR _ltempColor$[ebp]
  027e5	50		 push	 eax
  027e6	8b 4d 08	 mov	 ecx, DWORD PTR _apDC$[ebp]
  027e9	8b 11		 mov	 edx, DWORD PTR [ecx]
  027eb	8b 4d 08	 mov	 ecx, DWORD PTR _apDC$[ebp]
  027ee	ff 52 38	 call	 DWORD PTR [edx+56]

; 1070 : 	apDC->SelectObject(oldFont);

  027f1	8b 45 a4	 mov	 eax, DWORD PTR _oldFont$[ebp]
  027f4	50		 push	 eax
  027f5	8b 4d 08	 mov	 ecx, DWORD PTR _apDC$[ebp]
  027f8	8b 11		 mov	 edx, DWORD PTR [ecx]
  027fa	8b 4d 08	 mov	 ecx, DWORD PTR _apDC$[ebp]
  027fd	ff 52 30	 call	 DWORD PTR [edx+48]

; 1071 : 	font.DeleteObject();

  02800	8d 4d a8	 lea	 ecx, DWORD PTR _font$[ebp]
  02803	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject

; 1072 : }

  02808	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0280c	8d 4d a8	 lea	 ecx, DWORD PTR _font$[ebp]
  0280f	e8 00 00 00 00	 call	 ??1CFont@@UAE@XZ	; CFont::~CFont
  02814	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02818	8d 4d 0c	 lea	 ecx, DWORD PTR _astrText$[ebp]
  0281b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  02821	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02828	8d 4d 2c	 lea	 ecx, DWORD PTR _strTextName$[ebp]
  0282b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L199084:
  02831	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02834	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0283b	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0283e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02843	8b e5		 mov	 esp, ebp
  02845	5d		 pop	 ebp
  02846	c2 40 00	 ret	 64			; 00000040H
_TEXT	ENDS
text$x	SEGMENT
$L199860:
  00065	8d 4d 2c	 lea	 ecx, DWORD PTR _strTextName$[ebp]
  00068	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L199861:
  0006e	8d 4d 0c	 lea	 ecx, DWORD PTR _astrText$[ebp]
  00071	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L199862:
  00077	8d 4d a8	 lea	 ecx, DWORD PTR _font$[ebp]
  0007a	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
__ehhandler$?DrawTextA@CBitMapOperate@@UAEXPAVCDC@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@KAAUtagRECT@@I_NIIIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  0007f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199864
  00084	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DrawTextA@CBitMapOperate@@UAEXPAVCDC@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@KAAUtagRECT@@I_NIIIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CBitMapOperate::DrawTextA
PUBLIC	?AfterChangeColor@CBitMapOperate@@QAEXXZ	; CBitMapOperate::AfterChangeColor
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AfterChangeColor@CBitMapOperate@@QAEXXZ PROC NEAR	; CBitMapOperate::AfterChangeColor
; _this$ = ecx

; 1074 : {

  02850	55		 push	 ebp
  02851	8b ec		 mov	 ebp, esp
  02853	51		 push	 ecx
  02854	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1075 : }

  02857	8b e5		 mov	 esp, ebp
  02859	5d		 pop	 ebp
  0285a	c3		 ret	 0
?AfterChangeColor@CBitMapOperate@@QAEXXZ ENDP		; CBitMapOperate::AfterChangeColor
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 304  : 		iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::const_iterator::const_iterator

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::iterator::iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 193  : 			{	// construct with null node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 194  : 			}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initX$ = 8						; size = 4
_initY$ = 12						; size = 4
??0CPoint@@QAE@HH@Z PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 63   : 	{ x = initX; y = initY; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _initX$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _initY$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0CPoint@@QAE@HH@Z ENDP				; CPoint::CPoint
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
??0CRect@@QAE@HHHH@Z PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 112  : 	{ left = l; top = t; right = r; bottom = b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _r$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _b$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
??0CRect@@QAE@HHHH@Z ENDP				; CRect::CRect
_TEXT	ENDS
PUBLIC	??0CSimpleException@@QAE@XZ			; CSimpleException::CSimpleException
PUBLIC	??_7CMemoryException@@6B@			; CMemoryException::`vftable'
PUBLIC	??_GCMemoryException@@UAEPAXI@Z			; CMemoryException::`scalar deleting destructor'
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CSimpleException@@8		; CSimpleException::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCSimpleException@@@8			; CSimpleException `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CException@@8			; CException::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCException@@@8				; CException `RTTI Type Descriptor'
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	??_R4CMemoryException@@6B@			; CMemoryException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMemoryException@@@8			; CMemoryException `RTTI Type Descriptor'
PUBLIC	??_R3CMemoryException@@8			; CMemoryException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMemoryException@@8			; CMemoryException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CMemoryException@@8		; CMemoryException::`RTTI Base Class Descriptor at (0,-1,0,0)'
EXTRN	?GetErrorMessage@CSimpleException@@UAEHPADIPAI@Z:NEAR ; CSimpleException::GetErrorMessage
EXTRN	?GetRuntimeClass@CMemoryException@@UBEPAUCRuntimeClass@@XZ:NEAR ; CMemoryException::GetRuntimeClass
EXTRN	??_ECMemoryException@@UAEPAXI@Z:NEAR		; CMemoryException::`vector deleting destructor'
;	COMDAT ??_7CMemoryException@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
CONST	SEGMENT
??_7CMemoryException@@6B@ DD FLAT:??_R4CMemoryException@@6B@ ; CMemoryException::`vftable'
	DD	FLAT:?GetRuntimeClass@CMemoryException@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECMemoryException@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?GetErrorMessage@CSimpleException@@UAEHPADIPAI@Z
	DD	FLAT:?ReportError@CException@@UAEHII@Z
CONST	ENDS
;	COMDAT ??_R4CMemoryException@@6B@
rdata$r	SEGMENT
??_R4CMemoryException@@6B@ DD 00H			; CMemoryException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMemoryException@@@8
	DD	FLAT:??_R3CMemoryException@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMemoryException@@@8
_DATA	SEGMENT
??_R0?AVCMemoryException@@@8 DD FLAT:??_7type_info@@6B@	; CMemoryException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMemoryException@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CMemoryException@@8
rdata$r	SEGMENT
??_R3CMemoryException@@8 DD 00H				; CMemoryException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CMemoryException@@8
rdata$r	ENDS
;	COMDAT ??_R2CMemoryException@@8
rdata$r	SEGMENT
??_R2CMemoryException@@8 DD FLAT:??_R1A@?0A@A@CMemoryException@@8 ; CMemoryException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CSimpleException@@8
	DD	FLAT:??_R1A@?0A@A@CException@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMemoryException@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CMemoryException@@8 DD FLAT:??_R0?AVCMemoryException@@@8 ; CMemoryException::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSimpleException@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CSimpleException@@8 DD FLAT:??_R0?AVCSimpleException@@@8 ; CSimpleException::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCSimpleException@@@8
_DATA	SEGMENT
??_R0?AVCSimpleException@@@8 DD FLAT:??_7type_info@@6B@	; CSimpleException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSimpleException@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CException@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CException@@8 DD FLAT:??_R0?AVCException@@@8 ; CException::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCException@@@8
_DATA	SEGMENT
??_R0?AVCException@@@8 DD FLAT:??_7type_info@@6B@	; CException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCException@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0CMemoryException@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMemoryException@@QAE@XZ PROC NEAR			; CMemoryException::CMemoryException, COMDAT
; _this$ = ecx

; 64   : 	: CSimpleException() { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CSimpleException@@QAE@XZ ; CSimpleException::CSimpleException
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMemoryException@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CMemoryException@@QAE@XZ ENDP			; CMemoryException::CMemoryException
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC NEAR	; CObject::Serialize, COMDAT
; _this$ = ecx

; 25   : 	{ /* CObject does not serialize anything by default */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AssertValid@CObject@@UBEXXZ PROC NEAR			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 41   : 	{ /* no asserts in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC NEAR	; CObject::Dump, COMDAT
; _this$ = ecx

; 43   : 	{ /* no dumping in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
EXTRN	??0CException@@QAE@XZ:NEAR			; CException::CException
; Function compile flags: /Odt
;	COMDAT ??0CSimpleException@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CSimpleException@@QAE@XZ PROC NEAR			; CSimpleException::CSimpleException, COMDAT
; _this$ = ecx

; 57   : 	{ m_bInitialized = FALSE; m_bLoaded = FALSE; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CException@@QAE@XZ	; CException::CException
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0CSimpleException@@QAE@XZ ENDP			; CSimpleException::CSimpleException
_TEXT	ENDS
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
; Function compile flags: /Odt
;	COMDAT ??_GCMemoryException@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCMemoryException@@UAEPAXI@Z PROC NEAR		; CMemoryException::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMemoryException@@UAE@XZ ; CMemoryException::~CMemoryException
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L33008
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L33008:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCMemoryException@@UAEPAXI@Z ENDP			; CMemoryException::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC NEAR				; CObject::operator delete, COMDAT

; 31   : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
_TEXT	ENDS
PUBLIC	??1CSimpleException@@UAE@XZ			; CSimpleException::~CSimpleException
; Function compile flags: /Odt
;	COMDAT ??1CMemoryException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMemoryException@@UAE@XZ PROC NEAR			; CMemoryException::~CMemoryException, COMDAT
; _this$ = ecx

; 68   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMemoryException@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CSimpleException@@UAE@XZ ; CSimpleException::~CSimpleException
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CMemoryException@@UAE@XZ ENDP			; CMemoryException::~CMemoryException
_TEXT	ENDS
PUBLIC	??1CException@@UAE@XZ				; CException::~CException
; Function compile flags: /Odt
;	COMDAT ??1CSimpleException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CSimpleException@@UAE@XZ PROC NEAR			; CSimpleException::~CSimpleException, COMDAT
; _this$ = ecx

; 61   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CException@@UAE@XZ	; CException::~CException
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CSimpleException@@UAE@XZ ENDP			; CSimpleException::~CSimpleException
_TEXT	ENDS
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
; Function compile flags: /Odt
;	COMDAT ??1CException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CException@@UAE@XZ PROC NEAR				; CException::~CException, COMDAT
; _this$ = ecx

; 55   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CObject@@UAE@XZ	; CObject::~CObject
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CException@@UAE@XZ ENDP				; CException::~CException
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CObject@@UAE@XZ PROC NEAR				; CObject::~CObject, COMDAT
; _this$ = ecx

; 23   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
_TEXT	ENDS
PUBLIC	??_R0?AVCGdiObject@@@8				; CGdiObject `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CGdiObject@@8			; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4CPen@@6B@					; CPen::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPen@@@8				; CPen `RTTI Type Descriptor'
PUBLIC	??_R3CPen@@8					; CPen::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPen@@8					; CPen::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CPen@@8				; CPen::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0CGdiObject@@QAE@XZ				; CGdiObject::CGdiObject
PUBLIC	??_7CPen@@6B@					; CPen::`vftable'
PUBLIC	??_GCPen@@UAEPAXI@Z				; CPen::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CPen@@UBEPAUCRuntimeClass@@XZ:NEAR ; CPen::GetRuntimeClass
EXTRN	??_ECPen@@UAEPAXI@Z:NEAR			; CPen::`vector deleting destructor'
;	COMDAT ??_7CPen@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
CONST	SEGMENT
??_7CPen@@6B@ DD FLAT:??_R4CPen@@6B@			; CPen::`vftable'
	DD	FLAT:?GetRuntimeClass@CPen@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECPen@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CPen@@6B@
rdata$r	SEGMENT
??_R4CPen@@6B@ DD 00H					; CPen::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPen@@@8
	DD	FLAT:??_R3CPen@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPen@@@8
_DATA	SEGMENT
??_R0?AVCPen@@@8 DD FLAT:??_7type_info@@6B@		; CPen `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPen@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CPen@@8
rdata$r	SEGMENT
??_R3CPen@@8 DD	00H					; CPen::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CPen@@8
rdata$r	ENDS
;	COMDAT ??_R2CPen@@8
rdata$r	SEGMENT
??_R2CPen@@8 DD	FLAT:??_R1A@?0A@A@CPen@@8		; CPen::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CPen@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CPen@@8 DD FLAT:??_R0?AVCPen@@@8		; CPen::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CGdiObject@@8 DD FLAT:??_R0?AVCGdiObject@@@8 ; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
_DATA	SEGMENT
??_R0?AVCGdiObject@@@8 DD FLAT:??_7type_info@@6B@	; CGdiObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGdiObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0CPen@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CPen@@QAE@XZ PROC NEAR				; CPen::CPen, COMDAT
; _this$ = ecx

; 104  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CGdiObject@@QAE@XZ	; CGdiObject::CGdiObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CPen@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CPen@@QAE@XZ ENDP					; CPen::CPen
_TEXT	ENDS
PUBLIC	??_R4CGdiObject@@6B@				; CGdiObject::`RTTI Complete Object Locator'
PUBLIC	??_R3CGdiObject@@8				; CGdiObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGdiObject@@8				; CGdiObject::`RTTI Base Class Array'
PUBLIC	??0CObject@@IAE@XZ				; CObject::CObject
PUBLIC	??_7CGdiObject@@6B@				; CGdiObject::`vftable'
PUBLIC	??_GCGdiObject@@UAEPAXI@Z			; CGdiObject::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ:NEAR ; CGdiObject::GetRuntimeClass
EXTRN	??_ECGdiObject@@UAEPAXI@Z:NEAR			; CGdiObject::`vector deleting destructor'
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT
??_7CGdiObject@@6B@ DD FLAT:??_R4CGdiObject@@6B@	; CGdiObject::`vftable'
	DD	FLAT:?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECGdiObject@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT
??_R4CGdiObject@@6B@ DD 00H				; CGdiObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGdiObject@@@8
	DD	FLAT:??_R3CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT
??_R3CGdiObject@@8 DD 00H				; CGdiObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT
??_R2CGdiObject@@8 DD FLAT:??_R1A@?0A@A@CGdiObject@@8	; CGdiObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CObject@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CGdiObject@@QAE@XZ PROC NEAR				; CGdiObject::CGdiObject, COMDAT
; _this$ = ecx

; 82   : 	{ m_hObject = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CObject@@IAE@XZ	; CObject::CObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CGdiObject@@6B@
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0CGdiObject@@QAE@XZ ENDP				; CGdiObject::CGdiObject
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CObject@@IAE@XZ PROC NEAR				; CObject::CObject, COMDAT
; _this$ = ecx

; 21   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CObject@@IAE@XZ ENDP					; CObject::CObject
_TEXT	ENDS
PUBLIC	??1CGdiObject@@UAE@XZ				; CGdiObject::~CGdiObject
; Function compile flags: /Odt
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGdiObject@@UAEPAXI@Z PROC NEAR			; CGdiObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41495
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41495:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCGdiObject@@UAEPAXI@Z ENDP				; CGdiObject::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
xdata$x	SEGMENT
$T199919 DD	0ffffffffH
	DD	FLAT:$L199915
$T199917 DD	019930520H
	DD	01H
	DD	FLAT:$T199919
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CGdiObject@@UAE@XZ PROC NEAR				; CGdiObject::~CGdiObject, COMDAT
; _this$ = ecx

; 84   : 	{ DeleteObject(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGdiObject@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CGdiObject@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject
  00034	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CObject@@UAE@XZ	; CObject::~CObject
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L199915:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CObject@@UAE@XZ	; CObject::~CObject
__ehhandler$??1CGdiObject@@UAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199917
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CGdiObject@@UAE@XZ ENDP				; CGdiObject::~CGdiObject
; Function compile flags: /Odt
;	COMDAT ??_GCPen@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCPen@@UAEPAXI@Z PROC NEAR				; CPen::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CPen@@UAE@XZ		; CPen::~CPen
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41541
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41541:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCPen@@UAEPAXI@Z ENDP				; CPen::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CPen@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CPen@@UAE@XZ PROC NEAR				; CPen::~CPen, COMDAT
; _this$ = ecx

; 106  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CPen@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CPen@@UAE@XZ ENDP					; CPen::~CPen
_TEXT	ENDS
EXTRN	__imp__CreatePen@12:NEAR
EXTRN	?Attach@CGdiObject@@QAEHPAX@Z:NEAR		; CGdiObject::Attach
; Function compile flags: /Odt
;	COMDAT ?CreatePen@CPen@@QAEHHHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nPenStyle$ = 8						; size = 4
_nWidth$ = 12						; size = 4
_crColor$ = 16						; size = 4
?CreatePen@CPen@@QAEHHHK@Z PROC NEAR			; CPen::CreatePen, COMDAT
; _this$ = ecx

; 108  : 	{ return Attach(::CreatePen(nPenStyle, nWidth, crColor)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 10	 mov	 eax, DWORD PTR _crColor$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _nWidth$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR _nPenStyle$[ebp]
  00012	52		 push	 edx
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreatePen@12
  00019	50		 push	 eax
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
?CreatePen@CPen@@QAEHHHK@Z ENDP				; CPen::CreatePen
_TEXT	ENDS
PUBLIC	??_R4CBrush@@6B@				; CBrush::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBrush@@@8				; CBrush `RTTI Type Descriptor'
PUBLIC	??_R3CBrush@@8					; CBrush::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBrush@@8					; CBrush::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CBrush@@8				; CBrush::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_7CBrush@@6B@					; CBrush::`vftable'
PUBLIC	??_GCBrush@@UAEPAXI@Z				; CBrush::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CBrush@@UBEPAUCRuntimeClass@@XZ:NEAR ; CBrush::GetRuntimeClass
EXTRN	??_ECBrush@@UAEPAXI@Z:NEAR			; CBrush::`vector deleting destructor'
;	COMDAT ??_7CBrush@@6B@
CONST	SEGMENT
??_7CBrush@@6B@ DD FLAT:??_R4CBrush@@6B@		; CBrush::`vftable'
	DD	FLAT:?GetRuntimeClass@CBrush@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECBrush@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CBrush@@6B@
rdata$r	SEGMENT
??_R4CBrush@@6B@ DD 00H					; CBrush::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBrush@@@8
	DD	FLAT:??_R3CBrush@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBrush@@@8
_DATA	SEGMENT
??_R0?AVCBrush@@@8 DD FLAT:??_7type_info@@6B@		; CBrush `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBrush@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CBrush@@8
rdata$r	SEGMENT
??_R3CBrush@@8 DD 00H					; CBrush::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CBrush@@8
rdata$r	ENDS
;	COMDAT ??_R2CBrush@@8
rdata$r	SEGMENT
??_R2CBrush@@8 DD FLAT:??_R1A@?0A@A@CBrush@@8		; CBrush::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBrush@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CBrush@@8 DD FLAT:??_R0?AVCBrush@@@8	; CBrush::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CBrush@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CBrush@@QAE@XZ PROC NEAR				; CBrush::CBrush, COMDAT
; _this$ = ecx

; 128  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CGdiObject@@QAE@XZ	; CGdiObject::CGdiObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBrush@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CBrush@@QAE@XZ ENDP					; CBrush::CBrush
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCBrush@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCBrush@@UAEPAXI@Z PROC NEAR				; CBrush::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41589
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41589:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCBrush@@UAEPAXI@Z ENDP				; CBrush::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CBrush@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CBrush@@UAE@XZ PROC NEAR				; CBrush::~CBrush, COMDAT
; _this$ = ecx

; 130  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CBrush@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CBrush@@UAE@XZ ENDP					; CBrush::~CBrush
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?CreateSolidBrush@CBrush@@QAEHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_crColor$ = 8						; size = 4
?CreateSolidBrush@CBrush@@QAEHK@Z PROC NEAR		; CBrush::CreateSolidBrush, COMDAT
; _this$ = ecx

; 132  : 	{ return Attach(::CreateSolidBrush(crColor)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _crColor$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?CreateSolidBrush@CBrush@@QAEHK@Z ENDP			; CBrush::CreateSolidBrush
_TEXT	ENDS
PUBLIC	??_R4CFont@@6B@					; CFont::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCFont@@@8				; CFont `RTTI Type Descriptor'
PUBLIC	??_R3CFont@@8					; CFont::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CFont@@8					; CFont::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CFont@@8				; CFont::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_7CFont@@6B@					; CFont::`vftable'
PUBLIC	??_GCFont@@UAEPAXI@Z				; CFont::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CFont@@UBEPAUCRuntimeClass@@XZ:NEAR ; CFont::GetRuntimeClass
EXTRN	??_ECFont@@UAEPAXI@Z:NEAR			; CFont::`vector deleting destructor'
;	COMDAT ??_7CFont@@6B@
CONST	SEGMENT
??_7CFont@@6B@ DD FLAT:??_R4CFont@@6B@			; CFont::`vftable'
	DD	FLAT:?GetRuntimeClass@CFont@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECFont@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CFont@@6B@
rdata$r	SEGMENT
??_R4CFont@@6B@ DD 00H					; CFont::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCFont@@@8
	DD	FLAT:??_R3CFont@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFont@@@8
_DATA	SEGMENT
??_R0?AVCFont@@@8 DD FLAT:??_7type_info@@6B@		; CFont `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFont@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CFont@@8
rdata$r	SEGMENT
??_R3CFont@@8 DD 00H					; CFont::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CFont@@8
rdata$r	ENDS
;	COMDAT ??_R2CFont@@8
rdata$r	SEGMENT
??_R2CFont@@8 DD FLAT:??_R1A@?0A@A@CFont@@8		; CFont::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CFont@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CFont@@8 DD FLAT:??_R0?AVCFont@@@8		; CFont::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CFont@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CFont@@QAE@XZ PROC NEAR				; CFont::CFont, COMDAT
; _this$ = ecx

; 153  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CGdiObject@@QAE@XZ	; CGdiObject::CGdiObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CFont@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CFont@@QAE@XZ ENDP					; CFont::CFont
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCFont@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCFont@@UAEPAXI@Z PROC NEAR				; CFont::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CFont@@UAE@XZ	; CFont::~CFont
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L41640
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L41640:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCFont@@UAEPAXI@Z ENDP				; CFont::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CFont@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CFont@@UAE@XZ PROC NEAR				; CFont::~CFont, COMDAT
; _this$ = ecx

; 155  : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CFont@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CFont@@UAE@XZ ENDP					; CFont::~CFont
_TEXT	ENDS
EXTRN	__imp__CreateFontIndirectA@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpLogFont$ = 8						; size = 4
?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z PROC NEAR ; CFont::CreateFontIndirectA, COMDAT
; _this$ = ecx

; 157  : 	{ return Attach(::CreateFontIndirect(lpLogFont)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpLogFont$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFontIndirectA@4
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?CreateFontIndirectA@CFont@@QAEHPBUtagLOGFONTA@@@Z ENDP	; CFont::CreateFontIndirectA
_TEXT	ENDS
PUBLIC	?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ		; CDC::GetSafeHdc
EXTRN	?Attach@CDC@@QAEHPAUHDC__@@@Z:NEAR		; CDC::Attach
; Function compile flags: /Odt
;	COMDAT ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?CreateCompatibleDC@CDC@@QAEHPAV1@@Z PROC NEAR		; CDC::CreateCompatibleDC, COMDAT
; _this$ = ecx

; 330  : 	{ return Attach(::CreateCompatibleDC(pDC->GetSafeHdc())); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?Attach@CDC@@QAEHPAUHDC__@@@Z ; CDC::Attach
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?CreateCompatibleDC@CDC@@QAEHPAV1@@Z ENDP		; CDC::CreateCompatibleDC
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ PROC NEAR		; CDC::GetSafeHdc, COMDAT
; _this$ = ecx

; 316  : 	{ return this == NULL ? NULL : m_hDC; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  0000d	75 09		 jne	 SHORT $L199953
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00016	eb 09		 jmp	 SHORT $L199954
$L199953:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	89 4d f8	 mov	 DWORD PTR tv66[ebp], ecx
$L199954:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ENDP			; CDC::GetSafeHdc
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SelectObject@CDC@@QAEPAXPAX@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_hObject$ = 8						; size = 4
?SelectObject@CDC@@QAEPAXPAX@Z PROC NEAR		; CDC::SelectObject, COMDAT
; _this$ = ecx

; 365  : 	{ ASSERT(m_hDC == m_hAttribDC); // ASSERT a simple CDC object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 366  : 		return (hObject != NULL) ? ::SelectObject(m_hDC, hObject) : NULL; }

  00009	83 7d 08 00	 cmp	 DWORD PTR _hObject$[ebp], 0
  0000d	74 16		 je	 SHORT $L199957
  0000f	8b 45 08	 mov	 eax, DWORD PTR _hObject$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00019	52		 push	 edx
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  00020	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  00023	eb 07		 jmp	 SHORT $L199958
$L199957:
  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L199958:
  0002c	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?SelectObject@CDC@@QAEPAXPAX@Z ENDP			; CDC::SelectObject
_TEXT	ENDS
EXTRN	__imp__GetTextColor@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetTextColor@CDC@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTextColor@CDC@@QBEKXZ PROC NEAR			; CDC::GetTextColor, COMDAT
; _this$ = ecx

; 384  : 	{ ASSERT(m_hAttribDC != NULL); return ::GetTextColor(m_hAttribDC); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextColor@4
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetTextColor@CDC@@QBEKXZ ENDP				; CDC::GetTextColor
_TEXT	ENDS
EXTRN	__imp__Polygon@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?Polygon@CDC@@QAEHPAUtagPOINT@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpPoints$ = 8						; size = 4
_nCount$ = 12						; size = 4
?Polygon@CDC@@QAEHPAUtagPOINT@@H@Z PROC NEAR		; CDC::Polygon, COMDAT
; _this$ = ecx

; 531  : 	{ ASSERT(m_hDC != NULL); return ::Polygon(m_hDC, lpPoints, nCount); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _nCount$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _lpPoints$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Polygon@12
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?Polygon@CDC@@QAEHPAUtagPOINT@@H@Z ENDP			; CDC::Polygon
_TEXT	ENDS
EXTRN	__imp__GetPixel@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetPixel@CDC@@QBEKHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetPixel@CDC@@QBEKHH@Z PROC NEAR			; CDC::GetPixel, COMDAT
; _this$ = ecx

; 556  : 	{ ASSERT(m_hDC != NULL); return ::GetPixel(m_hDC, x, y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPixel@12
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?GetPixel@CDC@@QBEKHH@Z ENDP				; CDC::GetPixel
_TEXT	ENDS
EXTRN	_atexit:NEAR
CRT$XCU	SEGMENT
_$S7	DD	FLAT:_$E5
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\layoutmgr\changecolor\bitmapoperate.cpp
CRT$XCU	ENDS
;	COMDAT _$E5
text$yc	SEGMENT
_$E5	PROC NEAR					; COMDAT

; 1077 : CBitMapOperate gBitMapOperate;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?gBitMapOperate@@3VCBitMapOperate@@A
  00008	e8 00 00 00 00	 call	 ??0CBitMapOperate@@QAE@XZ ; CBitMapOperate::CBitMapOperate
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:_$E6
  00012	e8 00 00 00 00	 call	 _atexit
  00017	83 c4 04	 add	 esp, 4
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_$E5	ENDP
; Function compile flags: /Odt
text$yc	ENDS
;	COMDAT _$E6
text$yd	SEGMENT
_$E6	PROC NEAR					; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?gBitMapOperate@@3VCBitMapOperate@@A
  00008	e8 00 00 00 00	 call	 ??1CBitMapOperate@@UAE@XZ ; CBitMapOperate::~CBitMapOperate
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E6	ENDP
text$yd	ENDS
PUBLIC	?gBitMapOperate@@3VCBitMapOperate@@A		; gBitMapOperate
_BSS	SEGMENT
?gBitMapOperate@@3VCBitMapOperate@@A DB 04001cH DUP (?)	; gBitMapOperate
_BSS	ENDS
END
