; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\Gui\CommonControl\PictureEx.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ?Unlock@CSyncObject@@UAEHJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CCriticalSection@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCriticalSection@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCriticalSection@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CCriticalSection@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CCriticalSection@@UAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CCriticalSection@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDrawPointChanged@CPictureEx@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPictureEx@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CArray@VCRect@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$CArray@VCRect@@V1@@@QAEHVCRect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CArray@VCRect@@V1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CArray@VCRect@@V1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAtGrow@?$CArray@VCRect@@V1@@@QAEXHVCRect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CPictureEx@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CPictureEx@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSyncObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CPictureEx@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCSyncObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCCriticalSection@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$CArray@VCRect@@V1@@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCPictureEx@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CCriticalSection@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$CArray@VCRect@@V1@@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CPictureEx@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CArchive@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CArray@VCRect@@V1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PtInRect@CRect@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Offset@CPoint@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CenterPoint@CRect@@QBE?AVCPoint@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0PAVCFileException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??1AFX_EXCEPTION_LINK@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CObject@@SGPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CPictureEx@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?EqualRect@CRect@@QBEHPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CCriticalSection@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG198241 DB	'GIF', 00H
$SG198243 DB	'87a', 00H
$SG198244 DB	'89a', 00H
CONST	ENDS
PUBLIC	??0CPictureEx@@QAE@_N@Z				; CPictureEx::CPictureEx
PUBLIC	??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
PUBLIC	??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
PUBLIC	??2CObject@@SGPAXI@Z				; CObject::operator new
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
PUBLIC	??_7CPictureEx@@6B@				; CPictureEx::`vftable'
PUBLIC	??_GCPictureEx@@UAEPAXI@Z			; CPictureEx::`scalar deleting destructor'
PUBLIC	??0?$CArray@VCRect@@V1@@@QAE@XZ			; CArray<CRect,CRect>::CArray<CRect,CRect>
PUBLIC	??_R4CPictureEx@@6B@				; CPictureEx::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPictureEx@@@8				; CPictureEx `RTTI Type Descriptor'
PUBLIC	??_R3CPictureEx@@8				; CPictureEx::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPictureEx@@8				; CPictureEx::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CPictureEx@@8			; CPictureEx::`RTTI Base Class Descriptor at (0,-1,0,0)'
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp__CreateEventA@16:NEAR
EXTRN	??_ECPictureEx@@UAEPAXI@Z:NEAR			; CPictureEx::`vector deleting destructor'
EXTRN	__imp__SetRect@20:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
xdata$x	SEGMENT
$T199988 DD	0ffffffffH
	DD	FLAT:$L199979
	DD	00H
	DD	FLAT:$L199980
	DD	00H
	DD	FLAT:$L199981
$T199985 DD	019930520H
	DD	03H
	DD	FLAT:$T199988
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CPictureEx@@6B@
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\pictureex.cpp
CONST	SEGMENT
??_7CPictureEx@@6B@ DD FLAT:??_R4CPictureEx@@6B@	; CPictureEx::`vftable'
	DD	FLAT:??_ECPictureEx@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CPictureEx@@6B@
rdata$r	SEGMENT
??_R4CPictureEx@@6B@ DD 00H				; CPictureEx::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPictureEx@@@8
	DD	FLAT:??_R3CPictureEx@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPictureEx@@@8
_DATA	SEGMENT
??_R0?AVCPictureEx@@@8 DD FLAT:??_7type_info@@6B@	; CPictureEx `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPictureEx@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CPictureEx@@8
rdata$r	SEGMENT
??_R3CPictureEx@@8 DD 00H				; CPictureEx::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CPictureEx@@8
rdata$r	ENDS
;	COMDAT ??_R2CPictureEx@@8
rdata$r	SEGMENT
??_R2CPictureEx@@8 DD FLAT:??_R1A@?0A@A@CPictureEx@@8	; CPictureEx::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CPictureEx@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CPictureEx@@8 DD FLAT:??_R0?AVCPictureEx@@@8 ; CPictureEx::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
_TEXT	SEGMENT
tv151 = -40						; size = 4
tv143 = -36						; size = 4
_this$ = -32						; size = 4
$T199976 = -28						; size = 4
$T199975 = -24						; size = 4
$T199972 = -20						; size = 4
$T199971 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_bStretch$ = 8						; size = 1
??0CPictureEx@@QAE@_N@Z PROC NEAR			; CPictureEx::CPictureEx
; _this$ = ecx

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CPictureEx@@QAE@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0001b	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00021	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CPictureEx@@6B@
  00027	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8a 55 08	 mov	 dl, BYTE PTR _bStretch$[ebp]
  0002d	88 51 5c	 mov	 BYTE PTR [ecx+92], dl
  00030	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00039	e8 00 00 00 00	 call	 ??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 175  : 	// check structures size
; 176  : 	ASSERT(sizeof(TGIFImageDescriptor) == 10);
; 177  : 	ASSERT(sizeof(TGIFAppExtension)    == 14);
; 178  : 	ASSERT(sizeof(TGIFPlainTextExt)    == 15);
; 179  : 	ASSERT(sizeof(TGIFLSDescriptor)    ==  7);
; 180  : 	ASSERT(sizeof(TGIFControlExt)	   ==  8);
; 181  : 	ASSERT(sizeof(TGIFCommentExt)	   ==  2);
; 182  : 	ASSERT(sizeof(TGIFHeader)		   ==  6);
; 183  : 
; 184  : 	m_pGIFLSDescriptor = NULL;

  00045	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00048	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], 0

; 185  : 	m_pGIFHeader	   = NULL;

  0004f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	c7 41 74 00 00
	00 00		 mov	 DWORD PTR [ecx+116], 0

; 186  : 	m_pPicture		   = NULL;

  00059	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	c7 42 70 00 00
	00 00		 mov	 DWORD PTR [edx+112], 0

; 187  : 	m_pRawData		   = NULL;

  00063	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00066	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [eax+120], 0

; 188  : 	m_hThread		   = NULL;

  0006d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 189  : 	m_hBitmap          = NULL;

  00077	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0

; 190  : 	m_hMemDC		   = NULL;

  00081	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00084	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0

; 191  : 
; 192  : 	m_hDispMemDC       = NULL;

  0008b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0

; 193  : 	m_hDispMemBM       = NULL;

  00095	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00098	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], 0

; 194  : 	m_hDispOldBM       = NULL;

  0009f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 195  : 
; 196  : 	m_bHasMask         = FALSE;

  000a9	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 197  : 	m_bIsInitialized   = FALSE;

  000b3	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000b6	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 198  : 	m_bExitThread	   = FALSE;

  000bd	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 199  : 	m_bIsPlaying       = FALSE;

  000c7	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 200  : 	m_bIsGIF		   = FALSE;

  000d1	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 201  : 	m_clrBackground    = RGB(255,255,255); // white by default

  000db	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000de	c7 40 28 ff ff
	ff 00		 mov	 DWORD PTR [eax+40], 16777215 ; 00ffffffH

; 202  : 	m_nGlobalCTSize    = 0;

  000e5	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 203  : 	m_nCurrOffset	   = 0;

  000ef	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000f2	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 204  : 	m_nCurrFrame	   = 0;

  000f9	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 205  : 	m_nDataSize		   = 0;

  00103	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 206  : 	m_PictureSize.cx = m_PictureSize.cy = 0;

  0010d	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00110	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0
  00117	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 207  : 	SetRect(&m_PaintRect,0,0,0,0);

  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	6a 00		 push	 0
  00127	6a 00		 push	 0
  00129	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	83 c1 10	 add	 ecx, 16			; 00000010H
  0012f	51		 push	 ecx
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 208  : 
; 209  : 	m_bPause		= false;

  00136	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00139	c6 42 04 00	 mov	 BYTE PTR [edx+4], 0

; 210  : 
; 211  : 	m_aryPoint = new CArray<CRect, CRect>;

  0013d	6a 14		 push	 20			; 00000014H
  0013f	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  00144	89 45 ec	 mov	 DWORD PTR $T199972[ebp], eax
  00147	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0014b	83 7d ec 00	 cmp	 DWORD PTR $T199972[ebp], 0
  0014f	74 0d		 je	 SHORT $L199973
  00151	8b 4d ec	 mov	 ecx, DWORD PTR $T199972[ebp]
  00154	e8 00 00 00 00	 call	 ??0?$CArray@VCRect@@V1@@@QAE@XZ ; CArray<CRect,CRect>::CArray<CRect,CRect>
  00159	89 45 dc	 mov	 DWORD PTR tv143[ebp], eax
  0015c	eb 07		 jmp	 SHORT $L199974
$L199973:
  0015e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv143[ebp], 0
$L199974:
  00165	8b 45 dc	 mov	 eax, DWORD PTR tv143[ebp]
  00168	89 45 f0	 mov	 DWORD PTR $T199971[ebp], eax
  0016b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0016f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00172	8b 55 f0	 mov	 edx, DWORD PTR $T199971[ebp]
  00175	89 91 90 00 00
	00		 mov	 DWORD PTR [ecx+144], edx

; 212  : 	m_aryPrepPoint = new CArray<CRect , CRect>;

  0017b	6a 14		 push	 20			; 00000014H
  0017d	e8 00 00 00 00	 call	 ??2CObject@@SGPAXI@Z	; CObject::operator new
  00182	89 45 e4	 mov	 DWORD PTR $T199976[ebp], eax
  00185	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00189	83 7d e4 00	 cmp	 DWORD PTR $T199976[ebp], 0
  0018d	74 0d		 je	 SHORT $L199977
  0018f	8b 4d e4	 mov	 ecx, DWORD PTR $T199976[ebp]
  00192	e8 00 00 00 00	 call	 ??0?$CArray@VCRect@@V1@@@QAE@XZ ; CArray<CRect,CRect>::CArray<CRect,CRect>
  00197	89 45 d8	 mov	 DWORD PTR tv151[ebp], eax
  0019a	eb 07		 jmp	 SHORT $L199978
$L199977:
  0019c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv151[ebp], 0
$L199978:
  001a3	8b 45 d8	 mov	 eax, DWORD PTR tv151[ebp]
  001a6	89 45 e8	 mov	 DWORD PTR $T199975[ebp], eax
  001a9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001ad	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001b0	8b 55 e8	 mov	 edx, DWORD PTR $T199975[ebp]
  001b3	89 91 94 00 00
	00		 mov	 DWORD PTR [ecx+148], edx

; 213  : 	m_hExitEvent = CreateEvent(NULL,TRUE,FALSE,NULL);

  001b9	6a 00		 push	 0
  001bb	6a 00		 push	 0
  001bd	6a 01		 push	 1
  001bf	6a 00		 push	 0
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventA@16
  001c7	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ca	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 214  : }

  001cd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001d4	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  001d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001e1	8b e5		 mov	 esp, ebp
  001e3	5d		 pop	 ebp
  001e4	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L199979:
  00000	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
$L199980:
  0000e	8b 45 ec	 mov	 eax, DWORD PTR $T199972[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00017	c3		 ret	 0
$L199981:
  00018	8b 45 e4	 mov	 eax, DWORD PTR $T199976[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00021	c3		 ret	 0
__ehhandler$??0CPictureEx@@QAE@_N@Z:
  00022	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T199985
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CPictureEx@@QAE@_N@Z ENDP				; CPictureEx::CPictureEx
PUBLIC	??1CPictureEx@@UAE@XZ				; CPictureEx::~CPictureEx
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt
;	COMDAT ??_GCPictureEx@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCPictureEx@@UAEPAXI@Z PROC NEAR			; CPictureEx::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CPictureEx@@UAE@XZ	; CPictureEx::~CPictureEx
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L198223
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L198223:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCPictureEx@@UAEPAXI@Z ENDP				; CPictureEx::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Stop@CPictureEx@@QAEXXZ			; CPictureEx::Stop
PUBLIC	?UnLoad@CPictureEx@@QAEXXZ			; CPictureEx::UnLoad
EXTRN	__imp__CloseHandle@4:NEAR
xdata$x	SEGMENT
$T200005 DD	0ffffffffH
	DD	FLAT:$L200001
$T200003 DD	019930520H
	DD	01H
	DD	FLAT:$T200005
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv87 = -40						; size = 4
tv79 = -36						; size = 4
_this$ = -32						; size = 4
$T199998 = -28						; size = 4
$T199997 = -24						; size = 4
$T199994 = -20						; size = 4
$T199993 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CPictureEx@@UAE@XZ PROC NEAR				; CPictureEx::~CPictureEx
; _this$ = ecx

; 217  : {

  001f0	55		 push	 ebp
  001f1	8b ec		 mov	 ebp, esp
  001f3	6a ff		 push	 -1
  001f5	68 00 00 00 00	 push	 __ehhandler$??1CPictureEx@@UAE@XZ
  001fa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00200	50		 push	 eax
  00201	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00208	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0020b	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  0020e	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00211	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CPictureEx@@6B@
  00217	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 218  : 
; 219  : 	Stop();	

  0021e	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00221	e8 00 00 00 00	 call	 ?Stop@CPictureEx@@QAEXXZ ; CPictureEx::Stop

; 220  : 	UnLoad();

  00226	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00229	e8 00 00 00 00	 call	 ?UnLoad@CPictureEx@@QAEXXZ ; CPictureEx::UnLoad

; 221  : 	CloseHandle(m_hExitEvent);

  0022e	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00231	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00234	52		 push	 edx
  00235	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 222  : 	delete m_aryPrepPoint;

  0023b	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0023e	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  00244	89 4d ec	 mov	 DWORD PTR $T199994[ebp], ecx
  00247	8b 55 ec	 mov	 edx, DWORD PTR $T199994[ebp]
  0024a	89 55 f0	 mov	 DWORD PTR $T199993[ebp], edx
  0024d	83 7d f0 00	 cmp	 DWORD PTR $T199993[ebp], 0
  00251	74 12		 je	 SHORT $L199995
  00253	6a 01		 push	 1
  00255	8b 45 f0	 mov	 eax, DWORD PTR $T199993[ebp]
  00258	8b 10		 mov	 edx, DWORD PTR [eax]
  0025a	8b 4d f0	 mov	 ecx, DWORD PTR $T199993[ebp]
  0025d	ff 52 04	 call	 DWORD PTR [edx+4]
  00260	89 45 dc	 mov	 DWORD PTR tv79[ebp], eax
  00263	eb 07		 jmp	 SHORT $L199996
$L199995:
  00265	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$L199996:

; 223  : 	delete m_aryPoint;

  0026c	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0026f	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00275	89 4d e4	 mov	 DWORD PTR $T199998[ebp], ecx
  00278	8b 55 e4	 mov	 edx, DWORD PTR $T199998[ebp]
  0027b	89 55 e8	 mov	 DWORD PTR $T199997[ebp], edx
  0027e	83 7d e8 00	 cmp	 DWORD PTR $T199997[ebp], 0
  00282	74 12		 je	 SHORT $L199999
  00284	6a 01		 push	 1
  00286	8b 45 e8	 mov	 eax, DWORD PTR $T199997[ebp]
  00289	8b 10		 mov	 edx, DWORD PTR [eax]
  0028b	8b 4d e8	 mov	 ecx, DWORD PTR $T199997[ebp]
  0028e	ff 52 04	 call	 DWORD PTR [edx+4]
  00291	89 45 d8	 mov	 DWORD PTR tv87[ebp], eax
  00294	eb 07		 jmp	 SHORT $L198226
$L199999:
  00296	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
$L198226:

; 224  : 
; 225  : }

  0029d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002a4	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  002a7	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  002ad	e8 00 00 00 00	 call	 ??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  002b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002bc	8b e5		 mov	 esp, ebp
  002be	5d		 pop	 ebp
  002bf	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200001:
  0002c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00035	e9 00 00 00 00	 jmp	 ??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
__ehhandler$??1CPictureEx@@UAE@XZ:
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200003
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CPictureEx@@UAE@XZ ENDP				; CPictureEx::~CPictureEx
PUBLIC	?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z ; CPictureEx::TGIFLSDescriptor::GetPackedValue
PUBLIC	?Load@CPictureEx@@QAEHPAXK@Z			; CPictureEx::Load
PUBLIC	?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::empty
PUBLIC	?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::push_back
PUBLIC	?SkipNextGraphicBlock@CPictureEx@@IAEHXZ	; CPictureEx::SkipNextGraphicBlock
PUBLIC	?PrepareDC@CPictureEx@@IAEHHH@Z			; CPictureEx::PrepareDC
PUBLIC	?ResetDataPointer@CPictureEx@@IAEXXZ		; CPictureEx::ResetDataPointer
PUBLIC	?GetNextGraphicBlock@CPictureEx@@IAEPAXPAI0PAUtagSIZE@@10@Z ; CPictureEx::GetNextGraphicBlock
EXTRN	_IID_IPicture:BYTE
EXTRN	__imp__GlobalLock@4:NEAR
EXTRN	__imp__GlobalUnlock@4:NEAR
EXTRN	__imp__GlobalFree@4:NEAR
EXTRN	__imp__GetDC@4:NEAR
EXTRN	__imp__ReleaseDC@8:NEAR
EXTRN	__imp__GetDeviceCaps@8:NEAR
EXTRN	_memcmp:NEAR
EXTRN	__imp__CreateStreamOnHGlobal@12:NEAR
EXTRN	__imp__OleLoadPicture@20:NEAR
EXTRN	__imp__MulDiv@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -72						; size = 4
_pStream$198286 = -68					; size = 4
_frame$198279 = -64					; size = 28
_hFrameData$198281 = -36				; size = 4
_nCurFrame$198282 = -32					; size = 4
_nBlockLen$198280 = -28					; size = 4
_pBkClr$198258 = -24					; size = 4
_nFrameCount$198267 = -20				; size = 4
_hmHeight$198251 = -16					; size = 4
_hmWidth$198250 = -12					; size = 4
_hDC$198252 = -8					; size = 4
_pStream$ = -4						; size = 4
_hGlobal$ = 8						; size = 4
_dwSize$ = 12						; size = 4
?Load@CPictureEx@@QAEHPAXK@Z PROC NEAR			; CPictureEx::Load
; _this$ = ecx

; 235  : {

  002c0	55		 push	 ebp
  002c1	8b ec		 mov	 ebp, esp
  002c3	83 ec 48	 sub	 esp, 72			; 00000048H
  002c6	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 236  : 	IStream *pStream = NULL;

  002c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pStream$[ebp], 0

; 237  : 	UnLoad();

  002d0	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d3	e8 00 00 00 00	 call	 ?UnLoad@CPictureEx@@QAEXXZ ; CPictureEx::UnLoad

; 238  : 
; 239  : 	if (!(m_pRawData = reinterpret_cast<unsigned char*> (GlobalLock(hGlobal))) )

  002d8	8b 45 08	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  002db	50		 push	 eax
  002dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  002e2	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e5	89 41 78	 mov	 DWORD PTR [ecx+120], eax
  002e8	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  002eb	83 7a 78 00	 cmp	 DWORD PTR [edx+120], 0
  002ef	75 07		 jne	 SHORT $L198238

; 240  : 	{
; 241  : 		TRACE(_T("Load: Error locking memory\n"));
; 242  : 		return FALSE;

  002f1	33 c0		 xor	 eax, eax
  002f3	e9 cb 03 00 00	 jmp	 $L198235
$L198238:

; 243  : 	};
; 244  : 
; 245  : 	m_nDataSize = dwSize;

  002f8	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  002fb	8b 4d 0c	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  002fe	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 246  : 	m_pGIFHeader = reinterpret_cast<TGIFHeader *> (m_pRawData);

  00301	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00304	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00307	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0030a	89 4a 74	 mov	 DWORD PTR [edx+116], ecx

; 247  : 
; 248  : 	if ((memcmp(&m_pGIFHeader->m_cSignature,"GIF",3) != 0) &&
; 249  : 		((memcmp(&m_pGIFHeader->m_cVersion,"87a",3) != 0) ||
; 250  : 		 (memcmp(&m_pGIFHeader->m_cVersion,"89a",3) != 0)) )

  0030d	6a 03		 push	 3
  0030f	68 00 00 00 00	 push	 OFFSET FLAT:$SG198241
  00314	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00317	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  0031a	50		 push	 eax
  0031b	e8 00 00 00 00	 call	 _memcmp
  00320	83 c4 0c	 add	 esp, 12			; 0000000cH
  00323	85 c0		 test	 eax, eax
  00325	0f 84 42 01 00
	00		 je	 $L198240
  0032b	6a 03		 push	 3
  0032d	68 00 00 00 00	 push	 OFFSET FLAT:$SG198243
  00332	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00335	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00338	83 c2 03	 add	 edx, 3
  0033b	52		 push	 edx
  0033c	e8 00 00 00 00	 call	 _memcmp
  00341	83 c4 0c	 add	 esp, 12			; 0000000cH
  00344	85 c0		 test	 eax, eax
  00346	75 21		 jne	 SHORT $L198242
  00348	6a 03		 push	 3
  0034a	68 00 00 00 00	 push	 OFFSET FLAT:$SG198244
  0034f	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00352	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00355	83 c1 03	 add	 ecx, 3
  00358	51		 push	 ecx
  00359	e8 00 00 00 00	 call	 _memcmp
  0035e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00361	85 c0		 test	 eax, eax
  00363	0f 84 04 01 00
	00		 je	 $L198240
$L198242:

; 251  : 	{
; 252  : 	// it's neither GIF87a nor GIF89a
; 253  : 	// do the default processing
; 254  : 
; 255  : 		// clear GIF variables
; 256  : 		m_pRawData = NULL;

  00369	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  0036c	c7 42 78 00 00
	00 00		 mov	 DWORD PTR [edx+120], 0

; 257  : 		GlobalUnlock(hGlobal);

  00373	8b 45 08	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  00376	50		 push	 eax
  00377	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 258  : 
; 259  : 		// don't delete memory on object's release
; 260  : 		if (CreateStreamOnHGlobal(hGlobal,FALSE,&pStream) != S_OK)

  0037d	8d 4d fc	 lea	 ecx, DWORD PTR _pStream$[ebp]
  00380	51		 push	 ecx
  00381	6a 00		 push	 0
  00383	8b 55 08	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00386	52		 push	 edx
  00387	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateStreamOnHGlobal@12
  0038d	85 c0		 test	 eax, eax
  0038f	74 07		 je	 SHORT $L198246

; 261  : 			return FALSE;

  00391	33 c0		 xor	 eax, eax
  00393	e9 2b 03 00 00	 jmp	 $L198235
$L198246:

; 262  : 
; 263  : 		if (OleLoadPicture(pStream,dwSize,FALSE,IID_IPicture,
; 264  : 			reinterpret_cast<LPVOID *>(&m_pPicture)) != S_OK)

  00398	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0039b	83 c0 70	 add	 eax, 112		; 00000070H
  0039e	50		 push	 eax
  0039f	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPicture
  003a4	6a 00		 push	 0
  003a6	8b 4d 0c	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  003a9	51		 push	 ecx
  003aa	8b 55 fc	 mov	 edx, DWORD PTR _pStream$[ebp]
  003ad	52		 push	 edx
  003ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleLoadPicture@20
  003b4	85 c0		 test	 eax, eax
  003b6	74 13		 je	 SHORT $L198249

; 265  : 		{
; 266  : 			pStream->Release();

  003b8	8b 45 fc	 mov	 eax, DWORD PTR _pStream$[ebp]
  003bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  003bd	8b 55 fc	 mov	 edx, DWORD PTR _pStream$[ebp]
  003c0	52		 push	 edx
  003c1	ff 51 08	 call	 DWORD PTR [ecx+8]

; 267  : 			return FALSE;

  003c4	33 c0		 xor	 eax, eax
  003c6	e9 f8 02 00 00	 jmp	 $L198235
$L198249:

; 268  : 		};
; 269  : 		pStream->Release();

  003cb	8b 45 fc	 mov	 eax, DWORD PTR _pStream$[ebp]
  003ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  003d0	8b 55 fc	 mov	 edx, DWORD PTR _pStream$[ebp]
  003d3	52		 push	 edx
  003d4	ff 51 08	 call	 DWORD PTR [ecx+8]

; 270  : 
; 271  : 		// store picture's size
; 272  : 
; 273  : 		long hmWidth;
; 274  : 		long hmHeight;
; 275  : 		m_pPicture->get_Width(&hmWidth);

  003d7	8d 45 f4	 lea	 eax, DWORD PTR _hmWidth$198250[ebp]
  003da	50		 push	 eax
  003db	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  003de	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  003e1	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  003e4	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  003e7	8b 12		 mov	 edx, DWORD PTR [edx]
  003e9	51		 push	 ecx
  003ea	ff 52 18	 call	 DWORD PTR [edx+24]

; 276  : 		m_pPicture->get_Height(&hmHeight);

  003ed	8d 45 f0	 lea	 eax, DWORD PTR _hmHeight$198251[ebp]
  003f0	50		 push	 eax
  003f1	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  003f4	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  003f7	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  003fa	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  003fd	8b 12		 mov	 edx, DWORD PTR [edx]
  003ff	51		 push	 ecx
  00400	ff 52 1c	 call	 DWORD PTR [edx+28]

; 277  : 
; 278  : 		HDC hDC = ::GetDC(m_hWnd);

  00403	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00406	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00409	51		 push	 ecx
  0040a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  00410	89 45 f8	 mov	 DWORD PTR _hDC$198252[ebp], eax

; 279  : 		m_PictureSize.cx = MulDiv(hmWidth, GetDeviceCaps(hDC,LOGPIXELSX), 2540);

  00413	68 ec 09 00 00	 push	 2540			; 000009ecH
  00418	6a 58		 push	 88			; 00000058H
  0041a	8b 55 f8	 mov	 edx, DWORD PTR _hDC$198252[ebp]
  0041d	52		 push	 edx
  0041e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8
  00424	50		 push	 eax
  00425	8b 45 f4	 mov	 eax, DWORD PTR _hmWidth$198250[ebp]
  00428	50		 push	 eax
  00429	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  0042f	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00432	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 280  : 		m_PictureSize.cy = MulDiv(hmHeight, GetDeviceCaps(hDC,LOGPIXELSY), 2540);

  00435	68 ec 09 00 00	 push	 2540			; 000009ecH
  0043a	6a 5a		 push	 90			; 0000005aH
  0043c	8b 55 f8	 mov	 edx, DWORD PTR _hDC$198252[ebp]
  0043f	52		 push	 edx
  00440	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8
  00446	50		 push	 eax
  00447	8b 45 f0	 mov	 eax, DWORD PTR _hmHeight$198251[ebp]
  0044a	50		 push	 eax
  0044b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  00451	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00454	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 281  : 		::ReleaseDC(m_hWnd,hDC);

  00457	8b 55 f8	 mov	 edx, DWORD PTR _hDC$198252[ebp]
  0045a	52		 push	 edx
  0045b	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0045e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00461	51		 push	 ecx
  00462	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 282  : 	}
; 283  : 	else

  00468	e9 40 02 00 00	 jmp	 $L198253
$L198240:

; 284  : 	{
; 285  : 		// it's a GIF
; 286  : 		m_bIsGIF = TRUE;

  0046d	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00470	c7 42 3c 01 00
	00 00		 mov	 DWORD PTR [edx+60], 1

; 287  : 		m_pGIFLSDescriptor = reinterpret_cast<TGIFLSDescriptor *>
; 288  : 			(m_pRawData + sizeof(TGIFHeader));

  00477	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0047a	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0047d	83 c1 06	 add	 ecx, 6
  00480	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00483	89 4a 7c	 mov	 DWORD PTR [edx+124], ecx

; 289  : 		if (m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCT) == 1)

  00486	6a 00		 push	 0
  00488	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0048b	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  0048e	e8 00 00 00 00	 call	 ?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z ; CPictureEx::TGIFLSDescriptor::GetPackedValue
  00493	83 f8 01	 cmp	 eax, 1
  00496	75 60		 jne	 SHORT $L198256

; 290  : 		{
; 291  : 			// calculate the globat color table size
; 292  : 			m_nGlobalCTSize = static_cast<int>
; 293  : 				(3* (1 << (m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCTSIZE)+1)));

  00498	6a 03		 push	 3
  0049a	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0049d	8b 49 7c	 mov	 ecx, DWORD PTR [ecx+124]
  004a0	e8 00 00 00 00	 call	 ?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z ; CPictureEx::TGIFLSDescriptor::GetPackedValue
  004a5	83 c0 01	 add	 eax, 1
  004a8	ba 01 00 00 00	 mov	 edx, 1
  004ad	8b c8		 mov	 ecx, eax
  004af	d3 e2		 shl	 edx, cl
  004b1	6b d2 03	 imul	 edx, 3
  004b4	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  004b7	89 50 38	 mov	 DWORD PTR [eax+56], edx

; 294  : 			// get the background color if GCT is present
; 295  : 			unsigned char *pBkClr = m_pRawData + sizeof(TGIFHeader) + 
; 296  : 				sizeof(TGIFLSDescriptor) + 3*m_pGIFLSDescriptor->m_cBkIndex;

  004ba	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  004bd	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  004c0	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  004c3	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  004c6	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  004ca	6b c0 03	 imul	 eax, 3
  004cd	8d 4c 02 0d	 lea	 ecx, DWORD PTR [edx+eax+13]
  004d1	89 4d e8	 mov	 DWORD PTR _pBkClr$198258[ebp], ecx

; 297  : 			m_clrBackground = RGB(pBkClr[0],pBkClr[1],pBkClr[2]);

  004d4	8b 55 e8	 mov	 edx, DWORD PTR _pBkClr$198258[ebp]
  004d7	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  004da	8b 4d e8	 mov	 ecx, DWORD PTR _pBkClr$198258[ebp]
  004dd	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  004e1	c1 e2 08	 shl	 edx, 8
  004e4	0b c2		 or	 eax, edx
  004e6	8b 4d e8	 mov	 ecx, DWORD PTR _pBkClr$198258[ebp]
  004e9	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  004ed	c1 e2 10	 shl	 edx, 16			; 00000010H
  004f0	0b c2		 or	 eax, edx
  004f2	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  004f5	89 41 28	 mov	 DWORD PTR [ecx+40], eax
$L198256:

; 298  : 		};
; 299  : 
; 300  : 		// store the picture's size
; 301  : 		m_PictureSize.cx = m_pGIFLSDescriptor->m_wWidth;

  004f8	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  004fb	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  004fe	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00501	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00504	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 302  : 		m_PictureSize.cy = m_pGIFLSDescriptor->m_wHeight;

  00507	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0050a	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  0050d	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00511	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00514	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 303  : 
; 304  : 		// determine frame count for this picture
; 305  : 		UINT nFrameCount=0;

  00517	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nFrameCount$198267[ebp], 0

; 306  : 		ResetDataPointer();

  0051e	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00521	e8 00 00 00 00	 call	 ?ResetDataPointer@CPictureEx@@IAEXXZ ; CPictureEx::ResetDataPointer
$L198269:

; 307  : 		while (SkipNextGraphicBlock())

  00526	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00529	e8 00 00 00 00	 call	 ?SkipNextGraphicBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextGraphicBlock
  0052e	85 c0		 test	 eax, eax
  00530	74 0b		 je	 SHORT $L198270

; 308  : 			nFrameCount++;

  00532	8b 4d ec	 mov	 ecx, DWORD PTR _nFrameCount$198267[ebp]
  00535	83 c1 01	 add	 ecx, 1
  00538	89 4d ec	 mov	 DWORD PTR _nFrameCount$198267[ebp], ecx
  0053b	eb e9		 jmp	 SHORT $L198269
$L198270:

; 309  : 
; 310  : #ifdef GIF_TRACING
; 311  : 		TRACE(
; 312  : 			_T(" -= GIF encountered\n"
; 313  : 			   "Logical Screen dimensions = %dx%d\n"
; 314  : 			   "Global color table = %d\n"
; 315  : 			   "Color depth = %d\n"
; 316  : 			   "Sort flag = %d\n"
; 317  : 			   "Size of Global Color Table = %d\n"
; 318  : 			   "Background color index = %d\n"
; 319  : 			   "Pixel aspect ratio = %d\n"
; 320  : 			   "Frame count = %d\n"
; 321  : 			   "Background color = %06Xh\n\n"
; 322  : 			  ),
; 323  : 			m_pGIFLSDescriptor->m_wWidth,
; 324  : 			m_pGIFLSDescriptor->m_wHeight,
; 325  : 			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCT),
; 326  : 			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_CRESOLUTION),
; 327  : 			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_SORT),
; 328  : 			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCTSIZE),
; 329  : 			m_pGIFLSDescriptor->m_cBkIndex,
; 330  : 			m_pGIFLSDescriptor->m_cPixelAspect,
; 331  : 			nFrameCount,
; 332  : 			m_clrBackground
; 333  : 			);
; 334  : 		EnumGIFBlocks();
; 335  : #endif
; 336  : 
; 337  : 		if (nFrameCount == 0) // it's an empty GIF!

  0053d	83 7d ec 00	 cmp	 DWORD PTR _nFrameCount$198267[ebp], 0
  00541	75 1b		 jne	 SHORT $L198271

; 338  : 		{
; 339  : 			m_pRawData = NULL;

  00543	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00546	c7 42 78 00 00
	00 00		 mov	 DWORD PTR [edx+120], 0

; 340  : 			GlobalUnlock(hGlobal);

  0054d	8b 45 08	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  00550	50		 push	 eax
  00551	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 341  : 			return FALSE;

  00557	33 c0		 xor	 eax, eax
  00559	e9 65 01 00 00	 jmp	 $L198235
$L198271:

; 342  : 		};
; 343  : 
; 344  : 		// now check the frame count
; 345  : 		// if there's only one frame, no need to animate this GIF
; 346  : 		// therefore, treat it like any other pic
; 347  : 
; 348  : 		if (nFrameCount == 1)

  0055e	83 7d ec 01	 cmp	 DWORD PTR _nFrameCount$198267[ebp], 1
  00562	75 73		 jne	 SHORT $L198272

; 349  : 		{
; 350  : 			// clear GIF variables
; 351  : 			m_pRawData = NULL;

  00564	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00567	c7 41 78 00 00
	00 00		 mov	 DWORD PTR [ecx+120], 0

; 352  : 			GlobalUnlock(hGlobal);

  0056e	8b 55 08	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00571	52		 push	 edx
  00572	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 353  : 
; 354  : 			// don't delete memory on object's release
; 355  : 			if (CreateStreamOnHGlobal(hGlobal,FALSE,&pStream) != S_OK)

  00578	8d 45 fc	 lea	 eax, DWORD PTR _pStream$[ebp]
  0057b	50		 push	 eax
  0057c	6a 00		 push	 0
  0057e	8b 4d 08	 mov	 ecx, DWORD PTR _hGlobal$[ebp]
  00581	51		 push	 ecx
  00582	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateStreamOnHGlobal@12
  00588	85 c0		 test	 eax, eax
  0058a	74 07		 je	 SHORT $L198274

; 356  : 				return FALSE;

  0058c	33 c0		 xor	 eax, eax
  0058e	e9 30 01 00 00	 jmp	 $L198235
$L198274:

; 357  : 
; 358  : 			if (OleLoadPicture(pStream,dwSize,FALSE,IID_IPicture,
; 359  : 				(LPVOID *)&m_pPicture) != S_OK)

  00593	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00596	83 c2 70	 add	 edx, 112		; 00000070H
  00599	52		 push	 edx
  0059a	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPicture
  0059f	6a 00		 push	 0
  005a1	8b 45 0c	 mov	 eax, DWORD PTR _dwSize$[ebp]
  005a4	50		 push	 eax
  005a5	8b 4d fc	 mov	 ecx, DWORD PTR _pStream$[ebp]
  005a8	51		 push	 ecx
  005a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleLoadPicture@20
  005af	85 c0		 test	 eax, eax
  005b1	74 13		 je	 SHORT $L198277

; 360  : 			{
; 361  : 				pStream->Release();

  005b3	8b 55 fc	 mov	 edx, DWORD PTR _pStream$[ebp]
  005b6	8b 02		 mov	 eax, DWORD PTR [edx]
  005b8	8b 4d fc	 mov	 ecx, DWORD PTR _pStream$[ebp]
  005bb	51		 push	 ecx
  005bc	ff 50 08	 call	 DWORD PTR [eax+8]

; 362  : 				return FALSE;

  005bf	33 c0		 xor	 eax, eax
  005c1	e9 fd 00 00 00	 jmp	 $L198235
$L198277:

; 363  : 			};
; 364  : 
; 365  : 			pStream->Release();

  005c6	8b 55 fc	 mov	 edx, DWORD PTR _pStream$[ebp]
  005c9	8b 02		 mov	 eax, DWORD PTR [edx]
  005cb	8b 4d fc	 mov	 ecx, DWORD PTR _pStream$[ebp]
  005ce	51		 push	 ecx
  005cf	ff 50 08	 call	 DWORD PTR [eax+8]

; 366  : 		}
; 367  : 		else

  005d2	e9 d6 00 00 00	 jmp	 $L198253
$L198272:

; 368  : 		{
; 369  : 		// if, on the contrary, there are several frames
; 370  : 		// then store separate frames in an array
; 371  : 
; 372  : 			TFrame frame;
; 373  : 			UINT nBlockLen;
; 374  : 			HGLOBAL hFrameData;
; 375  : 			UINT nCurFrame = 0;

  005d7	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _nCurFrame$198282[ebp], 0

; 376  : 
; 377  : 			ResetDataPointer();

  005de	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  005e1	e8 00 00 00 00	 call	 ?ResetDataPointer@CPictureEx@@IAEXXZ ; CPictureEx::ResetDataPointer
$L198284:

; 378  : 			while (hFrameData = GetNextGraphicBlock(&nBlockLen,
; 379  : 				&frame.m_nDelay, &frame.m_frameSize,
; 380  : 				&frame.m_frameOffset, &frame.m_nDisposal) )

  005e6	8d 55 d8	 lea	 edx, DWORD PTR _frame$198279[ebp+24]
  005e9	52		 push	 edx
  005ea	8d 45 cc	 lea	 eax, DWORD PTR _frame$198279[ebp+12]
  005ed	50		 push	 eax
  005ee	8d 4d c4	 lea	 ecx, DWORD PTR _frame$198279[ebp+4]
  005f1	51		 push	 ecx
  005f2	8d 55 d4	 lea	 edx, DWORD PTR _frame$198279[ebp+20]
  005f5	52		 push	 edx
  005f6	8d 45 e4	 lea	 eax, DWORD PTR _nBlockLen$198280[ebp]
  005f9	50		 push	 eax
  005fa	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  005fd	e8 00 00 00 00	 call	 ?GetNextGraphicBlock@CPictureEx@@IAEPAXPAI0PAUtagSIZE@@10@Z ; CPictureEx::GetNextGraphicBlock
  00602	89 45 dc	 mov	 DWORD PTR _hFrameData$198281[ebp], eax
  00605	83 7d dc 00	 cmp	 DWORD PTR _hFrameData$198281[ebp], 0
  00609	74 75		 je	 SHORT $L198285

; 381  : 			{
; 382  : 				#ifdef GIF_TRACING
; 383  : 				//////////////////////////////////////////////
; 384  : 				// uncomment the following strings if you want 
; 385  : 				// to write separate frames on disk
; 386  : 				//
; 387  : 				//	CString szName;
; 388  : 				//	szName.Format(_T("%.4d.gif"),nCurFrame);
; 389  : 				//	WriteDataOnDisk(szName,hFrameData,nBlockLen);
; 390  : 				//	nCurFrame++;
; 391  : 				#endif // GIF_TRACING
; 392  : 
; 393  : 				IStream *pStream = NULL;

  0060b	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _pStream$198286[ebp], 0

; 394  : 
; 395  : 				// delete memory on object's release
; 396  : 				if (CreateStreamOnHGlobal(hFrameData,TRUE,&pStream) != S_OK)

  00612	8d 4d bc	 lea	 ecx, DWORD PTR _pStream$198286[ebp]
  00615	51		 push	 ecx
  00616	6a 01		 push	 1
  00618	8b 55 dc	 mov	 edx, DWORD PTR _hFrameData$198281[ebp]
  0061b	52		 push	 edx
  0061c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateStreamOnHGlobal@12
  00622	85 c0		 test	 eax, eax
  00624	74 0c		 je	 SHORT $L198288

; 397  : 				{
; 398  : 					GlobalFree(hFrameData);

  00626	8b 45 dc	 mov	 eax, DWORD PTR _hFrameData$198281[ebp]
  00629	50		 push	 eax
  0062a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 399  : 					continue;

  00630	eb b4		 jmp	 SHORT $L198284
$L198288:

; 400  : 				};
; 401  : 
; 402  : 				if (OleLoadPicture(pStream,nBlockLen,FALSE,
; 403  : 					IID_IPicture,
; 404  : 					reinterpret_cast<LPVOID *>(&frame.m_pPicture)) != S_OK)

  00632	8d 4d c0	 lea	 ecx, DWORD PTR _frame$198279[ebp]
  00635	51		 push	 ecx
  00636	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPicture
  0063b	6a 00		 push	 0
  0063d	8b 55 e4	 mov	 edx, DWORD PTR _nBlockLen$198280[ebp]
  00640	52		 push	 edx
  00641	8b 45 bc	 mov	 eax, DWORD PTR _pStream$198286[ebp]
  00644	50		 push	 eax
  00645	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleLoadPicture@20
  0064b	85 c0		 test	 eax, eax
  0064d	74 0e		 je	 SHORT $L198291

; 405  : 				{
; 406  : 					pStream->Release();

  0064f	8b 4d bc	 mov	 ecx, DWORD PTR _pStream$198286[ebp]
  00652	8b 11		 mov	 edx, DWORD PTR [ecx]
  00654	8b 45 bc	 mov	 eax, DWORD PTR _pStream$198286[ebp]
  00657	50		 push	 eax
  00658	ff 52 08	 call	 DWORD PTR [edx+8]

; 407  : 					continue;

  0065b	eb 89		 jmp	 SHORT $L198284
$L198291:

; 408  : 				};
; 409  : 				pStream->Release();

  0065d	8b 4d bc	 mov	 ecx, DWORD PTR _pStream$198286[ebp]
  00660	8b 11		 mov	 edx, DWORD PTR [ecx]
  00662	8b 45 bc	 mov	 eax, DWORD PTR _pStream$198286[ebp]
  00665	50		 push	 eax
  00666	ff 52 08	 call	 DWORD PTR [edx+8]

; 410  : 			
; 411  : 				// everything went well, add this frame
; 412  : 				m_arrFrames.push_back(frame);

  00669	8d 4d c0	 lea	 ecx, DWORD PTR _frame$198279[ebp]
  0066c	51		 push	 ecx
  0066d	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00670	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00676	e8 00 00 00 00	 call	 ?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::push_back

; 413  : 			};

  0067b	e9 66 ff ff ff	 jmp	 $L198284
$L198285:

; 414  : 
; 415  : 			// clean after ourselves
; 416  : 			m_pRawData = NULL;

  00680	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00683	c7 42 78 00 00
	00 00		 mov	 DWORD PTR [edx+120], 0

; 417  : 			GlobalUnlock(hGlobal);

  0068a	8b 45 08	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  0068d	50		 push	 eax
  0068e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 418  : 
; 419  : 			if (m_arrFrames.empty()) // couldn't load any frames

  00694	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00697	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0069d	e8 00 00 00 00	 call	 ?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::empty
  006a2	0f b6 c8	 movzx	 ecx, al
  006a5	85 c9		 test	 ecx, ecx
  006a7	74 04		 je	 SHORT $L198253

; 420  : 				return FALSE;

  006a9	33 c0		 xor	 eax, eax
  006ab	eb 16		 jmp	 SHORT $L198235
$L198253:

; 421  : 		};
; 422  : 	}; // if (!IsGIF...
; 423  : 
; 424  : 	return PrepareDC(m_PictureSize.cx,m_PictureSize.cy);

  006ad	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  006b0	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  006b3	50		 push	 eax
  006b4	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  006b7	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  006ba	52		 push	 edx
  006bb	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  006be	e8 00 00 00 00	 call	 ?PrepareDC@CPictureEx@@IAEHHH@Z ; CPictureEx::PrepareDC
$L198235:

; 425  : }

  006c3	8b e5		 mov	 esp, ebp
  006c5	5d		 pop	 ebp
  006c6	c2 08 00	 ret	 8
?Load@CPictureEx@@QAEHPAXK@Z ENDP			; CPictureEx::Load
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z
_TEXT	SEGMENT
tv66 = -12						; size = 4
_this$ = -8						; size = 4
_nRet$ = -4						; size = 4
_Value$ = 8						; size = 4
?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z PROC NEAR ; CPictureEx::TGIFLSDescriptor::GetPackedValue, COMDAT
; _this$ = ecx

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 117  : 	int nRet = (int)m_cPacked;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00010	89 4d fc	 mov	 DWORD PTR _nRet$[ebp], ecx

; 118  : 
; 119  : 	switch (Value)

  00013	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  00016	89 55 f4	 mov	 DWORD PTR tv66[ebp], edx
  00019	83 7d f4 03	 cmp	 DWORD PTR tv66[ebp], 3
  0001d	77 3d		 ja	 SHORT $L198174
  0001f	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  00022	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L200010[eax*4]
$L198177:

; 120  : 	{
; 121  : 	case LSD_PACKED_GLOBALCT:
; 122  : 		nRet = nRet >> 7;

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _nRet$[ebp]
  0002c	c1 f9 07	 sar	 ecx, 7
  0002f	89 4d fc	 mov	 DWORD PTR _nRet$[ebp], ecx

; 123  : 		break;

  00032	eb 28		 jmp	 SHORT $L198174
$L198178:

; 124  : 
; 125  : 	case LSD_PACKED_CRESOLUTION:
; 126  : 		nRet = ((nRet & 0x70) >> 4) + 1;

  00034	8b 55 fc	 mov	 edx, DWORD PTR _nRet$[ebp]
  00037	83 e2 70	 and	 edx, 112		; 00000070H
  0003a	c1 fa 04	 sar	 edx, 4
  0003d	83 c2 01	 add	 edx, 1
  00040	89 55 fc	 mov	 DWORD PTR _nRet$[ebp], edx

; 127  : 		break;

  00043	eb 17		 jmp	 SHORT $L198174
$L198179:

; 128  : 
; 129  : 	case LSD_PACKED_SORT:
; 130  : 		nRet = (nRet & 8) >> 3;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _nRet$[ebp]
  00048	83 e0 08	 and	 eax, 8
  0004b	c1 f8 03	 sar	 eax, 3
  0004e	89 45 fc	 mov	 DWORD PTR _nRet$[ebp], eax

; 131  : 		break;

  00051	eb 09		 jmp	 SHORT $L198174
$L198180:

; 132  : 
; 133  : 	case LSD_PACKED_GLOBALCTSIZE:
; 134  : 		nRet &= 7;

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _nRet$[ebp]
  00056	83 e1 07	 and	 ecx, 7
  00059	89 4d fc	 mov	 DWORD PTR _nRet$[ebp], ecx
$L198174:

; 135  : 		break;
; 136  : 	};
; 137  : 
; 138  : 	return nRet;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _nRet$[ebp]

; 139  : }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
$L200010:
  00065	00 00 00 00	 DD	 $L198177
  00069	00 00 00 00	 DD	 $L198178
  0006d	00 00 00 00	 DD	 $L198179
  00071	00 00 00 00	 DD	 $L198180
?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z ENDP ; CPictureEx::TGIFLSDescriptor::GetPackedValue
_TEXT	ENDS
PUBLIC	?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
PUBLIC	?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::end
PUBLIC	?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::clear
PUBLIC	??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator<
PUBLIC	??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
PUBLIC	??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator*
PUBLIC	??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++
EXTRN	__imp__SelectObject@8:NEAR
EXTRN	__imp__DeleteDC@4:NEAR
EXTRN	__imp__DeleteObject@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv129 = -24						; size = 4
_this$ = -20						; size = 4
$T200015 = -16						; size = 4
$T200014 = -12						; size = 4
$T200013 = -8						; size = 4
_it$ = -4						; size = 4
?UnLoad@CPictureEx@@QAEXXZ PROC NEAR			; CPictureEx::UnLoad
; _this$ = ecx

; 428  : {

  006d0	55		 push	 ebp
  006d1	8b ec		 mov	 ebp, esp
  006d3	83 ec 18	 sub	 esp, 24			; 00000018H
  006d6	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 429  : 	Stop();

  006d9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  006dc	e8 00 00 00 00	 call	 ?Stop@CPictureEx@@QAEXXZ ; CPictureEx::Stop

; 430  : 	if (m_pPicture)

  006e1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  006e4	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  006e8	74 1c		 je	 SHORT $L198296

; 431  : 	{
; 432  : 		m_pPicture->Release();

  006ea	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  006ed	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  006f0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  006f3	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  006f6	8b 12		 mov	 edx, DWORD PTR [edx]
  006f8	51		 push	 ecx
  006f9	ff 52 08	 call	 DWORD PTR [edx+8]

; 433  : 		m_pPicture = NULL;

  006fc	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  006ff	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0
$L198296:

; 434  : 	};
; 435  : 	
; 436  : 	std::vector<TFrame>::iterator it;

  00706	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  00709	e8 00 00 00 00	 call	 ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator

; 437  : 	for (it=m_arrFrames.begin();it<m_arrFrames.end();it++)

  0070e	8d 4d f8	 lea	 ecx, DWORD PTR $T200013[ebp]
  00711	51		 push	 ecx
  00712	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00715	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0071b	e8 00 00 00 00	 call	 ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
  00720	8b 10		 mov	 edx, DWORD PTR [eax]
  00722	89 55 fc	 mov	 DWORD PTR _it$[ebp], edx
  00725	eb 0e		 jmp	 SHORT $L198418
$L198419:
  00727	6a 00		 push	 0
  00729	8d 45 f4	 lea	 eax, DWORD PTR $T200014[ebp]
  0072c	50		 push	 eax
  0072d	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  00730	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++
$L198418:
  00735	8d 4d f0	 lea	 ecx, DWORD PTR $T200015[ebp]
  00738	51		 push	 ecx
  00739	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0073c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00742	e8 00 00 00 00	 call	 ?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::end
  00747	50		 push	 eax
  00748	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  0074b	e8 00 00 00 00	 call	 ??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator<
  00750	0f b6 d0	 movzx	 edx, al
  00753	85 d2		 test	 edx, edx
  00755	74 1b		 je	 SHORT $L198420

; 438  : 		(*it).m_pPicture->Release();

  00757	8d 4d fc	 lea	 ecx, DWORD PTR _it$[ebp]
  0075a	e8 00 00 00 00	 call	 ??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator*
  0075f	8b 00		 mov	 eax, DWORD PTR [eax]
  00761	89 45 e8	 mov	 DWORD PTR tv129[ebp], eax
  00764	8b 4d e8	 mov	 ecx, DWORD PTR tv129[ebp]
  00767	8b 11		 mov	 edx, DWORD PTR [ecx]
  00769	8b 45 e8	 mov	 eax, DWORD PTR tv129[ebp]
  0076c	50		 push	 eax
  0076d	ff 52 08	 call	 DWORD PTR [edx+8]
  00770	eb b5		 jmp	 SHORT $L198419
$L198420:

; 439  : 	m_arrFrames.clear();

  00772	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00775	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0077b	e8 00 00 00 00	 call	 ?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::clear

; 440  : 
; 441  : 	if (m_hMemDC)

  00780	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00783	83 79 4c 00	 cmp	 DWORD PTR [ecx+76], 0
  00787	74 42		 je	 SHORT $L198421

; 442  : 	{
; 443  : 		SelectObject(m_hMemDC,m_hOldBitmap);

  00789	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0078c	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0078f	50		 push	 eax
  00790	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00793	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00796	52		 push	 edx
  00797	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 444  : 		::DeleteDC(m_hMemDC);

  0079d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  007a0	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  007a3	51		 push	 ecx
  007a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 445  : 		::DeleteObject(m_hBitmap);

  007aa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  007ad	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  007b0	50		 push	 eax
  007b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 446  : 		m_hMemDC  = NULL;

  007b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  007ba	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0

; 447  : 		m_hBitmap = NULL;

  007c1	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  007c4	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0
$L198421:

; 448  : 	};
; 449  : 
; 450  : 	if (m_hDispMemDC)

  007cb	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  007ce	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  007d2	74 42		 je	 SHORT $L198422

; 451  : 	{
; 452  : 		SelectObject(m_hDispMemDC,m_hDispOldBM);

  007d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  007d7	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  007da	52		 push	 edx
  007db	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  007de	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  007e1	51		 push	 ecx
  007e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 453  : 		::DeleteDC(m_hDispMemDC);

  007e8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  007eb	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  007ee	50		 push	 eax
  007ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 454  : 		::DeleteObject(m_hDispMemBM);

  007f5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  007f8	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  007fb	52		 push	 edx
  007fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 455  : 		m_hDispMemDC  = NULL;

  00802	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00805	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 456  : 		m_hDispMemBM = NULL;

  0080c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0080f	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0
$L198422:

; 457  : 	};
; 458  : 
; 459  : 	SetRect(&m_PaintRect,0,0,0,0);

  00816	6a 00		 push	 0
  00818	6a 00		 push	 0
  0081a	6a 00		 push	 0
  0081c	6a 00		 push	 0
  0081e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00821	83 c2 10	 add	 edx, 16			; 00000010H
  00824	52		 push	 edx
  00825	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 460  : 	m_pGIFLSDescriptor = NULL;

  0082b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0082e	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], 0

; 461  : 	m_pGIFHeader	   = NULL;

  00835	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00838	c7 41 74 00 00
	00 00		 mov	 DWORD PTR [ecx+116], 0

; 462  : 	m_pRawData		   = NULL;

  0083f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00842	c7 42 78 00 00
	00 00		 mov	 DWORD PTR [edx+120], 0

; 463  : 	m_hThread		   = NULL;

  00849	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0084c	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 464  : 	m_bIsInitialized   = FALSE;

  00853	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00856	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 465  : 	m_bExitThread	   = FALSE;

  0085d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00860	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0

; 466  : 	m_bIsGIF		   = FALSE;

  00867	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0086a	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 467  : 	m_clrBackground    = RGB(255,255,255); // white by default

  00871	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00874	c7 41 28 ff ff
	ff 00		 mov	 DWORD PTR [ecx+40], 16777215 ; 00ffffffH

; 468  : 	m_nGlobalCTSize	   = 0;

  0087b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0087e	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 469  : 	m_nCurrOffset	   = 0;

  00885	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00888	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 470  : 	m_nCurrFrame	   = 0;

  0088f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00892	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 471  : 	m_nDataSize		   = 0;

  00899	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0089c	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 472  : }

  008a3	8b e5		 mov	 esp, ebp
  008a5	5d		 pop	 ebp
  008a6	c3		 ret	 0
?UnLoad@CPictureEx@@QAEXXZ ENDP				; CPictureEx::UnLoad
_TEXT	ENDS
PUBLIC	?IsAnimatedGIF@CPictureEx@@QBEHXZ		; CPictureEx::IsAnimatedGIF
PUBLIC	?Draw@CPictureEx@@QAEHXZ			; CPictureEx::Draw
PUBLIC	?_ThreadAnimation@CPictureEx@@KGIPAX@Z		; CPictureEx::_ThreadAnimation
PUBLIC	?OnPaint@CPictureEx@@QAEXPAUHDC__@@@Z		; CPictureEx::OnPaint
EXTRN	__imp___beginthreadex:NEAR
EXTRN	__imp__ResumeThread@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -16						; size = 4
_hmHeight$198442 = -12					; size = 4
_hmWidth$198441 = -8					; size = 4
_nDummy$198435 = -4					; size = 4
?Draw@CPictureEx@@QAEHXZ PROC NEAR			; CPictureEx::Draw
; _this$ = ecx

; 475  : {

  008b0	55		 push	 ebp
  008b1	8b ec		 mov	 ebp, esp
  008b3	83 ec 10	 sub	 esp, 16			; 00000010H
  008b6	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 	if(m_hThread != NULL)

  008b9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  008bc	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  008c0	74 07		 je	 SHORT $L198432

; 477  : 		return FALSE;

  008c2	33 c0		 xor	 eax, eax
  008c4	e9 e9 00 00 00	 jmp	 $L198431
$L198432:

; 478  : 	if (!m_bIsInitialized)

  008c9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  008cc	83 79 48 00	 cmp	 DWORD PTR [ecx+72], 0
  008d0	75 07		 jne	 SHORT $L198433

; 479  : 	{
; 480  : 		TRACE(_T("Call one of the CPictureEx::Load() member functions before calling Draw()\n"));
; 481  : 		return FALSE;

  008d2	33 c0		 xor	 eax, eax
  008d4	e9 d9 00 00 00	 jmp	 $L198431
$L198433:

; 482  : 	};
; 483  : 
; 484  : 	if (IsAnimatedGIF())

  008d9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  008dc	e8 00 00 00 00	 call	 ?IsAnimatedGIF@CPictureEx@@QBEHXZ ; CPictureEx::IsAnimatedGIF
  008e1	85 c0		 test	 eax, eax
  008e3	74 44		 je	 SHORT $L198434

; 485  : 	{
; 486  : 	// the picture needs animation
; 487  : 	// we'll start the thread that will handle it for us
; 488  : 	
; 489  : 		unsigned int nDummy;
; 490  : 		m_hThread = (HANDLE) _beginthreadex(NULL,0,_ThreadAnimation,this,
; 491  : 			CREATE_SUSPENDED,&nDummy);

  008e5	8d 55 fc	 lea	 edx, DWORD PTR _nDummy$198435[ebp]
  008e8	52		 push	 edx
  008e9	6a 04		 push	 4
  008eb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  008ee	50		 push	 eax
  008ef	68 00 00 00 00	 push	 OFFSET FLAT:?_ThreadAnimation@CPictureEx@@KGIPAX@Z ; CPictureEx::_ThreadAnimation
  008f4	6a 00		 push	 0
  008f6	6a 00		 push	 0
  008f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___beginthreadex
  008fe	83 c4 18	 add	 esp, 24			; 00000018H
  00901	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00904	89 41 68	 mov	 DWORD PTR [ecx+104], eax

; 492  : 		if (!m_hThread)

  00907	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0090a	83 7a 68 00	 cmp	 DWORD PTR [edx+104], 0
  0090e	75 07		 jne	 SHORT $L198437

; 493  : 		{
; 494  : 			TRACE(_T("Draw: Couldn't start a GIF animation thread\n"));
; 495  : 			return FALSE;

  00910	33 c0		 xor	 eax, eax
  00912	e9 9b 00 00 00	 jmp	 $L198431
$L198437:

; 496  : 		} 
; 497  : 		else 
; 498  : 			ResumeThread(m_hThread);

  00917	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0091a	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0091d	51		 push	 ecx
  0091e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResumeThread@4

; 499  : 	} 
; 500  : 	else

  00924	e9 87 00 00 00	 jmp	 $L198439
$L198434:

; 501  : 	{
; 502  : 		if (m_pPicture)

  00929	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0092c	83 7a 70 00	 cmp	 DWORD PTR [edx+112], 0
  00930	74 7e		 je	 SHORT $L198439

; 503  : 		{
; 504  : 			long hmWidth;
; 505  : 			long hmHeight;
; 506  : 			m_pPicture->get_Width(&hmWidth);

  00932	8d 45 f8	 lea	 eax, DWORD PTR _hmWidth$198441[ebp]
  00935	50		 push	 eax
  00936	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00939	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  0093c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0093f	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00942	8b 12		 mov	 edx, DWORD PTR [edx]
  00944	51		 push	 ecx
  00945	ff 52 18	 call	 DWORD PTR [edx+24]

; 507  : 			m_pPicture->get_Height(&hmHeight);

  00948	8d 45 f4	 lea	 eax, DWORD PTR _hmHeight$198442[ebp]
  0094b	50		 push	 eax
  0094c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0094f	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00952	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00955	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00958	8b 12		 mov	 edx, DWORD PTR [edx]
  0095a	51		 push	 ecx
  0095b	ff 52 1c	 call	 DWORD PTR [edx+28]

; 508  : 			if (m_pPicture->Render(m_hMemDC, 0, 0, m_PictureSize.cx, m_PictureSize.cy, 
; 509  : 				0, hmHeight, hmWidth, -hmHeight, NULL) == S_OK)

  0095e	6a 00		 push	 0
  00960	8b 45 f4	 mov	 eax, DWORD PTR _hmHeight$198442[ebp]
  00963	f7 d8		 neg	 eax
  00965	50		 push	 eax
  00966	8b 4d f8	 mov	 ecx, DWORD PTR _hmWidth$198441[ebp]
  00969	51		 push	 ecx
  0096a	8b 55 f4	 mov	 edx, DWORD PTR _hmHeight$198442[ebp]
  0096d	52		 push	 edx
  0096e	6a 00		 push	 0
  00970	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00973	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00976	51		 push	 ecx
  00977	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0097a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0097d	50		 push	 eax
  0097e	6a 00		 push	 0
  00980	6a 00		 push	 0
  00982	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00985	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00988	52		 push	 edx
  00989	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0098c	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0098f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00992	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00995	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00997	50		 push	 eax
  00998	ff 51 20	 call	 DWORD PTR [ecx+32]
  0099b	85 c0		 test	 eax, eax
  0099d	75 11		 jne	 SHORT $L198439

; 510  : 			{
; 511  : ////				Invalidate(FALSE);
; 512  : 				OnPaint();

  0099f	6a 00		 push	 0
  009a1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  009a4	e8 00 00 00 00	 call	 ?OnPaint@CPictureEx@@QAEXPAUHDC__@@@Z ; CPictureEx::OnPaint

; 513  : 				return TRUE;

  009a9	b8 01 00 00 00	 mov	 eax, 1
  009ae	eb 02		 jmp	 SHORT $L198431
$L198439:

; 514  : 			};
; 515  : 		};
; 516  : 	};
; 517  : 
; 518  : 	return FALSE;	

  009b0	33 c0		 xor	 eax, eax
$L198431:

; 519  : }

  009b2	8b e5		 mov	 esp, ebp
  009b4	5d		 pop	 ebp
  009b5	c3		 ret	 0
?Draw@CPictureEx@@QAEHXZ ENDP				; CPictureEx::Draw
_TEXT	ENDS
PUBLIC	?GetSize@CPictureEx@@QBE?AUtagSIZE@@XZ		; CPictureEx::GetSize
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetSize@CPictureEx@@QBE?AUtagSIZE@@XZ PROC NEAR	; CPictureEx::GetSize
; _this$ = ecx

; 522  : {

  009c0	55		 push	 ebp
  009c1	8b ec		 mov	 ebp, esp
  009c3	51		 push	 ecx
  009c4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 523  : 	return m_PictureSize;

  009c7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009ca	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  009cd	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  009d0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  009d3	89 08		 mov	 DWORD PTR [eax], ecx
  009d5	89 50 04	 mov	 DWORD PTR [eax+4], edx
  009d8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 524  : }

  009db	8b e5		 mov	 esp, ebp
  009dd	5d		 pop	 ebp
  009de	c2 04 00	 ret	 4
?GetSize@CPictureEx@@QBE?AUtagSIZE@@XZ ENDP		; CPictureEx::GetSize
_TEXT	ENDS
PUBLIC	?Load@CPictureEx@@QAEHPBD@Z			; CPictureEx::Load
PUBLIC	??1AFX_EXCEPTION_LINK@@QAE@XZ			; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK
PUBLIC	??_R0PAVCFileException@@@8			; CFileException * `RTTI Type Descriptor'
EXTRN	__imp__GlobalAlloc@8:NEAR
EXTRN	??0AFX_EXCEPTION_LINK@@QAE@XZ:NEAR		; AFX_EXCEPTION_LINK::AFX_EXCEPTION_LINK
EXTRN	??0CFile@@QAE@XZ:NEAR				; CFile::CFile
EXTRN	?Open@CFile@@UAEHPBDIPAVCFileException@@@Z:NEAR	; CFile::Open
EXTRN	?GetLength@CFile@@UBE_KXZ:NEAR			; CFile::GetLength
EXTRN	?Read@CFile@@UAEIPAXI@Z:NEAR			; CFile::Read
EXTRN	?Delete@CException@@QAEXXZ:NEAR			; CException::Delete
EXTRN	?Close@CFile@@UAEXXZ:NEAR			; CFile::Close
EXTRN	??1CFile@@UAE@XZ:NEAR				; CFile::~CFile
xdata$x	SEGMENT
$T200033 DD	0ffffffffH
	DD	FLAT:$L200026
	DD	00H
	DD	FLAT:$L200027
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T200035 DD	00H
	DD	FLAT:??_R0PAVCFileException@@@8
	DD	0ffffffc4H
	DD	FLAT:$L200025
$T200034 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T200035
$T200031 DD	019930520H
	DD	04H
	DD	FLAT:$T200033
	DD	01H
	DD	FLAT:$T200034
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0PAVCFileException@@@8
_DATA	SEGMENT
??_R0PAVCFileException@@@8 DD FLAT:??_7type_info@@6B@	; CFileException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCFileException@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T200023 = -80						; size = 4
$T200022 = -76						; size = 4
$T200021 = -72						; size = 4
$T200020 = -68						; size = 4
$T200019 = -64						; size = 4
_e$198468 = -60						; size = 4
__afxExceptionLink$198466 = -56				; size = 8
_hGlobal$ = -48						; size = 4
_file$ = -44						; size = 16
_bRetValue$ = -28					; size = 4
_dwSize$ = -24						; size = 4
_pData$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_szFileName$ = 8					; size = 4
?Load@CPictureEx@@QAEHPBD@Z PROC NEAR			; CPictureEx::Load
; _this$ = ecx

; 527  : {

  009f0	55		 push	 ebp
  009f1	8b ec		 mov	 ebp, esp
  009f3	6a ff		 push	 -1
  009f5	68 00 00 00 00	 push	 __ehhandler$?Load@CPictureEx@@QAEHPBD@Z
  009fa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00a00	50		 push	 eax
  00a01	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00a08	51		 push	 ecx
  00a09	83 ec 44	 sub	 esp, 68			; 00000044H
  00a0c	53		 push	 ebx
  00a0d	56		 push	 esi
  00a0e	57		 push	 edi
  00a0f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00a12	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 528  : 	ASSERT(szFileName);
; 529  : 	
; 530  : 	CFile file;

  00a15	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00a18	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile
  00a1d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 531  : 	HGLOBAL hGlobal;
; 532  : 	DWORD dwSize;
; 533  : 
; 534  : 	if (!file.Open(szFileName,
; 535  : 				CFile::modeRead | 
; 536  : 				CFile::shareDenyWrite) )

  00a24	6a 00		 push	 0
  00a26	6a 20		 push	 32			; 00000020H
  00a28	8b 45 08	 mov	 eax, DWORD PTR _szFileName$[ebp]
  00a2b	50		 push	 eax
  00a2c	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00a2f	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  00a34	85 c0		 test	 eax, eax
  00a36	75 1e		 jne	 SHORT $L198457

; 537  : 	{
; 538  : 		TRACE(_T("Load (file): Error opening file %s\n"),szFileName);
; 539  : 		return FALSE;

  00a38	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T200019[ebp], 0
  00a3f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00a46	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00a49	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00a4e	8b 45 c0	 mov	 eax, DWORD PTR $T200019[ebp]
  00a51	e9 44 01 00 00	 jmp	 $L198452
$L198457:

; 540  : 	};
; 541  : 
; 542  : 	dwSize = (DWORD)(file.GetLength());

  00a56	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00a59	e8 00 00 00 00	 call	 ?GetLength@CFile@@UBE_KXZ ; CFile::GetLength
  00a5e	89 45 e8	 mov	 DWORD PTR _dwSize$[ebp], eax

; 543  : 	hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,dwSize);

  00a61	8b 4d e8	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  00a64	51		 push	 ecx
  00a65	6a 22		 push	 34			; 00000022H
  00a67	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00a6d	89 45 d0	 mov	 DWORD PTR _hGlobal$[ebp], eax

; 544  : 	if (!hGlobal)

  00a70	83 7d d0 00	 cmp	 DWORD PTR _hGlobal$[ebp], 0
  00a74	75 1e		 jne	 SHORT $L198460

; 545  : 	{
; 546  : 		TRACE(_T("Load (file): Error allocating memory\n"));
; 547  : 		return FALSE;

  00a76	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T200020[ebp], 0
  00a7d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00a84	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00a87	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00a8c	8b 45 bc	 mov	 eax, DWORD PTR $T200020[ebp]
  00a8f	e9 06 01 00 00	 jmp	 $L198452
$L198460:

; 548  : 	};
; 549  : 	
; 550  : 	char *pData = reinterpret_cast<char*>(GlobalLock(hGlobal));

  00a94	8b 55 d0	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00a97	52		 push	 edx
  00a98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  00a9e	89 45 ec	 mov	 DWORD PTR _pData$[ebp], eax

; 551  : 	if (!pData)

  00aa1	83 7d ec 00	 cmp	 DWORD PTR _pData$[ebp], 0
  00aa5	75 28		 jne	 SHORT $L198464

; 552  : 	{
; 553  : 		TRACE(_T("Load (file): Error locking memory\n"));
; 554  : 		GlobalFree(hGlobal);

  00aa7	8b 45 d0	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  00aaa	50		 push	 eax
  00aab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 555  : 		return FALSE;

  00ab1	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T200021[ebp], 0
  00ab8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00abf	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00ac2	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00ac7	8b 45 b8	 mov	 eax, DWORD PTR $T200021[ebp]
  00aca	e9 cb 00 00 00	 jmp	 $L198452
$L198464:

; 556  : 	};
; 557  : 
; 558  : 	TRY

  00acf	8d 4d c8	 lea	 ecx, DWORD PTR __afxExceptionLink$198466[ebp]
  00ad2	e8 00 00 00 00	 call	 ??0AFX_EXCEPTION_LINK@@QAE@XZ ; AFX_EXCEPTION_LINK::AFX_EXCEPTION_LINK
  00ad7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00adb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 559  : 	{
; 560  : 		file.Read(pData,dwSize);

  00adf	8b 4d e8	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  00ae2	51		 push	 ecx
  00ae3	8b 55 ec	 mov	 edx, DWORD PTR _pData$[ebp]
  00ae6	52		 push	 edx
  00ae7	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00aea	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  00aef	eb 2d		 jmp	 SHORT $L200024
$L200025:

; 561  : 	}
; 562  : 	CATCH(CFileException, e);                                          

  00af1	8b 45 c4	 mov	 eax, DWORD PTR _e$198468[ebp]
  00af4	89 45 cc	 mov	 DWORD PTR __afxExceptionLink$198466[ebp+4], eax

; 563  : 	{
; 564  : 		TRACE(_T("Load (file): An exception occured while reading the file %s\n"),
; 565  : 			szFileName);
; 566  : 		GlobalFree(hGlobal);

  00af7	8b 4d d0	 mov	 ecx, DWORD PTR _hGlobal$[ebp]
  00afa	51		 push	 ecx
  00afb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 567  : 		e->Delete();

  00b01	8b 4d c4	 mov	 ecx, DWORD PTR _e$198468[ebp]
  00b04	e8 00 00 00 00	 call	 ?Delete@CException@@QAEXXZ ; CException::Delete

; 568  : 		file.Close();

  00b09	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00b0c	e8 00 00 00 00	 call	 ?Close@CFile@@UAEXXZ	; CFile::Close

; 569  : 		return FALSE;

  00b11	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T200022[ebp], 0
  00b18	b8 00 00 00 00	 mov	 eax, $L200029
  00b1d	c3		 ret	 0
$L200024:

; 570  : 	}
; 571  : 	END_CATCH

  00b1e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00b25	eb 20		 jmp	 SHORT $L200028
$L200029:

; 569  : 		return FALSE;

  00b27	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00b2b	8d 4d c8	 lea	 ecx, DWORD PTR __afxExceptionLink$198466[ebp]
  00b2e	e8 00 00 00 00	 call	 ??1AFX_EXCEPTION_LINK@@QAE@XZ ; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK
  00b33	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00b3a	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00b3d	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00b42	8b 45 b4	 mov	 eax, DWORD PTR $T200022[ebp]
  00b45	eb 53		 jmp	 SHORT $L198452
$L200028:

; 570  : 	}
; 571  : 	END_CATCH

  00b47	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00b4b	8d 4d c8	 lea	 ecx, DWORD PTR __afxExceptionLink$198466[ebp]
  00b4e	e8 00 00 00 00	 call	 ??1AFX_EXCEPTION_LINK@@QAE@XZ ; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK

; 572  : 	GlobalUnlock(hGlobal);

  00b53	8b 55 d0	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00b56	52		 push	 edx
  00b57	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 573  : 	file.Close();

  00b5d	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00b60	e8 00 00 00 00	 call	 ?Close@CFile@@UAEXXZ	; CFile::Close

; 574  : 
; 575  : 	BOOL bRetValue = Load(hGlobal,dwSize);

  00b65	8b 45 e8	 mov	 eax, DWORD PTR _dwSize$[ebp]
  00b68	50		 push	 eax
  00b69	8b 4d d0	 mov	 ecx, DWORD PTR _hGlobal$[ebp]
  00b6c	51		 push	 ecx
  00b6d	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00b70	e8 00 00 00 00	 call	 ?Load@CPictureEx@@QAEHPAXK@Z ; CPictureEx::Load
  00b75	89 45 e4	 mov	 DWORD PTR _bRetValue$[ebp], eax

; 576  : 	GlobalFree(hGlobal);

  00b78	8b 55 d0	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00b7b	52		 push	 edx
  00b7c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 577  : 	return bRetValue;

  00b82	8b 45 e4	 mov	 eax, DWORD PTR _bRetValue$[ebp]
  00b85	89 45 b0	 mov	 DWORD PTR $T200023[ebp], eax
  00b88	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00b8f	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00b92	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00b97	8b 45 b0	 mov	 eax, DWORD PTR $T200023[ebp]
$L198452:

; 578  : }

  00b9a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00b9d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00ba4	5f		 pop	 edi
  00ba5	5e		 pop	 esi
  00ba6	5b		 pop	 ebx
  00ba7	8b e5		 mov	 esp, ebp
  00ba9	5d		 pop	 ebp
  00baa	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L200026:
  00044	8d 4d d4	 lea	 ecx, DWORD PTR _file$[ebp]
  00047	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
$L200027:
  0004c	8d 4d c8	 lea	 ecx, DWORD PTR __afxExceptionLink$198466[ebp]
  0004f	e9 00 00 00 00	 jmp	 ??1AFX_EXCEPTION_LINK@@QAE@XZ ; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK
__ehhandler$?Load@CPictureEx@@QAEHPBD@Z:
  00054	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200031
  00059	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Load@CPictureEx@@QAEHPBD@Z ENDP			; CPictureEx::Load
PUBLIC	?Load@CPictureEx@@QAEHPBD0@Z			; CPictureEx::Load
PUBLIC	?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ	; AfxGetResourceHandle
EXTRN	__imp__FreeResource@4:NEAR
EXTRN	__imp__LockResource@4:NEAR
EXTRN	__imp__FindResourceA@12:NEAR
EXTRN	__imp__LoadResource@8:NEAR
EXTRN	__imp__SizeofResource@8:NEAR
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -32						; size = 4
_pSrc$ = -28						; size = 4
_hPicture$ = -24					; size = 4
_hGlobal$ = -20						; size = 4
_hResData$ = -16					; size = 4
_bRetValue$ = -12					; size = 4
_dwSize$ = -8						; size = 4
_pDest$ = -4						; size = 4
_szResourceName$ = 8					; size = 4
_szResourceType$ = 12					; size = 4
?Load@CPictureEx@@QAEHPBD0@Z PROC NEAR			; CPictureEx::Load
; _this$ = ecx

; 581  : {

  00bb0	55		 push	 ebp
  00bb1	8b ec		 mov	 ebp, esp
  00bb3	83 ec 20	 sub	 esp, 32			; 00000020H
  00bb6	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 582  : 	ASSERT(szResourceName);
; 583  : 	ASSERT(szResourceType);
; 584  : 
; 585  : 	HRSRC hPicture = FindResource(AfxGetResourceHandle(),szResourceName,szResourceType);

  00bb9	8b 45 0c	 mov	 eax, DWORD PTR _szResourceType$[ebp]
  00bbc	50		 push	 eax
  00bbd	8b 4d 08	 mov	 ecx, DWORD PTR _szResourceName$[ebp]
  00bc0	51		 push	 ecx
  00bc1	e8 00 00 00 00	 call	 ?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ ; AfxGetResourceHandle
  00bc6	50		 push	 eax
  00bc7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  00bcd	89 45 e8	 mov	 DWORD PTR _hPicture$[ebp], eax

; 586  : 	HGLOBAL hResData;
; 587  : 	if (!hPicture || !(hResData = LoadResource(AfxGetResourceHandle(),hPicture)))

  00bd0	83 7d e8 00	 cmp	 DWORD PTR _hPicture$[ebp], 0
  00bd4	74 19		 je	 SHORT $L198484
  00bd6	8b 55 e8	 mov	 edx, DWORD PTR _hPicture$[ebp]
  00bd9	52		 push	 edx
  00bda	e8 00 00 00 00	 call	 ?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ ; AfxGetResourceHandle
  00bdf	50		 push	 eax
  00be0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8
  00be6	89 45 f0	 mov	 DWORD PTR _hResData$[ebp], eax
  00be9	83 7d f0 00	 cmp	 DWORD PTR _hResData$[ebp], 0
  00bed	75 07		 jne	 SHORT $L198483
$L198484:

; 588  : 	{
; 589  : 		TRACE(_T("Load (resource): Error loading resource %s\n"),szResourceName);
; 590  : 		return FALSE;

  00bef	33 c0		 xor	 eax, eax
  00bf1	e9 bf 00 00 00	 jmp	 $L198478
$L198483:

; 591  : 	};
; 592  : 	DWORD dwSize = SizeofResource(AfxGetResourceHandle(),hPicture);

  00bf6	8b 45 e8	 mov	 eax, DWORD PTR _hPicture$[ebp]
  00bf9	50		 push	 eax
  00bfa	e8 00 00 00 00	 call	 ?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ ; AfxGetResourceHandle
  00bff	50		 push	 eax
  00c00	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8
  00c06	89 45 f8	 mov	 DWORD PTR _dwSize$[ebp], eax

; 593  : 
; 594  : 	// hResData is not the real HGLOBAL (we can't lock it)
; 595  : 	// let's make it real
; 596  : 
; 597  : 	HGLOBAL hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,dwSize);

  00c09	8b 4d f8	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  00c0c	51		 push	 ecx
  00c0d	6a 22		 push	 34			; 00000022H
  00c0f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00c15	89 45 ec	 mov	 DWORD PTR _hGlobal$[ebp], eax

; 598  : 	if (!hGlobal)

  00c18	83 7d ec 00	 cmp	 DWORD PTR _hGlobal$[ebp], 0
  00c1c	75 11		 jne	 SHORT $L198487

; 599  : 	{
; 600  : 		TRACE(_T("Load (resource): Error allocating memory\n"));
; 601  : 		FreeResource(hResData);

  00c1e	8b 55 f0	 mov	 edx, DWORD PTR _hResData$[ebp]
  00c21	52		 push	 edx
  00c22	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeResource@4

; 602  : 		return FALSE;

  00c28	33 c0		 xor	 eax, eax
  00c2a	e9 86 00 00 00	 jmp	 $L198478
$L198487:

; 603  : 	};
; 604  : 	
; 605  : 	char *pDest = reinterpret_cast<char *> (GlobalLock(hGlobal));

  00c2f	8b 45 ec	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  00c32	50		 push	 eax
  00c33	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  00c39	89 45 fc	 mov	 DWORD PTR _pDest$[ebp], eax

; 606  : 	char *pSrc = reinterpret_cast<char *> (LockResource(hResData));

  00c3c	8b 4d f0	 mov	 ecx, DWORD PTR _hResData$[ebp]
  00c3f	51		 push	 ecx
  00c40	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LockResource@4
  00c46	89 45 e4	 mov	 DWORD PTR _pSrc$[ebp], eax

; 607  : 	if (!pSrc || !pDest)

  00c49	83 7d e4 00	 cmp	 DWORD PTR _pSrc$[ebp], 0
  00c4d	74 06		 je	 SHORT $L198493
  00c4f	83 7d fc 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  00c53	75 18		 jne	 SHORT $L198492
$L198493:

; 608  : 	{
; 609  : 		TRACE(_T("Load (resource): Error locking memory\n"));
; 610  : 		GlobalFree(hGlobal);

  00c55	8b 55 ec	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00c58	52		 push	 edx
  00c59	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 611  : 		FreeResource(hResData);

  00c5f	8b 45 f0	 mov	 eax, DWORD PTR _hResData$[ebp]
  00c62	50		 push	 eax
  00c63	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeResource@4

; 612  : 		return FALSE;

  00c69	33 c0		 xor	 eax, eax
  00c6b	eb 48		 jmp	 SHORT $L198478
$L198492:

; 613  : 	};
; 614  : 	CopyMemory(pDest,pSrc,dwSize);

  00c6d	8b 4d f8	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  00c70	51		 push	 ecx
  00c71	8b 55 e4	 mov	 edx, DWORD PTR _pSrc$[ebp]
  00c74	52		 push	 edx
  00c75	8b 45 fc	 mov	 eax, DWORD PTR _pDest$[ebp]
  00c78	50		 push	 eax
  00c79	e8 00 00 00 00	 call	 _memcpy
  00c7e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 615  : 	FreeResource(hResData);

  00c81	8b 4d f0	 mov	 ecx, DWORD PTR _hResData$[ebp]
  00c84	51		 push	 ecx
  00c85	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeResource@4

; 616  : 	GlobalUnlock(hGlobal);

  00c8b	8b 55 ec	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00c8e	52		 push	 edx
  00c8f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 617  : 
; 618  : 	BOOL bRetValue = Load(hGlobal,dwSize);

  00c95	8b 45 f8	 mov	 eax, DWORD PTR _dwSize$[ebp]
  00c98	50		 push	 eax
  00c99	8b 4d ec	 mov	 ecx, DWORD PTR _hGlobal$[ebp]
  00c9c	51		 push	 ecx
  00c9d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00ca0	e8 00 00 00 00	 call	 ?Load@CPictureEx@@QAEHPAXK@Z ; CPictureEx::Load
  00ca5	89 45 f4	 mov	 DWORD PTR _bRetValue$[ebp], eax

; 619  : 	GlobalFree(hGlobal);

  00ca8	8b 55 ec	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00cab	52		 push	 edx
  00cac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 620  : 	return bRetValue;

  00cb2	8b 45 f4	 mov	 eax, DWORD PTR _bRetValue$[ebp]
$L198478:

; 621  : }

  00cb5	8b e5		 mov	 esp, ebp
  00cb7	5d		 pop	 ebp
  00cb8	c2 08 00	 ret	 8
?Load@CPictureEx@@QAEHPBD0@Z ENDP			; CPictureEx::Load
; Function compile flags: /Odt
_this$ = -4						; size = 4
?ResetDataPointer@CPictureEx@@IAEXXZ PROC NEAR		; CPictureEx::ResetDataPointer
; _this$ = ecx

; 624  : {

  00cc0	55		 push	 ebp
  00cc1	8b ec		 mov	 ebp, esp
  00cc3	51		 push	 ecx
  00cc4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 625  : 	// skip header and logical screen descriptor
; 626  : 	m_nCurrOffset = 
; 627  : 		sizeof(TGIFHeader)+sizeof(TGIFLSDescriptor)+m_nGlobalCTSize;

  00cc7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00cca	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00ccd	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00cd0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00cd3	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 628  : }

  00cd6	8b e5		 mov	 esp, ebp
  00cd8	5d		 pop	 ebp
  00cd9	c3		 ret	 0
?ResetDataPointer@CPictureEx@@IAEXXZ ENDP		; CPictureEx::ResetDataPointer
_TEXT	ENDS
PUBLIC	?GetNextBlockLen@CPictureEx@@IBEHXZ		; CPictureEx::GetNextBlockLen
PUBLIC	?SkipNextBlock@CPictureEx@@IAEHXZ		; CPictureEx::SkipNextBlock
PUBLIC	?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nBlock$ = -4						; size = 4
?SkipNextGraphicBlock@CPictureEx@@IAEHXZ PROC NEAR	; CPictureEx::SkipNextGraphicBlock
; _this$ = ecx

; 631  : {

  00ce0	55		 push	 ebp
  00ce1	8b ec		 mov	 ebp, esp
  00ce3	83 ec 08	 sub	 esp, 8
  00ce6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 632  : 	if (!m_pRawData) return FALSE;

  00ce9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00cec	83 78 78 00	 cmp	 DWORD PTR [eax+120], 0
  00cf0	75 07		 jne	 SHORT $L198503
  00cf2	33 c0		 xor	 eax, eax
  00cf4	e9 e7 00 00 00	 jmp	 $L198502
$L198503:

; 633  : 
; 634  : 	// GIF header + LSDescriptor [+ GCT] [+ Control block] + Data
; 635  : 
; 636  : 	enum GIFBlockTypes nBlock;
; 637  : 
; 638  : 	nBlock = GetNextBlock();

  00cf9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00cfc	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  00d01	89 45 fc	 mov	 DWORD PTR _nBlock$[ebp], eax
$L198506:

; 639  : 
; 640  : 	while ((nBlock != BLOCK_CONTROLEXT) &&
; 641  : 		   (nBlock != BLOCK_IMAGE) &&
; 642  : 		   (nBlock != BLOCK_PLAINTEXT) &&
; 643  : 		   (nBlock != BLOCK_UNKNOWN) &&
; 644  : 		   (nBlock != BLOCK_TRAILER) )

  00d04	83 7d fc 03	 cmp	 DWORD PTR _nBlock$[ebp], 3
  00d08	74 38		 je	 SHORT $L198507
  00d0a	83 7d fc 05	 cmp	 DWORD PTR _nBlock$[ebp], 5
  00d0e	74 32		 je	 SHORT $L198507
  00d10	83 7d fc 04	 cmp	 DWORD PTR _nBlock$[ebp], 4
  00d14	74 2c		 je	 SHORT $L198507
  00d16	83 7d fc 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  00d1a	74 26		 je	 SHORT $L198507
  00d1c	83 7d fc 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  00d20	74 20		 je	 SHORT $L198507

; 645  : 	{
; 646  : 		if (!SkipNextBlock()) return NULL;

  00d22	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d25	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  00d2a	85 c0		 test	 eax, eax
  00d2c	75 07		 jne	 SHORT $L198508
  00d2e	33 c0		 xor	 eax, eax
  00d30	e9 ab 00 00 00	 jmp	 $L198502
$L198508:

; 647  : 		nBlock = GetNextBlock();

  00d35	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d38	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  00d3d	89 45 fc	 mov	 DWORD PTR _nBlock$[ebp], eax

; 648  : 	};

  00d40	eb c2		 jmp	 SHORT $L198506
$L198507:

; 649  : 
; 650  : 	if ((nBlock == BLOCK_UNKNOWN) ||
; 651  : 		(nBlock == BLOCK_TRAILER))

  00d42	83 7d fc 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  00d46	74 06		 je	 SHORT $L198510
  00d48	83 7d fc 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  00d4c	75 07		 jne	 SHORT $L198509
$L198510:

; 652  : 		return FALSE;

  00d4e	33 c0		 xor	 eax, eax
  00d50	e9 8b 00 00 00	 jmp	 $L198502
$L198509:

; 653  : 
; 654  : 	// it's either a control ext.block, an image or a plain text
; 655  : 
; 656  : 	if (GetNextBlockLen() <= 0) return FALSE;

  00d55	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d58	e8 00 00 00 00	 call	 ?GetNextBlockLen@CPictureEx@@IBEHXZ ; CPictureEx::GetNextBlockLen
  00d5d	85 c0		 test	 eax, eax
  00d5f	7f 04		 jg	 SHORT $L198511
  00d61	33 c0		 xor	 eax, eax
  00d63	eb 7b		 jmp	 SHORT $L198502
$L198511:

; 657  : 
; 658  : 	if (nBlock == BLOCK_CONTROLEXT)

  00d65	83 7d fc 03	 cmp	 DWORD PTR _nBlock$[ebp], 3
  00d69	75 60		 jne	 SHORT $L198512

; 659  : 	{
; 660  : 		if (!SkipNextBlock()) return FALSE;

  00d6b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d6e	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  00d73	85 c0		 test	 eax, eax
  00d75	75 04		 jne	 SHORT $L198513
  00d77	33 c0		 xor	 eax, eax
  00d79	eb 65		 jmp	 SHORT $L198502
$L198513:

; 661  : 		nBlock = GetNextBlock();

  00d7b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d7e	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  00d83	89 45 fc	 mov	 DWORD PTR _nBlock$[ebp], eax
$L198515:

; 662  : 
; 663  : 		// skip everything until we meet an image block or a plain-text block
; 664  : 		while ((nBlock != BLOCK_IMAGE) &&
; 665  : 			   (nBlock != BLOCK_PLAINTEXT) &&
; 666  : 			   (nBlock != BLOCK_UNKNOWN) &&
; 667  : 			   (nBlock != BLOCK_TRAILER) )

  00d86	83 7d fc 05	 cmp	 DWORD PTR _nBlock$[ebp], 5
  00d8a	74 2f		 je	 SHORT $L198516
  00d8c	83 7d fc 04	 cmp	 DWORD PTR _nBlock$[ebp], 4
  00d90	74 29		 je	 SHORT $L198516
  00d92	83 7d fc 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  00d96	74 23		 je	 SHORT $L198516
  00d98	83 7d fc 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  00d9c	74 1d		 je	 SHORT $L198516

; 668  : 		{
; 669  : 			if (!SkipNextBlock()) return NULL;

  00d9e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00da1	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  00da6	85 c0		 test	 eax, eax
  00da8	75 04		 jne	 SHORT $L198517
  00daa	33 c0		 xor	 eax, eax
  00dac	eb 32		 jmp	 SHORT $L198502
$L198517:

; 670  : 			nBlock = GetNextBlock();

  00dae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00db1	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  00db6	89 45 fc	 mov	 DWORD PTR _nBlock$[ebp], eax

; 671  : 		};

  00db9	eb cb		 jmp	 SHORT $L198515
$L198516:

; 672  : 
; 673  : 		if ((nBlock == BLOCK_UNKNOWN) ||
; 674  : 			(nBlock == BLOCK_TRAILER))

  00dbb	83 7d fc 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  00dbf	74 06		 je	 SHORT $L198519
  00dc1	83 7d fc 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  00dc5	75 04		 jne	 SHORT $L198512
$L198519:

; 675  : 			return FALSE;

  00dc7	33 c0		 xor	 eax, eax
  00dc9	eb 15		 jmp	 SHORT $L198502
$L198512:

; 676  : 	};
; 677  : 
; 678  : 	// skip the found data block (image or plain-text)
; 679  : 	if (!SkipNextBlock()) return FALSE;

  00dcb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00dce	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  00dd3	85 c0		 test	 eax, eax
  00dd5	75 04		 jne	 SHORT $L198520
  00dd7	33 c0		 xor	 eax, eax
  00dd9	eb 05		 jmp	 SHORT $L198502
$L198520:

; 680  : 
; 681  : 	return TRUE;

  00ddb	b8 01 00 00 00	 mov	 eax, 1
$L198502:

; 682  : }

  00de0	8b e5		 mov	 esp, ebp
  00de2	5d		 pop	 ebp
  00de3	c3		 ret	 0
?SkipNextGraphicBlock@CPictureEx@@IAEHXZ ENDP		; CPictureEx::SkipNextGraphicBlock
_TEXT	ENDS
PUBLIC	?GetSubBlocksLen@CPictureEx@@IBEII@Z		; CPictureEx::GetSubBlocksLen
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nCurOffset$ = -8					; size = 4
_nRet$ = -4						; size = 4
_nStartingOffset$ = 8					; size = 4
?GetSubBlocksLen@CPictureEx@@IBEII@Z PROC NEAR		; CPictureEx::GetSubBlocksLen
; _this$ = ecx

; 685  : {

  00df0	55		 push	 ebp
  00df1	8b ec		 mov	 ebp, esp
  00df3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00df6	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 686  : 	UINT nRet = 0;

  00df9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nRet$[ebp], 0

; 687  : 	UINT nCurOffset = nStartingOffset;

  00e00	8b 45 08	 mov	 eax, DWORD PTR _nStartingOffset$[ebp]
  00e03	89 45 f8	 mov	 DWORD PTR _nCurOffset$[ebp], eax
$L198528:

; 688  : 	
; 689  : 	while (m_pRawData[nCurOffset] != 0)

  00e06	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00e09	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  00e0c	8b 45 f8	 mov	 eax, DWORD PTR _nCurOffset$[ebp]
  00e0f	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00e13	85 c9		 test	 ecx, ecx
  00e15	74 30		 je	 SHORT $L198529

; 690  : 	{
; 691  : 		nRet += m_pRawData[nCurOffset]+1;

  00e17	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00e1a	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  00e1d	8b 4d f8	 mov	 ecx, DWORD PTR _nCurOffset$[ebp]
  00e20	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  00e24	8b 45 fc	 mov	 eax, DWORD PTR _nRet$[ebp]
  00e27	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00e2b	89 4d fc	 mov	 DWORD PTR _nRet$[ebp], ecx

; 692  : 		nCurOffset += m_pRawData[nCurOffset]+1;

  00e2e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00e31	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  00e34	8b 4d f8	 mov	 ecx, DWORD PTR _nCurOffset$[ebp]
  00e37	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  00e3b	8b 45 f8	 mov	 eax, DWORD PTR _nCurOffset$[ebp]
  00e3e	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00e42	89 4d f8	 mov	 DWORD PTR _nCurOffset$[ebp], ecx

; 693  : 	};

  00e45	eb bf		 jmp	 SHORT $L198528
$L198529:

; 694  : 
; 695  : 	return nRet+1;

  00e47	8b 45 fc	 mov	 eax, DWORD PTR _nRet$[ebp]
  00e4a	83 c0 01	 add	 eax, 1

; 696  : }

  00e4d	8b e5		 mov	 esp, ebp
  00e4f	5d		 pop	 ebp
  00e50	c2 04 00	 ret	 4
?GetSubBlocksLen@CPictureEx@@IBEII@Z ENDP		; CPictureEx::GetSubBlocksLen
; Function compile flags: /Odt
tv74 = -12						; size = 4
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ PROC NEAR ; CPictureEx::GetNextBlock
; _this$ = ecx

; 699  : {

  00e60	55		 push	 ebp
  00e61	8b ec		 mov	 ebp, esp
  00e63	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00e66	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 700  : 	switch(m_pRawData[m_nCurrOffset])

  00e69	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e6c	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00e6f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00e72	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00e75	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  00e78	88 4d f8	 mov	 BYTE PTR tv68[ebp], cl
  00e7b	80 7d f8 21	 cmp	 BYTE PTR tv68[ebp], 33	; 00000021H
  00e7f	74 0e		 je	 SHORT $L198537
  00e81	80 7d f8 2c	 cmp	 BYTE PTR tv68[ebp], 44	; 0000002cH
  00e85	74 64		 je	 SHORT $L198547
  00e87	80 7d f8 3b	 cmp	 BYTE PTR tv68[ebp], 59	; 0000003bH
  00e8b	74 57		 je	 SHORT $L198546
  00e8d	eb 63		 jmp	 SHORT $L198534
$L198537:

; 701  : 	{
; 702  : 	case 0x21:
; 703  : 	// extension block
; 704  : 		switch(m_pRawData[m_nCurrOffset+1])

  00e8f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00e92	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00e95	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e98	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  00e9b	0f b6 44 02 01	 movzx	 eax, BYTE PTR [edx+eax+1]
  00ea0	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  00ea3	8b 4d f4	 mov	 ecx, DWORD PTR tv74[ebp]
  00ea6	83 e9 01	 sub	 ecx, 1
  00ea9	89 4d f4	 mov	 DWORD PTR tv74[ebp], ecx
  00eac	81 7d f4 fe 00
	00 00		 cmp	 DWORD PTR tv74[ebp], 254 ; 000000feH
  00eb3	77 2d		 ja	 SHORT $L198539
  00eb5	8b 55 f4	 mov	 edx, DWORD PTR tv74[ebp]
  00eb8	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $L200041[edx]
  00ebf	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L200042[eax*4]
$L198542:

; 705  : 		{
; 706  : 		case 0x01:
; 707  : 		// plain text extension
; 708  : 			return BLOCK_PLAINTEXT;

  00ec6	b8 04 00 00 00	 mov	 eax, 4
  00ecb	eb 27		 jmp	 SHORT $L198532
$L198543:

; 709  : 			break;
; 710  : 
; 711  : 		case 0xF9:
; 712  : 		// graphic control extension
; 713  : 			return BLOCK_CONTROLEXT;

  00ecd	b8 03 00 00 00	 mov	 eax, 3
  00ed2	eb 20		 jmp	 SHORT $L198532
$L198544:

; 714  : 			break;
; 715  : 
; 716  : 		case 0xFE:
; 717  : 		// comment extension
; 718  : 			return BLOCK_COMMEXT;

  00ed4	b8 02 00 00 00	 mov	 eax, 2
  00ed9	eb 19		 jmp	 SHORT $L198532
$L198545:

; 719  : 			break;
; 720  : 
; 721  : 		case 0xFF:
; 722  : 		// application extension
; 723  : 			return BLOCK_APPEXT;

  00edb	b8 01 00 00 00	 mov	 eax, 1
  00ee0	eb 12		 jmp	 SHORT $L198532
$L198539:

; 724  : 			break;
; 725  : 		};
; 726  : 		break;

  00ee2	eb 0e		 jmp	 SHORT $L198534
$L198546:

; 727  : 	
; 728  : 	case 0x3B:
; 729  : 	// trailer
; 730  : 		return BLOCK_TRAILER;

  00ee4	b8 06 00 00 00	 mov	 eax, 6
  00ee9	eb 09		 jmp	 SHORT $L198532
$L198547:

; 731  : 		break;
; 732  : 
; 733  : 	case 0x2C:
; 734  : 	// image data
; 735  : 		return BLOCK_IMAGE;

  00eeb	b8 05 00 00 00	 mov	 eax, 5
  00ef0	eb 02		 jmp	 SHORT $L198532
$L198534:

; 736  : 		break;
; 737  : 	};
; 738  : 
; 739  : 	return BLOCK_UNKNOWN;

  00ef2	33 c0		 xor	 eax, eax
$L198532:

; 740  : }

  00ef4	8b e5		 mov	 esp, ebp
  00ef6	5d		 pop	 ebp
  00ef7	c3		 ret	 0
$L200042:
  00ef8	00 00 00 00	 DD	 $L198542
  00efc	00 00 00 00	 DD	 $L198543
  00f00	00 00 00 00	 DD	 $L198544
  00f04	00 00 00 00	 DD	 $L198545
  00f08	00 00 00 00	 DD	 $L198539
$L200041:
  00f0c	00		 DB	 0
  00f0d	04		 DB	 4
  00f0e	04		 DB	 4
  00f0f	04		 DB	 4
  00f10	04		 DB	 4
  00f11	04		 DB	 4
  00f12	04		 DB	 4
  00f13	04		 DB	 4
  00f14	04		 DB	 4
  00f15	04		 DB	 4
  00f16	04		 DB	 4
  00f17	04		 DB	 4
  00f18	04		 DB	 4
  00f19	04		 DB	 4
  00f1a	04		 DB	 4
  00f1b	04		 DB	 4
  00f1c	04		 DB	 4
  00f1d	04		 DB	 4
  00f1e	04		 DB	 4
  00f1f	04		 DB	 4
  00f20	04		 DB	 4
  00f21	04		 DB	 4
  00f22	04		 DB	 4
  00f23	04		 DB	 4
  00f24	04		 DB	 4
  00f25	04		 DB	 4
  00f26	04		 DB	 4
  00f27	04		 DB	 4
  00f28	04		 DB	 4
  00f29	04		 DB	 4
  00f2a	04		 DB	 4
  00f2b	04		 DB	 4
  00f2c	04		 DB	 4
  00f2d	04		 DB	 4
  00f2e	04		 DB	 4
  00f2f	04		 DB	 4
  00f30	04		 DB	 4
  00f31	04		 DB	 4
  00f32	04		 DB	 4
  00f33	04		 DB	 4
  00f34	04		 DB	 4
  00f35	04		 DB	 4
  00f36	04		 DB	 4
  00f37	04		 DB	 4
  00f38	04		 DB	 4
  00f39	04		 DB	 4
  00f3a	04		 DB	 4
  00f3b	04		 DB	 4
  00f3c	04		 DB	 4
  00f3d	04		 DB	 4
  00f3e	04		 DB	 4
  00f3f	04		 DB	 4
  00f40	04		 DB	 4
  00f41	04		 DB	 4
  00f42	04		 DB	 4
  00f43	04		 DB	 4
  00f44	04		 DB	 4
  00f45	04		 DB	 4
  00f46	04		 DB	 4
  00f47	04		 DB	 4
  00f48	04		 DB	 4
  00f49	04		 DB	 4
  00f4a	04		 DB	 4
  00f4b	04		 DB	 4
  00f4c	04		 DB	 4
  00f4d	04		 DB	 4
  00f4e	04		 DB	 4
  00f4f	04		 DB	 4
  00f50	04		 DB	 4
  00f51	04		 DB	 4
  00f52	04		 DB	 4
  00f53	04		 DB	 4
  00f54	04		 DB	 4
  00f55	04		 DB	 4
  00f56	04		 DB	 4
  00f57	04		 DB	 4
  00f58	04		 DB	 4
  00f59	04		 DB	 4
  00f5a	04		 DB	 4
  00f5b	04		 DB	 4
  00f5c	04		 DB	 4
  00f5d	04		 DB	 4
  00f5e	04		 DB	 4
  00f5f	04		 DB	 4
  00f60	04		 DB	 4
  00f61	04		 DB	 4
  00f62	04		 DB	 4
  00f63	04		 DB	 4
  00f64	04		 DB	 4
  00f65	04		 DB	 4
  00f66	04		 DB	 4
  00f67	04		 DB	 4
  00f68	04		 DB	 4
  00f69	04		 DB	 4
  00f6a	04		 DB	 4
  00f6b	04		 DB	 4
  00f6c	04		 DB	 4
  00f6d	04		 DB	 4
  00f6e	04		 DB	 4
  00f6f	04		 DB	 4
  00f70	04		 DB	 4
  00f71	04		 DB	 4
  00f72	04		 DB	 4
  00f73	04		 DB	 4
  00f74	04		 DB	 4
  00f75	04		 DB	 4
  00f76	04		 DB	 4
  00f77	04		 DB	 4
  00f78	04		 DB	 4
  00f79	04		 DB	 4
  00f7a	04		 DB	 4
  00f7b	04		 DB	 4
  00f7c	04		 DB	 4
  00f7d	04		 DB	 4
  00f7e	04		 DB	 4
  00f7f	04		 DB	 4
  00f80	04		 DB	 4
  00f81	04		 DB	 4
  00f82	04		 DB	 4
  00f83	04		 DB	 4
  00f84	04		 DB	 4
  00f85	04		 DB	 4
  00f86	04		 DB	 4
  00f87	04		 DB	 4
  00f88	04		 DB	 4
  00f89	04		 DB	 4
  00f8a	04		 DB	 4
  00f8b	04		 DB	 4
  00f8c	04		 DB	 4
  00f8d	04		 DB	 4
  00f8e	04		 DB	 4
  00f8f	04		 DB	 4
  00f90	04		 DB	 4
  00f91	04		 DB	 4
  00f92	04		 DB	 4
  00f93	04		 DB	 4
  00f94	04		 DB	 4
  00f95	04		 DB	 4
  00f96	04		 DB	 4
  00f97	04		 DB	 4
  00f98	04		 DB	 4
  00f99	04		 DB	 4
  00f9a	04		 DB	 4
  00f9b	04		 DB	 4
  00f9c	04		 DB	 4
  00f9d	04		 DB	 4
  00f9e	04		 DB	 4
  00f9f	04		 DB	 4
  00fa0	04		 DB	 4
  00fa1	04		 DB	 4
  00fa2	04		 DB	 4
  00fa3	04		 DB	 4
  00fa4	04		 DB	 4
  00fa5	04		 DB	 4
  00fa6	04		 DB	 4
  00fa7	04		 DB	 4
  00fa8	04		 DB	 4
  00fa9	04		 DB	 4
  00faa	04		 DB	 4
  00fab	04		 DB	 4
  00fac	04		 DB	 4
  00fad	04		 DB	 4
  00fae	04		 DB	 4
  00faf	04		 DB	 4
  00fb0	04		 DB	 4
  00fb1	04		 DB	 4
  00fb2	04		 DB	 4
  00fb3	04		 DB	 4
  00fb4	04		 DB	 4
  00fb5	04		 DB	 4
  00fb6	04		 DB	 4
  00fb7	04		 DB	 4
  00fb8	04		 DB	 4
  00fb9	04		 DB	 4
  00fba	04		 DB	 4
  00fbb	04		 DB	 4
  00fbc	04		 DB	 4
  00fbd	04		 DB	 4
  00fbe	04		 DB	 4
  00fbf	04		 DB	 4
  00fc0	04		 DB	 4
  00fc1	04		 DB	 4
  00fc2	04		 DB	 4
  00fc3	04		 DB	 4
  00fc4	04		 DB	 4
  00fc5	04		 DB	 4
  00fc6	04		 DB	 4
  00fc7	04		 DB	 4
  00fc8	04		 DB	 4
  00fc9	04		 DB	 4
  00fca	04		 DB	 4
  00fcb	04		 DB	 4
  00fcc	04		 DB	 4
  00fcd	04		 DB	 4
  00fce	04		 DB	 4
  00fcf	04		 DB	 4
  00fd0	04		 DB	 4
  00fd1	04		 DB	 4
  00fd2	04		 DB	 4
  00fd3	04		 DB	 4
  00fd4	04		 DB	 4
  00fd5	04		 DB	 4
  00fd6	04		 DB	 4
  00fd7	04		 DB	 4
  00fd8	04		 DB	 4
  00fd9	04		 DB	 4
  00fda	04		 DB	 4
  00fdb	04		 DB	 4
  00fdc	04		 DB	 4
  00fdd	04		 DB	 4
  00fde	04		 DB	 4
  00fdf	04		 DB	 4
  00fe0	04		 DB	 4
  00fe1	04		 DB	 4
  00fe2	04		 DB	 4
  00fe3	04		 DB	 4
  00fe4	04		 DB	 4
  00fe5	04		 DB	 4
  00fe6	04		 DB	 4
  00fe7	04		 DB	 4
  00fe8	04		 DB	 4
  00fe9	04		 DB	 4
  00fea	04		 DB	 4
  00feb	04		 DB	 4
  00fec	04		 DB	 4
  00fed	04		 DB	 4
  00fee	04		 DB	 4
  00fef	04		 DB	 4
  00ff0	04		 DB	 4
  00ff1	04		 DB	 4
  00ff2	04		 DB	 4
  00ff3	04		 DB	 4
  00ff4	04		 DB	 4
  00ff5	04		 DB	 4
  00ff6	04		 DB	 4
  00ff7	04		 DB	 4
  00ff8	04		 DB	 4
  00ff9	04		 DB	 4
  00ffa	04		 DB	 4
  00ffb	04		 DB	 4
  00ffc	04		 DB	 4
  00ffd	04		 DB	 4
  00ffe	04		 DB	 4
  00fff	04		 DB	 4
  01000	04		 DB	 4
  01001	04		 DB	 4
  01002	04		 DB	 4
  01003	04		 DB	 4
  01004	01		 DB	 1
  01005	04		 DB	 4
  01006	04		 DB	 4
  01007	04		 DB	 4
  01008	04		 DB	 4
  01009	02		 DB	 2
  0100a	03		 DB	 3
?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ENDP ; CPictureEx::GetNextBlock
; Function compile flags: /Odt
_this$ = -8						; size = 4
_nLen$ = -4						; size = 4
?SkipNextBlock@CPictureEx@@IAEHXZ PROC NEAR		; CPictureEx::SkipNextBlock
; _this$ = ecx

; 743  : {

  01010	55		 push	 ebp
  01011	8b ec		 mov	 ebp, esp
  01013	83 ec 08	 sub	 esp, 8
  01016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 	if (!m_pRawData) return FALSE;

  01019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0101c	83 78 78 00	 cmp	 DWORD PTR [eax+120], 0
  01020	75 04		 jne	 SHORT $L198551
  01022	33 c0		 xor	 eax, eax
  01024	eb 3a		 jmp	 SHORT $L198550
$L198551:

; 745  : 
; 746  : 	int nLen = GetNextBlockLen();

  01026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01029	e8 00 00 00 00	 call	 ?GetNextBlockLen@CPictureEx@@IBEHXZ ; CPictureEx::GetNextBlockLen
  0102e	89 45 fc	 mov	 DWORD PTR _nLen$[ebp], eax

; 747  : 	if ((nLen <= 0) || ((m_nCurrOffset+nLen) > m_nDataSize))

  01031	83 7d fc 00	 cmp	 DWORD PTR _nLen$[ebp], 0
  01035	7e 11		 jle	 SHORT $L198554
  01037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0103a	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0103d	03 55 fc	 add	 edx, DWORD PTR _nLen$[ebp]
  01040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01043	3b 50 30	 cmp	 edx, DWORD PTR [eax+48]
  01046	76 04		 jbe	 SHORT $L198553
$L198554:

; 748  : 		return FALSE;

  01048	33 c0		 xor	 eax, eax
  0104a	eb 14		 jmp	 SHORT $L198550
$L198553:

; 749  : 
; 750  : 	m_nCurrOffset += nLen;

  0104c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0104f	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  01052	03 55 fc	 add	 edx, DWORD PTR _nLen$[ebp]
  01055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01058	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 751  : 	return TRUE;

  0105b	b8 01 00 00 00	 mov	 eax, 1
$L198550:

; 752  : }

  01060	8b e5		 mov	 esp, ebp
  01062	5d		 pop	 ebp
  01063	c3		 ret	 0
?SkipNextBlock@CPictureEx@@IAEHXZ ENDP			; CPictureEx::SkipNextBlock
_TEXT	ENDS
PUBLIC	?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z ; CPictureEx::TGIFImageDescriptor::GetPackedValue
; Function compile flags: /Odt
_TEXT	SEGMENT
tv66 = -28						; size = 4
_this$ = -24						; size = 4
_nLCTSize$198583 = -20					; size = 4
_nTmp$198585 = -16					; size = 4
_pIDescr$198581 = -12					; size = 4
_nBlock$ = -8						; size = 4
_nTmp$ = -4						; size = 4
?GetNextBlockLen@CPictureEx@@IBEHXZ PROC NEAR		; CPictureEx::GetNextBlockLen
; _this$ = ecx

; 755  : {

  01070	55		 push	 ebp
  01071	8b ec		 mov	 ebp, esp
  01073	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01076	56		 push	 esi
  01077	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 756  : 	GIFBlockTypes nBlock = GetNextBlock();

  0107a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0107d	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  01082	89 45 f8	 mov	 DWORD PTR _nBlock$[ebp], eax

; 757  : 
; 758  : 	int nTmp;
; 759  : 
; 760  : 	switch(nBlock)

  01085	8b 45 f8	 mov	 eax, DWORD PTR _nBlock$[ebp]
  01088	89 45 e4	 mov	 DWORD PTR tv66[ebp], eax
  0108b	83 7d e4 06	 cmp	 DWORD PTR tv66[ebp], 6
  0108f	0f 87 06 01 00
	00		 ja	 $L198561
  01095	8b 4d e4	 mov	 ecx, DWORD PTR tv66[ebp]
  01098	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L200045[ecx*4]
$L198564:

; 761  : 	{
; 762  : 	case BLOCK_UNKNOWN:
; 763  : 		return -1;

  0109f	83 c8 ff	 or	 eax, -1
  010a2	e9 f6 00 00 00	 jmp	 $L198557
$L198565:

; 764  : 		break;
; 765  : 
; 766  : 	case BLOCK_TRAILER:
; 767  : 		return 1;

  010a7	b8 01 00 00 00	 mov	 eax, 1
  010ac	e9 ec 00 00 00	 jmp	 $L198557
$L198566:

; 768  : 		break;
; 769  : 
; 770  : 	case BLOCK_APPEXT:
; 771  : 		nTmp = GetSubBlocksLen(m_nCurrOffset+sizeof(TGIFAppExtension));

  010b1	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  010b4	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  010b7	83 c0 0e	 add	 eax, 14			; 0000000eH
  010ba	50		 push	 eax
  010bb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  010be	e8 00 00 00 00	 call	 ?GetSubBlocksLen@CPictureEx@@IBEII@Z ; CPictureEx::GetSubBlocksLen
  010c3	89 45 fc	 mov	 DWORD PTR _nTmp$[ebp], eax

; 772  : 		if (nTmp > 0)

  010c6	83 7d fc 00	 cmp	 DWORD PTR _nTmp$[ebp], 0
  010ca	7e 0b		 jle	 SHORT $L198568

; 773  : 			return sizeof(TGIFAppExtension)+nTmp;

  010cc	8b 45 fc	 mov	 eax, DWORD PTR _nTmp$[ebp]
  010cf	83 c0 0e	 add	 eax, 14			; 0000000eH
  010d2	e9 c6 00 00 00	 jmp	 $L198557
$L198568:

; 774  : 		break;

  010d7	e9 bf 00 00 00	 jmp	 $L198561
$L198570:

; 775  : 
; 776  : 	case BLOCK_COMMEXT:
; 777  : 		nTmp = GetSubBlocksLen(m_nCurrOffset+sizeof(TGIFCommentExt));

  010dc	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  010df	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  010e2	83 c2 02	 add	 edx, 2
  010e5	52		 push	 edx
  010e6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  010e9	e8 00 00 00 00	 call	 ?GetSubBlocksLen@CPictureEx@@IBEII@Z ; CPictureEx::GetSubBlocksLen
  010ee	89 45 fc	 mov	 DWORD PTR _nTmp$[ebp], eax

; 778  : 		if (nTmp > 0)

  010f1	83 7d fc 00	 cmp	 DWORD PTR _nTmp$[ebp], 0
  010f5	7e 0b		 jle	 SHORT $L198572

; 779  : 			return sizeof(TGIFCommentExt)+nTmp;

  010f7	8b 45 fc	 mov	 eax, DWORD PTR _nTmp$[ebp]
  010fa	83 c0 02	 add	 eax, 2
  010fd	e9 9b 00 00 00	 jmp	 $L198557
$L198572:

; 780  : 		break;

  01102	e9 94 00 00 00	 jmp	 $L198561
$L198574:

; 781  : 
; 782  : 	case BLOCK_CONTROLEXT:
; 783  : 		return sizeof(TGIFControlExt);

  01107	b8 08 00 00 00	 mov	 eax, 8
  0110c	e9 8c 00 00 00	 jmp	 $L198557
$L198576:

; 784  : 		break;
; 785  : 
; 786  : 	case BLOCK_PLAINTEXT:
; 787  : 		nTmp = GetSubBlocksLen(m_nCurrOffset+sizeof(TGIFPlainTextExt));

  01111	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  01114	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01117	83 c1 0f	 add	 ecx, 15			; 0000000fH
  0111a	51		 push	 ecx
  0111b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0111e	e8 00 00 00 00	 call	 ?GetSubBlocksLen@CPictureEx@@IBEII@Z ; CPictureEx::GetSubBlocksLen
  01123	89 45 fc	 mov	 DWORD PTR _nTmp$[ebp], eax

; 788  : 		if (nTmp > 0)

  01126	83 7d fc 00	 cmp	 DWORD PTR _nTmp$[ebp], 0
  0112a	7e 08		 jle	 SHORT $L198578

; 789  : 			return sizeof(TGIFPlainTextExt)+nTmp;

  0112c	8b 45 fc	 mov	 eax, DWORD PTR _nTmp$[ebp]
  0112f	83 c0 0f	 add	 eax, 15			; 0000000fH
  01132	eb 69		 jmp	 SHORT $L198557
$L198578:

; 790  : 		break;

  01134	eb 65		 jmp	 SHORT $L198561
$L198580:

; 791  : 
; 792  : 	case BLOCK_IMAGE:
; 793  : 		TGIFImageDescriptor *pIDescr = 
; 794  : 			reinterpret_cast<TGIFImageDescriptor *> (&m_pRawData[m_nCurrOffset]);

  01136	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  01139	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  0113c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0113f	03 41 34	 add	 eax, DWORD PTR [ecx+52]
  01142	89 45 f4	 mov	 DWORD PTR _pIDescr$198581[ebp], eax

; 795  : 		int nLCTSize = (int)
; 796  : 			(pIDescr->GetPackedValue(ID_PACKED_LOCALCT)*3*
; 797  : 			(1 << (pIDescr->GetPackedValue(ID_PACKED_LOCALCTSIZE)+1)));

  01145	6a 00		 push	 0
  01147	8b 4d f4	 mov	 ecx, DWORD PTR _pIDescr$198581[ebp]
  0114a	e8 00 00 00 00	 call	 ?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z ; CPictureEx::TGIFImageDescriptor::GetPackedValue
  0114f	8b f0		 mov	 esi, eax
  01151	6b f6 03	 imul	 esi, 3
  01154	6a 03		 push	 3
  01156	8b 4d f4	 mov	 ecx, DWORD PTR _pIDescr$198581[ebp]
  01159	e8 00 00 00 00	 call	 ?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z ; CPictureEx::TGIFImageDescriptor::GetPackedValue
  0115e	83 c0 01	 add	 eax, 1
  01161	ba 01 00 00 00	 mov	 edx, 1
  01166	8b c8		 mov	 ecx, eax
  01168	d3 e2		 shl	 edx, cl
  0116a	0f af f2	 imul	 esi, edx
  0116d	89 75 ec	 mov	 DWORD PTR _nLCTSize$198583[ebp], esi

; 798  : 
; 799  : 		int nTmp = GetSubBlocksLen(m_nCurrOffset+
; 800  : 			sizeof(TGIFImageDescriptor) + nLCTSize + 1);

  01170	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  01173	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01176	8b 55 ec	 mov	 edx, DWORD PTR _nLCTSize$198583[ebp]
  01179	8d 44 11 0b	 lea	 eax, DWORD PTR [ecx+edx+11]
  0117d	50		 push	 eax
  0117e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  01181	e8 00 00 00 00	 call	 ?GetSubBlocksLen@CPictureEx@@IBEII@Z ; CPictureEx::GetSubBlocksLen
  01186	89 45 f0	 mov	 DWORD PTR _nTmp$198585[ebp], eax

; 801  : 		if (nTmp > 0)

  01189	83 7d f0 00	 cmp	 DWORD PTR _nTmp$198585[ebp], 0
  0118d	7e 0c		 jle	 SHORT $L198561

; 802  : 			return sizeof(TGIFImageDescriptor) + nLCTSize + 1 + nTmp;

  0118f	8b 4d f0	 mov	 ecx, DWORD PTR _nTmp$198585[ebp]
  01192	8b 55 ec	 mov	 edx, DWORD PTR _nLCTSize$198583[ebp]
  01195	8d 44 0a 0b	 lea	 eax, DWORD PTR [edx+ecx+11]
  01199	eb 02		 jmp	 SHORT $L198557
$L198561:

; 803  : 		break;
; 804  : 	};
; 805  : 
; 806  : 	return 0;

  0119b	33 c0		 xor	 eax, eax
$L198557:

; 807  : }

  0119d	5e		 pop	 esi
  0119e	8b e5		 mov	 esp, ebp
  011a0	5d		 pop	 ebp
  011a1	c3		 ret	 0
$L200045:
  011a2	00 00 00 00	 DD	 $L198564
  011a6	00 00 00 00	 DD	 $L198566
  011aa	00 00 00 00	 DD	 $L198570
  011ae	00 00 00 00	 DD	 $L198574
  011b2	00 00 00 00	 DD	 $L198576
  011b6	00 00 00 00	 DD	 $L198580
  011ba	00 00 00 00	 DD	 $L198565
?GetNextBlockLen@CPictureEx@@IBEHXZ ENDP		; CPictureEx::GetNextBlockLen
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z
_TEXT	SEGMENT
tv66 = -12						; size = 4
_this$ = -8						; size = 4
_nRet$ = -4						; size = 4
_Value$ = 8						; size = 4
?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z PROC NEAR ; CPictureEx::TGIFImageDescriptor::GetPackedValue, COMDAT
; _this$ = ecx

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 143  : 	int nRet = (int)m_cPacked;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  00010	89 4d fc	 mov	 DWORD PTR _nRet$[ebp], ecx

; 144  : 
; 145  : 	switch (Value)

  00013	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  00016	89 55 f4	 mov	 DWORD PTR tv66[ebp], edx
  00019	83 7d f4 03	 cmp	 DWORD PTR tv66[ebp], 3
  0001d	77 3a		 ja	 SHORT $L198188
  0001f	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  00022	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L200047[eax*4]
$L198191:

; 146  : 	{
; 147  : 	case ID_PACKED_LOCALCT:
; 148  : 		nRet >>= 7;

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _nRet$[ebp]
  0002c	c1 f9 07	 sar	 ecx, 7
  0002f	89 4d fc	 mov	 DWORD PTR _nRet$[ebp], ecx

; 149  : 		break;

  00032	eb 25		 jmp	 SHORT $L198188
$L198192:

; 150  : 
; 151  : 	case ID_PACKED_INTERLACE:
; 152  : 		nRet = ((nRet & 0x40) >> 6);

  00034	8b 55 fc	 mov	 edx, DWORD PTR _nRet$[ebp]
  00037	83 e2 40	 and	 edx, 64			; 00000040H
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	89 55 fc	 mov	 DWORD PTR _nRet$[ebp], edx

; 153  : 		break;

  00040	eb 17		 jmp	 SHORT $L198188
$L198193:

; 154  : 
; 155  : 	case ID_PACKED_SORT:
; 156  : 		nRet = (nRet & 0x20) >> 5;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _nRet$[ebp]
  00045	83 e0 20	 and	 eax, 32			; 00000020H
  00048	c1 f8 05	 sar	 eax, 5
  0004b	89 45 fc	 mov	 DWORD PTR _nRet$[ebp], eax

; 157  : 		break;

  0004e	eb 09		 jmp	 SHORT $L198188
$L198194:

; 158  : 
; 159  : 	case ID_PACKED_LOCALCTSIZE:
; 160  : 		nRet &= 7;

  00050	8b 4d fc	 mov	 ecx, DWORD PTR _nRet$[ebp]
  00053	83 e1 07	 and	 ecx, 7
  00056	89 4d fc	 mov	 DWORD PTR _nRet$[ebp], ecx
$L198188:

; 161  : 		break;
; 162  : 	};
; 163  : 
; 164  : 	return nRet;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _nRet$[ebp]

; 165  : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
$L200047:
  00062	00 00 00 00	 DD	 $L198191
  00066	00 00 00 00	 DD	 $L198192
  0006a	00 00 00 00	 DD	 $L198193
  0006e	00 00 00 00	 DD	 $L198194
?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z ENDP ; CPictureEx::TGIFImageDescriptor::GetPackedValue
_TEXT	ENDS
PUBLIC	?ThreadAnimation@CPictureEx@@IAEXXZ		; CPictureEx::ThreadAnimation
; Function compile flags: /Odt
_TEXT	SEGMENT
_pPic$ = -4						; size = 4
_pParam$ = 8						; size = 4
?_ThreadAnimation@CPictureEx@@KGIPAX@Z PROC NEAR	; CPictureEx::_ThreadAnimation

; 810  : {

  011c0	55		 push	 ebp
  011c1	8b ec		 mov	 ebp, esp
  011c3	51		 push	 ecx

; 811  : 	ASSERT(pParam);
; 812  : 	CPictureEx *pPic = reinterpret_cast<CPictureEx *> (pParam);

  011c4	8b 45 08	 mov	 eax, DWORD PTR _pParam$[ebp]
  011c7	89 45 fc	 mov	 DWORD PTR _pPic$[ebp], eax

; 813  : 
; 814  : 	pPic->m_bIsPlaying = TRUE;

  011ca	8b 4d fc	 mov	 ecx, DWORD PTR _pPic$[ebp]
  011cd	c7 41 40 01 00
	00 00		 mov	 DWORD PTR [ecx+64], 1

; 815  : 	pPic->ThreadAnimation();

  011d4	8b 4d fc	 mov	 ecx, DWORD PTR _pPic$[ebp]
  011d7	e8 00 00 00 00	 call	 ?ThreadAnimation@CPictureEx@@IAEXXZ ; CPictureEx::ThreadAnimation

; 816  : 	pPic->m_bIsPlaying = FALSE;

  011dc	8b 55 fc	 mov	 edx, DWORD PTR _pPic$[ebp]
  011df	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 817  : 
; 818  : 	// this thread has finished its work so we close the handle
; 819  : 	CloseHandle(pPic->m_hThread); 

  011e6	8b 45 fc	 mov	 eax, DWORD PTR _pPic$[ebp]
  011e9	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  011ec	51		 push	 ecx
  011ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 820  : 	// and init the handle to zero (so that Stop() doesn't Wait on it)
; 821  : 	pPic->m_hThread = 0;

  011f3	8b 55 fc	 mov	 edx, DWORD PTR _pPic$[ebp]
  011f6	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 822  : 	return 0;

  011fd	33 c0		 xor	 eax, eax

; 823  : }

  011ff	8b e5		 mov	 esp, ebp
  01201	5d		 pop	 ebp
  01202	c2 04 00	 ret	 4
?_ThreadAnimation@CPictureEx@@KGIPAX@Z ENDP		; CPictureEx::_ThreadAnimation
_TEXT	ENDS
PUBLIC	?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
PUBLIC	??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
EXTRN	__imp__BitBlt@36:NEAR
EXTRN	__imp__CreateCompatibleBitmap@12:NEAR
EXTRN	__imp__CreateCompatibleDC@4:NEAR
EXTRN	__imp__CreateSolidBrush@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	__imp__FillRect@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv331 = -84						; size = 4
tv320 = -80						; size = 4
tv309 = -76						; size = 4
_this$ = -72						; size = 4
_rect$198631 = -68					; size = 16
_hBrush$198629 = -52					; size = 4
_rect$198624 = -48					; size = 16
_hBrush$198622 = -32					; size = 4
_hmHeight$198614 = -28					; size = 4
_hmWidth$198613 = -24					; size = 4
_rect$198601 = -20					; size = 16
_hBrush$198599 = -4					; size = 4
?ThreadAnimation@CPictureEx@@IAEXXZ PROC NEAR		; CPictureEx::ThreadAnimation
; _this$ = ecx

; 826  : {

  01210	55		 push	 ebp
  01211	8b ec		 mov	 ebp, esp
  01213	83 ec 54	 sub	 esp, 84			; 00000054H
  01216	56		 push	 esi
  01217	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 827  : 	// first, restore background (for stop/draw support)
; 828  : 	// disposal method #2
; 829  : 	if (m_arrFrames[m_nCurrFrame].m_nDisposal == 2)

  0121a	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0121d	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01220	51		 push	 ecx
  01221	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01224	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0122a	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0122f	83 78 18 02	 cmp	 DWORD PTR [eax+24], 2
  01233	0f 85 de 00 00
	00		 jne	 $L198598

; 830  : 	{
; 831  : 		HBRUSH hBrush = CreateSolidBrush(m_clrBackground);

  01239	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  0123c	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0123f	50		 push	 eax
  01240	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  01246	89 45 fc	 mov	 DWORD PTR _hBrush$198599[ebp], eax

; 832  : 		if (hBrush)

  01249	83 7d fc 00	 cmp	 DWORD PTR _hBrush$198599[ebp], 0
  0124d	0f 84 bf 00 00
	00		 je	 $L198600

; 833  : 		{
; 834  : 			RECT rect = {
; 835  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cx,

  01253	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01256	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01259	52		 push	 edx
  0125a	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0125d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01263	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01268	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0126b	89 45 ec	 mov	 DWORD PTR _rect$198601[ebp], eax

; 836  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cy,

  0126e	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01271	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01274	52		 push	 edx
  01275	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01278	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0127e	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01283	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  01286	89 45 f0	 mov	 DWORD PTR _rect$198601[ebp+4], eax

; 837  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cx + m_arrFrames[m_nCurrFrame].m_frameSize.cx,

  01289	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0128c	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0128f	52		 push	 edx
  01290	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01293	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01299	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0129e	8b f0		 mov	 esi, eax
  012a0	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  012a3	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  012a6	51		 push	 ecx
  012a7	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  012aa	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  012b0	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  012b5	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  012b8	03 50 04	 add	 edx, DWORD PTR [eax+4]
  012bb	89 55 f4	 mov	 DWORD PTR _rect$198601[ebp+8], edx

; 838  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cy + m_arrFrames[m_nCurrFrame].m_frameSize.cy };

  012be	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  012c1	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  012c4	51		 push	 ecx
  012c5	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  012c8	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  012ce	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  012d3	8b f0		 mov	 esi, eax
  012d5	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  012d8	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  012db	50		 push	 eax
  012dc	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  012df	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  012e5	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  012ea	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  012ed	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  012f0	89 4d f8	 mov	 DWORD PTR _rect$198601[ebp+12], ecx

; 839  : 			FillRect(m_hMemDC,&rect,hBrush);

  012f3	8b 55 fc	 mov	 edx, DWORD PTR _hBrush$198599[ebp]
  012f6	52		 push	 edx
  012f7	8d 45 ec	 lea	 eax, DWORD PTR _rect$198601[ebp]
  012fa	50		 push	 eax
  012fb	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  012fe	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  01301	52		 push	 edx
  01302	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 840  : 			DeleteObject(hBrush);

  01308	8b 45 fc	 mov	 eax, DWORD PTR _hBrush$198599[ebp]
  0130b	50		 push	 eax
  0130c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$L198600:

; 841  : 		};
; 842  : 	} 
; 843  : 	else

  01312	e9 ef 00 00 00	 jmp	 $L198606
$L198598:

; 844  : 		// disposal method #3
; 845  : 		if (m_hDispMemDC && (m_arrFrames[m_nCurrFrame].m_nDisposal == 3) )

  01317	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0131a	83 79 50 00	 cmp	 DWORD PTR [ecx+80], 0
  0131e	0f 84 e2 00 00
	00		 je	 $L198606
  01324	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  01327	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0132a	50		 push	 eax
  0132b	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0132e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01334	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01339	83 78 18 03	 cmp	 DWORD PTR [eax+24], 3
  0133d	0f 85 c3 00 00
	00		 jne	 $L198606

; 846  : 		{
; 847  : 			// put it back
; 848  : 			BitBlt(m_hMemDC,
; 849  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cx,
; 850  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cy,
; 851  : 				m_arrFrames[m_nCurrFrame].m_frameSize.cx,
; 852  : 				m_arrFrames[m_nCurrFrame].m_frameSize.cy,
; 853  : 				m_hDispMemDC,0,0, SRCCOPY);

  01343	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01348	6a 00		 push	 0
  0134a	6a 00		 push	 0
  0134c	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0134f	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  01352	52		 push	 edx
  01353	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01356	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01359	51		 push	 ecx
  0135a	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0135d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01363	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01368	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0136b	52		 push	 edx
  0136c	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0136f	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01372	51		 push	 ecx
  01373	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01376	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0137c	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01381	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01384	52		 push	 edx
  01385	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01388	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0138b	51		 push	 ecx
  0138c	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0138f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01395	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0139a	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0139d	52		 push	 edx
  0139e	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  013a1	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  013a4	51		 push	 ecx
  013a5	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  013a8	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  013ae	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  013b3	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  013b6	52		 push	 edx
  013b7	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  013ba	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  013bd	51		 push	 ecx
  013be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 854  : 			// init variables
; 855  : 			SelectObject(m_hDispMemDC,m_hDispOldBM);

  013c4	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  013c7	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  013ca	50		 push	 eax
  013cb	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  013ce	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  013d1	52		 push	 edx
  013d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 856  : 			DeleteDC(m_hDispMemDC); m_hDispMemDC = NULL;

  013d8	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  013db	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  013de	51		 push	 ecx
  013df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  013e5	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  013e8	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], 0

; 857  : 			DeleteObject(m_hDispMemBM); m_hDispMemBM = NULL;

  013ef	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  013f2	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  013f5	51		 push	 ecx
  013f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  013fc	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  013ff	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], 0
$L198606:

; 858  : 		};
; 859  : 
; 860  : 	while (!m_bExitThread)

  01406	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01409	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  0140d	0f 85 35 05 00
	00		 jne	 $L198597

; 861  : 	{
; 862  : 		if (m_arrFrames[m_nCurrFrame].m_pPicture)

  01413	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01416	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01419	52		 push	 edx
  0141a	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0141d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01423	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01428	83 38 00	 cmp	 DWORD PTR [eax], 0
  0142b	0f 84 8e 04 00
	00		 je	 $L198608

; 863  : 		{
; 864  : 		///////////////////////////////////////////////////////
; 865  : 		// Before rendering a frame we should take care of what's 
; 866  : 		// behind that frame. TFrame::m_nDisposal will be our guide:
; 867  : 		//   0 - no disposal specified (do nothing)
; 868  : 		//   1 - do not dispose (again, do nothing)
; 869  : 		//   2 - restore to background color (m_clrBackground)
; 870  : 		//   3 - restore to previous
; 871  : 
; 872  : 			//////// disposal method #3
; 873  : 			if (m_arrFrames[m_nCurrFrame].m_nDisposal == 3)

  01431	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01434	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01437	51		 push	 ecx
  01438	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0143b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01441	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01446	83 78 18 03	 cmp	 DWORD PTR [eax+24], 3
  0144a	0f 85 0d 01 00
	00		 jne	 $L198609

; 874  : 			{
; 875  : 				// prepare a memory DC and store the background in it
; 876  : 				m_hDispMemDC = CreateCompatibleDC(m_hMemDC);

  01450	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  01453	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  01456	50		 push	 eax
  01457	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  0145d	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01460	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 877  : 				m_hDispMemBM = CreateCompatibleBitmap(m_hMemDC,
; 878  : 							m_arrFrames[m_nCurrFrame].m_frameSize.cx,
; 879  : 							m_arrFrames[m_nCurrFrame].m_frameSize.cy);

  01463	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  01466	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01469	50		 push	 eax
  0146a	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0146d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01473	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01478	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0147b	51		 push	 ecx
  0147c	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  0147f	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01482	50		 push	 eax
  01483	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01486	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0148c	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01491	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01494	51		 push	 ecx
  01495	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  01498	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  0149b	50		 push	 eax
  0149c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  014a2	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  014a5	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 880  : 				
; 881  : 				if (m_hDispMemDC && m_hDispMemBM)

  014a8	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  014ab	83 7a 50 00	 cmp	 DWORD PTR [edx+80], 0
  014af	0f 84 a8 00 00
	00		 je	 $L198609
  014b5	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  014b8	83 78 54 00	 cmp	 DWORD PTR [eax+84], 0
  014bc	0f 84 9b 00 00
	00		 je	 $L198609

; 882  : 				{
; 883  : 					m_hDispOldBM = reinterpret_cast<HBITMAP> (SelectObject(m_hDispMemDC,m_hDispMemBM));

  014c2	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  014c5	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  014c8	52		 push	 edx
  014c9	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  014cc	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  014cf	51		 push	 ecx
  014d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  014d6	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  014d9	89 42 58	 mov	 DWORD PTR [edx+88], eax

; 884  : 					BitBlt(m_hDispMemDC,0,0,
; 885  : 						m_arrFrames[m_nCurrFrame].m_frameSize.cx,
; 886  : 						m_arrFrames[m_nCurrFrame].m_frameSize.cy,
; 887  : 						m_hMemDC,
; 888  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cx,
; 889  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cy,
; 890  : 						SRCCOPY);

  014dc	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  014e1	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  014e4	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  014e7	51		 push	 ecx
  014e8	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  014eb	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  014f1	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  014f6	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  014f9	52		 push	 edx
  014fa	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  014fd	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01500	51		 push	 ecx
  01501	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01504	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0150a	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0150f	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01512	52		 push	 edx
  01513	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01516	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  01519	51		 push	 ecx
  0151a	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  0151d	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01520	50		 push	 eax
  01521	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01524	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0152a	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0152f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01532	51		 push	 ecx
  01533	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  01536	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01539	50		 push	 eax
  0153a	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0153d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01543	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01548	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0154b	51		 push	 ecx
  0154c	6a 00		 push	 0
  0154e	6a 00		 push	 0
  01550	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  01553	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  01556	50		 push	 eax
  01557	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
$L198609:

; 891  : 				};
; 892  : 			};
; 893  : 			///////////////////////
; 894  : 
; 895  : 			long hmWidth;
; 896  : 			long hmHeight;
; 897  : 			m_arrFrames[m_nCurrFrame].m_pPicture->get_Width(&hmWidth);

  0155d	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01560	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01563	52		 push	 edx
  01564	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01567	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0156d	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01572	8b 00		 mov	 eax, DWORD PTR [eax]
  01574	89 45 b4	 mov	 DWORD PTR tv309[ebp], eax
  01577	8d 4d e8	 lea	 ecx, DWORD PTR _hmWidth$198613[ebp]
  0157a	51		 push	 ecx
  0157b	8b 55 b4	 mov	 edx, DWORD PTR tv309[ebp]
  0157e	52		 push	 edx
  0157f	8b 45 b4	 mov	 eax, DWORD PTR tv309[ebp]
  01582	8b 08		 mov	 ecx, DWORD PTR [eax]
  01584	ff 51 18	 call	 DWORD PTR [ecx+24]

; 898  : 			m_arrFrames[m_nCurrFrame].m_pPicture->get_Height(&hmHeight);

  01587	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  0158a	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0158d	50		 push	 eax
  0158e	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01591	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01597	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0159c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0159e	89 4d b0	 mov	 DWORD PTR tv320[ebp], ecx
  015a1	8d 55 e4	 lea	 edx, DWORD PTR _hmHeight$198614[ebp]
  015a4	52		 push	 edx
  015a5	8b 45 b0	 mov	 eax, DWORD PTR tv320[ebp]
  015a8	50		 push	 eax
  015a9	8b 4d b0	 mov	 ecx, DWORD PTR tv320[ebp]
  015ac	8b 11		 mov	 edx, DWORD PTR [ecx]
  015ae	ff 52 1c	 call	 DWORD PTR [edx+28]

; 899  : 
; 900  : 			if (m_arrFrames[m_nCurrFrame].m_pPicture->Render(m_hMemDC, 
; 901  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cx, 
; 902  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cy, 
; 903  : 				m_arrFrames[m_nCurrFrame].m_frameSize.cx, 
; 904  : 				m_arrFrames[m_nCurrFrame].m_frameSize.cy, 
; 905  : 				0, hmHeight, hmWidth, -hmHeight, NULL) == S_OK)

  015b1	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  015b4	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  015b7	51		 push	 ecx
  015b8	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  015bb	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  015c1	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  015c6	8b 10		 mov	 edx, DWORD PTR [eax]
  015c8	89 55 ac	 mov	 DWORD PTR tv331[ebp], edx
  015cb	6a 00		 push	 0
  015cd	8b 45 e4	 mov	 eax, DWORD PTR _hmHeight$198614[ebp]
  015d0	f7 d8		 neg	 eax
  015d2	50		 push	 eax
  015d3	8b 4d e8	 mov	 ecx, DWORD PTR _hmWidth$198613[ebp]
  015d6	51		 push	 ecx
  015d7	8b 55 e4	 mov	 edx, DWORD PTR _hmHeight$198614[ebp]
  015da	52		 push	 edx
  015db	6a 00		 push	 0
  015dd	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  015e0	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  015e3	51		 push	 ecx
  015e4	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  015e7	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  015ed	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  015f2	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  015f5	52		 push	 edx
  015f6	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  015f9	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  015fc	51		 push	 ecx
  015fd	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01600	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01606	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0160b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0160e	52		 push	 edx
  0160f	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01612	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01615	51		 push	 ecx
  01616	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01619	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0161f	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01624	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  01627	52		 push	 edx
  01628	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0162b	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0162e	51		 push	 ecx
  0162f	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01632	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01638	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0163d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01640	52		 push	 edx
  01641	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01644	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  01647	51		 push	 ecx
  01648	8b 55 ac	 mov	 edx, DWORD PTR tv331[ebp]
  0164b	52		 push	 edx
  0164c	8b 45 ac	 mov	 eax, DWORD PTR tv331[ebp]
  0164f	8b 08		 mov	 ecx, DWORD PTR [eax]
  01651	ff 51 20	 call	 DWORD PTR [ecx+32]
  01654	85 c0		 test	 eax, eax
  01656	75 0a		 jne	 SHORT $L198616

; 906  : 			{
; 907  : ////				Invalidate(FALSE);
; 908  : 				OnPaint();

  01658	6a 00		 push	 0
  0165a	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0165d	e8 00 00 00 00	 call	 ?OnPaint@CPictureEx@@QAEXPAUHDC__@@@Z ; CPictureEx::OnPaint
$L198616:

; 909  : 			};
; 910  : 			
; 911  : 			if (m_bExitThread) break;

  01662	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  01665	83 7a 44 00	 cmp	 DWORD PTR [edx+68], 0
  01669	74 05		 je	 SHORT $L198617
  0166b	e9 d8 02 00 00	 jmp	 $L198597
$L198617:

; 912  : 
; 913  : 			// if the delay time is too short (like in old GIFs), wait for 100ms
; 914  : 			if (m_arrFrames[m_nCurrFrame].m_nDelay < 5) 

  01670	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01673	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01676	51		 push	 ecx
  01677	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0167a	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01680	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01685	83 78 14 05	 cmp	 DWORD PTR [eax+20], 5
  01689	73 11		 jae	 SHORT $L198618

; 915  : 				WaitForSingleObject(m_hExitEvent, 100);

  0168b	6a 64		 push	 100			; 00000064H
  0168d	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  01690	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  01693	50		 push	 eax
  01694	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 916  : 			else

  0169a	eb 29		 jmp	 SHORT $L198619
$L198618:

; 917  : 				WaitForSingleObject(m_hExitEvent, 10*m_arrFrames[m_nCurrFrame].m_nDelay);

  0169c	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0169f	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  016a2	52		 push	 edx
  016a3	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  016a6	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  016ac	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  016b1	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  016b4	6b c0 0a	 imul	 eax, 10			; 0000000aH
  016b7	50		 push	 eax
  016b8	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  016bb	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  016be	52		 push	 edx
  016bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$L198619:

; 918  : 
; 919  : 			if (m_bExitThread) break;

  016c5	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  016c8	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  016cc	74 05		 je	 SHORT $L198620
  016ce	e9 75 02 00 00	 jmp	 $L198597
$L198620:

; 920  : 
; 921  : 			// disposal method #2
; 922  : 			if (m_arrFrames[m_nCurrFrame].m_nDisposal == 2)

  016d3	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  016d6	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  016d9	52		 push	 edx
  016da	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  016dd	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  016e3	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  016e8	83 78 18 02	 cmp	 DWORD PTR [eax+24], 2
  016ec	0f 85 de 00 00
	00		 jne	 $L198621

; 923  : 			{
; 924  : 				HBRUSH hBrush = CreateSolidBrush(m_clrBackground);

  016f2	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  016f5	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  016f8	51		 push	 ecx
  016f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  016ff	89 45 e0	 mov	 DWORD PTR _hBrush$198622[ebp], eax

; 925  : 				if (hBrush)

  01702	83 7d e0 00	 cmp	 DWORD PTR _hBrush$198622[ebp], 0
  01706	0f 84 bf 00 00
	00		 je	 $L198623

; 926  : 				{
; 927  : 					RECT rect = {
; 928  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cx,

  0170c	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  0170f	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01712	50		 push	 eax
  01713	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01716	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0171c	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01721	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01724	89 4d d0	 mov	 DWORD PTR _rect$198624[ebp], ecx

; 929  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cy,

  01727	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  0172a	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0172d	50		 push	 eax
  0172e	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01731	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01737	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0173c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0173f	89 4d d4	 mov	 DWORD PTR _rect$198624[ebp+4], ecx

; 930  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cx + m_arrFrames[m_nCurrFrame].m_frameSize.cx,

  01742	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  01745	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01748	50		 push	 eax
  01749	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0174c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01752	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01757	8b f0		 mov	 esi, eax
  01759	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0175c	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0175f	52		 push	 edx
  01760	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01763	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01769	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0176e	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01771	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  01774	89 4d d8	 mov	 DWORD PTR _rect$198624[ebp+8], ecx

; 931  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cy + m_arrFrames[m_nCurrFrame].m_frameSize.cy };

  01777	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  0177a	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0177d	50		 push	 eax
  0177e	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01781	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01787	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0178c	8b f0		 mov	 esi, eax
  0178e	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01791	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01794	52		 push	 edx
  01795	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01798	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0179e	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  017a3	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  017a6	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  017a9	89 4d dc	 mov	 DWORD PTR _rect$198624[ebp+12], ecx

; 932  : 					FillRect(m_hMemDC,&rect,hBrush);

  017ac	8b 55 e0	 mov	 edx, DWORD PTR _hBrush$198622[ebp]
  017af	52		 push	 edx
  017b0	8d 45 d0	 lea	 eax, DWORD PTR _rect$198624[ebp]
  017b3	50		 push	 eax
  017b4	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  017b7	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  017ba	52		 push	 edx
  017bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 933  : 					DeleteObject(hBrush);

  017c1	8b 45 e0	 mov	 eax, DWORD PTR _hBrush$198622[ebp]
  017c4	50		 push	 eax
  017c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$L198623:

; 934  : 				};
; 935  : 			} 
; 936  : 			else

  017cb	e9 ef 00 00 00	 jmp	 $L198608
$L198621:

; 937  : 				if (m_hDispMemDC && (m_arrFrames[m_nCurrFrame].m_nDisposal == 3) )

  017d0	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  017d3	83 79 50 00	 cmp	 DWORD PTR [ecx+80], 0
  017d7	0f 84 e2 00 00
	00		 je	 $L198608
  017dd	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  017e0	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  017e3	50		 push	 eax
  017e4	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  017e7	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  017ed	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  017f2	83 78 18 03	 cmp	 DWORD PTR [eax+24], 3
  017f6	0f 85 c3 00 00
	00		 jne	 $L198608

; 938  : 				{
; 939  : 					// put it back
; 940  : 					BitBlt(m_hMemDC,
; 941  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cx,
; 942  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cy,
; 943  : 						m_arrFrames[m_nCurrFrame].m_frameSize.cx,
; 944  : 						m_arrFrames[m_nCurrFrame].m_frameSize.cy,
; 945  : 						m_hDispMemDC,0,0, SRCCOPY);

  017fc	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01801	6a 00		 push	 0
  01803	6a 00		 push	 0
  01805	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01808	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0180b	52		 push	 edx
  0180c	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0180f	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01812	51		 push	 ecx
  01813	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01816	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0181c	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01821	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  01824	52		 push	 edx
  01825	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01828	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0182b	51		 push	 ecx
  0182c	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0182f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01835	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0183a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0183d	52		 push	 edx
  0183e	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01841	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01844	51		 push	 ecx
  01845	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01848	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0184e	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01853	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  01856	52		 push	 edx
  01857	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0185a	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0185d	51		 push	 ecx
  0185e	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01861	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01867	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0186c	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0186f	52		 push	 edx
  01870	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01873	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  01876	51		 push	 ecx
  01877	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 946  : 					// init variables
; 947  : 					SelectObject(m_hDispMemDC,m_hDispOldBM);

  0187d	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  01880	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  01883	50		 push	 eax
  01884	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  01887	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0188a	52		 push	 edx
  0188b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 948  : 					DeleteDC(m_hDispMemDC); m_hDispMemDC = NULL;

  01891	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01894	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  01897	51		 push	 ecx
  01898	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  0189e	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  018a1	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], 0

; 949  : 					DeleteObject(m_hDispMemBM); m_hDispMemBM = NULL;

  018a8	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  018ab	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  018ae	51		 push	 ecx
  018af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  018b5	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  018b8	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], 0
$L198608:

; 950  : 				};
; 951  : 		};
; 952  : 		m_nCurrFrame++;

  018bf	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  018c2	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  018c5	83 c1 01	 add	 ecx, 1
  018c8	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  018cb	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 953  : 		if (m_nCurrFrame == m_arrFrames.size())

  018ce	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  018d1	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  018d7	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  018dc	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  018df	39 41 2c	 cmp	 DWORD PTR [ecx+44], eax
  018e2	75 5f		 jne	 SHORT $L198628

; 954  : 		{
; 955  : 			m_nCurrFrame
; 956  : 				= 0; 

  018e4	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  018e7	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 957  : 		// init the screen for the first frame,
; 958  : 			HBRUSH hBrush = CreateSolidBrush(m_clrBackground);

  018ee	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  018f1	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  018f4	51		 push	 ecx
  018f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  018fb	89 45 cc	 mov	 DWORD PTR _hBrush$198629[ebp], eax

; 959  : 			if (hBrush)

  018fe	83 7d cc 00	 cmp	 DWORD PTR _hBrush$198629[ebp], 0
  01902	74 3f		 je	 SHORT $L198628

; 960  : 			{
; 961  : 				RECT rect = {0,0,m_PictureSize.cx,m_PictureSize.cy};

  01904	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _rect$198631[ebp], 0
  0190b	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _rect$198631[ebp+4], 0
  01912	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  01915	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01918	89 45 c4	 mov	 DWORD PTR _rect$198631[ebp+8], eax
  0191b	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0191e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  01921	89 55 c8	 mov	 DWORD PTR _rect$198631[ebp+12], edx

; 962  : 				FillRect(m_hMemDC,&rect,hBrush);

  01924	8b 45 cc	 mov	 eax, DWORD PTR _hBrush$198629[ebp]
  01927	50		 push	 eax
  01928	8d 4d bc	 lea	 ecx, DWORD PTR _rect$198631[ebp]
  0192b	51		 push	 ecx
  0192c	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  0192f	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  01932	50		 push	 eax
  01933	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 963  : 				DeleteObject(hBrush);

  01939	8b 4d cc	 mov	 ecx, DWORD PTR _hBrush$198629[ebp]
  0193c	51		 push	 ecx
  0193d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$L198628:

; 964  : 			};
; 965  : 		};
; 966  : 	};

  01943	e9 be fa ff ff	 jmp	 $L198606
$L198597:

; 967  : }

  01948	5e		 pop	 esi
  01949	8b e5		 mov	 esp, ebp
  0194b	5d		 pop	 ebp
  0194c	c3		 ret	 0
?ThreadAnimation@CPictureEx@@IAEXXZ ENDP		; CPictureEx::ThreadAnimation
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ		; CArray<CRect,CRect>::RemoveAll
EXTRN	__imp__SetEvent@4:NEAR
EXTRN	__imp__ResetEvent@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Stop@CPictureEx@@QAEXXZ PROC NEAR			; CPictureEx::Stop
; _this$ = ecx

; 970  : {

  01950	55		 push	 ebp
  01951	8b ec		 mov	 ebp, esp
  01953	51		 push	 ecx
  01954	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 971  : 	m_bIsPlaying = FALSE;

  01957	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0195a	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 972  : 	m_bExitThread = TRUE;

  01961	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01964	c7 41 44 01 00
	00 00		 mov	 DWORD PTR [ecx+68], 1

; 973  : 	this->m_aryPoint->RemoveAll();

  0196b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0196e	8b 8a 90 00 00
	00		 mov	 ecx, DWORD PTR [edx+144]
  01974	e8 00 00 00 00	 call	 ?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ ; CArray<CRect,CRect>::RemoveAll

; 974  : 	SetEvent(m_hExitEvent);

  01979	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0197c	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  0197f	51		 push	 ecx
  01980	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 975  : 	if (m_hThread)

  01986	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01989	83 7a 68 00	 cmp	 DWORD PTR [edx+104], 0
  0198d	74 32		 je	 SHORT $L198635

; 976  : 	{
; 977  : 		// we'll wait for 5 seconds then continue execution
; 978  : 		WaitForSingleObject(m_hThread,5000);	

  0198f	68 88 13 00 00	 push	 5000			; 00001388H
  01994	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01997	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0199a	51		 push	 ecx
  0199b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 979  : 		if( m_hThread != NULL )

  019a1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  019a4	83 7a 68 00	 cmp	 DWORD PTR [edx+104], 0
  019a8	74 0d		 je	 SHORT $L198636

; 980  : 		{
; 981  : 			CloseHandle(m_hThread);

  019aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  019ad	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  019b0	51		 push	 ecx
  019b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$L198636:

; 982  : 		}
; 983  : 
; 984  : 		m_hThread = NULL;

  019b7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  019ba	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0
$L198635:

; 985  : 	}
; 986  : 
; 987  : 	// make it possible to Draw() again
; 988  : 	ResetEvent(m_hExitEvent);

  019c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  019c4	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  019c7	51		 push	 ecx
  019c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 989  : 	m_bExitThread = FALSE;

  019ce	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  019d1	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0

; 990  : }

  019d8	8b e5		 mov	 esp, ebp
  019da	5d		 pop	 ebp
  019db	c3		 ret	 0
?Stop@CPictureEx@@QAEXXZ ENDP				; CPictureEx::Stop
_TEXT	ENDS
PUBLIC	?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z ; CPictureEx::TGIFControlExt::GetPackedValue
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -36						; size = 4
_pImage$198668 = -32					; size = 4
_pControl$198657 = -28					; size = 4
_nBlock$ = -24						; size = 4
_nBlockLen$ = -20					; size = 4
_hGlobal$ = -16						; size = 4
_nOffset$ = -12						; size = 4
_nStart$ = -8						; size = 4
_pGlobal$ = -4						; size = 4
_pBlockLen$ = 8						; size = 4
_pDelay$ = 12						; size = 4
_pBlockSize$ = 16					; size = 4
_pBlockOffset$ = 20					; size = 4
_pDisposal$ = 24					; size = 4
?GetNextGraphicBlock@CPictureEx@@IAEPAXPAI0PAUtagSIZE@@10@Z PROC NEAR ; CPictureEx::GetNextGraphicBlock
; _this$ = ecx

; 995  : {

  019e0	55		 push	 ebp
  019e1	8b ec		 mov	 ebp, esp
  019e3	83 ec 24	 sub	 esp, 36			; 00000024H
  019e6	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 996  : 	if (!m_pRawData) return NULL;

  019e9	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  019ec	83 78 78 00	 cmp	 DWORD PTR [eax+120], 0
  019f0	75 07		 jne	 SHORT $L198645
  019f2	33 c0		 xor	 eax, eax
  019f4	e9 44 02 00 00	 jmp	 $L198644
$L198645:

; 997  : 
; 998  : 	// GIF header + LSDescriptor [+ GCT] [+ Control block] + Data
; 999  : 
; 1000 : 	*pDisposal = 0;

  019f9	8b 4d 18	 mov	 ecx, DWORD PTR _pDisposal$[ebp]
  019fc	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1001 : 	enum GIFBlockTypes nBlock;
; 1002 : 	nBlock = GetNextBlock();

  01a02	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a05	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  01a0a	89 45 e8	 mov	 DWORD PTR _nBlock$[ebp], eax
$L198648:

; 1003 : 
; 1004 : 	while (
; 1005 : 		(nBlock != BLOCK_CONTROLEXT) &&
; 1006 : 		(nBlock != BLOCK_IMAGE) &&
; 1007 : 		(nBlock != BLOCK_PLAINTEXT) &&
; 1008 : 		(nBlock != BLOCK_UNKNOWN) &&
; 1009 : 		(nBlock != BLOCK_TRAILER)
; 1010 : 		)

  01a0d	83 7d e8 03	 cmp	 DWORD PTR _nBlock$[ebp], 3
  01a11	74 38		 je	 SHORT $L198649
  01a13	83 7d e8 05	 cmp	 DWORD PTR _nBlock$[ebp], 5
  01a17	74 32		 je	 SHORT $L198649
  01a19	83 7d e8 04	 cmp	 DWORD PTR _nBlock$[ebp], 4
  01a1d	74 2c		 je	 SHORT $L198649
  01a1f	83 7d e8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  01a23	74 26		 je	 SHORT $L198649
  01a25	83 7d e8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  01a29	74 20		 je	 SHORT $L198649

; 1011 : 	{
; 1012 : 		if (!SkipNextBlock()) return NULL;

  01a2b	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a2e	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  01a33	85 c0		 test	 eax, eax
  01a35	75 07		 jne	 SHORT $L198650
  01a37	33 c0		 xor	 eax, eax
  01a39	e9 ff 01 00 00	 jmp	 $L198644
$L198650:

; 1013 : 		nBlock = GetNextBlock();

  01a3e	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a41	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  01a46	89 45 e8	 mov	 DWORD PTR _nBlock$[ebp], eax

; 1014 : 	};

  01a49	eb c2		 jmp	 SHORT $L198648
$L198649:

; 1015 : 
; 1016 : 	if ((nBlock == BLOCK_UNKNOWN) ||
; 1017 : 		(nBlock == BLOCK_TRAILER))

  01a4b	83 7d e8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  01a4f	74 06		 je	 SHORT $L198652
  01a51	83 7d e8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  01a55	75 07		 jne	 SHORT $L198651
$L198652:

; 1018 : 		return NULL;

  01a57	33 c0		 xor	 eax, eax
  01a59	e9 df 01 00 00	 jmp	 $L198644
$L198651:

; 1019 : 
; 1020 : 	// it's either a control ext.block, an image or a plain text
; 1021 : 
; 1022 : 	int nStart = m_nCurrOffset;

  01a5e	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  01a61	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  01a64	89 45 f8	 mov	 DWORD PTR _nStart$[ebp], eax

; 1023 : 	int nBlockLen = GetNextBlockLen();

  01a67	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a6a	e8 00 00 00 00	 call	 ?GetNextBlockLen@CPictureEx@@IBEHXZ ; CPictureEx::GetNextBlockLen
  01a6f	89 45 ec	 mov	 DWORD PTR _nBlockLen$[ebp], eax

; 1024 : 
; 1025 : 	if (nBlockLen <= 0) return NULL;

  01a72	83 7d ec 00	 cmp	 DWORD PTR _nBlockLen$[ebp], 0
  01a76	7f 07		 jg	 SHORT $L198655
  01a78	33 c0		 xor	 eax, eax
  01a7a	e9 be 01 00 00	 jmp	 $L198644
$L198655:

; 1026 : 
; 1027 : 	if (nBlock == BLOCK_CONTROLEXT)

  01a7f	83 7d e8 03	 cmp	 DWORD PTR _nBlock$[ebp], 3
  01a83	0f 85 b1 00 00
	00		 jne	 $L198656

; 1028 : 	{
; 1029 : 		// get the following data
; 1030 : 		TGIFControlExt *pControl = 
; 1031 : 			reinterpret_cast<TGIFControlExt *> (&m_pRawData[m_nCurrOffset]);

  01a89	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a8c	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  01a8f	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  01a92	03 50 34	 add	 edx, DWORD PTR [eax+52]
  01a95	89 55 e4	 mov	 DWORD PTR _pControl$198657[ebp], edx

; 1032 : 		// store delay time
; 1033 : 		*pDelay = pControl->m_wDelayTime;

  01a98	8b 4d e4	 mov	 ecx, DWORD PTR _pControl$198657[ebp]
  01a9b	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  01a9f	8b 45 0c	 mov	 eax, DWORD PTR _pDelay$[ebp]
  01aa2	89 10		 mov	 DWORD PTR [eax], edx

; 1034 : 		// store disposal method
; 1035 : 		*pDisposal = pControl->GetPackedValue(GCX_PACKED_DISPOSAL);

  01aa4	6a 00		 push	 0
  01aa6	8b 4d e4	 mov	 ecx, DWORD PTR _pControl$198657[ebp]
  01aa9	e8 00 00 00 00	 call	 ?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z ; CPictureEx::TGIFControlExt::GetPackedValue
  01aae	8b 4d 18	 mov	 ecx, DWORD PTR _pDisposal$[ebp]
  01ab1	89 01		 mov	 DWORD PTR [ecx], eax

; 1036 : 
; 1037 : 		if (!SkipNextBlock()) return NULL;

  01ab3	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ab6	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  01abb	85 c0		 test	 eax, eax
  01abd	75 07		 jne	 SHORT $L198659
  01abf	33 c0		 xor	 eax, eax
  01ac1	e9 77 01 00 00	 jmp	 $L198644
$L198659:

; 1038 : 		nBlock = GetNextBlock();

  01ac6	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ac9	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  01ace	89 45 e8	 mov	 DWORD PTR _nBlock$[ebp], eax
$L198661:

; 1039 : 		
; 1040 : 		// skip everything until we find data to display 
; 1041 : 		// (image block or plain-text block)
; 1042 : 		
; 1043 : 		while (
; 1044 : 			(nBlock != BLOCK_IMAGE) &&
; 1045 : 			(nBlock != BLOCK_PLAINTEXT) &&
; 1046 : 			(nBlock != BLOCK_UNKNOWN) &&
; 1047 : 			(nBlock != BLOCK_TRAILER)
; 1048 : 			)

  01ad1	83 7d e8 05	 cmp	 DWORD PTR _nBlock$[ebp], 5
  01ad5	74 40		 je	 SHORT $L198662
  01ad7	83 7d e8 04	 cmp	 DWORD PTR _nBlock$[ebp], 4
  01adb	74 3a		 je	 SHORT $L198662
  01add	83 7d e8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  01ae1	74 34		 je	 SHORT $L198662
  01ae3	83 7d e8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  01ae7	74 2e		 je	 SHORT $L198662

; 1049 : 		{
; 1050 : 			if (!SkipNextBlock()) return NULL;

  01ae9	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01aec	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  01af1	85 c0		 test	 eax, eax
  01af3	75 07		 jne	 SHORT $L198663
  01af5	33 c0		 xor	 eax, eax
  01af7	e9 41 01 00 00	 jmp	 $L198644
$L198663:

; 1051 : 			nBlock = GetNextBlock();

  01afc	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01aff	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  01b04	89 45 e8	 mov	 DWORD PTR _nBlock$[ebp], eax

; 1052 : 			nBlockLen += GetNextBlockLen();

  01b07	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b0a	e8 00 00 00 00	 call	 ?GetNextBlockLen@CPictureEx@@IBEHXZ ; CPictureEx::GetNextBlockLen
  01b0f	03 45 ec	 add	 eax, DWORD PTR _nBlockLen$[ebp]
  01b12	89 45 ec	 mov	 DWORD PTR _nBlockLen$[ebp], eax

; 1053 : 		};

  01b15	eb ba		 jmp	 SHORT $L198661
$L198662:

; 1054 : 
; 1055 : 		if ((nBlock == BLOCK_UNKNOWN) || (nBlock == BLOCK_TRAILER))

  01b17	83 7d e8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  01b1b	74 06		 je	 SHORT $L198665
  01b1d	83 7d e8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  01b21	75 07		 jne	 SHORT $L198664
$L198665:

; 1056 : 			return NULL;

  01b23	33 c0		 xor	 eax, eax
  01b25	e9 13 01 00 00	 jmp	 $L198644
$L198664:

; 1057 : 		nBlockLen += GetNextBlockLen();

  01b2a	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b2d	e8 00 00 00 00	 call	 ?GetNextBlockLen@CPictureEx@@IBEHXZ ; CPictureEx::GetNextBlockLen
  01b32	03 45 ec	 add	 eax, DWORD PTR _nBlockLen$[ebp]
  01b35	89 45 ec	 mov	 DWORD PTR _nBlockLen$[ebp], eax

; 1058 : 	}
; 1059 : 	else

  01b38	eb 09		 jmp	 SHORT $L198666
$L198656:

; 1060 : 		*pDelay = -1; // to indicate that there was no delay value

  01b3a	8b 55 0c	 mov	 edx, DWORD PTR _pDelay$[ebp]
  01b3d	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
$L198666:

; 1061 : 
; 1062 : 	if (nBlock == BLOCK_IMAGE)

  01b43	83 7d e8 05	 cmp	 DWORD PTR _nBlock$[ebp], 5
  01b47	75 41		 jne	 SHORT $L198667

; 1063 : 	{
; 1064 : 		// store size and offsets
; 1065 : 		TGIFImageDescriptor *pImage = 
; 1066 : 			reinterpret_cast<TGIFImageDescriptor *> (&m_pRawData[m_nCurrOffset]);

  01b49	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  01b4c	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  01b4f	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  01b52	03 4a 34	 add	 ecx, DWORD PTR [edx+52]
  01b55	89 4d e0	 mov	 DWORD PTR _pImage$198668[ebp], ecx

; 1067 : 		pBlockSize->cx = pImage->m_wWidth;

  01b58	8b 45 e0	 mov	 eax, DWORD PTR _pImage$198668[ebp]
  01b5b	0f b7 48 05	 movzx	 ecx, WORD PTR [eax+5]
  01b5f	8b 55 10	 mov	 edx, DWORD PTR _pBlockSize$[ebp]
  01b62	89 0a		 mov	 DWORD PTR [edx], ecx

; 1068 : 		pBlockSize->cy = pImage->m_wHeight;

  01b64	8b 45 e0	 mov	 eax, DWORD PTR _pImage$198668[ebp]
  01b67	0f b7 48 07	 movzx	 ecx, WORD PTR [eax+7]
  01b6b	8b 55 10	 mov	 edx, DWORD PTR _pBlockSize$[ebp]
  01b6e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1069 : 		pBlockOffset->cx = pImage->m_wLeftPos;

  01b71	8b 45 e0	 mov	 eax, DWORD PTR _pImage$198668[ebp]
  01b74	0f b7 48 01	 movzx	 ecx, WORD PTR [eax+1]
  01b78	8b 55 14	 mov	 edx, DWORD PTR _pBlockOffset$[ebp]
  01b7b	89 0a		 mov	 DWORD PTR [edx], ecx

; 1070 : 		pBlockOffset->cy = pImage->m_wTopPos;

  01b7d	8b 45 e0	 mov	 eax, DWORD PTR _pImage$198668[ebp]
  01b80	0f b7 48 03	 movzx	 ecx, WORD PTR [eax+3]
  01b84	8b 55 14	 mov	 edx, DWORD PTR _pBlockOffset$[ebp]
  01b87	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L198667:

; 1071 : 	};
; 1072 : 
; 1073 : 	if (!SkipNextBlock()) return NULL;

  01b8a	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b8d	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  01b92	85 c0		 test	 eax, eax
  01b94	75 07		 jne	 SHORT $L198670
  01b96	33 c0		 xor	 eax, eax
  01b98	e9 a0 00 00 00	 jmp	 $L198644
$L198670:

; 1074 : 
; 1075 : 	HGLOBAL hGlobal = GlobalAlloc(GMEM_FIXED,
; 1076 : 		sizeof(TGIFHeader) +
; 1077 : 		sizeof(TGIFLSDescriptor) +
; 1078 : 		m_nGlobalCTSize +
; 1079 : 		nBlockLen + 
; 1080 : 		1);  // for the trailer

  01b9d	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  01ba0	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01ba3	8b 55 ec	 mov	 edx, DWORD PTR _nBlockLen$[ebp]
  01ba6	8d 44 11 0e	 lea	 eax, DWORD PTR [ecx+edx+14]
  01baa	50		 push	 eax
  01bab	6a 00		 push	 0
  01bad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  01bb3	89 45 f0	 mov	 DWORD PTR _hGlobal$[ebp], eax

; 1081 : 
; 1082 : 	if (!hGlobal) return NULL;

  01bb6	83 7d f0 00	 cmp	 DWORD PTR _hGlobal$[ebp], 0
  01bba	75 04		 jne	 SHORT $L198674
  01bbc	33 c0		 xor	 eax, eax
  01bbe	eb 7d		 jmp	 SHORT $L198644
$L198674:

; 1083 : 
; 1084 : 	int nOffset = 0; 

  01bc0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nOffset$[ebp], 0

; 1085 : 
; 1086 : 	// GMEM_FIXED means we get a pointer
; 1087 : 	unsigned char *pGlobal = reinterpret_cast<unsigned char *> (hGlobal);

  01bc7	8b 4d f0	 mov	 ecx, DWORD PTR _hGlobal$[ebp]
  01bca	89 4d fc	 mov	 DWORD PTR _pGlobal$[ebp], ecx

; 1088 : 
; 1089 : 	CopyMemory(pGlobal,m_pRawData, 
; 1090 : 		sizeof(TGIFHeader)+sizeof(TGIFLSDescriptor)+m_nGlobalCTSize);

  01bcd	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  01bd0	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  01bd3	83 c0 0d	 add	 eax, 13			; 0000000dH
  01bd6	50		 push	 eax
  01bd7	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01bda	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  01bdd	52		 push	 edx
  01bde	8b 45 fc	 mov	 eax, DWORD PTR _pGlobal$[ebp]
  01be1	50		 push	 eax
  01be2	e8 00 00 00 00	 call	 _memcpy
  01be7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1091 : 	nOffset += sizeof(TGIFHeader)+sizeof(TGIFLSDescriptor)+m_nGlobalCTSize;

  01bea	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01bed	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  01bf0	8b 45 f4	 mov	 eax, DWORD PTR _nOffset$[ebp]
  01bf3	8d 4c 10 0d	 lea	 ecx, DWORD PTR [eax+edx+13]
  01bf7	89 4d f4	 mov	 DWORD PTR _nOffset$[ebp], ecx

; 1092 : 
; 1093 : 	CopyMemory(pGlobal + nOffset,&m_pRawData[nStart], nBlockLen);

  01bfa	8b 55 ec	 mov	 edx, DWORD PTR _nBlockLen$[ebp]
  01bfd	52		 push	 edx
  01bfe	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  01c01	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  01c04	03 4d f8	 add	 ecx, DWORD PTR _nStart$[ebp]
  01c07	51		 push	 ecx
  01c08	8b 55 fc	 mov	 edx, DWORD PTR _pGlobal$[ebp]
  01c0b	03 55 f4	 add	 edx, DWORD PTR _nOffset$[ebp]
  01c0e	52		 push	 edx
  01c0f	e8 00 00 00 00	 call	 _memcpy
  01c14	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1094 : 	nOffset += nBlockLen;

  01c17	8b 45 f4	 mov	 eax, DWORD PTR _nOffset$[ebp]
  01c1a	03 45 ec	 add	 eax, DWORD PTR _nBlockLen$[ebp]
  01c1d	89 45 f4	 mov	 DWORD PTR _nOffset$[ebp], eax

; 1095 : 
; 1096 : 	pGlobal[nOffset] = 0x3B; // trailer

  01c20	8b 4d fc	 mov	 ecx, DWORD PTR _pGlobal$[ebp]
  01c23	03 4d f4	 add	 ecx, DWORD PTR _nOffset$[ebp]
  01c26	c6 01 3b	 mov	 BYTE PTR [ecx], 59	; 0000003bH

; 1097 : 	nOffset++;

  01c29	8b 55 f4	 mov	 edx, DWORD PTR _nOffset$[ebp]
  01c2c	83 c2 01	 add	 edx, 1
  01c2f	89 55 f4	 mov	 DWORD PTR _nOffset$[ebp], edx

; 1098 : 
; 1099 : 	*pBlockLen = nOffset;

  01c32	8b 45 08	 mov	 eax, DWORD PTR _pBlockLen$[ebp]
  01c35	8b 4d f4	 mov	 ecx, DWORD PTR _nOffset$[ebp]
  01c38	89 08		 mov	 DWORD PTR [eax], ecx

; 1100 : 
; 1101 : 	return hGlobal;

  01c3a	8b 45 f0	 mov	 eax, DWORD PTR _hGlobal$[ebp]
$L198644:

; 1102 : }

  01c3d	8b e5		 mov	 esp, ebp
  01c3f	5d		 pop	 ebp
  01c40	c2 14 00	 ret	 20			; 00000014H
?GetNextGraphicBlock@CPictureEx@@IAEPAXPAI0PAUtagSIZE@@10@Z ENDP ; CPictureEx::GetNextGraphicBlock
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z
_TEXT	SEGMENT
tv66 = -12						; size = 4
_this$ = -8						; size = 4
_nRet$ = -4						; size = 4
_Value$ = 8						; size = 4
?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z PROC NEAR ; CPictureEx::TGIFControlExt::GetPackedValue, COMDAT
; _this$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 96   : 	int nRet = (int)m_cPacked;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00010	89 4d fc	 mov	 DWORD PTR _nRet$[ebp], ecx

; 97   : 	switch (Value)

  00013	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  00016	89 55 f4	 mov	 DWORD PTR tv66[ebp], edx
  00019	83 7d f4 00	 cmp	 DWORD PTR tv66[ebp], 0
  0001d	74 0e		 je	 SHORT $L198164
  0001f	83 7d f4 01	 cmp	 DWORD PTR tv66[ebp], 1
  00023	74 16		 je	 SHORT $L198165
  00025	83 7d f4 02	 cmp	 DWORD PTR tv66[ebp], 2
  00029	74 1d		 je	 SHORT $L198166
  0002b	eb 24		 jmp	 SHORT $L198161
$L198164:

; 98   : 	{
; 99   : 	case GCX_PACKED_DISPOSAL:
; 100  : 		nRet = (nRet & 28) >> 2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _nRet$[ebp]
  00030	83 e0 1c	 and	 eax, 28			; 0000001cH
  00033	c1 f8 02	 sar	 eax, 2
  00036	89 45 fc	 mov	 DWORD PTR _nRet$[ebp], eax

; 101  : 		break;

  00039	eb 16		 jmp	 SHORT $L198161
$L198165:

; 102  : 
; 103  : 	case GCX_PACKED_USERINPUT:
; 104  : 		nRet = (nRet & 2) >> 1;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _nRet$[ebp]
  0003e	83 e1 02	 and	 ecx, 2
  00041	d1 f9		 sar	 ecx, 1
  00043	89 4d fc	 mov	 DWORD PTR _nRet$[ebp], ecx

; 105  : 		break;

  00046	eb 09		 jmp	 SHORT $L198161
$L198166:

; 106  : 
; 107  : 	case GCX_PACKED_TRANSPCOLOR:
; 108  : 		nRet &= 1;

  00048	8b 55 fc	 mov	 edx, DWORD PTR _nRet$[ebp]
  0004b	83 e2 01	 and	 edx, 1
  0004e	89 55 fc	 mov	 DWORD PTR _nRet$[ebp], edx
$L198161:

; 109  : 		break;
; 110  : 	};
; 111  : 
; 112  : 	return nRet;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _nRet$[ebp]

; 113  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z ENDP ; CPictureEx::TGIFControlExt::GetPackedValue
_TEXT	ENDS
PUBLIC	?IsGIF@CPictureEx@@QBEHXZ			; CPictureEx::IsGIF
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGIF@CPictureEx@@QBEHXZ PROC NEAR			; CPictureEx::IsGIF
; _this$ = ecx

; 1105 : {

  01c50	55		 push	 ebp
  01c51	8b ec		 mov	 ebp, esp
  01c53	51		 push	 ecx
  01c54	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1106 : 	return m_bIsGIF;

  01c57	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01c5a	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]

; 1107 : }

  01c5d	8b e5		 mov	 esp, ebp
  01c5f	5d		 pop	 ebp
  01c60	c3		 ret	 0
?IsGIF@CPictureEx@@QBEHXZ ENDP				; CPictureEx::IsGIF
; Function compile flags: /Odt
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?IsAnimatedGIF@CPictureEx@@QBEHXZ PROC NEAR		; CPictureEx::IsAnimatedGIF
; _this$ = ecx

; 1110 : {

  01c70	55		 push	 ebp
  01c71	8b ec		 mov	 ebp, esp
  01c73	83 ec 08	 sub	 esp, 8
  01c76	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1111 : 	return (m_bIsGIF && (m_arrFrames.size() > 1));

  01c79	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01c7c	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  01c80	74 1c		 je	 SHORT $L200057
  01c82	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c85	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01c8b	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  01c90	83 f8 01	 cmp	 eax, 1
  01c93	76 09		 jbe	 SHORT $L200057
  01c95	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  01c9c	eb 07		 jmp	 SHORT $L200058
$L200057:
  01c9e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$L200058:
  01ca5	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 1112 : }

  01ca8	8b e5		 mov	 esp, ebp
  01caa	5d		 pop	 ebp
  01cab	c3		 ret	 0
?IsAnimatedGIF@CPictureEx@@QBEHXZ ENDP			; CPictureEx::IsAnimatedGIF
_TEXT	ENDS
PUBLIC	?IsPlaying@CPictureEx@@QBEHXZ			; CPictureEx::IsPlaying
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPlaying@CPictureEx@@QBEHXZ PROC NEAR			; CPictureEx::IsPlaying
; _this$ = ecx

; 1115 : {

  01cb0	55		 push	 ebp
  01cb1	8b ec		 mov	 ebp, esp
  01cb3	51		 push	 ecx
  01cb4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1116 : 	return m_bIsPlaying;

  01cb7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01cba	8b 40 40	 mov	 eax, DWORD PTR [eax+64]

; 1117 : }

  01cbd	8b e5		 mov	 esp, ebp
  01cbf	5d		 pop	 ebp
  01cc0	c3		 ret	 0
?IsPlaying@CPictureEx@@QBEHXZ ENDP			; CPictureEx::IsPlaying
_TEXT	ENDS
PUBLIC	?GetFrameCount@CPictureEx@@QBEHXZ		; CPictureEx::GetFrameCount
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFrameCount@CPictureEx@@QBEHXZ PROC NEAR		; CPictureEx::GetFrameCount
; _this$ = ecx

; 1120 : {

  01cd0	55		 push	 ebp
  01cd1	8b ec		 mov	 ebp, esp
  01cd3	51		 push	 ecx
  01cd4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1121 : 	if (!IsAnimatedGIF())

  01cd7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cda	e8 00 00 00 00	 call	 ?IsAnimatedGIF@CPictureEx@@QBEHXZ ; CPictureEx::IsAnimatedGIF
  01cdf	85 c0		 test	 eax, eax
  01ce1	75 04		 jne	 SHORT $L198694

; 1122 : 		return 0;

  01ce3	33 c0		 xor	 eax, eax
  01ce5	eb 0e		 jmp	 SHORT $L198693
$L198694:

; 1123 : 
; 1124 : 	return (int)(m_arrFrames.size());

  01ce7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cea	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01cf0	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
$L198693:

; 1125 : }

  01cf5	8b e5		 mov	 esp, ebp
  01cf7	5d		 pop	 ebp
  01cf8	c3		 ret	 0
?GetFrameCount@CPictureEx@@QBEHXZ ENDP			; CPictureEx::GetFrameCount
_TEXT	ENDS
PUBLIC	?GetBkColor@CPictureEx@@QBEKXZ			; CPictureEx::GetBkColor
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBkColor@CPictureEx@@QBEKXZ PROC NEAR		; CPictureEx::GetBkColor
; _this$ = ecx

; 1128 : {

  01d00	55		 push	 ebp
  01d01	8b ec		 mov	 ebp, esp
  01d03	51		 push	 ecx
  01d04	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1129 : 	return m_clrBackground;

  01d07	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d0a	8b 40 28	 mov	 eax, DWORD PTR [eax+40]

; 1130 : }

  01d0d	8b e5		 mov	 esp, ebp
  01d0f	5d		 pop	 ebp
  01d10	c3		 ret	 0
?GetBkColor@CPictureEx@@QBEKXZ ENDP			; CPictureEx::GetBkColor
_TEXT	ENDS
PUBLIC	?Offset@CPoint@@QAEXHH@Z			; CPoint::Offset
PUBLIC	??0CRect@@QAE@HHHH@Z				; CRect::CRect
PUBLIC	?CenterPoint@CRect@@QBE?AVCPoint@@XZ		; CRect::CenterPoint
PUBLIC	?PtInRect@CRect@@QBEHUtagPOINT@@@Z		; CRect::PtInRect
PUBLIC	?HitTest@CPictureEx@@QAEHVCPoint@@@Z		; CPictureEx::HitTest
PUBLIC	?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ		; CArray<CRect,CRect>::GetSize
PUBLIC	?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z	; CArray<CRect,CRect>::GetAt
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T200063 = -52						; size = 8
_r$198710 = -44						; size = 16
_p1$198708 = -28					; size = 8
_rc$198707 = -20					; size = 16
_i$198703 = -4						; size = 4
_p$ = 8							; size = 8
?HitTest@CPictureEx@@QAEHVCPoint@@@Z PROC NEAR		; CPictureEx::HitTest
; _this$ = ecx

; 1133 : {

  01d20	55		 push	 ebp
  01d21	8b ec		 mov	 ebp, esp
  01d23	83 ec 38	 sub	 esp, 56			; 00000038H
  01d26	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 1134 : 	for(int i = 0 ; i<m_aryPoint->GetSize(); i++)

  01d29	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$198703[ebp], 0
  01d30	eb 09		 jmp	 SHORT $L198704
$L198705:
  01d32	8b 45 fc	 mov	 eax, DWORD PTR _i$198703[ebp]
  01d35	83 c0 01	 add	 eax, 1
  01d38	89 45 fc	 mov	 DWORD PTR _i$198703[ebp], eax
$L198704:
  01d3b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01d3e	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [ecx+144]
  01d44	e8 00 00 00 00	 call	 ?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ ; CArray<CRect,CRect>::GetSize
  01d49	39 45 fc	 cmp	 DWORD PTR _i$198703[ebp], eax
  01d4c	0f 8d a9 00 00
	00		 jge	 $L198706

; 1135 : 	{
; 1136 : 		
; 1137 : 		CRect rc = m_aryPoint->GetAt(i);

  01d52	8b 55 fc	 mov	 edx, DWORD PTR _i$198703[ebp]
  01d55	52		 push	 edx
  01d56	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  01d59	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  01d5f	e8 00 00 00 00	 call	 ?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z ; CArray<CRect,CRect>::GetAt
  01d64	8b 08		 mov	 ecx, DWORD PTR [eax]
  01d66	89 4d ec	 mov	 DWORD PTR _rc$198707[ebp], ecx
  01d69	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01d6c	89 55 f0	 mov	 DWORD PTR _rc$198707[ebp+4], edx
  01d6f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01d72	89 4d f4	 mov	 DWORD PTR _rc$198707[ebp+8], ecx
  01d75	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01d78	89 55 f8	 mov	 DWORD PTR _rc$198707[ebp+12], edx

; 1138 : 		CPoint p1 = rc.CenterPoint();

  01d7b	8d 45 e4	 lea	 eax, DWORD PTR _p1$198708[ebp]
  01d7e	50		 push	 eax
  01d7f	8d 4d ec	 lea	 ecx, DWORD PTR _rc$198707[ebp]
  01d82	e8 00 00 00 00	 call	 ?CenterPoint@CRect@@QBE?AVCPoint@@XZ ; CRect::CenterPoint

; 1139 : 		p1.Offset(-m_PictureSize.cx/2 , - m_PictureSize.cy/2);

  01d87	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01d8a	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  01d8d	f7 d8		 neg	 eax
  01d8f	99		 cdq
  01d90	2b c2		 sub	 eax, edx
  01d92	d1 f8		 sar	 eax, 1
  01d94	50		 push	 eax
  01d95	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  01d98	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01d9b	f7 d8		 neg	 eax
  01d9d	99		 cdq
  01d9e	2b c2		 sub	 eax, edx
  01da0	d1 f8		 sar	 eax, 1
  01da2	50		 push	 eax
  01da3	8d 4d e4	 lea	 ecx, DWORD PTR _p1$198708[ebp]
  01da6	e8 00 00 00 00	 call	 ?Offset@CPoint@@QAEXHH@Z ; CPoint::Offset

; 1140 : 		CRect r(p1.x, p1.y, p1.x + m_PictureSize.cx , p1.y + m_PictureSize.cy);

  01dab	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  01dae	8b 4d e8	 mov	 ecx, DWORD PTR _p1$198708[ebp+4]
  01db1	03 48 24	 add	 ecx, DWORD PTR [eax+36]
  01db4	51		 push	 ecx
  01db5	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  01db8	8b 45 e4	 mov	 eax, DWORD PTR _p1$198708[ebp]
  01dbb	03 42 20	 add	 eax, DWORD PTR [edx+32]
  01dbe	50		 push	 eax
  01dbf	8b 4d e8	 mov	 ecx, DWORD PTR _p1$198708[ebp+4]
  01dc2	51		 push	 ecx
  01dc3	8b 55 e4	 mov	 edx, DWORD PTR _p1$198708[ebp]
  01dc6	52		 push	 edx
  01dc7	8d 4d d4	 lea	 ecx, DWORD PTR _r$198710[ebp]
  01dca	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect

; 1141 : 
; 1142 : 		if(r.PtInRect(p))

  01dcf	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  01dd2	89 45 cc	 mov	 DWORD PTR $T200063[ebp], eax
  01dd5	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp+4]
  01dd8	89 4d d0	 mov	 DWORD PTR $T200063[ebp+4], ecx
  01ddb	8b 55 d0	 mov	 edx, DWORD PTR $T200063[ebp+4]
  01dde	52		 push	 edx
  01ddf	8b 45 cc	 mov	 eax, DWORD PTR $T200063[ebp]
  01de2	50		 push	 eax
  01de3	8d 4d d4	 lea	 ecx, DWORD PTR _r$198710[ebp]
  01de6	e8 00 00 00 00	 call	 ?PtInRect@CRect@@QBEHUtagPOINT@@@Z ; CRect::PtInRect
  01deb	85 c0		 test	 eax, eax
  01ded	74 07		 je	 SHORT $L198712

; 1143 : 			return TRUE;

  01def	b8 01 00 00 00	 mov	 eax, 1
  01df4	eb 07		 jmp	 SHORT $L198702
$L198712:

; 1144 : 	}

  01df6	e9 37 ff ff ff	 jmp	 $L198705
$L198706:

; 1145 : 
; 1146 : 	return FALSE;

  01dfb	33 c0		 xor	 eax, eax
$L198702:

; 1147 : }

  01dfd	8b e5		 mov	 esp, ebp
  01dff	5d		 pop	 ebp
  01e00	c2 08 00	 ret	 8
?HitTest@CPictureEx@@QAEHVCPoint@@@Z ENDP		; CPictureEx::HitTest
_TEXT	ENDS
PUBLIC	?Width@CRect@@QBEHXZ				; CRect::Width
PUBLIC	?Height@CRect@@QBEHXZ				; CRect::Height
EXTRN	__imp__RestoreDC@8:NEAR
EXTRN	__imp__SaveDC@4:NEAR
EXTRN	__imp__StretchBlt@44:NEAR
EXTRN	__imp__SetStretchBltMode@8:NEAR
EXTRN	__imp__TransparentBlt@44:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -44						; size = 4
_nPaintHeight$198729 = -40				; size = 4
_rc$198726 = -36					; size = 16
_p$198727 = -20						; size = 8
_i$198722 = -12						; size = 4
_iSaveDC$ = -8						; size = 4
_dc$ = -4						; size = 4
_memdc$ = 8						; size = 4
?OnPaint@CPictureEx@@QAEXPAUHDC__@@@Z PROC NEAR		; CPictureEx::OnPaint
; _this$ = ecx

; 1149 : {

  01e10	55		 push	 ebp
  01e11	8b ec		 mov	 ebp, esp
  01e13	83 ec 2c	 sub	 esp, 44			; 0000002cH
  01e16	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 1150 : 	//CPaintDC dc(this); // device context for painting
; 1151 : 	////Lock lock(_csGifOnPaint);;
; 1152 : 	if(m_bPause)

  01e19	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  01e1c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  01e20	85 c9		 test	 ecx, ecx
  01e22	74 05		 je	 SHORT $L198717

; 1153 : 		return;

  01e24	e9 03 02 00 00	 jmp	 $L198716
$L198717:

; 1154 : 	HDC dc = NULL;

  01e29	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dc$[ebp], 0

; 1155 : 	int iSaveDC = 0;

  01e30	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iSaveDC$[ebp], 0

; 1156 : 
; 1157 : 	if(memdc == NULL)

  01e37	83 7d 08 00	 cmp	 DWORD PTR _memdc$[ebp], 0
  01e3b	75 1f		 jne	 SHORT $L198720

; 1158 : 	{
; 1159 : 		dc = ::GetDC(m_hWnd);

  01e3d	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  01e40	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01e43	50		 push	 eax
  01e44	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  01e4a	89 45 fc	 mov	 DWORD PTR _dc$[ebp], eax

; 1160 : 		iSaveDC = SaveDC( dc );

  01e4d	8b 4d fc	 mov	 ecx, DWORD PTR _dc$[ebp]
  01e50	51		 push	 ecx
  01e51	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SaveDC@4
  01e57	89 45 f8	 mov	 DWORD PTR _iSaveDC$[ebp], eax

; 1161 : 	}
; 1162 : 	else

  01e5a	eb 06		 jmp	 SHORT $L198721
$L198720:

; 1163 : 	  dc = memdc;

  01e5c	8b 55 08	 mov	 edx, DWORD PTR _memdc$[ebp]
  01e5f	89 55 fc	 mov	 DWORD PTR _dc$[ebp], edx
$L198721:

; 1164 : 
; 1165 : 	for(int i = 0 ; i<m_aryPoint->GetSize(); i++)

  01e62	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$198722[ebp], 0
  01e69	eb 09		 jmp	 SHORT $L198723
$L198724:
  01e6b	8b 45 f4	 mov	 eax, DWORD PTR _i$198722[ebp]
  01e6e	83 c0 01	 add	 eax, 1
  01e71	89 45 f4	 mov	 DWORD PTR _i$198722[ebp], eax
$L198723:
  01e74	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  01e77	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [ecx+144]
  01e7d	e8 00 00 00 00	 call	 ?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ ; CArray<CRect,CRect>::GetSize
  01e82	39 45 f4	 cmp	 DWORD PTR _i$198722[ebp], eax
  01e85	0f 8d 7c 01 00
	00		 jge	 $L198725

; 1166 : 	{
; 1167 : 		CRect rc = m_aryPoint->GetAt(i);

  01e8b	8b 55 f4	 mov	 edx, DWORD PTR _i$198722[ebp]
  01e8e	52		 push	 edx
  01e8f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  01e92	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  01e98	e8 00 00 00 00	 call	 ?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z ; CArray<CRect,CRect>::GetAt
  01e9d	8b 08		 mov	 ecx, DWORD PTR [eax]
  01e9f	89 4d dc	 mov	 DWORD PTR _rc$198726[ebp], ecx
  01ea2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01ea5	89 55 e0	 mov	 DWORD PTR _rc$198726[ebp+4], edx
  01ea8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01eab	89 4d e4	 mov	 DWORD PTR _rc$198726[ebp+8], ecx
  01eae	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01eb1	89 55 e8	 mov	 DWORD PTR _rc$198726[ebp+12], edx

; 1168 : 		CPoint p = rc.CenterPoint();

  01eb4	8d 45 ec	 lea	 eax, DWORD PTR _p$198727[ebp]
  01eb7	50		 push	 eax
  01eb8	8d 4d dc	 lea	 ecx, DWORD PTR _rc$198726[ebp]
  01ebb	e8 00 00 00 00	 call	 ?CenterPoint@CRect@@QBE?AVCPoint@@XZ ; CRect::CenterPoint

; 1169 : 		p.Offset(-m_PictureSize.cx/2 , - m_PictureSize.cy/2);

  01ec0	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  01ec3	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  01ec6	f7 d8		 neg	 eax
  01ec8	99		 cdq
  01ec9	2b c2		 sub	 eax, edx
  01ecb	d1 f8		 sar	 eax, 1
  01ecd	50		 push	 eax
  01ece	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  01ed1	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01ed4	f7 d8		 neg	 eax
  01ed6	99		 cdq
  01ed7	2b c2		 sub	 eax, edx
  01ed9	d1 f8		 sar	 eax, 1
  01edb	50		 push	 eax
  01edc	8d 4d ec	 lea	 ecx, DWORD PTR _p$198727[ebp]
  01edf	e8 00 00 00 00	 call	 ?Offset@CPoint@@QAEXHH@Z ; CPoint::Offset

; 1170 : 				
; 1171 : 		LONG nPaintHeight = m_PaintRect.bottom - m_PaintRect.top;

  01ee4	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  01ee7	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  01eea	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  01eed	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  01ef0	89 55 d8	 mov	 DWORD PTR _nPaintHeight$198729[ebp], edx

; 1172 : 		if(!m_bStretch)

  01ef3	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  01ef6	0f b6 48 5c	 movzx	 ecx, BYTE PTR [eax+92]
  01efa	85 c9		 test	 ecx, ecx
  01efc	0f 85 b2 00 00
	00		 jne	 $L198730

; 1173 : 		{
; 1174 : 			if(m_bHasMask)

  01f02	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  01f05	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  01f09	74 77		 je	 SHORT $L198731

; 1175 : 			{
; 1176 : 				StretchBlt(dc, p.x, p.y,  m_PictureSize.cx, m_PictureSize.cy,
; 1177 : 					dc, rc.right, p.y, 1, m_PictureSize.cy, SRCCOPY);

  01f0b	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01f10	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  01f13	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01f16	51		 push	 ecx
  01f17	6a 01		 push	 1
  01f19	8b 55 f0	 mov	 edx, DWORD PTR _p$198727[ebp+4]
  01f1c	52		 push	 edx
  01f1d	8b 45 e4	 mov	 eax, DWORD PTR _rc$198726[ebp+8]
  01f20	50		 push	 eax
  01f21	8b 4d fc	 mov	 ecx, DWORD PTR _dc$[ebp]
  01f24	51		 push	 ecx
  01f25	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  01f28	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  01f2b	50		 push	 eax
  01f2c	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  01f2f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  01f32	52		 push	 edx
  01f33	8b 45 f0	 mov	 eax, DWORD PTR _p$198727[ebp+4]
  01f36	50		 push	 eax
  01f37	8b 4d ec	 mov	 ecx, DWORD PTR _p$198727[ebp]
  01f3a	51		 push	 ecx
  01f3b	8b 55 fc	 mov	 edx, DWORD PTR _dc$[ebp]
  01f3e	52		 push	 edx
  01f3f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchBlt@44

; 1178 : 
; 1179 : 				::TransparentBlt(dc, p.x, p.y, m_PictureSize.cx, m_PictureSize.cy,
; 1180 : 					m_hMemDC, 0, 0, m_PictureSize.cx, m_PictureSize.cy,RGB(0,0,0));

  01f45	6a 00		 push	 0
  01f47	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  01f4a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01f4d	51		 push	 ecx
  01f4e	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  01f51	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01f54	50		 push	 eax
  01f55	6a 00		 push	 0
  01f57	6a 00		 push	 0
  01f59	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  01f5c	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  01f5f	52		 push	 edx
  01f60	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  01f63	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01f66	51		 push	 ecx
  01f67	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  01f6a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01f6d	50		 push	 eax
  01f6e	8b 4d f0	 mov	 ecx, DWORD PTR _p$198727[ebp+4]
  01f71	51		 push	 ecx
  01f72	8b 55 ec	 mov	 edx, DWORD PTR _p$198727[ebp]
  01f75	52		 push	 edx
  01f76	8b 45 fc	 mov	 eax, DWORD PTR _dc$[ebp]
  01f79	50		 push	 eax
  01f7a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TransparentBlt@44

; 1181 : 			}
; 1182 : 			else

  01f80	eb 30		 jmp	 SHORT $L198739
$L198731:

; 1183 : 			{
; 1184 : 				BitBlt(dc, p.x, p.y, m_PictureSize.cx, m_PictureSize.cy, m_hMemDC, 0, 0,SRCCOPY);

  01f82	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01f87	6a 00		 push	 0
  01f89	6a 00		 push	 0
  01f8b	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  01f8e	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  01f91	52		 push	 edx
  01f92	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  01f95	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01f98	51		 push	 ecx
  01f99	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  01f9c	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01f9f	50		 push	 eax
  01fa0	8b 4d f0	 mov	 ecx, DWORD PTR _p$198727[ebp+4]
  01fa3	51		 push	 ecx
  01fa4	8b 55 ec	 mov	 edx, DWORD PTR _p$198727[ebp]
  01fa7	52		 push	 edx
  01fa8	8b 45 fc	 mov	 eax, DWORD PTR _dc$[ebp]
  01fab	50		 push	 eax
  01fac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
$L198739:

; 1185 : 			}
; 1186 : 		}
; 1187 : 		else

  01fb2	eb 4e		 jmp	 SHORT $L198741
$L198730:

; 1188 : 		{
; 1189 : 			SetStretchBltMode(dc,STRETCH_DELETESCANS); 

  01fb4	6a 03		 push	 3
  01fb6	8b 4d fc	 mov	 ecx, DWORD PTR _dc$[ebp]
  01fb9	51		 push	 ecx
  01fba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetStretchBltMode@8

; 1190 : 			StretchBlt(dc, rc.left, rc.top, rc.Width(), rc.Height(), m_hMemDC, 0, 0,m_PictureSize.cx, m_PictureSize.cy, SRCCOPY);

  01fc0	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01fc5	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  01fc8	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  01fcb	50		 push	 eax
  01fcc	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  01fcf	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  01fd2	52		 push	 edx
  01fd3	6a 00		 push	 0
  01fd5	6a 00		 push	 0
  01fd7	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  01fda	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  01fdd	51		 push	 ecx
  01fde	8d 4d dc	 lea	 ecx, DWORD PTR _rc$198726[ebp]
  01fe1	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  01fe6	50		 push	 eax
  01fe7	8d 4d dc	 lea	 ecx, DWORD PTR _rc$198726[ebp]
  01fea	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  01fef	50		 push	 eax
  01ff0	8b 55 e0	 mov	 edx, DWORD PTR _rc$198726[ebp+4]
  01ff3	52		 push	 edx
  01ff4	8b 45 dc	 mov	 eax, DWORD PTR _rc$198726[ebp]
  01ff7	50		 push	 eax
  01ff8	8b 4d fc	 mov	 ecx, DWORD PTR _dc$[ebp]
  01ffb	51		 push	 ecx
  01ffc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchBlt@44
$L198741:

; 1191 : 		}		
; 1192 : 	}

  02002	e9 64 fe ff ff	 jmp	 $L198724
$L198725:

; 1193 : 
; 1194 : 	if(memdc == NULL)

  02007	83 7d 08 00	 cmp	 DWORD PTR _memdc$[ebp], 0
  0200b	75 1f		 jne	 SHORT $L198716

; 1195 : 	{
; 1196 : 		RestoreDC( dc, iSaveDC );

  0200d	8b 55 f8	 mov	 edx, DWORD PTR _iSaveDC$[ebp]
  02010	52		 push	 edx
  02011	8b 45 fc	 mov	 eax, DWORD PTR _dc$[ebp]
  02014	50		 push	 eax
  02015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RestoreDC@8

; 1197 : 		::ReleaseDC(m_hWnd, dc);

  0201b	8b 4d fc	 mov	 ecx, DWORD PTR _dc$[ebp]
  0201e	51		 push	 ecx
  0201f	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  02022	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  02025	50		 push	 eax
  02026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
$L198716:

; 1198 : 	}
; 1199 : }

  0202c	8b e5		 mov	 esp, ebp
  0202e	5d		 pop	 ebp
  0202f	c2 04 00	 ret	 4
?OnPaint@CPictureEx@@QAEXPAUHDC__@@@Z ENDP		; CPictureEx::OnPaint
_TEXT	ENDS
EXTRN	__imp__GetSysColor@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -24						; size = 4
_hWinDC$ = -20						; size = 4
_rect$ = -16						; size = 16
_nWidth$ = 8						; size = 4
_nHeight$ = 12						; size = 4
?PrepareDC@CPictureEx@@IAEHHH@Z PROC NEAR		; CPictureEx::PrepareDC
; _this$ = ecx

; 1202 : {

  02040	55		 push	 ebp
  02041	8b ec		 mov	 ebp, esp
  02043	83 ec 18	 sub	 esp, 24			; 00000018H
  02046	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1203 : //	SetWindowPos(NULL,0,0,nWidth,nHeight,SWP_NOMOVE | SWP_NOZORDER);
; 1204 : 
; 1205 : 	HDC hWinDC = ::GetDC(m_hWnd);

  02049	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0204c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0204f	51		 push	 ecx
  02050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  02056	89 45 ec	 mov	 DWORD PTR _hWinDC$[ebp], eax

; 1206 : 	if (!hWinDC) return FALSE;

  02059	83 7d ec 00	 cmp	 DWORD PTR _hWinDC$[ebp], 0
  0205d	75 07		 jne	 SHORT $L198750
  0205f	33 c0		 xor	 eax, eax
  02061	e9 e9 00 00 00	 jmp	 $L198748
$L198750:

; 1207 : 	
; 1208 : 	m_hMemDC = CreateCompatibleDC(hWinDC);

  02066	8b 55 ec	 mov	 edx, DWORD PTR _hWinDC$[ebp]
  02069	52		 push	 edx
  0206a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  02070	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02073	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1209 : 	if (!m_hMemDC) 

  02076	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  02079	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  0207d	75 18		 jne	 SHORT $L198751

; 1210 : 	{
; 1211 : 		::ReleaseDC(m_hWnd,hWinDC);

  0207f	8b 45 ec	 mov	 eax, DWORD PTR _hWinDC$[ebp]
  02082	50		 push	 eax
  02083	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02086	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  02089	52		 push	 edx
  0208a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 1212 : 		return FALSE;

  02090	33 c0		 xor	 eax, eax
  02092	e9 b8 00 00 00	 jmp	 $L198748
$L198751:

; 1213 : 	};
; 1214 : 
; 1215 : 	m_hBitmap  = CreateCompatibleBitmap(hWinDC,nWidth,nHeight);

  02097	8b 45 0c	 mov	 eax, DWORD PTR _nHeight$[ebp]
  0209a	50		 push	 eax
  0209b	8b 4d 08	 mov	 ecx, DWORD PTR _nWidth$[ebp]
  0209e	51		 push	 ecx
  0209f	8b 55 ec	 mov	 edx, DWORD PTR _hWinDC$[ebp]
  020a2	52		 push	 edx
  020a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  020a9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  020ac	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 1216 : 	if (!m_hBitmap) 

  020af	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  020b2	83 7a 60 00	 cmp	 DWORD PTR [edx+96], 0
  020b6	75 22		 jne	 SHORT $L198752

; 1217 : 	{
; 1218 : 		::ReleaseDC(m_hWnd,hWinDC);

  020b8	8b 45 ec	 mov	 eax, DWORD PTR _hWinDC$[ebp]
  020bb	50		 push	 eax
  020bc	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  020bf	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  020c2	52		 push	 edx
  020c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 1219 : 		::DeleteDC(m_hMemDC);

  020c9	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  020cc	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  020cf	51		 push	 ecx
  020d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 1220 : 		return FALSE;

  020d6	33 c0		 xor	 eax, eax
  020d8	eb 75		 jmp	 SHORT $L198748
$L198752:

; 1221 : 	};
; 1222 : 
; 1223 : 	m_hOldBitmap = reinterpret_cast<HBITMAP> 
; 1224 : 						(SelectObject(m_hMemDC,m_hBitmap));

  020da	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  020dd	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  020e0	50		 push	 eax
  020e1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  020e4	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  020e7	52		 push	 edx
  020e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  020ee	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  020f1	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 1225 : 	
; 1226 : 	// fill the background
; 1227 : 	m_clrBackground = GetSysColor(COLOR_3DFACE);

  020f4	6a 0f		 push	 15			; 0000000fH
  020f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  020fc	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  020ff	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 1228 : 	RECT rect = {0,0,nWidth,nHeight};

  02102	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _rect$[ebp], 0
  02109	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _rect$[ebp+4], 0
  02110	8b 45 08	 mov	 eax, DWORD PTR _nWidth$[ebp]
  02113	89 45 f8	 mov	 DWORD PTR _rect$[ebp+8], eax
  02116	8b 4d 0c	 mov	 ecx, DWORD PTR _nHeight$[ebp]
  02119	89 4d fc	 mov	 DWORD PTR _rect$[ebp+12], ecx

; 1229 : 	FillRect(m_hMemDC,&rect,(HBRUSH)(COLOR_WINDOW));

  0211c	6a 05		 push	 5
  0211e	8d 55 f0	 lea	 edx, DWORD PTR _rect$[ebp]
  02121	52		 push	 edx
  02122	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  02125	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  02128	51		 push	 ecx
  02129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 1230 : 
; 1231 : 	::ReleaseDC(m_hWnd,hWinDC);

  0212f	8b 55 ec	 mov	 edx, DWORD PTR _hWinDC$[ebp]
  02132	52		 push	 edx
  02133	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  02136	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02139	51		 push	 ecx
  0213a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 1232 : 	m_bIsInitialized = TRUE;

  02140	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  02143	c7 42 48 01 00
	00 00		 mov	 DWORD PTR [edx+72], 1

; 1233 : 	return TRUE;

  0214a	b8 01 00 00 00	 mov	 eax, 1
$L198748:

; 1234 : }

  0214f	8b e5		 mov	 esp, ebp
  02151	5d		 pop	 ebp
  02152	c2 08 00	 ret	 8
?PrepareDC@CPictureEx@@IAEHHH@Z ENDP			; CPictureEx::PrepareDC
_TEXT	ENDS
PUBLIC	?SetBkColor@CPictureEx@@QAEXK@Z			; CPictureEx::SetBkColor
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -24						; size = 4
_rect$198763 = -20					; size = 16
_hBrush$ = -4						; size = 4
_clr$ = 8						; size = 4
?SetBkColor@CPictureEx@@QAEXK@Z PROC NEAR		; CPictureEx::SetBkColor
; _this$ = ecx

; 1243 : {

  02160	55		 push	 ebp
  02161	8b ec		 mov	 ebp, esp
  02163	83 ec 18	 sub	 esp, 24			; 00000018H
  02166	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1244 : 	if (!m_bIsInitialized) return;

  02169	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0216c	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  02170	75 02		 jne	 SHORT $L198760
  02172	eb 5b		 jmp	 SHORT $L198759
$L198760:

; 1245 : 
; 1246 : 	m_clrBackground = clr;

  02174	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  02177	8b 55 08	 mov	 edx, DWORD PTR _clr$[ebp]
  0217a	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 1247 : 
; 1248 : 	HBRUSH hBrush = CreateSolidBrush(clr);

  0217d	8b 45 08	 mov	 eax, DWORD PTR _clr$[ebp]
  02180	50		 push	 eax
  02181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  02187	89 45 fc	 mov	 DWORD PTR _hBrush$[ebp], eax

; 1249 : 	if (hBrush)

  0218a	83 7d fc 00	 cmp	 DWORD PTR _hBrush$[ebp], 0
  0218e	74 3f		 je	 SHORT $L198759

; 1250 : 	{
; 1251 : 		RECT rect = {0,0,m_PictureSize.cx,m_PictureSize.cy};

  02190	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _rect$198763[ebp], 0
  02197	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _rect$198763[ebp+4], 0
  0219e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  021a1	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  021a4	89 55 f4	 mov	 DWORD PTR _rect$198763[ebp+8], edx
  021a7	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  021aa	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  021ad	89 4d f8	 mov	 DWORD PTR _rect$198763[ebp+12], ecx

; 1252 : 		FillRect(m_hMemDC,&rect,hBrush);

  021b0	8b 55 fc	 mov	 edx, DWORD PTR _hBrush$[ebp]
  021b3	52		 push	 edx
  021b4	8d 45 ec	 lea	 eax, DWORD PTR _rect$198763[ebp]
  021b7	50		 push	 eax
  021b8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  021bb	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  021be	52		 push	 edx
  021bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 1253 : 		DeleteObject(hBrush);

  021c5	8b 45 fc	 mov	 eax, DWORD PTR _hBrush$[ebp]
  021c8	50		 push	 eax
  021c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
$L198759:

; 1254 : 	};
; 1255 : }

  021cf	8b e5		 mov	 esp, ebp
  021d1	5d		 pop	 ebp
  021d2	c2 04 00	 ret	 4
?SetBkColor@CPictureEx@@QAEXK@Z ENDP			; CPictureEx::SetBkColor
_TEXT	ENDS
PUBLIC	?SetPaintRect@CPictureEx@@QAEHPBUtagRECT@@@Z	; CPictureEx::SetPaintRect
EXTRN	__imp__CopyRect@8:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
?SetPaintRect@CPictureEx@@QAEHPBUtagRECT@@@Z PROC NEAR	; CPictureEx::SetPaintRect
; _this$ = ecx

; 1356 : {

  021e0	55		 push	 ebp
  021e1	8b ec		 mov	 ebp, esp
  021e3	51		 push	 ecx
  021e4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1357 : 	return CopyRect(&m_PaintRect, lpRect);

  021e7	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  021ea	50		 push	 eax
  021eb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  021ee	83 c1 10	 add	 ecx, 16			; 00000010H
  021f1	51		 push	 ecx
  021f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyRect@8

; 1358 : }

  021f8	8b e5		 mov	 esp, ebp
  021fa	5d		 pop	 ebp
  021fb	c2 04 00	 ret	 4
?SetPaintRect@CPictureEx@@QAEHPBUtagRECT@@@Z ENDP	; CPictureEx::SetPaintRect
_TEXT	ENDS
PUBLIC	?GetPaintRect@CPictureEx@@QAEHPAUtagRECT@@@Z	; CPictureEx::GetPaintRect
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
?GetPaintRect@CPictureEx@@QAEHPAUtagRECT@@@Z PROC NEAR	; CPictureEx::GetPaintRect
; _this$ = ecx

; 1361 : {

  02200	55		 push	 ebp
  02201	8b ec		 mov	 ebp, esp
  02203	51		 push	 ecx
  02204	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1362 : 	return CopyRect(lpRect, &m_PaintRect);

  02207	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0220a	83 c0 10	 add	 eax, 16			; 00000010H
  0220d	50		 push	 eax
  0220e	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  02211	51		 push	 ecx
  02212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyRect@8

; 1363 : }

  02218	8b e5		 mov	 esp, ebp
  0221a	5d		 pop	 ebp
  0221b	c2 04 00	 ret	 4
?GetPaintRect@CPictureEx@@QAEHPAUtagRECT@@@Z ENDP	; CPictureEx::GetPaintRect
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z ; std::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
PUBLIC	??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ	; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>
PUBLIC	?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Buy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z ; std::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::end
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L200079
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L200080
$L200079:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L200080:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::empty, COMDAT
; _this$ = ecx

; 525  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 526  : 		return (size() == 0);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  0000f	f7 d8		 neg	 eax
  00011	1b c0		 sbb	 eax, eax
  00013	40		 inc	 eax

; 527  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::empty
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+
; Function compile flags: /Odt
;	COMDAT ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T200086 = -8						; size = 4
$T200085 = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[], COMDAT
; _this$ = ecx

; 554  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		return (*(begin() + _Pos));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d f8	 lea	 ecx, DWORD PTR $T200086[ebp]
  00010	51		 push	 ecx
  00011	8d 55 fc	 lea	 edx, DWORD PTR $T200085[ebp]
  00014	52		 push	 edx
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator*

; 556  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::capacity
PUBLIC	?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::insert
PUBLIC	?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill
; Function compile flags: /Odt
;	COMDAT ?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T200090 = -8						; size = 4
$T200089 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0000a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  00012	8b f0		 mov	 esi, eax
  00014	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::capacity
  0001c	3b f0		 cmp	 esi, eax
  0001e	73 1d		 jae	 SHORT $L198849

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	50		 push	 eax
  00024	6a 01		 push	 1
  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	52		 push	 edx
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill
  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  0003b	eb 1f		 jmp	 SHORT $L198848
$L198849:

; 583  : 			insert(end(), _Val);

  0003d	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00040	52		 push	 edx
  00041	8d 45 fc	 lea	 eax, DWORD PTR $T200089[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::end
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	51		 push	 ecx
  00050	8d 55 f8	 lea	 edx, DWORD PTR $T200090[ebp]
  00053	52		 push	 edx
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::insert
$L198848:

; 584  : 		}

  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::push_back
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Tidy

; 745  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::clear
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator
; Function compile flags: /Odt
;	COMDAT ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator, COMDAT
; _this$ = ecx

; 209  : 		iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator

; 210  : 			{	// construct with null vector pointer
; 211  : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 236  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 237  : 			++*this;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++

; 238  : 			return (_Tmp);

  00019	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 239  : 			}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator<, COMDAT
; _this$ = ecx

; 164  : 			{	// test if this < _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 165  : 
; 166  : 
; 167  : 			return (_Myptr < _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00011	1b c0		 sbb	 eax, eax
  00013	f7 d8		 neg	 eax

; 168  : 			}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator<
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L200103
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L200104
$L200103:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L200104:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::capacity
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Insert_n
PUBLIC	??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator-
; Function compile flags: /Odt
;	COMDAT ?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
_this$ = -16						; size = 4
$T200110 = -12						; size = 4
$T200107 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  00011	85 c0		 test	 eax, eax
  00013	75 09		 jne	 SHORT $L200108
  00015	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0001c	eb 18		 jmp	 SHORT $L200109
$L200108:
  0001e	8d 45 f8	 lea	 eax, DWORD PTR $T200107[ebp]
  00021	50		 push	 eax
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
  0002a	50		 push	 eax
  0002b	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002e	e8 00 00 00 00	 call	 ??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator-
  00033	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$L200109:
  00036	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00039	89 4d fc	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0003c	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0003f	52		 push	 edx
  00040	6a 01		 push	 1
  00042	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00045	50		 push	 eax
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Insert_n

; 623  : 		return (begin() + _Off);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	52		 push	 edx
  00056	8d 45 f4	 lea	 eax, DWORD PTR $T200110[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+
  00069	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::allocate
PUBLIC	?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size
PUBLIC	?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Xlen
; Function compile flags: /Odt
;	COMDAT ?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L198889

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 49		 jmp	 SHORT $L198888
$L198889:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L198891

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Xlen

; 776  : 		else

  00044	eb 30		 jmp	 SHORT $L198890
$L198891:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00067	6b d2 1c	 imul	 edx, 28			; 0000001cH
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L198890:

; 781  : 			}
; 782  : 		return (true);

  00076	b0 01		 mov	 al, 1
$L198888:

; 783  : 		}

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::deallocate
PUBLIC	?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 3c		 je	 SHORT $L198895

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	8b c1		 mov	 eax, ecx
  00034	99		 cdq
  00035	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0003a	f7 f9		 idiv	 ecx
  0003c	50		 push	 eax
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::deallocate
$L198895:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Uninitialized_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt
;	COMDAT ?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Uninitialized_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00025	03 45 08	 add	 eax, DWORD PTR __Ptr$[ebp]

; 880  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>
; Function compile flags: /Odt
;	COMDAT ??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z PROC NEAR ; std::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z ENDP ; std::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ PROC NEAR ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ ENDP	; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 			++this->_Myptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 232  : 			}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+=
; Function compile flags: /Odt
;	COMDAT ??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 68   : 		const_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 69   : 			{	// construct with null pointer
; 70   : 			_Myptr = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 71   : 			}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ ; std::allocator<CPictureEx::TFrame>::max_size
; Function compile flags: /Odt
;	COMDAT ?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ ; std::allocator<CPictureEx::TFrame>::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>
PUBLIC	??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z ; std::fill<CPictureEx::TFrame *,CPictureEx::TFrame>
PUBLIC	??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z ; std::copy_backward<CPictureEx::TFrame *,CPictureEx::TFrame *>
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200147 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T200149 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L200141
$T200150 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L200143
$T200148 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T200149
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T200150
$T200145 DD	019930520H
	DD	04H
	DD	FLAT:$T200147
	DD	02H
	DD	FLAT:$T200148
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
tv241 = -76						; size = 4
tv240 = -72						; size = 4
tv86 = -68						; size = 4
_this$ = -64						; size = 4
__Oldend$199006 = -60					; size = 4
__Newvec$198985 = -56					; size = 4
__Ptr$198986 = -52					; size = 4
__Capacity$ = -48					; size = 4
__Tmp$ = -44						; size = 28
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 3c	 sub	 esp, 60			; 0000003cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00025	8b 75 10	 mov	 esi, DWORD PTR __Val$[ebp]
  00028	b9 07 00 00 00	 mov	 ecx, 7
  0002d	8d 7d d4	 lea	 edi, DWORD PTR __Tmp$[ebp]
  00030	f3 a5		 rep movsd

; 811  : 		size_type _Capacity = capacity();

  00032	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::capacity
  0003a	89 45 d0	 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  0003d	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00041	75 05		 jne	 SHORT $L198979

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00043	e9 d7 02 00 00	 jmp	 $L200136
$L198979:
  00048	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  00050	8b f0		 mov	 esi, eax
  00052	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size
  0005a	2b c6		 sub	 eax, esi
  0005c	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0005f	73 0d		 jae	 SHORT $L198981

; 816  : 			_Xlen();	// result too long

  00061	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  00069	e9 b1 02 00 00	 jmp	 $L200136
$L198981:
  0006e	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  00076	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00079	39 45 d0	 cmp	 DWORD PTR __Capacity$[ebp], eax
  0007c	0f 83 6d 01 00
	00		 jae	 $L198983

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00082	8b 75 d0	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00085	d1 ee		 shr	 esi, 1
  00087	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size
  0008f	2b c6		 sub	 eax, esi
  00091	3b 45 d0	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00094	73 09		 jae	 SHORT $L200137
  00096	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
  0009d	eb 0b		 jmp	 SHORT $L200138
$L200137:
  0009f	8b 45 d0	 mov	 eax, DWORD PTR __Capacity$[ebp]
  000a2	d1 e8		 shr	 eax, 1
  000a4	03 45 d0	 add	 eax, DWORD PTR __Capacity$[ebp]
  000a7	89 45 bc	 mov	 DWORD PTR tv86[ebp], eax
$L200138:
  000aa	8b 4d bc	 mov	 ecx, DWORD PTR tv86[ebp]
  000ad	89 4d d0	 mov	 DWORD PTR __Capacity$[ebp], ecx

; 821  : 			if (_Capacity < size() + _Count)

  000b0	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  000b8	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000bb	39 45 d0	 cmp	 DWORD PTR __Capacity$[ebp], eax
  000be	73 0e		 jae	 SHORT $L198984

; 822  : 				_Capacity = size() + _Count;

  000c0	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  000c8	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000cb	89 45 d0	 mov	 DWORD PTR __Capacity$[ebp], eax
$L198984:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000ce	8b 55 d0	 mov	 edx, DWORD PTR __Capacity$[ebp]
  000d1	52		 push	 edx
  000d2	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	e8 00 00 00 00	 call	 ?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::allocate
  000da	89 45 c8	 mov	 DWORD PTR __Newvec$198985[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  000dd	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$198985[ebp]
  000e0	89 45 cc	 mov	 DWORD PTR __Ptr$198986[ebp], eax

; 825  : 
; 826  : 			_TRY_BEGIN

  000e3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000ea	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$198985[ebp]
  000ed	51		 push	 ecx
  000ee	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  000f1	52		 push	 edx
  000f2	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f8	51		 push	 ecx
  000f9	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>
  00101	89 45 b8	 mov	 DWORD PTR tv240[ebp], eax
  00104	8b 55 b8	 mov	 edx, DWORD PTR tv240[ebp]
  00107	89 55 cc	 mov	 DWORD PTR __Ptr$198986[ebp], edx

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  0010a	8d 45 d4	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0010d	50		 push	 eax
  0010e	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00111	51		 push	 ecx
  00112	8b 55 cc	 mov	 edx, DWORD PTR __Ptr$198986[ebp]
  00115	52		 push	 edx
  00116	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill
  0011e	89 45 b4	 mov	 DWORD PTR tv241[ebp], eax
  00121	8b 45 b4	 mov	 eax, DWORD PTR tv241[ebp]
  00124	89 45 cc	 mov	 DWORD PTR __Ptr$198986[ebp], eax

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00127	8b 4d cc	 mov	 ecx, DWORD PTR __Ptr$198986[ebp]
  0012a	51		 push	 ecx
  0012b	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  0012e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00131	50		 push	 eax
  00132	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00135	51		 push	 ecx
  00136	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>
  0013e	eb 29		 jmp	 SHORT $L200140
$L200141:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  00140	8b 55 cc	 mov	 edx, DWORD PTR __Ptr$198986[ebp]
  00143	52		 push	 edx
  00144	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$198985[ebp]
  00147	50		 push	 eax
  00148	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0014b	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00150	8b 4d d0	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00153	51		 push	 ecx
  00154	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$198985[ebp]
  00157	52		 push	 edx
  00158	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::deallocate

; 834  : 			_RERAISE;

  00160	6a 00		 push	 0
  00162	6a 00		 push	 0
  00164	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200140:

; 835  : 			_CATCH_END

  00169	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 836  : 
; 837  : 			_Count += size();

  00170	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00173	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  00178	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  0017b	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  0017e	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00181	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00185	74 3c		 je	 SHORT $L198993

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  00187	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0018d	52		 push	 edx
  0018e	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00191	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00194	51		 push	 ecx
  00195	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0019d	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  001a0	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  001a3	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  001a6	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  001a9	8b c1		 mov	 eax, ecx
  001ab	99		 cdq
  001ac	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  001b1	f7 f9		 idiv	 ecx
  001b3	50		 push	 eax
  001b4	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  001b7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001ba	50		 push	 eax
  001bb	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001be	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::deallocate
$L198993:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001c3	8b 4d d0	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  001c6	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  001c9	03 4d c8	 add	 ecx, DWORD PTR __Newvec$198985[ebp]
  001cc	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  001cf	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 844  : 			_Mylast = _Newvec + _Count;

  001d2	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001d5	6b c0 1c	 imul	 eax, 28			; 0000001cH
  001d8	03 45 c8	 add	 eax, DWORD PTR __Newvec$198985[ebp]
  001db	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001de	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

  001e1	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  001e4	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$198985[ebp]
  001e7	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001ea	e9 30 01 00 00	 jmp	 $L200136
$L198983:
  001ef	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001f2	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001f5	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  001f8	99		 cdq
  001f9	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  001fe	f7 f9		 idiv	 ecx
  00200	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  00203	0f 83 b2 00 00
	00		 jae	 $L198996

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00209	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0020c	6b d2 1c	 imul	 edx, 28			; 0000001cH
  0020f	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  00212	52		 push	 edx
  00213	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00216	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00219	51		 push	 ecx
  0021a	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  0021d	52		 push	 edx
  0021e	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00221	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>

; 851  : 
; 852  : 			_TRY_BEGIN

  00226	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0022d	8d 45 d4	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00230	50		 push	 eax
  00231	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00237	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  0023a	99		 cdq
  0023b	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00240	f7 f9		 idiv	 ecx
  00242	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00245	2b d0		 sub	 edx, eax
  00247	52		 push	 edx
  00248	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0024b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0024e	51		 push	 ecx
  0024f	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00252	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill
  00257	eb 28		 jmp	 SHORT $L200142
$L200143:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  00259	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0025c	6b d2 1c	 imul	 edx, 28			; 0000001cH
  0025f	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00262	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00265	52		 push	 edx
  00266	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00269	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  0026c	03 4d 08	 add	 ecx, DWORD PTR __Where$[ebp]
  0026f	51		 push	 ecx
  00270	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00273	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy

; 857  : 			_RERAISE;

  00278	6a 00		 push	 0
  0027a	6a 00		 push	 0
  0027c	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200142:

; 858  : 			_CATCH_END

  00281	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 859  : 
; 860  : 			_Mylast += _Count;

  00288	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0028b	6b d2 1c	 imul	 edx, 28			; 0000001cH
  0028e	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00291	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00294	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00297	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  0029a	8d 55 d4	 lea	 edx, DWORD PTR __Tmp$[ebp]
  0029d	52		 push	 edx
  0029e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002a1	6b c0 1c	 imul	 eax, 28			; 0000001cH
  002a4	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  002a7	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002aa	2b d0		 sub	 edx, eax
  002ac	52		 push	 edx
  002ad	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  002b0	50		 push	 eax
  002b1	e8 00 00 00 00	 call	 ??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z ; std::fill<CPictureEx::TFrame *,CPictureEx::TFrame>
  002b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002b9	eb 64		 jmp	 SHORT $L200136
$L198996:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  002bb	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  002be	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002c1	89 55 c4	 mov	 DWORD PTR __Oldend$199006[ebp], edx

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002c4	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  002c7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002ca	51		 push	 ecx
  002cb	8b 55 c4	 mov	 edx, DWORD PTR __Oldend$199006[ebp]
  002ce	52		 push	 edx
  002cf	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002d2	6b c0 1c	 imul	 eax, 28			; 0000001cH
  002d5	8b 4d c4	 mov	 ecx, DWORD PTR __Oldend$199006[ebp]
  002d8	2b c8		 sub	 ecx, eax
  002da	51		 push	 ecx
  002db	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  002de	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>
  002e3	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  002e6	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  002e9	8b 45 c4	 mov	 eax, DWORD PTR __Oldend$199006[ebp]
  002ec	50		 push	 eax
  002ed	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002f0	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  002f3	8b 55 c4	 mov	 edx, DWORD PTR __Oldend$199006[ebp]
  002f6	2b d1		 sub	 edx, ecx
  002f8	52		 push	 edx
  002f9	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  002fc	50		 push	 eax
  002fd	e8 00 00 00 00	 call	 ??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z ; std::copy_backward<CPictureEx::TFrame *,CPictureEx::TFrame *>
  00302	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  00305	8d 4d d4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00308	51		 push	 ecx
  00309	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0030c	6b d2 1c	 imul	 edx, 28			; 0000001cH
  0030f	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  00312	52		 push	 edx
  00313	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00316	50		 push	 eax
  00317	e8 00 00 00 00	 call	 ??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z ; std::fill<CPictureEx::TFrame *,CPictureEx::TFrame>
  0031c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L200136:

; 873  : 			}
; 874  : 		}

  0031f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00322	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00329	5f		 pop	 edi
  0032a	5e		 pop	 esi
  0032b	5b		 pop	 ebx
  0032c	8b e5		 mov	 esp, ebp
  0032e	5d		 pop	 ebp
  0032f	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200145
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Insert_n
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200161 DD	0ffffffffH
	DD	FLAT:$L200157
$T200159 DD	019930520H
	DD	01H
	DD	FLAT:$T200161
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
	ORG $-30
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T200156 = -80						; size = 28
$T200155 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T200156[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T200156[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T200155[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T200155[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200154:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200157:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T200156[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200159
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z PROC NEAR ; std::allocator<CPictureEx::TFrame>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z ENDP ; std::allocator<CPictureEx::TFrame>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z ; std::_Allocate<CPictureEx::TFrame>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z PROC NEAR ; std::allocator<CPictureEx::TFrame>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z ; std::_Allocate<CPictureEx::TFrame>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z ENDP ; std::allocator<CPictureEx::TFrame>::allocate
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 01		 add	 eax, DWORD PTR [ecx]
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	89 02		 mov	 DWORD PTR [edx], eax

; 257  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator-
; Function compile flags: /Odt
;	COMDAT ??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T200174 = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR $T200174[ebp], ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR $T200174[ebp]
  00018	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator-

; 280  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator-
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ PROC NEAR ; std::allocator<CPictureEx::TFrame>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc 49 92
	24 09		 mov	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L200182
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L200183
$L200182:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L200183:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ ENDP ; std::allocator<CPictureEx::TFrame>::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	99		 cdq
  00012	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00017	f7 f9		 idiv	 ecx

; 144  : 			}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??0CObject@@IAE@XZ				; CObject::CObject
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z ; CArray<CRect,CRect>::Serialize
PUBLIC	??_7?$CArray@VCRect@@V1@@@6B@			; CArray<CRect,CRect>::`vftable'
PUBLIC	??_G?$CArray@VCRect@@V1@@@UAEPAXI@Z		; CArray<CRect,CRect>::`scalar deleting destructor'
PUBLIC	??_R4?$CArray@VCRect@@V1@@@6B@			; CArray<CRect,CRect>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CArray@VCRect@@V1@@@@8		; CArray<CRect,CRect> `RTTI Type Descriptor'
PUBLIC	??_R3?$CArray@VCRect@@V1@@@8			; CArray<CRect,CRect>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CArray@VCRect@@V1@@@8			; CArray<CRect,CRect>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@?$CArray@VCRect@@V1@@@8		; CArray<CRect,CRect>::`RTTI Base Class Descriptor at (0,-1,0,0)'
EXTRN	?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ:NEAR ; CObject::GetRuntimeClass
EXTRN	??_E?$CArray@VCRect@@V1@@@UAEPAXI@Z:NEAR	; CArray<CRect,CRect>::`vector deleting destructor'
;	COMDAT ??_7?$CArray@VCRect@@V1@@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
CONST	SEGMENT
??_7?$CArray@VCRect@@V1@@@6B@ DD FLAT:??_R4?$CArray@VCRect@@V1@@@6B@ ; CArray<CRect,CRect>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CArray@VCRect@@V1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4?$CArray@VCRect@@V1@@@6B@
rdata$r	SEGMENT
??_R4?$CArray@VCRect@@V1@@@6B@ DD 00H			; CArray<CRect,CRect>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CArray@VCRect@@V1@@@@8
	DD	FLAT:??_R3?$CArray@VCRect@@V1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CArray@VCRect@@V1@@@@8
_DATA	SEGMENT
??_R0?AV?$CArray@VCRect@@V1@@@@8 DD FLAT:??_7type_info@@6B@ ; CArray<CRect,CRect> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CArray@VCRect@@V1@@@', 00H
_DATA	ENDS
;	COMDAT ??_R3?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT
??_R3?$CArray@VCRect@@V1@@@8 DD 00H			; CArray<CRect,CRect>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CArray@VCRect@@V1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT
??_R2?$CArray@VCRect@@V1@@@8 DD FLAT:??_R1A@?0A@A@?$CArray@VCRect@@V1@@@8 ; CArray<CRect,CRect>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT
??_R1A@?0A@A@?$CArray@VCRect@@V1@@@8 DD FLAT:??_R0?AV?$CArray@VCRect@@V1@@@@8 ; CArray<CRect,CRect>::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0?$CArray@VCRect@@V1@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CArray@VCRect@@V1@@@QAE@XZ PROC NEAR		; CArray<CRect,CRect>::CArray<CRect,CRect>, COMDAT
; _this$ = ecx

; 349  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CObject@@IAE@XZ	; CObject::CObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@VCRect@@V1@@@6B@

; 350  : 	m_pData = NULL;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 351  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 352  : }

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??0?$CArray@VCRect@@V1@@@QAE@XZ ENDP			; CArray<CRect,CRect>::CArray<CRect,CRect>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ PROC NEAR		; CArray<CRect,CRect>::GetSize, COMDAT
; _this$ = ecx

; 272  : 	{ return m_nSize; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ ENDP		; CArray<CRect,CRect>::GetSize
_TEXT	ENDS
PUBLIC	?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z		; CArray<CRect,CRect>::SetSize
; Function compile flags: /Odt
;	COMDAT ?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ PROC NEAR	; CArray<CRect,CRect>::RemoveAll, COMDAT
; _this$ = ecx

; 284  : 	{ SetSize(0, -1); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a ff		 push	 -1
  00009	6a 00		 push	 0
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z ; CArray<CRect,CRect>::SetSize
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ ENDP		; CArray<CRect,CRect>::RemoveAll
_TEXT	ENDS
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:NEAR	; AfxThrowInvalidArgException
; Function compile flags: /Odt
;	COMDAT ?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z PROC NEAR	; CArray<CRect,CRect>::GetAt, COMDAT
; _this$ = ecx

; 287  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 288  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 289  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7c 19		 jl	 SHORT $L199084
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00013	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00016	7d 0e		 jge	 SHORT $L199084

; 290  : 		return m_pData[nIndex]; 

  00018	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  0001b	c1 e0 04	 shl	 eax, 4
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00024	eb 05		 jmp	 SHORT $L200194
$L199084:

; 291  : 	AfxThrowInvalidArgException();		

  00026	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L200194:

; 292  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z ENDP	; CArray<CRect,CRect>::GetAt
_TEXT	ENDS
EXTRN	?AfxTryCleanup@@YGXXZ:NEAR			; AfxTryCleanup
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.h
;	COMDAT ??1AFX_EXCEPTION_LINK@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1AFX_EXCEPTION_LINK@@QAE@XZ PROC NEAR			; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK, COMDAT
; _this$ = ecx

; 819  : 		{ AfxTryCleanup(); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	e8 00 00 00 00	 call	 ?AfxTryCleanup@@YGXXZ	; AfxTryCleanup
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??1AFX_EXCEPTION_LINK@@QAE@XZ ENDP			; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK
_TEXT	ENDS
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z ; SerializeElements<CRect>
PUBLIC	?IsStoring@CArchive@@QBEHXZ			; CArchive::IsStoring
EXTRN	?ReadCount@CArchive@@QAEKXZ:NEAR		; CArchive::ReadCount
EXTRN	?WriteCount@CArchive@@QAEXK@Z:NEAR		; CArchive::WriteCount
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nOldSize$199114 = -4					; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z PROC NEAR ; CArray<CRect,CRect>::Serialize, COMDAT
; _this$ = ecx

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 630  : 	ASSERT_VALID(this);
; 631  : 
; 632  : 	CObject::Serialize(ar);

  00009	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?Serialize@CObject@@UAEXAAVCArchive@@@Z ; CObject::Serialize

; 633  : 	if (ar.IsStoring())

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00018	e8 00 00 00 00	 call	 ?IsStoring@CArchive@@QBEHXZ ; CArchive::IsStoring
  0001d	85 c0		 test	 eax, eax
  0001f	74 11		 je	 SHORT $L199112

; 634  : 	{
; 635  : 		ar.WriteCount(m_nSize);

  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00027	52		 push	 edx
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0002b	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 636  : 	}
; 637  : 	else

  00030	eb 19		 jmp	 SHORT $L199113
$L199112:

; 638  : 	{
; 639  : 		DWORD_PTR nOldSize = ar.ReadCount();

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00035	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount
  0003a	89 45 fc	 mov	 DWORD PTR _nOldSize$199114[ebp], eax

; 640  : 		SetSize(nOldSize, -1);

  0003d	6a ff		 push	 -1
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _nOldSize$199114[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z ; CArray<CRect,CRect>::SetSize
$L199113:

; 641  : 	}
; 642  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00051	52		 push	 edx
  00052	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00058	51		 push	 ecx
  00059	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z ; SerializeElements<CRect>

; 643  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z ENDP ; CArray<CRect,CRect>::Serialize
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
PUBLIC	??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT
$T200201 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00004	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T200201[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T200201[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT
$T200204 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z PROC NEAR ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T200204[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T200204[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ENDP ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Uninitialized_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Uninitialized_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z PROC NEAR ; std::fill<CPictureEx::TFrame *,CPictureEx::TFrame>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1135 : 	for (; _First != _Last; ++_First)

  00005	eb 09		 jmp	 SHORT $L199261
$L199262:
  00007	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000a	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000d	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L199261:
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00013	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00016	74 0f		 je	 SHORT $L199260

; 1136 : 		*_First = _Val;

  00018	8b 75 10	 mov	 esi, DWORD PTR __Val$[ebp]
  0001b	b9 07 00 00 00	 mov	 ecx, 7
  00020	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00023	f3 a5		 rep movsd
  00025	eb e0		 jmp	 SHORT $L199262
$L199260:

; 1137 : 	}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z ENDP ; std::fill<CPictureEx::TFrame *,CPictureEx::TFrame>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CPictureEx::TFrame *,CPictureEx::TFrame *>
; Function compile flags: /Odt
;	COMDAT ??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z
_TEXT	SEGMENT
$T200211 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z PROC NEAR ; std::copy_backward<CPictureEx::TFrame *,CPictureEx::TFrame *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T200211[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T200211[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CPictureEx::TFrame *,CPictureEx::TFrame *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z ENDP ; std::copy_backward<CPictureEx::TFrame *,CPictureEx::TFrame *>
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z PROC NEAR ; std::_Allocate<CPictureEx::TFrame>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z ENDP ; std::_Allocate<CPictureEx::TFrame>
_TEXT	ENDS
PUBLIC	??1?$CArray@VCRect@@V1@@@UAE@XZ			; CArray<CRect,CRect>::~CArray<CRect,CRect>
; Function compile flags: /Odt
;	COMDAT ??_G?$CArray@VCRect@@V1@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CArray@VCRect@@V1@@@UAEPAXI@Z PROC NEAR		; CArray<CRect,CRect>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CArray@VCRect@@V1@@@UAE@XZ ; CArray<CRect,CRect>::~CArray<CRect,CRect>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L199288
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L199288:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_G?$CArray@VCRect@@V1@@@UAEPAXI@Z ENDP		; CArray<CRect,CRect>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CArray@VCRect@@V1@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T200218 = -8						; size = 4
_i$199099 = -4						; size = 4
??1?$CArray@VCRect@@V1@@@UAE@XZ PROC NEAR		; CArray<CRect,CRect>::~CArray<CRect,CRect>, COMDAT
; _this$ = ecx

; 356  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@VCRect@@V1@@@6B@

; 357  : 	ASSERT_VALID(this);
; 358  : 
; 359  : 	if (m_pData != NULL)

  00012	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00019	74 34		 je	 SHORT $L199096

; 360  : 	{
; 361  : 		for( int i = 0; i < m_nSize; i++ )

  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$199099[ebp], 0
  00022	eb 09		 jmp	 SHORT $L199100
$L199101:
  00024	8b 55 fc	 mov	 edx, DWORD PTR _i$199099[ebp]
  00027	83 c2 01	 add	 edx, 1
  0002a	89 55 fc	 mov	 DWORD PTR _i$199099[ebp], edx
$L199100:
  0002d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _i$199099[ebp]
  00033	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00036	7d 02		 jge	 SHORT $L199102

; 362  : 			(m_pData + i)->~TYPE();

  00038	eb ea		 jmp	 SHORT $L199101
$L199102:

; 363  : 		delete[] (BYTE*)m_pData;

  0003a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00040	89 45 f8	 mov	 DWORD PTR $T200218[ebp], eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR $T200218[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0004c	83 c4 04	 add	 esp, 4
$L199096:

; 364  : 	}
; 365  : }

  0004f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ??1CObject@@UAE@XZ	; CObject::~CObject
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
??1?$CArray@VCRect@@V1@@@UAE@XZ ENDP			; CArray<CRect,CRect>::~CArray<CRect,CRect>
_TEXT	ENDS
PUBLIC	??0CRect@@QAE@XZ				; CRect::CRect
PUBLIC	??2@YAPAXIPAX@Z					; operator new
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	_memset:NEAR
; Function compile flags: /Odt
;	COMDAT ?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z
_TEXT	SEGMENT
tv225 = -88						; size = 4
tv183 = -84						; size = 4
tv184 = -80						; size = 4
tv169 = -76						; size = 4
tv136 = -72						; size = 4
tv83 = -68						; size = 4
_this$ = -64						; size = 4
$T200240 = -60						; size = 4
$T200237 = -56						; size = 4
$T200236 = -52						; size = 4
$T200229 = -48						; size = 4
$T200226 = -44						; size = 4
$T200225 = -40						; size = 4
$T200222 = -36						; size = 4
_i$199366 = -32						; size = 4
_pNewData$199354 = -28					; size = 4
_nNewMax$199348 = -24					; size = 4
_i$199342 = -20						; size = 4
_i$199333 = -16						; size = 4
_i$199320 = -12						; size = 4
_nAllocSize$199311 = -8					; size = 4
_i$199302 = -4						; size = 4
_nNewSize$ = 8						; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z PROC NEAR	; CArray<CRect,CRect>::SetSize, COMDAT
; _this$ = ecx

; 369  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 370  : 	ASSERT_VALID(this);
; 371  : 	ASSERT(nNewSize >= 0);
; 372  : 
; 373  : 	if(nNewSize < 0 )

  00009	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  0000d	7d 05		 jge	 SHORT $L199298

; 374  : 		AfxThrowInvalidArgException();

  0000f	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L199298:

; 375  : 
; 376  : 	if (nGrowBy >= 0)

  00014	83 7d 0c 00	 cmp	 DWORD PTR _nGrowBy$[ebp], 0
  00018	7c 09		 jl	 SHORT $L199299

; 377  : 		m_nGrowBy = nGrowBy;  // set new size

  0001a	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _nGrowBy$[ebp]
  00020	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$L199299:

; 378  : 
; 379  : 	if (nNewSize == 0)

  00023	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  00027	75 60		 jne	 SHORT $L199300

; 380  : 	{
; 381  : 		// shrink to nothing
; 382  : 		if (m_pData != NULL)

  00029	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00030	74 3e		 je	 SHORT $L199301

; 383  : 		{
; 384  : 			for( int i = 0; i < m_nSize; i++ )

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$199302[ebp], 0
  00039	eb 09		 jmp	 SHORT $L199303
$L199304:
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _i$199302[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 fc	 mov	 DWORD PTR _i$199302[ebp], eax
$L199303:
  00044	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 55 fc	 mov	 edx, DWORD PTR _i$199302[ebp]
  0004a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004d	7d 02		 jge	 SHORT $L199305

; 385  : 				(m_pData + i)->~TYPE();

  0004f	eb ea		 jmp	 SHORT $L199304
$L199305:

; 386  : 			delete[] (BYTE*)m_pData;

  00051	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00057	89 4d dc	 mov	 DWORD PTR $T200222[ebp], ecx
  0005a	8b 55 dc	 mov	 edx, DWORD PTR $T200222[ebp]
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00063	83 c4 04	 add	 esp, 4

; 387  : 			m_pData = NULL;

  00066	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L199301:

; 388  : 		}
; 389  : 		m_nSize = m_nMaxSize = 0;

  00070	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0007a	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 390  : 	}
; 391  : 	else if (m_pData == NULL)

  00084	e9 1b 03 00 00	 jmp	 $L200221
$L199300:
  00089	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00090	0f 85 bc 00 00
	00		 jne	 $L199309

; 392  : 	{
; 393  : 		// create buffer big enough to hold number of requested elements or
; 394  : 		// m_nGrowBy elements, whichever is larger.
; 395  : #ifdef SIZE_T_MAX
; 396  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 397  : #endif
; 398  : 		size_t nAllocSize = max(nNewSize, m_nGrowBy);

  00096	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  0009c	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0009f	7e 08		 jle	 SHORT $L200223
  000a1	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  000a4	89 45 bc	 mov	 DWORD PTR tv83[ebp], eax
  000a7	eb 09		 jmp	 SHORT $L200224
$L200223:
  000a9	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000af	89 55 bc	 mov	 DWORD PTR tv83[ebp], edx
$L200224:
  000b2	8b 45 bc	 mov	 eax, DWORD PTR tv83[ebp]
  000b5	89 45 f8	 mov	 DWORD PTR _nAllocSize$199311[ebp], eax

; 399  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _nAllocSize$199311[ebp]
  000bb	c1 e1 04	 shl	 ecx, 4
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000c4	83 c4 04	 add	 esp, 4
  000c7	89 45 d8	 mov	 DWORD PTR $T200225[ebp], eax
  000ca	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  000cd	8b 45 d8	 mov	 eax, DWORD PTR $T200225[ebp]
  000d0	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 400  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  000d3	8b 4d f8	 mov	 ecx, DWORD PTR _nAllocSize$199311[ebp]
  000d6	c1 e1 04	 shl	 ecx, 4
  000d9	51		 push	 ecx
  000da	6a 00		 push	 0
  000dc	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  000df	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 _memset
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 401  : 		for( int i = 0; i < nNewSize; i++ )

  000eb	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$199320[ebp], 0
  000f2	eb 09		 jmp	 SHORT $L199321
$L199322:
  000f4	8b 4d f4	 mov	 ecx, DWORD PTR _i$199320[ebp]
  000f7	83 c1 01	 add	 ecx, 1
  000fa	89 4d f4	 mov	 DWORD PTR _i$199320[ebp], ecx
$L199321:
  000fd	8b 55 f4	 mov	 edx, DWORD PTR _i$199320[ebp]
  00100	3b 55 08	 cmp	 edx, DWORD PTR _nNewSize$[ebp]
  00103	7d 36		 jge	 SHORT $L199323

; 402  : #pragma push_macro("new")
; 403  : #undef new
; 404  : 			::new( (void*)( m_pData + i ) ) TYPE;

  00105	8b 45 f4	 mov	 eax, DWORD PTR _i$199320[ebp]
  00108	c1 e0 04	 shl	 eax, 4
  0010b	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00111	50		 push	 eax
  00112	6a 10		 push	 16			; 00000010H
  00114	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00119	83 c4 08	 add	 esp, 8
  0011c	89 45 d4	 mov	 DWORD PTR $T200226[ebp], eax
  0011f	83 7d d4 00	 cmp	 DWORD PTR $T200226[ebp], 0
  00123	74 0d		 je	 SHORT $L200227
  00125	8b 4d d4	 mov	 ecx, DWORD PTR $T200226[ebp]
  00128	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect
  0012d	89 45 b8	 mov	 DWORD PTR tv136[ebp], eax
  00130	eb 07		 jmp	 SHORT $L200228
$L200227:
  00132	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
$L200228:
  00139	eb b9		 jmp	 SHORT $L199322
$L199323:

; 405  : #pragma pop_macro("new")
; 406  : 		m_nSize = nNewSize;

  0013b	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  0013e	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00141	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 407  : 		m_nMaxSize = nAllocSize;

  00144	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00147	8b 55 f8	 mov	 edx, DWORD PTR _nAllocSize$199311[ebp]
  0014a	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 408  : 	}
; 409  : 	else if (nNewSize <= m_nMaxSize)

  0014d	e9 52 02 00 00	 jmp	 $L200221
$L199309:
  00152	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00155	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  00158	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0015b	0f 8f d6 00 00
	00		 jg	 $L199328

; 410  : 	{
; 411  : 		// it fits
; 412  : 		if (nNewSize > m_nSize)

  00161	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00164	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00167	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0016a	0f 8e 8c 00 00
	00		 jle	 $L199329

; 413  : 		{
; 414  : 			// initialize the new elements
; 415  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00170	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00173	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00176	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  00179	c1 e2 04	 shl	 edx, 4
  0017c	52		 push	 edx
  0017d	6a 00		 push	 0
  0017f	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00182	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00185	c1 e1 04	 shl	 ecx, 4
  00188	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  0018b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0018e	51		 push	 ecx
  0018f	e8 00 00 00 00	 call	 _memset
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH

; 416  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )

  00197	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$199333[ebp], 0
  0019e	eb 09		 jmp	 SHORT $L199334
$L199335:
  001a0	8b 45 f0	 mov	 eax, DWORD PTR _i$199333[ebp]
  001a3	83 c0 01	 add	 eax, 1
  001a6	89 45 f0	 mov	 DWORD PTR _i$199333[ebp], eax
$L199334:
  001a9	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ac	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  001af	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  001b2	39 55 f0	 cmp	 DWORD PTR _i$199333[ebp], edx
  001b5	7d 43		 jge	 SHORT $L199336

; 417  : #pragma push_macro("new")
; 418  : #undef new
; 419  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;

  001b7	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  001ba	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001bd	c1 e1 04	 shl	 ecx, 4
  001c0	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  001c3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001c6	03 c1		 add	 eax, ecx
  001c8	8b 4d f0	 mov	 ecx, DWORD PTR _i$199333[ebp]
  001cb	c1 e1 04	 shl	 ecx, 4
  001ce	03 c1		 add	 eax, ecx
  001d0	50		 push	 eax
  001d1	6a 10		 push	 16			; 00000010H
  001d3	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  001d8	83 c4 08	 add	 esp, 8
  001db	89 45 d0	 mov	 DWORD PTR $T200229[ebp], eax
  001de	83 7d d0 00	 cmp	 DWORD PTR $T200229[ebp], 0
  001e2	74 0d		 je	 SHORT $L200230
  001e4	8b 4d d0	 mov	 ecx, DWORD PTR $T200229[ebp]
  001e7	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect
  001ec	89 45 b4	 mov	 DWORD PTR tv169[ebp], eax
  001ef	eb 07		 jmp	 SHORT $L200231
$L200230:
  001f1	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv169[ebp], 0
$L200231:
  001f8	eb a6		 jmp	 SHORT $L199335
$L199336:

; 420  : #pragma pop_macro("new")
; 421  : 		}
; 422  : 		else if (m_nSize > nNewSize)

  001fa	eb 2d		 jmp	 SHORT $L199340
$L199329:
  001fc	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  001ff	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00202	3b 45 08	 cmp	 eax, DWORD PTR _nNewSize$[ebp]
  00205	7e 22		 jle	 SHORT $L199340

; 423  : 		{
; 424  : 			// destroy the old elements
; 425  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )

  00207	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$199342[ebp], 0
  0020e	eb 09		 jmp	 SHORT $L199343
$L199344:
  00210	8b 4d ec	 mov	 ecx, DWORD PTR _i$199342[ebp]
  00213	83 c1 01	 add	 ecx, 1
  00216	89 4d ec	 mov	 DWORD PTR _i$199342[ebp], ecx
$L199343:
  00219	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  0021c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0021f	2b 45 08	 sub	 eax, DWORD PTR _nNewSize$[ebp]
  00222	39 45 ec	 cmp	 DWORD PTR _i$199342[ebp], eax
  00225	7d 02		 jge	 SHORT $L199340

; 426  : 				(m_pData + nNewSize + i)->~TYPE();

  00227	eb e7		 jmp	 SHORT $L199344
$L199340:

; 427  : 		}
; 428  : 		m_nSize = nNewSize;

  00229	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0022c	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  0022f	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 429  : 	}
; 430  : 	else

  00232	e9 6d 01 00 00	 jmp	 $L200221
$L199328:

; 431  : 	{
; 432  : 		// otherwise, grow array
; 433  : 		nGrowBy = m_nGrowBy;

  00237	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0023a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0023d	89 4d 0c	 mov	 DWORD PTR _nGrowBy$[ebp], ecx

; 434  : 		if (nGrowBy == 0)

  00240	83 7d 0c 00	 cmp	 DWORD PTR _nGrowBy$[ebp], 0
  00244	75 45		 jne	 SHORT $L199347

; 435  : 		{
; 436  : 			// heuristically determine growth when nGrowBy == 0
; 437  : 			//  (this avoids heap fragmentation in many situations)
; 438  : 			nGrowBy = m_nSize / 8;

  00246	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00249	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0024c	99		 cdq
  0024d	83 e2 07	 and	 edx, 7
  00250	03 c2		 add	 eax, edx
  00252	c1 f8 03	 sar	 eax, 3
  00255	89 45 0c	 mov	 DWORD PTR _nGrowBy$[ebp], eax

; 439  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  00258	83 7d 0c 04	 cmp	 DWORD PTR _nGrowBy$[ebp], 4
  0025c	7d 09		 jge	 SHORT $L200234
  0025e	c7 45 b0 04 00
	00 00		 mov	 DWORD PTR tv184[ebp], 4
  00265	eb 1e		 jmp	 SHORT $L200235
$L200234:
  00267	81 7d 0c 00 04
	00 00		 cmp	 DWORD PTR _nGrowBy$[ebp], 1024 ; 00000400H
  0026e	7e 09		 jle	 SHORT $L200232
  00270	c7 45 ac 00 04
	00 00		 mov	 DWORD PTR tv183[ebp], 1024 ; 00000400H
  00277	eb 06		 jmp	 SHORT $L200233
$L200232:
  00279	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  0027c	89 45 ac	 mov	 DWORD PTR tv183[ebp], eax
$L200233:
  0027f	8b 4d ac	 mov	 ecx, DWORD PTR tv183[ebp]
  00282	89 4d b0	 mov	 DWORD PTR tv184[ebp], ecx
$L200235:
  00285	8b 55 b0	 mov	 edx, DWORD PTR tv184[ebp]
  00288	89 55 0c	 mov	 DWORD PTR _nGrowBy$[ebp], edx
$L199347:

; 440  : 		}
; 441  : 		INT_PTR nNewMax;
; 442  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  0028b	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0028e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00291	03 4d 0c	 add	 ecx, DWORD PTR _nGrowBy$[ebp]
  00294	39 4d 08	 cmp	 DWORD PTR _nNewSize$[ebp], ecx
  00297	7d 0e		 jge	 SHORT $L199349

; 443  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity

  00299	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  0029c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0029f	03 45 0c	 add	 eax, DWORD PTR _nGrowBy$[ebp]
  002a2	89 45 e8	 mov	 DWORD PTR _nNewMax$199348[ebp], eax

; 444  : 		else

  002a5	eb 06		 jmp	 SHORT $L199350
$L199349:

; 445  : 			nNewMax = nNewSize;  // no slush

  002a7	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  002aa	89 4d e8	 mov	 DWORD PTR _nNewMax$199348[ebp], ecx
$L199350:

; 446  : 
; 447  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 448  : 		
; 449  : 		if(nNewMax  < m_nMaxSize)

  002ad	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  002b0	8b 45 e8	 mov	 eax, DWORD PTR _nNewMax$199348[ebp]
  002b3	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  002b6	7d 05		 jge	 SHORT $L199352

; 450  : 			AfxThrowInvalidArgException();

  002b8	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L199352:

; 451  : 
; 452  : #ifdef SIZE_T_MAX
; 453  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 454  : #endif
; 455  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  002bd	8b 4d e8	 mov	 ecx, DWORD PTR _nNewMax$199348[ebp]
  002c0	c1 e1 04	 shl	 ecx, 4
  002c3	51		 push	 ecx
  002c4	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002c9	83 c4 04	 add	 esp, 4
  002cc	89 45 cc	 mov	 DWORD PTR $T200236[ebp], eax
  002cf	8b 55 cc	 mov	 edx, DWORD PTR $T200236[ebp]
  002d2	89 55 e4	 mov	 DWORD PTR _pNewData$199354[ebp], edx

; 456  : 
; 457  : 		// copy new data from old
; 458  : 		memcpy(pNewData, m_pData, (size_t)m_nSize * sizeof(TYPE));

  002d5	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  002d8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002db	c1 e1 04	 shl	 ecx, 4
  002de	51		 push	 ecx
  002df	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  002e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002e5	50		 push	 eax
  002e6	8b 4d e4	 mov	 ecx, DWORD PTR _pNewData$199354[ebp]
  002e9	51		 push	 ecx
  002ea	e8 00 00 00 00	 call	 _memcpy
  002ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 459  : 
; 460  : 		// construct remaining elements
; 461  : 		ASSERT(nNewSize > m_nSize);
; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  002f2	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  002f5	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  002f8	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  002fb	c1 e0 04	 shl	 eax, 4
  002fe	50		 push	 eax
  002ff	6a 00		 push	 0
  00301	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00304	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00307	c1 e2 04	 shl	 edx, 4
  0030a	03 55 e4	 add	 edx, DWORD PTR _pNewData$199354[ebp]
  0030d	52		 push	 edx
  0030e	e8 00 00 00 00	 call	 _memset
  00313	83 c4 0c	 add	 esp, 12			; 0000000cH

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )

  00316	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$199366[ebp], 0
  0031d	eb 09		 jmp	 SHORT $L199367
$L199368:
  0031f	8b 45 e0	 mov	 eax, DWORD PTR _i$199366[ebp]
  00322	83 c0 01	 add	 eax, 1
  00325	89 45 e0	 mov	 DWORD PTR _i$199366[ebp], eax
$L199367:
  00328	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0032b	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  0032e	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  00331	39 55 e0	 cmp	 DWORD PTR _i$199366[ebp], edx
  00334	7d 3e		 jge	 SHORT $L199369

; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;

  00336	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00339	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0033c	c1 e1 04	 shl	 ecx, 4
  0033f	03 4d e4	 add	 ecx, DWORD PTR _pNewData$199354[ebp]
  00342	8b 55 e0	 mov	 edx, DWORD PTR _i$199366[ebp]
  00345	c1 e2 04	 shl	 edx, 4
  00348	03 ca		 add	 ecx, edx
  0034a	51		 push	 ecx
  0034b	6a 10		 push	 16			; 00000010H
  0034d	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00352	83 c4 08	 add	 esp, 8
  00355	89 45 c8	 mov	 DWORD PTR $T200237[ebp], eax
  00358	83 7d c8 00	 cmp	 DWORD PTR $T200237[ebp], 0
  0035c	74 0d		 je	 SHORT $L200238
  0035e	8b 4d c8	 mov	 ecx, DWORD PTR $T200237[ebp]
  00361	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect
  00366	89 45 a8	 mov	 DWORD PTR tv225[ebp], eax
  00369	eb 07		 jmp	 SHORT $L200239
$L200238:
  0036b	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv225[ebp], 0
$L200239:
  00372	eb ab		 jmp	 SHORT $L199368
$L199369:

; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  00374	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00377	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0037a	89 4d c4	 mov	 DWORD PTR $T200240[ebp], ecx
  0037d	8b 55 c4	 mov	 edx, DWORD PTR $T200240[ebp]
  00380	52		 push	 edx
  00381	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00386	83 c4 04	 add	 esp, 4

; 471  : 		m_pData = pNewData;

  00389	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0038c	8b 4d e4	 mov	 ecx, DWORD PTR _pNewData$199354[ebp]
  0038f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 472  : 		m_nSize = nNewSize;

  00392	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00395	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00398	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 473  : 		m_nMaxSize = nNewMax;

  0039b	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0039e	8b 55 e8	 mov	 edx, DWORD PTR _nNewMax$199348[ebp]
  003a1	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L200221:

; 474  : 	}
; 475  : }

  003a4	8b e5		 mov	 esp, ebp
  003a6	5d		 pop	 ebp
  003a7	c2 08 00	 ret	 8
?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z ENDP		; CArray<CRect,CRect>::SetSize
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
EXTRN	?Read@CArchive@@QAEIPAXI@Z:NEAR			; CArchive::Read
EXTRN	?Write@CArchive@@QAEXPBXI@Z:NEAR		; CArchive::Write
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z
_TEXT	SEGMENT
tv79 = -32						; size = 4
tv69 = -28						; size = 4
_nElementsToRead$199404 = -24				; size = 4
_nElementsLeft$199400 = -20				; size = 4
_pData$199399 = -16					; size = 4
_nElementsToWrite$199394 = -12				; size = 4
_nElementsLeft$199390 = -8				; size = 4
_pData$199389 = -4					; size = 4
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z PROC NEAR ; SerializeElements<CRect>, COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 70   : 	ASSERT(nCount == 0 ||
; 71   : 		AfxIsValidAddress(pElements, (size_t)nCount * sizeof(TYPE)));
; 72   : 
; 73   : 	// default is bit-wise read/write
; 74   : 	if (ar.IsStoring())

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00009	e8 00 00 00 00	 call	 ?IsStoring@CArchive@@QBEHXZ ; CArchive::IsStoring
  0000e	85 c0		 test	 eax, eax
  00010	74 5c		 je	 SHORT $L199388

; 75   :    {
; 76   : 	  TYPE* pData;
; 77   : 	  UINT_PTR nElementsLeft;
; 78   : 
; 79   : 	  nElementsLeft = nCount;

  00012	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR _nElementsLeft$199390[ebp], eax

; 80   : 	  pData = pElements;

  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0001b	89 4d fc	 mov	 DWORD PTR _pData$199389[ebp], ecx
$L199392:

; 81   : 	  while( nElementsLeft > 0 )

  0001e	83 7d f8 00	 cmp	 DWORD PTR _nElementsLeft$199390[ebp], 0
  00022	76 48		 jbe	 SHORT $L199393

; 82   : 	  {
; 83   : 		 UINT nElementsToWrite;
; 84   : 
; 85   : 		 nElementsToWrite = UINT(min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00024	81 7d f8 ff ff
	ff 07		 cmp	 DWORD PTR _nElementsLeft$199390[ebp], 134217727 ; 07ffffffH
  0002b	73 08		 jae	 SHORT $L200245
  0002d	8b 55 f8	 mov	 edx, DWORD PTR _nElementsLeft$199390[ebp]
  00030	89 55 e4	 mov	 DWORD PTR tv69[ebp], edx
  00033	eb 07		 jmp	 SHORT $L200246
$L200245:
  00035	c7 45 e4 ff ff
	ff 07		 mov	 DWORD PTR tv69[ebp], 134217727 ; 07ffffffH
$L200246:
  0003c	8b 45 e4	 mov	 eax, DWORD PTR tv69[ebp]
  0003f	89 45 f4	 mov	 DWORD PTR _nElementsToWrite$199394[ebp], eax

; 86   : 		 ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  00042	8b 4d f4	 mov	 ecx, DWORD PTR _nElementsToWrite$199394[ebp]
  00045	c1 e1 04	 shl	 ecx, 4
  00048	51		 push	 ecx
  00049	8b 55 fc	 mov	 edx, DWORD PTR _pData$199389[ebp]
  0004c	52		 push	 edx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00050	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 87   : 		 nElementsLeft -= nElementsToWrite;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _nElementsLeft$199390[ebp]
  00058	2b 45 f4	 sub	 eax, DWORD PTR _nElementsToWrite$199394[ebp]
  0005b	89 45 f8	 mov	 DWORD PTR _nElementsLeft$199390[ebp], eax

; 88   : 		 pData += nElementsToWrite;

  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _nElementsToWrite$199394[ebp]
  00061	c1 e1 04	 shl	 ecx, 4
  00064	03 4d fc	 add	 ecx, DWORD PTR _pData$199389[ebp]
  00067	89 4d fc	 mov	 DWORD PTR _pData$199389[ebp], ecx

; 89   : 	  }

  0006a	eb b2		 jmp	 SHORT $L199392
$L199393:

; 90   :    }
; 91   : 	else

  0006c	eb 5a		 jmp	 SHORT $L199386
$L199388:

; 92   :    {
; 93   : 	  TYPE* pData;
; 94   : 	  UINT_PTR nElementsLeft;
; 95   : 
; 96   : 	  nElementsLeft = nCount;

  0006e	8b 55 10	 mov	 edx, DWORD PTR _nCount$[ebp]
  00071	89 55 ec	 mov	 DWORD PTR _nElementsLeft$199400[ebp], edx

; 97   : 	  pData = pElements;

  00074	8b 45 0c	 mov	 eax, DWORD PTR _pElements$[ebp]
  00077	89 45 f0	 mov	 DWORD PTR _pData$199399[ebp], eax
$L199402:

; 98   : 	  while( nElementsLeft > 0 )

  0007a	83 7d ec 00	 cmp	 DWORD PTR _nElementsLeft$199400[ebp], 0
  0007e	76 48		 jbe	 SHORT $L199386

; 99   : 	  {
; 100  : 		 UINT nElementsToRead;
; 101  : 
; 102  : 		 nElementsToRead = UINT(min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00080	81 7d ec ff ff
	ff 07		 cmp	 DWORD PTR _nElementsLeft$199400[ebp], 134217727 ; 07ffffffH
  00087	73 08		 jae	 SHORT $L200247
  00089	8b 4d ec	 mov	 ecx, DWORD PTR _nElementsLeft$199400[ebp]
  0008c	89 4d e0	 mov	 DWORD PTR tv79[ebp], ecx
  0008f	eb 07		 jmp	 SHORT $L200248
$L200247:
  00091	c7 45 e0 ff ff
	ff 07		 mov	 DWORD PTR tv79[ebp], 134217727 ; 07ffffffH
$L200248:
  00098	8b 55 e0	 mov	 edx, DWORD PTR tv79[ebp]
  0009b	89 55 e8	 mov	 DWORD PTR _nElementsToRead$199404[ebp], edx

; 103  : 		 ar.Read(pData, nElementsToRead*sizeof(TYPE));

  0009e	8b 45 e8	 mov	 eax, DWORD PTR _nElementsToRead$199404[ebp]
  000a1	c1 e0 04	 shl	 eax, 4
  000a4	50		 push	 eax
  000a5	8b 4d f0	 mov	 ecx, DWORD PTR _pData$199399[ebp]
  000a8	51		 push	 ecx
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  000ac	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 104  : 		 nElementsLeft -= nElementsToRead;

  000b1	8b 55 ec	 mov	 edx, DWORD PTR _nElementsLeft$199400[ebp]
  000b4	2b 55 e8	 sub	 edx, DWORD PTR _nElementsToRead$199404[ebp]
  000b7	89 55 ec	 mov	 DWORD PTR _nElementsLeft$199400[ebp], edx

; 105  : 		 pData += nElementsToRead;

  000ba	8b 45 e8	 mov	 eax, DWORD PTR _nElementsToRead$199404[ebp]
  000bd	c1 e0 04	 shl	 eax, 4
  000c0	03 45 f0	 add	 eax, DWORD PTR _pData$199399[ebp]
  000c3	89 45 f0	 mov	 DWORD PTR _pData$199399[ebp], eax

; 106  : 	  }

  000c6	eb b2		 jmp	 SHORT $L199402
$L199386:

; 107  :    }
; 108  : }

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 0c 00	 ret	 12			; 0000000cH
??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z ENDP ; SerializeElements<CRect>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z PROC NEAR ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ENDP ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z ; std::allocator<CPictureEx::TFrame>::construct
PUBLIC	?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z ; std::allocator<CPictureEx::TFrame>::destroy
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T200258 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T200260 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L200254
$T200259 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T200260
$T200256 DD	019930520H
	DD	02H
	DD	FLAT:$T200258
	DD	01H
	DD	FLAT:$T200259
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 208  : 	_FwdIt _Next = _First;

  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 209  : 
; 210  : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  0002d	eb 12		 jmp	 SHORT $L199413
$L199414:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00032	83 e9 01	 sub	 ecx, 1
  00035	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 1c	 add	 edx, 28			; 0000001cH
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L199413:
  00041	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00045	76 12		 jbe	 SHORT $L199415

; 212  : 		_Al.construct(_First, _Val);

  00047	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00052	e8 00 00 00 00	 call	 ?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z ; std::allocator<CPictureEx::TFrame>::construct
  00057	eb d6		 jmp	 SHORT $L199414
$L199415:
  00059	eb 2a		 jmp	 SHORT $L200253
$L200254:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

  0005b	eb 09		 jmp	 SHORT $L199416
$L199417:
  0005d	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00060	83 c2 1c	 add	 edx, 28			; 0000001cH
  00063	89 55 ec	 mov	 DWORD PTR __Next$[ebp], edx
$L199416:
  00066	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00069	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  0006c	74 0e		 je	 SHORT $L199418

; 215  : 		_Al.destroy(_Next);

  0006e	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00071	51		 push	 ecx
  00072	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00075	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z ; std::allocator<CPictureEx::TFrame>::destroy
  0007a	eb e1		 jmp	 SHORT $L199417
$L199418:

; 216  : 	_RERAISE;

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200253:

; 217  : 	_CATCH_END

  00085	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$L200252:

; 218  : 	}

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200256
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L199420
$L199421:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L199420:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L199419

; 226  : 		_Al.destroy(_First);

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001d	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z ; std::allocator<CPictureEx::TFrame>::destroy
  00022	eb e1		 jmp	 SHORT $L199421
$L199419:

; 227  : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT
$T200267 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T200267[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T200267[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ENDP ; std::_Uninitialized_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<CPictureEx::TFrame *,CPictureEx::TFrame *>, COMDAT

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
$L199465:

; 1049 : 	while (_First != _Last)

  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000b	74 21		 je	 SHORT $L199466

; 1050 : 		*--_Dest = *--_Last;

  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00010	83 e9 1c	 sub	 ecx, 28			; 0000001cH
  00013	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  00016	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00019	83 ea 1c	 sub	 edx, 28			; 0000001cH
  0001c	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0001f	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00022	b9 07 00 00 00	 mov	 ecx, 7
  00027	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0002a	f3 a5		 rep movsd
  0002c	eb d7		 jmp	 SHORT $L199465
$L199466:

; 1051 : 	return (_Dest);

  0002e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1052 : 	}

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CPictureEx::TFrame *,CPictureEx::TFrame *>
_TEXT	ENDS
PUBLIC	??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z ; std::_Construct<CPictureEx::TFrame,CPictureEx::TFrame>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z PROC NEAR ; std::allocator<CPictureEx::TFrame>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z ; std::_Construct<CPictureEx::TFrame,CPictureEx::TFrame>
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z ENDP ; std::allocator<CPictureEx::TFrame>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z ; std::_Destroy<CPictureEx::TFrame>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z PROC NEAR ; std::allocator<CPictureEx::TFrame>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z ; std::_Destroy<CPictureEx::TFrame>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z ENDP ; std::allocator<CPictureEx::TFrame>::destroy
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T200281 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T200283 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L200277
$T200282 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T200283
$T200279 DD	019930520H
	DD	02H
	DD	FLAT:$T200281
	DD	01H
	DD	FLAT:$T200282
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 78   : 	_FwdIt _Next = _Dest;

  00020	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 79   : 
; 80   : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  0002d	eb 12		 jmp	 SHORT $L199484
$L199485:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00035	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 1c	 add	 edx, 28			; 0000001cH
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L199484:
  00041	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00044	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00047	74 12		 je	 SHORT $L199486

; 82   : 		_Al.construct(_Dest, *_First);

  00049	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00050	52		 push	 edx
  00051	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00054	e8 00 00 00 00	 call	 ?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z ; std::allocator<CPictureEx::TFrame>::construct
  00059	eb d4		 jmp	 SHORT $L199485
$L199486:
  0005b	eb 2a		 jmp	 SHORT $L200276
$L200277:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  0005d	eb 09		 jmp	 SHORT $L199487
$L199488:
  0005f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00062	83 c0 1c	 add	 eax, 28			; 0000001cH
  00065	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$L199487:
  00068	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  0006b	3b 4d 10	 cmp	 ecx, DWORD PTR __Dest$[ebp]
  0006e	74 0e		 je	 SHORT $L199489

; 85   : 		_Al.destroy(_Next);

  00070	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00073	52		 push	 edx
  00074	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00077	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z ; std::allocator<CPictureEx::TFrame>::destroy
  0007c	eb e1		 jmp	 SHORT $L199488
$L199489:

; 86   : 	_RERAISE;

  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	e8 00 00 00 00	 call	 __CxxThrowException@8
$L200276:

; 87   : 	_CATCH_END

  00087	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 88   : 	return (_Dest);

  0008e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$L200275:

; 89   : 	}

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200279
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
$T200288 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z PROC NEAR ; std::_Construct<CPictureEx::TFrame,CPictureEx::TFrame>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00008	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000b	50		 push	 eax
  0000c	6a 1c		 push	 28			; 0000001cH
  0000e	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00013	83 c4 08	 add	 esp, 8
  00016	89 45 fc	 mov	 DWORD PTR $T200288[ebp], eax
  00019	83 7d fc 00	 cmp	 DWORD PTR $T200288[ebp], 0
  0001d	74 15		 je	 SHORT $L200289
  0001f	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  00022	b9 07 00 00 00	 mov	 ecx, 7
  00027	8b 7d fc	 mov	 edi, DWORD PTR $T200288[ebp]
  0002a	f3 a5		 rep movsd
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR $T200288[ebp]
  0002f	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
  00032	eb 07		 jmp	 SHORT $L199490
$L200289:
  00034	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L199490:

; 43   : 	}

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z ENDP ; std::_Construct<CPictureEx::TFrame,CPictureEx::TFrame>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z PROC NEAR ; std::_Destroy<CPictureEx::TFrame>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z ENDP ; std::_Destroy<CPictureEx::TFrame>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ?Offset@CPoint@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_xOffset$ = 8						; size = 4
_yOffset$ = 12						; size = 4
?Offset@CPoint@@QAEXHH@Z PROC NEAR			; CPoint::Offset, COMDAT
; _this$ = ecx

; 74   : 	{ x += xOffset; y += yOffset; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	03 4d 08	 add	 ecx, DWORD PTR _xOffset$[ebp]
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	03 4d 0c	 add	 ecx, DWORD PTR _yOffset$[ebp]
  0001d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00020	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
?Offset@CPoint@@QAEXHH@Z ENDP				; CPoint::Offset
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRect@@QAE@XZ PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 110  : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CRect@@QAE@XZ ENDP					; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
??0CRect@@QAE@HHHH@Z PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 112  : 	{ left = l; top = t; right = r; bottom = b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _r$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _b$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
??0CRect@@QAE@HHHH@Z ENDP				; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Width@CRect@@QBEHXZ PROC NEAR				; CRect::Width, COMDAT
; _this$ = ecx

; 123  : 	{ return right - left; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Width@CRect@@QBEHXZ ENDP				; CRect::Width
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Height@CRect@@QBEHXZ PROC NEAR				; CRect::Height, COMDAT
; _this$ = ecx

; 125  : 	{ return bottom - top; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?Height@CRect@@QBEHXZ ENDP				; CRect::Height
_TEXT	ENDS
PUBLIC	??0CPoint@@QAE@HH@Z				; CPoint::CPoint
; Function compile flags: /Odt
;	COMDAT ?CenterPoint@CRect@@QBE?AVCPoint@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?CenterPoint@CRect@@QBE?AVCPoint@@XZ PROC NEAR		; CRect::CenterPoint, COMDAT
; _this$ = ecx

; 137  : 	{ return CPoint((left+right)/2, (top+bottom)/2); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  00013	99		 cdq
  00014	2b c2		 sub	 eax, edx
  00016	d1 f8		 sar	 eax, 1
  00018	50		 push	 eax
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 02		 mov	 eax, DWORD PTR [edx]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00024	99		 cdq
  00025	2b c2		 sub	 eax, edx
  00027	d1 f8		 sar	 eax, 1
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?CenterPoint@CRect@@QBE?AVCPoint@@XZ ENDP		; CRect::CenterPoint
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initX$ = 8						; size = 4
_initY$ = 12						; size = 4
??0CPoint@@QAE@HH@Z PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 63   : 	{ x = initX; y = initY; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _initX$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _initY$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0CPoint@@QAE@HH@Z ENDP				; CPoint::CPoint
_TEXT	ENDS
EXTRN	__imp__PtInRect@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?PtInRect@CRect@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_point$ = 8						; size = 8
?PtInRect@CRect@@QBEHUtagPOINT@@@Z PROC NEAR		; CRect::PtInRect, COMDAT
; _this$ = ecx

; 151  : 	{ return ::PtInRect(this, point); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp+4]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _point$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	52		 push	 edx
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?PtInRect@CRect@@QBEHUtagPOINT@@@Z ENDP			; CRect::PtInRect
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CObject@@IAE@XZ PROC NEAR				; CObject::CObject, COMDAT
; _this$ = ecx

; 21   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CObject@@IAE@XZ ENDP					; CObject::CObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CObject@@UAE@XZ PROC NEAR				; CObject::~CObject, COMDAT
; _this$ = ecx

; 23   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC NEAR	; CObject::Serialize, COMDAT
; _this$ = ecx

; 25   : 	{ /* CObject does not serialize anything by default */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC NEAR				; CObject::operator delete, COMDAT

; 31   : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??2CObject@@SGPAXI@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
??2CObject@@SGPAXI@Z PROC NEAR				; CObject::operator new, COMDAT

; 37   : 	{ return ::operator new(nSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _nSize$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??2CObject@@SGPAXI@Z ENDP				; CObject::operator new
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AssertValid@CObject@@UBEXXZ PROC NEAR			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 41   : 	{ /* no asserts in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC NEAR	; CObject::Dump, COMDAT
; _this$ = ecx

; 43   : 	{ /* no dumping in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsStoring@CArchive@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStoring@CArchive@@QBEHXZ PROC NEAR			; CArchive::IsStoring, COMDAT
; _this$ = ecx

; 133  : 	{ return (m_nMode & CArchive::load) == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000d	83 e0 01	 and	 eax, 1
  00010	f7 d8		 neg	 eax
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?IsStoring@CArchive@@QBEHXZ ENDP			; CArchive::IsStoring
_TEXT	ENDS
EXTRN	?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ:NEAR ; AfxGetModuleState
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
;	COMDAT ?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ PROC NEAR	; AfxGetResourceHandle, COMDAT

; 26   : 	{ ASSERT(afxCurrentResourceHandle != NULL);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 27   : 		return afxCurrentResourceHandle; }

  00003	e8 00 00 00 00	 call	 ?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetModuleState
  00008	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ ENDP	; AfxGetResourceHandle
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 28   : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200339 DD	0ffffffffH
	DD	FLAT:$L200334
$T200337 DD	019930520H
	DD	01H
	DD	FLAT:$T200339
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 20   : 		}

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200334:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200337
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102266
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102266:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200351 DD	0ffffffffH
	DD	FLAT:$L200346
$T200349 DD	019930520H
	DD	01H
	DD	FLAT:$T200351
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200346:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200349
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102332
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102332:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200366 DD	0ffffffffH
	DD	FLAT:$L200361
$T200364 DD	019930520H
	DD	01H
	DD	FLAT:$T200366
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0003f	52		 push	 edx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200361:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200364
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
END
