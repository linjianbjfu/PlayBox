; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\boxgit\PlayBox\CommonLib\common\tools.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_05GIBEAPNE@CLSID?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PDIKPLII@AppID?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OHBKMIBJ@HKCR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KIFLFONO@HKCU?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04CBBMIBLK@HKLM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DLBIJLAB@HKU?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OFOCGAOH@HKPD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04POMNGLEL@HKDD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LEMDOLAJ@HKCC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OEMMANAM@HKEY_USERS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LFHHJFCN@?4tlb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06JHNIBAJK@CLSID?2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@CCIMKLEB@?2Required?5Categories?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@LFOHFLDB@?2Implemented?5Categories?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OGDGDABE@DllGetVersion?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@OGEBEC@comctl32?4dll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KFDNOLCO@shell32?4dll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@PPPPCDEP@?$AAA?$AAP?$AAP?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@HHDGIIFB@0123456789abcdefABCDEF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT _InlineIsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ocslen@@YAHPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ocscpy@@YAPA_WPA_WPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharNextO@@YAPA_WPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?A2WBSTR@@YAPA_WPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComAutoCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CComAutoCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlFindResourceInstance@ATL@@YAPAUHINSTANCE__@@PBD0G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlFindStringResourceInstance@ATL@@YAPAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlHresultFromLastError@ATL@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlHresultFromWin32@ATL@@YAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComPtrAssign@ATL@@YGPAUIUnknown@@PAPAU2@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComQIPtrAssign@ATL@@YGPAUIUnknown@@PAPAU2@PAU2@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@?$CComPtr@UIDispatch@@@ATL@@QAEJJPAUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutProperty@?$CComPtr@UIDispatch@@@ATL@@QAEJJPAUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIDOfName@?$CComPtr@UIDispatch@@@ATL@@QAEJPB_WPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Invoke0@?$CComPtr@UIDispatch@@@ATL@@QAEJJPAUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Invoke1@?$CComPtr@UIDispatch@@@ATL@@QAEJJPAUtagVARIANT@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvokeN@?$CComPtr@UIDispatch@@@ATL@@QAEJJPAUtagVARIANT@@H0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutProperty@?$CComPtr@UIDispatch@@@ATL@@SAJPAUIDispatch@@JPAUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@?$CComPtr@UIDispatch@@@ATL@@SAJPAUIDispatch@@JPAUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@CComBSTR@ATL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ByteLength@CComBSTR@ATL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCComBSTR@ATL@@QBEPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ICComBSTR@ATL@@QAEPAPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Copy@CComBSTR@ATL@@QBEPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@CComBSTR@ATL@@QAEXPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Detach@CComBSTR@ATL@@QAEPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@CComBSTR@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7CComBSTR@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Append@CComBSTR@ATL@@QAEJABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Append@CComBSTR@ATL@@QAEJPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendBSTR@CComBSTR@ATL@@QAEJPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Append@CComBSTR@ATL@@QAEJPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??MCComBSTR@ATL@@QBE_NABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??MCComBSTR@ATL@@QBE_NPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??OCComBSTR@ATL@@QBE_NABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??OCComBSTR@ATL@@QBE_NPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9CComBSTR@ATL@@QBE_NPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8CComBSTR@ATL@@QBE_NABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8CComBSTR@ATL@@QBE_NPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8CComBSTR@ATL@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CComBSTR@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8CComBSTR@ATL@@QBE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteToStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadFromStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringResource@CComBSTR@ATL@@SA_NPAUHINSTANCE__@@IAAPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringResource@CComBSTR@ATL@@SA_NIAAPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComVariant@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CComVariant@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComVariant@ATL@@QAE@ABUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CComVariant@ATL@@QAEAAV01@ABVCComBSTR@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CComVariant@ATL@@QAEAAV01@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CComVariant@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8CComVariant@ATL@@QBE_NABUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CComVariant@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Copy@CComVariant@ATL@@QAEJPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChangeType@CComVariant@ATL@@QAEJGPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalCopy@CComVariant@ATL@@QAEXPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIPersistStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Invoke2@?$CComPtr@UIDispatch@@@ATL@@QAEJJPAUtagVARIANT@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RevokeClassObject@_ATL_OBJMAP_ENTRY30@ATL@@QAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterClassObject@_ATL_OBJMAP_ENTRY30@ATL@@QAGJKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Increment@CComMultiThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrement@CComMultiThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@_stdcallthunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@CHandle@ATL@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Detach@CHandle@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CHandle@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CCritSecLock@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CCritSecLock@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterTypeLib@CAtlComModule@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterTypeLib@CAtlComModule@ATL@@QAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnRegisterTypeLib@CAtlComModule@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnRegisterTypeLib@CAtlComModule@ATL@@QAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnregisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??0CAtlModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAtlModule@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLockCount@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EscapeSingleQuote@CAtlModule@ATL@@SAXPA_WPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAtlModule@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_m_hInst@CComModule@ATL@@QBEAAPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCComModule@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CComModule@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Apartment@CComApartment@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetThread@CComSimpleThreadAllocator@ATL@@QAEHPAVCComApartment@2@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRegKey@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRegKey@ATL@@QAE@PAUHKEY__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRegKey@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCRegKey@ATL@@QBEPAUHKEY__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteValue@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CRegKey@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryStringValue@CRegKey@ATL@@QAEJPBDPADPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetKeyValue@CRegKey@ATL@@QAEJPBD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterProgID@CComModule@ATL@@SAJPBD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CExpansionVector@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateError@CRegParser@ATL@@IAEJI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndOfVar@CRegParser@ATL@@IAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CParseBuffer@CRegParser@ATL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CParseBuffer@CRegParser@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRegObject@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRegObject@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResourceRegisterSz@CRegObject@ATL@@QAGJPB_W00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResourceUnregisterSz@CRegObject@ATL@@QAGJPB_W00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterWithString@CRegObject@ATL@@IAEJPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearReplacements@CRegObject@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StrFromMap@CRegObject@ATL@@QAEPB_WPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CommonFileRegister@CRegObject@ATL@@IAEJPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChToByte@CRegParser@ATL@@KAED@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StrChrA@CRegParser@ATL@@KAPADPADD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSpace@CRegParser@ATL@@IAEHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextToken@CRegParser@ATL@@IAEJPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRegObject@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IRegistrarBase@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CExpansionVector@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterClassHelper@CComModule@ATL@@QAGJABU_GUID@@PBD11K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnregisterClassHelper@CComModule@ATL@@QAGJABU_GUID@@PBD1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_WPAPA_WPAPAUITypeLib@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UICatRegister@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetDllVersion@ATL@@YAJPAUHINSTANCE__@@PAU_DLLVERSIONINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetDllVersion@ATL@@YAJPBDPAU_DLLVERSIONINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_m_csStaticDataInit@CComModule@ATL@@QAEAAU_RTL_CRITICAL_SECTION@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CComModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIConnectionPointContainer@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIConnectionPoint@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComModuleGetClassObject@ATL@@YGJPAU_ATL_COM_MODULE70@1@ABU_GUID@@1PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComModuleRegisterClassObjects@ATL@@YGJPAU_ATL_COM_MODULE70@1@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComModuleRevokeClassObjects@ATL@@YGJPAU_ATL_COM_MODULE70@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWaitWithMessageLoop@ATL@@YGHPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleAddCreateWndData@ATL@@YGXPAU_ATL_WIN_MODULE70@1@PAU_AtlCreateWndData@1@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleExtractCreateWndData@ATL@@YGPAXPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlModuleAddTermFunc@ATL@@YGJPAU_ATL_MODULE70@1@P6GXK@ZK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlCallTermFunc@ATL@@YGXPAU_ATL_MODULE70@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWin32Heap@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CWin32Heap@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CWin32Heap@ATL@@UAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@CWin32Heap@ATL@@UAEIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCWin32Heap@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIMalloc@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNilStringData@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEnvironmentVariableW@?$ChTraitsCRT@_W@ATL@@CGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CFixedStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CFixedStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CFixedStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringLog@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnAllocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnReallocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringLog@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IFixedStringLog@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAtlStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAtlStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringW@?$ChTraitsOS@_W@ATL@@KGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExW@?$ChTraitsOS@_W@ATL@@KGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiW@?$ChTraitsOS@_W@ATL@@KGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerW@?$ChTraitsOS@_W@ATL@@KGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperW@?$ChTraitsOS@_W@ATL@@KGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strchr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strrchr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strrev@?$ChTraitsOS@_W@ATL@@SAPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strstr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strspn@?$ChTraitsOS@_W@ATL@@SAHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strcspn@?$ChTraitsOS@_W@ATL@@SAHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strpbrk@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@_W@std@@YAD_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@_WDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIDispatch@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIDispatch@@@ATL@@IAE@PAUIDispatch@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIDispatch@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@_W$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@_W$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@_W$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@_W$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIPersistStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIPersistStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIPersistStream@@@ATL@@QBEPAUIPersistStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIPersistStream@@@ATL@@QAEPAPAUIPersistStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIPersistStream@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIPersistStream@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlAutoThreadModuleT@VCAtlAutoThreadModule@ATL@@VCComSimpleThreadAllocator@2@$0PPPPPPPP@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CAtlAutoThreadModuleT@VCAtlAutoThreadModule@ATL@@VCComSimpleThreadAllocator@2@$0PPPPPPPP@@ATL@@UAEJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lookup@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetKeyAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetValueAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UITypeLib@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeLib@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UICatRegister@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UICatRegister@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UICatRegister@@@ATL@@QAEPAPAUICatRegister@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UICatRegister@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICatRegister@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIConnectionPointContainer@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIConnectionPointContainer@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIConnectionPointContainer@@@ATL@@QAEPAPAUIConnectionPointContainer@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIConnectionPointContainer@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIConnectionPointContainer@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIConnectionPoint@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIConnectionPoint@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIConnectionPoint@@@ATL@@QAEPAPAUIConnectionPoint@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIConnectionPoint@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIConnectionPoint@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIMalloc@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIMalloc@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIMalloc@@@ATL@@QAEPAPAUIMalloc@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIMalloc@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIMalloc@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Find@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReverseFind@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Right@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Left@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CAtlAutoThreadModuleT@VCAtlAutoThreadModule@ATL@@VCComSimpleThreadAllocator@2@$0PPPPPPPP@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@_W$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@_W$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIPersistStream@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitLibId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAppId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAPB_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindKey@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalSetAtIndex@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UICatRegister@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIConnectionPointContainer@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIConnectionPoint@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIMalloc@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Concatenate@?$CSimpleStringT@D$0A@@ATL@@KAXAAV12@PBDH1H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindChar@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindCharRev@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@std@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@_W$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@AAVCComCriticalSection@1@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlAlignUp@H@ATL@@YGHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0IPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?2PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?3PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@D@std@@YADDABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __GUID_00020400_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0?AVCWin32Heap@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4IFixedStringLog@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?szThreadingModel@?1??RegisterClassHelper@CComModule@ATL@@QAGJABU_GUID@@PBD11K@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R2domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __GUID_0002e012_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0?AVdomain_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CComModule@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_R0?AVrange_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?szBoth@?1??RegisterClassHelper@CComModule@ATL@@QAGJABU_GUID@@PBD11K@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@codecvt_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CComModule@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCAtlModule@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __GUID_b196b284_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R3?$CAtlAutoThreadModuleT@VCAtlAutoThreadModule@ATL@@VCComSimpleThreadAllocator@2@$0PPPPPPPP@@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CRegObject@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCFixedStringLog@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AU_ATL_MODULE70@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$codecvt@_WDH@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUIAtlMemMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CWin32Heap@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4underflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IRegistrarBase@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CAtlAutoThreadModuleT@VCAtlAutoThreadModule@ATL@@VCComSimpleThreadAllocator@2@$0PPPPPPPP@@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3IUnknown@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CFixedStringMgr@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI1?AVexception@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R3invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?szAUTPRX32@?1??RegisterClassHelper@CComModule@ATL@@QAGJABU_GUID@@PBD11K@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCRegObject@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4overflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@IAtlMemMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVunderflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CFixedStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT __CTA1?AVexception@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R2IFixedStringLog@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IAtlAutoThreadModule@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R2CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CAtlModule@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVIFixedStringLog@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4domain_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CAtlModuleT@VCComModule@ATL@@@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CWin32Heap@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$CAtlAutoThreadModuleT@VCAtlAutoThreadModule@ATL@@VCComSimpleThreadAllocator@2@$0PPPPPPPP@@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IUnknown@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$CAtlModuleT@VCComModule@ATL@@@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?szApartment@?1??RegisterClassHelper@CComModule@ATL@@QAGJABU_GUID@@PBD11K@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@CAtlModule@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CFixedStringLog@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?szLS32@?1??RegisterClassHelper@CComModule@ATL@@QAGJABU_GUID@@PBD11K@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0?AVbad_exception@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AUIAtlAutoThreadModule@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AUIAtlStringMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2CWin32Heap@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$CAtlModuleT@VCComModule@ATL@@@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ??_R0?AVCAtlStringMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?szProgID@?1??RegisterClassHelper@CComModule@ATL@@QAGJABU_GUID@@PBD11K@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4invalid_argument@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CFixedStringLog@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$codecvt@_WDH@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4range_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IFixedStringLog@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?s_bGetVersion@?1??IsVista@@YA_NXZ@4_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __GUID_00000146_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R1A@?0A@A@IUnknown@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?map@?2??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@23@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CRegObject@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CFixedStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CFixedStringLog@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IRegistrarBase@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R13?0A@A@_ATL_MODULE70@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?dwLastThreadID@?1??RandomIntValue@@YAXHPAH@Z@4KA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCFixedStringMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknown@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R3CAtlModule@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_7IUnknown@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4bad_exception@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CRegObject@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R1A@?0A@A@CFixedStringLog@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$CAtlAutoThreadModuleT@VCAtlAutoThreadModule@ATL@@VCComSimpleThreadAllocator@2@$0PPPPPPPP@@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CComModule@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$CAtlAutoThreadModuleT@VCAtlAutoThreadModule@ATL@@VCComSimpleThreadAllocator@2@$0PPPPPPPP@@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R1A@?0A@A@underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IRegistrarBase@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?$S4@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4IA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_R1A@?0A@A@bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4IUnknown@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R4CAtlModule@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?s_bIsVista@?1??IsVista@@YA_NXZ@4_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@IAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IRegistrarBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _CLSID_StdGlobalInterfaceTable
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?szIPS32@?1??RegisterClassHelper@CComModule@ATL@@QAGJABU_GUID@@PBD11K@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CWin32Heap@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@?$CAtlModuleT@VCComModule@ATL@@@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?szVIProgID@?1??RegisterClassHelper@CComModule@ATL@@QAGJABU_GUID@@PBD11K@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAF@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAJ@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAE@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cbNeverDelete@CRegParser@ATL@@1HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAM@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@D@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFixedStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?MAX_VALUE@CRegParser@ATL@@1HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CComModule@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@K@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CAtlModule@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAD@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@M@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@J@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAI@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_K@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@I@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@H@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_K@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAG@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CRegObject@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CAtlStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@N@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAK@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7?$CAtlModuleT@VCComModule@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@UtagVARIANT@@@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_J@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@F@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_W@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@G@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@E@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_J@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CAtlAutoThreadModuleT@VCAtlAutoThreadModule@ATL@@VCComSimpleThreadAllocator@2@$0PPPPPPPP@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?MAX_TYPE@CRegParser@ATL@@1HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAN@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAH@ATL@@2GB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7CWin32Heap@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CComModule@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUIRegistrarBase@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$CAtlModuleT@VCComModule@ATL@@@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_S?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$codecvt@_WDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R3IFixedStringLog@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CFixedStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IRegistrarBase@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCComModule@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __GUID_00000109_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CAtlStringMgr@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVinvalid_argument@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVoverflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2CRegObject@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
PUBLIC	_LIBID_ATLLib
PUBLIC	_CLSID_StdGlobalInterfaceTable
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?rgszNeverDelete@CRegParser@ATL@@1QBQBDB	; ATL::CRegParser::rgszNeverDelete
PUBLIC	?cbNeverDelete@CRegParser@ATL@@1HB		; ATL::CRegParser::cbNeverDelete
PUBLIC	?MAX_VALUE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_VALUE
PUBLIC	?MAX_TYPE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_TYPE
PUBLIC	?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA	; ATL::CComApartment::ATL_CREATE_OBJECT
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	_IID_IInternalConnection
PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	?VT@?$CVarTypeInfo@D@ATL@@2GB			; ATL::CVarTypeInfo<char>::VT
PUBLIC	?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ ; ATL::CVarTypeInfo<char>::pmField
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	?VT@?$CVarTypeInfo@E@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char>::VT
PUBLIC	?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ ; ATL::CVarTypeInfo<unsigned char>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAD@ATL@@2GB			; ATL::CVarTypeInfo<char *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ ; ATL::CVarTypeInfo<char *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAE@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ ; ATL::CVarTypeInfo<unsigned char *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@F@ATL@@2GB			; ATL::CVarTypeInfo<short>::VT
PUBLIC	?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A ; ATL::CFixedStringMgr::s_pLog
PUBLIC	?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ ; ATL::CVarTypeInfo<short>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAF@ATL@@2GB			; ATL::CVarTypeInfo<short *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ ; ATL::CVarTypeInfo<short *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@G@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short>::VT
PUBLIC	?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ ; ATL::CVarTypeInfo<unsigned short>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAG@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short *>::VT
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ ; ATL::CVarTypeInfo<unsigned short *>::pmField
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?VT@?$CVarTypeInfo@H@ATL@@2GB			; ATL::CVarTypeInfo<int>::VT
PUBLIC	?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ ; ATL::CVarTypeInfo<int>::pmField
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?VT@?$CVarTypeInfo@PAH@ATL@@2GB			; ATL::CVarTypeInfo<int *>::VT
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ ; ATL::CVarTypeInfo<int *>::pmField
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?VT@?$CVarTypeInfo@I@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int>::VT
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ ; ATL::CVarTypeInfo<unsigned int>::pmField
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?VT@?$CVarTypeInfo@PAI@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ ; ATL::CVarTypeInfo<unsigned int *>::pmField
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?VT@?$CVarTypeInfo@J@ATL@@2GB			; ATL::CVarTypeInfo<long>::VT
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ ; ATL::CVarTypeInfo<long>::pmField
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?VT@?$CVarTypeInfo@PAJ@ATL@@2GB			; ATL::CVarTypeInfo<long *>::VT
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ ; ATL::CVarTypeInfo<long *>::pmField
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?VT@?$CVarTypeInfo@K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long>::VT
PUBLIC	?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ ; ATL::CVarTypeInfo<unsigned long>::pmField
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?VT@?$CVarTypeInfo@PAK@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long *>::VT
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ ; ATL::CVarTypeInfo<unsigned long *>::pmField
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?VT@?$CVarTypeInfo@_J@ATL@@2GB			; ATL::CVarTypeInfo<__int64>::VT
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ ; ATL::CVarTypeInfo<__int64>::pmField
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?VT@?$CVarTypeInfo@PA_J@ATL@@2GB		; ATL::CVarTypeInfo<__int64 *>::VT
PUBLIC	_CLSID_Registrar
PUBLIC	?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ ; ATL::CVarTypeInfo<__int64 *>::pmField
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?VT@?$CVarTypeInfo@_K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned __int64>::VT
PUBLIC	?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PA_K@ATL@@2GB		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@M@ATL@@2GB			; ATL::CVarTypeInfo<float>::VT
PUBLIC	_IID_IRegistrar
PUBLIC	?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ ; ATL::CVarTypeInfo<float>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAM@ATL@@2GB			; ATL::CVarTypeInfo<float *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ ; ATL::CVarTypeInfo<float *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@N@ATL@@2GB			; ATL::CVarTypeInfo<double>::VT
PUBLIC	?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ ; ATL::CVarTypeInfo<double>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAN@ATL@@2GB			; ATL::CVarTypeInfo<double *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ ; ATL::CVarTypeInfo<double *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@UtagVARIANT@@@ATL@@2GB	; ATL::CVarTypeInfo<tagVARIANT>::VT
PUBLIC	?VT@?$CVarTypeInfo@PA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ ; ATL::CVarTypeInfo<wchar_t *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ ; ATL::CVarTypeInfo<wchar_t * *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown * *>::VT
PUBLIC	?_strthunks@ATL@@3U_AtlStringThunks@1@A		; ATL::_strthunks
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown * *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch *>::pmField
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch * *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY>::VT
PUBLIC	?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY>::pmField
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWThunk
PUBLIC	?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY *>::pmField
PUBLIC	?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z	; ATL::CompareStringWThunk
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWThunk
PUBLIC	?m_libid@CAtlModule@ATL@@2U_GUID@@A		; ATL::CAtlModule::m_libid
PUBLIC	?lstrcmpiWThunk@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWThunk
PUBLIC	?CharLowerWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWThunk
PUBLIC	?CharUpperWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWThunk
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA
_BSS	SEGMENT
?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA DD 01H DUP (?) ; ATL::CComApartment::ATL_CREATE_OBJECT
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_BSS	SEGMENT
?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A DD 01H DUP (?) ; ATL::CFixedStringMgr::s_pLog
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_BSS	SEGMENT
?m_libid@CAtlModule@ATL@@2U_GUID@@A DB 010H DUP (?)	; ATL::CAtlModule::m_libid
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@D@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@D@ATL@@2GB DW 010H			; ATL::CVarTypeInfo<char>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ DD 08H ; ATL::CVarTypeInfo<char>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@E@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@E@ATL@@2GB DW 011H			; ATL::CVarTypeInfo<unsigned char>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAD@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAD@ATL@@2GB DW 04010H		; ATL::CVarTypeInfo<char *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ DD 08H ; ATL::CVarTypeInfo<char *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAE@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAE@ATL@@2GB DW 04011H		; ATL::CVarTypeInfo<unsigned char *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@F@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@F@ATL@@2GB DW 02H			; ATL::CVarTypeInfo<short>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ DD 08H ; ATL::CVarTypeInfo<short>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAF@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAF@ATL@@2GB DW 04002H		; ATL::CVarTypeInfo<short *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ DD 08H ; ATL::CVarTypeInfo<short *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@G@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@G@ATL@@2GB DW 012H			; ATL::CVarTypeInfo<unsigned short>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAG@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAG@ATL@@2GB DW 04012H		; ATL::CVarTypeInfo<unsigned short *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@H@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@H@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<int>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ DD 08H ; ATL::CVarTypeInfo<int>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAH@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAH@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<int *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ DD 08H ; ATL::CVarTypeInfo<int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@I@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@I@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned int>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAI@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAI@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned int *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@J@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<long>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ DD 08H ; ATL::CVarTypeInfo<long>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAJ@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAJ@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<long *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ DD 08H ; ATL::CVarTypeInfo<long *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@K@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned long>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAK@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAK@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned long *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_J@ATL@@2GB DW 014H			; ATL::CVarTypeInfo<__int64>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_J@ATL@@2GB DW 04014H		; ATL::CVarTypeInfo<__int64 *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_K@ATL@@2GB DW 015H			; ATL::CVarTypeInfo<unsigned __int64>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_K@ATL@@2GB DW 04015H		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@M@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@M@ATL@@2GB DW 04H			; ATL::CVarTypeInfo<float>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ DD 08H ; ATL::CVarTypeInfo<float>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAM@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAM@ATL@@2GB DW 04004H		; ATL::CVarTypeInfo<float *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ DD 08H ; ATL::CVarTypeInfo<float *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@N@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@N@ATL@@2GB DW 05H			; ATL::CVarTypeInfo<double>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ DD 08H ; ATL::CVarTypeInfo<double>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAN@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAN@ATL@@2GB DW 04005H		; ATL::CVarTypeInfo<double *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ DD 08H ; ATL::CVarTypeInfo<double *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@UtagVARIANT@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@UtagVARIANT@@@ATL@@2GB DW 0cH	; ATL::CVarTypeInfo<tagVARIANT>::VT
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_W@ATL@@2GB DW 08H			; ATL::CVarTypeInfo<wchar_t *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB DW 04008H		; ATL::CVarTypeInfo<wchar_t * *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB DW 0dH	; ATL::CVarTypeInfo<IUnknown *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB DW 0400dH	; ATL::CVarTypeInfo<IUnknown * *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB DW 09H	; ATL::CVarTypeInfo<IDispatch *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB DW 04009H	; ATL::CVarTypeInfo<IDispatch * *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB DW 06H		; ATL::CVarTypeInfo<tagCY>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB DW 04006H	; ATL::CVarTypeInfo<tagCY *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY *>::pmField
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT _CLSID_StdGlobalInterfaceTable
CONST	SEGMENT
_CLSID_StdGlobalInterfaceTable DD 0323H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
CONST	SEGMENT
$SG68674 DB	'S', 00H
	ORG $+2
_szStringVal DD	FLAT:$SG68674
$SG68676 DB	'M', 00H
	ORG $+2
_multiszStringVal DD FLAT:$SG68676
$SG68678 DB	'D', 00H
	ORG $+2
_szDwordVal DD	FLAT:$SG68678
$SG68680 DB	'B', 00H
	ORG $+2
_szBinaryVal DD	FLAT:$SG68680
$SG68682 DB	'Val', 00H
_szValToken DD	FLAT:$SG68682
$SG68684 DB	'ForceRemove', 00H
_szForceRemove DD FLAT:$SG68684
$SG68686 DB	'NoRemove', 00H
	ORG $+3
_szNoRemove DD	FLAT:$SG68686
$SG68688 DB	'Delete', 00H
	ORG $+1
_szDelete DD	FLAT:$SG68688
CONST	ENDS
;	COMDAT ?MAX_VALUE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_VALUE@CRegParser@ATL@@1HB DD 01000H		; ATL::CRegParser::MAX_VALUE
CONST	ENDS
;	COMDAT ?MAX_TYPE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_TYPE@CRegParser@ATL@@1HB DD 01000H			; ATL::CRegParser::MAX_TYPE
CONST	ENDS
CONST	SEGMENT
$SG69317 DB	'AppID', 00H
	ORG $+2
$SG69318 DB	'CLSID', 00H
	ORG $+2
$SG69319 DB	'Component Categories', 00H
	ORG $+3
$SG69320 DB	'FileType', 00H
	ORG $+3
$SG69321 DB	'Interface', 00H
	ORG $+2
$SG69322 DB	'Hardware', 00H
	ORG $+3
$SG69323 DB	'Mime', 00H
	ORG $+3
$SG69324 DB	'SAM', 00H
$SG69325 DB	'SECURITY', 00H
	ORG $+3
$SG69326 DB	'SYSTEM', 00H
	ORG $+1
$SG69327 DB	'Software', 00H
	ORG $+3
$SG69328 DB	'TypeLib', 00H
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB
CONST	SEGMENT
?rgszNeverDelete@CRegParser@ATL@@1QBQBDB DD FLAT:$SG69317 ; ATL::CRegParser::rgszNeverDelete
	DD	FLAT:$SG69318
	DD	FLAT:$SG69319
	DD	FLAT:$SG69320
	DD	FLAT:$SG69321
	DD	FLAT:$SG69322
	DD	FLAT:$SG69323
	DD	FLAT:$SG69324
	DD	FLAT:$SG69325
	DD	FLAT:$SG69326
	DD	FLAT:$SG69327
	DD	FLAT:$SG69328
CONST	ENDS
;	COMDAT ?cbNeverDelete@CRegParser@ATL@@1HB
CONST	SEGMENT
?cbNeverDelete@CRegParser@ATL@@1HB DD 0cH		; ATL::CRegParser::cbNeverDelete
CONST	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT
?_strthunks@ATL@@3U_AtlStringThunks@1@A DD FLAT:?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ; ATL::_strthunks
	DD	FLAT:?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
	DD	FLAT:?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
	DD	FLAT:?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_DATA	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
CONST	SEGMENT
$SG87058 DB	'%s.%s.tmp', 00H
	ORG $+2
$SG87064 DB	'%s.%s.tmp', 00H
	ORG $+2
$SG87065 DB	'%s.%s.tmp', 00H
	ORG $+2
$SG87073 DB	'%s\%s.tmp', 00H
	ORG $+2
$SG87091 DB	'Buffer not big enough!', 00H
$SG87106 DB	00H
$SG87110 DB	'%s\%s', 00H
	ORG $+2
$SG87112 DB	'%s%s', 00H
	ORG $+3
$SG87114 DB	'%s', 00H
$SG87131 DB	00H
$SG87135 DB	'%s\%s', 00H
	ORG $+2
$SG87137 DB	'%s%s', 00H
	ORG $+3
$SG87139 DB	'%s', 00H
$SG87161 DB	00H
$SG87162 DB	'iexplore.exe', 00H
	ORG $+3
$SG87163 DB	'open', 00H
$SG87211 DB	00H
$SG87227 DB	00H
$SG87235 DB	00H
$SG87243 DB	00H
$SG87251 DB	00H
	ORG $+2
$SG87260 DB	'\/', 00H
$SG87264 DB	00H
$SG87272 DB	'\', 00H
	ORG $+2
$SG87277 DB	'.', 00H
$SG87287 DB	00H
$SG87289 DB	00H
$SG87291 DB	00H
	ORG $+3
$SG87305 DB	'r', 00H
	ORG $+2
$SG87316 DB	'w', 00H
	ORG $+2
$SG87358 DB	'-', 00H
	ORG $+2
$SG87363 DB	'.', 00H
	ORG $+2
$SG87364 DB	':', 00H
	ORG $+2
$SG87365 DB	':', 00H
	ORG $+2
$SG87368 DB	' ', 00H
	ORG $+2
$SG87620 DB	'&', 00H
	ORG $+2
$SG87746 DB	'=', 00H
$SG87755 DB	00H
	ORG $+1
$SG87763 DB	'=', 00H
$SG87765 DB	00H
	ORG $+1
$SG87767 DB	'&', 00H
	ORG $+2
$SG87779 DB	'=', 00H
$SG87781 DB	00H
	ORG $+1
$SG87783 DB	'&', 00H
	ORG $+2
$SG87796 DB	'0', 00H
	ORG $+2
$SG87799 DB	'0', 00H
	ORG $+2
$SG87802 DB	'0', 00H
	ORG $+2
$SG87806 DB	'%x', 00H
	ORG $+1
$SG87807 DB	'%x', 00H
	ORG $+1
$SG87808 DB	'%x', 00H
	ORG $+1
$SG87889 DB	'\', 00H, '/', 00H, '"', 00H, '*', 00H, '<', 00H, '>', 00H
	DB	':', 00H, '?', 00H, '|', 00H, 00H, 00H
$SG87947 DB	'%c:\', 00H
	ORG $+3
$SG87956 DB	'\\?\%c:', 00H
$SG87978 DB	'rb', 00H
CONST	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__GetVersionExA@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -160						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

  00011	c7 85 60 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _ver$[ebp], 148 ; 00000094H

; 139  : 	::GetVersionEx( &ver );

  0001b	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _ver$[ebp]
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00028	83 bd 70 ff ff
	ff 02		 cmp	 DWORD PTR _ver$[ebp+16], 2
  0002f	75 15		 jne	 SHORT $L56668
  00031	83 bd 64 ff ff
	ff 05		 cmp	 DWORD PTR _ver$[ebp+4], 5
  00038	72 0c		 jb	 SHORT $L56668

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  0003a	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

  00044	eb 0a		 jmp	 SHORT $L56669
$L56668:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00046	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L56669:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  00050	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pfnGetThreadACP$[ebp]
  00056	51		 push	 ecx
  00057	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0005c	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pNew$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pp$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 93   : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetThreadLocale@0:NEAR
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
; Function compile flags: /Odt
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$56656 = -24					; size = 4
_lcidThread$ = -20					; size = 4
_szACP$ = -16						; size = 7
__$ArrayPad$ = -8					; size = 4
_nACP$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0
  0001b	89 45 ec	 mov	 DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  0001e	6a 07		 push	 7
  00020	8d 45 f0	 lea	 eax, DWORD PTR _szACP$[ebp]
  00023	50		 push	 eax
  00024	68 04 10 00 00	 push	 4100			; 00001004H
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _lcidThread$[ebp]
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00033	85 c0		 test	 eax, eax
  00035	74 34		 je	 SHORT $L56655

; 111  : 	{
; 112  : 		char* pch = szACP;

  00037	8d 55 f0	 lea	 edx, DWORD PTR _szACP$[ebp]
  0003a	89 55 e8	 mov	 DWORD PTR _pch$56656[ebp], edx
$L56658:

; 113  : 		while (*pch != '\0')

  0003d	8b 45 e8	 mov	 eax, DWORD PTR _pch$56656[ebp]
  00040	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00043	85 c9		 test	 ecx, ecx
  00045	74 24		 je	 SHORT $L56655

; 114  : 		{
; 115  : 			nACP *= 10;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  0004a	6b d2 0a	 imul	 edx, 10			; 0000000aH
  0004d	89 55 fc	 mov	 DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

  00050	8b 45 e8	 mov	 eax, DWORD PTR _pch$56656[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  00059	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  0005d	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
  00060	8b 4d e8	 mov	 ecx, DWORD PTR _pch$56656[ebp]
  00063	83 c1 01	 add	 ecx, 1
  00066	89 4d e8	 mov	 DWORD PTR _pch$56656[ebp], ecx

; 117  : 		}

  00069	eb d2		 jmp	 SHORT $L56658
$L56655:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  0006b	83 7d fc 00	 cmp	 DWORD PTR _nACP$[ebp], 0
  0006f	75 09		 jne	 SHORT $L56660

; 121  : 		nACP = ::GetACP();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  00077	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
$L56660:

; 122  : 
; 123  : 	return nACP;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _nACP$[ebp]

; 124  : }

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  : 	return( CP_THREAD_ACP );

  00003	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
PUBLIC	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z	; ATL::_AtlInstallStringThunk
PUBLIC	?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableW@12:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWThunk, COMDAT

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 184  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
; 185  : 		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetEnvironmentVariableW@12
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
  0000e	68 14 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 186  : 
; 187  : 	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);

  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 0c	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  00022	52		 push	 edx
  00023	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  00026	50		 push	 eax
  00027	ff 15 14 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20

; 188  : }

  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWThunk
_TEXT	ENDS
PUBLIC	?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
PUBLIC	??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
EXTRN	__imp__GetVersion@0:NEAR
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT
?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA DB 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT
??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 DD 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
; Function compile flags: /Odt
_BSS	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT
_pfn$ = -4						; size = 4
_ppThunk$ = 8						; size = 4
_pfnWin9x$ = 12						; size = 4
_pfnNT$ = 16						; size = 4
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z PROC NEAR	; ATL::_AtlInstallStringThunk, COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 116  : #pragma warning (push)
; 117  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 118  : 
; 119  : 	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
  00009	83 e0 01	 and	 eax, 1
  0000c	75 25		 jne	 SHORT $L72295
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
  00014	83 c9 01	 or	 ecx, 1
  00017	89 0d 00 00 00
	00		 mov	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, ecx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00023	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00028	f7 d8		 neg	 eax
  0002a	1b c0		 sbb	 eax, eax
  0002c	f7 d8		 neg	 eax
  0002e	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L72295:

; 120  : 	
; 121  : #pragma warning (pop)
; 122  : 
; 123  : 	void* pfn;
; 124  : 	if (s_bWin9x)

  00033	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  0003a	85 d2		 test	 edx, edx
  0003c	74 08		 je	 SHORT $L72297

; 125  : 		pfn = pfnWin9x;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _pfnWin9x$[ebp]
  00041	89 45 fc	 mov	 DWORD PTR _pfn$[ebp], eax

; 126  : 	else

  00044	eb 06		 jmp	 SHORT $L72298
$L72297:

; 127  : 	{
; 128  : #ifdef _CSTRING_ALWAYS_THUNK
; 129  : 		pfn = pfnWin9x;
; 130  : 		(void)pfnNT;
; 131  : #else
; 132  : 		pfn = pfnNT;

  00046	8b 4d 10	 mov	 ecx, DWORD PTR _pfnNT$[ebp]
  00049	89 4d fc	 mov	 DWORD PTR _pfn$[ebp], ecx
$L72298:

; 133  : #endif
; 134  : 	}
; 135  : 	InterlockedExchangePointer(ppThunk, pfn);

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _pfn$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 08	 mov	 eax, DWORD PTR _ppThunk$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 136  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ENDP	; ATL::_AtlInstallStringThunk
_TEXT	ENDS
PUBLIC	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
PUBLIC	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
PUBLIC	??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z		; ATL::CW2AEX<128>::CW2AEX<128>
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
PUBLIC	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CW2AEX<128>::operator char *
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp__GetEnvironmentVariableA@12:NEAR
EXTRN	__imp__MultiByteToWideChar@24:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T94687	DD	0ffffffffH
	DD	FLAT:$L94678
	DD	00H
	DD	FLAT:$L94679
$T94683	DD	019930520H
	DD	02H
	DD	FLAT:$T94687
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
$T94677 = -312						; size = 4
$T94676 = -308						; size = 4
$T94675 = -304						; size = 4
_pszBufferA$ = -300					; size = 132
_nSizeW$ = -160						; size = 4
_pszNameA$ = -156					; size = 132
__$ArrayPad$ = -20					; size = 4
_nSizeA$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWFake, COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 160  : 	ULONG nSizeA;
; 161  : 	ULONG nSizeW;
; 162  : 	CTempBuffer<char> pszBufferA;

  00026	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 163  : 	CW2A pszNameA(pszName);

  00038	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  0003b	50		 push	 eax
  0003c	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ; ATL::CW2AEX<128>::CW2AEX<128>
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 164  : 
; 165  : 	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00055	e8 00 00 00 00	 call	 ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ; ATL::CW2AEX<128>::operator char *
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12
  00061	89 45 f0	 mov	 DWORD PTR _nSizeA$[ebp], eax

; 166  : 	if (nSizeA == 0)

  00064	83 7d f0 00	 cmp	 DWORD PTR _nSizeA$[ebp], 0
  00068	75 36		 jne	 SHORT $L72369

; 167  : 		return 0;

  0006a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T94675[ebp], 0
  00074	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00078	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  0007e	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  00083	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00090	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  00095	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T94675[ebp]
  0009b	e9 ee 00 00 00	 jmp	 $L72341
$L72369:

; 168  : 
; 169  : 	pszBufferA.Allocate(nSizeA*2);

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _nSizeA$[ebp]
  000a3	d1 e1		 shl	 ecx, 1
  000a5	51		 push	 ecx
  000a6	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000ac	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 170  : 	::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA);

  000b1	8b 55 f0	 mov	 edx, DWORD PTR _nSizeA$[ebp]
  000b4	52		 push	 edx
  000b5	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000bb	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000c0	50		 push	 eax
  000c1	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  000c7	e8 00 00 00 00	 call	 ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ; ATL::CW2AEX<128>::operator char *
  000cc	50		 push	 eax
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12

; 171  : 
; 172  : 	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);

  000d3	6a 00		 push	 0
  000d5	6a 00		 push	 0
  000d7	6a ff		 push	 -1
  000d9	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000df	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  000ec	50		 push	 eax
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  000f3	89 85 60 ff ff
	ff		 mov	 DWORD PTR _nSizeW$[ebp], eax

; 173  : 	if (nSize == 0)

  000f9	83 7d 10 00	 cmp	 DWORD PTR _nSize$[ebp], 0
  000fd	75 35		 jne	 SHORT $L72371

; 174  : 		return nSizeW;

  000ff	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nSizeW$[ebp]
  00105	89 85 cc fe ff
	ff		 mov	 DWORD PTR $T94676[ebp], eax
  0010b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0010f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00115	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00121	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00127	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  0012c	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T94676[ebp]
  00132	eb 5a		 jmp	 SHORT $L72341
$L72371:

; 175  : 	ATLASSERT(nSize >= nSizeW);
; 176  : 	::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW);

  00134	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _nSizeW$[ebp]
  0013a	51		 push	 ecx
  0013b	8b 55 0c	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  0013e	52		 push	 edx
  0013f	6a ff		 push	 -1
  00141	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00147	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  0014c	50		 push	 eax
  0014d	6a 00		 push	 0
  0014f	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00154	50		 push	 eax
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 177  : 
; 178  : 	return nSizeW;

  0015b	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nSizeW$[ebp]
  00161	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T94677[ebp], eax
  00167	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0016b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00171	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  00176	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0017d	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00183	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  00188	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T94677[ebp]
$L72341:

; 179  : }

  0018e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00191	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00198	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L94678:
  00000	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
$L94679:
  0000b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94683
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 158  : 	return( g_pfnGetThreadACP() );

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 159  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringW@24:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWThunk, COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 217  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CompareStringW@24
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ; ATL::CompareStringWFake
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A ; ATL::_strthunks
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : 
; 219  : 	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);

  0001b	8b 4d 1c	 mov	 ecx, DWORD PTR _nLength2$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 18	 mov	 edx, DWORD PTR _pszString2$[ebp]
  00022	52		 push	 edx
  00023	8b 45 14	 mov	 eax, DWORD PTR _nLength1$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR _pszString1$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR _lcid$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A

; 220  : }

  00039	5d		 pop	 ebp
  0003a	c2 18 00	 ret	 24			; 00000018H
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWThunk
_TEXT	ENDS
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
PUBLIC	?AtlW2AHelper@@YGPADPADPB_WHI@Z			; AtlW2AHelper
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
EXTRN	__imp__lstrlenW@4:NEAR
EXTRN	__alloca_probe:NEAR
EXTRN	__imp__CompareStringA@24:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T94711	DD	0ffffffffH
	DD	FLAT:$L94706
$T94708	DD	019930520H
	DD	01H
	DD	FLAT:$T94711
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
tv147 = -68						; size = 4
tv142 = -64						; size = 4
tv149 = -60						; size = 4
tv89 = -56						; size = 4
tv84 = -52						; size = 4
tv91 = -48						; size = 4
$T94705 = -44						; size = 4
_pszAString1$ = -40					; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__convert_ex$ = -32					; size = 4
__acp_ex$ = -28						; size = 4
_pszAString2$ = -24					; size = 4
__lpw_ex$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWFake, COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 38	 sub	 esp, 56			; 00000038H

; 193  : 	USES_CONVERSION_EX;

  0001b	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00020	89 45 e4	 mov	 DWORD PTR __acp_ex$[ebp], eax
  00023	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 194  : 	
; 195  : 	LPCSTR pszAString1 = NULL;

  00032	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pszAString1$[ebp], 0

; 196  : 	if(pszString1 != NULL)

  00039	83 7d 10 00	 cmp	 DWORD PTR _pszString1$[ebp], 0
  0003d	0f 84 98 00 00
	00		 je	 $L72395

; 197  : 	{
; 198  : 		pszAString1 = W2A_EX(pszString1,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00043	8b 45 10	 mov	 eax, DWORD PTR _pszString1$[ebp]
  00046	89 45 f0	 mov	 DWORD PTR __lpw_ex$[ebp], eax
  00049	83 7d f0 00	 cmp	 DWORD PTR __lpw_ex$[ebp], 0
  0004d	75 09		 jne	 SHORT $L94699
  0004f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
  00056	eb 6d		 jmp	 SHORT $L94700
$L94699:
  00058	8b 4d f0	 mov	 ecx, DWORD PTR __lpw_ex$[ebp]
  0005b	51		 push	 ecx
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00062	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00066	89 55 e0	 mov	 DWORD PTR __convert_ex$[ebp], edx
  00069	81 7d e0 00 04
	00 00		 cmp	 DWORD PTR __convert_ex$[ebp], 1024 ; 00000400H
  00070	7f 2c		 jg	 SHORT $L94697
  00072	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0007b	83 c4 04	 add	 esp, 4
  0007e	0f b6 c8	 movzx	 ecx, al
  00081	85 c9		 test	 ecx, ecx
  00083	74 19		 je	 SHORT $L94697
  00085	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00088	83 c0 03	 add	 eax, 3
  0008b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008e	e8 00 00 00 00	 call	 __alloca_probe
  00093	89 65 cc	 mov	 DWORD PTR tv84[ebp], esp
  00096	8b 55 cc	 mov	 edx, DWORD PTR tv84[ebp]
  00099	89 55 c8	 mov	 DWORD PTR tv89[ebp], edx
  0009c	eb 0f		 jmp	 SHORT $L94698
$L94697:
  0009e	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  000a1	50		 push	 eax
  000a2	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000a5	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  000aa	89 45 c8	 mov	 DWORD PTR tv89[ebp], eax
$L94698:
  000ad	8b 4d e4	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 e0	 mov	 edx, DWORD PTR __convert_ex$[ebp]
  000b4	52		 push	 edx
  000b5	8b 45 f0	 mov	 eax, DWORD PTR __lpw_ex$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d c8	 mov	 ecx, DWORD PTR tv89[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  000c2	89 45 d0	 mov	 DWORD PTR tv91[ebp], eax
$L94700:
  000c5	8b 55 d0	 mov	 edx, DWORD PTR tv91[ebp]
  000c8	89 55 d8	 mov	 DWORD PTR _pszAString1$[ebp], edx

; 199  : 		if(pszAString1 == NULL)

  000cb	83 7d d8 00	 cmp	 DWORD PTR _pszAString1$[ebp], 0
  000cf	75 0a		 jne	 SHORT $L72395

; 200  : 			AtlThrow(E_OUTOFMEMORY);

  000d1	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  000d6	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L72395:

; 201  : 	}
; 202  : 
; 203  : 	LPCSTR pszAString2 = NULL;

  000db	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pszAString2$[ebp], 0

; 204  : 	if(pszString2 != NULL)

  000e2	83 7d 18 00	 cmp	 DWORD PTR _pszString2$[ebp], 0
  000e6	0f 84 98 00 00
	00		 je	 $L72401

; 205  : 	{
; 206  : 		pszAString2 = W2A_EX(pszString2,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  000ec	8b 45 18	 mov	 eax, DWORD PTR _pszString2$[ebp]
  000ef	89 45 f0	 mov	 DWORD PTR __lpw_ex$[ebp], eax
  000f2	83 7d f0 00	 cmp	 DWORD PTR __lpw_ex$[ebp], 0
  000f6	75 09		 jne	 SHORT $L94703
  000f8	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv149[ebp], 0
  000ff	eb 6d		 jmp	 SHORT $L94704
$L94703:
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __lpw_ex$[ebp]
  00104	51		 push	 ecx
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0010b	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  0010f	89 55 e0	 mov	 DWORD PTR __convert_ex$[ebp], edx
  00112	81 7d e0 00 04
	00 00		 cmp	 DWORD PTR __convert_ex$[ebp], 1024 ; 00000400H
  00119	7f 2c		 jg	 SHORT $L94701
  0011b	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  00124	83 c4 04	 add	 esp, 4
  00127	0f b6 c8	 movzx	 ecx, al
  0012a	85 c9		 test	 ecx, ecx
  0012c	74 19		 je	 SHORT $L94701
  0012e	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00131	83 c0 03	 add	 eax, 3
  00134	83 e0 fc	 and	 eax, -4			; fffffffcH
  00137	e8 00 00 00 00	 call	 __alloca_probe
  0013c	89 65 c0	 mov	 DWORD PTR tv142[ebp], esp
  0013f	8b 55 c0	 mov	 edx, DWORD PTR tv142[ebp]
  00142	89 55 bc	 mov	 DWORD PTR tv147[ebp], edx
  00145	eb 0f		 jmp	 SHORT $L94702
$L94701:
  00147	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  0014a	50		 push	 eax
  0014b	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  0014e	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  00153	89 45 bc	 mov	 DWORD PTR tv147[ebp], eax
$L94702:
  00156	8b 4d e4	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  00159	51		 push	 ecx
  0015a	8b 55 e0	 mov	 edx, DWORD PTR __convert_ex$[ebp]
  0015d	52		 push	 edx
  0015e	8b 45 f0	 mov	 eax, DWORD PTR __lpw_ex$[ebp]
  00161	50		 push	 eax
  00162	8b 4d bc	 mov	 ecx, DWORD PTR tv147[ebp]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0016b	89 45 c4	 mov	 DWORD PTR tv149[ebp], eax
$L94704:
  0016e	8b 55 c4	 mov	 edx, DWORD PTR tv149[ebp]
  00171	89 55 e8	 mov	 DWORD PTR _pszAString2$[ebp], edx

; 207  : 		if(pszAString2 == NULL)

  00174	83 7d e8 00	 cmp	 DWORD PTR _pszAString2$[ebp], 0
  00178	75 0a		 jne	 SHORT $L72401

; 208  : 			AtlThrow(E_OUTOFMEMORY);

  0017a	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0017f	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L72401:

; 209  : 	}
; 210  : 
; 211  : 	return ::CompareStringA(lcid, dwFlags, pszAString1, nLength1, pszAString2, nLength2);

  00184	8b 45 1c	 mov	 eax, DWORD PTR _nLength2$[ebp]
  00187	50		 push	 eax
  00188	8b 4d e8	 mov	 ecx, DWORD PTR _pszAString2$[ebp]
  0018b	51		 push	 ecx
  0018c	8b 55 14	 mov	 edx, DWORD PTR _nLength1$[ebp]
  0018f	52		 push	 edx
  00190	8b 45 d8	 mov	 eax, DWORD PTR _pszAString1$[ebp]
  00193	50		 push	 eax
  00194	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00197	51		 push	 ecx
  00198	8b 55 08	 mov	 edx, DWORD PTR _lcid$[ebp]
  0019b	52		 push	 edx
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CompareStringA@24
  001a2	89 45 d4	 mov	 DWORD PTR $T94705[ebp], eax
  001a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001ac	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  001af	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  001b4	8b 45 d4	 mov	 eax, DWORD PTR $T94705[ebp]
$L94696:

; 212  : }

  001b7	8d 65 bc	 lea	 esp, DWORD PTR [ebp-68]
  001ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L94706:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94708
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWFake
EXTRN	__imp___resetstkoflw:NEAR
EXTRN	__except_handler3:NEAR
;	COMDAT CONST
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
CONST	SEGMENT
$T94722	DD	0ffffffffH
	DD	FLAT:$L94717
	DD	FLAT:$L94718
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
tv65 = -40						; size = 4
$T94721 = -36						; size = 4
_p$56627 = -32						; size = 4
_bStackAvailable$ = -25					; size = 1
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 OFFSET FLAT:$T94722
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:__except_handler3
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00015	50		 push	 eax
  00016	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001d	83 c4 e8	 add	 esp, -24		; ffffffe8H
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 332  :     bool bStackAvailable = true;

  00026	c6 45 e7 01	 mov	 BYTE PTR _bStackAvailable$[ebp], 1

; 333  : 
; 334  :     __try

  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 335  :     {
; 336  :         PVOID p = _alloca(Size + _ATL_STACK_MARGIN);

  00031	8b 45 08	 mov	 eax, DWORD PTR _Size$[ebp]
  00034	05 03 20 00 00	 add	 eax, 8195		; 00002003H
  00039	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003c	e8 00 00 00 00	 call	 __alloca_probe
  00041	89 65 d8	 mov	 DWORD PTR tv65[ebp], esp
  00044	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00047	8b 45 d8	 mov	 eax, DWORD PTR tv65[ebp]
  0004a	89 45 e0	 mov	 DWORD PTR _p$56627[ebp], eax
  0004d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00054	eb 2c		 jmp	 SHORT $L94720
$L94717:
$L94726:

; 337  :         (p);
; 338  :     }
; 339  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 340  :                    EXCEPTION_EXECUTE_HANDLER :
; 341  :                    EXCEPTION_CONTINUE_SEARCH)

  00056	8b 4d ec	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+4]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8b 02		 mov	 eax, DWORD PTR [edx]
  0005d	89 45 dc	 mov	 DWORD PTR $T94721[ebp], eax
  00060	8b 45 dc	 mov	 eax, DWORD PTR $T94721[ebp]
  00063	2d fd 00 00 c0	 sub	 eax, -1073741571	; c00000fdH
  00068	f7 d8		 neg	 eax
  0006a	1b c0		 sbb	 eax, eax
  0006c	40		 inc	 eax
$L94719:
$L94725:
  0006d	c3		 ret	 0
$L94718:
  0006e	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 342  :     {
; 343  :         bStackAvailable = false;

  00071	c6 45 e7 00	 mov	 BYTE PTR _bStackAvailable$[ebp], 0

; 344  :         _resetstkoflw();

  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___resetstkoflw
  0007b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$L94720:

; 345  :     }
; 346  :     return bStackAvailable;

  00082	8a 45 e7	 mov	 al, BYTE PTR _bStackAvailable$[ebp]
$L94716:

; 347  : }

  00085	8d 65 cc	 lea	 esp, DWORD PTR [ebp-52]
  00088	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
EXTRN	__imp__WideCharToMultiByte@32:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPB_WHI@Z PROC NEAR		; AtlW2AHelper, COMDAT

; 573  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 574  : 	ATLASSERT(lpw != NULL);
; 575  : 	ATLASSERT(lpa != NULL);
; 576  : 	if (lpa == NULL || lpw == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpa$[ebp], 0
  00008	74 06		 je	 SHORT $L56814
  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpw$[ebp], 0
  0000e	75 04		 jne	 SHORT $L56813
$L56814:

; 577  : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 34		 jmp	 SHORT $L56810
$L56813:

; 578  : 	// verify that no illegal character present
; 579  : 	// since lpa was allocated based on the size of lpw
; 580  : 	// don't worry about the number of chars
; 581  : 	lpa[0] = '\0';

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpa$[ebp]
  00017	c6 00 00	 mov	 BYTE PTR [eax], 0

; 582  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR _nChars$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _lpa$[ebp]
  00025	52		 push	 edx
  00026	6a ff		 push	 -1
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lpw$[ebp]
  0002b	50		 push	 eax
  0002c	6a 00		 push	 0
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _acp$[ebp]
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00038	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 583  : 	if(ret == 0)

  0003b	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0003f	75 04		 jne	 SHORT $L56816

; 584  : 	{
; 585  : 		ATLASSERT(FALSE);
; 586  : 		return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	eb 03		 jmp	 SHORT $L56810
$L56816:

; 587  : 	}
; 588  : 	return lpa;

  00045	8b 45 08	 mov	 eax, DWORD PTR _lpa$[ebp]
$L56810:

; 589  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 10 00	 ret	 16			; 00000010H
?AtlW2AHelper@@YGPADPADPB_WHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
EXTRN	__CxxThrowException@8:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT __TI1?AVCAtlException@ATL@@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T94734 = -8						; size = 4
$T94733 = -4						; size = 4
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )
; 65   : 	{
; 66   : 		AfxThrowMemoryException();
; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );
; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );

  00006	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00009	50		 push	 eax
  0000a	8d 4d f8	 lea	 ecx, DWORD PTR $T94734[ebp]
  0000d	e8 00 00 00 00	 call	 ??0CAtlException@ATL@@QAE@J@Z ; ATL::CAtlException::CAtlException
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	89 4d fc	 mov	 DWORD PTR $T94733[ebp], ecx
  00017	68 00 00 00 00	 push	 OFFSET FLAT:__TI1?AVCAtlException@ATL@@
  0001c	8d 55 fc	 lea	 edx, DWORD PTR $T94733[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 __CxxThrowException@8
$L94732:

; 74   : #endif
; 75   : };

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC NEAR			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _hr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 41   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
PUBLIC	?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExW@20:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWThunk, COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 241  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetStringTypeExW@20
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ; ATL::GetStringTypeExWFake
  0000e	68 04 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  : 
; 243  : 	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);

  0001b	8b 4d 18	 mov	 ecx, DWORD PTR _pwCharType$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 14	 mov	 edx, DWORD PTR _nLength$[ebp]
  00022	52		 push	 edx
  00023	8b 45 10	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _dwInfoType$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _lcid$[ebp]
  0002e	52		 push	 edx
  0002f	ff 15 04 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4

; 244  : }

  00035	5d		 pop	 ebp
  00036	c2 14 00	 ret	 20			; 00000014H
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z ENDP	; ATL::GetStringTypeExWThunk
_TEXT	ENDS
EXTRN	__imp__GetStringTypeExA@20:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T94749	DD	0ffffffffH
	DD	FLAT:$L94744
$T94746	DD	019930520H
	DD	01H
	DD	FLAT:$T94749
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
$T94743 = -164						; size = 4
_nLengthA$ = -160					; size = 4
_pszA$ = -156						; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWFake, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 225  : 	int nLengthA;
; 226  : 	CTempBuffer<char> pszA;

  00026	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 227  : 
; 228  : 	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	8b 45 14	 mov	 eax, DWORD PTR _nLength$[ebp]
  00043	50		 push	 eax
  00044	8b 4d 10	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  00047	51		 push	 ecx
  00048	6a 00		 push	 0
  0004a	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00056	89 85 60 ff ff
	ff		 mov	 DWORD PTR _nLengthA$[ebp], eax

; 229  : 	pszA.Allocate(nLengthA);

  0005c	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _nLengthA$[ebp]
  00062	52		 push	 edx
  00063	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  00069	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 230  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nLengthA$[ebp]
  00078	50		 push	 eax
  00079	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  0007f	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  00084	50		 push	 eax
  00085	8b 4d 14	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 10	 mov	 edx, DWORD PTR _pszSrc$[ebp]
  0008c	52		 push	 edx
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 231  : 
; 232  : 	if (nLength == -1)

  0009b	83 7d 14 ff	 cmp	 DWORD PTR _nLength$[ebp], -1
  0009f	75 0a		 jne	 SHORT $L72427

; 233  : 		nLengthA = -1;

  000a1	c7 85 60 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _nLengthA$[ebp], -1
$L72427:

; 234  : 
; 235  : 	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);

  000ab	8b 45 18	 mov	 eax, DWORD PTR _pwCharType$[ebp]
  000ae	50		 push	 eax
  000af	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _nLengthA$[ebp]
  000b5	51		 push	 ecx
  000b6	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  000bc	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000c1	50		 push	 eax
  000c2	8b 55 0c	 mov	 edx, DWORD PTR _dwInfoType$[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 08	 mov	 eax, DWORD PTR _lcid$[ebp]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStringTypeExA@20
  000d0	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T94743[ebp], eax
  000d6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000dd	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  000e3	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  000e8	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T94743[ebp]

; 236  : }

  000ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L94744:
  00000	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94746
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ENDP		; ATL::GetStringTypeExWFake
PUBLIC	?lstrcmpiWFake@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiW@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWThunk, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 255  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__lstrcmpiW@8
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?lstrcmpiWFake@ATL@@YGHPB_W0@Z ; ATL::lstrcmpiWFake
  0000e	68 08 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 256  : 
; 257  : 	return _strthunks.pfnlstrcmpiW(psz1, psz2);

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _psz2$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _psz1$[ebp]
  00022	52		 push	 edx
  00023	ff 15 08 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8

; 258  : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWThunk
_TEXT	ENDS
EXTRN	__imp__lstrcmpiA@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv94 = -28						; size = 4
tv76 = -24						; size = 4
tv79 = -20						; size = 4
__acp$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWFake@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWFake, COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 248  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f4	 mov	 DWORD PTR __acp$[ebp], eax

; 249  : 
; 250  : 	return ::lstrcmpiA(W2A(psz1), W2A(psz2));

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _psz2$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L94756
  0001a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L94757
$L94756:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e8	 mov	 DWORD PTR tv76[ebp], esp
  00045	8b 45 f4	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e8	 mov	 eax, DWORD PTR tv76[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
$L94757:
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _psz1$[ebp]
  00060	89 4d f8	 mov	 DWORD PTR __lpw$[ebp], ecx
  00063	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00067	75 09		 jne	 SHORT $L94758
  00069	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00070	eb 3a		 jmp	 SHORT $L94759
$L94758:
  00072	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00075	52		 push	 edx
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0007c	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00080	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00083	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008c	e8 00 00 00 00	 call	 __alloca_probe
  00091	89 65 e0	 mov	 DWORD PTR tv91[ebp], esp
  00094	8b 4d f4	 mov	 ecx, DWORD PTR __acp$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 fc	 mov	 edx, DWORD PTR __convert$[ebp]
  0009b	52		 push	 edx
  0009c	8b 45 f8	 mov	 eax, DWORD PTR __lpw$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d e0	 mov	 ecx, DWORD PTR tv91[ebp]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  000a9	89 45 e4	 mov	 DWORD PTR tv94[ebp], eax
$L94759:
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000af	52		 push	 edx
  000b0	8b 45 e4	 mov	 eax, DWORD PTR tv94[ebp]
  000b3	50		 push	 eax
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8

; 251  : }

  000ba	8d 65 e0	 lea	 esp, DWORD PTR [ebp-32]
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
?lstrcmpiWFake@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWFake
_TEXT	ENDS
PUBLIC	?CharLowerWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWFake
EXTRN	__imp__CharLowerW@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWThunk, COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 274  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharLowerW@4
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CharLowerWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharLowerWFake
  0000e	68 0c 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  : 
; 276  : 	return _strthunks.pfnCharLowerW(psz);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 15 0c 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12

; 277  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWThunk
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z		; AtlA2WHelper
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	__imp__CharLowerA@4:NEAR
EXTRN	__imp__wcscpy:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
__lpa$ = -20						; size = 4
__acp$ = -16						; size = 4
_pszA$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWFake, COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 262  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f0	 mov	 DWORD PTR __acp$[ebp], eax

; 263  : 	LPSTR pszA;
; 264  : 
; 265  : 	pszA = W2A(psz);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L94764
  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L94765
$L94764:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e4	 mov	 DWORD PTR tv75[ebp], esp
  00045	8b 45 f0	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$L94765:
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00060	89 4d f4	 mov	 DWORD PTR _pszA$[ebp], ecx

; 266  : 	::CharLowerA(pszA);

  00063	8b 55 f4	 mov	 edx, DWORD PTR _pszA$[ebp]
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharLowerA@4

; 267  : 	wcscpy(psz, A2W(pszA));

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _pszA$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR __lpa$[ebp], eax
  00073	83 7d ec 00	 cmp	 DWORD PTR __lpa$[ebp], 0
  00077	75 09		 jne	 SHORT $L94766
  00079	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00080	eb 3b		 jmp	 SHORT $L94767
$L94766:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00092	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00095	d1 e0		 shl	 eax, 1
  00097	83 c0 03	 add	 eax, 3
  0009a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0009d	e8 00 00 00 00	 call	 __alloca_probe
  000a2	89 65 dc	 mov	 DWORD PTR tv90[ebp], esp
  000a5	8b 55 f0	 mov	 edx, DWORD PTR __acp$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  000ba	89 45 e0	 mov	 DWORD PTR tv94[ebp], eax
$L94767:
  000bd	8b 45 e0	 mov	 eax, DWORD PTR tv94[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  000c4	51		 push	 ecx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000cb	83 c4 08	 add	 esp, 8

; 268  : 
; 269  : 	return psz;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]

; 270  : }

  000d1	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z PROC NEAR		; AtlA2WHelper, COMDAT

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 555  : 	ATLASSERT(lpa != NULL);
; 556  : 	ATLASSERT(lpw != NULL);
; 557  : 	if (lpw == NULL || lpa == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpw$[ebp], 0
  00008	74 06		 je	 SHORT $L56801
  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpa$[ebp], 0
  0000e	75 04		 jne	 SHORT $L56800
$L56801:

; 558  : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 32		 jmp	 SHORT $L56797
$L56800:

; 559  : 	// verify that no illegal character present
; 560  : 	// since lpw was allocated based on the size of lpa
; 561  : 	// don't worry about the number of chars
; 562  : 	lpw[0] = '\0';

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
  00017	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 563  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _nChars$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 08	 mov	 edx, DWORD PTR _lpw$[ebp]
  00023	52		 push	 edx
  00024	6a ff		 push	 -1
  00026	8b 45 0c	 mov	 eax, DWORD PTR _lpa$[ebp]
  00029	50		 push	 eax
  0002a	6a 00		 push	 0
  0002c	8b 4d 14	 mov	 ecx, DWORD PTR _acp$[ebp]
  0002f	51		 push	 ecx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00036	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 564  : 	if(ret == 0)

  00039	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0003d	75 04		 jne	 SHORT $L56803

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);
; 567  : 		return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	eb 03		 jmp	 SHORT $L56797
$L56803:

; 568  : 	}		
; 569  : 	return lpw;

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
$L56797:

; 570  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?CharUpperWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWFake
EXTRN	__imp__CharUpperW@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWThunk, COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharUpperW@4
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CharUpperWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharUpperWFake
  0000e	68 10 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 294  : 
; 295  : 	return _strthunks.pfnCharUpperW(psz);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 15 10 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16

; 296  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWThunk
_TEXT	ENDS
EXTRN	__imp__CharUpperA@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
__lpa$ = -20						; size = 4
__acp$ = -16						; size = 4
_pszA$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWFake, COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 281  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f0	 mov	 DWORD PTR __acp$[ebp], eax

; 282  : 	LPSTR pszA;
; 283  : 
; 284  : 	pszA = W2A(psz);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L94774
  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L94775
$L94774:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e4	 mov	 DWORD PTR tv75[ebp], esp
  00045	8b 45 f0	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$L94775:
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00060	89 4d f4	 mov	 DWORD PTR _pszA$[ebp], ecx

; 285  : 	::CharUpperA(pszA);

  00063	8b 55 f4	 mov	 edx, DWORD PTR _pszA$[ebp]
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharUpperA@4

; 286  : 	wcscpy(psz, A2W(pszA));

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _pszA$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR __lpa$[ebp], eax
  00073	83 7d ec 00	 cmp	 DWORD PTR __lpa$[ebp], 0
  00077	75 09		 jne	 SHORT $L94776
  00079	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00080	eb 3b		 jmp	 SHORT $L94777
$L94776:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00092	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00095	d1 e0		 shl	 eax, 1
  00097	83 c0 03	 add	 eax, 3
  0009a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0009d	e8 00 00 00 00	 call	 __alloca_probe
  000a2	89 65 dc	 mov	 DWORD PTR tv90[ebp], esp
  000a5	8b 55 f0	 mov	 edx, DWORD PTR __acp$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  000ba	89 45 e0	 mov	 DWORD PTR tv94[ebp], eax
$L94777:
  000bd	8b 45 e0	 mov	 eax, DWORD PTR tv94[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  000c4	51		 push	 ecx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000cb	83 c4 08	 add	 esp, 8

; 287  : 
; 288  : 	return psz;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]

; 289  : }

  000d1	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWFake
_TEXT	ENDS
PUBLIC	??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ		; ATL::CSimpleStringT<char,0>::operator char const *
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADXZ	; ATL::CSimpleStringT<char,0>::GetBuffer
PUBLIC	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ	; ATL::CSimpleStringT<char,0>::GetLength
PUBLIC	??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
PUBLIC	??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
PUBLIC	??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
PUBLIC	??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
PUBLIC	??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=
PUBLIC	??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=
PUBLIC	?Find@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHDH@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Find
PUBLIC	?ReverseFind@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::ReverseFind
PUBLIC	?Right@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Right
PUBLIC	?Left@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Left
PUBLIC	?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Format
PUBLIC	??HATL@@YA?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@0@ABV10@0@Z ; ATL::operator+
PUBLIC	?MoveFileDelayAbPath@@YAXAAV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@@Z ; MoveFileDelayAbPath
EXTRN	__imp__FindFirstFileA@8:NEAR
EXTRN	__imp__MoveFileExA@12:NEAR
EXTRN	__imp__rename:NEAR
EXTRN	__imp__itoa:NEAR
EXTRN	__imp__FindClose@4:NEAR
EXTRN	_memset:NEAR
EXTRN	__imp__GetTempPathA@8:NEAR
xdata$x	SEGMENT
$T94796	DD	0ffffffffH
	DD	FLAT:$L94784
	DD	00H
	DD	FLAT:$L94785
	DD	01H
	DD	FLAT:$L94786
	DD	02H
	DD	FLAT:$L94787
	DD	03H
	DD	FLAT:$L94788
	DD	04H
	DD	FLAT:$L94789
	DD	05H
	DD	FLAT:$L94790
$T94793	DD	019930520H
	DD	07H
	DD	FLAT:$T94796
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\commonlib\common\tools.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv245 = -696						; size = 4
tv243 = -692						; size = 4
tv187 = -688						; size = 4
$T94783 = -684						; size = 4
$T94782 = -677						; size = 1
$T94781 = -676						; size = 4
_hFind$ = -672						; size = 4
_szNum$ = -668						; size = 32
_tempFile$ = -636					; size = 4
_dwResult$ = -632					; size = 4
_postfix$ = -628					; size = 4
_sysTempFile$ = -624					; size = 4
_ret$ = -620						; size = 4
_TempPath$ = -616					; size = 4
_temp1$ = -612						; size = 4
_temp$ = -608						; size = 4
_ffd$ = -604						; size = 320
_szTempPath$ = -284					; size = 260
__$ArrayPad$ = -20					; size = 4
_n$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_fileName$ = 8						; size = 4
?MoveFileDelayAbPath@@YAXAAV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@@Z PROC NEAR ; MoveFileDelayAbPath

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MoveFileDelayAbPath@@YAXAAV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec ac 02 00
	00		 sub	 esp, 684		; 000002acH
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	56		 push	 esi

; 20   : 	//,
; 21   : 	char szTempPath[MAX_PATH], szNum[NUM_LENGTH];
; 22   : 	memset(szTempPath, 0, MAX_PATH);

  00027	68 04 01 00 00	 push	 260			; 00000104H
  0002c	6a 00		 push	 0
  0002e	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _szTempPath$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23   : 	memset(szNum, 0, NUM_LENGTH);

  0003d	6a 20		 push	 32			; 00000020H
  0003f	6a 00		 push	 0
  00041	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR _szNum$[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _memset
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24   : 	DWORD dwResult=::GetTempPath(MAX_PATH, szTempPath);

  00050	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _szTempPath$[ebp]
  00056	52		 push	 edx
  00057	68 04 01 00 00	 push	 260			; 00000104H
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTempPathA@8
  00062	89 85 88 fd ff
	ff		 mov	 DWORD PTR _dwResult$[ebp], eax

; 25   : 
; 26   : 	CSTRING TempPath = szTempPath;

  00068	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _szTempPath$[ebp]
  0006e	50		 push	 eax
  0006f	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _TempPath$[ebp]
  00075	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0007a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 27   : 	CSTRING temp = fileName.Left(fileName.Find('.'));

  00081	6a 00		 push	 0
  00083	6a 2e		 push	 46			; 0000002eH
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  00088	e8 00 00 00 00	 call	 ?Find@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHDH@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Find
  0008d	50		 push	 eax
  0008e	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00094	51		 push	 ecx
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  00098	e8 00 00 00 00	 call	 ?Left@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Left
  0009d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 28   : 	CSTRING postfix = fileName.Right(fileName.GetLength() - fileName.ReverseFind('.'));

  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  000a4	e8 00 00 00 00	 call	 ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
  000a9	8b f0		 mov	 esi, eax
  000ab	6a 2e		 push	 46			; 0000002eH
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  000b0	e8 00 00 00 00	 call	 ?ReverseFind@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::ReverseFind
  000b5	2b f0		 sub	 esi, eax
  000b7	56		 push	 esi
  000b8	8d 95 8c fd ff
	ff		 lea	 edx, DWORD PTR _postfix$[ebp]
  000be	52		 push	 edx
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  000c2	e8 00 00 00 00	 call	 ?Right@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Right
  000c7	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 29   : 	CSTRING tempFile, sysTempFile;

  000cb	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _tempFile$[ebp]
  000d1	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  000d6	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000da	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _sysTempFile$[ebp]
  000e0	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  000e5	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 30   : 
; 31   : 	dwResult=::GetTempPath(MAX_PATH, szTempPath);

  000e9	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _szTempPath$[ebp]
  000ef	50		 push	 eax
  000f0	68 04 01 00 00	 push	 260			; 00000104H
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTempPathA@8
  000fb	89 85 88 fd ff
	ff		 mov	 DWORD PTR _dwResult$[ebp], eax

; 32   : 	TempPath = szTempPath;

  00101	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _szTempPath$[ebp]
  00107	51		 push	 ecx
  00108	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _TempPath$[ebp]
  0010e	e8 00 00 00 00	 call	 ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=

; 33   : 	int n = 0;

  00113	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 34   : 	HANDLE hFind;
; 35   : 	WIN32_FIND_DATA ffd; 
; 36   : 	tempFile.Format("%s.%s.tmp", temp.GetBuffer(), itoa(n, szNum, 10));

  0011a	6a 0a		 push	 10			; 0000000aH
  0011c	8d 95 64 fd ff
	ff		 lea	 edx, DWORD PTR _szNum$[ebp]
  00122	52		 push	 edx
  00123	8b 45 f0	 mov	 eax, DWORD PTR _n$[ebp]
  00126	50		 push	 eax
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__itoa
  0012d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00130	50		 push	 eax
  00131	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00137	e8 00 00 00 00	 call	 ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADXZ ; ATL::CSimpleStringT<char,0>::GetBuffer
  0013c	50		 push	 eax
  0013d	68 00 00 00 00	 push	 OFFSET FLAT:$SG87058
  00142	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _tempFile$[ebp]
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Format
  0014e	83 c4 10	 add	 esp, 16			; 00000010H

; 37   : 	hFind = FindFirstFile(tempFile, &ffd);

  00151	8d 95 a4 fd ff
	ff		 lea	 edx, DWORD PTR _ffd$[ebp]
  00157	52		 push	 edx
  00158	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _tempFile$[ebp]
  0015e	e8 00 00 00 00	 call	 ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::operator char const *
  00163	50		 push	 eax
  00164	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  0016a	89 85 60 fd ff
	ff		 mov	 DWORD PTR _hFind$[ebp], eax
$L87060:

; 38   : 	while(hFind != INVALID_HANDLE_VALUE)

  00170	83 bd 60 fd ff
	ff ff		 cmp	 DWORD PTR _hFind$[ebp], -1
  00177	74 6e		 je	 SHORT $L87061

; 39   : 	{
; 40   : 		n++;

  00179	8b 45 f0	 mov	 eax, DWORD PTR _n$[ebp]
  0017c	83 c0 01	 add	 eax, 1
  0017f	89 45 f0	 mov	 DWORD PTR _n$[ebp], eax

; 41   : 		FindClose(hFind);

  00182	8b 8d 60 fd ff
	ff		 mov	 ecx, DWORD PTR _hFind$[ebp]
  00188	51		 push	 ecx
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4

; 42   : 		tempFile.Format("%s.%s.tmp", temp.GetBuffer(), itoa(n, szNum, 10));

  0018f	6a 0a		 push	 10			; 0000000aH
  00191	8d 95 64 fd ff
	ff		 lea	 edx, DWORD PTR _szNum$[ebp]
  00197	52		 push	 edx
  00198	8b 45 f0	 mov	 eax, DWORD PTR _n$[ebp]
  0019b	50		 push	 eax
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__itoa
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a5	50		 push	 eax
  001a6	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  001ac	e8 00 00 00 00	 call	 ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADXZ ; ATL::CSimpleStringT<char,0>::GetBuffer
  001b1	50		 push	 eax
  001b2	68 00 00 00 00	 push	 OFFSET FLAT:$SG87064
  001b7	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _tempFile$[ebp]
  001bd	51		 push	 ecx
  001be	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Format
  001c3	83 c4 10	 add	 esp, 16			; 00000010H

; 43   : 		hFind = FindFirstFile(tempFile, &ffd);

  001c6	8d 95 a4 fd ff
	ff		 lea	 edx, DWORD PTR _ffd$[ebp]
  001cc	52		 push	 edx
  001cd	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _tempFile$[ebp]
  001d3	e8 00 00 00 00	 call	 ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::operator char const *
  001d8	50		 push	 eax
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  001df	89 85 60 fd ff
	ff		 mov	 DWORD PTR _hFind$[ebp], eax

; 44   : 	}

  001e5	eb 89		 jmp	 SHORT $L87060
$L87061:

; 45   : 	tempFile.Format("%s.%s.tmp", temp.GetBuffer(), itoa(n, szNum, 10));

  001e7	6a 0a		 push	 10			; 0000000aH
  001e9	8d 85 64 fd ff
	ff		 lea	 eax, DWORD PTR _szNum$[ebp]
  001ef	50		 push	 eax
  001f0	8b 4d f0	 mov	 ecx, DWORD PTR _n$[ebp]
  001f3	51		 push	 ecx
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__itoa
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fd	50		 push	 eax
  001fe	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00204	e8 00 00 00 00	 call	 ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADXZ ; ATL::CSimpleStringT<char,0>::GetBuffer
  00209	50		 push	 eax
  0020a	68 00 00 00 00	 push	 OFFSET FLAT:$SG87065
  0020f	8d 95 84 fd ff
	ff		 lea	 edx, DWORD PTR _tempFile$[ebp]
  00215	52		 push	 edx
  00216	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Format
  0021b	83 c4 10	 add	 esp, 16			; 00000010H

; 46   : 	int ret = temp.ReverseFind('\\');

  0021e	6a 5c		 push	 92			; 0000005cH
  00220	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00226	e8 00 00 00 00	 call	 ?ReverseFind@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::ReverseFind
  0022b	89 85 94 fd ff
	ff		 mov	 DWORD PTR _ret$[ebp], eax

; 47   : 	CSTRING temp1 = temp;

  00231	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  00237	50		 push	 eax
  00238	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _temp1$[ebp]
  0023e	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  00243	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 48   : 	if(ret != -1)

  00247	83 bd 94 fd ff
	ff ff		 cmp	 DWORD PTR _ret$[ebp], -1
  0024e	74 5e		 je	 SHORT $L87068

; 49   : 	{
; 50   : 		temp1 = temp.Right(temp.GetLength() - ret -1);

  00250	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00256	e8 00 00 00 00	 call	 ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
  0025b	2b 85 94 fd ff
	ff		 sub	 eax, DWORD PTR _ret$[ebp]
  00261	83 e8 01	 sub	 eax, 1
  00264	50		 push	 eax
  00265	8d 8d 5c fd ff
	ff		 lea	 ecx, DWORD PTR $T94781[ebp]
  0026b	51		 push	 ecx
  0026c	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00272	e8 00 00 00 00	 call	 ?Right@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Right
  00277	89 85 50 fd ff
	ff		 mov	 DWORD PTR tv187[ebp], eax
  0027d	8b 95 50 fd ff
	ff		 mov	 edx, DWORD PTR tv187[ebp]
  00283	89 95 4c fd ff
	ff		 mov	 DWORD PTR tv243[ebp], edx
  00289	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0028d	8b 85 4c fd ff
	ff		 mov	 eax, DWORD PTR tv243[ebp]
  00293	50		 push	 eax
  00294	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _temp1$[ebp]
  0029a	e8 00 00 00 00	 call	 ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=
  0029f	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  002a3	8d 8d 5c fd ff
	ff		 lea	 ecx, DWORD PTR $T94781[ebp]
  002a9	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L87068:

; 51   : 	}
; 52   : 	sysTempFile.Format("%s\\%s.tmp", TempPath.GetBuffer(), temp1.GetBuffer());

  002ae	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _temp1$[ebp]
  002b4	e8 00 00 00 00	 call	 ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADXZ ; ATL::CSimpleStringT<char,0>::GetBuffer
  002b9	50		 push	 eax
  002ba	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _TempPath$[ebp]
  002c0	e8 00 00 00 00	 call	 ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADXZ ; ATL::CSimpleStringT<char,0>::GetBuffer
  002c5	50		 push	 eax
  002c6	68 00 00 00 00	 push	 OFFSET FLAT:$SG87073
  002cb	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _sysTempFile$[ebp]
  002d1	51		 push	 ecx
  002d2	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Format
  002d7	83 c4 10	 add	 esp, 16			; 00000010H

; 53   : 
; 54   : 	if(rename(temp + postfix, tempFile) == 0)

  002da	8d 95 8c fd ff
	ff		 lea	 edx, DWORD PTR _postfix$[ebp]
  002e0	52		 push	 edx
  002e1	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  002e7	50		 push	 eax
  002e8	8d 8d 54 fd ff
	ff		 lea	 ecx, DWORD PTR $T94783[ebp]
  002ee	51		 push	 ecx
  002ef	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@0@ABV10@0@Z ; ATL::operator+
  002f4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f7	89 85 48 fd ff
	ff		 mov	 DWORD PTR tv245[ebp], eax
  002fd	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _tempFile$[ebp]
  00303	e8 00 00 00 00	 call	 ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::operator char const *
  00308	50		 push	 eax
  00309	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR tv245[ebp]
  0030f	e8 00 00 00 00	 call	 ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::operator char const *
  00314	50		 push	 eax
  00315	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rename
  0031b	83 c4 08	 add	 esp, 8
  0031e	f7 d8		 neg	 eax
  00320	1b c0		 sbb	 eax, eax
  00322	40		 inc	 eax
  00323	88 85 5b fd ff
	ff		 mov	 BYTE PTR $T94782[ebp], al
  00329	8d 8d 54 fd ff
	ff		 lea	 ecx, DWORD PTR $T94783[ebp]
  0032f	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  00334	0f b6 95 5b fd
	ff ff		 movzx	 edx, BYTE PTR $T94782[ebp]
  0033b	85 d2		 test	 edx, edx
  0033d	74 20		 je	 SHORT $L87075

; 55   : 		MoveFileEx(tempFile, sysTempFile, MOVEFILE_DELAY_UNTIL_REBOOT | MOVEFILE_REPLACE_EXISTING); 

  0033f	6a 05		 push	 5
  00341	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _sysTempFile$[ebp]
  00347	e8 00 00 00 00	 call	 ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::operator char const *
  0034c	50		 push	 eax
  0034d	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _tempFile$[ebp]
  00353	e8 00 00 00 00	 call	 ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::operator char const *
  00358	50		 push	 eax
  00359	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileExA@12
$L87075:

; 56   : }

  0035f	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00363	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _temp1$[ebp]
  00369	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0036e	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00372	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _sysTempFile$[ebp]
  00378	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0037d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00381	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _tempFile$[ebp]
  00387	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0038c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00390	8d 8d 8c fd ff
	ff		 lea	 ecx, DWORD PTR _postfix$[ebp]
  00396	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0039b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0039f	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  003a5	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  003aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003b1	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _TempPath$[ebp]
  003b7	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  003bc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  003c6	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ce	5e		 pop	 esi
  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94784:
  00000	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _TempPath$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L94785:
  0000b	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L94786:
  00016	8d 8d 8c fd ff
	ff		 lea	 ecx, DWORD PTR _postfix$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L94787:
  00021	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _tempFile$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L94788:
  0002c	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _sysTempFile$[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L94789:
  00037	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _temp1$[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L94790:
  00042	8d 8d 5c fd ff
	ff		 lea	 ecx, DWORD PTR $T94781[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?MoveFileDelayAbPath@@YAXAAV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@@Z:
  0004d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94793
  00052	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?MoveFileDelayAbPath@@YAXAAV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@@Z ENDP ; MoveFileDelayAbPath
PUBLIC	__TI1?AVexception@@
PUBLIC	__CTA1?AVexception@@
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	?ConvertGB2312ToUnicode@@YAXPADPA_WH@Z		; ConvertGB2312ToUnicode
EXTRN	__imp_??0exception@@QAE@ABQBD@Z:NEAR
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
;	COMDAT __TI1?AVexception@@
xdata$x	SEGMENT
__TI1?AVexception@@ DD 00H
	DD	FLAT:??1exception@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA1?AVexception@@
xdata$x	ENDS
;	COMDAT __CTA1?AVexception@@
xdata$x	SEGMENT
__CTA1?AVexception@@ DD 01H
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
$T94799 = -20						; size = 4
$T94798 = -16						; size = 12
_len$ = -4						; size = 4
_strGB2312$ = 8						; size = 4
_pszWBuff$ = 12						; size = 4
_iBufferLen$ = 16					; size = 4
?ConvertGB2312ToUnicode@@YAXPADPA_WH@Z PROC NEAR	; ConvertGB2312ToUnicode

; 59   : {

  003e0	55		 push	 ebp
  003e1	8b ec		 mov	 ebp, esp
  003e3	83 ec 14	 sub	 esp, 20			; 00000014H

; 60   : 	int len=MultiByteToWideChar(CP_ACP, 0,strGB2312, -1, NULL,0);

  003e6	6a 00		 push	 0
  003e8	6a 00		 push	 0
  003ea	6a ff		 push	 -1
  003ec	8b 45 08	 mov	 eax, DWORD PTR _strGB2312$[ebp]
  003ef	50		 push	 eax
  003f0	6a 00		 push	 0
  003f2	6a 00		 push	 0
  003f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  003fa	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 61   : 	if (iBufferLen<len)

  003fd	8b 4d 10	 mov	 ecx, DWORD PTR _iBufferLen$[ebp]
  00400	3b 4d fc	 cmp	 ecx, DWORD PTR _len$[ebp]
  00403	7d 22		 jge	 SHORT $L87083

; 62   : 	{
; 63   : 		throw exception("Buffer not big enough!");

  00405	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T94799[ebp], OFFSET FLAT:$SG87091
  0040c	8d 55 ec	 lea	 edx, DWORD PTR $T94799[ebp]
  0040f	52		 push	 edx
  00410	8d 4d f0	 lea	 ecx, DWORD PTR $T94798[ebp]
  00413	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABQBD@Z
  00419	68 00 00 00 00	 push	 OFFSET FLAT:__TI1?AVexception@@
  0041e	8d 45 f0	 lea	 eax, DWORD PTR $T94798[ebp]
  00421	50		 push	 eax
  00422	e8 00 00 00 00	 call	 __CxxThrowException@8
$L87083:

; 64   : 		return;
; 65   : 	}
; 66   : 	MultiByteToWideChar(CP_ACP, 0, strGB2312, -1, (LPWSTR)pszWBuff, len);

  00427	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  0042a	51		 push	 ecx
  0042b	8b 55 0c	 mov	 edx, DWORD PTR _pszWBuff$[ebp]
  0042e	52		 push	 edx
  0042f	6a ff		 push	 -1
  00431	8b 45 08	 mov	 eax, DWORD PTR _strGB2312$[ebp]
  00434	50		 push	 eax
  00435	6a 00		 push	 0
  00437	6a 00		 push	 0
  00439	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
$L94797:

; 67   : }

  0043f	8b e5		 mov	 esp, ebp
  00441	5d		 pop	 ebp
  00442	c3		 ret	 0
?ConvertGB2312ToUnicode@@YAXPADPA_WH@Z ENDP		; ConvertGB2312ToUnicode
_TEXT	ENDS
PUBLIC	?win32exec@@YAPAXPBD0_N@Z			; win32exec
EXTRN	__imp___snprintf:NEAR
EXTRN	__imp__CreateProcessA@40:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	_strlen:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_len$87107 = -2156					; size = 4
_si$ = -2152						; size = 68
_pi$ = -2076						; size = 16
_nRet$ = -2060						; size = 4
_cmd$ = -2056						; size = 2048
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_cmdline$ = 8						; size = 4
_workpath$ = 12						; size = 4
_waiting$ = 16						; size = 1
?win32exec@@YAPAXPBD0_N@Z PROC NEAR			; win32exec

; 72   : {

  00450	55		 push	 ebp
  00451	8b ec		 mov	 ebp, esp
  00453	81 ec 6c 08 00
	00		 sub	 esp, 2156		; 0000086cH
  00459	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0045e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 73   : 	STARTUPINFO    		 si;
; 74   : 	PROCESS_INFORMATION  pi;
; 75   : 	char cmd[CMD_LINE_LENGTH];
; 76   : 	int nRet;
; 77   : 
; 78   : 	memset(&si, 0, sizeof (STARTUPINFO)) ;

  00461	6a 44		 push	 68			; 00000044H
  00463	6a 00		 push	 0
  00465	8d 85 98 f7 ff
	ff		 lea	 eax, DWORD PTR _si$[ebp]
  0046b	50		 push	 eax
  0046c	e8 00 00 00 00	 call	 _memset
  00471	83 c4 0c	 add	 esp, 12			; 0000000cH

; 79   : 	si.cb = sizeof (STARTUPINFO) ;

  00474	c7 85 98 f7 ff
	ff 44 00 00 00	 mov	 DWORD PTR _si$[ebp], 68	; 00000044H

; 80   : 	si.dwFlags = STARTF_USESHOWWINDOW;

  0047e	c7 85 c4 f7 ff
	ff 01 00 00 00	 mov	 DWORD PTR _si$[ebp+44], 1

; 81   : 	si.wShowWindow = SW_HIDE;

  00488	66 c7 85 c8 f7
	ff ff 00 00	 mov	 WORD PTR _si$[ebp+48], 0

; 82   : 	memset(&pi, 0, sizeof (PROCESS_INFORMATION));

  00491	6a 10		 push	 16			; 00000010H
  00493	6a 00		 push	 0
  00495	8d 8d e4 f7 ff
	ff		 lea	 ecx, DWORD PTR _pi$[ebp]
  0049b	51		 push	 ecx
  0049c	e8 00 00 00 00	 call	 _memset
  004a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 83   : 	memset(cmd, 0, CMD_LINE_LENGTH);

  004a4	68 00 08 00 00	 push	 2048			; 00000800H
  004a9	6a 00		 push	 0
  004ab	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _cmd$[ebp]
  004b1	52		 push	 edx
  004b2	e8 00 00 00 00	 call	 _memset
  004b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 84   : 
; 85   : 	if(workpath != "")

  004ba	81 7d 0c 00 00
	00 00		 cmp	 DWORD PTR _workpath$[ebp], OFFSET FLAT:$SG87106
  004c1	74 7e		 je	 SHORT $L87105

; 86   : 	{
; 87   : 		int len = (int)strlen(workpath);

  004c3	8b 45 0c	 mov	 eax, DWORD PTR _workpath$[ebp]
  004c6	50		 push	 eax
  004c7	e8 00 00 00 00	 call	 _strlen
  004cc	83 c4 04	 add	 esp, 4
  004cf	89 85 94 f7 ff
	ff		 mov	 DWORD PTR _len$87107[ebp], eax

; 88   : 		if(workpath[len-1] != '/' && workpath[len-1] != '\\')

  004d5	8b 4d 0c	 mov	 ecx, DWORD PTR _workpath$[ebp]
  004d8	03 8d 94 f7 ff
	ff		 add	 ecx, DWORD PTR _len$87107[ebp]
  004de	0f be 51 ff	 movsx	 edx, BYTE PTR [ecx-1]
  004e2	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  004e5	74 36		 je	 SHORT $L87109
  004e7	8b 45 0c	 mov	 eax, DWORD PTR _workpath$[ebp]
  004ea	03 85 94 f7 ff
	ff		 add	 eax, DWORD PTR _len$87107[ebp]
  004f0	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  004f4	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  004f7	74 24		 je	 SHORT $L87109

; 89   : 			_snprintf(cmd, CMD_LINE_LENGTH-1, "%s\\%s", workpath, cmdline);

  004f9	8b 55 08	 mov	 edx, DWORD PTR _cmdline$[ebp]
  004fc	52		 push	 edx
  004fd	8b 45 0c	 mov	 eax, DWORD PTR _workpath$[ebp]
  00500	50		 push	 eax
  00501	68 00 00 00 00	 push	 OFFSET FLAT:$SG87110
  00506	68 ff 07 00 00	 push	 2047			; 000007ffH
  0050b	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _cmd$[ebp]
  00511	51		 push	 ecx
  00512	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  00518	83 c4 14	 add	 esp, 20			; 00000014H

; 90   : 		else

  0051b	eb 22		 jmp	 SHORT $L87111
$L87109:

; 91   : 			_snprintf(cmd, CMD_LINE_LENGTH-1, "%s%s", workpath, cmdline);

  0051d	8b 55 08	 mov	 edx, DWORD PTR _cmdline$[ebp]
  00520	52		 push	 edx
  00521	8b 45 0c	 mov	 eax, DWORD PTR _workpath$[ebp]
  00524	50		 push	 eax
  00525	68 00 00 00 00	 push	 OFFSET FLAT:$SG87112
  0052a	68 ff 07 00 00	 push	 2047			; 000007ffH
  0052f	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _cmd$[ebp]
  00535	51		 push	 ecx
  00536	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  0053c	83 c4 14	 add	 esp, 20			; 00000014H
$L87111:

; 92   : 	}
; 93   : 	else

  0053f	eb 1e		 jmp	 SHORT $L87113
$L87105:

; 94   : 		_snprintf(cmd, CMD_LINE_LENGTH-1, "%s", cmdline);

  00541	8b 55 08	 mov	 edx, DWORD PTR _cmdline$[ebp]
  00544	52		 push	 edx
  00545	68 00 00 00 00	 push	 OFFSET FLAT:$SG87114
  0054a	68 ff 07 00 00	 push	 2047			; 000007ffH
  0054f	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _cmd$[ebp]
  00555	50		 push	 eax
  00556	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  0055c	83 c4 10	 add	 esp, 16			; 00000010H
$L87113:

; 95   : 
; 96   : 	nRet = CreateProcess (NULL, cmd, NULL, NULL,
; 97   : 		FALSE, (DWORD) NORMAL_PRIORITY_CLASS, NULL,
; 98   : 		workpath, &si, &pi);

  0055f	8d 8d e4 f7 ff
	ff		 lea	 ecx, DWORD PTR _pi$[ebp]
  00565	51		 push	 ecx
  00566	8d 95 98 f7 ff
	ff		 lea	 edx, DWORD PTR _si$[ebp]
  0056c	52		 push	 edx
  0056d	8b 45 0c	 mov	 eax, DWORD PTR _workpath$[ebp]
  00570	50		 push	 eax
  00571	6a 00		 push	 0
  00573	6a 20		 push	 32			; 00000020H
  00575	6a 00		 push	 0
  00577	6a 00		 push	 0
  00579	6a 00		 push	 0
  0057b	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _cmd$[ebp]
  00581	51		 push	 ecx
  00582	6a 00		 push	 0
  00584	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateProcessA@40
  0058a	89 85 f4 f7 ff
	ff		 mov	 DWORD PTR _nRet$[ebp], eax

; 99   : 
; 100  : 	if(nRet==0)

  00590	83 bd f4 f7 ff
	ff 00		 cmp	 DWORD PTR _nRet$[ebp], 0
  00597	75 04		 jne	 SHORT $L87116

; 101  : 	{
; 102  : 		return NULL;

  00599	33 c0		 xor	 eax, eax
  0059b	eb 37		 jmp	 SHORT $L87097
$L87116:

; 103  : 	}
; 104  : 
; 105  : 	if(waiting) 

  0059d	0f b6 55 10	 movzx	 edx, BYTE PTR _waiting$[ebp]
  005a1	85 d2		 test	 edx, edx
  005a3	74 29		 je	 SHORT $L87117

; 106  : 	{
; 107  : 		WaitForSingleObject(pi.hProcess, INFINITE);

  005a5	6a ff		 push	 -1
  005a7	8b 85 e4 f7 ff
	ff		 mov	 eax, DWORD PTR _pi$[ebp]
  005ad	50		 push	 eax
  005ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 108  : 		CloseHandle(pi.hProcess);

  005b4	8b 8d e4 f7 ff
	ff		 mov	 ecx, DWORD PTR _pi$[ebp]
  005ba	51		 push	 ecx
  005bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 109  : 		CloseHandle(pi.hThread);

  005c1	8b 95 e8 f7 ff
	ff		 mov	 edx, DWORD PTR _pi$[ebp+4]
  005c7	52		 push	 edx
  005c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$L87117:

; 110  : 	}
; 111  : 
; 112  : 	return pi.hProcess;

  005ce	8b 85 e4 f7 ff
	ff		 mov	 eax, DWORD PTR _pi$[ebp]
$L87097:

; 113  : }

  005d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005dc	8b e5		 mov	 esp, ebp
  005de	5d		 pop	 ebp
  005df	c3		 ret	 0
?win32exec@@YAPAXPBD0_N@Z ENDP				; win32exec
_TEXT	ENDS
PUBLIC	?win32Showexec@@YAPAXPBD0_N@Z			; win32Showexec
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_len$87132 = -2156					; size = 4
_si$ = -2152						; size = 68
_pi$ = -2080						; size = 16
_dw$ = -2064						; size = 4
_nRet$ = -2060						; size = 4
_cmd$ = -2056						; size = 2048
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_cmdline$ = 8						; size = 4
_workpath$ = 12						; size = 4
_waiting$ = 16						; size = 1
?win32Showexec@@YAPAXPBD0_N@Z PROC NEAR			; win32Showexec

; 116  : {

  005e0	55		 push	 ebp
  005e1	8b ec		 mov	 ebp, esp
  005e3	81 ec 6c 08 00
	00		 sub	 esp, 2156		; 0000086cH
  005e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  005ee	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 117  : 	STARTUPINFO    		 si;
; 118  : 	PROCESS_INFORMATION  pi;
; 119  : 	char cmd[2048];
; 120  : 	int nRet;
; 121  : 
; 122  : 	memset(&si, 0, sizeof (STARTUPINFO)) ;

  005f1	6a 44		 push	 68			; 00000044H
  005f3	6a 00		 push	 0
  005f5	8d 85 98 f7 ff
	ff		 lea	 eax, DWORD PTR _si$[ebp]
  005fb	50		 push	 eax
  005fc	e8 00 00 00 00	 call	 _memset
  00601	83 c4 0c	 add	 esp, 12			; 0000000cH

; 123  : 	si.cb = sizeof (STARTUPINFO) ;

  00604	c7 85 98 f7 ff
	ff 44 00 00 00	 mov	 DWORD PTR _si$[ebp], 68	; 00000044H

; 124  : 	si.dwFlags = STARTF_USESHOWWINDOW;

  0060e	c7 85 c4 f7 ff
	ff 01 00 00 00	 mov	 DWORD PTR _si$[ebp+44], 1

; 125  : 	si.wShowWindow = SW_SHOW;

  00618	66 c7 85 c8 f7
	ff ff 05 00	 mov	 WORD PTR _si$[ebp+48], 5

; 126  : 	memset(&pi, 0, sizeof (PROCESS_INFORMATION));

  00621	6a 10		 push	 16			; 00000010H
  00623	6a 00		 push	 0
  00625	8d 8d e0 f7 ff
	ff		 lea	 ecx, DWORD PTR _pi$[ebp]
  0062b	51		 push	 ecx
  0062c	e8 00 00 00 00	 call	 _memset
  00631	83 c4 0c	 add	 esp, 12			; 0000000cH

; 127  : 	memset(cmd, 0, CMD_LINE_LENGTH);

  00634	68 00 08 00 00	 push	 2048			; 00000800H
  00639	6a 00		 push	 0
  0063b	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _cmd$[ebp]
  00641	52		 push	 edx
  00642	e8 00 00 00 00	 call	 _memset
  00647	83 c4 0c	 add	 esp, 12			; 0000000cH

; 128  : 
; 129  : 	if(workpath != "")

  0064a	81 7d 0c 00 00
	00 00		 cmp	 DWORD PTR _workpath$[ebp], OFFSET FLAT:$SG87131
  00651	74 7e		 je	 SHORT $L87130

; 130  : 	{
; 131  : 		int len = (int)strlen(workpath);

  00653	8b 45 0c	 mov	 eax, DWORD PTR _workpath$[ebp]
  00656	50		 push	 eax
  00657	e8 00 00 00 00	 call	 _strlen
  0065c	83 c4 04	 add	 esp, 4
  0065f	89 85 94 f7 ff
	ff		 mov	 DWORD PTR _len$87132[ebp], eax

; 132  : 		if(workpath[len-1] != '/' && workpath[len-1] != '\\')

  00665	8b 4d 0c	 mov	 ecx, DWORD PTR _workpath$[ebp]
  00668	03 8d 94 f7 ff
	ff		 add	 ecx, DWORD PTR _len$87132[ebp]
  0066e	0f be 51 ff	 movsx	 edx, BYTE PTR [ecx-1]
  00672	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  00675	74 36		 je	 SHORT $L87134
  00677	8b 45 0c	 mov	 eax, DWORD PTR _workpath$[ebp]
  0067a	03 85 94 f7 ff
	ff		 add	 eax, DWORD PTR _len$87132[ebp]
  00680	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  00684	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  00687	74 24		 je	 SHORT $L87134

; 133  : 			_snprintf(cmd, CMD_LINE_LENGTH-1, "%s\\%s", workpath, cmdline);

  00689	8b 55 08	 mov	 edx, DWORD PTR _cmdline$[ebp]
  0068c	52		 push	 edx
  0068d	8b 45 0c	 mov	 eax, DWORD PTR _workpath$[ebp]
  00690	50		 push	 eax
  00691	68 00 00 00 00	 push	 OFFSET FLAT:$SG87135
  00696	68 ff 07 00 00	 push	 2047			; 000007ffH
  0069b	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _cmd$[ebp]
  006a1	51		 push	 ecx
  006a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  006a8	83 c4 14	 add	 esp, 20			; 00000014H

; 134  : 		else

  006ab	eb 22		 jmp	 SHORT $L87136
$L87134:

; 135  : 			_snprintf(cmd, CMD_LINE_LENGTH-1, "%s%s", workpath, cmdline);

  006ad	8b 55 08	 mov	 edx, DWORD PTR _cmdline$[ebp]
  006b0	52		 push	 edx
  006b1	8b 45 0c	 mov	 eax, DWORD PTR _workpath$[ebp]
  006b4	50		 push	 eax
  006b5	68 00 00 00 00	 push	 OFFSET FLAT:$SG87137
  006ba	68 ff 07 00 00	 push	 2047			; 000007ffH
  006bf	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _cmd$[ebp]
  006c5	51		 push	 ecx
  006c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  006cc	83 c4 14	 add	 esp, 20			; 00000014H
$L87136:

; 136  : 	}
; 137  : 	else

  006cf	eb 1e		 jmp	 SHORT $L87138
$L87130:

; 138  : 		_snprintf(cmd, CMD_LINE_LENGTH-1, "%s", cmdline);

  006d1	8b 55 08	 mov	 edx, DWORD PTR _cmdline$[ebp]
  006d4	52		 push	 edx
  006d5	68 00 00 00 00	 push	 OFFSET FLAT:$SG87139
  006da	68 ff 07 00 00	 push	 2047			; 000007ffH
  006df	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _cmd$[ebp]
  006e5	50		 push	 eax
  006e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  006ec	83 c4 10	 add	 esp, 16			; 00000010H
$L87138:

; 139  : 
; 140  : 	nRet = CreateProcess (NULL, cmd, NULL, NULL,
; 141  : 		FALSE, (DWORD) NORMAL_PRIORITY_CLASS, NULL,
; 142  : 		workpath, &si, &pi);

  006ef	8d 8d e0 f7 ff
	ff		 lea	 ecx, DWORD PTR _pi$[ebp]
  006f5	51		 push	 ecx
  006f6	8d 95 98 f7 ff
	ff		 lea	 edx, DWORD PTR _si$[ebp]
  006fc	52		 push	 edx
  006fd	8b 45 0c	 mov	 eax, DWORD PTR _workpath$[ebp]
  00700	50		 push	 eax
  00701	6a 00		 push	 0
  00703	6a 20		 push	 32			; 00000020H
  00705	6a 00		 push	 0
  00707	6a 00		 push	 0
  00709	6a 00		 push	 0
  0070b	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _cmd$[ebp]
  00711	51		 push	 ecx
  00712	6a 00		 push	 0
  00714	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateProcessA@40
  0071a	89 85 f4 f7 ff
	ff		 mov	 DWORD PTR _nRet$[ebp], eax

; 143  : 	DWORD dw =GetLastError();

  00720	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00726	89 85 f0 f7 ff
	ff		 mov	 DWORD PTR _dw$[ebp], eax

; 144  : 
; 145  : 	if(nRet==0)

  0072c	83 bd f4 f7 ff
	ff 00		 cmp	 DWORD PTR _nRet$[ebp], 0
  00733	75 04		 jne	 SHORT $L87142

; 146  : 	{
; 147  : 		return NULL;

  00735	33 c0		 xor	 eax, eax
  00737	eb 37		 jmp	 SHORT $L87122
$L87142:

; 148  : 	}
; 149  : 
; 150  : 	if(waiting) 

  00739	0f b6 55 10	 movzx	 edx, BYTE PTR _waiting$[ebp]
  0073d	85 d2		 test	 edx, edx
  0073f	74 29		 je	 SHORT $L87143

; 151  : 	{
; 152  : 		WaitForSingleObject(pi.hProcess, INFINITE);

  00741	6a ff		 push	 -1
  00743	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _pi$[ebp]
  00749	50		 push	 eax
  0074a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 153  : 		CloseHandle(pi.hProcess);

  00750	8b 8d e0 f7 ff
	ff		 mov	 ecx, DWORD PTR _pi$[ebp]
  00756	51		 push	 ecx
  00757	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 154  : 		CloseHandle(pi.hThread);

  0075d	8b 95 e4 f7 ff
	ff		 mov	 edx, DWORD PTR _pi$[ebp+4]
  00763	52		 push	 edx
  00764	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$L87143:

; 155  : 	}
; 156  : 
; 157  : 	return pi.hProcess;

  0076a	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _pi$[ebp]
$L87122:

; 158  : }

  00770	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00773	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00778	8b e5		 mov	 esp, ebp
  0077a	5d		 pop	 ebp
  0077b	c3		 ret	 0
?win32Showexec@@YAPAXPBD0_N@Z ENDP			; win32Showexec
_TEXT	ENDS
PUBLIC	?BringWindowToTop@@YAXPAUHWND__@@K@Z		; BringWindowToTop
EXTRN	__imp__GetForegroundWindow@0:NEAR
EXTRN	__imp__SetForegroundWindow@4:NEAR
EXTRN	__imp__ShowWindow@8:NEAR
EXTRN	__imp__BringWindowToTop@4:NEAR
EXTRN	__imp__GetWindowThreadProcessId@8:NEAR
EXTRN	__imp__GetCurrentThreadId@0:NEAR
EXTRN	__imp__AttachThreadInput@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_dwFGThreadId$ = -16					; size = 4
_dwFGProcessId$ = -12					; size = 4
_dwThisThreadId$ = -8					; size = 4
_hwndForeground$ = -4					; size = 4
_hwnd$ = 8						; size = 4
_type$ = 12						; size = 4
?BringWindowToTop@@YAXPAUHWND__@@K@Z PROC NEAR		; BringWindowToTop

; 161  : {

  00780	55		 push	 ebp
  00781	8b ec		 mov	 ebp, esp
  00783	83 ec 10	 sub	 esp, 16			; 00000010H

; 162  : 	DWORD dwFGThreadId, dwFGProcessId,dwThisThreadId;
; 163  : 	HWND hwndForeground = ::GetForegroundWindow();

  00786	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetForegroundWindow@0
  0078c	89 45 fc	 mov	 DWORD PTR _hwndForeground$[ebp], eax

; 164  : 	dwFGThreadId = GetWindowThreadProcessId(hwndForeground, &dwFGProcessId);

  0078f	8d 45 f4	 lea	 eax, DWORD PTR _dwFGProcessId$[ebp]
  00792	50		 push	 eax
  00793	8b 4d fc	 mov	 ecx, DWORD PTR _hwndForeground$[ebp]
  00796	51		 push	 ecx
  00797	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowThreadProcessId@8
  0079d	89 45 f0	 mov	 DWORD PTR _dwFGThreadId$[ebp], eax

; 165  : 	dwThisThreadId = GetCurrentThreadId();

  007a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  007a6	89 45 f8	 mov	 DWORD PTR _dwThisThreadId$[ebp], eax

; 166  : 	AttachThreadInput(dwThisThreadId, dwFGThreadId,TRUE);

  007a9	6a 01		 push	 1
  007ab	8b 55 f0	 mov	 edx, DWORD PTR _dwFGThreadId$[ebp]
  007ae	52		 push	 edx
  007af	8b 45 f8	 mov	 eax, DWORD PTR _dwThisThreadId$[ebp]
  007b2	50		 push	 eax
  007b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AttachThreadInput@12

; 167  : 	if(type != NULL)

  007b9	83 7d 0c 00	 cmp	 DWORD PTR _type$[ebp], 0
  007bd	74 0e		 je	 SHORT $L87152

; 168  : 	{
; 169  : 		::ShowWindow(hwnd,type);

  007bf	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  007c2	51		 push	 ecx
  007c3	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  007c6	52		 push	 edx
  007c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$L87152:

; 170  : 	}
; 171  : 	::SetForegroundWindow(hwnd);

  007cd	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  007d0	50		 push	 eax
  007d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetForegroundWindow@4

; 172  : 	::BringWindowToTop(hwnd);

  007d7	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  007da	51		 push	 ecx
  007db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BringWindowToTop@4

; 173  : 	AttachThreadInput(dwThisThreadId, dwFGThreadId,FALSE);

  007e1	6a 00		 push	 0
  007e3	8b 55 f0	 mov	 edx, DWORD PTR _dwFGThreadId$[ebp]
  007e6	52		 push	 edx
  007e7	8b 45 f8	 mov	 eax, DWORD PTR _dwThisThreadId$[ebp]
  007ea	50		 push	 eax
  007eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AttachThreadInput@12

; 174  : }

  007f1	8b e5		 mov	 esp, ebp
  007f3	5d		 pop	 ebp
  007f4	c3		 ret	 0
?BringWindowToTop@@YAXPAUHWND__@@K@Z ENDP		; BringWindowToTop
_TEXT	ENDS
PUBLIC	?RunExplorer@@YAXV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@00@Z ; RunExplorer
EXTRN	__imp__ShellExecuteA@24:NEAR
EXTRN	__imp__FindWindowA@8:NEAR
EXTRN	__imp__Sleep@4:NEAR
xdata$x	SEGMENT
$T94815	DD	0ffffffffH
	DD	FLAT:$L94808
	DD	00H
	DD	FLAT:$L94809
	DD	01H
	DD	FLAT:$L94810
	DD	02H
	DD	FLAT:$L94811
$T94813	DD	019930520H
	DD	04H
	DD	FLAT:$T94815
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_i$87164 = -24						; size = 4
_hwnd$ = -20						; size = 4
_info$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_title$ = 8						; size = 4
_url$ = 12						; size = 4
_prepTitle$ = 16					; size = 4
?RunExplorer@@YAXV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@00@Z PROC NEAR ; RunExplorer

; 177  : {

  00800	55		 push	 ebp
  00801	8b ec		 mov	 ebp, esp
  00803	6a ff		 push	 -1
  00805	68 00 00 00 00	 push	 __ehhandler$?RunExplorer@@YAXV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@00@Z
  0080a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00810	50		 push	 eax
  00811	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00818	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0081b	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 178  : 	//char pbase[PATHSIZE], ipage[PATHSIZE];
; 179  : 	CSTRING info ;

  00822	8d 4d f0	 lea	 ecx, DWORD PTR _info$[ebp]
  00825	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0082a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 180  : 
; 181  : 	// 
; 182  : 	HWND hwnd = ::FindWindow(NULL, title);

  0082e	8d 4d 08	 lea	 ecx, DWORD PTR _title$[ebp]
  00831	e8 00 00 00 00	 call	 ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::operator char const *
  00836	50		 push	 eax
  00837	6a 00		 push	 0
  00839	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindWindowA@8
  0083f	89 45 ec	 mov	 DWORD PTR _hwnd$[ebp], eax

; 183  : 	if (hwnd != NULL)

  00842	83 7d ec 00	 cmp	 DWORD PTR _hwnd$[ebp], 0
  00846	74 46		 je	 SHORT $L87160

; 184  : 	{
; 185  : 		BringWindowToTop(hwnd,SW_SHOWMAXIMIZED);

  00848	6a 03		 push	 3
  0084a	8b 45 ec	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0084d	50		 push	 eax
  0084e	e8 00 00 00 00	 call	 ?BringWindowToTop@@YAXPAUHWND__@@K@Z ; BringWindowToTop
  00853	83 c4 08	 add	 esp, 8

; 186  : 		return;

  00856	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0085a	8d 4d f0	 lea	 ecx, DWORD PTR _info$[ebp]
  0085d	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  00862	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00866	8d 4d 08	 lea	 ecx, DWORD PTR _title$[ebp]
  00869	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0086e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00872	8d 4d 0c	 lea	 ecx, DWORD PTR _url$[ebp]
  00875	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0087a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00881	8d 4d 10	 lea	 ecx, DWORD PTR _prepTitle$[ebp]
  00884	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  00889	e9 a8 00 00 00	 jmp	 $L87157
$L87160:

; 187  : 	}
; 188  : 
; 189  : 	ShellExecute(NULL, "open", "iexplore.exe", 	url,"", SW_SHOWMAXIMIZED);

  0088e	6a 03		 push	 3
  00890	68 00 00 00 00	 push	 OFFSET FLAT:$SG87161
  00895	8d 4d 0c	 lea	 ecx, DWORD PTR _url$[ebp]
  00898	e8 00 00 00 00	 call	 ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::operator char const *
  0089d	50		 push	 eax
  0089e	68 00 00 00 00	 push	 OFFSET FLAT:$SG87162
  008a3	68 00 00 00 00	 push	 OFFSET FLAT:$SG87163
  008a8	6a 00		 push	 0
  008aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShellExecuteA@24

; 190  : //	ShellExecute(NULL, "open", "", 	url, "", SW_SHOWMAXIMIZED);
; 191  : 
; 192  : 	hwnd = NULL;

  008b0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _hwnd$[ebp], 0

; 193  : 	for(int i = 0 ;i< 60;i++)

  008b7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$87164[ebp], 0
  008be	eb 09		 jmp	 SHORT $L87165
$L87166:
  008c0	8b 4d e8	 mov	 ecx, DWORD PTR _i$87164[ebp]
  008c3	83 c1 01	 add	 ecx, 1
  008c6	89 4d e8	 mov	 DWORD PTR _i$87164[ebp], ecx
$L87165:
  008c9	83 7d e8 3c	 cmp	 DWORD PTR _i$87164[ebp], 60 ; 0000003cH
  008cd	7d 26		 jge	 SHORT $L87167

; 194  : 	{
; 195  : 		hwnd = ::FindWindow(NULL , prepTitle);

  008cf	8d 4d 10	 lea	 ecx, DWORD PTR _prepTitle$[ebp]
  008d2	e8 00 00 00 00	 call	 ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::operator char const *
  008d7	50		 push	 eax
  008d8	6a 00		 push	 0
  008da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindWindowA@8
  008e0	89 45 ec	 mov	 DWORD PTR _hwnd$[ebp], eax

; 196  : 		if(hwnd != NULL)

  008e3	83 7d ec 00	 cmp	 DWORD PTR _hwnd$[ebp], 0
  008e7	74 02		 je	 SHORT $L87168

; 197  : 		{
; 198  : 			break;

  008e9	eb 0a		 jmp	 SHORT $L87167
$L87168:

; 199  : 		}
; 200  : 		Sleep(100);

  008eb	6a 64		 push	 100			; 00000064H
  008ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 201  : 	}

  008f3	eb cb		 jmp	 SHORT $L87166
$L87167:

; 202  : 	BringWindowToTop(hwnd,SW_SHOWMAXIMIZED);

  008f5	6a 03		 push	 3
  008f7	8b 55 ec	 mov	 edx, DWORD PTR _hwnd$[ebp]
  008fa	52		 push	 edx
  008fb	e8 00 00 00 00	 call	 ?BringWindowToTop@@YAXPAUHWND__@@K@Z ; BringWindowToTop
  00900	83 c4 08	 add	 esp, 8

; 203  : }

  00903	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00907	8d 4d f0	 lea	 ecx, DWORD PTR _info$[ebp]
  0090a	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0090f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00913	8d 4d 08	 lea	 ecx, DWORD PTR _title$[ebp]
  00916	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0091b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0091f	8d 4d 0c	 lea	 ecx, DWORD PTR _url$[ebp]
  00922	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  00927	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0092e	8d 4d 10	 lea	 ecx, DWORD PTR _prepTitle$[ebp]
  00931	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L87157:
  00936	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00939	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00940	8b e5		 mov	 esp, ebp
  00942	5d		 pop	 ebp
  00943	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94808:
  00057	8d 4d 10	 lea	 ecx, DWORD PTR _prepTitle$[ebp]
  0005a	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L94809:
  0005f	8d 4d 0c	 lea	 ecx, DWORD PTR _url$[ebp]
  00062	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L94810:
  00067	8d 4d 08	 lea	 ecx, DWORD PTR _title$[ebp]
  0006a	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L94811:
  0006f	8d 4d f0	 lea	 ecx, DWORD PTR _info$[ebp]
  00072	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?RunExplorer@@YAXV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@00@Z:
  00077	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94813
  0007c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?RunExplorer@@YAXV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@00@Z ENDP ; RunExplorer
PUBLIC	?ulong2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; ulong2str
EXTRN	__imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:NEAR
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:NEAR
EXTRN	__imp_?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ:NEAR
xdata$x	SEGMENT
$T94824	DD	0ffffffffH
	DD	FLAT:$L94818
	DD	00H
	DD	FLAT:$L94817
$T94822	DD	019930520H
	DD	02H
	DD	FLAT:$T94824
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T94819 = -144						; size = 4
_oss$ = -140						; size = 128
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 4
?ulong2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z PROC NEAR ; ulong2str

; 209  : {

  00950	55		 push	 ebp
  00951	8b ec		 mov	 ebp, esp
  00953	6a ff		 push	 -1
  00955	68 00 00 00 00	 push	 __ehhandler$?ulong2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z
  0095a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00960	50		 push	 eax
  00961	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00968	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  0096e	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T94819[ebp], 0

; 210  : 	ostringstream oss;

  00978	6a 01		 push	 1
  0097a	6a 02		 push	 2
  0097c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00982	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  00988	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 211  : 	oss << d;

  0098f	8b 45 0c	 mov	 eax, DWORD PTR _d$[ebp]
  00992	50		 push	 eax
  00993	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00999	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z

; 212  : 	return oss.str();

  0099f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  009a2	51		 push	 ecx
  009a3	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  009a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  009af	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR $T94819[ebp]
  009b5	83 ca 01	 or	 edx, 1
  009b8	89 95 70 ff ff
	ff		 mov	 DWORD PTR $T94819[ebp], edx
  009be	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  009c2	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  009c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  009ce	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 213  : }

  009d1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  009d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  009db	8b e5		 mov	 esp, ebp
  009dd	5d		 pop	 ebp
  009de	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94817:
  00081	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00087	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$L94818:
  0008d	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T94819[ebp]
  00093	83 e0 01	 and	 eax, 1
  00096	0f 84 10 00 00
	00		 je	 $L94820
  0009c	83 a5 70 ff ff
	ff fe		 and	 DWORD PTR $T94819[ebp], -2 ; fffffffeH
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a6	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94820:
  000ac	c3		 ret	 0
__ehhandler$?ulong2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z:
  000ad	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94822
  000b2	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ulong2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ENDP ; ulong2str
PUBLIC	?long2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@J@Z ; long2str
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z:NEAR
xdata$x	SEGMENT
$T94833	DD	0ffffffffH
	DD	FLAT:$L94827
	DD	00H
	DD	FLAT:$L94826
$T94831	DD	019930520H
	DD	02H
	DD	FLAT:$T94833
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T94828 = -144						; size = 4
_oss$ = -140						; size = 128
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 4
?long2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@J@Z PROC NEAR ; long2str

; 219  : {

  009e0	55		 push	 ebp
  009e1	8b ec		 mov	 ebp, esp
  009e3	6a ff		 push	 -1
  009e5	68 00 00 00 00	 push	 __ehhandler$?long2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@J@Z
  009ea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  009f0	50		 push	 eax
  009f1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  009f8	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  009fe	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T94828[ebp], 0

; 220  : 	ostringstream oss;

  00a08	6a 01		 push	 1
  00a0a	6a 02		 push	 2
  00a0c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00a12	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  00a18	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 221  : 	oss << d;

  00a1f	8b 45 0c	 mov	 eax, DWORD PTR _d$[ebp]
  00a22	50		 push	 eax
  00a23	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00a29	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z

; 222  : 	return oss.str();

  00a2f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00a32	51		 push	 ecx
  00a33	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00a39	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  00a3f	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR $T94828[ebp]
  00a45	83 ca 01	 or	 edx, 1
  00a48	89 95 70 ff ff
	ff		 mov	 DWORD PTR $T94828[ebp], edx
  00a4e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00a52	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00a58	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  00a5e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 223  : }

  00a61	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00a64	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00a6b	8b e5		 mov	 esp, ebp
  00a6d	5d		 pop	 ebp
  00a6e	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94826:
  000b7	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  000bd	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$L94827:
  000c3	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T94828[ebp]
  000c9	83 e0 01	 and	 eax, 1
  000cc	0f 84 10 00 00
	00		 je	 $L94829
  000d2	83 a5 70 ff ff
	ff fe		 and	 DWORD PTR $T94828[ebp], -2 ; fffffffeH
  000d9	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000dc	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94829:
  000e2	c3		 ret	 0
__ehhandler$?long2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@J@Z:
  000e3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94831
  000e8	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?long2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@J@Z ENDP ; long2str
PUBLIC	?uint2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; uint2str
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z:NEAR
xdata$x	SEGMENT
$T94842	DD	0ffffffffH
	DD	FLAT:$L94836
	DD	00H
	DD	FLAT:$L94835
$T94840	DD	019930520H
	DD	02H
	DD	FLAT:$T94842
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T94837 = -144						; size = 4
_oss$ = -140						; size = 128
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 4
?uint2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC NEAR ; uint2str

; 229  : {

  00a70	55		 push	 ebp
  00a71	8b ec		 mov	 ebp, esp
  00a73	6a ff		 push	 -1
  00a75	68 00 00 00 00	 push	 __ehhandler$?uint2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
  00a7a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00a80	50		 push	 eax
  00a81	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00a88	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00a8e	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T94837[ebp], 0

; 230  : 	ostringstream oss;

  00a98	6a 01		 push	 1
  00a9a	6a 02		 push	 2
  00a9c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00aa2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  00aa8	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 231  : 	oss << d;

  00aaf	8b 45 0c	 mov	 eax, DWORD PTR _d$[ebp]
  00ab2	50		 push	 eax
  00ab3	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00ab9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z

; 232  : 	return oss.str();

  00abf	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00ac2	51		 push	 ecx
  00ac3	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00ac9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  00acf	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR $T94837[ebp]
  00ad5	83 ca 01	 or	 edx, 1
  00ad8	89 95 70 ff ff
	ff		 mov	 DWORD PTR $T94837[ebp], edx
  00ade	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00ae2	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00ae8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  00aee	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 233  : }

  00af1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00af4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00afb	8b e5		 mov	 esp, ebp
  00afd	5d		 pop	 ebp
  00afe	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94835:
  000ed	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  000f3	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$L94836:
  000f9	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T94837[ebp]
  000ff	83 e0 01	 and	 eax, 1
  00102	0f 84 10 00 00
	00		 je	 $L94838
  00108	83 a5 70 ff ff
	ff fe		 and	 DWORD PTR $T94837[ebp], -2 ; fffffffeH
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00112	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94838:
  00118	c3		 ret	 0
__ehhandler$?uint2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z:
  00119	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94840
  0011e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?uint2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; uint2str
PUBLIC	?int2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; int2str
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:NEAR
xdata$x	SEGMENT
$T94851	DD	0ffffffffH
	DD	FLAT:$L94845
	DD	00H
	DD	FLAT:$L94844
$T94849	DD	019930520H
	DD	02H
	DD	FLAT:$T94851
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T94846 = -144						; size = 4
_oss$ = -140						; size = 128
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 4
?int2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC NEAR ; int2str

; 239  : {

  00b00	55		 push	 ebp
  00b01	8b ec		 mov	 ebp, esp
  00b03	6a ff		 push	 -1
  00b05	68 00 00 00 00	 push	 __ehhandler$?int2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
  00b0a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00b10	50		 push	 eax
  00b11	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00b18	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00b1e	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T94846[ebp], 0

; 240  : 	ostringstream oss;

  00b28	6a 01		 push	 1
  00b2a	6a 02		 push	 2
  00b2c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00b32	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  00b38	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 241  : 	oss << d;

  00b3f	8b 45 0c	 mov	 eax, DWORD PTR _d$[ebp]
  00b42	50		 push	 eax
  00b43	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00b49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z

; 242  : 	return oss.str();

  00b4f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00b52	51		 push	 ecx
  00b53	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00b59	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  00b5f	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR $T94846[ebp]
  00b65	83 ca 01	 or	 edx, 1
  00b68	89 95 70 ff ff
	ff		 mov	 DWORD PTR $T94846[ebp], edx
  00b6e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00b72	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00b78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  00b7e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 243  : }

  00b81	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00b84	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00b8b	8b e5		 mov	 esp, ebp
  00b8d	5d		 pop	 ebp
  00b8e	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94844:
  00123	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _oss$[ebp]
  00129	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$L94845:
  0012f	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T94846[ebp]
  00135	83 e0 01	 and	 eax, 1
  00138	0f 84 10 00 00
	00		 je	 $L94847
  0013e	83 a5 70 ff ff
	ff fe		 and	 DWORD PTR $T94846[ebp], -2 ; fffffffeH
  00145	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00148	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94847:
  0014e	c3		 ret	 0
__ehhandler$?int2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:
  0014f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94849
  00154	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?int2str@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; int2str
PUBLIC	?str2ulong@@YAKABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; str2ulong
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:NEAR
EXTRN	__imp_??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z:NEAR
EXTRN	__imp_??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:NEAR
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAK@Z:NEAR
xdata$x	SEGMENT
$T94858	DD	0ffffffffH
	DD	FLAT:$L94854
$T94856	DD	019930520H
	DD	01H
	DD	FLAT:$T94858
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T94853 = -160						; size = 4
_iss$ = -156						; size = 132
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
?str2ulong@@YAKABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; str2ulong

; 249  : {

  00b90	55		 push	 ebp
  00b91	8b ec		 mov	 ebp, esp
  00b93	6a ff		 push	 -1
  00b95	68 00 00 00 00	 push	 __ehhandler$?str2ulong@@YAKABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00b9a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00ba0	50		 push	 eax
  00ba1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00ba8	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H

; 250  : 	if(s ==  "")

  00bae	68 00 00 00 00	 push	 OFFSET FLAT:$SG87211
  00bb3	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00bb6	50		 push	 eax
  00bb7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
  00bbd	83 c4 08	 add	 esp, 8
  00bc0	0f b6 c8	 movzx	 ecx, al
  00bc3	85 c9		 test	 ecx, ecx
  00bc5	74 04		 je	 SHORT $L87210

; 251  : 	{
; 252  : 		return 0;

  00bc7	33 c0		 xor	 eax, eax
  00bc9	eb 4d		 jmp	 SHORT $L87209
$L87210:

; 253  : 	}
; 254  : 
; 255  : 	istringstream iss(s);

  00bcb	6a 01		 push	 1
  00bcd	6a 01		 push	 1
  00bcf	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00bd2	52		 push	 edx
  00bd3	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00bd9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
  00bdf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 256  : 	unsigned long i;
; 257  : 	iss >> i;

  00be6	8d 45 f0	 lea	 eax, DWORD PTR _i$[ebp]
  00be9	50		 push	 eax
  00bea	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00bf0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAK@Z

; 258  : 	return i;

  00bf6	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00bf9	89 8d 60 ff ff
	ff		 mov	 DWORD PTR $T94853[ebp], ecx
  00bff	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c06	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00c0c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  00c12	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T94853[ebp]
$L87209:

; 259  : }

  00c18	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00c1b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00c22	8b e5		 mov	 esp, ebp
  00c24	5d		 pop	 ebp
  00c25	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94854:
  00159	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  0015f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__ehhandler$?str2ulong@@YAKABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00165	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94856
  0016a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?str2ulong@@YAKABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; str2ulong
PUBLIC	?str2long@@YAJABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; str2long
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z:NEAR
xdata$x	SEGMENT
$T94865	DD	0ffffffffH
	DD	FLAT:$L94861
$T94863	DD	019930520H
	DD	01H
	DD	FLAT:$T94865
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T94860 = -160						; size = 4
_iss$ = -156						; size = 132
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
?str2long@@YAJABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; str2long

; 265  : {

  00c30	55		 push	 ebp
  00c31	8b ec		 mov	 ebp, esp
  00c33	6a ff		 push	 -1
  00c35	68 00 00 00 00	 push	 __ehhandler$?str2long@@YAJABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00c3a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00c40	50		 push	 eax
  00c41	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00c48	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H

; 266  : 	if(s ==  "")

  00c4e	68 00 00 00 00	 push	 OFFSET FLAT:$SG87227
  00c53	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00c56	50		 push	 eax
  00c57	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
  00c5d	83 c4 08	 add	 esp, 8
  00c60	0f b6 c8	 movzx	 ecx, al
  00c63	85 c9		 test	 ecx, ecx
  00c65	74 04		 je	 SHORT $L87226

; 267  : 	{
; 268  : 		return 0;

  00c67	33 c0		 xor	 eax, eax
  00c69	eb 4d		 jmp	 SHORT $L87225
$L87226:

; 269  : 	}
; 270  : 
; 271  : 	istringstream iss(s);

  00c6b	6a 01		 push	 1
  00c6d	6a 01		 push	 1
  00c6f	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00c72	52		 push	 edx
  00c73	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00c79	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
  00c7f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 272  : 	long i;
; 273  : 	iss >> i;

  00c86	8d 45 f0	 lea	 eax, DWORD PTR _i$[ebp]
  00c89	50		 push	 eax
  00c8a	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00c90	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z

; 274  : 	return i;

  00c96	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00c99	89 8d 60 ff ff
	ff		 mov	 DWORD PTR $T94860[ebp], ecx
  00c9f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ca6	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00cac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  00cb2	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T94860[ebp]
$L87225:

; 275  : }

  00cb8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00cbb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00cc2	8b e5		 mov	 esp, ebp
  00cc4	5d		 pop	 ebp
  00cc5	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94861:
  0016f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00175	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__ehhandler$?str2long@@YAJABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  0017b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94863
  00180	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?str2long@@YAJABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; str2long
PUBLIC	__real@0000000000000000
PUBLIC	?str2double@@YANABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; str2double
EXTRN	__fltused:NEAR
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAN@Z:NEAR
xdata$x	SEGMENT
$T94875	DD	0ffffffffH
	DD	FLAT:$L94868
$T94870	DD	019930520H
	DD	01H
	DD	FLAT:$T94875
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odt
CONST	ENDS
_TEXT	SEGMENT
$T94867 = -164						; size = 8
_d$ = -156						; size = 8
_iss$ = -148						; size = 132
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
?str2double@@YANABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; str2double

; 278  : {

  00cd0	55		 push	 ebp
  00cd1	8b ec		 mov	 ebp, esp
  00cd3	6a ff		 push	 -1
  00cd5	68 00 00 00 00	 push	 __ehhandler$?str2double@@YANABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00cda	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00ce0	50		 push	 eax
  00ce1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00ce8	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H

; 279  : 	if (s == "")

  00cee	68 00 00 00 00	 push	 OFFSET FLAT:$SG87235
  00cf3	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00cf6	50		 push	 eax
  00cf7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
  00cfd	83 c4 08	 add	 esp, 8
  00d00	0f b6 c8	 movzx	 ecx, al
  00d03	85 c9		 test	 ecx, ecx
  00d05	74 08		 je	 SHORT $L87234

; 280  : 		return 0.00;

  00d07	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  00d0d	eb 53		 jmp	 SHORT $L87233
$L87234:

; 281  : 
; 282  : 	istringstream iss (s);

  00d0f	6a 01		 push	 1
  00d11	6a 01		 push	 1
  00d13	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00d16	52		 push	 edx
  00d17	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00d1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
  00d23	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 283  : 	double d;
; 284  : 	iss >> d;

  00d2a	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _d$[ebp]
  00d30	50		 push	 eax
  00d31	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00d37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAN@Z

; 285  : 
; 286  : 	return d;

  00d3d	dd 85 64 ff ff
	ff		 fld	 QWORD PTR _d$[ebp]
  00d43	dd 9d 5c ff ff
	ff		 fstp	 QWORD PTR $T94867[ebp]
  00d49	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d50	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00d56	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  00d5c	dd 85 5c ff ff
	ff		 fld	 QWORD PTR $T94867[ebp]
$L87233:

; 287  : }

  00d62	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00d65	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00d6c	8b e5		 mov	 esp, ebp
  00d6e	5d		 pop	 ebp
  00d6f	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94868:
  00185	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  0018b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__ehhandler$?str2double@@YANABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00191	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94870
  00196	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?str2double@@YANABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; str2double
PUBLIC	?str2uint@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; str2uint
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAI@Z:NEAR
xdata$x	SEGMENT
$T94882	DD	0ffffffffH
	DD	FLAT:$L94878
$T94880	DD	019930520H
	DD	01H
	DD	FLAT:$T94882
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T94877 = -160						; size = 4
_iss$ = -156						; size = 132
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
?str2uint@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; str2uint

; 293  : {

  00d70	55		 push	 ebp
  00d71	8b ec		 mov	 ebp, esp
  00d73	6a ff		 push	 -1
  00d75	68 00 00 00 00	 push	 __ehhandler$?str2uint@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00d7a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00d80	50		 push	 eax
  00d81	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00d88	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H

; 294  : 	if(s ==  "")

  00d8e	68 00 00 00 00	 push	 OFFSET FLAT:$SG87243
  00d93	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00d96	50		 push	 eax
  00d97	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
  00d9d	83 c4 08	 add	 esp, 8
  00da0	0f b6 c8	 movzx	 ecx, al
  00da3	85 c9		 test	 ecx, ecx
  00da5	74 04		 je	 SHORT $L87242

; 295  : 	{
; 296  : 		return 0;

  00da7	33 c0		 xor	 eax, eax
  00da9	eb 4d		 jmp	 SHORT $L87241
$L87242:

; 297  : 	}
; 298  : 
; 299  : 	istringstream iss(s);

  00dab	6a 01		 push	 1
  00dad	6a 01		 push	 1
  00daf	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00db2	52		 push	 edx
  00db3	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00db9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
  00dbf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 300  : 	unsigned int i;
; 301  : 	iss >> i;

  00dc6	8d 45 f0	 lea	 eax, DWORD PTR _i$[ebp]
  00dc9	50		 push	 eax
  00dca	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00dd0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAI@Z

; 302  : 	return i;

  00dd6	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00dd9	89 8d 60 ff ff
	ff		 mov	 DWORD PTR $T94877[ebp], ecx
  00ddf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00de6	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00dec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  00df2	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T94877[ebp]
$L87241:

; 303  : }

  00df8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00dfb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00e02	8b e5		 mov	 esp, ebp
  00e04	5d		 pop	 ebp
  00e05	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94878:
  0019b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  001a1	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__ehhandler$?str2uint@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  001a7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94880
  001ac	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?str2uint@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; str2uint
PUBLIC	?str2int@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; str2int
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z:NEAR
xdata$x	SEGMENT
$T94889	DD	0ffffffffH
	DD	FLAT:$L94885
$T94887	DD	019930520H
	DD	01H
	DD	FLAT:$T94889
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T94884 = -160						; size = 4
_iss$ = -156						; size = 132
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
?str2int@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; str2int

; 309  : {

  00e10	55		 push	 ebp
  00e11	8b ec		 mov	 ebp, esp
  00e13	6a ff		 push	 -1
  00e15	68 00 00 00 00	 push	 __ehhandler$?str2int@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00e1a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00e20	50		 push	 eax
  00e21	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00e28	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H

; 310  : 	if(s ==  "")

  00e2e	68 00 00 00 00	 push	 OFFSET FLAT:$SG87251
  00e33	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00e36	50		 push	 eax
  00e37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
  00e3d	83 c4 08	 add	 esp, 8
  00e40	0f b6 c8	 movzx	 ecx, al
  00e43	85 c9		 test	 ecx, ecx
  00e45	74 04		 je	 SHORT $L87250

; 311  : 	{
; 312  : 		return 0;

  00e47	33 c0		 xor	 eax, eax
  00e49	eb 4d		 jmp	 SHORT $L87249
$L87250:

; 313  : 	}
; 314  : 
; 315  : 	istringstream iss(s);

  00e4b	6a 01		 push	 1
  00e4d	6a 01		 push	 1
  00e4f	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00e52	52		 push	 edx
  00e53	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00e59	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
  00e5f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 316  : 	int i;
; 317  : 	iss >> i;

  00e66	8d 45 f0	 lea	 eax, DWORD PTR _i$[ebp]
  00e69	50		 push	 eax
  00e6a	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00e70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z

; 318  : 	return i;

  00e76	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00e79	89 8d 60 ff ff
	ff		 mov	 DWORD PTR $T94884[ebp], ecx
  00e7f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00e86	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  00e8c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  00e92	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T94884[ebp]
$L87249:

; 319  : }

  00e98	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00e9b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00ea2	8b e5		 mov	 esp, ebp
  00ea4	5d		 pop	 ebp
  00ea5	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94885:
  001b1	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _iss$[ebp]
  001b7	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__ehhandler$?str2int@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  001bd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94887
  001c2	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?str2int@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; str2int
PUBLIC	?GetFileNameFromUrl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z ; GetFileNameFromUrl
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	__imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB:DWORD
EXTRN	__imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z:NEAR
EXTRN	__imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z:NEAR
xdata$x	SEGMENT
$T94898	DD	0ffffffffH
	DD	FLAT:$L94892
	DD	00H
	DD	FLAT:$L94891
$T94896	DD	019930520H
	DD	02H
	DD	FLAT:$T94898
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T94893 = -20						; size = 4
_nIdx$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_url$ = 12						; size = 28
?GetFileNameFromUrl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z PROC NEAR ; GetFileNameFromUrl

; 322  : {

  00eb0	55		 push	 ebp
  00eb1	8b ec		 mov	 ebp, esp
  00eb3	6a ff		 push	 -1
  00eb5	68 00 00 00 00	 push	 __ehhandler$?GetFileNameFromUrl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z
  00eba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00ec0	50		 push	 eax
  00ec1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00ec8	83 ec 08	 sub	 esp, 8
  00ecb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T94893[ebp], 0
  00ed2	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 323  : 	string::size_type nIdx = url.find_last_of("\\/");

  00ed9	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  00ede	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ee0	51		 push	 ecx
  00ee1	68 00 00 00 00	 push	 OFFSET FLAT:$SG87260
  00ee6	8d 4d 0c	 lea	 ecx, DWORD PTR _url$[ebp]
  00ee9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
  00eef	89 45 f0	 mov	 DWORD PTR _nIdx$[ebp], eax

; 324  : 	if(nIdx != string::npos)

  00ef2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  00ef8	8b 45 f0	 mov	 eax, DWORD PTR _nIdx$[ebp]
  00efb	3b 02		 cmp	 eax, DWORD PTR [edx]
  00efd	74 3f		 je	 SHORT $L87261

; 325  : 		return url.substr(nIdx + 1, url.length() - nIdx - 1);

  00eff	8d 4d 0c	 lea	 ecx, DWORD PTR _url$[ebp]
  00f02	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00f08	2b 45 f0	 sub	 eax, DWORD PTR _nIdx$[ebp]
  00f0b	83 e8 01	 sub	 eax, 1
  00f0e	50		 push	 eax
  00f0f	8b 4d f0	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  00f12	83 c1 01	 add	 ecx, 1
  00f15	51		 push	 ecx
  00f16	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00f19	52		 push	 edx
  00f1a	8d 4d 0c	 lea	 ecx, DWORD PTR _url$[ebp]
  00f1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  00f23	8b 45 ec	 mov	 eax, DWORD PTR $T94893[ebp]
  00f26	83 c8 01	 or	 eax, 1
  00f29	89 45 ec	 mov	 DWORD PTR $T94893[ebp], eax
  00f2c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00f30	8d 4d 0c	 lea	 ecx, DWORD PTR _url$[ebp]
  00f33	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00f39	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00f3c	eb 27		 jmp	 SHORT $L87258
$L87261:

; 326  : 	else
; 327  : 		return "";

  00f3e	68 00 00 00 00	 push	 OFFSET FLAT:$SG87264
  00f43	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00f46	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00f4c	8b 4d ec	 mov	 ecx, DWORD PTR $T94893[ebp]
  00f4f	83 c9 01	 or	 ecx, 1
  00f52	89 4d ec	 mov	 DWORD PTR $T94893[ebp], ecx
  00f55	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00f59	8d 4d 0c	 lea	 ecx, DWORD PTR _url$[ebp]
  00f5c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00f62	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L87258:

; 328  : }

  00f65	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00f68	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00f6f	8b e5		 mov	 esp, ebp
  00f71	5d		 pop	 ebp
  00f72	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94891:
  001c7	8d 4d 0c	 lea	 ecx, DWORD PTR _url$[ebp]
  001ca	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94892:
  001d0	8b 45 ec	 mov	 eax, DWORD PTR $T94893[ebp]
  001d3	83 e0 01	 and	 eax, 1
  001d6	0f 84 0d 00 00
	00		 je	 $L94894
  001dc	83 65 ec fe	 and	 DWORD PTR $T94893[ebp], -2 ; fffffffeH
  001e0	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001e3	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94894:
  001e9	c3		 ret	 0
__ehhandler$?GetFileNameFromUrl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z:
  001ea	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94896
  001ef	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetFileNameFromUrl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z ENDP ; GetFileNameFromUrl
PUBLIC	?ParsePath@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@11@Z ; ParsePath
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
EXTRN	__imp_?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z:NEAR
xdata$x	SEGMENT
$T94914	DD	0ffffffffH
	DD	FLAT:$L94906
	DD	00H
	DD	FLAT:$L94907
	DD	00H
	DD	FLAT:$L94908
	DD	00H
	DD	FLAT:$L94909
	DD	00H
	DD	FLAT:$L94910
$T94912	DD	019930520H
	DD	05H
	DD	FLAT:$T94914
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv163 = -168						; size = 4
tv168 = -164						; size = 4
tv161 = -160						; size = 4
tv167 = -156						; size = 4
tv159 = -152						; size = 4
tv166 = -148						; size = 4
tv157 = -144						; size = 4
tv165 = -140						; size = 4
$T94905 = -133						; size = 1
$T94904 = -132						; size = 28
$T94903 = -104						; size = 28
$T94902 = -76						; size = 28
$T94901 = -48						; size = 28
$T94900 = -17						; size = 1
_nPos$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 28
_basepath$ = 36						; size = 4
_filename$ = 40						; size = 4
_ext$ = 44						; size = 4
?ParsePath@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@11@Z PROC NEAR ; ParsePath

; 331  : {

  00f80	55		 push	 ebp
  00f81	8b ec		 mov	 ebp, esp
  00f83	6a ff		 push	 -1
  00f85	68 00 00 00 00	 push	 __ehhandler$?ParsePath@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@11@Z
  00f8a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00f90	50		 push	 eax
  00f91	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00f98	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  00f9e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 332  : 	string::size_type nPos = path.rfind("\\");

  00fa5	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  00faa	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fac	51		 push	 ecx
  00fad	68 00 00 00 00	 push	 OFFSET FLAT:$SG87272
  00fb2	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00fb5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
  00fbb	89 45 f0	 mov	 DWORD PTR _nPos$[ebp], eax

; 333  : 	if (nPos == string::npos)

  00fbe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  00fc4	8b 45 f0	 mov	 eax, DWORD PTR _nPos$[ebp]
  00fc7	3b 02		 cmp	 eax, DWORD PTR [edx]
  00fc9	75 1c		 jne	 SHORT $L87273

; 334  : 		return false;

  00fcb	c6 45 ef 00	 mov	 BYTE PTR $T94900[ebp], 0
  00fcf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00fd6	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00fd9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00fdf	8a 45 ef	 mov	 al, BYTE PTR $T94900[ebp]
  00fe2	e9 7c 01 00 00	 jmp	 $L87270
$L87273:

; 335  : 
; 336  : 	basepath = path.substr(0, nPos+1);

  00fe7	8b 4d f0	 mov	 ecx, DWORD PTR _nPos$[ebp]
  00fea	83 c1 01	 add	 ecx, 1
  00fed	51		 push	 ecx
  00fee	6a 00		 push	 0
  00ff0	8d 55 d0	 lea	 edx, DWORD PTR $T94901[ebp]
  00ff3	52		 push	 edx
  00ff4	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00ff7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  00ffd	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv165[ebp], eax
  01003	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv165[ebp]
  01009	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], eax
  0100f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01013	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv157[ebp]
  01019	51		 push	 ecx
  0101a	8b 4d 24	 mov	 ecx, DWORD PTR _basepath$[ebp]
  0101d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  01023	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01027	8d 4d d0	 lea	 ecx, DWORD PTR $T94901[ebp]
  0102a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 337  : 	filename = path.substr(nPos+1, path.length()-nPos-1);

  01030	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  01033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  01039	2b 45 f0	 sub	 eax, DWORD PTR _nPos$[ebp]
  0103c	83 e8 01	 sub	 eax, 1
  0103f	50		 push	 eax
  01040	8b 55 f0	 mov	 edx, DWORD PTR _nPos$[ebp]
  01043	83 c2 01	 add	 edx, 1
  01046	52		 push	 edx
  01047	8d 45 b4	 lea	 eax, DWORD PTR $T94902[ebp]
  0104a	50		 push	 eax
  0104b	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  0104e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  01054	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv166[ebp], eax
  0105a	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv166[ebp]
  01060	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv159[ebp], ecx
  01066	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0106a	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv159[ebp]
  01070	52		 push	 edx
  01071	8b 4d 28	 mov	 ecx, DWORD PTR _filename$[ebp]
  01074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0107a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0107e	8d 4d b4	 lea	 ecx, DWORD PTR $T94902[ebp]
  01081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 338  : 
; 339  : 	nPos = filename.rfind(".");

  01087	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0108c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0108e	51		 push	 ecx
  0108f	68 00 00 00 00	 push	 OFFSET FLAT:$SG87277
  01094	8b 4d 28	 mov	 ecx, DWORD PTR _filename$[ebp]
  01097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
  0109d	89 45 f0	 mov	 DWORD PTR _nPos$[ebp], eax

; 340  : 
; 341  : 	ext = filename.substr(nPos + 1, path.length() - nPos - 1);

  010a0	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  010a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  010a9	2b 45 f0	 sub	 eax, DWORD PTR _nPos$[ebp]
  010ac	83 e8 01	 sub	 eax, 1
  010af	50		 push	 eax
  010b0	8b 55 f0	 mov	 edx, DWORD PTR _nPos$[ebp]
  010b3	83 c2 01	 add	 edx, 1
  010b6	52		 push	 edx
  010b7	8d 45 98	 lea	 eax, DWORD PTR $T94903[ebp]
  010ba	50		 push	 eax
  010bb	8b 4d 28	 mov	 ecx, DWORD PTR _filename$[ebp]
  010be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  010c4	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv167[ebp], eax
  010ca	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv167[ebp]
  010d0	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv161[ebp], ecx
  010d6	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  010da	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv161[ebp]
  010e0	52		 push	 edx
  010e1	8b 4d 2c	 mov	 ecx, DWORD PTR _ext$[ebp]
  010e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  010ea	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  010ee	8d 4d 98	 lea	 ecx, DWORD PTR $T94903[ebp]
  010f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 342  : 	filename = filename.substr(0, nPos + 1);

  010f7	8b 45 f0	 mov	 eax, DWORD PTR _nPos$[ebp]
  010fa	83 c0 01	 add	 eax, 1
  010fd	50		 push	 eax
  010fe	6a 00		 push	 0
  01100	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T94904[ebp]
  01106	51		 push	 ecx
  01107	8b 4d 28	 mov	 ecx, DWORD PTR _filename$[ebp]
  0110a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  01110	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv168[ebp], eax
  01116	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv168[ebp]
  0111c	89 95 58 ff ff
	ff		 mov	 DWORD PTR tv163[ebp], edx
  01122	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  01126	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv163[ebp]
  0112c	50		 push	 eax
  0112d	8b 4d 28	 mov	 ecx, DWORD PTR _filename$[ebp]
  01130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  01136	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0113a	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T94904[ebp]
  01140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 343  : 	return true;

  01146	c6 85 7b ff ff
	ff 01		 mov	 BYTE PTR $T94905[ebp], 1
  0114d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01154	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  01157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0115d	8a 85 7b ff ff
	ff		 mov	 al, BYTE PTR $T94905[ebp]
$L87270:

; 344  : }

  01163	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01166	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0116d	8b e5		 mov	 esp, ebp
  0116f	5d		 pop	 ebp
  01170	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94906:
  001f4	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  001f7	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94907:
  001fd	8d 4d d0	 lea	 ecx, DWORD PTR $T94901[ebp]
  00200	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94908:
  00206	8d 4d b4	 lea	 ecx, DWORD PTR $T94902[ebp]
  00209	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94909:
  0020f	8d 4d 98	 lea	 ecx, DWORD PTR $T94903[ebp]
  00212	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94910:
  00218	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T94904[ebp]
  0021e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?ParsePath@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@11@Z:
  00224	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94912
  00229	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ParsePath@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@11@Z ENDP ; ParsePath
PUBLIC	?GetExePath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GetExePath
EXTRN	__imp__GetModuleFileNameA@12:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
xdata$x	SEGMENT
$T94930	DD	0ffffffffH
	DD	FLAT:$L94923
	DD	00H
	DD	FLAT:$L94918
	DD	01H
	DD	FLAT:$L94919
	DD	02H
	DD	FLAT:$L94920
	DD	03H
	DD	FLAT:$L94921
$T94927	DD	019930520H
	DD	05H
	DD	FLAT:$T94930
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv147 = -408						; size = 4
$T94924 = -404						; size = 4
$T94917 = -400						; size = 4
_sz$ = -396						; size = 260
_filename$ = -128					; size = 28
_basepath$ = -100					; size = 28
_ext$ = -72						; size = 28
_ExePath$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetExePath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC NEAR ; GetExePath

; 347  : {

  01180	55		 push	 ebp
  01181	8b ec		 mov	 ebp, esp
  01183	6a ff		 push	 -1
  01185	68 00 00 00 00	 push	 __ehhandler$?GetExePath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  0118a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01190	50		 push	 eax
  01191	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01198	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  0119e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  011a3	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  011a6	57		 push	 edi
  011a7	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T94924[ebp], 0

; 348  : 	char sz[MAX_PATH]={0};

  011b1	c6 85 74 fe ff
	ff 00		 mov	 BYTE PTR _sz$[ebp], 0
  011b8	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  011bd	33 c0		 xor	 eax, eax
  011bf	8d bd 75 fe ff
	ff		 lea	 edi, DWORD PTR _sz$[ebp+1]
  011c5	f3 ab		 rep stosd
  011c7	66 ab		 stosw
  011c9	aa		 stosb

; 349  : 	::GetModuleFileName(NULL, sz, MAX_PATH);

  011ca	68 04 01 00 00	 push	 260			; 00000104H
  011cf	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _sz$[ebp]
  011d5	50		 push	 eax
  011d6	6a 00		 push	 0
  011d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 350  : 	string ExePath = sz;

  011de	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR _sz$[ebp]
  011e4	51		 push	 ecx
  011e5	8d 4d d4	 lea	 ecx, DWORD PTR _ExePath$[ebp]
  011e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  011ee	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 351  : 	string basepath = "";

  011f5	68 00 00 00 00	 push	 OFFSET FLAT:$SG87287
  011fa	8d 4d 9c	 lea	 ecx, DWORD PTR _basepath$[ebp]
  011fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  01203	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 352  : 	string filename = "";

  01207	68 00 00 00 00	 push	 OFFSET FLAT:$SG87289
  0120c	8d 4d 80	 lea	 ecx, DWORD PTR _filename$[ebp]
  0120f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  01215	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 353  : 	string ext = "";

  01219	68 00 00 00 00	 push	 OFFSET FLAT:$SG87291
  0121e	8d 4d b8	 lea	 ecx, DWORD PTR _ext$[ebp]
  01221	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  01227	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 354  : 	ParsePath(ExePath, basepath, filename, ext);

  0122b	8d 55 b8	 lea	 edx, DWORD PTR _ext$[ebp]
  0122e	52		 push	 edx
  0122f	8d 45 80	 lea	 eax, DWORD PTR _filename$[ebp]
  01232	50		 push	 eax
  01233	8d 4d 9c	 lea	 ecx, DWORD PTR _basepath$[ebp]
  01236	51		 push	 ecx
  01237	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0123a	8b cc		 mov	 ecx, esp
  0123c	89 a5 70 fe ff
	ff		 mov	 DWORD PTR $T94917[ebp], esp
  01242	8d 55 d4	 lea	 edx, DWORD PTR _ExePath$[ebp]
  01245	52		 push	 edx
  01246	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0124c	89 85 68 fe ff
	ff		 mov	 DWORD PTR tv147[ebp], eax
  01252	e8 00 00 00 00	 call	 ?ParsePath@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@11@Z ; ParsePath
  01257	83 c4 28	 add	 esp, 40			; 00000028H

; 355  : 	return basepath;

  0125a	8d 45 9c	 lea	 eax, DWORD PTR _basepath$[ebp]
  0125d	50		 push	 eax
  0125e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  01267	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T94924[ebp]
  0126d	83 c9 01	 or	 ecx, 1
  01270	89 8d 6c fe ff
	ff		 mov	 DWORD PTR $T94924[ebp], ecx
  01276	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0127a	8d 4d b8	 lea	 ecx, DWORD PTR _ext$[ebp]
  0127d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01283	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01287	8d 4d 80	 lea	 ecx, DWORD PTR _filename$[ebp]
  0128a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01290	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01294	8d 4d 9c	 lea	 ecx, DWORD PTR _basepath$[ebp]
  01297	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0129d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  012a1	8d 4d d4	 lea	 ecx, DWORD PTR _ExePath$[ebp]
  012a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  012aa	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 356  : }

  012ad	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  012b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  012b7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012bf	5f		 pop	 edi
  012c0	8b e5		 mov	 esp, ebp
  012c2	5d		 pop	 ebp
  012c3	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94918:
  0022e	8d 4d d4	 lea	 ecx, DWORD PTR _ExePath$[ebp]
  00231	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94919:
  00237	8d 4d 9c	 lea	 ecx, DWORD PTR _basepath$[ebp]
  0023a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94920:
  00240	8d 4d 80	 lea	 ecx, DWORD PTR _filename$[ebp]
  00243	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94921:
  00249	8d 4d b8	 lea	 ecx, DWORD PTR _ext$[ebp]
  0024c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94923:
  00252	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR $T94924[ebp]
  00258	83 e0 01	 and	 eax, 1
  0025b	0f 84 10 00 00
	00		 je	 $L94925
  00261	83 a5 6c fe ff
	ff fe		 and	 DWORD PTR $T94924[ebp], -2 ; fffffffeH
  00268	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0026b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94925:
  00271	c3		 ret	 0
__ehhandler$?GetExePath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
  00272	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94927
  00277	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetExePath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; GetExePath
PUBLIC	?CutLogFile@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CutLogFile
EXTRN	__imp__fclose:NEAR
EXTRN	__imp__fopen:NEAR
EXTRN	__imp__fread:NEAR
EXTRN	__imp__fseek:NEAR
EXTRN	__imp__fwrite:NEAR
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
xdata$x	SEGMENT
$T94941	DD	0ffffffffH
	DD	FLAT:$L94937
$T94939	DD	019930520H
	DD	01H
	DD	FLAT:$T94941
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T94936 = -45						; size = 1
$T94935 = -44						; size = 4
$T94934 = -37						; size = 1
$T94933 = -36						; size = 4
$T94932 = -29						; size = 1
_dwRead$ = -28						; size = 4
_szContent$ = -24					; size = 4
_file$ = -20						; size = 4
_n$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 28
_nLen$ = 36						; size = 4
?CutLogFile@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC NEAR ; CutLogFile

; 359  : {

  012d0	55		 push	 ebp
  012d1	8b ec		 mov	 ebp, esp
  012d3	6a ff		 push	 -1
  012d5	68 00 00 00 00	 push	 __ehhandler$?CutLogFile@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
  012da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  012e0	50		 push	 eax
  012e1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  012e8	83 ec 24	 sub	 esp, 36			; 00000024H
  012eb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 360  : 	if(nLen <= 0)

  012f2	83 7d 24 00	 cmp	 DWORD PTR _nLen$[ebp], 0
  012f6	7f 1c		 jg	 SHORT $L87297

; 361  : 		return false;

  012f8	c6 45 e3 00	 mov	 BYTE PTR $T94932[ebp], 0
  012fc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01303	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  01306	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0130c	8a 45 e3	 mov	 al, BYTE PTR $T94932[ebp]
  0130f	e9 49 01 00 00	 jmp	 $L87296
$L87297:

; 362  : 
; 363  : 	FILE *file;
; 364  : 	char *szContent = new char[nLen];

  01314	8b 45 24	 mov	 eax, DWORD PTR _nLen$[ebp]
  01317	50		 push	 eax
  01318	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0131d	83 c4 04	 add	 esp, 4
  01320	89 45 dc	 mov	 DWORD PTR $T94933[ebp], eax
  01323	8b 4d dc	 mov	 ecx, DWORD PTR $T94933[ebp]
  01326	89 4d e8	 mov	 DWORD PTR _szContent$[ebp], ecx

; 365  : 	DWORD dwRead = 0;

  01329	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwRead$[ebp], 0

; 366  : 	if( (file = fopen(path.c_str(), "r")) != NULL )

  01330	68 00 00 00 00	 push	 OFFSET FLAT:$SG87305
  01335	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  01338	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0133e	50		 push	 eax
  0133f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  01345	83 c4 08	 add	 esp, 8
  01348	89 45 ec	 mov	 DWORD PTR _file$[ebp], eax
  0134b	83 7d ec 00	 cmp	 DWORD PTR _file$[ebp], 0
  0134f	74 4e		 je	 SHORT $L87304

; 367  : 	{
; 368  : 		fseek( file, 0 - nLen, SEEK_END );

  01351	6a 02		 push	 2
  01353	33 d2		 xor	 edx, edx
  01355	2b 55 24	 sub	 edx, DWORD PTR _nLen$[ebp]
  01358	52		 push	 edx
  01359	8b 45 ec	 mov	 eax, DWORD PTR _file$[ebp]
  0135c	50		 push	 eax
  0135d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  01363	83 c4 0c	 add	 esp, 12			; 0000000cH

; 369  : 		dwRead = (DWORD)fread( szContent, sizeof(char), nLen, file );

  01366	8b 4d ec	 mov	 ecx, DWORD PTR _file$[ebp]
  01369	51		 push	 ecx
  0136a	8b 55 24	 mov	 edx, DWORD PTR _nLen$[ebp]
  0136d	52		 push	 edx
  0136e	6a 01		 push	 1
  01370	8b 45 e8	 mov	 eax, DWORD PTR _szContent$[ebp]
  01373	50		 push	 eax
  01374	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0137a	83 c4 10	 add	 esp, 16			; 00000010H
  0137d	89 45 e4	 mov	 DWORD PTR _dwRead$[ebp], eax

; 370  : 		if(ferror(file))

  01380	8b 4d ec	 mov	 ecx, DWORD PTR _file$[ebp]
  01383	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01386	83 e2 20	 and	 edx, 32			; 00000020H
  01389	74 07		 je	 SHORT $L87308

; 371  : 		{
; 372  : 			dwRead = 0;

  0138b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwRead$[ebp], 0
$L87308:

; 373  : 		}
; 374  : 		fclose(file);

  01392	8b 45 ec	 mov	 eax, DWORD PTR _file$[ebp]
  01395	50		 push	 eax
  01396	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0139c	83 c4 04	 add	 esp, 4
$L87304:

; 375  : 	}
; 376  : 
; 377  : 	if(dwRead == 0)

  0139f	83 7d e4 00	 cmp	 DWORD PTR _dwRead$[ebp], 0
  013a3	75 1c		 jne	 SHORT $L87309

; 378  : 		return false;

  013a5	c6 45 db 00	 mov	 BYTE PTR $T94934[ebp], 0
  013a9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  013b0	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  013b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  013b9	8a 45 db	 mov	 al, BYTE PTR $T94934[ebp]
  013bc	e9 9c 00 00 00	 jmp	 $L87296
$L87309:

; 379  : 
; 380  : 	int n = 0;

  013c1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
$L87313:

; 381  : 	while(n <= nLen && szContent[n] != '\n')

  013c8	8b 4d f0	 mov	 ecx, DWORD PTR _n$[ebp]
  013cb	3b 4d 24	 cmp	 ecx, DWORD PTR _nLen$[ebp]
  013ce	7f 19		 jg	 SHORT $L87314
  013d0	8b 55 e8	 mov	 edx, DWORD PTR _szContent$[ebp]
  013d3	03 55 f0	 add	 edx, DWORD PTR _n$[ebp]
  013d6	0f be 02	 movsx	 eax, BYTE PTR [edx]
  013d9	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  013dc	74 0b		 je	 SHORT $L87314

; 382  : 		n++;

  013de	8b 4d f0	 mov	 ecx, DWORD PTR _n$[ebp]
  013e1	83 c1 01	 add	 ecx, 1
  013e4	89 4d f0	 mov	 DWORD PTR _n$[ebp], ecx
  013e7	eb df		 jmp	 SHORT $L87313
$L87314:

; 383  : 
; 384  : 	if( (file = fopen(path.c_str(), "w")) != NULL )

  013e9	68 00 00 00 00	 push	 OFFSET FLAT:$SG87316
  013ee	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  013f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  013f7	50		 push	 eax
  013f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  013fe	83 c4 08	 add	 esp, 8
  01401	89 45 ec	 mov	 DWORD PTR _file$[ebp], eax
  01404	83 7d ec 00	 cmp	 DWORD PTR _file$[ebp], 0
  01408	74 2a		 je	 SHORT $L87315

; 385  : 	{
; 386  : 		fwrite(szContent + n, sizeof(char), nLen-n, file );

  0140a	8b 55 ec	 mov	 edx, DWORD PTR _file$[ebp]
  0140d	52		 push	 edx
  0140e	8b 45 24	 mov	 eax, DWORD PTR _nLen$[ebp]
  01411	2b 45 f0	 sub	 eax, DWORD PTR _n$[ebp]
  01414	50		 push	 eax
  01415	6a 01		 push	 1
  01417	8b 4d e8	 mov	 ecx, DWORD PTR _szContent$[ebp]
  0141a	03 4d f0	 add	 ecx, DWORD PTR _n$[ebp]
  0141d	51		 push	 ecx
  0141e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  01424	83 c4 10	 add	 esp, 16			; 00000010H

; 387  : 		fclose(file);

  01427	8b 55 ec	 mov	 edx, DWORD PTR _file$[ebp]
  0142a	52		 push	 edx
  0142b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  01431	83 c4 04	 add	 esp, 4
$L87315:

; 388  : 	}
; 389  : 	delete[] szContent;

  01434	8b 45 e8	 mov	 eax, DWORD PTR _szContent$[ebp]
  01437	89 45 d4	 mov	 DWORD PTR $T94935[ebp], eax
  0143a	8b 4d d4	 mov	 ecx, DWORD PTR $T94935[ebp]
  0143d	51		 push	 ecx
  0143e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  01443	83 c4 04	 add	 esp, 4

; 390  : 	return true;

  01446	c6 45 d3 01	 mov	 BYTE PTR $T94936[ebp], 1
  0144a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01451	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  01454	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0145a	8a 45 d3	 mov	 al, BYTE PTR $T94936[ebp]
$L87296:

; 391  : }

  0145d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01460	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01467	8b e5		 mov	 esp, ebp
  01469	5d		 pop	 ebp
  0146a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94937:
  0027c	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  0027f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CutLogFile@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:
  00285	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94939
  0028a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CutLogFile@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; CutLogFile
PUBLIC	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?FormatTime@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABU_SYSTEMTIME@@@Z ; FormatTime
EXTRN	__imp_??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:NEAR
EXTRN	__imp_??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:NEAR
EXTRN	__imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z:NEAR
EXTRN	__imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEDD@Z:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z:NEAR
EXTRN	__imp_??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:NEAR
xdata$x	SEGMENT
$T94968	DD	0ffffffffH
	DD	FLAT:$L94961
	DD	00H
	DD	FLAT:$L94956
	DD	01H
	DD	FLAT:$L94957
	DD	02H
	DD	FLAT:$L94958
	DD	03H
	DD	FLAT:$L94959
	DD	04H
	DD	FLAT:$L94960
$T94965	DD	019930520H
	DD	06H
	DD	FLAT:$T94968
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv221 = -344						; size = 4
tv68 = -340						; size = 4
tv219 = -336						; size = 4
tv71 = -332						; size = 4
tv172 = -328						; size = 4
tv94 = -324						; size = 4
$T94962 = -320						; size = 4
$T94955 = -316						; size = 28
$T94954 = -288						; size = 28
$T94951 = -260						; size = 8
$T94950 = -252						; size = 8
$T94949 = -244						; size = 8
$T94948 = -236						; size = 8
$T94945 = -228						; size = 8
$T94944 = -220						; size = 8
_strTime$ = -212					; size = 28
_strDay$ = -184						; size = 28
__$ArrayPad$ = -156					; size = 4
_fillc$ = -149						; size = 1
_stream$ = -148						; size = 136
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_time$ = 12						; size = 4
?FormatTime@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABU_SYSTEMTIME@@@Z PROC NEAR ; FormatTime

; 394  : {

  01470	55		 push	 ebp
  01471	8b ec		 mov	 ebp, esp
  01473	6a ff		 push	 -1
  01475	68 00 00 00 00	 push	 __ehhandler$?FormatTime@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABU_SYSTEMTIME@@@Z
  0147a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01480	50		 push	 eax
  01481	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01488	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  0148e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  01493	89 85 64 ff ff
	ff		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01499	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T94962[ebp], 0

; 395  : 	string strDay, strTime ;

  014a3	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strDay$[ebp]
  014a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  014af	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  014b6	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _strTime$[ebp]
  014bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  014c2	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 396  : 	stringstream stream;

  014c6	6a 01		 push	 1
  014c8	6a 03		 push	 3
  014ca	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _stream$[ebp]
  014d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  014d6	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 397  : 	char fillc = stream.fill('0');

  014da	6a 30		 push	 48			; 00000030H
  014dc	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _stream$[ebp]
  014e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  014e5	8d 8c 0d 6c ff
	ff ff		 lea	 ecx, DWORD PTR _stream$[ebp+ecx]
  014ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEDD@Z
  014f2	88 85 6b ff ff
	ff		 mov	 BYTE PTR _fillc$[ebp], al

; 398  : 
; 399  : 	stream<< setw(2) << time.wMonth << "-" << setw(2) << time.wDay;

  014f8	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _stream$[ebp]
  014fe	85 d2		 test	 edx, edx
  01500	74 0e		 je	 SHORT $L94946
  01502	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _stream$[ebp+8]
  01508	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv94[ebp], eax
  0150e	eb 0a		 jmp	 SHORT $L94947
$L94946:
  01510	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv94[ebp], 0
$L94947:
  0151a	8b 4d 0c	 mov	 ecx, DWORD PTR _time$[ebp]
  0151d	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  01521	52		 push	 edx
  01522	6a 02		 push	 2
  01524	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR $T94944[ebp]
  0152a	50		 push	 eax
  0152b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
  01531	83 c4 08	 add	 esp, 8
  01534	50		 push	 eax
  01535	68 00 00 00 00	 push	 OFFSET FLAT:$SG87358
  0153a	8b 4d 0c	 mov	 ecx, DWORD PTR _time$[ebp]
  0153d	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  01541	52		 push	 edx
  01542	6a 02		 push	 2
  01544	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR $T94945[ebp]
  0154a	50		 push	 eax
  0154b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
  01551	83 c4 08	 add	 esp, 8
  01554	50		 push	 eax
  01555	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv94[ebp]
  0155b	51		 push	 ecx
  0155c	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
  01561	83 c4 08	 add	 esp, 8
  01564	8b c8		 mov	 ecx, eax
  01566	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  0156c	50		 push	 eax
  0156d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  01573	83 c4 08	 add	 esp, 8
  01576	50		 push	 eax
  01577	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
  0157c	83 c4 08	 add	 esp, 8
  0157f	8b c8		 mov	 ecx, eax
  01581	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z

; 400  : 	stream>> strDay;

  01587	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR _strDay$[ebp]
  0158d	52		 push	 edx
  0158e	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _stream$[ebp]
  01594	50		 push	 eax
  01595	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
  0159a	83 c4 08	 add	 esp, 8

; 401  : 	stream.clear();

  0159d	6a 00		 push	 0
  0159f	6a 00		 push	 0
  015a1	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _stream$[ebp]
  015a7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  015aa	8d 8c 15 6c ff
	ff ff		 lea	 ecx, DWORD PTR _stream$[ebp+edx]
  015b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 402  : 	// use two strings (strDay and strTime)here , because of the " " problem
; 403  : 	// when >> a stringtream to a string, >> operation will stop when barge up against " "
; 404  : 	stream<< setw(2) << time.wHour << ":" 
; 405  : 		<< setw(2) << time.wMinute << ":" 
; 406  : 		<< setw(2) << time.wSecond << "."
; 407  : 		<< setw(3) << time.wMilliseconds;

  015b7	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _stream$[ebp]
  015bd	85 c0		 test	 eax, eax
  015bf	74 0e		 je	 SHORT $L94952
  015c1	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _stream$[ebp+8]
  015c7	89 8d b8 fe ff
	ff		 mov	 DWORD PTR tv172[ebp], ecx
  015cd	eb 0a		 jmp	 SHORT $L94953
$L94952:
  015cf	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv172[ebp], 0
$L94953:
  015d9	8b 55 0c	 mov	 edx, DWORD PTR _time$[ebp]
  015dc	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  015e0	50		 push	 eax
  015e1	6a 03		 push	 3
  015e3	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR $T94948[ebp]
  015e9	51		 push	 ecx
  015ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
  015f0	83 c4 08	 add	 esp, 8
  015f3	50		 push	 eax
  015f4	68 00 00 00 00	 push	 OFFSET FLAT:$SG87363
  015f9	8b 55 0c	 mov	 edx, DWORD PTR _time$[ebp]
  015fc	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  01600	50		 push	 eax
  01601	6a 02		 push	 2
  01603	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T94949[ebp]
  01609	51		 push	 ecx
  0160a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
  01610	83 c4 08	 add	 esp, 8
  01613	50		 push	 eax
  01614	68 00 00 00 00	 push	 OFFSET FLAT:$SG87364
  01619	8b 55 0c	 mov	 edx, DWORD PTR _time$[ebp]
  0161c	66 8b 42 0a	 mov	 ax, WORD PTR [edx+10]
  01620	50		 push	 eax
  01621	6a 02		 push	 2
  01623	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T94950[ebp]
  01629	51		 push	 ecx
  0162a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
  01630	83 c4 08	 add	 esp, 8
  01633	50		 push	 eax
  01634	68 00 00 00 00	 push	 OFFSET FLAT:$SG87365
  01639	8b 55 0c	 mov	 edx, DWORD PTR _time$[ebp]
  0163c	66 8b 42 08	 mov	 ax, WORD PTR [edx+8]
  01640	50		 push	 eax
  01641	6a 02		 push	 2
  01643	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR $T94951[ebp]
  01649	51		 push	 ecx
  0164a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
  01650	83 c4 08	 add	 esp, 8
  01653	50		 push	 eax
  01654	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv172[ebp]
  0165a	52		 push	 edx
  0165b	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
  01660	83 c4 08	 add	 esp, 8
  01663	8b c8		 mov	 ecx, eax
  01665	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  0166b	50		 push	 eax
  0166c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  01672	83 c4 08	 add	 esp, 8
  01675	50		 push	 eax
  01676	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
  0167b	83 c4 08	 add	 esp, 8
  0167e	8b c8		 mov	 ecx, eax
  01680	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  01686	50		 push	 eax
  01687	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0168d	83 c4 08	 add	 esp, 8
  01690	50		 push	 eax
  01691	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
  01696	83 c4 08	 add	 esp, 8
  01699	8b c8		 mov	 ecx, eax
  0169b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z
  016a1	50		 push	 eax
  016a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  016a8	83 c4 08	 add	 esp, 8
  016ab	50		 push	 eax
  016ac	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
  016b1	83 c4 08	 add	 esp, 8
  016b4	8b c8		 mov	 ecx, eax
  016b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@G@Z

; 408  : 	stream>> strTime;

  016bc	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _strTime$[ebp]
  016c2	50		 push	 eax
  016c3	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _stream$[ebp]
  016c9	51		 push	 ecx
  016ca	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
  016cf	83 c4 08	 add	 esp, 8

; 409  : 	strTime = strDay + " " + strTime;

  016d2	68 00 00 00 00	 push	 OFFSET FLAT:$SG87368
  016d7	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR _strDay$[ebp]
  016dd	52		 push	 edx
  016de	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T94954[ebp]
  016e4	50		 push	 eax
  016e5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  016ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  016ed	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  016f3	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  016f9	89 8d b0 fe ff
	ff		 mov	 DWORD PTR tv219[ebp], ecx
  016ff	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  01703	8d 95 2c ff ff
	ff		 lea	 edx, DWORD PTR _strTime$[ebp]
  01709	52		 push	 edx
  0170a	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR tv219[ebp]
  01710	50		 push	 eax
  01711	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR $T94955[ebp]
  01717	51		 push	 ecx
  01718	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0171d	83 c4 0c	 add	 esp, 12			; 0000000cH
  01720	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  01726	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR tv68[ebp]
  0172c	89 95 a8 fe ff
	ff		 mov	 DWORD PTR tv221[ebp], edx
  01732	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  01736	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR tv221[ebp]
  0173c	50		 push	 eax
  0173d	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _strTime$[ebp]
  01743	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  01749	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0174d	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR $T94955[ebp]
  01753	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01759	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0175d	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T94954[ebp]
  01763	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 410  : 	return strTime;

  01769	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _strTime$[ebp]
  0176f	51		 push	 ecx
  01770	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01773	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  01779	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR $T94962[ebp]
  0177f	83 ca 01	 or	 edx, 1
  01782	89 95 c0 fe ff
	ff		 mov	 DWORD PTR $T94962[ebp], edx
  01788	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0178c	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _stream$[ebp]
  01792	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  01798	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0179c	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _strTime$[ebp]
  017a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  017a8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  017ac	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strDay$[ebp]
  017b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  017b8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 411  : }

  017bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  017be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  017c5	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017d0	8b e5		 mov	 esp, ebp
  017d2	5d		 pop	 ebp
  017d3	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94956:
  0028f	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strDay$[ebp]
  00295	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94957:
  0029b	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _strTime$[ebp]
  002a1	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94958:
  002a7	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _stream$[ebp]
  002ad	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$L94959:
  002b3	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T94954[ebp]
  002b9	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94960:
  002bf	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR $T94955[ebp]
  002c5	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94961:
  002cb	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR $T94962[ebp]
  002d1	83 e0 01	 and	 eax, 1
  002d4	0f 84 10 00 00
	00		 je	 $L94963
  002da	83 a5 c0 fe ff
	ff fe		 and	 DWORD PTR $T94962[ebp], -2 ; fffffffeH
  002e1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  002e4	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94963:
  002ea	c3		 ret	 0
__ehhandler$?FormatTime@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABU_SYSTEMTIME@@@Z:
  002eb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94965
  002f0	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FormatTime@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABU_SYSTEMTIME@@@Z ENDP ; FormatTime
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
PUBLIC	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
PUBLIC	??9const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator!=
PUBLIC	??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*
PUBLIC	??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV012@H@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator++
PUBLIC	?GetKeyValueStrUnescape@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z ; GetKeyValueStrUnescape
PUBLIC	?UTF8ToGB@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; UTF8ToGB
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z:NEAR
EXTRN	?Tokenize@YL_StringUtil@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@0@Z:NEAR ; YL_StringUtil::Tokenize
EXTRN	?decode@YL_URLEncoder@@SAPADPAD@Z:NEAR		; YL_URLEncoder::decode
EXTRN	__imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z:NEAR
xdata$x	SEGMENT
$T94985	DD	0ffffffffH
	DD	FLAT:$L94978
	DD	00H
	DD	FLAT:$L94974
	DD	01H
	DD	FLAT:$L94975
	DD	01H
	DD	FLAT:$L94976
	DD	03H
	DD	FLAT:$L94977
$T94982	DD	019930520H
	DD	05H
	DD	FLAT:$T94985
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T94979 = -136						; size = 4
$T94973 = -132						; size = 4
$T94972 = -128						; size = 4
$T94971 = -124						; size = 28
_strval$87751 = -96					; size = 28
_str$87748 = -68					; size = 28
__$ArrayPad$ = -40					; size = 4
_bpos$87745 = -36					; size = 4
_iter$87738 = -32					; size = 4
_vecstrs$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_line$ = 12						; size = 4
_key$ = 16						; size = 4
?GetKeyValueStrUnescape@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z PROC NEAR ; GetKeyValueStrUnescape

; 414  : {

  017e0	55		 push	 ebp
  017e1	8b ec		 mov	 ebp, esp
  017e3	6a ff		 push	 -1
  017e5	68 00 00 00 00	 push	 __ehhandler$?GetKeyValueStrUnescape@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z
  017ea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  017f0	50		 push	 eax
  017f1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  017f8	83 ec 7c	 sub	 esp, 124		; 0000007cH
  017fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  01800	89 45 d8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01803	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T94979[ebp], 0

; 415  : 	vector<string> vecstrs;

  0180d	8d 4d e4	 lea	 ecx, DWORD PTR _vecstrs$[ebp]
  01810	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  01815	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 416  : 	YL_StringUtil::Tokenize(line, vecstrs, "&");

  0181c	68 00 00 00 00	 push	 OFFSET FLAT:$SG87620
  01821	8d 4d 84	 lea	 ecx, DWORD PTR $T94971[ebp]
  01824	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0182a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0182e	8d 45 84	 lea	 eax, DWORD PTR $T94971[ebp]
  01831	50		 push	 eax
  01832	8d 4d e4	 lea	 ecx, DWORD PTR _vecstrs$[ebp]
  01835	51		 push	 ecx
  01836	8b 55 0c	 mov	 edx, DWORD PTR _line$[ebp]
  01839	52		 push	 edx
  0183a	e8 00 00 00 00	 call	 ?Tokenize@YL_StringUtil@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@0@Z ; YL_StringUtil::Tokenize
  0183f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01842	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01846	8d 4d 84	 lea	 ecx, DWORD PTR $T94971[ebp]
  01849	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 417  : 	for(vector<string>::iterator iter = vecstrs.begin(); iter != vecstrs.end(); iter++)

  0184f	8d 45 e0	 lea	 eax, DWORD PTR _iter$87738[ebp]
  01852	50		 push	 eax
  01853	8d 4d e4	 lea	 ecx, DWORD PTR _vecstrs$[ebp]
  01856	e8 00 00 00 00	 call	 ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
  0185b	eb 0e		 jmp	 SHORT $L87742
$L87743:
  0185d	6a 00		 push	 0
  0185f	8d 4d 80	 lea	 ecx, DWORD PTR $T94972[ebp]
  01862	51		 push	 ecx
  01863	8d 4d e0	 lea	 ecx, DWORD PTR _iter$87738[ebp]
  01866	e8 00 00 00 00	 call	 ??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV012@H@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator++
$L87742:
  0186b	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR $T94973[ebp]
  01871	52		 push	 edx
  01872	8d 4d e4	 lea	 ecx, DWORD PTR _vecstrs$[ebp]
  01875	e8 00 00 00 00	 call	 ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
  0187a	50		 push	 eax
  0187b	8d 4d e0	 lea	 ecx, DWORD PTR _iter$87738[ebp]
  0187e	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator!=
  01883	0f b6 c0	 movzx	 eax, al
  01886	85 c0		 test	 eax, eax
  01888	0f 84 04 01 00
	00		 je	 $L87744

; 418  : 	{
; 419  : 		string::size_type bpos = (*iter).find("=");

  0188e	6a 00		 push	 0
  01890	68 00 00 00 00	 push	 OFFSET FLAT:$SG87746
  01895	8d 4d e0	 lea	 ecx, DWORD PTR _iter$87738[ebp]
  01898	e8 00 00 00 00	 call	 ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*
  0189d	8b c8		 mov	 ecx, eax
  0189f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
  018a5	89 45 dc	 mov	 DWORD PTR _bpos$87745[ebp], eax

; 420  : 		if (bpos == string::npos)

  018a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  018ae	8b 55 dc	 mov	 edx, DWORD PTR _bpos$87745[ebp]
  018b1	3b 11		 cmp	 edx, DWORD PTR [ecx]
  018b3	75 02		 jne	 SHORT $L87747

; 421  : 			continue;

  018b5	eb a6		 jmp	 SHORT $L87743
$L87747:

; 422  : 		string str = (*iter).substr(0, bpos);

  018b7	8b 45 dc	 mov	 eax, DWORD PTR _bpos$87745[ebp]
  018ba	50		 push	 eax
  018bb	6a 00		 push	 0
  018bd	8d 4d bc	 lea	 ecx, DWORD PTR _str$87748[ebp]
  018c0	51		 push	 ecx
  018c1	8d 4d e0	 lea	 ecx, DWORD PTR _iter$87738[ebp]
  018c4	e8 00 00 00 00	 call	 ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*
  018c9	8b c8		 mov	 ecx, eax
  018cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  018d1	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 423  : 		if(str == key)

  018d5	8b 55 10	 mov	 edx, DWORD PTR _key$[ebp]
  018d8	52		 push	 edx
  018d9	8d 45 bc	 lea	 eax, DWORD PTR _str$87748[ebp]
  018dc	50		 push	 eax
  018dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
  018e3	83 c4 08	 add	 esp, 8
  018e6	0f b6 c8	 movzx	 ecx, al
  018e9	85 c9		 test	 ecx, ecx
  018eb	0f 84 8f 00 00
	00		 je	 $L87750

; 424  : 		{
; 425  : 			string strval = (*iter).substr(bpos+1, (*iter).length()-bpos-1);

  018f1	8d 4d e0	 lea	 ecx, DWORD PTR _iter$87738[ebp]
  018f4	e8 00 00 00 00	 call	 ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*
  018f9	8b c8		 mov	 ecx, eax
  018fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  01901	2b 45 dc	 sub	 eax, DWORD PTR _bpos$87745[ebp]
  01904	83 e8 01	 sub	 eax, 1
  01907	50		 push	 eax
  01908	8b 55 dc	 mov	 edx, DWORD PTR _bpos$87745[ebp]
  0190b	83 c2 01	 add	 edx, 1
  0190e	52		 push	 edx
  0190f	8d 45 a0	 lea	 eax, DWORD PTR _strval$87751[ebp]
  01912	50		 push	 eax
  01913	8d 4d e0	 lea	 ecx, DWORD PTR _iter$87738[ebp]
  01916	e8 00 00 00 00	 call	 ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*
  0191b	8b c8		 mov	 ecx, eax
  0191d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  01923	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 426  : 			return UTF8ToGB( YL_URLEncoder::decode((char*)strval.c_str()) );

  01927	8d 4d a0	 lea	 ecx, DWORD PTR _strval$87751[ebp]
  0192a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  01930	50		 push	 eax
  01931	e8 00 00 00 00	 call	 ?decode@YL_URLEncoder@@SAPADPAD@Z ; YL_URLEncoder::decode
  01936	83 c4 04	 add	 esp, 4
  01939	50		 push	 eax
  0193a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0193d	51		 push	 ecx
  0193e	e8 00 00 00 00	 call	 ?UTF8ToGB@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; UTF8ToGB
  01943	83 c4 08	 add	 esp, 8
  01946	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR $T94979[ebp]
  0194c	83 ca 01	 or	 edx, 1
  0194f	89 95 78 ff ff
	ff		 mov	 DWORD PTR $T94979[ebp], edx
  01955	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  01959	8d 4d a0	 lea	 ecx, DWORD PTR _strval$87751[ebp]
  0195c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01962	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01966	8d 4d bc	 lea	 ecx, DWORD PTR _str$87748[ebp]
  01969	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0196f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01973	8d 4d e4	 lea	 ecx, DWORD PTR _vecstrs$[ebp]
  01976	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0197b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0197e	eb 3e		 jmp	 SHORT $L87375
$L87750:

; 427  : 		}
; 428  : 	}

  01980	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01984	8d 4d bc	 lea	 ecx, DWORD PTR _str$87748[ebp]
  01987	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0198d	e9 cb fe ff ff	 jmp	 $L87743
$L87744:

; 429  : 	return "";

  01992	68 00 00 00 00	 push	 OFFSET FLAT:$SG87755
  01997	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0199a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  019a0	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T94979[ebp]
  019a6	83 c8 01	 or	 eax, 1
  019a9	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T94979[ebp], eax
  019af	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  019b3	8d 4d e4	 lea	 ecx, DWORD PTR _vecstrs$[ebp]
  019b6	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  019bb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L87375:

; 430  : }

  019be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  019c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  019c8	8b 4d d8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  019cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  019d0	8b e5		 mov	 esp, ebp
  019d2	5d		 pop	 ebp
  019d3	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94974:
  002f5	8d 4d e4	 lea	 ecx, DWORD PTR _vecstrs$[ebp]
  002f8	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$L94975:
  002fd	8d 4d 84	 lea	 ecx, DWORD PTR $T94971[ebp]
  00300	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94976:
  00306	8d 4d bc	 lea	 ecx, DWORD PTR _str$87748[ebp]
  00309	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94977:
  0030f	8d 4d a0	 lea	 ecx, DWORD PTR _strval$87751[ebp]
  00312	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94978:
  00318	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T94979[ebp]
  0031e	83 e0 01	 and	 eax, 1
  00321	0f 84 10 00 00
	00		 je	 $L94980
  00327	83 a5 78 ff ff
	ff fe		 and	 DWORD PTR $T94979[ebp], -2 ; fffffffeH
  0032e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00331	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L94980:
  00337	c3		 ret	 0
__ehhandler$?GetKeyValueStrUnescape@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z:
  00338	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94982
  0033d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetKeyValueStrUnescape@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z ENDP ; GetKeyValueStrUnescape
PUBLIC	?GetKeyValueStr1@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z ; GetKeyValueStr1
EXTRN	__imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z:NEAR
xdata$x	SEGMENT
$T94995	DD	0ffffffffH
	DD	FLAT:$L94988
$T94993	DD	019930520H
	DD	01H
	DD	FLAT:$T94995
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv134 = -60						; size = 4
tv128 = -56						; size = 4
$T94990 = -52						; size = 4
$T94987 = -48						; size = 28
_bpos$ = -20						; size = 4
_epos$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_line$ = 12						; size = 4
_key$ = 16						; size = 4
?GetKeyValueStr1@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z PROC NEAR ; GetKeyValueStr1

; 433  : {

  019e0	55		 push	 ebp
  019e1	8b ec		 mov	 ebp, esp
  019e3	6a ff		 push	 -1
  019e5	68 00 00 00 00	 push	 __ehhandler$?GetKeyValueStr1@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z
  019ea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  019f0	50		 push	 eax
  019f1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  019f8	83 ec 30	 sub	 esp, 48			; 00000030H
  019fb	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T94990[ebp], 0

; 434  : 	string::size_type bpos = line.find(key+"=");

  01a02	68 00 00 00 00	 push	 OFFSET FLAT:$SG87763
  01a07	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  01a0a	50		 push	 eax
  01a0b	8d 4d d0	 lea	 ecx, DWORD PTR $T94987[ebp]
  01a0e	51		 push	 ecx
  01a0f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01a14	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a17	89 45 c8	 mov	 DWORD PTR tv128[ebp], eax
  01a1a	8b 55 c8	 mov	 edx, DWORD PTR tv128[ebp]
  01a1d	89 55 c4	 mov	 DWORD PTR tv134[ebp], edx
  01a20	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  01a27	6a 00		 push	 0
  01a29	8b 45 c4	 mov	 eax, DWORD PTR tv134[ebp]
  01a2c	50		 push	 eax
  01a2d	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  01a30	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z
  01a36	89 45 ec	 mov	 DWORD PTR _bpos$[ebp], eax
  01a39	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01a40	8d 4d d0	 lea	 ecx, DWORD PTR $T94987[ebp]
  01a43	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 435  : 	if (bpos != 0)

  01a49	83 7d ec 00	 cmp	 DWORD PTR _bpos$[ebp], 0
  01a4d	74 1f		 je	 SHORT $L87764

; 436  : 		return "";

  01a4f	68 00 00 00 00	 push	 OFFSET FLAT:$SG87765
  01a54	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01a57	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  01a5d	8b 4d cc	 mov	 ecx, DWORD PTR $T94990[ebp]
  01a60	83 c9 01	 or	 ecx, 1
  01a63	89 4d cc	 mov	 DWORD PTR $T94990[ebp], ecx
  01a66	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  01a69	e9 81 00 00 00	 jmp	 $L87760
$L87764:

; 437  : 	bpos += key.length() + 1;

  01a6e	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  01a71	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  01a77	8b 55 ec	 mov	 edx, DWORD PTR _bpos$[ebp]
  01a7a	8d 44 02 01	 lea	 eax, DWORD PTR [edx+eax+1]
  01a7e	89 45 ec	 mov	 DWORD PTR _bpos$[ebp], eax

; 438  : 	string::size_type epos = line.find("&", bpos);

  01a81	8b 4d ec	 mov	 ecx, DWORD PTR _bpos$[ebp]
  01a84	51		 push	 ecx
  01a85	68 00 00 00 00	 push	 OFFSET FLAT:$SG87767
  01a8a	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  01a8d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
  01a93	89 45 f0	 mov	 DWORD PTR _epos$[ebp], eax

; 439  : 	if (epos != string::npos)

  01a96	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  01a9c	8b 45 f0	 mov	 eax, DWORD PTR _epos$[ebp]
  01a9f	3b 02		 cmp	 eax, DWORD PTR [edx]
  01aa1	74 26		 je	 SHORT $L87768

; 440  : 		return line.substr(bpos, epos - bpos);

  01aa3	8b 4d f0	 mov	 ecx, DWORD PTR _epos$[ebp]
  01aa6	2b 4d ec	 sub	 ecx, DWORD PTR _bpos$[ebp]
  01aa9	51		 push	 ecx
  01aaa	8b 55 ec	 mov	 edx, DWORD PTR _bpos$[ebp]
  01aad	52		 push	 edx
  01aae	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  01ab1	50		 push	 eax
  01ab2	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  01ab5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  01abb	8b 4d cc	 mov	 ecx, DWORD PTR $T94990[ebp]
  01abe	83 c9 01	 or	 ecx, 1
  01ac1	89 4d cc	 mov	 DWORD PTR $T94990[ebp], ecx
  01ac4	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  01ac7	eb 26		 jmp	 SHORT $L87760
$L87768:

; 441  : 	else
; 442  : 		return line.substr(bpos); 

  01ac9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  01acf	8b 02		 mov	 eax, DWORD PTR [edx]
  01ad1	50		 push	 eax
  01ad2	8b 4d ec	 mov	 ecx, DWORD PTR _bpos$[ebp]
  01ad5	51		 push	 ecx
  01ad6	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  01ad9	52		 push	 edx
  01ada	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  01add	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  01ae3	8b 45 cc	 mov	 eax, DWORD PTR $T94990[ebp]
  01ae6	83 c8 01	 or	 eax, 1
  01ae9	89 45 cc	 mov	 DWORD PTR $T94990[ebp], eax
  01aec	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L87760:

; 443  : }

  01aef	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01af2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01af9	8b e5		 mov	 esp, ebp
  01afb	5d		 pop	 ebp
  01afc	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94988:
  00342	8d 4d d0	 lea	 ecx, DWORD PTR $T94987[ebp]
  00345	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetKeyValueStr1@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z:
  0034b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T94993
  00350	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetKeyValueStr1@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z ENDP ; GetKeyValueStr1
PUBLIC	?GetKeyValueStr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z ; GetKeyValueStr
xdata$x	SEGMENT
$T95005	DD	0ffffffffH
	DD	FLAT:$L94998
$T95003	DD	019930520H
	DD	01H
	DD	FLAT:$T95005
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv134 = -60						; size = 4
tv128 = -56						; size = 4
$T95000 = -52						; size = 4
$T94997 = -48						; size = 28
_bpos$ = -20						; size = 4
_epos$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_line$ = 12						; size = 4
_key$ = 16						; size = 4
?GetKeyValueStr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z PROC NEAR ; GetKeyValueStr

; 445  : {

  01b00	55		 push	 ebp
  01b01	8b ec		 mov	 ebp, esp
  01b03	6a ff		 push	 -1
  01b05	68 00 00 00 00	 push	 __ehhandler$?GetKeyValueStr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z
  01b0a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01b10	50		 push	 eax
  01b11	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01b18	83 ec 30	 sub	 esp, 48			; 00000030H
  01b1b	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T95000[ebp], 0

; 446  : 	//vector<string> vecstrs;
; 447  : 	//YL_StringUtil::Tokenize(line, vecstrs, "&");
; 448  : 	//for(vector<string>::iterator iter = vecstrs.begin(); iter != vecstrs.end(); iter++)
; 449  : 	//{
; 450  : 	//	string::size_type bpos = (*iter).find("=");
; 451  : 	//	if (bpos == string::npos)
; 452  : 	//		continue;
; 453  : 	//	string str = (*iter).substr(0, bpos);
; 454  : 	//	if(str == key)
; 455  : 	//	{
; 456  : 	//		string strval = (*iter).substr(bpos+1, (*iter).length()-bpos-1);
; 457  : 	//		return strval;
; 458  : 	//	}
; 459  : 	//}
; 460  : 	//return "";
; 461  : 	string::size_type bpos = line.find(key+"=");

  01b22	68 00 00 00 00	 push	 OFFSET FLAT:$SG87779
  01b27	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  01b2a	50		 push	 eax
  01b2b	8d 4d d0	 lea	 ecx, DWORD PTR $T94997[ebp]
  01b2e	51		 push	 ecx
  01b2f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01b34	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b37	89 45 c8	 mov	 DWORD PTR tv128[ebp], eax
  01b3a	8b 55 c8	 mov	 edx, DWORD PTR tv128[ebp]
  01b3d	89 55 c4	 mov	 DWORD PTR tv134[ebp], edx
  01b40	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  01b47	6a 00		 push	 0
  01b49	8b 45 c4	 mov	 eax, DWORD PTR tv134[ebp]
  01b4c	50		 push	 eax
  01b4d	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  01b50	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z
  01b56	89 45 ec	 mov	 DWORD PTR _bpos$[ebp], eax
  01b59	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01b60	8d 4d d0	 lea	 ecx, DWORD PTR $T94997[ebp]
  01b63	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 462  : 	if (bpos == string::npos)

  01b69	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  01b6f	8b 55 ec	 mov	 edx, DWORD PTR _bpos$[ebp]
  01b72	3b 11		 cmp	 edx, DWORD PTR [ecx]
  01b74	75 1f		 jne	 SHORT $L87780

; 463  : 		return "";

  01b76	68 00 00 00 00	 push	 OFFSET FLAT:$SG87781
  01b7b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01b7e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  01b84	8b 45 cc	 mov	 eax, DWORD PTR $T95000[ebp]
  01b87	83 c8 01	 or	 eax, 1
  01b8a	89 45 cc	 mov	 DWORD PTR $T95000[ebp], eax
  01b8d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  01b90	e9 81 00 00 00	 jmp	 $L87776
$L87780:

; 464  : 	bpos += key.length() + 1;

  01b95	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  01b98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  01b9e	8b 4d ec	 mov	 ecx, DWORD PTR _bpos$[ebp]
  01ba1	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  01ba5	89 55 ec	 mov	 DWORD PTR _bpos$[ebp], edx

; 465  : 	string::size_type epos = line.find("&", bpos);

  01ba8	8b 45 ec	 mov	 eax, DWORD PTR _bpos$[ebp]
  01bab	50		 push	 eax
  01bac	68 00 00 00 00	 push	 OFFSET FLAT:$SG87783
  01bb1	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  01bb4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
  01bba	89 45 f0	 mov	 DWORD PTR _epos$[ebp], eax

; 466  : 	if (epos != string::npos)

  01bbd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  01bc3	8b 55 f0	 mov	 edx, DWORD PTR _epos$[ebp]
  01bc6	3b 11		 cmp	 edx, DWORD PTR [ecx]
  01bc8	74 26		 je	 SHORT $L87784

; 467  : 		return line.substr(bpos, epos - bpos);

  01bca	8b 45 f0	 mov	 eax, DWORD PTR _epos$[ebp]
  01bcd	2b 45 ec	 sub	 eax, DWORD PTR _bpos$[ebp]
  01bd0	50		 push	 eax
  01bd1	8b 4d ec	 mov	 ecx, DWORD PTR _bpos$[ebp]
  01bd4	51		 push	 ecx
  01bd5	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  01bd8	52		 push	 edx
  01bd9	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  01bdc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  01be2	8b 45 cc	 mov	 eax, DWORD PTR $T95000[ebp]
  01be5	83 c8 01	 or	 eax, 1
  01be8	89 45 cc	 mov	 DWORD PTR $T95000[ebp], eax
  01beb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  01bee	eb 26		 jmp	 SHORT $L87776
$L87784:

; 468  : 	else
; 469  : 		return line.substr(bpos); 

  01bf0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  01bf6	8b 11		 mov	 edx, DWORD PTR [ecx]
  01bf8	52		 push	 edx
  01bf9	8b 45 ec	 mov	 eax, DWORD PTR _bpos$[ebp]
  01bfc	50		 push	 eax
  01bfd	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01c00	51		 push	 ecx
  01c01	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  01c04	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  01c0a	8b 55 cc	 mov	 edx, DWORD PTR $T95000[ebp]
  01c0d	83 ca 01	 or	 edx, 1
  01c10	89 55 cc	 mov	 DWORD PTR $T95000[ebp], edx
  01c13	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L87776:

; 470  : }

  01c16	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01c19	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01c20	8b e5		 mov	 esp, ebp
  01c22	5d		 pop	 ebp
  01c23	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L94998:
  00355	8d 4d d0	 lea	 ecx, DWORD PTR $T94997[ebp]
  00358	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetKeyValueStr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z:
  0035e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95003
  00363	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetKeyValueStr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@0@Z ENDP ; GetKeyValueStr
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str2rgb@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; str2rgb
EXTRN	__imp__sscanf:NEAR
xdata$x	SEGMENT
$T95029	DD	0ffffffffH
	DD	FLAT:$L95015
	DD	00H
	DD	FLAT:$L95016
	DD	01H
	DD	FLAT:$L95017
	DD	02H
	DD	FLAT:$L95018
	DD	03H
	DD	FLAT:$L95019
	DD	04H
	DD	FLAT:$L95020
	DD	03H
	DD	FLAT:$L95021
	DD	06H
	DD	FLAT:$L95022
	DD	03H
	DD	FLAT:$L95023
	DD	08H
	DD	FLAT:$L95024
$T95026	DD	019930520H
	DD	0aH
	DD	FLAT:$T95029
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv188 = -336						; size = 4
tv195 = -332						; size = 4
tv186 = -328						; size = 4
tv194 = -324						; size = 4
tv184 = -320						; size = 4
tv193 = -316						; size = 4
tv182 = -312						; size = 4
tv66 = -308						; size = 4
tv180 = -304						; size = 4
tv69 = -300						; size = 4
tv178 = -296						; size = 4
tv72 = -292						; size = 4
$T95014 = -288						; size = 4
$T95013 = -284						; size = 28
$T95012 = -256						; size = 28
$T95011 = -228						; size = 28
$T95010 = -200						; size = 28
$T95009 = -172						; size = 28
$T95008 = -144						; size = 28
_nb$ = -116						; size = 4
_r$ = -112						; size = 28
_ng$ = -84						; size = 4
_g$ = -80						; size = 28
_b$ = -52						; size = 28
__$ArrayPad$ = -24					; size = 4
_nr$ = -20						; size = 4
_color$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_strClr$ = 8						; size = 28
?str2rgb@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; str2rgb

; 473  : {

  01c30	55		 push	 ebp
  01c31	8b ec		 mov	 ebp, esp
  01c33	6a ff		 push	 -1
  01c35	68 00 00 00 00	 push	 __ehhandler$?str2rgb@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  01c3a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01c40	50		 push	 eax
  01c41	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01c48	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  01c4e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  01c53	89 45 e8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01c56	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 474  : 	string r,g,b;	

  01c5d	8d 4d 90	 lea	 ecx, DWORD PTR _r$[ebp]
  01c60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01c66	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01c6a	8d 4d b0	 lea	 ecx, DWORD PTR _g$[ebp]
  01c6d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01c73	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01c77	8d 4d cc	 lea	 ecx, DWORD PTR _b$[ebp]
  01c7a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01c80	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 475  : 	r = "0" + strClr.substr(0,2);

  01c84	6a 02		 push	 2
  01c86	6a 00		 push	 0
  01c88	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T95008[ebp]
  01c8e	50		 push	 eax
  01c8f	8d 4d 08	 lea	 ecx, DWORD PTR _strClr$[ebp]
  01c92	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  01c98	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  01c9e	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  01ca4	89 8d d8 fe ff
	ff		 mov	 DWORD PTR tv178[ebp], ecx
  01caa	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  01cae	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv178[ebp]
  01cb4	52		 push	 edx
  01cb5	68 00 00 00 00	 push	 OFFSET FLAT:$SG87796
  01cba	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T95009[ebp]
  01cc0	50		 push	 eax
  01cc1	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01cc6	83 c4 0c	 add	 esp, 12			; 0000000cH
  01cc9	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  01ccf	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  01cd5	89 8d d0 fe ff
	ff		 mov	 DWORD PTR tv180[ebp], ecx
  01cdb	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  01cdf	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv180[ebp]
  01ce5	52		 push	 edx
  01ce6	8d 4d 90	 lea	 ecx, DWORD PTR _r$[ebp]
  01ce9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  01cef	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  01cf3	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T95009[ebp]
  01cf9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01cff	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  01d03	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T95008[ebp]
  01d09	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 476  : 	g = "0" + strClr.substr(2,2);

  01d0f	6a 02		 push	 2
  01d11	6a 02		 push	 2
  01d13	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T95010[ebp]
  01d19	50		 push	 eax
  01d1a	8d 4d 08	 lea	 ecx, DWORD PTR _strClr$[ebp]
  01d1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  01d23	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  01d29	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  01d2f	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv182[ebp], ecx
  01d35	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  01d39	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR tv182[ebp]
  01d3f	52		 push	 edx
  01d40	68 00 00 00 00	 push	 OFFSET FLAT:$SG87799
  01d45	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR $T95011[ebp]
  01d4b	50		 push	 eax
  01d4c	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d51	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d54	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv193[ebp], eax
  01d5a	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv193[ebp]
  01d60	89 8d c0 fe ff
	ff		 mov	 DWORD PTR tv184[ebp], ecx
  01d66	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  01d6a	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR tv184[ebp]
  01d70	52		 push	 edx
  01d71	8d 4d b0	 lea	 ecx, DWORD PTR _g$[ebp]
  01d74	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  01d7a	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  01d7e	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T95011[ebp]
  01d84	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01d8a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  01d8e	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T95010[ebp]
  01d94	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 477  : 	b = "0" + strClr.substr(4,2);

  01d9a	6a 02		 push	 2
  01d9c	6a 04		 push	 4
  01d9e	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T95012[ebp]
  01da4	50		 push	 eax
  01da5	8d 4d 08	 lea	 ecx, DWORD PTR _strClr$[ebp]
  01da8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  01dae	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv194[ebp], eax
  01db4	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv194[ebp]
  01dba	89 8d b8 fe ff
	ff		 mov	 DWORD PTR tv186[ebp], ecx
  01dc0	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  01dc4	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv186[ebp]
  01dca	52		 push	 edx
  01dcb	68 00 00 00 00	 push	 OFFSET FLAT:$SG87802
  01dd0	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T95013[ebp]
  01dd6	50		 push	 eax
  01dd7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ddc	83 c4 0c	 add	 esp, 12			; 0000000cH
  01ddf	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv195[ebp], eax
  01de5	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv195[ebp]
  01deb	89 8d b0 fe ff
	ff		 mov	 DWORD PTR tv188[ebp], ecx
  01df1	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  01df5	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR tv188[ebp]
  01dfb	52		 push	 edx
  01dfc	8d 4d cc	 lea	 ecx, DWORD PTR _b$[ebp]
  01dff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  01e05	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  01e09	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T95013[ebp]
  01e0f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01e15	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  01e19	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T95012[ebp]
  01e1f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 478  : 	int nr,ng,nb;
; 479  : 	sscanf(r.c_str(), "%x", &nr);

  01e25	8d 45 ec	 lea	 eax, DWORD PTR _nr$[ebp]
  01e28	50		 push	 eax
  01e29	68 00 00 00 00	 push	 OFFSET FLAT:$SG87806
  01e2e	8d 4d 90	 lea	 ecx, DWORD PTR _r$[ebp]
  01e31	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  01e37	50		 push	 eax
  01e38	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sscanf
  01e3e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 480  : 	sscanf(g.c_str(), "%x", &ng);

  01e41	8d 4d ac	 lea	 ecx, DWORD PTR _ng$[ebp]
  01e44	51		 push	 ecx
  01e45	68 00 00 00 00	 push	 OFFSET FLAT:$SG87807
  01e4a	8d 4d b0	 lea	 ecx, DWORD PTR _g$[ebp]
  01e4d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  01e53	50		 push	 eax
  01e54	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sscanf
  01e5a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 481  : 	sscanf(b.c_str(), "%x", &nb);

  01e5d	8d 55 8c	 lea	 edx, DWORD PTR _nb$[ebp]
  01e60	52		 push	 edx
  01e61	68 00 00 00 00	 push	 OFFSET FLAT:$SG87808
  01e66	8d 4d cc	 lea	 ecx, DWORD PTR _b$[ebp]
  01e69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  01e6f	50		 push	 eax
  01e70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sscanf
  01e76	83 c4 0c	 add	 esp, 12			; 0000000cH

; 482  : 
; 483  : 	COLORREF color = RGB(nr,ng,nb);

  01e79	0f b6 45 ec	 movzx	 eax, BYTE PTR _nr$[ebp]
  01e7d	0f b6 4d ac	 movzx	 ecx, BYTE PTR _ng$[ebp]
  01e81	c1 e1 08	 shl	 ecx, 8
  01e84	0b c1		 or	 eax, ecx
  01e86	0f b6 55 8c	 movzx	 edx, BYTE PTR _nb$[ebp]
  01e8a	c1 e2 10	 shl	 edx, 16			; 00000010H
  01e8d	0b c2		 or	 eax, edx
  01e8f	89 45 f0	 mov	 DWORD PTR _color$[ebp], eax

; 484  : 	return color;	

  01e92	8b 45 f0	 mov	 eax, DWORD PTR _color$[ebp]
  01e95	89 85 e0 fe ff
	ff		 mov	 DWORD PTR $T95014[ebp], eax
  01e9b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01e9f	8d 4d cc	 lea	 ecx, DWORD PTR _b$[ebp]
  01ea2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01ea8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01eac	8d 4d b0	 lea	 ecx, DWORD PTR _g$[ebp]
  01eaf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01eb5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01eb9	8d 4d 90	 lea	 ecx, DWORD PTR _r$[ebp]
  01ebc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01ec2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01ec9	8d 4d 08	 lea	 ecx, DWORD PTR _strClr$[ebp]
  01ecc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01ed2	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR $T95014[ebp]

; 485  : }

  01ed8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01edb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01ee2	8b 4d e8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ee5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01eea	8b e5		 mov	 esp, ebp
  01eec	5d		 pop	 ebp
  01eed	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L95015:
  00368	8d 4d 08	 lea	 ecx, DWORD PTR _strClr$[ebp]
  0036b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95016:
  00371	8d 4d 90	 lea	 ecx, DWORD PTR _r$[ebp]
  00374	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95017:
  0037a	8d 4d b0	 lea	 ecx, DWORD PTR _g$[ebp]
  0037d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95018:
  00383	8d 4d cc	 lea	 ecx, DWORD PTR _b$[ebp]
  00386	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95019:
  0038c	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T95008[ebp]
  00392	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95020:
  00398	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T95009[ebp]
  0039e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95021:
  003a4	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T95010[ebp]
  003aa	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95022:
  003b0	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T95011[ebp]
  003b6	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95023:
  003bc	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T95012[ebp]
  003c2	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95024:
  003c8	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T95013[ebp]
  003ce	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?str2rgb@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  003d4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95026
  003d9	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?str2rgb@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; str2rgb
PUBLIC	?RandomIntValue@@YAXHPAH@Z			; RandomIntValue
EXTRN	__imp__GetTickCount@0:NEAR
EXTRN	__imp__rand:NEAR
EXTRN	__imp__srand:NEAR
;	COMDAT ?dwLastThreadID@?1??RandomIntValue@@YAXHPAH@Z@4KA
_BSS	SEGMENT
?dwLastThreadID@?1??RandomIntValue@@YAXHPAH@Z@4KA DD 01H DUP (?) ; `RandomIntValue'::`2'::dwLastThreadID
; Function compile flags: /Odt
_BSS	ENDS
_TEXT	SEGMENT
_i$87836 = -16						; size = 4
_idx$87829 = -12					; size = 4
_idx$87825 = -8						; size = 4
_iRandValue$ = -4					; size = 4
_iNum$ = 8						; size = 4
_pStoreRandomValues$ = 12				; size = 4
?RandomIntValue@@YAXHPAH@Z PROC NEAR			; RandomIntValue

; 488  : {

  01ef0	55		 push	 ebp
  01ef1	8b ec		 mov	 ebp, esp
  01ef3	83 ec 10	 sub	 esp, 16			; 00000010H

; 489  : 	static DWORD dwLastThreadID = 0;
; 490  : 	if( dwLastThreadID != GetCurrentThreadId() )

  01ef6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  01efc	39 05 00 00 00
	00		 cmp	 DWORD PTR ?dwLastThreadID@?1??RandomIntValue@@YAXHPAH@Z@4KA, eax
  01f02	74 1b		 je	 SHORT $L87823

; 491  : 	{
; 492  : 		srand(GetTickCount());

  01f04	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01f0a	50		 push	 eax
  01f0b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand
  01f11	83 c4 04	 add	 esp, 4

; 493  : 		dwLastThreadID = GetCurrentThreadId();

  01f14	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  01f1a	a3 00 00 00 00	 mov	 DWORD PTR ?dwLastThreadID@?1??RandomIntValue@@YAXHPAH@Z@4KA, eax
$L87823:

; 494  : 	}	
; 495  : 
; 496  : 	int iRandValue = 0;

  01f1f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iRandValue$[ebp], 0

; 497  : 
; 498  : 	for(int idx = 0;idx < iNum;idx++)

  01f26	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _idx$87825[ebp], 0
  01f2d	eb 09		 jmp	 SHORT $L87826
$L87827:
  01f2f	8b 45 f8	 mov	 eax, DWORD PTR _idx$87825[ebp]
  01f32	83 c0 01	 add	 eax, 1
  01f35	89 45 f8	 mov	 DWORD PTR _idx$87825[ebp], eax
$L87826:
  01f38	8b 4d f8	 mov	 ecx, DWORD PTR _idx$87825[ebp]
  01f3b	3b 4d 08	 cmp	 ecx, DWORD PTR _iNum$[ebp]
  01f3e	7d 0f		 jge	 SHORT $L87828

; 499  : 	{
; 500  : 		pStoreRandomValues[idx] = -1;

  01f40	8b 55 f8	 mov	 edx, DWORD PTR _idx$87825[ebp]
  01f43	8b 45 0c	 mov	 eax, DWORD PTR _pStoreRandomValues$[ebp]
  01f46	c7 04 90 ff ff
	ff ff		 mov	 DWORD PTR [eax+edx*4], -1

; 501  : 	}

  01f4d	eb e0		 jmp	 SHORT $L87827
$L87828:

; 502  : 
; 503  : 	for( int idx = 0;idx < iNum;idx++ )

  01f4f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _idx$87829[ebp], 0
  01f56	eb 09		 jmp	 SHORT $L87830
$L87831:
  01f58	8b 4d f4	 mov	 ecx, DWORD PTR _idx$87829[ebp]
  01f5b	83 c1 01	 add	 ecx, 1
  01f5e	89 4d f4	 mov	 DWORD PTR _idx$87829[ebp], ecx
$L87830:
  01f61	8b 55 f4	 mov	 edx, DWORD PTR _idx$87829[ebp]
  01f64	3b 55 08	 cmp	 edx, DWORD PTR _iNum$[ebp]
  01f67	7d 2d		 jge	 SHORT $L87820
$L87833:

; 504  : 	{
; 505  : 		do{			
; 506  : 			int i = rand();

  01f69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  01f6f	89 45 f0	 mov	 DWORD PTR _i$87836[ebp], eax

; 507  : 			iRandValue = i % (int)iNum;

  01f72	8b 45 f0	 mov	 eax, DWORD PTR _i$87836[ebp]
  01f75	99		 cdq
  01f76	f7 7d 08	 idiv	 DWORD PTR _iNum$[ebp]
  01f79	89 55 fc	 mov	 DWORD PTR _iRandValue$[ebp], edx

; 508  : 		}while( pStoreRandomValues[iRandValue] != -1 );

  01f7c	8b 45 fc	 mov	 eax, DWORD PTR _iRandValue$[ebp]
  01f7f	8b 4d 0c	 mov	 ecx, DWORD PTR _pStoreRandomValues$[ebp]
  01f82	83 3c 81 ff	 cmp	 DWORD PTR [ecx+eax*4], -1
  01f86	75 e1		 jne	 SHORT $L87833

; 509  : 
; 510  : 		pStoreRandomValues[iRandValue] = idx;		

  01f88	8b 55 fc	 mov	 edx, DWORD PTR _iRandValue$[ebp]
  01f8b	8b 45 0c	 mov	 eax, DWORD PTR _pStoreRandomValues$[ebp]
  01f8e	8b 4d f4	 mov	 ecx, DWORD PTR _idx$87829[ebp]
  01f91	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 511  : 	}	

  01f94	eb c2		 jmp	 SHORT $L87831
$L87820:

; 512  : }

  01f96	8b e5		 mov	 esp, ebp
  01f98	5d		 pop	 ebp
  01f99	c3		 ret	 0
?RandomIntValue@@YAXHPAH@Z ENDP				; RandomIntValue
_TEXT	ENDS
PUBLIC	?GetCurrentDate@@YAIXZ				; GetCurrentDate
EXTRN	__imp__time:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_timer$ = -4						; size = 4
?GetCurrentDate@@YAIXZ PROC NEAR			; GetCurrentDate

; 515  : {

  01fa0	55		 push	 ebp
  01fa1	8b ec		 mov	 ebp, esp
  01fa3	51		 push	 ecx

; 516  : 	time_t timer;
; 517  : 	time(&timer);

  01fa4	8d 45 fc	 lea	 eax, DWORD PTR _timer$[ebp]
  01fa7	50		 push	 eax
  01fa8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__time
  01fae	83 c4 04	 add	 esp, 4

; 518  : 	return (unsigned int)(timer/(60 * 60 * 24));

  01fb1	8b 45 fc	 mov	 eax, DWORD PTR _timer$[ebp]
  01fb4	99		 cdq
  01fb5	b9 80 51 01 00	 mov	 ecx, 86400		; 00015180H
  01fba	f7 f9		 idiv	 ecx

; 519  : }

  01fbc	8b e5		 mov	 esp, ebp
  01fbe	5d		 pop	 ebp
  01fbf	c3		 ret	 0
?GetCurrentDate@@YAIXZ ENDP				; GetCurrentDate
_TEXT	ENDS
PUBLIC	?RSHash@@YAJPBD@Z				; RSHash
; Function compile flags: /Odt
_TEXT	SEGMENT
_hash$ = -12						; size = 4
_b$ = -8						; size = 4
_a$ = -4						; size = 4
_str$ = 8						; size = 4
?RSHash@@YAJPBD@Z PROC NEAR				; RSHash

; 522  : {

  01fc0	55		 push	 ebp
  01fc1	8b ec		 mov	 ebp, esp
  01fc3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 523  :     long b = 479551;

  01fc6	c7 45 f8 3f 51
	07 00		 mov	 DWORD PTR _b$[ebp], 479551 ; 0007513fH

; 524  :     long a = 63489;

  01fcd	c7 45 fc 01 f8
	00 00		 mov	 DWORD PTR _a$[ebp], 63489 ; 0000f801H

; 525  :     long hash = 0;

  01fd4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hash$[ebp], 0
$L87849:

; 526  : 
; 527  :     while (*str)

  01fdb	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  01fde	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  01fe1	85 c9		 test	 ecx, ecx
  01fe3	74 27		 je	 SHORT $L87850

; 528  :     {
; 529  :             hash = hash * a + (*str++);

  01fe5	8b 55 f4	 mov	 edx, DWORD PTR _hash$[ebp]
  01fe8	0f af 55 fc	 imul	 edx, DWORD PTR _a$[ebp]
  01fec	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  01fef	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  01ff2	03 d1		 add	 edx, ecx
  01ff4	89 55 f4	 mov	 DWORD PTR _hash$[ebp], edx
  01ff7	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  01ffa	83 c2 01	 add	 edx, 1
  01ffd	89 55 08	 mov	 DWORD PTR _str$[ebp], edx

; 530  :             a *= b;

  02000	8b 45 fc	 mov	 eax, DWORD PTR _a$[ebp]
  02003	0f af 45 f8	 imul	 eax, DWORD PTR _b$[ebp]
  02007	89 45 fc	 mov	 DWORD PTR _a$[ebp], eax

; 531  :     }

  0200a	eb cf		 jmp	 SHORT $L87849
$L87850:

; 532  : 
; 533  :     return (hash & 0x7FFFFFFF);

  0200c	8b 45 f4	 mov	 eax, DWORD PTR _hash$[ebp]
  0200f	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH

; 534  : }

  02014	8b e5		 mov	 esp, ebp
  02016	5d		 pop	 ebp
  02017	c3		 ret	 0
?RSHash@@YAJPBD@Z ENDP					; RSHash
_TEXT	ENDS
PUBLIC	?IsVista@@YA_NXZ				; IsVista
;	COMDAT ?s_bGetVersion@?1??IsVista@@YA_NXZ@4_NA
_BSS	SEGMENT
?s_bGetVersion@?1??IsVista@@YA_NXZ@4_NA DB 01H DUP (?)	; `IsVista'::`2'::s_bGetVersion
_BSS	ENDS
;	COMDAT ?s_bIsVista@?1??IsVista@@YA_NXZ@4_NA
_BSS	SEGMENT
?s_bIsVista@?1??IsVista@@YA_NXZ@4_NA DB 01H DUP (?)	; `IsVista'::`2'::s_bIsVista
; Function compile flags: /Odt
_BSS	ENDS
_TEXT	SEGMENT
tv75 = -172						; size = 4
_osvi$ = -168						; size = 156
__$ArrayPad$ = -8					; size = 4
_bOsVersionInfoEx$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?IsVista@@YA_NXZ PROC NEAR				; IsVista

; 537  : {

  02020	55		 push	 ebp
  02021	8b ec		 mov	 ebp, esp
  02023	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  02029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0202e	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 538  : 	static bool s_bGetVersion	= false;
; 539  : 	static bool s_bIsVista		= false;
; 540  : 
; 541  : 	if( s_bGetVersion )

  02031	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?s_bGetVersion@?1??IsVista@@YA_NXZ@4_NA
  02038	85 c0		 test	 eax, eax
  0203a	74 0a		 je	 SHORT $L87857

; 542  : 	{
; 543  : 		return s_bIsVista;

  0203c	a0 00 00 00 00	 mov	 al, BYTE PTR ?s_bIsVista@?1??IsVista@@YA_NXZ@4_NA
  02041	e9 9a 00 00 00	 jmp	 $L87852
$L87857:

; 544  : 	}
; 545  : 
; 546  : 	OSVERSIONINFOEX osvi;
; 547  : 	BOOL bOsVersionInfoEx;
; 548  : 
; 549  : 	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

  02046	68 9c 00 00 00	 push	 156			; 0000009cH
  0204b	6a 00		 push	 0
  0204d	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _osvi$[ebp]
  02053	51		 push	 ecx
  02054	e8 00 00 00 00	 call	 _memset
  02059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 550  : 	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

  0205c	c7 85 58 ff ff
	ff 9c 00 00 00	 mov	 DWORD PTR _osvi$[ebp], 156 ; 0000009cH

; 551  : 
; 552  : 	if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )

  02066	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _osvi$[ebp]
  0206c	52		 push	 edx
  0206d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4
  02073	89 45 fc	 mov	 DWORD PTR _bOsVersionInfoEx$[ebp], eax
  02076	83 7d fc 00	 cmp	 DWORD PTR _bOsVersionInfoEx$[ebp], 0
  0207a	75 1f		 jne	 SHORT $L87863

; 553  : 	{
; 554  : 		osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

  0207c	c7 85 58 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _osvi$[ebp], 148 ; 00000094H

; 555  : 		if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) ) 

  02086	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _osvi$[ebp]
  0208c	50		 push	 eax
  0208d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4
  02093	85 c0		 test	 eax, eax
  02095	75 04		 jne	 SHORT $L87863

; 556  : 			return false;

  02097	32 c0		 xor	 al, al
  02099	eb 45		 jmp	 SHORT $L87852
$L87863:

; 557  : 	}
; 558  : 
; 559  : 	switch (osvi.dwPlatformId)

  0209b	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _osvi$[ebp+16]
  020a1	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], ecx
  020a7	83 bd 54 ff ff
	ff 02		 cmp	 DWORD PTR tv75[ebp], 2
  020ae	74 02		 je	 SHORT $L87871
  020b0	eb 1b		 jmp	 SHORT $L87874
$L87871:

; 560  : 	{	
; 561  : 
; 562  : 	case VER_PLATFORM_WIN32_NT:
; 563  : 
; 564  : 		if ( osvi.dwMajorVersion == 6  )

  020b2	83 bd 5c ff ff
	ff 06		 cmp	 DWORD PTR _osvi$[ebp+4], 6
  020b9	75 09		 jne	 SHORT $L87872

; 565  : 		{
; 566  : 			s_bIsVista = true;			

  020bb	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?s_bIsVista@?1??IsVista@@YA_NXZ@4_NA, 1

; 567  : 		}
; 568  : 		else

  020c2	eb 07		 jmp	 SHORT $L87873
$L87872:

; 569  : 		{
; 570  : 			s_bIsVista = false;

  020c4	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?s_bIsVista@?1??IsVista@@YA_NXZ@4_NA, 0
$L87873:

; 571  : 		}
; 572  : 		break;

  020cb	eb 07		 jmp	 SHORT $L87868
$L87874:

; 573  : 	default:
; 574  : 		s_bIsVista = false;

  020cd	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?s_bIsVista@?1??IsVista@@YA_NXZ@4_NA, 0
$L87868:

; 575  : 		break;
; 576  : 	}
; 577  : 		
; 578  : 	s_bGetVersion = true;

  020d4	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?s_bGetVersion@?1??IsVista@@YA_NXZ@4_NA, 1

; 579  : 
; 580  : 	return s_bIsVista;

  020db	a0 00 00 00 00	 mov	 al, BYTE PTR ?s_bIsVista@?1??IsVista@@YA_NXZ@4_NA
$L87852:

; 581  : }

  020e0	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  020e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  020e8	8b e5		 mov	 esp, ebp
  020ea	5d		 pop	 ebp
  020eb	c3		 ret	 0
?IsVista@@YA_NXZ ENDP					; IsVista
_TEXT	ENDS
PUBLIC	?ReplaceInvalidPlaylist@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@Z ; ReplaceInvalidPlaylist
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
EXTRN	__imp__wcschr:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
$T95043 = -36						; size = 4
$T95042 = -32						; size = 4
$T95041 = -28						; size = 4
$T95040 = -24						; size = 4
_idx$87884 = -20					; size = 4
_buffer$ = -16						; size = 4
_wszUtf8$ = -12						; size = 4
_len$ = -8						; size = 4
_dwNum$ = -4						; size = 4
_strSrc$ = 8						; size = 4
_strDes$ = 12						; size = 4
?ReplaceInvalidPlaylist@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@Z PROC NEAR ; ReplaceInvalidPlaylist

; 586  : {

  020f0	55		 push	 ebp
  020f1	8b ec		 mov	 ebp, esp
  020f3	83 ec 24	 sub	 esp, 36			; 00000024H

; 587  : 	int len=MultiByteToWideChar(CP_ACP, 0,strSrc.c_str(), -1, NULL,0);

  020f6	6a 00		 push	 0
  020f8	6a 00		 push	 0
  020fa	6a ff		 push	 -1
  020fc	8b 4d 08	 mov	 ecx, DWORD PTR _strSrc$[ebp]
  020ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  02105	50		 push	 eax
  02106	6a 00		 push	 0
  02108	6a 00		 push	 0
  0210a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  02110	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 588  : 	unsigned short * wszUtf8 = new unsigned short[len];

  02113	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  02116	d1 e0		 shl	 eax, 1
  02118	50		 push	 eax
  02119	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0211e	83 c4 04	 add	 esp, 4
  02121	89 45 e8	 mov	 DWORD PTR $T95040[ebp], eax
  02124	8b 4d e8	 mov	 ecx, DWORD PTR $T95040[ebp]
  02127	89 4d f4	 mov	 DWORD PTR _wszUtf8$[ebp], ecx

; 589  : 	memset(wszUtf8, 0, len * 2);

  0212a	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  0212d	d1 e2		 shl	 edx, 1
  0212f	52		 push	 edx
  02130	6a 00		 push	 0
  02132	8b 45 f4	 mov	 eax, DWORD PTR _wszUtf8$[ebp]
  02135	50		 push	 eax
  02136	e8 00 00 00 00	 call	 _memset
  0213b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 590  : 	MultiByteToWideChar(CP_ACP, 0, strSrc.c_str(), -1, (LPWSTR)wszUtf8, len);

  0213e	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  02141	51		 push	 ecx
  02142	8b 55 f4	 mov	 edx, DWORD PTR _wszUtf8$[ebp]
  02145	52		 push	 edx
  02146	6a ff		 push	 -1
  02148	8b 4d 08	 mov	 ecx, DWORD PTR _strSrc$[ebp]
  0214b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  02151	50		 push	 eax
  02152	6a 00		 push	 0
  02154	6a 00		 push	 0
  02156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 591  : 
; 592  : 	for( size_t idx = 0;idx < len-1;idx++ )

  0215c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _idx$87884[ebp], 0
  02163	eb 09		 jmp	 SHORT $L87885
$L87886:
  02165	8b 45 ec	 mov	 eax, DWORD PTR _idx$87884[ebp]
  02168	83 c0 01	 add	 eax, 1
  0216b	89 45 ec	 mov	 DWORD PTR _idx$87884[ebp], eax
$L87885:
  0216e	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  02171	83 e9 01	 sub	 ecx, 1
  02174	39 4d ec	 cmp	 DWORD PTR _idx$87884[ebp], ecx
  02177	73 2b		 jae	 SHORT $L87887

; 593  : 	{
; 594  : 		if( wcschr( s_WSTR_INVALID_FILENAME,wszUtf8[idx] ) != 0 )

  02179	8b 55 ec	 mov	 edx, DWORD PTR _idx$87884[ebp]
  0217c	8b 45 f4	 mov	 eax, DWORD PTR _wszUtf8$[ebp]
  0217f	66 8b 0c 50	 mov	 cx, WORD PTR [eax+edx*2]
  02183	51		 push	 ecx
  02184	68 00 00 00 00	 push	 OFFSET FLAT:$SG87889
  02189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcschr
  0218f	83 c4 08	 add	 esp, 8
  02192	85 c0		 test	 eax, eax
  02194	74 0c		 je	 SHORT $L87888

; 595  : 		{		
; 596  : 			wszUtf8[idx] = ' ';

  02196	8b 55 ec	 mov	 edx, DWORD PTR _idx$87884[ebp]
  02199	8b 45 f4	 mov	 eax, DWORD PTR _wszUtf8$[ebp]
  0219c	66 c7 04 50 20
	00		 mov	 WORD PTR [eax+edx*2], 32 ; 00000020H
$L87888:

; 597  : 		}
; 598  : 	}

  021a2	eb c1		 jmp	 SHORT $L87886
$L87887:

; 599  : 
; 600  : 	DWORD dwNum = WideCharToMultiByte(CP_ACP,NULL,(LPWSTR)wszUtf8,-1,NULL,0,NULL,FALSE);

  021a4	6a 00		 push	 0
  021a6	6a 00		 push	 0
  021a8	6a 00		 push	 0
  021aa	6a 00		 push	 0
  021ac	6a ff		 push	 -1
  021ae	8b 4d f4	 mov	 ecx, DWORD PTR _wszUtf8$[ebp]
  021b1	51		 push	 ecx
  021b2	6a 00		 push	 0
  021b4	6a 00		 push	 0
  021b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  021bc	89 45 fc	 mov	 DWORD PTR _dwNum$[ebp], eax

; 601  : 
; 602  : 	char *buffer = new char[ dwNum ];

  021bf	8b 55 fc	 mov	 edx, DWORD PTR _dwNum$[ebp]
  021c2	52		 push	 edx
  021c3	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  021c8	83 c4 04	 add	 esp, 4
  021cb	89 45 e4	 mov	 DWORD PTR $T95041[ebp], eax
  021ce	8b 45 e4	 mov	 eax, DWORD PTR $T95041[ebp]
  021d1	89 45 f0	 mov	 DWORD PTR _buffer$[ebp], eax

; 603  : 	memset(buffer, 0, dwNum);

  021d4	8b 4d fc	 mov	 ecx, DWORD PTR _dwNum$[ebp]
  021d7	51		 push	 ecx
  021d8	6a 00		 push	 0
  021da	8b 55 f0	 mov	 edx, DWORD PTR _buffer$[ebp]
  021dd	52		 push	 edx
  021de	e8 00 00 00 00	 call	 _memset
  021e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 604  : 	WideCharToMultiByte(CP_ACP,NULL,(LPWSTR)wszUtf8,-1,buffer,dwNum,NULL,NULL);

  021e6	6a 00		 push	 0
  021e8	6a 00		 push	 0
  021ea	8b 45 fc	 mov	 eax, DWORD PTR _dwNum$[ebp]
  021ed	50		 push	 eax
  021ee	8b 4d f0	 mov	 ecx, DWORD PTR _buffer$[ebp]
  021f1	51		 push	 ecx
  021f2	6a ff		 push	 -1
  021f4	8b 55 f4	 mov	 edx, DWORD PTR _wszUtf8$[ebp]
  021f7	52		 push	 edx
  021f8	6a 00		 push	 0
  021fa	6a 00		 push	 0
  021fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 605  : 
; 606  : 	strDes = buffer;

  02202	8b 45 f0	 mov	 eax, DWORD PTR _buffer$[ebp]
  02205	50		 push	 eax
  02206	8b 4d 0c	 mov	 ecx, DWORD PTR _strDes$[ebp]
  02209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 607  : 
; 608  : 	delete[] buffer;

  0220f	8b 4d f0	 mov	 ecx, DWORD PTR _buffer$[ebp]
  02212	89 4d e0	 mov	 DWORD PTR $T95042[ebp], ecx
  02215	8b 55 e0	 mov	 edx, DWORD PTR $T95042[ebp]
  02218	52		 push	 edx
  02219	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0221e	83 c4 04	 add	 esp, 4

; 609  : 	delete[] wszUtf8;

  02221	8b 45 f4	 mov	 eax, DWORD PTR _wszUtf8$[ebp]
  02224	89 45 dc	 mov	 DWORD PTR $T95043[ebp], eax
  02227	8b 4d dc	 mov	 ecx, DWORD PTR $T95043[ebp]
  0222a	51		 push	 ecx
  0222b	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  02230	83 c4 04	 add	 esp, 4

; 610  : }

  02233	8b e5		 mov	 esp, ebp
  02235	5d		 pop	 ebp
  02236	c3		 ret	 0
?ReplaceInvalidPlaylist@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@Z ENDP ; ReplaceInvalidPlaylist
_TEXT	ENDS
PUBLIC	?ShowNoActiveTopWindow@@YAXPAUHWND__@@@Z	; ShowNoActiveTopWindow
EXTRN	__imp__SetWindowPos@28:NEAR
EXTRN	__imp__GetWindowRect@8:NEAR
EXTRN	__imp__GetSystemMetrics@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_nFullWidth$ = -28					; size = 4
_rect$ = -24						; size = 16
_hwndact$ = -8						; size = 4
_nFullHeight$ = -4					; size = 4
_hWnd$ = 8						; size = 4
?ShowNoActiveTopWindow@@YAXPAUHWND__@@@Z PROC NEAR	; ShowNoActiveTopWindow

; 613  : {

  02240	55		 push	 ebp
  02241	8b ec		 mov	 ebp, esp
  02243	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 614  : 	RECT rect;
; 615  : 	HWND hwndact;
; 616  : 
; 617  : 	int nFullWidth  = GetSystemMetrics(SM_CXSCREEN);

  02246	6a 00		 push	 0
  02248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  0224e	89 45 e4	 mov	 DWORD PTR _nFullWidth$[ebp], eax

; 618  : 	int nFullHeight = GetSystemMetrics(SM_CYSCREEN);

  02251	6a 01		 push	 1
  02253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  02259	89 45 fc	 mov	 DWORD PTR _nFullHeight$[ebp], eax

; 619  : 	hwndact = ::GetForegroundWindow();

  0225c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetForegroundWindow@0
  02262	89 45 f8	 mov	 DWORD PTR _hwndact$[ebp], eax

; 620  : 	if(hwndact == NULL)

  02265	83 7d f8 00	 cmp	 DWORD PTR _hwndact$[ebp], 0
  02269	75 0e		 jne	 SHORT $L87905

; 621  : 	{
; 622  : 		ShowWindow(hWnd, SW_SHOWNOACTIVATE);

  0226b	6a 04		 push	 4
  0226d	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  02270	50		 push	 eax
  02271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 623  : 		return;

  02277	eb 74		 jmp	 SHORT $L87900
$L87905:

; 624  : 	}
; 625  : 
; 626  : 	::GetWindowRect(hwndact, &rect);

  02279	8d 4d e8	 lea	 ecx, DWORD PTR _rect$[ebp]
  0227c	51		 push	 ecx
  0227d	8b 55 f8	 mov	 edx, DWORD PTR _hwndact$[ebp]
  02280	52		 push	 edx
  02281	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 627  : 	if(hWnd == NULL)

  02287	83 7d 08 00	 cmp	 DWORD PTR _hWnd$[ebp], 0
  0228b	75 02		 jne	 SHORT $L87906

; 628  : 		return;

  0228d	eb 5e		 jmp	 SHORT $L87900
$L87906:

; 629  : 
; 630  : 	if(nFullWidth ==  rect.right - rect.left && nFullHeight == rect.bottom - rect.top)

  0228f	8b 45 f0	 mov	 eax, DWORD PTR _rect$[ebp+8]
  02292	2b 45 e8	 sub	 eax, DWORD PTR _rect$[ebp]
  02295	39 45 e4	 cmp	 DWORD PTR _nFullWidth$[ebp], eax
  02298	75 31		 jne	 SHORT $L87907
  0229a	8b 4d f4	 mov	 ecx, DWORD PTR _rect$[ebp+12]
  0229d	2b 4d ec	 sub	 ecx, DWORD PTR _rect$[ebp+4]
  022a0	39 4d fc	 cmp	 DWORD PTR _nFullHeight$[ebp], ecx
  022a3	75 26		 jne	 SHORT $L87907

; 631  : 	{
; 632  : 		::SetWindowPos(hWnd, hwndact, 0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);

  022a5	6a 13		 push	 19			; 00000013H
  022a7	6a 00		 push	 0
  022a9	6a 00		 push	 0
  022ab	6a 00		 push	 0
  022ad	6a 00		 push	 0
  022af	8b 55 f8	 mov	 edx, DWORD PTR _hwndact$[ebp]
  022b2	52		 push	 edx
  022b3	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  022b6	50		 push	 eax
  022b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 633  : 		ShowWindow(hWnd,SW_SHOWNOACTIVATE);

  022bd	6a 04		 push	 4
  022bf	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  022c2	51		 push	 ecx
  022c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 634  : 	}else{

  022c9	eb 22		 jmp	 SHORT $L87900
$L87907:

; 635  : 		::SetWindowPos(hWnd, HWND_TOPMOST, 0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);

  022cb	6a 13		 push	 19			; 00000013H
  022cd	6a 00		 push	 0
  022cf	6a 00		 push	 0
  022d1	6a 00		 push	 0
  022d3	6a 00		 push	 0
  022d5	6a ff		 push	 -1
  022d7	8b 55 08	 mov	 edx, DWORD PTR _hWnd$[ebp]
  022da	52		 push	 edx
  022db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 636  : 		ShowWindow(hWnd, SW_SHOWNOACTIVATE);

  022e1	6a 04		 push	 4
  022e3	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  022e6	50		 push	 eax
  022e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$L87900:

; 637  : 	}
; 638  : }

  022ed	8b e5		 mov	 esp, ebp
  022ef	5d		 pop	 ebp
  022f0	c3		 ret	 0
?ShowNoActiveTopWindow@@YAXPAUHWND__@@@Z ENDP		; ShowNoActiveTopWindow
_TEXT	ENDS
PUBLIC	?GetDisksProperty@@YAHPAXPAU_STORAGE_DEVICE_DESCRIPTOR@@@Z ; GetDisksProperty
EXTRN	__imp__DeviceIoControl@32:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_bResult$ = -24						; size = 4
_Query$ = -20						; size = 12
__$ArrayPad$ = -8					; size = 4
_dwOutBytes$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_hDevice$ = 8						; size = 4
_pDevDesc$ = 12						; size = 4
?GetDisksProperty@@YAHPAXPAU_STORAGE_DEVICE_DESCRIPTOR@@@Z PROC NEAR ; GetDisksProperty

; 648  : {

  02300	55		 push	 ebp
  02301	8b ec		 mov	 ebp, esp
  02303	83 ec 18	 sub	 esp, 24			; 00000018H
  02306	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0230b	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 649  : 	STORAGE_PROPERTY_QUERY	Query;	// input param for query
; 650  : 	DWORD dwOutBytes;				// IOCTL output length
; 651  : 	BOOL bResult;					// IOCTL return val
; 652  : 
; 653  : 	// specify the query type
; 654  : 	Query.PropertyId = StorageDeviceProperty;

  0230e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _Query$[ebp], 0

; 655  : 	Query.QueryType = PropertyStandardQuery;

  02315	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Query$[ebp+4], 0

; 656  : 
; 657  : 	// Query using IOCTL_STORAGE_QUERY_PROPERTY 
; 658  : 	bResult = ::DeviceIoControl(hDevice,			// device handle
; 659  : 			IOCTL_STORAGE_QUERY_PROPERTY,			// info of device property
; 660  : 			&Query, sizeof(STORAGE_PROPERTY_QUERY),	// input data buffer
; 661  : 			pDevDesc, pDevDesc->Size,				// output data buffer
; 662  : 			&dwOutBytes,							// out's length
; 663  : 			(LPOVERLAPPED)NULL);					

  0231c	6a 00		 push	 0
  0231e	8d 45 fc	 lea	 eax, DWORD PTR _dwOutBytes$[ebp]
  02321	50		 push	 eax
  02322	8b 4d 0c	 mov	 ecx, DWORD PTR _pDevDesc$[ebp]
  02325	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02328	52		 push	 edx
  02329	8b 45 0c	 mov	 eax, DWORD PTR _pDevDesc$[ebp]
  0232c	50		 push	 eax
  0232d	6a 0c		 push	 12			; 0000000cH
  0232f	8d 4d ec	 lea	 ecx, DWORD PTR _Query$[ebp]
  02332	51		 push	 ecx
  02333	68 00 14 2d 00	 push	 2954240			; 002d1400H
  02338	8b 55 08	 mov	 edx, DWORD PTR _hDevice$[ebp]
  0233b	52		 push	 edx
  0233c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  02342	89 45 e8	 mov	 DWORD PTR _bResult$[ebp], eax

; 664  : 
; 665  : 	return bResult;

  02345	8b 45 e8	 mov	 eax, DWORD PTR _bResult$[ebp]

; 666  : }

  02348	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0234b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02350	8b e5		 mov	 esp, ebp
  02352	5d		 pop	 ebp
  02353	c3		 ret	 0
?GetDisksProperty@@YAHPAXPAU_STORAGE_DEVICE_DESCRIPTOR@@@Z ENDP ; GetDisksProperty
_TEXT	ENDS
PUBLIC	?chFirstDriveFromMask@@YADK@Z			; chFirstDriveFromMask
; Function compile flags: /Odt
_TEXT	SEGMENT
_i$ = -1						; size = 1
_unitmask$ = 8						; size = 4
?chFirstDriveFromMask@@YADK@Z PROC NEAR			; chFirstDriveFromMask

; 676  : {

  02360	55		 push	 ebp
  02361	8b ec		 mov	 ebp, esp
  02363	51		 push	 ecx

; 677  : 
; 678  :       char i;
; 679  :       for (i = 0; i < 26; ++i)  

  02364	c6 45 ff 00	 mov	 BYTE PTR _i$[ebp], 0
  02368	eb 08		 jmp	 SHORT $L87923
$L87924:
  0236a	8a 45 ff	 mov	 al, BYTE PTR _i$[ebp]
  0236d	04 01		 add	 al, 1
  0236f	88 45 ff	 mov	 BYTE PTR _i$[ebp], al
$L87923:
  02372	0f be 4d ff	 movsx	 ecx, BYTE PTR _i$[ebp]
  02376	83 f9 1a	 cmp	 ecx, 26			; 0000001aH
  02379	7d 14		 jge	 SHORT $L87925

; 680  :       {
; 681  :            if (unitmask & 0x1) 

  0237b	8b 55 08	 mov	 edx, DWORD PTR _unitmask$[ebp]
  0237e	83 e2 01	 and	 edx, 1
  02381	74 02		 je	 SHORT $L87926

; 682  : 				break;

  02383	eb 0a		 jmp	 SHORT $L87925
$L87926:

; 683  :             unitmask = unitmask >> 1;

  02385	8b 45 08	 mov	 eax, DWORD PTR _unitmask$[ebp]
  02388	d1 e8		 shr	 eax, 1
  0238a	89 45 08	 mov	 DWORD PTR _unitmask$[ebp], eax

; 684  :       }

  0238d	eb db		 jmp	 SHORT $L87924
$L87925:

; 685  :     return (i + 'A');

  0238f	0f be 45 ff	 movsx	 eax, BYTE PTR _i$[ebp]
  02393	83 c0 41	 add	 eax, 65			; 00000041H

; 686  : }

  02396	8b e5		 mov	 esp, ebp
  02398	5d		 pop	 ebp
  02399	c3		 ret	 0
?chFirstDriveFromMask@@YADK@Z ENDP			; chFirstDriveFromMask
_TEXT	ENDS
PUBLIC	?ReInitUSB_Disk_Letter@@YAXPAD@Z		; ReInitUSB_Disk_Letter
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__imp__sprintf:NEAR
EXTRN	__imp__GetLogicalDrives@0:NEAR
EXTRN	__imp__GetDriveTypeA@4:NEAR
EXTRN	__imp__CreateFileA@28:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv80 = -392						; size = 4
$T95052 = -388						; size = 4
$T95051 = -384						; size = 4
_temp$87946 = -380					; size = 4
_MaxDriveSet$ = -376					; size = 4
_pDevDesc$ = -372					; size = 4
_k$ = -368						; size = 4
_drive$ = -364						; size = 4
_CurDriveSet$ = -360					; size = 4
_drivetype$ = -356					; size = 4
_szBuf$ = -352						; size = 300
_szDrvName$ = -44					; size = 33
__$ArrayPad$ = -8					; size = 4
_hDevice$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
_szMoveDiskName$ = 8					; size = 4
?ReInitUSB_Disk_Letter@@YAXPAD@Z PROC NEAR		; ReInitUSB_Disk_Letter

; 696  : {

  023a0	55		 push	 ebp
  023a1	8b ec		 mov	 ebp, esp
  023a3	81 ec 88 01 00
	00		 sub	 esp, 392		; 00000188H
  023a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  023ae	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 697  : 	int k = 0;

  023b1	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$[ebp], 0

; 698  : 	DWORD			MaxDriveSet, CurDriveSet;
; 699  : 	DWORD			drive, drivetype;
; 700  : 	TCHAR			szBuf[300];
; 701  : 	HANDLE			hDevice;
; 702  : 	PSTORAGE_DEVICE_DESCRIPTOR pDevDesc;
; 703  : 
; 704  : 	for(k=0; k<26; k++)

  023bb	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$[ebp], 0
  023c5	eb 0f		 jmp	 SHORT $L87938
$L87939:
  023c7	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _k$[ebp]
  023cd	83 c0 01	 add	 eax, 1
  023d0	89 85 90 fe ff
	ff		 mov	 DWORD PTR _k$[ebp], eax
$L87938:
  023d6	83 bd 90 fe ff
	ff 1a		 cmp	 DWORD PTR _k$[ebp], 26	; 0000001aH
  023dd	7d 0e		 jge	 SHORT $L87940

; 705  : 		szMoveDiskName[k] = '\0';	

  023df	8b 4d 08	 mov	 ecx, DWORD PTR _szMoveDiskName$[ebp]
  023e2	03 8d 90 fe ff
	ff		 add	 ecx, DWORD PTR _k$[ebp]
  023e8	c6 01 00	 mov	 BYTE PTR [ecx], 0
  023eb	eb da		 jmp	 SHORT $L87939
$L87940:

; 706  : 	k = 0;		

  023ed	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$[ebp], 0

; 707  : 	// Get available drives we can monitor
; 708  : 	MaxDriveSet = CurDriveSet = 0;

  023f7	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _CurDriveSet$[ebp], 0
  02401	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _CurDriveSet$[ebp]
  02407	89 95 88 fe ff
	ff		 mov	 DWORD PTR _MaxDriveSet$[ebp], edx

; 709  : 
; 710  : 	MaxDriveSet = GetLogicalDrives();

  0240d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLogicalDrives@0
  02413	89 85 88 fe ff
	ff		 mov	 DWORD PTR _MaxDriveSet$[ebp], eax

; 711  : 	CurDriveSet = MaxDriveSet;

  02419	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _MaxDriveSet$[ebp]
  0241f	89 85 98 fe ff
	ff		 mov	 DWORD PTR _CurDriveSet$[ebp], eax

; 712  : 	char szDrvName[33];
; 713  : 	for ( drive = 0; drive < 32; ++drive )  

  02425	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _drive$[ebp], 0
  0242f	eb 0f		 jmp	 SHORT $L87942
$L87943:
  02431	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _drive$[ebp]
  02437	83 c1 01	 add	 ecx, 1
  0243a	89 8d 94 fe ff
	ff		 mov	 DWORD PTR _drive$[ebp], ecx
$L87942:
  02440	83 bd 94 fe ff
	ff 20		 cmp	 DWORD PTR _drive$[ebp], 32 ; 00000020H
  02447	0f 83 ee 01 00
	00		 jae	 $L87929

; 714  : 	{
; 715  : 		if ( MaxDriveSet & (1 << drive) )  

  0244d	ba 01 00 00 00	 mov	 edx, 1
  02452	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _drive$[ebp]
  02458	d3 e2		 shl	 edx, cl
  0245a	23 95 88 fe ff
	ff		 and	 edx, DWORD PTR _MaxDriveSet$[ebp]
  02460	0f 84 d0 01 00
	00		 je	 $L87945

; 716  : 		{
; 717  : 			DWORD temp = 1<<drive;

  02466	b8 01 00 00 00	 mov	 eax, 1
  0246b	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _drive$[ebp]
  02471	d3 e0		 shl	 eax, cl
  02473	89 85 84 fe ff
	ff		 mov	 DWORD PTR _temp$87946[ebp], eax

; 718  : 			_stprintf( szDrvName, _T("%c:\\"), 'A'+drive );

  02479	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _drive$[ebp]
  0247f	83 c1 41	 add	 ecx, 65			; 00000041H
  02482	51		 push	 ecx
  02483	68 00 00 00 00	 push	 OFFSET FLAT:$SG87947
  02488	8d 55 d4	 lea	 edx, DWORD PTR _szDrvName$[ebp]
  0248b	52		 push	 edx
  0248c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  02492	83 c4 0c	 add	 esp, 12			; 0000000cH

; 719  : 			switch ( GetDriveType( szDrvName ) )  

  02495	8d 45 d4	 lea	 eax, DWORD PTR _szDrvName$[ebp]
  02498	50		 push	 eax
  02499	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDriveTypeA@4
  0249f	89 85 78 fe ff
	ff		 mov	 DWORD PTR tv80[ebp], eax
  024a5	83 bd 78 fe ff
	ff 06		 cmp	 DWORD PTR tv80[ebp], 6
  024ac	0f 87 84 01 00
	00		 ja	 $L87945
  024b2	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR tv80[ebp]
  024b8	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L95054[ecx*4]
$L87952:

; 720  : 			{
; 721  : 				case 0:					// The drive type cannot be determined.
; 722  : 				case 1:					// The root directory does not exist.
; 723  : 					drivetype = DRVUNKNOWN;

  024bf	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _drivetype$[ebp], 0

; 724  : 					break;

  024c9	e9 68 01 00 00	 jmp	 $L87945
$L87953:

; 725  : 				case DRIVE_REMOVABLE:	// The drive can be removed from the drive.
; 726  : 					drivetype = DRVREMOVE;

  024ce	c7 85 9c fe ff
	ff 05 00 00 00	 mov	 DWORD PTR _drivetype$[ebp], 5

; 727  : 					szMoveDiskName[k] = chFirstDriveFromMask(temp);

  024d8	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR _temp$87946[ebp]
  024de	52		 push	 edx
  024df	e8 00 00 00 00	 call	 ?chFirstDriveFromMask@@YADK@Z ; chFirstDriveFromMask
  024e4	83 c4 04	 add	 esp, 4
  024e7	8b 4d 08	 mov	 ecx, DWORD PTR _szMoveDiskName$[ebp]
  024ea	03 8d 90 fe ff
	ff		 add	 ecx, DWORD PTR _k$[ebp]
  024f0	88 01		 mov	 BYTE PTR [ecx], al

; 728  : 					k++;

  024f2	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _k$[ebp]
  024f8	83 c2 01	 add	 edx, 1
  024fb	89 95 90 fe ff
	ff		 mov	 DWORD PTR _k$[ebp], edx

; 729  : 					break;

  02501	e9 30 01 00 00	 jmp	 $L87945
$L87955:

; 730  : 				case DRIVE_CDROM:		// The drive is a CD-ROM drive.
; 731  : 					break;
; 732  : 				case DRIVE_FIXED:		// The disk cannot be removed from the drive.
; 733  : 					drivetype = DRVFIXED;

  02506	c7 85 9c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _drivetype$[ebp], 1

; 734  : 					sprintf(szBuf, "\\\\?\\%c:", 'A'+drive);

  02510	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _drive$[ebp]
  02516	83 c0 41	 add	 eax, 65			; 00000041H
  02519	50		 push	 eax
  0251a	68 00 00 00 00	 push	 OFFSET FLAT:$SG87956
  0251f	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR _szBuf$[ebp]
  02525	51		 push	 ecx
  02526	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  0252c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 735  : 					hDevice = CreateFile(szBuf, GENERIC_READ,
; 736  : 							FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);

  0252f	6a 00		 push	 0
  02531	6a 00		 push	 0
  02533	6a 03		 push	 3
  02535	6a 00		 push	 0
  02537	6a 03		 push	 3
  02539	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0253e	8d 95 a0 fe ff
	ff		 lea	 edx, DWORD PTR _szBuf$[ebp]
  02544	52		 push	 edx
  02545	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  0254b	89 45 fc	 mov	 DWORD PTR _hDevice$[ebp], eax

; 737  : 
; 738  : 					if (hDevice != INVALID_HANDLE_VALUE)

  0254e	83 7d fc ff	 cmp	 DWORD PTR _hDevice$[ebp], -1
  02552	0f 84 9d 00 00
	00		 je	 $L87959

; 739  : 					{
; 740  : 
; 741  : 						pDevDesc = (PSTORAGE_DEVICE_DESCRIPTOR)new BYTE[sizeof(STORAGE_DEVICE_DESCRIPTOR) + 512 - 1];

  02558	68 27 02 00 00	 push	 551			; 00000227H
  0255d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  02562	83 c4 04	 add	 esp, 4
  02565	89 85 80 fe ff
	ff		 mov	 DWORD PTR $T95051[ebp], eax
  0256b	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR $T95051[ebp]
  02571	89 85 8c fe ff
	ff		 mov	 DWORD PTR _pDevDesc$[ebp], eax

; 742  : 
; 743  : 						pDevDesc->Size = sizeof(STORAGE_DEVICE_DESCRIPTOR) + 512 - 1;

  02577	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR _pDevDesc$[ebp]
  0257d	c7 41 04 27 02
	00 00		 mov	 DWORD PTR [ecx+4], 551	; 00000227H

; 744  : 
; 745  : 						if(GetDisksProperty(hDevice, pDevDesc))

  02584	8b 95 8c fe ff
	ff		 mov	 edx, DWORD PTR _pDevDesc$[ebp]
  0258a	52		 push	 edx
  0258b	8b 45 fc	 mov	 eax, DWORD PTR _hDevice$[ebp]
  0258e	50		 push	 eax
  0258f	e8 00 00 00 00	 call	 ?GetDisksProperty@@YAHPAXPAU_STORAGE_DEVICE_DESCRIPTOR@@@Z ; GetDisksProperty
  02594	83 c4 08	 add	 esp, 8
  02597	85 c0		 test	 eax, eax
  02599	74 35		 je	 SHORT $L87965

; 746  : 						{
; 747  : 							if(pDevDesc->BusType == CP_BusTypeUsb)

  0259b	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR _pDevDesc$[ebp]
  025a1	83 79 1c 07	 cmp	 DWORD PTR [ecx+28], 7
  025a5	75 29		 jne	 SHORT $L87965

; 748  : 							{
; 749  : 								szMoveDiskName[k] = chFirstDriveFromMask(temp);

  025a7	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR _temp$87946[ebp]
  025ad	52		 push	 edx
  025ae	e8 00 00 00 00	 call	 ?chFirstDriveFromMask@@YADK@Z ; chFirstDriveFromMask
  025b3	83 c4 04	 add	 esp, 4
  025b6	8b 4d 08	 mov	 ecx, DWORD PTR _szMoveDiskName$[ebp]
  025b9	03 8d 90 fe ff
	ff		 add	 ecx, DWORD PTR _k$[ebp]
  025bf	88 01		 mov	 BYTE PTR [ecx], al

; 750  : 								k++;

  025c1	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _k$[ebp]
  025c7	83 c2 01	 add	 edx, 1
  025ca	89 95 90 fe ff
	ff		 mov	 DWORD PTR _k$[ebp], edx
$L87965:

; 751  : 							}
; 752  : 						}
; 753  : 
; 754  : 						delete pDevDesc;

  025d0	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _pDevDesc$[ebp]
  025d6	89 85 7c fe ff
	ff		 mov	 DWORD PTR $T95052[ebp], eax
  025dc	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR $T95052[ebp]
  025e2	51		 push	 ecx
  025e3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  025e8	83 c4 04	 add	 esp, 4

; 755  : 						CloseHandle(hDevice);

  025eb	8b 55 fc	 mov	 edx, DWORD PTR _hDevice$[ebp]
  025ee	52		 push	 edx
  025ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$L87959:

; 756  : 					}
; 757  : 					
; 758  : 					break;

  025f5	eb 3f		 jmp	 SHORT $L87945
$L87968:

; 759  : 				case DRIVE_REMOTE:		// The drive is a remote (network) drive.
; 760  : 					drivetype = DRVREMOTE;

  025f7	c7 85 9c fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _drivetype$[ebp], 2

; 761  : 					szMoveDiskName[k] = chFirstDriveFromMask(temp);

  02601	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _temp$87946[ebp]
  02607	50		 push	 eax
  02608	e8 00 00 00 00	 call	 ?chFirstDriveFromMask@@YADK@Z ; chFirstDriveFromMask
  0260d	83 c4 04	 add	 esp, 4
  02610	8b 4d 08	 mov	 ecx, DWORD PTR _szMoveDiskName$[ebp]
  02613	03 8d 90 fe ff
	ff		 add	 ecx, DWORD PTR _k$[ebp]
  02619	88 01		 mov	 BYTE PTR [ecx], al

; 762  : 					k++;

  0261b	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _k$[ebp]
  02621	83 c2 01	 add	 edx, 1
  02624	89 95 90 fe ff
	ff		 mov	 DWORD PTR _k$[ebp], edx

; 763  : 					break;

  0262a	eb 0a		 jmp	 SHORT $L87945
$L87969:

; 764  : 				case DRIVE_RAMDISK:		// The drive is a RAM disk.
; 765  : 					drivetype = DRVRAM;

  0262c	c7 85 9c fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _drivetype$[ebp], 3
$L87945:

; 766  : 					break;
; 767  : 			}
; 768  : 		}
; 769  : 	}

  02636	e9 f6 fd ff ff	 jmp	 $L87943
$L87929:

; 770  : }

  0263b	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0263e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02643	8b e5		 mov	 esp, ebp
  02645	5d		 pop	 ebp
  02646	c3		 ret	 0
$L95054:
  02647	00 00 00 00	 DD	 $L87952
  0264b	00 00 00 00	 DD	 $L87952
  0264f	00 00 00 00	 DD	 $L87953
  02653	00 00 00 00	 DD	 $L87955
  02657	00 00 00 00	 DD	 $L87968
  0265b	00 00 00 00	 DD	 $L87945
  0265f	00 00 00 00	 DD	 $L87969
?ReInitUSB_Disk_Letter@@YAXPAD@Z ENDP			; ReInitUSB_Disk_Letter
_TEXT	ENDS
PUBLIC	?LoadAnImage@@YAPAUHBITMAP__@@PBD@Z		; LoadAnImage
EXTRN	__imp__GlobalAlloc@8:NEAR
EXTRN	__imp__GlobalFree@4:NEAR
EXTRN	__imp__OleLoadPicture@20:NEAR
EXTRN	__imp__ftell:NEAR
EXTRN	_IID_IPicture:BYTE
EXTRN	__imp__CopyImage@20:NEAR
EXTRN	__imp__CreateStreamOnHGlobal@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_fs$ = -32						; size = 4
_hG$ = -28						; size = 4
_hB$ = -24						; size = 4
_hBB$ = -20						; size = 4
_s$ = -16						; size = 4
_pp$ = -12						; size = 4
_fp$ = -8						; size = 4
_p$ = -4						; size = 4
_FileName$ = 8						; size = 4
?LoadAnImage@@YAPAUHBITMAP__@@PBD@Z PROC NEAR		; LoadAnImage

; 775  : {

  02670	55		 push	 ebp
  02671	8b ec		 mov	 ebp, esp
  02673	83 ec 20	 sub	 esp, 32			; 00000020H

; 776  : 	// Use IPicture stuff to use JPG / GIF files
; 777  : 	IPicture* p;
; 778  : 	IStream* s;
; 779  : 	HGLOBAL hG;
; 780  : 	void* pp;
; 781  : 	FILE* fp;
; 782  : 
; 783  : 	// Read file into memory
; 784  : 	fp = fopen(FileName, "rb");

  02676	68 00 00 00 00	 push	 OFFSET FLAT:$SG87978
  0267b	8b 45 08	 mov	 eax, DWORD PTR _FileName$[ebp]
  0267e	50		 push	 eax
  0267f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  02685	83 c4 08	 add	 esp, 8
  02688	89 45 f8	 mov	 DWORD PTR _fp$[ebp], eax

; 785  : 	if (!fp)

  0268b	83 7d f8 00	 cmp	 DWORD PTR _fp$[ebp], 0
  0268f	75 07		 jne	 SHORT $L87979

; 786  : 	{
; 787  : 		return NULL;

  02691	33 c0		 xor	 eax, eax
  02693	e9 34 01 00 00	 jmp	 $L87972
$L87979:

; 788  : 	}
; 789  : 
; 790  : 	fseek(fp,0,SEEK_END);

  02698	6a 02		 push	 2
  0269a	6a 00		 push	 0
  0269c	8b 4d f8	 mov	 ecx, DWORD PTR _fp$[ebp]
  0269f	51		 push	 ecx
  026a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  026a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 791  : 	int fs = ftell(fp);

  026a9	8b 55 f8	 mov	 edx, DWORD PTR _fp$[ebp]
  026ac	52		 push	 edx
  026ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  026b3	83 c4 04	 add	 esp, 4
  026b6	89 45 e0	 mov	 DWORD PTR _fs$[ebp], eax

; 792  : 	fseek(fp,0,SEEK_SET);

  026b9	6a 00		 push	 0
  026bb	6a 00		 push	 0
  026bd	8b 45 f8	 mov	 eax, DWORD PTR _fp$[ebp]
  026c0	50		 push	 eax
  026c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  026c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 793  : 	hG = GlobalAlloc(GPTR,fs);

  026ca	8b 4d e0	 mov	 ecx, DWORD PTR _fs$[ebp]
  026cd	51		 push	 ecx
  026ce	6a 40		 push	 64			; 00000040H
  026d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  026d6	89 45 e4	 mov	 DWORD PTR _hG$[ebp], eax

; 794  : 	if(!hG)

  026d9	83 7d e4 00	 cmp	 DWORD PTR _hG$[ebp], 0
  026dd	75 14		 jne	 SHORT $L87981

; 795  : 	{
; 796  : 		fclose(fp);

  026df	8b 55 f8	 mov	 edx, DWORD PTR _fp$[ebp]
  026e2	52		 push	 edx
  026e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  026e9	83 c4 04	 add	 esp, 4

; 797  : 		return NULL;

  026ec	33 c0		 xor	 eax, eax
  026ee	e9 d9 00 00 00	 jmp	 $L87972
$L87981:

; 798  : 	}
; 799  : 	pp = (void*)hG;

  026f3	8b 45 e4	 mov	 eax, DWORD PTR _hG$[ebp]
  026f6	89 45 f4	 mov	 DWORD PTR _pp$[ebp], eax

; 800  : 	fread(pp,1,fs,fp);

  026f9	8b 4d f8	 mov	 ecx, DWORD PTR _fp$[ebp]
  026fc	51		 push	 ecx
  026fd	8b 55 e0	 mov	 edx, DWORD PTR _fs$[ebp]
  02700	52		 push	 edx
  02701	6a 01		 push	 1
  02703	8b 45 f4	 mov	 eax, DWORD PTR _pp$[ebp]
  02706	50		 push	 eax
  02707	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0270d	83 c4 10	 add	 esp, 16			; 00000010H

; 801  : 	fclose(fp);

  02710	8b 4d f8	 mov	 ecx, DWORD PTR _fp$[ebp]
  02713	51		 push	 ecx
  02714	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0271a	83 c4 04	 add	 esp, 4

; 802  : 
; 803  : 	// Create an IStream so IPicture can
; 804  : 	CreateStreamOnHGlobal(hG, false, &s);

  0271d	8d 55 f0	 lea	 edx, DWORD PTR _s$[ebp]
  02720	52		 push	 edx
  02721	6a 00		 push	 0
  02723	8b 45 e4	 mov	 eax, DWORD PTR _hG$[ebp]
  02726	50		 push	 eax
  02727	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateStreamOnHGlobal@12

; 805  : 	if(!s)

  0272d	83 7d f0 00	 cmp	 DWORD PTR _s$[ebp], 0
  02731	75 11		 jne	 SHORT $L87983

; 806  : 	{
; 807  : 		GlobalFree(hG);

  02733	8b 4d e4	 mov	 ecx, DWORD PTR _hG$[ebp]
  02736	51		 push	 ecx
  02737	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 808  : 		return NULL;

  0273d	33 c0		 xor	 eax, eax
  0273f	e9 88 00 00 00	 jmp	 $L87972
$L87983:

; 809  : 	}
; 810  : 
; 811  : 	OleLoadPicture(s,0,false,IID_IPicture,(void**)&p);

  02744	8d 55 fc	 lea	 edx, DWORD PTR _p$[ebp]
  02747	52		 push	 edx
  02748	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPicture
  0274d	6a 00		 push	 0
  0274f	6a 00		 push	 0
  02751	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  02754	50		 push	 eax
  02755	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleLoadPicture@20

; 812  : 
; 813  : 	if(!p)

  0275b	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0275f	75 1a		 jne	 SHORT $L87985

; 814  : 	{
; 815  : 		s->Release();

  02761	8b 4d f0	 mov	 ecx, DWORD PTR _s$[ebp]
  02764	8b 11		 mov	 edx, DWORD PTR [ecx]
  02766	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  02769	50		 push	 eax
  0276a	ff 52 08	 call	 DWORD PTR [edx+8]

; 816  : 		GlobalFree(hG);

  0276d	8b 4d e4	 mov	 ecx, DWORD PTR _hG$[ebp]
  02770	51		 push	 ecx
  02771	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 817  : 		return NULL;

  02777	33 c0		 xor	 eax, eax
  02779	eb 51		 jmp	 SHORT $L87972
$L87985:

; 818  : 	}
; 819  : 	s->Release();

  0277b	8b 55 f0	 mov	 edx, DWORD PTR _s$[ebp]
  0277e	8b 02		 mov	 eax, DWORD PTR [edx]
  02780	8b 4d f0	 mov	 ecx, DWORD PTR _s$[ebp]
  02783	51		 push	 ecx
  02784	ff 50 08	 call	 DWORD PTR [eax+8]

; 820  : 	GlobalFree(hG);

  02787	8b 55 e4	 mov	 edx, DWORD PTR _hG$[ebp]
  0278a	52		 push	 edx
  0278b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 821  : 
; 822  : 	HBITMAP hB = 0;

  02791	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hB$[ebp], 0

; 823  : 	p->get_Handle((unsigned int*)&hB);

  02798	8d 45 e8	 lea	 eax, DWORD PTR _hB$[ebp]
  0279b	50		 push	 eax
  0279c	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0279f	8b 11		 mov	 edx, DWORD PTR [ecx]
  027a1	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  027a4	50		 push	 eax
  027a5	ff 52 0c	 call	 DWORD PTR [edx+12]

; 824  : 
; 825  : 	// Copy the image. Necessary, because upon p's release,
; 826  : 	// the handle is destroyed.
; 827  : 	HBITMAP hBB = (HBITMAP)CopyImage(hB, IMAGE_BITMAP, 0, 0, LR_COPYRETURNORG);

  027a8	6a 04		 push	 4
  027aa	6a 00		 push	 0
  027ac	6a 00		 push	 0
  027ae	6a 00		 push	 0
  027b0	8b 4d e8	 mov	 ecx, DWORD PTR _hB$[ebp]
  027b3	51		 push	 ecx
  027b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyImage@20
  027ba	89 45 ec	 mov	 DWORD PTR _hBB$[ebp], eax

; 828  : 
; 829  : 	p->Release();

  027bd	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  027c0	8b 02		 mov	 eax, DWORD PTR [edx]
  027c2	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  027c5	51		 push	 ecx
  027c6	ff 50 08	 call	 DWORD PTR [eax+8]

; 830  : 	return hBB;

  027c9	8b 45 ec	 mov	 eax, DWORD PTR _hBB$[ebp]
$L87972:

; 831  : }

  027cc	8b e5		 mov	 esp, ebp
  027ce	5d		 pop	 ebp
  027cf	c3		 ret	 0
?LoadAnImage@@YAPAUHBITMAP__@@PBD@Z ENDP		; LoadAnImage
_TEXT	ENDS
PUBLIC	?IsNetAlive@@YA_NXZ				; IsNetAlive
EXTRN	__imp__InternetGetConnectedState@8:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_dwOnline$ = -4						; size = 4
?IsNetAlive@@YA_NXZ PROC NEAR				; IsNetAlive

; 834  : {

  027d0	55		 push	 ebp
  027d1	8b ec		 mov	 ebp, esp
  027d3	51		 push	 ecx

; 835  : 	DWORD dwOnline;
; 836  : 	return InternetGetConnectedState(&dwOnline, 0);

  027d4	6a 00		 push	 0
  027d6	8d 45 fc	 lea	 eax, DWORD PTR _dwOnline$[ebp]
  027d9	50		 push	 eax
  027da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InternetGetConnectedState@8
  027e0	85 c0		 test	 eax, eax
  027e2	0f 95 c0	 setne	 al

; 837  : }

  027e5	8b e5		 mov	 esp, ebp
  027e7	5d		 pop	 ebp
  027e8	c3		 ret	 0
?IsNetAlive@@YA_NXZ ENDP				; IsNetAlive
_TEXT	ENDS
PUBLIC	?GBToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; GBToUTF8
xdata$x	SEGMENT
$T95071	DD	0ffffffffH
	DD	FLAT:$L95064
	DD	00H
	DD	FLAT:$L95063
$T95068	DD	019930520H
	DD	02H
	DD	FLAT:$T95071
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T95065 = -80						; size = 4
$T95062 = -76						; size = 4
$T95061 = -72						; size = 4
$T95060 = -68						; size = 4
$T95059 = -64						; size = 4
_j$ = -60						; size = 4
_result$ = -56						; size = 28
__$ArrayPad$ = -28					; size = 4
_strSrc$ = -24						; size = 4
_i$ = -20						; size = 4
_szRes$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_str$ = 12						; size = 4
?GBToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC NEAR ; GBToUTF8

; 840  : {

  027f0	55		 push	 ebp
  027f1	8b ec		 mov	 ebp, esp
  027f3	6a ff		 push	 -1
  027f5	68 00 00 00 00	 push	 __ehhandler$?GBToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
  027fa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02800	50		 push	 eax
  02801	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02808	83 ec 44	 sub	 esp, 68			; 00000044H
  0280b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02810	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02813	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T95065[ebp], 0

; 841  :      string result;

  0281a	8d 4d c8	 lea	 ecx, DWORD PTR _result$[ebp]
  0281d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  02823	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 842  :      WCHAR *strSrc;
; 843  :      TCHAR *szRes;
; 844  : 
; 845  :      //
; 846  :      int i = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);

  0282a	6a 00		 push	 0
  0282c	6a 00		 push	 0
  0282e	6a ff		 push	 -1
  02830	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  02833	50		 push	 eax
  02834	6a 00		 push	 0
  02836	6a 00		 push	 0
  02838	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  0283e	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 847  :      strSrc = new WCHAR[i+1];

  02841	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  02844	8d 54 09 02	 lea	 edx, DWORD PTR [ecx+ecx+2]
  02848	52		 push	 edx
  02849	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0284e	83 c4 04	 add	 esp, 4
  02851	89 45 c0	 mov	 DWORD PTR $T95059[ebp], eax
  02854	8b 45 c0	 mov	 eax, DWORD PTR $T95059[ebp]
  02857	89 45 e8	 mov	 DWORD PTR _strSrc$[ebp], eax

; 848  :      MultiByteToWideChar(CP_ACP, 0, str, -1, strSrc, i);

  0285a	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0285d	51		 push	 ecx
  0285e	8b 55 e8	 mov	 edx, DWORD PTR _strSrc$[ebp]
  02861	52		 push	 edx
  02862	6a ff		 push	 -1
  02864	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  02867	50		 push	 eax
  02868	6a 00		 push	 0
  0286a	6a 00		 push	 0
  0286c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 849  : 
; 850  :      //
; 851  :      i = WideCharToMultiByte(CP_UTF8, 0, strSrc, -1, NULL, 0, NULL, NULL);

  02872	6a 00		 push	 0
  02874	6a 00		 push	 0
  02876	6a 00		 push	 0
  02878	6a 00		 push	 0
  0287a	6a ff		 push	 -1
  0287c	8b 4d e8	 mov	 ecx, DWORD PTR _strSrc$[ebp]
  0287f	51		 push	 ecx
  02880	6a 00		 push	 0
  02882	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  02887	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  0288d	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 852  :      szRes = new TCHAR[i+1];

  02890	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  02893	83 c2 01	 add	 edx, 1
  02896	52		 push	 edx
  02897	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0289c	83 c4 04	 add	 esp, 4
  0289f	89 45 bc	 mov	 DWORD PTR $T95060[ebp], eax
  028a2	8b 45 bc	 mov	 eax, DWORD PTR $T95060[ebp]
  028a5	89 45 f0	 mov	 DWORD PTR _szRes$[ebp], eax

; 853  :      int j=WideCharToMultiByte(CP_UTF8, 0, strSrc, -1, szRes, i, NULL, NULL);

  028a8	6a 00		 push	 0
  028aa	6a 00		 push	 0
  028ac	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  028af	51		 push	 ecx
  028b0	8b 55 f0	 mov	 edx, DWORD PTR _szRes$[ebp]
  028b3	52		 push	 edx
  028b4	6a ff		 push	 -1
  028b6	8b 45 e8	 mov	 eax, DWORD PTR _strSrc$[ebp]
  028b9	50		 push	 eax
  028ba	6a 00		 push	 0
  028bc	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  028c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  028c7	89 45 c4	 mov	 DWORD PTR _j$[ebp], eax

; 854  : 
; 855  :      result = szRes;

  028ca	8b 4d f0	 mov	 ecx, DWORD PTR _szRes$[ebp]
  028cd	51		 push	 ecx
  028ce	8d 4d c8	 lea	 ecx, DWORD PTR _result$[ebp]
  028d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 856  :      delete []strSrc;

  028d7	8b 55 e8	 mov	 edx, DWORD PTR _strSrc$[ebp]
  028da	89 55 b8	 mov	 DWORD PTR $T95061[ebp], edx
  028dd	8b 45 b8	 mov	 eax, DWORD PTR $T95061[ebp]
  028e0	50		 push	 eax
  028e1	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  028e6	83 c4 04	 add	 esp, 4

; 857  :      delete []szRes;

  028e9	8b 4d f0	 mov	 ecx, DWORD PTR _szRes$[ebp]
  028ec	89 4d b4	 mov	 DWORD PTR $T95062[ebp], ecx
  028ef	8b 55 b4	 mov	 edx, DWORD PTR $T95062[ebp]
  028f2	52		 push	 edx
  028f3	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  028f8	83 c4 04	 add	 esp, 4

; 858  : 
; 859  :      return result;

  028fb	8d 45 c8	 lea	 eax, DWORD PTR _result$[ebp]
  028fe	50		 push	 eax
  028ff	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  02902	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  02908	8b 4d b0	 mov	 ecx, DWORD PTR $T95065[ebp]
  0290b	83 c9 01	 or	 ecx, 1
  0290e	89 4d b0	 mov	 DWORD PTR $T95065[ebp], ecx
  02911	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02915	8d 4d c8	 lea	 ecx, DWORD PTR _result$[ebp]
  02918	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0291e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 860  : }

  02921	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02924	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0292b	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0292e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02933	8b e5		 mov	 esp, ebp
  02935	5d		 pop	 ebp
  02936	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L95063:
  003de	8d 4d c8	 lea	 ecx, DWORD PTR _result$[ebp]
  003e1	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95064:
  003e7	8b 45 b0	 mov	 eax, DWORD PTR $T95065[ebp]
  003ea	83 e0 01	 and	 eax, 1
  003ed	0f 84 0d 00 00
	00		 je	 $L95066
  003f3	83 65 b0 fe	 and	 DWORD PTR $T95065[ebp], -2 ; fffffffeH
  003f7	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  003fa	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95066:
  00400	c3		 ret	 0
__ehhandler$?GBToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:
  00401	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95068
  00406	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GBToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; GBToUTF8
xdata$x	SEGMENT
$T95086	DD	0ffffffffH
	DD	FLAT:$L95079
	DD	00H
	DD	FLAT:$L95078
$T95083	DD	019930520H
	DD	02H
	DD	FLAT:$T95086
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T95080 = -76						; size = 4
$T95077 = -72						; size = 4
$T95076 = -68						; size = 4
$T95075 = -64						; size = 4
$T95074 = -60						; size = 4
_result$ = -56						; size = 28
__$ArrayPad$ = -28					; size = 4
_strSrc$ = -24						; size = 4
_i$ = -20						; size = 4
_szRes$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_str$ = 12						; size = 4
?UTF8ToGB@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC NEAR ; UTF8ToGB

; 863  : {

  02940	55		 push	 ebp
  02941	8b ec		 mov	 ebp, esp
  02943	6a ff		 push	 -1
  02945	68 00 00 00 00	 push	 __ehhandler$?UTF8ToGB@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
  0294a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02950	50		 push	 eax
  02951	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02958	83 ec 40	 sub	 esp, 64			; 00000040H
  0295b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02960	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02963	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T95080[ebp], 0

; 864  :      string result;

  0296a	8d 4d c8	 lea	 ecx, DWORD PTR _result$[ebp]
  0296d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  02973	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 865  :      WCHAR *strSrc;
; 866  :      TCHAR *szRes;
; 867  : 
; 868  :      //
; 869  :      int i = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0);

  0297a	6a 00		 push	 0
  0297c	6a 00		 push	 0
  0297e	6a ff		 push	 -1
  02980	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  02983	50		 push	 eax
  02984	6a 00		 push	 0
  02986	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  0298b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  02991	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 870  :      strSrc = new WCHAR[i+1];

  02994	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  02997	8d 54 09 02	 lea	 edx, DWORD PTR [ecx+ecx+2]
  0299b	52		 push	 edx
  0299c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  029a1	83 c4 04	 add	 esp, 4
  029a4	89 45 c4	 mov	 DWORD PTR $T95074[ebp], eax
  029a7	8b 45 c4	 mov	 eax, DWORD PTR $T95074[ebp]
  029aa	89 45 e8	 mov	 DWORD PTR _strSrc$[ebp], eax

; 871  :      MultiByteToWideChar(CP_UTF8, 0, str, -1, strSrc, i);

  029ad	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  029b0	51		 push	 ecx
  029b1	8b 55 e8	 mov	 edx, DWORD PTR _strSrc$[ebp]
  029b4	52		 push	 edx
  029b5	6a ff		 push	 -1
  029b7	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  029ba	50		 push	 eax
  029bb	6a 00		 push	 0
  029bd	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  029c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 872  : 
; 873  :      //
; 874  :      i = WideCharToMultiByte(CP_ACP, 0, strSrc, -1, NULL, 0, NULL, NULL);

  029c8	6a 00		 push	 0
  029ca	6a 00		 push	 0
  029cc	6a 00		 push	 0
  029ce	6a 00		 push	 0
  029d0	6a ff		 push	 -1
  029d2	8b 4d e8	 mov	 ecx, DWORD PTR _strSrc$[ebp]
  029d5	51		 push	 ecx
  029d6	6a 00		 push	 0
  029d8	6a 00		 push	 0
  029da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  029e0	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 875  :      szRes = new TCHAR[i+1];

  029e3	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  029e6	83 c2 01	 add	 edx, 1
  029e9	52		 push	 edx
  029ea	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  029ef	83 c4 04	 add	 esp, 4
  029f2	89 45 c0	 mov	 DWORD PTR $T95075[ebp], eax
  029f5	8b 45 c0	 mov	 eax, DWORD PTR $T95075[ebp]
  029f8	89 45 f0	 mov	 DWORD PTR _szRes$[ebp], eax

; 876  :      WideCharToMultiByte(CP_ACP, 0, strSrc, -1, szRes, i, NULL, NULL);

  029fb	6a 00		 push	 0
  029fd	6a 00		 push	 0
  029ff	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  02a02	51		 push	 ecx
  02a03	8b 55 f0	 mov	 edx, DWORD PTR _szRes$[ebp]
  02a06	52		 push	 edx
  02a07	6a ff		 push	 -1
  02a09	8b 45 e8	 mov	 eax, DWORD PTR _strSrc$[ebp]
  02a0c	50		 push	 eax
  02a0d	6a 00		 push	 0
  02a0f	6a 00		 push	 0
  02a11	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 877  : 
; 878  :      result = szRes;

  02a17	8b 4d f0	 mov	 ecx, DWORD PTR _szRes$[ebp]
  02a1a	51		 push	 ecx
  02a1b	8d 4d c8	 lea	 ecx, DWORD PTR _result$[ebp]
  02a1e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 879  :      delete []strSrc;

  02a24	8b 55 e8	 mov	 edx, DWORD PTR _strSrc$[ebp]
  02a27	89 55 bc	 mov	 DWORD PTR $T95076[ebp], edx
  02a2a	8b 45 bc	 mov	 eax, DWORD PTR $T95076[ebp]
  02a2d	50		 push	 eax
  02a2e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  02a33	83 c4 04	 add	 esp, 4

; 880  :      delete []szRes;

  02a36	8b 4d f0	 mov	 ecx, DWORD PTR _szRes$[ebp]
  02a39	89 4d b8	 mov	 DWORD PTR $T95077[ebp], ecx
  02a3c	8b 55 b8	 mov	 edx, DWORD PTR $T95077[ebp]
  02a3f	52		 push	 edx
  02a40	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  02a45	83 c4 04	 add	 esp, 4

; 881  : 
; 882  :      return result;

  02a48	8d 45 c8	 lea	 eax, DWORD PTR _result$[ebp]
  02a4b	50		 push	 eax
  02a4c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  02a4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  02a55	8b 4d b4	 mov	 ecx, DWORD PTR $T95080[ebp]
  02a58	83 c9 01	 or	 ecx, 1
  02a5b	89 4d b4	 mov	 DWORD PTR $T95080[ebp], ecx
  02a5e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02a62	8d 4d c8	 lea	 ecx, DWORD PTR _result$[ebp]
  02a65	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  02a6b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 883  : }

  02a6e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02a71	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02a78	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02a7b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02a80	8b e5		 mov	 esp, ebp
  02a82	5d		 pop	 ebp
  02a83	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L95078:
  0040b	8d 4d c8	 lea	 ecx, DWORD PTR _result$[ebp]
  0040e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95079:
  00414	8b 45 b4	 mov	 eax, DWORD PTR $T95080[ebp]
  00417	83 e0 01	 and	 eax, 1
  0041a	0f 84 0d 00 00
	00		 je	 $L95081
  00420	83 65 b4 fe	 and	 DWORD PTR $T95080[ebp], -2 ; fffffffeH
  00424	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00427	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95081:
  0042d	c3		 ret	 0
__ehhandler$?UTF8ToGB@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:
  0042e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95083
  00433	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?UTF8ToGB@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; UTF8ToGB
PUBLIC	?IsNumber@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IsNumber
EXTRN	__imp_?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z:NEAR
xdata$x	SEGMENT
$T95094	DD	0ffffffffH
	DD	FLAT:$L95090
$T95092	DD	019930520H
	DD	01H
	DD	FLAT:$T95094
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T95089 = -18						; size = 1
$T95088 = -17						; size = 1
_i$88025 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_strNum$ = 8						; size = 28
?IsNumber@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; IsNumber

; 886  : {

  02a90	55		 push	 ebp
  02a91	8b ec		 mov	 ebp, esp
  02a93	6a ff		 push	 -1
  02a95	68 00 00 00 00	 push	 __ehhandler$?IsNumber@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  02a9a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02aa0	50		 push	 eax
  02aa1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02aa8	83 ec 08	 sub	 esp, 8
  02aab	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 887  : 	for( size_t i=0;i<strNum.length(); i++)

  02ab2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$88025[ebp], 0
  02ab9	eb 09		 jmp	 SHORT $L88026
$L88027:
  02abb	8b 45 f0	 mov	 eax, DWORD PTR _i$88025[ebp]
  02abe	83 c0 01	 add	 eax, 1
  02ac1	89 45 f0	 mov	 DWORD PTR _i$88025[ebp], eax
$L88026:
  02ac4	8d 4d 08	 lea	 ecx, DWORD PTR _strNum$[ebp]
  02ac7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  02acd	39 45 f0	 cmp	 DWORD PTR _i$88025[ebp], eax
  02ad0	73 45		 jae	 SHORT $L88028

; 888  : 	{
; 889  : 		if( strNum.at(i) < '0' || strNum.at(i) > '9')

  02ad2	8b 4d f0	 mov	 ecx, DWORD PTR _i$88025[ebp]
  02ad5	51		 push	 ecx
  02ad6	8d 4d 08	 lea	 ecx, DWORD PTR _strNum$[ebp]
  02ad9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
  02adf	0f be 10	 movsx	 edx, BYTE PTR [eax]
  02ae2	83 fa 30	 cmp	 edx, 48			; 00000030H
  02ae5	7c 15		 jl	 SHORT $L88030
  02ae7	8b 45 f0	 mov	 eax, DWORD PTR _i$88025[ebp]
  02aea	50		 push	 eax
  02aeb	8d 4d 08	 lea	 ecx, DWORD PTR _strNum$[ebp]
  02aee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
  02af4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  02af7	83 f9 39	 cmp	 ecx, 57			; 00000039H
  02afa	7e 19		 jle	 SHORT $L88029
$L88030:

; 890  : 		{
; 891  : 			return false;

  02afc	c6 45 ef 00	 mov	 BYTE PTR $T95088[ebp], 0
  02b00	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02b07	8d 4d 08	 lea	 ecx, DWORD PTR _strNum$[ebp]
  02b0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  02b10	8a 45 ef	 mov	 al, BYTE PTR $T95088[ebp]
  02b13	eb 19		 jmp	 SHORT $L88024
$L88029:

; 892  : 		}
; 893  : 	}

  02b15	eb a4		 jmp	 SHORT $L88027
$L88028:

; 894  : 	return true;

  02b17	c6 45 ee 01	 mov	 BYTE PTR $T95089[ebp], 1
  02b1b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02b22	8d 4d 08	 lea	 ecx, DWORD PTR _strNum$[ebp]
  02b25	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  02b2b	8a 45 ee	 mov	 al, BYTE PTR $T95089[ebp]
$L88024:

; 895  : }

  02b2e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02b31	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02b38	8b e5		 mov	 esp, ebp
  02b3a	5d		 pop	 ebp
  02b3b	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L95090:
  00438	8d 4d 08	 lea	 ecx, DWORD PTR _strNum$[ebp]
  0043b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?IsNumber@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00441	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95092
  00446	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?IsNumber@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IsNumber
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 373  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = -4						; size = 4
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 375  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));

  00009	8b 45 08	 mov	 eax, DWORD PTR _nRequestedSize$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 377  : 		if (p == NULL)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0001f	75 04		 jne	 SHORT $L88049

; 378  : 			return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	eb 1a		 jmp	 SHORT $L88036
$L88049:

; 379  : 		
; 380  : 		// Add buffer to the list
; 381  : 		p->m_pNext = m_pHead;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00028	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	89 01		 mov	 DWORD PTR [ecx], eax

; 382  : 		m_pHead = p;

  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00035	89 11		 mov	 DWORD PTR [ecx], edx

; 383  : 		
; 384  : 		return p->GetData();

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
$L88036:

; 385  : 	}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
EXTRN	__imp__malloc:NEAR
; Function compile flags: /Odt
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC NEAR		; ATL::CCRTAllocator::Allocate, COMDAT

; 30   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 		return malloc(nBytes);

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0000d	83 c4 04	 add	 esp, 4

; 32   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
; Function compile flags: /Odt
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$88055 = -4						; size = 4
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 387  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$L88053:

; 388  : 		// Walk the list and free the buffers
; 389  : 		while (m_pHead != NULL)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 22		 je	 SHORT $L88051

; 390  : 		{
; 391  : 			CAtlSafeAllocBufferNode* p = m_pHead;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 fc	 mov	 DWORD PTR _p$88055[ebp], edx

; 392  : 			m_pHead = m_pHead->m_pNext;

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	89 02		 mov	 DWORD PTR [edx], eax

; 393  : 			Allocator::Free(p);

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _p$88055[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  0002e	83 c4 04	 add	 esp, 4

; 394  : 		}

  00031	eb d6		 jmp	 SHORT $L88053
$L88051:

; 395  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
EXTRN	__imp__free:NEAR
; Function compile flags: /Odt
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC NEAR		; ATL::CCRTAllocator::Free, COMDAT

; 35   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   : 		free(p);

  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000d	83 c4 04	 add	 esp, 4

; 37   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 217  : 	}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	39 01		 cmp	 DWORD PTR [ecx], eax
  00012	74 08		 je	 SHORT $L88074

; 227  : 		{
; 228  : 			FreeHeap();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L88074:

; 229  : 		}
; 230  : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 233  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 235  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z		; ATL::CW2AEX<128>::Init
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z PROC NEAR		; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 419  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	89 01		 mov	 DWORD PTR [ecx], eax

; 420  : 		Init( psz, _AtlGetConversionACP() );

  00012	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00017	50		 push	 eax
  00018	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  0001b	52		 push	 edx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init

; 421  : 	}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC NEAR			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 428  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 429  : 		if( m_psz != m_szBuffer )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	39 01		 cmp	 DWORD PTR [ecx], eax
  00012	74 0f		 je	 SHORT $L88319

; 430  : 		{
; 431  : 			free( m_psz );

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 02		 mov	 eax, DWORD PTR [edx]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00020	83 c4 04	 add	 esp, 4
$L88319:

; 432  : 		}
; 433  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC NEAR		; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 436  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 437  : 		return( m_psz );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 438  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
PUBLIC	?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 796  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	e8 00 00 00 00	 call	 ?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>

; 797  : 	}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Odt
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_strSrc$ = 8						; size = 4
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 814  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _strSrc$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>

; 815  : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
PUBLIC	?CheckImplicitLoad@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@AAE_NPBX@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95129	DD	0ffffffffH
	DD	FLAT:$L95125
$T95127	DD	019930520H
	DD	01H
	DD	FLAT:$T95129
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pszSrc$ = 8						; size = 4
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 830  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	e8 00 00 00 00	 call	 ?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
  00021	50		 push	 eax
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 831  : 		if( !CheckImplicitLoad( pszSrc ) )

  00031	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00034	50		 push	 eax
  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?CheckImplicitLoad@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@AAE_NPBX@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
  0003d	0f b6 c8	 movzx	 ecx, al
  00040	85 c9		 test	 ecx, ecx
  00042	75 0c		 jne	 SHORT $L88328

; 832  : 		{
; 833  : 			// nDestLength is in XCHARs
; 834  : 			*this = pszSrc;

  00044	8b 55 08	 mov	 edx, DWORD PTR _pszSrc$[ebp]
  00047	52		 push	 edx
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=
$L88328:

; 835  : 		}
; 836  : 	}

  00050	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95125:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
__ehhandler$??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95127
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Odt
;	COMDAT ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 962  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 963  : 	}

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Odt
;	COMDAT ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_strSrc$ = 8						; size = 4
??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@ABV01@@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=, COMDAT
; _this$ = ecx

; 967  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 968  : 		CThisSimpleString::operator=( strSrc );

  00007	8b 45 08	 mov	 eax, DWORD PTR _strSrc$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=

; 969  : 
; 970  : 		return( *this );

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 971  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@ABV01@@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=
_TEXT	ENDS
PUBLIC	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z	; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Odt
;	COMDAT ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszSrc$ = 8						; size = 4
??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=, COMDAT
; _this$ = ecx

; 982  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 983  : 		CThisSimpleString::operator=( pszSrc );

  00007	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z ; ATL::CSimpleStringT<char,0>::operator=

; 984  : 
; 985  : 		return( *this );

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 986  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=
_TEXT	ENDS
PUBLIC	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ	; ATL::CSimpleStringT<char,0>::GetString
PUBLIC	?StringFindChar@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z ; ATL::ChTraitsCRT<char>::StringFindChar
; Function compile flags: /Odt
;	COMDAT ?Find@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHDH@Z
_TEXT	SEGMENT
tv78 = -16						; size = 4
_this$ = -12						; size = 4
_nLength$ = -8						; size = 4
_psz$ = -4						; size = 4
_ch$ = 8						; size = 1
_iStart$ = 12						; size = 4
?Find@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHDH@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Find, COMDAT
; _this$ = ecx

; 1368 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1369 : 		// iStart is in XCHARs
; 1370 : 		ATLASSERT( iStart >= 0 );
; 1371 : 
; 1372 : 		// nLength is in XCHARs
; 1373 : 		int nLength = GetLength();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
  00011	89 45 f8	 mov	 DWORD PTR _nLength$[ebp], eax

; 1374 : 		if( iStart < 0 || iStart >= nLength)

  00014	83 7d 0c 00	 cmp	 DWORD PTR _iStart$[ebp], 0
  00018	7c 08		 jl	 SHORT $L88341
  0001a	8b 45 0c	 mov	 eax, DWORD PTR _iStart$[ebp]
  0001d	3b 45 f8	 cmp	 eax, DWORD PTR _nLength$[ebp]
  00020	7c 05		 jl	 SHORT $L88340
$L88341:

; 1375 : 		{
; 1376 : 			return( -1 );

  00022	83 c8 ff	 or	 eax, -1
  00025	eb 3d		 jmp	 SHORT $L88337
$L88340:

; 1377 : 		}
; 1378 : 
; 1379 : 		// find first single character
; 1380 : 		PCXSTR psz = StringTraits::StringFindChar( GetString()+iStart, ch );

  00027	8a 4d 08	 mov	 cl, BYTE PTR _ch$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
  00033	03 45 0c	 add	 eax, DWORD PTR _iStart$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?StringFindChar@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z ; ATL::ChTraitsCRT<char>::StringFindChar
  0003c	83 c4 08	 add	 esp, 8
  0003f	89 45 fc	 mov	 DWORD PTR _psz$[ebp], eax

; 1381 : 
; 1382 : 		// return -1 if not found and index otherwise
; 1383 : 		return( (psz == NULL) ? -1 : int( psz-GetString() ) );

  00042	83 7d fc 00	 cmp	 DWORD PTR _psz$[ebp], 0
  00046	75 09		 jne	 SHORT $L95140
  00048	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR tv78[ebp], -1
  0004f	eb 10		 jmp	 SHORT $L95141
$L95140:
  00051	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
  00059	8b 55 fc	 mov	 edx, DWORD PTR _psz$[ebp]
  0005c	2b d0		 sub	 edx, eax
  0005e	89 55 f0	 mov	 DWORD PTR tv78[ebp], edx
$L95141:
  00061	8b 45 f0	 mov	 eax, DWORD PTR tv78[ebp]
$L88337:

; 1384 : 	}

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
?Find@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHDH@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Find
_TEXT	ENDS
PUBLIC	?StringFindCharRev@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z ; ATL::ChTraitsCRT<char>::StringFindCharRev
; Function compile flags: /Odt
;	COMDAT ?ReverseFind@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHD@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
_psz$ = -4						; size = 4
_ch$ = 8						; size = 1
?ReverseFind@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHD@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::ReverseFind, COMDAT
; _this$ = ecx

; 1423 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1424 : 		// find last single character
; 1425 : 		PCXSTR psz = StringTraits::StringFindCharRev( GetString(), ch );

  00009	8a 45 08	 mov	 al, BYTE PTR _ch$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?StringFindCharRev@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z ; ATL::ChTraitsCRT<char>::StringFindCharRev
  0001b	83 c4 08	 add	 esp, 8
  0001e	89 45 fc	 mov	 DWORD PTR _psz$[ebp], eax

; 1426 : 
; 1427 : 		// return -1 if not found, distance from beginning otherwise
; 1428 : 		return( (psz == NULL) ? -1 : int( psz-GetString() ) );

  00021	83 7d fc 00	 cmp	 DWORD PTR _psz$[ebp], 0
  00025	75 09		 jne	 SHORT $L95144
  00027	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
  0002e	eb 10		 jmp	 SHORT $L95145
$L95144:
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _psz$[ebp]
  0003b	2b c8		 sub	 ecx, eax
  0003d	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
$L95145:
  00040	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]

; 1429 : 	}

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?ReverseFind@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBEHD@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::ReverseFind
_TEXT	ENDS
PUBLIC	?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ ; ATL::CSimpleStringT<char,0>::GetManager
PUBLIC	??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Odt
;	COMDAT ?Right@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T95149 = -8						; size = 4
_nLength$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_nCount$ = 12						; size = 4
?Right@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Right, COMDAT
; _this$ = ecx

; 1743 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T95149[ebp], 0

; 1744 : 		// nCount is in XCHARs
; 1745 : 		if (nCount < 0)

  00010	83 7d 0c 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00014	7d 07		 jge	 SHORT $L88349

; 1746 : 			nCount = 0;

  00016	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _nCount$[ebp], 0
$L88349:

; 1747 : 
; 1748 : 		int nLength = GetLength();

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
  00025	89 45 fc	 mov	 DWORD PTR _nLength$[ebp], eax

; 1749 : 		if( nCount >= nLength )

  00028	8b 45 0c	 mov	 eax, DWORD PTR _nCount$[ebp]
  0002b	3b 45 fc	 cmp	 eax, DWORD PTR _nLength$[ebp]
  0002e	7c 1a		 jl	 SHORT $L88351

; 1750 : 		{
; 1751 : 			return( *this );

  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	51		 push	 ecx
  00034	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00037	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0003c	8b 55 f8	 mov	 edx, DWORD PTR $T95149[ebp]
  0003f	83 ca 01	 or	 edx, 1
  00042	89 55 f8	 mov	 DWORD PTR $T95149[ebp], edx
  00045	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00048	eb 30		 jmp	 SHORT $L88348
$L88351:

; 1752 : 		}
; 1753 : 
; 1754 : 		return( CStringT( GetString()+nLength-nCount, nCount, GetManager() ) );

  0004a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ ; ATL::CSimpleStringT<char,0>::GetManager
  00052	50		 push	 eax
  00053	8b 45 0c	 mov	 eax, DWORD PTR _nCount$[ebp]
  00056	50		 push	 eax
  00057	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
  0005f	03 45 fc	 add	 eax, DWORD PTR _nLength$[ebp]
  00062	2b 45 0c	 sub	 eax, DWORD PTR _nCount$[ebp]
  00065	50		 push	 eax
  00066	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00069	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR $T95149[ebp]
  00071	83 c9 01	 or	 ecx, 1
  00074	89 4d f8	 mov	 DWORD PTR $T95149[ebp], ecx
  00077	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L88348:

; 1755 : 	}

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
?Right@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Right
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Left@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T95154 = -8						; size = 4
_nLength$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_nCount$ = 12						; size = 4
?Left@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Left, COMDAT
; _this$ = ecx

; 1759 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T95154[ebp], 0

; 1760 : 		// nCount is in XCHARs
; 1761 : 		if (nCount < 0)

  00010	83 7d 0c 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00014	7d 07		 jge	 SHORT $L88356

; 1762 : 			nCount = 0;

  00016	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _nCount$[ebp], 0
$L88356:

; 1763 : 
; 1764 : 		int nLength = GetLength();

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
  00025	89 45 fc	 mov	 DWORD PTR _nLength$[ebp], eax

; 1765 : 		if( nCount >= nLength )

  00028	8b 45 0c	 mov	 eax, DWORD PTR _nCount$[ebp]
  0002b	3b 45 fc	 cmp	 eax, DWORD PTR _nLength$[ebp]
  0002e	7c 1a		 jl	 SHORT $L88358

; 1766 : 		{
; 1767 : 			return( *this );

  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	51		 push	 ecx
  00034	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00037	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0003c	8b 55 f8	 mov	 edx, DWORD PTR $T95154[ebp]
  0003f	83 ca 01	 or	 edx, 1
  00042	89 55 f8	 mov	 DWORD PTR $T95154[ebp], edx
  00045	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00048	eb 2a		 jmp	 SHORT $L88355
$L88358:

; 1768 : 		}
; 1769 : 
; 1770 : 		return( CStringT( GetString(), nCount, GetManager() ) );

  0004a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ ; ATL::CSimpleStringT<char,0>::GetManager
  00052	50		 push	 eax
  00053	8b 45 0c	 mov	 eax, DWORD PTR _nCount$[ebp]
  00056	50		 push	 eax
  00057	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
  0005f	50		 push	 eax
  00060	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00063	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  00068	8b 4d f8	 mov	 ecx, DWORD PTR $T95154[ebp]
  0006b	83 c9 01	 or	 ecx, 1
  0006e	89 4d f8	 mov	 DWORD PTR $T95154[ebp], ecx
  00071	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L88355:

; 1771 : 	}

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
?Left@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QBE?AV12@H@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Left
_TEXT	ENDS
PUBLIC	?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::FormatV
; Function compile flags: /Odt
;	COMDAT ?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT
_argList$ = -4						; size = 4
_this$ = 8						; size = 4
_pszFormat$ = 12					; size = 4
?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Format, COMDAT

; 1795 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1796 : 		ATLASSERT( AtlIsValidString( pszFormat ) );
; 1797 : 		
; 1798 : 		va_list argList;
; 1799 : 		va_start( argList, pszFormat );

  00004	8d 45 10	 lea	 eax, DWORD PTR _pszFormat$[ebp+4]
  00007	89 45 fc	 mov	 DWORD PTR _argList$[ebp], eax

; 1800 : 		FormatV( pszFormat, argList );

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _argList$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _pszFormat$[ebp]
  00011	52		 push	 edx
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::FormatV

; 1801 : 		va_end( argList );

  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _argList$[ebp], 0

; 1802 : 	}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Format
_TEXT	ENDS
PUBLIC	?Concatenate@?$CSimpleStringT@D$0A@@ATL@@KAXAAV12@PBDH1H@Z ; ATL::CSimpleStringT<char,0>::Concatenate
PUBLIC	??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95167	DD	0ffffffffH
	DD	FLAT:$L95160
$T95165	DD	019930520H
	DD	01H
	DD	FLAT:$T95167
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@0@ABV10@0@Z
_TEXT	SEGMENT
$T95162 = -20						; size = 4
_strResult$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_str1$ = 12						; size = 4
_str2$ = 16						; size = 4
??HATL@@YA?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@0@ABV10@0@Z PROC NEAR ; ATL::operator+, COMDAT

; 2014 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T95162[ebp], 0

; 2015 : 		CStringT strResult( str1.GetManager() );

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _str1$[ebp]
  00025	e8 00 00 00 00	 call	 ?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ ; ATL::CSimpleStringT<char,0>::GetManager
  0002a	50		 push	 eax
  0002b	8d 4d f0	 lea	 ecx, DWORD PTR _strResult$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2016 : 
; 2017 : 		Concatenate( strResult, str1, str1.GetLength(), str2, str2.GetLength() );

  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _str2$[ebp]
  0003d	e8 00 00 00 00	 call	 ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
  00042	50		 push	 eax
  00043	8b 4d 10	 mov	 ecx, DWORD PTR _str2$[ebp]
  00046	e8 00 00 00 00	 call	 ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::operator char const *
  0004b	50		 push	 eax
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _str1$[ebp]
  0004f	e8 00 00 00 00	 call	 ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
  00054	50		 push	 eax
  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _str1$[ebp]
  00058	e8 00 00 00 00	 call	 ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::operator char const *
  0005d	50		 push	 eax
  0005e	8d 45 f0	 lea	 eax, DWORD PTR _strResult$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?Concatenate@?$CSimpleStringT@D$0A@@ATL@@KAXAAV12@PBDH1H@Z ; ATL::CSimpleStringT<char,0>::Concatenate
  00067	83 c4 14	 add	 esp, 20			; 00000014H

; 2018 : 
; 2019 : 		return( strResult );

  0006a	8d 4d f0	 lea	 ecx, DWORD PTR _strResult$[ebp]
  0006d	51		 push	 ecx
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00071	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  00076	8b 55 ec	 mov	 edx, DWORD PTR $T95162[ebp]
  00079	83 ca 01	 or	 edx, 1
  0007c	89 55 ec	 mov	 DWORD PTR $T95162[ebp], edx
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8d 4d f0	 lea	 ecx, DWORD PTR _strResult$[ebp]
  00089	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
  0008e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2020 : 	}

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95160:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _strResult$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
__ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@0@ABV10@0@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95165
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??HATL@@YA?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@0@ABV10@0@Z ENDP ; ATL::operator+
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::operator char const *, COMDAT
; _this$ = ecx

; 378  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 379  : 		return( m_pszData );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 380  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP		; ATL::CSimpleStringT<char,0>::operator char const *
_TEXT	ENDS
PUBLIC	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Fork
PUBLIC	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
PUBLIC	?IsShared@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsShared
; Function compile flags: /Odt
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pData$ = -4						; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 479  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 480  : 		CStringData* pData = GetData();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00011	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 481  : 		if( pData->IsShared() )

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00017	e8 00 00 00 00	 call	 ?IsShared@CStringData@ATL@@QBE_NXZ ; ATL::CStringData::IsShared
  0001c	0f b6 c0	 movzx	 eax, al
  0001f	85 c0		 test	 eax, eax
  00021	74 0f		 je	 SHORT $L88377

; 482  : 		{
; 483  : 			Fork( pData->nDataLength );

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00026	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00029	52		 push	 edx
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork
$L88377:

; 484  : 		}
; 485  : 
; 486  : 		return( m_pszData );

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]

; 487  : 	}

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADXZ ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsShared@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsShared, COMDAT
; _this$ = ecx

; 79   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 		return( nRefs > 1 ); 

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00010	0f 9f c1	 setg	 cl
  00013	8a c1		 mov	 al, cl

; 81   : 	}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?IsShared@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsShared
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::GetLength, COMDAT
; _this$ = ecx

; 500  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 501  : 		return( GetData()->nDataLength );

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 502  : 	}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ENDP	; ATL::CSimpleStringT<char,0>::GetLength
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV012@H@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 236  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 237  : 			++*this;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator++

; 238  : 			return (_Tmp);

  00019	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 239  : 			}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV012@H@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator==
; Function compile flags: /Odt
;	COMDAT ??9const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 159  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 161  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );
; 278  : 		if( nBytes > t_nFixedBytes )

  00007	81 7d 08 80 00
	00 00		 cmp	 DWORD PTR _nBytes$[ebp], 128 ; 00000080H
  0000e	76 0e		 jbe	 SHORT $L90136

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

  00010	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

  0001c	eb 0b		 jmp	 SHORT $L90137
$L90136:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 04	 add	 ecx, 4
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	89 0a		 mov	 DWORD PTR [edx], ecx
$L90137:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]

; 288  : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  00012	83 c4 04	 add	 esp, 4

; 314  : 	}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nLengthW$ = -8						; size = 4
_nLengthA$ = -4						; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z PROC NEAR		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 442  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 443  : 		if (psz == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  0000d	75 0b		 jne	 SHORT $L90261

; 444  : 		{
; 445  : 			m_psz = NULL;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 446  : 			return;

  00018	eb 70		 jmp	 SHORT $L95198
$L90261:

; 447  : 		}
; 448  : 		int nLengthW = lstrlenW( psz )+1;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001d	51		 push	 ecx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00024	83 c0 01	 add	 eax, 1
  00027	89 45 f8	 mov	 DWORD PTR _nLengthW$[ebp], eax

; 449  : 		int nLengthA = nLengthW*2;

  0002a	8b 55 f8	 mov	 edx, DWORD PTR _nLengthW$[ebp]
  0002d	d1 e2		 shl	 edx, 1
  0002f	89 55 fc	 mov	 DWORD PTR _nLengthA$[ebp], edx

; 450  : 
; 451  : 		if( nLengthA > t_nBufferLength )

  00032	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _nLengthA$[ebp], 128 ; 00000080H
  00039	7e 24		 jle	 SHORT $L90264

; 452  : 		{
; 453  : 			m_psz = static_cast< LPSTR >( malloc( nLengthA*sizeof( char ) ) );

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _nLengthA$[ebp]
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00045	83 c4 04	 add	 esp, 4
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 454  : 			if (m_psz == NULL)

  0004d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00050	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00053	75 0a		 jne	 SHORT $L90264

; 455  : 			{
; 456  : 				AtlThrow( E_OUTOFMEMORY );

  00055	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0005a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L90264:

; 457  : 			}
; 458  : 		}
; 459  : 
; 460  : 		if (::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ) == 0)

  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	8b 45 fc	 mov	 eax, DWORD PTR _nLengthA$[ebp]
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	52		 push	 edx
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _nLengthW$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  00074	51		 push	 ecx
  00075	6a 00		 push	 0
  00077	8b 55 0c	 mov	 edx, DWORD PTR _nCodePage$[ebp]
  0007a	52		 push	 edx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00081	85 c0		 test	 eax, eax
  00083	75 05		 jne	 SHORT $L95198

; 461  : 		{
; 462  : 			AtlThrowLastWin32();

  00085	e8 00 00 00 00	 call	 ?AtlThrowLastWin32@ATL@@YGXXZ ; ATL::AtlThrowLastWin32
$L95198:

; 463  : 		}
; 464  : 	}

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ENDP		; ATL::CW2AEX<128>::Init
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_dwError$ = -4						; size = 4
?AtlThrowLastWin32@ATL@@YGXXZ PROC NEAR			; ATL::AtlThrowLastWin32, COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 81   : 	DWORD dwError = ::GetLastError();

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0000c	89 45 fc	 mov	 DWORD PTR _dwError$[ebp], eax

; 82   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

  0000f	83 7d fc 00	 cmp	 DWORD PTR _dwError$[ebp], 0
  00013	7f 08		 jg	 SHORT $L95201
  00015	8b 45 fc	 mov	 eax, DWORD PTR _dwError$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001b	eb 18		 jmp	 SHORT $L95202
$L95201:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _dwError$[ebp]
  00020	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00026	81 c9 00 00 07
	00		 or	 ecx, 458752		; 00070000H
  0002c	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  00032	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
$L95202:
  00035	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L95200:

; 83   : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pStringMgr$ = 8					; size = 4
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 800  : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pStringMgr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>

; 801  : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Odt
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pch$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pStringMgr$ = 16					; size = 4
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 923  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 10	 mov	 eax, DWORD PTR _pStringMgr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _nLength$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR _pch$[ebp]
  00012	52		 push	 edx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>

; 924  : 	}

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
PUBLIC	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
PUBLIC	?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z ; ATL::ChTraitsCRT<char>::GetFormattedLength
PUBLIC	?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z	; ATL::ChTraitsCRT<char>::Format
; Function compile flags: /Odt
;	COMDAT ?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nLength$ = -8						; size = 4
_pszBuffer$ = -4					; size = 4
_pszFormat$ = 8						; size = 4
_args$ = 12						; size = 4
?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::FormatV, COMDAT
; _this$ = ecx

; 1855 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1856 : 		ATLASSERT( AtlIsValidString( pszFormat ) );
; 1857 : 		if(pszFormat == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _pszFormat$[ebp], 0
  0000d	75 0a		 jne	 SHORT $L90277

; 1858 : 			AtlThrow(E_INVALIDARG);

  0000f	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00014	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L90277:

; 1859 : 
; 1860 : 		int nLength = StringTraits::GetFormattedLength( pszFormat, args );

  00019	8b 45 0c	 mov	 eax, DWORD PTR _args$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _pszFormat$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z ; ATL::ChTraitsCRT<char>::GetFormattedLength
  00026	83 c4 08	 add	 esp, 8
  00029	89 45 f8	 mov	 DWORD PTR _nLength$[ebp], eax

; 1861 : 		PXSTR pszBuffer = GetBuffer( nLength );

  0002c	8b 55 f8	 mov	 edx, DWORD PTR _nLength$[ebp]
  0002f	52		 push	 edx
  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
  00038	89 45 fc	 mov	 DWORD PTR _pszBuffer$[ebp], eax

; 1862 : 		StringTraits::Format( pszBuffer, pszFormat, args );

  0003b	8b 45 0c	 mov	 eax, DWORD PTR _args$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _pszFormat$[ebp]
  00042	51		 push	 ecx
  00043	8b 55 fc	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z ; ATL::ChTraitsCRT<char>::Format
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1863 : 		ReleaseBufferSetLength( nLength );

  0004f	8b 45 f8	 mov	 eax, DWORD PTR _nLength$[ebp]
  00052	50		 push	 eax
  00053	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
$L95209:

; 1864 : 	}

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::FormatV
_TEXT	ENDS
PUBLIC	?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHI@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::LoadStringA
; Function compile flags: /Odt
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nID$90286 = -8						; size = 4
_bRet$ = -1						; size = 1
_pv$ = 8						; size = 4
?CheckImplicitLoad@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@AAE_NPBX@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad, COMDAT
; _this$ = ecx

; 2229 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2230 : 		bool bRet = false;

  00009	c6 45 ff 00	 mov	 BYTE PTR _bRet$[ebp], 0

; 2231 : 
; 2232 : 		if( (pv != NULL) && IS_INTRESOURCE( pv ) )

  0000d	83 7d 08 00	 cmp	 DWORD PTR _pv$[ebp], 0
  00011	74 29		 je	 SHORT $L90285
  00013	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00016	c1 e8 10	 shr	 eax, 16			; 00000010H
  00019	85 c0		 test	 eax, eax
  0001b	75 1f		 jne	 SHORT $L90285

; 2233 : 		{
; 2234 : 			UINT nID = LOWORD( reinterpret_cast< DWORD_PTR >( pv ) );

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _pv$[ebp]
  00020	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00026	0f b7 d1	 movzx	 edx, cx
  00029	89 55 f8	 mov	 DWORD PTR _nID$90286[ebp], edx

; 2235 : 			if( !LoadString( nID ) )

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _nID$90286[ebp]
  0002f	50		 push	 eax
  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHI@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::LoadStringA

; 2236 : 			{
; 2237 : 				ATLTRACE( atlTraceString, 2, _T( "Warning: implicit LoadString(%u) failed\n" ), nID );
; 2238 : 			}
; 2239 : 			bRet = true;

  00038	c6 45 ff 01	 mov	 BYTE PTR _bRet$[ebp], 1
$L90285:

; 2240 : 		}
; 2241 : 
; 2242 : 		return( bRet );

  0003c	8a 45 ff	 mov	 al, BYTE PTR _bRet$[ebp]

; 2243 : 	}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?CheckImplicitLoad@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@AAE_NPBX@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
_TEXT	ENDS
PUBLIC	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pData$ = -4						; size = 4
_pStringMgr$ = 8					; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 210  : 	explicit CSimpleStringT( IAtlStringMgr* pStringMgr ) throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 211  : 	{
; 212  : 		ATLASSERT( pStringMgr != NULL );
; 213  : 		CStringData* pData = pStringMgr->GetNilString();

  00009	8b 45 08	 mov	 eax, DWORD PTR _pStringMgr$[ebp]
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _pStringMgr$[ebp]
  00011	ff 52 0c	 call	 DWORD PTR [edx+12]
  00014	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 214  : 		Attach( pData );

  00017	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach

; 215  : 	}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ENDP ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
; Function compile flags: /Odt
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pNewData$ = -8						; size = 4
_pSrcData$ = -4						; size = 4
_strSrc$ = 8						; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 217  : 	CSimpleStringT( const CSimpleStringT& strSrc )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 	{
; 219  : 		CStringData* pSrcData = strSrc.GetData();

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _strSrc$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00011	89 45 fc	 mov	 DWORD PTR _pSrcData$[ebp], eax

; 220  : 		CStringData* pNewData = CloneData( pSrcData );

  00014	8b 45 fc	 mov	 eax, DWORD PTR _pSrcData$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  0001d	83 c4 04	 add	 esp, 4
  00020	89 45 f8	 mov	 DWORD PTR _pNewData$[ebp], eax

; 221  : 		Attach( pNewData );

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _pNewData$[ebp]
  00026	51		 push	 ecx
  00027	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach

; 222  : 	}

  0002f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z ENDP	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?Release@CStringData@ATL@@QAEXXZ		; ATL::CStringData::Release
; Function compile flags: /Odt
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pData$ = -4						; size = 4
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ PROC NEAR		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 262  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 263  : 		CStringData* pData = GetData();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00011	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 264  : 		pData->Release();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00017	e8 00 00 00 00	 call	 ?Release@CStringData@ATL@@QAEXXZ ; ATL::CStringData::Release

; 265  : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ENDP		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Release@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::Release, COMDAT
; _this$ = ecx

; 92   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 93   : 		ATLASSERT( nRefs != 0 );
; 94   : 
; 95   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0000d	83 c9 ff	 or	 ecx, -1
  00010	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00014	49		 dec	 ecx
  00015	85 c9		 test	 ecx, ecx
  00017	7f 15		 jg	 SHORT $L71662

; 96   : 		{
; 97   : 			pStringMgr->Free( this );

  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	52		 push	 edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 11		 mov	 edx, DWORD PTR [ecx]
  00029	8b c8		 mov	 ecx, eax
  0002b	ff 52 04	 call	 DWORD PTR [edx+4]
$L71662:

; 98   : 		}
; 99   : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?Release@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::Release
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
PUBLIC	?IsLocked@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsLocked
; Function compile flags: /Odt
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pNewData$90310 = -12					; size = 4
_pOldData$ = -8						; size = 4
_pSrcData$ = -4						; size = 4
_strSrc$ = 8						; size = 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::operator=, COMDAT
; _this$ = ecx

; 273  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 274  : 		CStringData* pSrcData = strSrc.GetData();

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _strSrc$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00011	89 45 fc	 mov	 DWORD PTR _pSrcData$[ebp], eax

; 275  : 		CStringData* pOldData = GetData();

  00014	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  0001c	89 45 f8	 mov	 DWORD PTR _pOldData$[ebp], eax

; 276  : 		if( pSrcData != pOldData)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _pSrcData$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR _pOldData$[ebp]
  00025	74 5a		 je	 SHORT $L90306

; 277  : 		{
; 278  : 			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )

  00027	8b 4d f8	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  0002a	e8 00 00 00 00	 call	 ?IsLocked@CStringData@ATL@@QBE_NXZ ; ATL::CStringData::IsLocked
  0002f	0f b6 c8	 movzx	 ecx, al
  00032	85 c9		 test	 ecx, ecx
  00034	75 0c		 jne	 SHORT $L90308
  00036	8b 55 fc	 mov	 edx, DWORD PTR _pSrcData$[ebp]
  00039	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  0003c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00040	74 1c		 je	 SHORT $L90307
$L90308:

; 279  : 			{
; 280  : 				SetString( strSrc.GetString(), strSrc.GetLength() );

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _strSrc$[ebp]
  00045	e8 00 00 00 00	 call	 ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _strSrc$[ebp]
  0004e	e8 00 00 00 00	 call	 ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
  00053	50		 push	 eax
  00054	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 281  : 			}
; 282  : 			else

  0005c	eb 23		 jmp	 SHORT $L90306
$L90307:

; 283  : 			{
; 284  : 				CStringData* pNewData = CloneData( pSrcData );

  0005e	8b 55 fc	 mov	 edx, DWORD PTR _pSrcData$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  00067	83 c4 04	 add	 esp, 4
  0006a	89 45 f4	 mov	 DWORD PTR _pNewData$90310[ebp], eax

; 285  : 				pOldData->Release();

  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  00070	e8 00 00 00 00	 call	 ?Release@CStringData@ATL@@QAEXXZ ; ATL::CStringData::Release

; 286  : 				Attach( pNewData );

  00075	8b 45 f4	 mov	 eax, DWORD PTR _pNewData$90310[ebp]
  00078	50		 push	 eax
  00079	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$L90306:

; 287  : 			}
; 288  : 		}
; 289  : 
; 290  : 		return( *this );

  00081	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]

; 291  : 	}

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ENDP	; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsLocked@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsLocked, COMDAT
; _this$ = ecx

; 75   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 76   : 		return nRefs < 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00010	0f 9c c1	 setl	 cl
  00013	8a c1		 mov	 al, cl

; 77   : 	}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?IsLocked@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsLocked
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Odt
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszSrc$ = 8						; size = 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::operator=, COMDAT
; _this$ = ecx

; 315  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 316  : 		SetString( pszSrc );

  00007	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ; ATL::CSimpleStringT<char,0>::SetString

; 317  : 
; 318  : 		return( *this );

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 319  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z ENDP	; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetManager, COMDAT
; _this$ = ecx

; 504  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 505  : 		return( GetData()->pStringMgr->Clone() );

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00011	8b 00		 mov	 eax, DWORD PTR [eax]
  00013	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  0001e	ff 52 10	 call	 DWORD PTR [edx+16]

; 506  : 	}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetManager
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetString, COMDAT
; _this$ = ecx

; 509  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 510  : 		return( m_pszData );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 511  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP	; ATL::CSimpleStringT<char,0>::GetString
_TEXT	ENDS
PUBLIC	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Odt
;	COMDAT ?Concatenate@?$CSimpleStringT@D$0A@@ATL@@KAXAAV12@PBDH1H@Z
_TEXT	SEGMENT
_pszBuffer$ = -8					; size = 4
_nNewLength$ = -4					; size = 4
_strResult$ = 8						; size = 4
_psz1$ = 12						; size = 4
_nLength1$ = 16						; size = 4
_psz2$ = 20						; size = 4
_nLength2$ = 24						; size = 4
?Concatenate@?$CSimpleStringT@D$0A@@ATL@@KAXAAV12@PBDH1H@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Concatenate, COMDAT

; 696  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 697  : 		int nNewLength = nLength1+nLength2;

  00006	8b 45 10	 mov	 eax, DWORD PTR _nLength1$[ebp]
  00009	03 45 18	 add	 eax, DWORD PTR _nLength2$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _nNewLength$[ebp], eax

; 698  : 		PXSTR pszBuffer = strResult.GetBuffer( nNewLength );

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _nNewLength$[ebp]
  00012	51		 push	 ecx
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _strResult$[ebp]
  00016	e8 00 00 00 00	 call	 ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
  0001b	89 45 f8	 mov	 DWORD PTR _pszBuffer$[ebp], eax

; 699  : 		CopyChars( pszBuffer, psz1, nLength1 );

  0001e	8b 55 10	 mov	 edx, DWORD PTR _nLength1$[ebp]
  00021	52		 push	 edx
  00022	8b 45 0c	 mov	 eax, DWORD PTR _psz1$[ebp]
  00025	50		 push	 eax
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _pszBuffer$[ebp]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 700  : 		CopyChars( pszBuffer+nLength1, psz2, nLength2 );

  00032	8b 55 18	 mov	 edx, DWORD PTR _nLength2$[ebp]
  00035	52		 push	 edx
  00036	8b 45 14	 mov	 eax, DWORD PTR _psz2$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _pszBuffer$[ebp]
  0003d	03 4d 10	 add	 ecx, DWORD PTR _nLength1$[ebp]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  : 		strResult.ReleaseBufferSetLength( nNewLength );

  00049	8b 55 fc	 mov	 edx, DWORD PTR _nNewLength$[ebp]
  0004c	52		 push	 edx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _strResult$[ebp]
  00050	e8 00 00 00 00	 call	 ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength

; 702  : 	}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?Concatenate@?$CSimpleStringT@D$0A@@ATL@@KAXAAV12@PBDH1H@Z ENDP ; ATL::CSimpleStringT<char,0>::Concatenate
_TEXT	ENDS
PUBLIC	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
PUBLIC	?data@CStringData@ATL@@QAEPAXXZ			; ATL::CStringData::data
; Function compile flags: /Odt
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
tv82 = -28						; size = 4
tv74 = -24						; size = 4
_this$ = -20						; size = 4
_pOldData$ = -16					; size = 4
_pNewData$ = -12					; size = 4
_nOldLength$ = -8					; size = 4
_nCharsToCopy$ = -4					; size = 4
_nLength$ = 8						; size = 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::Fork, COMDAT
; _this$ = ecx

; 715  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 716  : 		CStringData* pOldData = GetData();

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00011	89 45 f0	 mov	 DWORD PTR _pOldData$[ebp], eax

; 717  : 		int nOldLength = pOldData->nDataLength;

  00014	8b 45 f0	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	89 4d f8	 mov	 DWORD PTR _nOldLength$[ebp], ecx

; 718  : 		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );

  0001d	8b 55 f0	 mov	 edx, DWORD PTR _pOldData$[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  00025	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	ff 52 10	 call	 DWORD PTR [edx+16]
  0002c	89 45 e8	 mov	 DWORD PTR tv74[ebp], eax
  0002f	6a 01		 push	 1
  00031	8b 45 08	 mov	 eax, DWORD PTR _nLength$[ebp]
  00034	50		 push	 eax
  00035	8b 4d e8	 mov	 ecx, DWORD PTR tv74[ebp]
  00038	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003a	8b 4d e8	 mov	 ecx, DWORD PTR tv74[ebp]
  0003d	ff 12		 call	 DWORD PTR [edx]
  0003f	89 45 f4	 mov	 DWORD PTR _pNewData$[ebp], eax

; 719  : 		if( pNewData == NULL )

  00042	83 7d f4 00	 cmp	 DWORD PTR _pNewData$[ebp], 0
  00046	75 05		 jne	 SHORT $L90326

; 720  : 		{
; 721  : 			ThrowMemoryException();

  00048	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L90326:

; 722  : 		}
; 723  : 		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _nOldLength$[ebp]
  00050	3b 45 08	 cmp	 eax, DWORD PTR _nLength$[ebp]
  00053	7d 08		 jge	 SHORT $L95234
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _nOldLength$[ebp]
  00058	89 4d e4	 mov	 DWORD PTR tv82[ebp], ecx
  0005b	eb 06		 jmp	 SHORT $L95235
$L95234:
  0005d	8b 55 08	 mov	 edx, DWORD PTR _nLength$[ebp]
  00060	89 55 e4	 mov	 DWORD PTR tv82[ebp], edx
$L95235:
  00063	8b 45 e4	 mov	 eax, DWORD PTR tv82[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	89 45 fc	 mov	 DWORD PTR _nCharsToCopy$[ebp], eax

; 724  : 		CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nCharsToCopy );

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _nCharsToCopy$[ebp]
  0006f	51		 push	 ecx
  00070	8b 4d f0	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  00073	e8 00 00 00 00	 call	 ?data@CStringData@ATL@@QAEPAXXZ ; ATL::CStringData::data
  00078	50		 push	 eax
  00079	8b 4d f4	 mov	 ecx, DWORD PTR _pNewData$[ebp]
  0007c	e8 00 00 00 00	 call	 ?data@CStringData@ATL@@QAEPAXXZ ; ATL::CStringData::data
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  : 		pNewData->nDataLength = nOldLength;

  0008a	8b 55 f4	 mov	 edx, DWORD PTR _pNewData$[ebp]
  0008d	8b 45 f8	 mov	 eax, DWORD PTR _nOldLength$[ebp]
  00090	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 726  : 		pOldData->Release();

  00093	8b 4d f0	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  00096	e8 00 00 00 00	 call	 ?Release@CStringData@ATL@@QAEXXZ ; ATL::CStringData::Release

; 727  : 		Attach( pNewData );

  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _pNewData$[ebp]
  0009e	51		 push	 ecx
  0009f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$L95233:

; 728  : 	}

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP		; ATL::CSimpleStringT<char,0>::Fork
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@CStringData@ATL@@QAEPAXXZ PROC NEAR		; ATL::CStringData::data, COMDAT
; _this$ = ecx

; 65   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   : 		return (this+1);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 10	 add	 eax, 16			; 00000010H

; 67   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?data@CStringData@ATL@@QAEPAXXZ ENDP			; ATL::CStringData::data
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetData, COMDAT
; _this$ = ecx

; 730  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 731  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	83 e8 10	 sub	 eax, 16			; 00000010H

; 732  : 	}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetData
_TEXT	ENDS
EXTRN	?g_strmgr@ATL@@3VCAtlStringMgr@1@A:BYTE		; ATL::g_strmgr
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlstr.h
;	COMDAT ?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT
?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ PROC NEAR ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::GetDefaultManager, COMDAT

; 953  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 954  : 		return( &g_strmgr );

  00003	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?g_strmgr@ATL@@3VCAtlStringMgr@1@A ; ATL::g_strmgr

; 955  : 	}

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ ENDP ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
_TEXT	ENDS
EXTRN	__imp___mbschr:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?StringFindChar@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z
_TEXT	SEGMENT
_pszBlock$ = 8						; size = 4
_chMatch$ = 12						; size = 1
?StringFindChar@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z PROC NEAR ; ATL::ChTraitsCRT<char>::StringFindChar, COMDAT

; 366  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 367  : 		return reinterpret_cast< LPCSTR >( _mbschr( reinterpret_cast< const unsigned char* >( pszBlock ), (unsigned char)chMatch ) );

  00003	0f b6 45 0c	 movzx	 eax, BYTE PTR _chMatch$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _pszBlock$[ebp]
  0000b	51		 push	 ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbschr
  00012	83 c4 08	 add	 esp, 8

; 368  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?StringFindChar@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z ENDP	; ATL::ChTraitsCRT<char>::StringFindChar
_TEXT	ENDS
EXTRN	__imp___mbsrchr:NEAR
; Function compile flags: /Odt
;	COMDAT ?StringFindCharRev@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
_ch$ = 12						; size = 1
?StringFindCharRev@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z PROC NEAR ; ATL::ChTraitsCRT<char>::StringFindCharRev, COMDAT

; 371  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 372  : 		return reinterpret_cast< LPSTR >( _mbsrchr( reinterpret_cast< const unsigned char* >( psz ), (unsigned char)ch ) );

  00003	0f b6 45 0c	 movzx	 eax, BYTE PTR _ch$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0000b	51		 push	 ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsrchr
  00012	83 c4 08	 add	 esp, 8

; 373  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?StringFindCharRev@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z ENDP ; ATL::ChTraitsCRT<char>::StringFindCharRev
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L91279

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 49		 jmp	 SHORT $L91278
$L91279:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L91281

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen

; 776  : 		else

  00044	eb 30		 jmp	 SHORT $L91280
$L91281:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00067	6b d2 1c	 imul	 edx, 28			; 0000001cH
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L91280:

; 781  : 			}
; 782  : 		return (true);

  00076	b0 01		 mov	 al, 1
$L91278:

; 783  : 		}

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 3c		 je	 SHORT $L91285

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	8b c1		 mov	 eax, ecx
  00034	99		 cdq
  00035	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0003a	f7 f9		 idiv	 ecx
  0003c	50		 push	 eax
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
$L91285:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC NEAR ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 			++this->_Myptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 232  : 			}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator++
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 152  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 156  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator==
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 365  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 366  : 			return (this + 1);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8

; 367  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00009	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

  00018	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0001c	75 0a		 jne	 SHORT $L91331

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

  0001e	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00023	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L91331:

; 297  : 		}
; 298  : 		m_p = p;

  00028	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0002e	89 11		 mov	 DWORD PTR [ecx], edx
$L95265:

; 299  : 	}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
PUBLIC	?FindStringResourceInstance@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUHINSTANCE__@@I@Z ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
PUBLIC	?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::LoadStringA
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hInst$ = -4						; size = 4
_nID$ = 8						; size = 4
?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHI@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::LoadStringA, COMDAT
; _this$ = ecx

; 1969 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1970 : 		HINSTANCE hInst = StringTraits::FindStringResourceInstance( nID );

  00009	8b 45 08	 mov	 eax, DWORD PTR _nID$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?FindStringResourceInstance@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUHINSTANCE__@@I@Z ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR _hInst$[ebp], eax

; 1971 : 		if( hInst == NULL )

  00018	83 7d fc 00	 cmp	 DWORD PTR _hInst$[ebp], 0
  0001c	75 04		 jne	 SHORT $L91360

; 1972 : 		{
; 1973 : 			return( FALSE );

  0001e	33 c0		 xor	 eax, eax
  00020	eb 10		 jmp	 SHORT $L91358
$L91360:

; 1974 : 		}
; 1975 : 
; 1976 : 		return( LoadString( hInst, nID ) );		

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _nID$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 fc	 mov	 edx, DWORD PTR _hInst$[ebp]
  00029	52		 push	 edx
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::LoadStringA
$L91358:

; 1977 : 	}

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHI@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::LoadStringA
_TEXT	ENDS
PUBLIC	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::SetLength
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pData$ = -4						; size = 4
_pchSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pStringMgr$ = 16					; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 245  : 	CSimpleStringT( const XCHAR* pchSrc, int nLength, IAtlStringMgr* pStringMgr )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 246  : 	{
; 247  : 		ATLASSERT( pStringMgr != NULL );
; 248  : 		
; 249  : 		if(pchSrc == NULL && nLength != 0)

  00009	83 7d 08 00	 cmp	 DWORD PTR _pchSrc$[ebp], 0
  0000d	75 10		 jne	 SHORT $L91364
  0000f	83 7d 0c 00	 cmp	 DWORD PTR _nLength$[ebp], 0
  00013	74 0a		 je	 SHORT $L91364

; 250  : 			AtlThrow(E_INVALIDARG);

  00015	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0001a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L91364:

; 251  : 
; 252  : 		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );

  0001f	6a 01		 push	 1
  00021	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 10	 mov	 ecx, DWORD PTR _pStringMgr$[ebp]
  00028	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _pStringMgr$[ebp]
  0002d	ff 12		 call	 DWORD PTR [edx]
  0002f	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 253  : 		if( pData == NULL )

  00032	83 7d fc 00	 cmp	 DWORD PTR _pData$[ebp], 0
  00036	75 05		 jne	 SHORT $L91368

; 254  : 		{
; 255  : 			ThrowMemoryException();

  00038	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L91368:

; 256  : 		}
; 257  : 		Attach( pData );

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00040	50		 push	 eax
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach

; 258  : 		SetLength( nLength );

  00049	8b 4d 0c	 mov	 ecx, DWORD PTR _nLength$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::SetLength

; 259  : 		CopyChars( m_pszData, pchSrc, nLength );

  00055	8b 55 0c	 mov	 edx, DWORD PTR _nLength$[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR _pchSrc$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH

; 260  : 	}

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$L95269:
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 0c 00	 ret	 12			; 0000000cH
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ENDP ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite
; Function compile flags: /Odt
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nMinBufferLength$ = 8					; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 489  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 490  : 		return( PrepareWrite( nMinBufferLength ) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _nMinBufferLength$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite

; 491  : 	}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nNewLength$ = 8					; size = 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength, COMDAT
; _this$ = ecx

; 546  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 547  : 		ATLASSERT( nNewLength >= 0 );
; 548  : 		SetLength( nNewLength );

  00007	8b 45 08	 mov	 eax, DWORD PTR _nNewLength$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::SetLength

; 549  : 	}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
_TEXT	ENDS
PUBLIC	?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ; ATL::CSimpleStringT<char,0>::StringLength
; Function compile flags: /Odt
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszSrc$ = 8						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 579  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		SetString( pszSrc, StringLength( pszSrc ) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ; ATL::CSimpleStringT<char,0>::StringLength
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  00017	51		 push	 ecx
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 581  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
PUBLIC	?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ	; ATL::CSimpleStringT<char,0>::Empty
PUBLIC	?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
; Function compile flags: /Odt
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pszBuffer$91384 = -12					; size = 4
_nOffset$91383 = -8					; size = 4
_nOldLength$91382 = -4					; size = 4
_pszSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 583  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 584  : 		if( nLength == 0 )

  00009	83 7d 0c 00	 cmp	 DWORD PTR _nLength$[ebp], 0
  0000d	75 0a		 jne	 SHORT $L91378

; 585  : 		{
; 586  : 			Empty();

  0000f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ; ATL::CSimpleStringT<char,0>::Empty

; 587  : 		}
; 588  : 		else

  00017	eb 7b		 jmp	 SHORT $L95277
$L91378:

; 589  : 		{
; 590  : 			// It is possible that pszSrc points to a location inside of our 
; 591  : 			// buffer.  GetBuffer() might change m_pszData if (1) the buffer 
; 592  : 			// is shared or (2) the buffer is too small to hold the new 
; 593  : 			// string.  We detect this aliasing, and modify pszSrc to point
; 594  : 			// into the newly allocated buffer instead.
; 595  : 			
; 596  : 			if(pszSrc == NULL)

  00019	83 7d 08 00	 cmp	 DWORD PTR _pszSrc$[ebp], 0
  0001d	75 0a		 jne	 SHORT $L91380

; 597  : 				AtlThrow(E_INVALIDARG);			

  0001f	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00024	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L91380:

; 598  : 				
; 599  : 			UINT nOldLength = GetLength();

  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
  00031	89 45 fc	 mov	 DWORD PTR _nOldLength$91382[ebp], eax

; 600  : 			UINT_PTR nOffset = pszSrc-GetString();

  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  0003f	2b c8		 sub	 ecx, eax
  00041	89 4d f8	 mov	 DWORD PTR _nOffset$91383[ebp], ecx

; 601  : 			// If 0 <= nOffset <= nOldLength, then pszSrc points into our 
; 602  : 			// buffer
; 603  : 
; 604  : 			PXSTR pszBuffer = GetBuffer( nLength );

  00044	8b 55 0c	 mov	 edx, DWORD PTR _nLength$[ebp]
  00047	52		 push	 edx
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
  00050	89 45 f4	 mov	 DWORD PTR _pszBuffer$91384[ebp], eax

; 605  : 			if( nOffset <= nOldLength )

  00053	8b 45 f8	 mov	 eax, DWORD PTR _nOffset$91383[ebp]
  00056	3b 45 fc	 cmp	 eax, DWORD PTR _nOldLength$91382[ebp]
  00059	77 19		 ja	 SHORT $L91385

; 606  : 			{
; 607  : 				CopyCharsOverlapped( pszBuffer, pszBuffer+nOffset, nLength );

  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _nLength$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 f4	 mov	 edx, DWORD PTR _pszBuffer$91384[ebp]
  00062	03 55 f8	 add	 edx, DWORD PTR _nOffset$91383[ebp]
  00065	52		 push	 edx
  00066	8b 45 f4	 mov	 eax, DWORD PTR _pszBuffer$91384[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 608  : 			}
; 609  : 			else

  00072	eb 14		 jmp	 SHORT $L91386
$L91385:

; 610  : 			{
; 611  : 				CopyChars( pszBuffer, pszSrc, nLength );

  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00077	51		 push	 ecx
  00078	8b 55 08	 mov	 edx, DWORD PTR _pszSrc$[ebp]
  0007b	52		 push	 edx
  0007c	8b 45 f4	 mov	 eax, DWORD PTR _pszBuffer$91384[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
$L91386:

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

  00088	8b 4d 0c	 mov	 ecx, DWORD PTR _nLength$[ebp]
  0008b	51		 push	 ecx
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
$L95277:

; 614  : 		}
; 615  : 	}

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 08 00	 ret	 8
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyChars, COMDAT

; 652  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 653  : 		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00003	8b 45 10	 mov	 eax, DWORD PTR _nChars$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _pchSrc$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR _pchDest$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memcpy
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 654  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::ThrowMemoryException, COMDAT

; 704  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 705  : 		AtlThrow( E_OUTOFMEMORY );

  00003	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00008	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L95281:

; 706  : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ENDP ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pData$ = 8						; size = 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Attach, COMDAT
; _this$ = ecx

; 711  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 712  : 		m_pszData = static_cast< PXSTR >( pData->data() );

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  0000a	e8 00 00 00 00	 call	 ?data@CStringData@ATL@@QAEPAXXZ ; ATL::CStringData::data
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	89 01		 mov	 DWORD PTR [ecx], eax

; 713  : 	}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ENDP ; ATL::CSimpleStringT<char,0>::Attach
_TEXT	ENDS
PUBLIC	?AddRef@CStringData@ATL@@QAEXXZ			; ATL::CStringData::AddRef
; Function compile flags: /Odt
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT
_pNewStringMgr$ = -8					; size = 4
_pNewData$ = -4						; size = 4
_pData$ = 8						; size = 4
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CloneData, COMDAT

; 801  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 802  : 		CStringData* pNewData = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pNewData$[ebp], 0

; 803  : 
; 804  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

  0000d	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	8b 55 08	 mov	 edx, DWORD PTR _pData$[ebp]
  00015	8b 02		 mov	 eax, DWORD PTR [edx]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	8b c8		 mov	 ecx, eax
  0001b	ff 52 10	 call	 DWORD PTR [edx+16]
  0001e	89 45 f8	 mov	 DWORD PTR _pNewStringMgr$[ebp], eax

; 805  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  00024	e8 00 00 00 00	 call	 ?IsLocked@CStringData@ATL@@QBE_NXZ ; ATL::CStringData::IsLocked
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 1a		 jne	 SHORT $L91397
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  00033	8b 55 f8	 mov	 edx, DWORD PTR _pNewStringMgr$[ebp]
  00036	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00038	75 10		 jne	 SHORT $L91397

; 806  : 		{
; 807  : 			pNewData = pData;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  0003d	89 45 fc	 mov	 DWORD PTR _pNewData$[ebp], eax

; 808  : 			pNewData->AddRef();

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _pNewData$[ebp]
  00043	e8 00 00 00 00	 call	 ?AddRef@CStringData@ATL@@QAEXXZ ; ATL::CStringData::AddRef

; 809  : 		}
; 810  : 		else

  00048	eb 51		 jmp	 SHORT $L91398
$L91397:

; 811  : 		{
; 812  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

  0004a	6a 01		 push	 1
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  0004f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00052	52		 push	 edx
  00053	8b 45 f8	 mov	 eax, DWORD PTR _pNewStringMgr$[ebp]
  00056	8b 10		 mov	 edx, DWORD PTR [eax]
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _pNewStringMgr$[ebp]
  0005b	ff 12		 call	 DWORD PTR [edx]
  0005d	89 45 fc	 mov	 DWORD PTR _pNewData$[ebp], eax

; 813  : 			if( pNewData == NULL )

  00060	83 7d fc 00	 cmp	 DWORD PTR _pNewData$[ebp], 0
  00064	75 05		 jne	 SHORT $L91400

; 814  : 			{
; 815  : 				ThrowMemoryException();

  00066	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L91400:

; 816  : 			}
; 817  : 			pNewData->nDataLength = pData->nDataLength;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _pNewData$[ebp]
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  00071	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00074	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 818  : 			CopyChars( PXSTR( pNewData->data() ), PCXSTR( pData->data() ), pData->nDataLength+1 );  // Copy '\0'

  00077	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  0007a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007d	83 c1 01	 add	 ecx, 1
  00080	51		 push	 ecx
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  00084	e8 00 00 00 00	 call	 ?data@CStringData@ATL@@QAEPAXXZ ; ATL::CStringData::data
  00089	50		 push	 eax
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _pNewData$[ebp]
  0008d	e8 00 00 00 00	 call	 ?data@CStringData@ATL@@QAEPAXXZ ; ATL::CStringData::data
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
$L91398:

; 819  : 		}
; 820  : 
; 821  : 		return( pNewData );

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _pNewData$[ebp]
$L95285:

; 822  : 	}

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ENDP ; ATL::CSimpleStringT<char,0>::CloneData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AddRef@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::AddRef, COMDAT
; _this$ = ecx

; 70   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 71   : 		ATLASSERT(nRefs > 0);
; 72   : 		_InterlockedIncrement(&nRefs);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0000d	b9 01 00 00 00	 mov	 ecx, 1
  00012	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx

; 73   : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?AddRef@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::AddRef
_TEXT	ENDS
EXTRN	__imp___vscprintf:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT
_pszFormat$ = 8						; size = 4
_args$ = 12						; size = 4
?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z PROC NEAR ; ATL::ChTraitsCRT<char>::GetFormattedLength, COMDAT

; 407  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 408  : 		return _vscprintf( pszFormat, args );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _args$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pszFormat$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vscprintf
  00011	83 c4 08	 add	 esp, 8

; 409  : 	}

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z ENDP ; ATL::ChTraitsCRT<char>::GetFormattedLength
_TEXT	ENDS
EXTRN	__imp__vsprintf:NEAR
; Function compile flags: /Odt
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT
_pszBuffer$ = 8						; size = 4
_pszFormat$ = 12					; size = 4
_args$ = 16						; size = 4
?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z PROC NEAR	; ATL::ChTraitsCRT<char>::Format, COMDAT

; 412  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 413  : 		return vsprintf( pszBuffer, pszFormat, args );

  00003	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _pszFormat$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  0000e	52		 push	 edx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 414  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z ENDP		; ATL::ChTraitsCRT<char>::Format
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95304	DD	0ffffffffH
	DD	FLAT:$L95300
$T95302	DD	019930520H
	DD	01H
	DD	FLAT:$T95304
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T95299 = -80						; size = 28
$T95298 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T95299[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T95299[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T95298[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T95298[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L95297:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95300:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T95299[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95302
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95317	DD	0ffffffffH
	DD	FLAT:$L95312
$T95315	DD	019930520H
	DD	01H
	DD	FLAT:$T95317
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 20   : 		}

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95312:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95315
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odt
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 28   : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L78413
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L78413:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95331	DD	0ffffffffH
	DD	FLAT:$L95326
$T95329	DD	019930520H
	DD	01H
	DD	FLAT:$T95331
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95326:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95329
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L78479
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L78479:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95357	DD	0ffffffffH
	DD	FLAT:$L95352
$T95355	DD	019930520H
	DD	01H
	DD	FLAT:$T95357
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0003f	52		 push	 edx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95352:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95355
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ; ATL::AtlGetStringResourceImage
PUBLIC	?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z ; ATL::ChTraitsCRT<char>::GetBaseTypeLength
PUBLIC	?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z ; ATL::ChTraitsCRT<char>::ConvertToBaseType
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_nLength$ = -12						; size = 4
_pszBuffer$ = -8					; size = 4
_pImage$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_nID$ = 12						; size = 4
?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHPAUHINSTANCE__@@I@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::LoadStringA, COMDAT
; _this$ = ecx

; 1981 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1982 : 		const ATLSTRINGRESOURCEIMAGE* pImage = AtlGetStringResourceImage( hInstance, nID );

  00009	8b 45 0c	 mov	 eax, DWORD PTR _nID$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _hInstance$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ; ATL::AtlGetStringResourceImage
  00016	83 c4 08	 add	 esp, 8
  00019	89 45 fc	 mov	 DWORD PTR _pImage$[ebp], eax

; 1983 : 		if( pImage == NULL )

  0001c	83 7d fc 00	 cmp	 DWORD PTR _pImage$[ebp], 0
  00020	75 04		 jne	 SHORT $L91709

; 1984 : 		{
; 1985 : 			return( FALSE );

  00022	33 c0		 xor	 eax, eax
  00024	eb 57		 jmp	 SHORT $L91707
$L91709:

; 1986 : 		}
; 1987 : 
; 1988 : 		int nLength = StringTraits::GetBaseTypeLength( pImage->achString, pImage->nLength );

  00026	8b 55 fc	 mov	 edx, DWORD PTR _pImage$[ebp]
  00029	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0002c	50		 push	 eax
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _pImage$[ebp]
  00030	83 c1 02	 add	 ecx, 2
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z ; ATL::ChTraitsCRT<char>::GetBaseTypeLength
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 f4	 mov	 DWORD PTR _nLength$[ebp], eax

; 1989 : 		PXSTR pszBuffer = GetBuffer( nLength );

  0003f	8b 55 f4	 mov	 edx, DWORD PTR _nLength$[ebp]
  00042	52		 push	 edx
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
  0004b	89 45 f8	 mov	 DWORD PTR _pszBuffer$[ebp], eax

; 1990 : 		StringTraits::ConvertToBaseType( pszBuffer, nLength, pImage->achString, pImage->nLength );

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _pImage$[ebp]
  00051	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00054	51		 push	 ecx
  00055	8b 55 fc	 mov	 edx, DWORD PTR _pImage$[ebp]
  00058	83 c2 02	 add	 edx, 2
  0005b	52		 push	 edx
  0005c	8b 45 f4	 mov	 eax, DWORD PTR _nLength$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _pszBuffer$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z ; ATL::ChTraitsCRT<char>::ConvertToBaseType
  00069	83 c4 10	 add	 esp, 16			; 00000010H

; 1991 : 		ReleaseBufferSetLength( nLength );

  0006c	8b 55 f4	 mov	 edx, DWORD PTR _nLength$[ebp]
  0006f	52		 push	 edx
  00070	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength

; 1992 : 
; 1993 : 		return( TRUE );

  00078	b8 01 00 00 00	 mov	 eax, 1
$L91707:

; 1994 : 	}

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 08 00	 ret	 8
?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::LoadStringA
_TEXT	ENDS
PUBLIC	?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
EXTRN	__imp__FindResourceA@12:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_hResource$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_id$ = 12						; size = 4
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z PROC NEAR ; ATL::AtlGetStringResourceImage, COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 281  : 	HRSRC hResource;
; 282  : 
; 283  : 	hResource = ::FindResource( hInstance, MAKEINTRESOURCE( ((id>>4)+1) ), RT_STRING );

  00004	6a 06		 push	 6
  00006	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  00009	c1 e8 04	 shr	 eax, 4
  0000c	83 c0 01	 add	 eax, 1
  0000f	0f b7 c8	 movzx	 ecx, ax
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR _hInstance$[ebp]
  00016	52		 push	 edx
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  0001d	89 45 fc	 mov	 DWORD PTR _hResource$[ebp], eax

; 284  : 	if( hResource == NULL )

  00020	83 7d fc 00	 cmp	 DWORD PTR _hResource$[ebp], 0
  00024	75 04		 jne	 SHORT $L57539

; 285  : 	{
; 286  : 		return( NULL );

  00026	33 c0		 xor	 eax, eax
  00028	eb 14		 jmp	 SHORT $L57531
$L57539:

; 287  : 	}
; 288  : 
; 289  : 	return _AtlGetStringResourceImage( hInstance, hResource, id );

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _hResource$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 08	 mov	 edx, DWORD PTR _hInstance$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
$L57531:

; 290  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ENDP ; ATL::AtlGetStringResourceImage
_TEXT	ENDS
EXTRN	__imp__LockResource@4:NEAR
EXTRN	__imp__LoadResource@8:NEAR
EXTRN	__imp__SizeofResource@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT
_hGlobal$ = -20						; size = 4
_iIndex$ = -16						; size = 4
_nResourceSize$ = -12					; size = 4
_pImageEnd$ = -8					; size = 4
_pImage$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_hResource$ = 12					; size = 4
_id$ = 16						; size = 4
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z PROC NEAR ; ATL::_AtlGetStringResourceImage, COMDAT

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 240  : 	const ATLSTRINGRESOURCEIMAGE* pImage;
; 241  : 	const ATLSTRINGRESOURCEIMAGE* pImageEnd;
; 242  : 	ULONG nResourceSize;
; 243  : 	HGLOBAL hGlobal;
; 244  : 	UINT iIndex;
; 245  : 
; 246  : 	hGlobal = ::LoadResource( hInstance, hResource );

  00006	8b 45 0c	 mov	 eax, DWORD PTR _hResource$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _hInstance$[ebp]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8
  00014	89 45 ec	 mov	 DWORD PTR _hGlobal$[ebp], eax

; 247  : 	if( hGlobal == NULL )

  00017	83 7d ec 00	 cmp	 DWORD PTR _hGlobal$[ebp], 0
  0001b	75 07		 jne	 SHORT $L57516

; 248  : 	{
; 249  : 		return( NULL );

  0001d	33 c0		 xor	 eax, eax
  0001f	e9 80 00 00 00	 jmp	 $L57510
$L57516:

; 250  : 	}
; 251  : 
; 252  : 	pImage = (const ATLSTRINGRESOURCEIMAGE*)::LockResource( hGlobal );

  00024	8b 55 ec	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00027	52		 push	 edx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LockResource@4
  0002e	89 45 fc	 mov	 DWORD PTR _pImage$[ebp], eax

; 253  : 	if( pImage == NULL )

  00031	83 7d fc 00	 cmp	 DWORD PTR _pImage$[ebp], 0
  00035	75 04		 jne	 SHORT $L57518

; 254  : 	{
; 255  : 		return( NULL );

  00037	33 c0		 xor	 eax, eax
  00039	eb 69		 jmp	 SHORT $L57510
$L57518:

; 256  : 	}
; 257  : 
; 258  : 	nResourceSize = ::SizeofResource( hInstance, hResource );

  0003b	8b 45 0c	 mov	 eax, DWORD PTR _hResource$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _hInstance$[ebp]
  00042	51		 push	 ecx
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8
  00049	89 45 f4	 mov	 DWORD PTR _nResourceSize$[ebp], eax

; 259  : 	pImageEnd = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+nResourceSize);

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _pImage$[ebp]
  0004f	03 55 f4	 add	 edx, DWORD PTR _nResourceSize$[ebp]
  00052	89 55 f8	 mov	 DWORD PTR _pImageEnd$[ebp], edx

; 260  : 	iIndex = id&0x000f;

  00055	8b 45 10	 mov	 eax, DWORD PTR _id$[ebp]
  00058	83 e0 0f	 and	 eax, 15			; 0000000fH
  0005b	89 45 f0	 mov	 DWORD PTR _iIndex$[ebp], eax
$L57521:

; 261  : 
; 262  : 	while( (iIndex > 0) && (pImage < pImageEnd) )

  0005e	83 7d f0 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00062	76 23		 jbe	 SHORT $L57522
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _pImage$[ebp]
  00067	3b 4d f8	 cmp	 ecx, DWORD PTR _pImageEnd$[ebp]
  0006a	73 1b		 jae	 SHORT $L57522

; 263  : 	{
; 264  : 		pImage = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+(sizeof( ATLSTRINGRESOURCEIMAGE )+(pImage->nLength*sizeof( WCHAR ))));

  0006c	8b 55 fc	 mov	 edx, DWORD PTR _pImage$[ebp]
  0006f	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _pImage$[ebp]
  00075	8d 54 41 02	 lea	 edx, DWORD PTR [ecx+eax*2+2]
  00079	89 55 fc	 mov	 DWORD PTR _pImage$[ebp], edx

; 265  : 		iIndex--;

  0007c	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0007f	83 e8 01	 sub	 eax, 1
  00082	89 45 f0	 mov	 DWORD PTR _iIndex$[ebp], eax

; 266  : 	}

  00085	eb d7		 jmp	 SHORT $L57521
$L57522:

; 267  : 	if( pImage >= pImageEnd )

  00087	8b 4d fc	 mov	 ecx, DWORD PTR _pImage$[ebp]
  0008a	3b 4d f8	 cmp	 ecx, DWORD PTR _pImageEnd$[ebp]
  0008d	72 04		 jb	 SHORT $L57526

; 268  : 	{
; 269  : 		return( NULL );

  0008f	33 c0		 xor	 eax, eax
  00091	eb 11		 jmp	 SHORT $L57510
$L57526:

; 270  : 	}
; 271  : 	if( pImage->nLength == 0 )

  00093	8b 55 fc	 mov	 edx, DWORD PTR _pImage$[ebp]
  00096	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00099	85 c0		 test	 eax, eax
  0009b	75 04		 jne	 SHORT $L57527

; 272  : 	{
; 273  : 		return( NULL );

  0009d	33 c0		 xor	 eax, eax
  0009f	eb 03		 jmp	 SHORT $L57510
$L57527:

; 274  : 	}
; 275  : 
; 276  : 	return( pImage );

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _pImage$[ebp]
$L57510:

; 277  : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ENDP ; ATL::_AtlGetStringResourceImage
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pNewData$91719 = -12					; size = 4
_pOldData$ = -8						; size = 4
_pStringMgr$ = -4					; size = 4
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::Empty, COMDAT
; _this$ = ecx

; 421  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 422  : 		CStringData* pOldData = GetData();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00011	89 45 f8	 mov	 DWORD PTR _pOldData$[ebp], eax

; 423  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;

  00014	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	89 4d fc	 mov	 DWORD PTR _pStringMgr$[ebp], ecx

; 424  : 		if( pOldData->nDataLength == 0 )

  0001c	8b 55 f8	 mov	 edx, DWORD PTR _pOldData$[ebp]
  0001f	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00023	75 02		 jne	 SHORT $L91716

; 425  : 		{
; 426  : 			return;

  00025	eb 3d		 jmp	 SHORT $L91713
$L91716:

; 427  : 		}
; 428  : 
; 429  : 		if( pOldData->IsLocked() )

  00027	8b 4d f8	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  0002a	e8 00 00 00 00	 call	 ?IsLocked@CStringData@ATL@@QBE_NXZ ; ATL::CStringData::IsLocked
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	74 0c		 je	 SHORT $L91717

; 430  : 		{
; 431  : 			// Don't reallocate a locked buffer that's shrinking
; 432  : 			SetLength( 0 );

  00036	6a 00		 push	 0
  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::SetLength

; 433  : 		}
; 434  : 		else

  00040	eb 22		 jmp	 SHORT $L91713
$L91717:

; 435  : 		{
; 436  : 			pOldData->Release();

  00042	8b 4d f8	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  00045	e8 00 00 00 00	 call	 ?Release@CStringData@ATL@@QAEXXZ ; ATL::CStringData::Release

; 437  : 			CStringData* pNewData = pStringMgr->GetNilString();

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _pStringMgr$[ebp]
  0004d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _pStringMgr$[ebp]
  00052	ff 52 0c	 call	 DWORD PTR [edx+12]
  00055	89 45 f4	 mov	 DWORD PTR _pNewData$91719[ebp], eax

; 438  : 			Attach( pNewData );

  00058	8b 45 f4	 mov	 eax, DWORD PTR _pNewData$91719[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$L91713:

; 439  : 		}
; 440  : 	}

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ENDP		; ATL::CSimpleStringT<char,0>::Empty
_TEXT	ENDS
EXTRN	__imp__memmove:NEAR
; Function compile flags: /Odt
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped, COMDAT

; 656  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 657  : 		memmove( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00003	8b 45 10	 mov	 eax, DWORD PTR _nChars$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _pchSrc$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR _pchDest$[ebp]
  0000e	52		 push	 edx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 658  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::StringLength, COMDAT

; 677  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 678  : 		if( psz == NULL )

  00003	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  00007	75 04		 jne	 SHORT $L91723

; 679  : 		{
; 680  : 			return( 0 );

  00009	33 c0		 xor	 eax, eax
  0000b	eb 0c		 jmp	 SHORT $L91722
$L91723:

; 681  : 		}
; 682  : 		return( int( strlen( psz ) ) );

  0000d	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _strlen
  00016	83 c4 04	 add	 esp, 4
$L91722:

; 683  : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::StringLength
_TEXT	ENDS
PUBLIC	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Odt
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pOldData$ = -12					; size = 4
_nTooShort$ = -8					; size = 4
_nShared$ = -4						; size = 4
_nLength$ = 8						; size = 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite, COMDAT
; _this$ = ecx

; 734  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 735  : 		CStringData* pOldData = GetData();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00011	89 45 f4	 mov	 DWORD PTR _pOldData$[ebp], eax

; 736  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

  00014	8b 45 f4	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	2b 48 0c	 sub	 ecx, DWORD PTR [eax+12]
  0001f	89 4d fc	 mov	 DWORD PTR _nShared$[ebp], ecx

; 737  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

  00022	8b 55 f4	 mov	 edx, DWORD PTR _pOldData$[ebp]
  00025	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00028	2b 45 08	 sub	 eax, DWORD PTR _nLength$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _nTooShort$[ebp], eax

; 738  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _nShared$[ebp]
  00031	0b 4d f8	 or	 ecx, DWORD PTR _nTooShort$[ebp]
  00034	7d 0c		 jge	 SHORT $L91729

; 739  : 		{
; 740  : 			PrepareWrite2( nLength );

  00036	8b 55 08	 mov	 edx, DWORD PTR _nLength$[ebp]
  00039	52		 push	 edx
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L91729:

; 741  : 		}
; 742  : 
; 743  : 		return( m_pszData );

  00042	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]

; 744  : 	}

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ENDP ; ATL::CSimpleStringT<char,0>::PrepareWrite
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetLength, COMDAT
; _this$ = ecx

; 789  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 790  : 		ATLASSERT( nLength >= 0 );
; 791  : 		ATLASSERT( nLength <= GetData()->nAllocLength );
; 792  : 
; 793  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

  00007	83 7d 08 00	 cmp	 DWORD PTR _nLength$[ebp], 0
  0000b	7c 10		 jl	 SHORT $L91735
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00018	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0001b	7e 0a		 jle	 SHORT $L91734
$L91735:

; 794  : 			AtlThrow(E_INVALIDARG);

  0001d	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00022	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L91734:

; 795  : 			
; 796  : 		GetData()->nDataLength = nLength;

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  0002f	8b 55 08	 mov	 edx, DWORD PTR _nLength$[ebp]
  00032	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 797  : 		m_pszData[nLength] = 0;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR _nLength$[ebp]
  0003d	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0
$L95375:

; 798  : 	}

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetLength
_TEXT	ENDS
PUBLIC	?AtlFindStringResourceInstance@ATL@@YAPAUHINSTANCE__@@IG@Z ; ATL::AtlFindStringResourceInstance
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlstr.h
;	COMDAT ?FindStringResourceInstance@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_nID$ = 8						; size = 4
?FindStringResourceInstance@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUHINSTANCE__@@I@Z PROC NEAR ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance, COMDAT

; 948  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 949  : 		return( AtlFindStringResourceInstance( nID ) );

  00003	6a 00		 push	 0
  00005	8b 45 08	 mov	 eax, DWORD PTR _nID$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?AtlFindStringResourceInstance@ATL@@YAPAUHINSTANCE__@@IG@Z ; ATL::AtlFindStringResourceInstance
  0000e	83 c4 08	 add	 esp, 8

; 950  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?FindStringResourceInstance@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUHINSTANCE__@@I@Z ENDP ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
_TEXT	ENDS
PUBLIC	?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@IG@Z ; ATL::AtlGetStringResourceImage
EXTRN	?GetHInstanceAt@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@H@Z:NEAR ; ATL::CAtlBaseModule::GetHInstanceAt
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?AtlFindStringResourceInstance@ATL@@YAPAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT
tv70 = -16						; size = 4
_i$57643 = -12						; size = 4
_hInst$ = -8						; size = 4
_p$ = -4						; size = 4
_nID$ = 8						; size = 4
_wLanguage$ = 12					; size = 2
?AtlFindStringResourceInstance@ATL@@YAPAUHINSTANCE__@@IG@Z PROC NEAR ; ATL::AtlFindStringResourceInstance, COMDAT

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 381  : 	const ATLSTRINGRESOURCEIMAGE* p = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0

; 382  : 	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);

  0000d	6a 00		 push	 0
  0000f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
  00014	e8 00 00 00 00	 call	 ?GetHInstanceAt@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@H@Z ; ATL::CAtlBaseModule::GetHInstanceAt
  00019	89 45 f8	 mov	 DWORD PTR _hInst$[ebp], eax

; 383  : 
; 384  : 	for (int i = 1; hInst != NULL && p == NULL; hInst = _AtlBaseModule.GetHInstanceAt(i++))

  0001c	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$57643[ebp], 1
  00023	eb 20		 jmp	 SHORT $L57644
$L57645:
  00025	8b 45 f4	 mov	 eax, DWORD PTR _i$57643[ebp]
  00028	89 45 f0	 mov	 DWORD PTR tv70[ebp], eax
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR tv70[ebp]
  0002e	51		 push	 ecx
  0002f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
  00034	e8 00 00 00 00	 call	 ?GetHInstanceAt@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@H@Z ; ATL::CAtlBaseModule::GetHInstanceAt
  00039	89 45 f8	 mov	 DWORD PTR _hInst$[ebp], eax
  0003c	8b 55 f4	 mov	 edx, DWORD PTR _i$57643[ebp]
  0003f	83 c2 01	 add	 edx, 1
  00042	89 55 f4	 mov	 DWORD PTR _i$57643[ebp], edx
$L57644:
  00045	83 7d f8 00	 cmp	 DWORD PTR _hInst$[ebp], 0
  00049	74 2b		 je	 SHORT $L57646
  0004b	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0004f	75 25		 jne	 SHORT $L57646

; 385  : 	{
; 386  : 		p = AtlGetStringResourceImage(hInst, nID, wLanguage);

  00051	66 8b 45 0c	 mov	 ax, WORD PTR _wLanguage$[ebp]
  00055	50		 push	 eax
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _nID$[ebp]
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _hInst$[ebp]
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@IG@Z ; ATL::AtlGetStringResourceImage
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 387  : 		if (p != NULL)

  00069	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0006d	74 05		 je	 SHORT $L57647

; 388  : 			return hInst;

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _hInst$[ebp]
  00072	eb 04		 jmp	 SHORT $L57640
$L57647:

; 389  : 	}

  00074	eb af		 jmp	 SHORT $L57645
$L57646:

; 390  : 
; 391  : 	return NULL;

  00076	33 c0		 xor	 eax, eax
$L57640:

; 392  : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?AtlFindStringResourceInstance@ATL@@YAPAUHINSTANCE__@@IG@Z ENDP ; ATL::AtlFindStringResourceInstance
_TEXT	ENDS
EXTRN	__imp__FindResourceExA@16:NEAR
; Function compile flags: /Odt
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT
_hResource$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_id$ = 12						; size = 4
_wLanguage$ = 16					; size = 2
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@IG@Z PROC NEAR ; ATL::AtlGetStringResourceImage, COMDAT

; 293  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 294  : 	HRSRC hResource;
; 295  : 
; 296  : 	hResource = ::FindResourceEx( hInstance, RT_STRING, MAKEINTRESOURCE( ((id>>4)+1) ), wLanguage );

  00004	66 8b 45 10	 mov	 ax, WORD PTR _wLanguage$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _id$[ebp]
  0000c	c1 e9 04	 shr	 ecx, 4
  0000f	83 c1 01	 add	 ecx, 1
  00012	0f b7 d1	 movzx	 edx, cx
  00015	52		 push	 edx
  00016	6a 06		 push	 6
  00018	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceExA@16
  00022	89 45 fc	 mov	 DWORD PTR _hResource$[ebp], eax

; 297  : 	if( hResource == NULL )

  00025	83 7d fc 00	 cmp	 DWORD PTR _hResource$[ebp], 0
  00029	75 04		 jne	 SHORT $L57553

; 298  : 	{
; 299  : 		return( NULL );

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 14		 jmp	 SHORT $L57545
$L57553:

; 300  : 	}
; 301  : 
; 302  : 	return _AtlGetStringResourceImage( hInstance, hResource, id );

  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _id$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 fc	 mov	 edx, DWORD PTR _hResource$[ebp]
  00036	52		 push	 edx
  00037	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
$L57545:

; 303  : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@IG@Z ENDP ; ATL::AtlGetStringResourceImage
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc 49 92
	24 09		 mov	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L95384
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L95385
$L95384:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L95385:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
_TEXT	ENDS
PUBLIC	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Reallocate
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nNewLength$91839 = -8					; size = 4
_pOldData$ = -4						; size = 4
_nLength$ = 8						; size = 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite2, COMDAT
; _this$ = ecx

; 746  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		CStringData* pOldData = GetData();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00011	89 45 fc	 mov	 DWORD PTR _pOldData$[ebp], eax

; 748  : 		if( pOldData->nDataLength > nLength )

  00014	8b 45 fc	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	3b 4d 08	 cmp	 ecx, DWORD PTR _nLength$[ebp]
  0001d	7e 09		 jle	 SHORT $L91835

; 749  : 		{
; 750  : 			nLength = pOldData->nDataLength;

  0001f	8b 55 fc	 mov	 edx, DWORD PTR _pOldData$[ebp]
  00022	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00025	89 45 08	 mov	 DWORD PTR _nLength$[ebp], eax
$L91835:

; 751  : 		}
; 752  : 		if( pOldData->IsShared() )

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  0002b	e8 00 00 00 00	 call	 ?IsShared@CStringData@ATL@@QBE_NXZ ; ATL::CStringData::IsShared
  00030	0f b6 c8	 movzx	 ecx, al
  00033	85 c9		 test	 ecx, ecx
  00035	74 0e		 je	 SHORT $L91836

; 753  : 		{
; 754  : 			Fork( nLength );

  00037	8b 55 08	 mov	 edx, DWORD PTR _nLength$[ebp]
  0003a	52		 push	 edx
  0003b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork

; 755  : 		}
; 756  : 		else if( pOldData->nAllocLength < nLength )

  00043	eb 4d		 jmp	 SHORT $L91833
$L91836:
  00045	8b 45 fc	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00048	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004b	3b 4d 08	 cmp	 ecx, DWORD PTR _nLength$[ebp]
  0004e	7d 42		 jge	 SHORT $L91833

; 757  : 		{
; 758  : 			// Grow exponentially, until we hit 1K.
; 759  : 			int nNewLength = pOldData->nAllocLength;

  00050	8b 55 fc	 mov	 edx, DWORD PTR _pOldData$[ebp]
  00053	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00056	89 45 f8	 mov	 DWORD PTR _nNewLength$91839[ebp], eax

; 760  : 			if( nNewLength > 1024 )

  00059	81 7d f8 00 04
	00 00		 cmp	 DWORD PTR _nNewLength$91839[ebp], 1024 ; 00000400H
  00060	7e 0e		 jle	 SHORT $L91840

; 761  : 			{
; 762  : 				nNewLength += 1024;

  00062	8b 4d f8	 mov	 ecx, DWORD PTR _nNewLength$91839[ebp]
  00065	81 c1 00 04 00
	00		 add	 ecx, 1024		; 00000400H
  0006b	89 4d f8	 mov	 DWORD PTR _nNewLength$91839[ebp], ecx

; 763  : 			}
; 764  : 			else

  0006e	eb 08		 jmp	 SHORT $L91841
$L91840:

; 765  : 			{
; 766  : 				nNewLength *= 2;

  00070	8b 55 f8	 mov	 edx, DWORD PTR _nNewLength$91839[ebp]
  00073	d1 e2		 shl	 edx, 1
  00075	89 55 f8	 mov	 DWORD PTR _nNewLength$91839[ebp], edx
$L91841:

; 767  : 			}
; 768  : 			if( nNewLength < nLength )

  00078	8b 45 f8	 mov	 eax, DWORD PTR _nNewLength$91839[ebp]
  0007b	3b 45 08	 cmp	 eax, DWORD PTR _nLength$[ebp]
  0007e	7d 06		 jge	 SHORT $L91842

; 769  : 			{
; 770  : 				nNewLength = nLength;

  00080	8b 4d 08	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00083	89 4d f8	 mov	 DWORD PTR _nNewLength$91839[ebp], ecx
$L91842:

; 771  : 			}
; 772  : 			Reallocate( nNewLength );

  00086	8b 55 f8	 mov	 edx, DWORD PTR _nNewLength$91839[ebp]
  00089	52		 push	 edx
  0008a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Reallocate
$L91833:

; 773  : 		}
; 774  : 	}

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z
_TEXT	SEGMENT
_pszSource$ = 8						; size = 4
_nLength$ = 12						; size = 4
?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z PROC NEAR ; ATL::ChTraitsCRT<char>::GetBaseTypeLength, COMDAT

; 436  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 437  : 		// Returns required buffer length in XCHARs
; 438  : 		return ::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSource, nLength, NULL, 0, NULL, NULL );

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pszSource$[ebp]
  00012	51		 push	 ecx
  00013	6a 00		 push	 0
  00015	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 439  : 	}

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z ENDP	; ATL::ChTraitsCRT<char>::GetBaseTypeLength
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z
_TEXT	SEGMENT
_pszDest$ = 8						; size = 4
_nDestLength$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nSrcLength$ = 20					; size = 4
?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z PROC NEAR ; ATL::ChTraitsCRT<char>::ConvertToBaseType, COMDAT

; 451  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 452  : 		// nLen is in XCHARs
; 453  : 		::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength, NULL, NULL );

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	8b 45 0c	 mov	 eax, DWORD PTR _nDestLength$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pszDest$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 14	 mov	 edx, DWORD PTR _nSrcLength$[ebp]
  00012	52		 push	 edx
  00013	8b 45 10	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 454  : 	}

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z ENDP ; ATL::ChTraitsCRT<char>::ConvertToBaseType
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pOldData$ = -12					; size = 4
_pStringMgr$ = -8					; size = 4
_pNewData$ = -4						; size = 4
_nLength$ = 8						; size = 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Reallocate, COMDAT
; _this$ = ecx

; 776  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		CStringData* pOldData = GetData();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00011	89 45 f4	 mov	 DWORD PTR _pOldData$[ebp], eax

; 778  : 		ATLASSERT( pOldData->nAllocLength < nLength );
; 779  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;

  00014	8b 45 f4	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	89 4d f8	 mov	 DWORD PTR _pStringMgr$[ebp], ecx

; 780  : 		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );

  0001c	6a 01		 push	 1
  0001e	8b 55 08	 mov	 edx, DWORD PTR _nLength$[ebp]
  00021	52		 push	 edx
  00022	8b 45 f4	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00025	50		 push	 eax
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _pStringMgr$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _pStringMgr$[ebp]
  0002e	ff 52 08	 call	 DWORD PTR [edx+8]
  00031	89 45 fc	 mov	 DWORD PTR _pNewData$[ebp], eax

; 781  : 		if( pNewData == NULL )

  00034	83 7d fc 00	 cmp	 DWORD PTR _pNewData$[ebp], 0
  00038	75 05		 jne	 SHORT $L91875

; 782  : 		{
; 783  : 			ThrowMemoryException();

  0003a	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L91875:

; 784  : 		}
; 785  : 		Attach( pNewData );

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _pNewData$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$L95393:

; 786  : 	}

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::Reallocate
_TEXT	ENDS
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T95404	DD	0ffffffffH
	DD	FLAT:$L95398
	DD	00H
	DD	FLAT:$L95397
$T95402	DD	019930520H
	DD	02H
	DD	FLAT:$T95404
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T95399 = -44						; size = 4
$T95396 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T95399[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T95396[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T95399[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T95399[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T95396[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95397:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T95396[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95398:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T95399[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L95400
  00015	83 65 d4 fe	 and	 DWORD PTR $T95399[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95400:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95402
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95417	DD	0ffffffffH
	DD	FLAT:$L95411
	DD	00H
	DD	FLAT:$L95410
$T95415	DD	019930520H
	DD	02H
	DD	FLAT:$T95417
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T95412 = -44						; size = 4
$T95409 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T95412[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T95409[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T95412[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T95412[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T95409[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95410:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T95409[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95411:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T95412[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L95413
  00015	83 65 d4 fe	 and	 DWORD PTR $T95412[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95413:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95415
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95430	DD	0ffffffffH
	DD	FLAT:$L95424
	DD	00H
	DD	FLAT:$L95423
$T95428	DD	019930520H
	DD	02H
	DD	FLAT:$T95430
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T95425 = -44						; size = 4
$T95422 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 1
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T95425[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00022	8a 45 0c	 mov	 al, BYTE PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	6a 01		 push	 1
  00028	8d 4d d8	 lea	 ecx, DWORD PTR $T95422[ebp]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
  00031	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  00034	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00037	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  0003a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00041	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00044	52		 push	 edx
  00045	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00058	8b 45 d4	 mov	 eax, DWORD PTR $T95425[ebp]
  0005b	83 c8 01	 or	 eax, 1
  0005e	89 45 d4	 mov	 DWORD PTR $T95425[ebp], eax
  00061	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00065	8d 4d d8	 lea	 ecx, DWORD PTR $T95422[ebp]
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95423:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T95422[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95424:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T95425[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L95426
  00015	83 65 d4 fe	 and	 DWORD PTR $T95425[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95426:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95428
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95443	DD	0ffffffffH
	DD	FLAT:$L95437
	DD	00H
	DD	FLAT:$L95436
$T95441	DD	019930520H
	DD	02H
	DD	FLAT:$T95443
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T95438 = -44						; size = 4
$T95435 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T95438[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T95435[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T95438[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T95438[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T95435[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95436:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T95435[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95437:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T95438[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L95439
  00015	83 65 d4 fe	 and	 DWORD PTR $T95438[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95439:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95441
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95456	DD	0ffffffffH
	DD	FLAT:$L95450
	DD	00H
	DD	FLAT:$L95449
$T95454	DD	019930520H
	DD	02H
	DD	FLAT:$T95456
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T95451 = -44						; size = 4
$T95448 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T95451[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T95448[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8a 55 10	 mov	 dl, BYTE PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T95451[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T95451[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T95448[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95449:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T95448[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95450:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T95451[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L95452
  00015	83 65 d4 fe	 and	 DWORD PTR $T95451[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L95452:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95454
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95469	DD	0ffffffffH
	DD	FLAT:$L95463
	DD	00H
	DD	FLAT:$L95462
$T95467	DD	019930520H
	DD	02H
	DD	FLAT:$T95469
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T95464 = -44						; size = 4
$T95461 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T95464[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T95461[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T95464[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T95464[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T95461[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95462:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T95461[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L95463:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T95464[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L95465
  00015	83 65 d4 fe	 and	 DWORD PTR $T95464[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L95465:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95467
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95482	DD	0ffffffffH
	DD	FLAT:$L95476
	DD	00H
	DD	FLAT:$L95475
$T95480	DD	019930520H
	DD	02H
	DD	FLAT:$T95482
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T95477 = -44						; size = 4
$T95474 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T95477[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T95474[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T95477[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T95477[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T95474[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95475:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T95474[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L95476:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T95477[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L95478
  00015	83 65 d4 fe	 and	 DWORD PTR $T95477[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L95478:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95480
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95495	DD	0ffffffffH
	DD	FLAT:$L95489
	DD	00H
	DD	FLAT:$L95488
$T95493	DD	019930520H
	DD	02H
	DD	FLAT:$T95495
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T95490 = -44						; size = 4
$T95487 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 2
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T95490[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00022	66 8b 45 0c	 mov	 ax, WORD PTR __Left$[ebp]
  00026	50		 push	 eax
  00027	6a 01		 push	 1
  00029	8d 4d d8	 lea	 ecx, DWORD PTR $T95487[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
  00032	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  00035	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00038	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  0003b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00042	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00045	52		 push	 edx
  00046	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00059	8b 45 d4	 mov	 eax, DWORD PTR $T95490[ebp]
  0005c	83 c8 01	 or	 eax, 1
  0005f	89 45 d4	 mov	 DWORD PTR $T95490[ebp], eax
  00062	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00066	8d 4d d8	 lea	 ecx, DWORD PTR $T95487[ebp]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95488:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T95487[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L95489:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T95490[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L95491
  00015	83 65 d4 fe	 and	 DWORD PTR $T95490[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L95491:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95493
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95508	DD	0ffffffffH
	DD	FLAT:$L95502
	DD	00H
	DD	FLAT:$L95501
$T95506	DD	019930520H
	DD	02H
	DD	FLAT:$T95508
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T95503 = -44						; size = 4
$T95500 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T95503[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T95500[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T95503[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T95503[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T95500[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95501:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T95500[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L95502:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T95503[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L95504
  00015	83 65 d4 fe	 and	 DWORD PTR $T95503[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L95504:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95506
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95521	DD	0ffffffffH
	DD	FLAT:$L95515
	DD	00H
	DD	FLAT:$L95514
$T95519	DD	019930520H
	DD	02H
	DD	FLAT:$T95521
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T95516 = -44						; size = 4
$T95513 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 2
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T95516[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T95513[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	66 8b 55 10	 mov	 dx, WORD PTR __Right$[ebp]
  00043	52		 push	 edx
  00044	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00057	8b 45 d4	 mov	 eax, DWORD PTR $T95516[ebp]
  0005a	83 c8 01	 or	 eax, 1
  0005d	89 45 d4	 mov	 DWORD PTR $T95516[ebp], eax
  00060	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00064	8d 4d d8	 lea	 ecx, DWORD PTR $T95513[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95514:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T95513[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L95515:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T95516[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L95517
  00015	83 65 d4 fe	 and	 DWORD PTR $T95516[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L95517:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95519
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
EXTRN	__imp_??1locale@std@@QAE@XZ:NEAR
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?width@ios_base@std@@QBEHXZ:NEAR
EXTRN	__imp_?width@ios_base@std@@QAEHH@Z:NEAR
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:NEAR
EXTRN	__imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z:NEAR
EXTRN	__imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?is@?$ctype@D@std@@QBE_NFD@Z:NEAR
EXTRN	__imp_?to_char_type@?$char_traits@D@std@@SADABH@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@D@std@@SAHXZ:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95538	DD	0ffffffffH
	DD	FLAT:$L95533
	DD	00H
	DD	FLAT:$L95534
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T95540	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L95532
$T95539	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T95540
$T95536	DD	019930520H
	DD	04H
	DD	FLAT:$T95538
	DD	01H
	DD	FLAT:$T95539
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv205 = -112						; size = 1
tv204 = -111						; size = 1
tv203 = -110						; size = 1
tv202 = -109						; size = 1
tv201 = -108						; size = 4
tv200 = -104						; size = 4
tv199 = -100						; size = 4
tv198 = -96						; size = 4
tv197 = -92						; size = 4
tv196 = -88						; size = 4
tv135 = -84						; size = 4
tv195 = -80						; size = 4
tv194 = -76						; size = 4
tv193 = -72						; size = 4
tv192 = -68						; size = 4
tv189 = -64						; size = 4
tv65 = -60						; size = 4
$T95530 = -56						; size = 4
$T95529 = -52						; size = 4
$T95526 = -48						; size = 4
__Meta$92104 = -44					; size = 4
__Size$92101 = -40					; size = 4
__Ctype_fac$92098 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 dc 01 00
	00		 je	 $L95531

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00055	8d 55 d0	 lea	 edx, DWORD PTR $T95526[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00061	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00064	8b ca		 mov	 ecx, edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0006c	89 45 c4	 mov	 DWORD PTR tv65[ebp], eax
  0006f	8b 45 c4	 mov	 eax, DWORD PTR tv65[ebp]
  00072	89 45 c0	 mov	 DWORD PTR tv189[ebp], eax
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00079	8b 4d c0	 mov	 ecx, DWORD PTR tv189[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 dc	 mov	 DWORD PTR __Ctype_fac$92098[ebp], eax
  00088	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0008c	8d 4d d0	 lea	 ecx, DWORD PTR $T95526[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	50		 push	 eax
  0009e	6a 00		 push	 0
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000a9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000be	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  000c1	83 7d bc 00	 cmp	 DWORD PTR tv192[ebp], 0
  000c5	7e 46		 jle	 SHORT $L95527
  000c7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000d2	8b ca		 mov	 ecx, edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000da	89 45 b8	 mov	 DWORD PTR tv193[ebp], eax
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  000e6	89 45 b4	 mov	 DWORD PTR tv194[ebp], eax
  000e9	8b 45 b8	 mov	 eax, DWORD PTR tv193[ebp]
  000ec	3b 45 b4	 cmp	 eax, DWORD PTR tv194[ebp]
  000ef	73 1c		 jae	 SHORT $L95527
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f9	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00102	89 45 b0	 mov	 DWORD PTR tv195[ebp], eax
  00105	8b 45 b0	 mov	 eax, DWORD PTR tv195[ebp]
  00108	89 45 ac	 mov	 DWORD PTR tv135[ebp], eax
  0010b	eb 12		 jmp	 SHORT $L95528
$L95527:
  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00116	89 45 a8	 mov	 DWORD PTR tv196[ebp], eax
  00119	8b 4d a8	 mov	 ecx, DWORD PTR tv196[ebp]
  0011c	89 4d ac	 mov	 DWORD PTR tv135[ebp], ecx
$L95528:
  0011f	8b 55 ac	 mov	 edx, DWORD PTR tv135[ebp]
  00122	89 55 d8	 mov	 DWORD PTR __Size$92101[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00125	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0012d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00130	8b ca		 mov	 ecx, edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00138	89 45 a4	 mov	 DWORD PTR tv197[ebp], eax
  0013b	8b 4d a4	 mov	 ecx, DWORD PTR tv197[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00144	89 45 a0	 mov	 DWORD PTR tv198[ebp], eax
  00147	8b 45 a0	 mov	 eax, DWORD PTR tv198[ebp]
  0014a	89 45 d4	 mov	 DWORD PTR __Meta$92104[ebp], eax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  0014d	eb 2f		 jmp	 SHORT $L92105
$L92106:
  0014f	8b 4d d8	 mov	 ecx, DWORD PTR __Size$92101[ebp]
  00152	83 e9 01	 sub	 ecx, 1
  00155	89 4d d8	 mov	 DWORD PTR __Size$92101[ebp], ecx
  00158	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0015b	8b 02		 mov	 eax, DWORD PTR [edx]
  0015d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00160	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00169	89 45 9c	 mov	 DWORD PTR tv199[ebp], eax
  0016c	8b 4d 9c	 mov	 ecx, DWORD PTR tv199[ebp]
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00175	89 45 98	 mov	 DWORD PTR tv200[ebp], eax
  00178	8b 4d 98	 mov	 ecx, DWORD PTR tv200[ebp]
  0017b	89 4d d4	 mov	 DWORD PTR __Meta$92104[ebp], ecx
$L92105:
  0017e	83 7d d8 00	 cmp	 DWORD PTR __Size$92101[ebp], 0
  00182	0f 86 8a 00 00
	00		 jbe	 $L92107

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0018e	89 45 94	 mov	 DWORD PTR tv201[ebp], eax
  00191	8b 55 94	 mov	 edx, DWORD PTR tv201[ebp]
  00194	89 55 cc	 mov	 DWORD PTR $T95529[ebp], edx
  00197	8d 45 d4	 lea	 eax, DWORD PTR __Meta$92104[ebp]
  0019a	50		 push	 eax
  0019b	8d 4d cc	 lea	 ecx, DWORD PTR $T95529[ebp]
  0019e	51		 push	 ecx
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  001a5	83 c4 08	 add	 esp, 8
  001a8	88 45 93	 mov	 BYTE PTR tv202[ebp], al
  001ab	0f b6 55 93	 movzx	 edx, BYTE PTR tv202[ebp]
  001af	85 d2		 test	 edx, edx
  001b1	74 0b		 je	 SHORT $L92109

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  001b3	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001b6	83 c8 01	 or	 eax, 1
  001b9	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  001bc	eb 54		 jmp	 SHORT $L92107
$L92109:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  001be	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$92104[ebp]
  001c1	51		 push	 ecx
  001c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  001c8	83 c4 04	 add	 esp, 4
  001cb	88 45 92	 mov	 BYTE PTR tv203[ebp], al
  001ce	8a 55 92	 mov	 dl, BYTE PTR tv203[ebp]
  001d1	52		 push	 edx
  001d2	6a 48		 push	 72			; 00000048H
  001d4	8b 4d dc	 mov	 ecx, DWORD PTR __Ctype_fac$92098[ebp]
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@D@std@@QBE_NFD@Z
  001dd	88 45 91	 mov	 BYTE PTR tv204[ebp], al
  001e0	0f b6 45 91	 movzx	 eax, BYTE PTR tv204[ebp]
  001e4	85 c0		 test	 eax, eax
  001e6	74 02		 je	 SHORT $L92111

; 454  : 				break;	// whitespace, quit

  001e8	eb 28		 jmp	 SHORT $L92107
$L92111:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  001ea	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$92104[ebp]
  001ed	51		 push	 ecx
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  001f4	83 c4 04	 add	 esp, 4
  001f7	88 45 90	 mov	 BYTE PTR tv205[ebp], al
  001fa	8a 55 90	 mov	 dl, BYTE PTR tv205[ebp]
  001fd	52		 push	 edx
  001fe	6a 01		 push	 1
  00200	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z

; 458  : 				_Changed = true;

  00209	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  0020d	e9 3d ff ff ff	 jmp	 $L92106
$L92107:
  00212	eb 1d		 jmp	 SHORT $L95531
$L95532:

; 460  : 		_CATCH_IO_(_Istr)

  00214	6a 01		 push	 1
  00216	6a 04		 push	 4
  00218	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0021b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00220	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00223	8b ca		 mov	 ecx, edx
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0022b	b8 00 00 00 00	 mov	 eax, $L95531
  00230	c3		 ret	 0
$L95531:
  00231	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  00238	6a 00		 push	 0
  0023a	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0023d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023f	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00242	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00245	8b ca		 mov	 ecx, edx
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z

; 464  : 	if (!_Changed)

  0024d	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  00251	85 c0		 test	 eax, eax
  00253	75 09		 jne	 SHORT $L92113

; 465  : 		_State |= ios_base::failbit;

  00255	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00258	83 c9 02	 or	 ecx, 2
  0025b	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L92113:

; 466  : 	_Istr.setstate(_State);

  0025e	6a 00		 push	 0
  00260	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00263	52		 push	 edx
  00264	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00267	8b 08		 mov	 ecx, DWORD PTR [eax]
  00269	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0026c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0026f	8b ca		 mov	 ecx, edx
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 467  : 	return (_Istr);

  00277	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0027a	89 45 c8	 mov	 DWORD PTR $T95530[ebp], eax
  0027d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00284	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00287	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0028c	8b 45 c8	 mov	 eax, DWORD PTR $T95530[ebp]

; 468  : 	}

  0028f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00292	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00299	5f		 pop	 edi
  0029a	5e		 pop	 esi
  0029b	5b		 pop	 ebx
  0029c	8b e5		 mov	 esp, ebp
  0029e	5d		 pop	 ebp
  0029f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95533:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
$L95534:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T95526[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95536
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T95552	DD	0ffffffffH
	DD	FLAT:$L95548
$T95550	DD	019930520H
	DD	01H
	DD	FLAT:$T95552
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0002f	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95548:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95550
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L89739

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L89739:

; 61   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L91252

; 54   : 				_Myistr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L91252:

; 55   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@@
PUBLIC	__CTA2?AVbad_cast@@
PUBLIC	??_R0?AVbad_cast@@@8				; bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:NEAR
EXTRN	__imp_?_Incref@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Register@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:NEAR
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:NEAR
EXTRN	__imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z:NEAR
EXTRN	__imp_??0bad_cast@@QAE@PBD@Z:NEAR
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
EXTRN	??0bad_cast@@QAE@ABV0@@Z:NEAR			; bad_cast::bad_cast
EXTRN	??1bad_cast@@UAE@XZ:NEAR			; bad_cast::~bad_cast
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95569	DD	0ffffffffH
	DD	FLAT:$L95565
$T95567	DD	019930520H
	DD	01H
	DD	FLAT:$T95569
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT
__TI2?AVbad_cast@@ DD 00H
	DD	FLAT:??1bad_cast@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@@@8 DD FLAT:??_7type_info@@6B@		; bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T95564 = -48						; size = 4
$T95563 = -44						; size = 12
__Pfmod$92027 = -32					; size = 4
__Psave$ = -28						; size = 4
__Lock$ = -24						; size = 4
__Id$ = -20						; size = 4
__Pf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<char> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 24	 sub	 esp, 36			; 00000024H

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	6a 00		 push	 0
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  00032	89 45 e4	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00041	89 45 ec	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00044	8b 4d ec	 mov	 ecx, DWORD PTR __Id$[ebp]
  00047	51		 push	 ecx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00051	89 45 f0	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00054	83 7d f0 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00058	74 02		 je	 SHORT $L92013

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  0005a	eb 62		 jmp	 SHORT $L92014
$L92013:
  0005c	83 7d e4 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  00060	74 08		 je	 SHORT $L92015

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00062	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  00065	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00068	eb 54		 jmp	 SHORT $L92014
$L92015:
  0006a	8d 45 e4	 lea	 eax, DWORD PTR __Psave$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
  00074	83 c4 04	 add	 esp, 4
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	75 1c		 jne	 SHORT $L92018

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  00081	8d 4d d4	 lea	 ecx, DWORD PTR $T95563[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  0008f	8d 4d d4	 lea	 ecx, DWORD PTR $T95563[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 __CxxThrowException@8
$L92018:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  00098	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  0009b	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Psave$[ebp]
  000a1	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000a6	8b 4d e4	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000a9	89 4d e0	 mov	 DWORD PTR __Pfmod$92027[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ac	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$92027[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$92027[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L92014:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000be	8b 55 f0	 mov	 edx, DWORD PTR __Pf$[ebp]
  000c1	89 55 d0	 mov	 DWORD PTR $T95564[ebp], edx
  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d4	8b 45 d0	 mov	 eax, DWORD PTR $T95564[ebp]
$L95562:

; 347  : 	}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95565:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95567
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00003	6a 0a		 push	 10			; 0000000aH
  00005	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0000d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00010	8b ca		 mov	 ecx, edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00018	50		 push	 eax
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z:NEAR
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95585	DD	0ffffffffH
	DD	FLAT:$L95581
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T95587	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L95580
$T95586	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T95587
$T95583	DD	019930520H
	DD	03H
	DD	FLAT:$T95585
	DD	01H
	DD	FLAT:$T95586
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
tv175 = -89						; size = 1
tv174 = -88						; size = 4
tv173 = -84						; size = 4
tv172 = -80						; size = 4
tv171 = -74						; size = 1
tv170 = -73						; size = 1
tv169 = -72						; size = 4
tv168 = -68						; size = 4
tv167 = -64						; size = 4
tv166 = -60						; size = 4
tv165 = -56						; size = 4
tv65 = -52						; size = 4
$T95578 = -48						; size = 4
$T95577 = -44						; size = 4
__Meta$92124 = -40					; size = 4
__Metadelim$92123 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 66 01 00
	00		 je	 $L95579

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  0006d	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z
  00077	83 c4 04	 add	 esp, 4
  0007a	89 45 cc	 mov	 DWORD PTR tv65[ebp], eax
  0007d	8b 55 cc	 mov	 edx, DWORD PTR tv65[ebp]
  00080	89 55 dc	 mov	 DWORD PTR __Metadelim$92123[ebp], edx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00083	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0008b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0008e	8b ca		 mov	 ecx, edx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00096	89 45 c8	 mov	 DWORD PTR tv165[ebp], eax
  00099	8b 4d c8	 mov	 ecx, DWORD PTR tv165[ebp]
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000a2	89 45 c4	 mov	 DWORD PTR tv166[ebp], eax
  000a5	8b 45 c4	 mov	 eax, DWORD PTR tv166[ebp]
  000a8	89 45 d8	 mov	 DWORD PTR __Meta$92124[ebp], eax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000ab	eb 26		 jmp	 SHORT $L92125
$L92126:
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000be	89 45 c0	 mov	 DWORD PTR tv167[ebp], eax
  000c1	8b 4d c0	 mov	 ecx, DWORD PTR tv167[ebp]
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000ca	89 45 bc	 mov	 DWORD PTR tv168[ebp], eax
  000cd	8b 45 bc	 mov	 eax, DWORD PTR tv168[ebp]
  000d0	89 45 d8	 mov	 DWORD PTR __Meta$92124[ebp], eax
$L92125:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  000d9	89 45 b8	 mov	 DWORD PTR tv169[ebp], eax
  000dc	8b 4d b8	 mov	 ecx, DWORD PTR tv169[ebp]
  000df	89 4d d4	 mov	 DWORD PTR $T95577[ebp], ecx
  000e2	8d 55 d8	 lea	 edx, DWORD PTR __Meta$92124[ebp]
  000e5	52		 push	 edx
  000e6	8d 45 d4	 lea	 eax, DWORD PTR $T95577[ebp]
  000e9	50		 push	 eax
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  000f0	83 c4 08	 add	 esp, 8
  000f3	88 45 b7	 mov	 BYTE PTR tv170[ebp], al
  000f6	0f b6 4d b7	 movzx	 ecx, BYTE PTR tv170[ebp]
  000fa	85 c9		 test	 ecx, ecx
  000fc	74 0e		 je	 SHORT $L92129

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  000fe	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00101	83 ca 01	 or	 edx, 1
  00104	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  00107	e9 92 00 00 00	 jmp	 $L92127
$L92129:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  0010c	8d 45 dc	 lea	 eax, DWORD PTR __Metadelim$92123[ebp]
  0010f	50		 push	 eax
  00110	8d 4d d8	 lea	 ecx, DWORD PTR __Meta$92124[ebp]
  00113	51		 push	 ecx
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  0011a	83 c4 08	 add	 esp, 8
  0011d	88 45 b6	 mov	 BYTE PTR tv171[ebp], al
  00120	0f b6 55 b6	 movzx	 edx, BYTE PTR tv171[ebp]
  00124	85 d2		 test	 edx, edx
  00126	74 25		 je	 SHORT $L92131

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00128	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  0012c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00134	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00137	8b ca		 mov	 ecx, edx
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0013f	89 45 b0	 mov	 DWORD PTR tv172[ebp], eax
  00142	8b 4d b0	 mov	 ecx, DWORD PTR tv172[ebp]
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ

; 501  : 				break;

  0014b	eb 51		 jmp	 SHORT $L92127
$L92131:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  0014d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00156	89 45 ac	 mov	 DWORD PTR tv173[ebp], eax
  00159	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00162	89 45 a8	 mov	 DWORD PTR tv174[ebp], eax
  00165	8b 45 ac	 mov	 eax, DWORD PTR tv173[ebp]
  00168	3b 45 a8	 cmp	 eax, DWORD PTR tv174[ebp]
  0016b	77 0b		 ja	 SHORT $L92133

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  0016d	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00170	83 c9 02	 or	 ecx, 2
  00173	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  00176	eb 26		 jmp	 SHORT $L92127
$L92133:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  00178	8d 55 d8	 lea	 edx, DWORD PTR __Meta$92124[ebp]
  0017b	52		 push	 edx
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  00182	83 c4 04	 add	 esp, 4
  00185	88 45 a7	 mov	 BYTE PTR tv175[ebp], al
  00188	8a 45 a7	 mov	 al, BYTE PTR tv175[ebp]
  0018b	50		 push	 eax
  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z

; 511  : 				_Changed = true;

  00195	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  00199	e9 0f ff ff ff	 jmp	 $L92126
$L92127:
  0019e	eb 1b		 jmp	 SHORT $L95579
$L95580:

; 513  : 		_CATCH_IO_(_Istr)

  001a0	6a 01		 push	 1
  001a2	6a 04		 push	 4
  001a4	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a9	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001ac	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001b5	b8 00 00 00 00	 mov	 eax, $L95579
  001ba	c3		 ret	 0
$L95579:
  001bb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  001c2	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $L92135

; 517  : 		_State |= ios_base::failbit;

  001ca	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001cd	83 c9 02	 or	 ecx, 2
  001d0	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L92135:

; 518  : 	_Istr.setstate(_State);

  001d3	6a 00		 push	 0
  001d5	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001d8	52		 push	 edx
  001d9	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001de	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001e1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001e4	8b ca		 mov	 ecx, edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 519  : 	return (_Istr);

  001ec	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001ef	89 45 d0	 mov	 DWORD PTR $T95578[ebp], eax
  001f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001f9	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  001fc	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00201	8b 45 d0	 mov	 eax, DWORD PTR $T95578[ebp]

; 520  : 	}

  00204	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00207	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	5b		 pop	 ebx
  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95581:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95583
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:NEAR
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:NEAR
EXTRN	__imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z:NEAR
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95607	DD	0ffffffffH
	DD	FLAT:$L95603
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T95609	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L95602
$T95608	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T95609
$T95605	DD	019930520H
	DD	03H
	DD	FLAT:$T95607
	DD	01H
	DD	FLAT:$T95608
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv221 = -129						; size = 1
tv220 = -128						; size = 4
tv219 = -124						; size = 4
tv218 = -120						; size = 4
tv217 = -114						; size = 1
tv216 = -113						; size = 1
tv215 = -112						; size = 4
tv214 = -108						; size = 4
tv213 = -104						; size = 4
tv212 = -100						; size = 4
tv211 = -93						; size = 1
tv210 = -92						; size = 4
tv209 = -88						; size = 4
tv208 = -84						; size = 4
tv207 = -77						; size = 1
tv83 = -76						; size = 4
tv81 = -72						; size = 4
$T95600 = -68						; size = 4
$T95599 = -64						; size = 4
$T95598 = -60						; size = 4
$T95597 = -56						; size = 4
$T95596 = -52						; size = 4
$T95595 = -48						; size = 4
$T95594 = -44						; size = 4
__Count$92158 = -40					; size = 4
__Size$ = -36						; size = 4
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 74	 sub	 esp, 116		; 00000074H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00032	89 45 dc	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0003d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00040	8b ca		 mov	 ecx, edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00048	85 c0		 test	 eax, eax
  0004a	7e 33		 jle	 SHORT $L95592
  0004c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00054	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00057	8b ca		 mov	 ecx, edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0005f	3b 45 dc	 cmp	 eax, DWORD PTR __Size$[ebp]
  00062	76 1b		 jbe	 SHORT $L95592
  00064	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00077	2b 45 dc	 sub	 eax, DWORD PTR __Size$[ebp]
  0007a	89 45 b8	 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 07		 jmp	 SHORT $L95593
$L95592:
  0007f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L95593:
  00086	8b 45 b8	 mov	 eax, DWORD PTR tv81[ebp]
  00089	89 45 e8	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008f	51		 push	 ecx
  00090	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00093	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  0009f	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000a2	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000a7	0f b6 d0	 movzx	 edx, al
  000aa	85 d2		 test	 edx, edx
  000ac	75 0e		 jne	 SHORT $L92147

; 550  : 		_State |= ios_base::badbit;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000b1	83 c8 04	 or	 eax, 4
  000b4	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000b7	e9 22 02 00 00	 jmp	 $L95601
$L92147:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  000d1	89 45 b4	 mov	 DWORD PTR tv83[ebp], eax
  000d4	8b 45 b4	 mov	 eax, DWORD PTR tv83[ebp]
  000d7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000dc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000df	0f 84 8a 00 00
	00		 je	 $L92150

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000e5	eb 09		 jmp	 SHORT $L92151
$L92152:
  000e7	8b 4d e8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  000ea	83 e9 01	 sub	 ecx, 1
  000ed	89 4d e8	 mov	 DWORD PTR __Pad$[ebp], ecx
$L92151:
  000f0	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  000f4	76 79		 jbe	 SHORT $L92150

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  000f6	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000f9	8b 02		 mov	 eax, DWORD PTR [edx]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000fe	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  00107	88 45 b3	 mov	 BYTE PTR tv207[ebp], al
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0010d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00112	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0011b	89 45 ac	 mov	 DWORD PTR tv208[ebp], eax
  0011e	8a 45 b3	 mov	 al, BYTE PTR tv207[ebp]
  00121	50		 push	 eax
  00122	8b 4d ac	 mov	 ecx, DWORD PTR tv208[ebp]
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0012b	89 45 a8	 mov	 DWORD PTR tv209[ebp], eax
  0012e	8b 4d a8	 mov	 ecx, DWORD PTR tv209[ebp]
  00131	89 4d d4	 mov	 DWORD PTR $T95594[ebp], ecx
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0013a	89 45 a4	 mov	 DWORD PTR tv210[ebp], eax
  0013d	8b 55 a4	 mov	 edx, DWORD PTR tv210[ebp]
  00140	89 55 d0	 mov	 DWORD PTR $T95595[ebp], edx
  00143	8d 45 d4	 lea	 eax, DWORD PTR $T95594[ebp]
  00146	50		 push	 eax
  00147	8d 4d d0	 lea	 ecx, DWORD PTR $T95595[ebp]
  0014a	51		 push	 ecx
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00151	83 c4 08	 add	 esp, 8
  00154	88 45 a3	 mov	 BYTE PTR tv211[ebp], al
  00157	0f b6 55 a3	 movzx	 edx, BYTE PTR tv211[ebp]
  0015b	85 d2		 test	 edx, edx
  0015d	74 0b		 je	 SHORT $L92156

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  0015f	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00162	83 c8 04	 or	 eax, 4
  00165	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  00168	eb 05		 jmp	 SHORT $L92150
$L92156:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  0016a	e9 78 ff ff ff	 jmp	 $L92152
$L92150:
  0016f	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00173	0f 85 91 00 00
	00		 jne	 $L92157

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00179	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Count$92158[ebp], 0
  00180	eb 09		 jmp	 SHORT $L92159
$L92160:
  00182	8b 4d d8	 mov	 ecx, DWORD PTR __Count$92158[ebp]
  00185	83 c1 01	 add	 ecx, 1
  00188	89 4d d8	 mov	 DWORD PTR __Count$92158[ebp], ecx
$L92159:
  0018b	8b 55 d8	 mov	 edx, DWORD PTR __Count$92158[ebp]
  0018e	3b 55 dc	 cmp	 edx, DWORD PTR __Size$[ebp]
  00191	73 77		 jae	 SHORT $L92157

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  00193	8b 45 d8	 mov	 eax, DWORD PTR __Count$92158[ebp]
  00196	50		 push	 eax
  00197	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
  001a0	89 45 9c	 mov	 DWORD PTR tv212[ebp], eax
  001a3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001ab	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001b4	89 45 98	 mov	 DWORD PTR tv213[ebp], eax
  001b7	8b 45 9c	 mov	 eax, DWORD PTR tv212[ebp]
  001ba	8a 08		 mov	 cl, BYTE PTR [eax]
  001bc	51		 push	 ecx
  001bd	8b 4d 98	 mov	 ecx, DWORD PTR tv213[ebp]
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  001c6	89 45 94	 mov	 DWORD PTR tv214[ebp], eax
  001c9	8b 55 94	 mov	 edx, DWORD PTR tv214[ebp]
  001cc	89 55 cc	 mov	 DWORD PTR $T95596[ebp], edx
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  001d5	89 45 90	 mov	 DWORD PTR tv215[ebp], eax
  001d8	8b 45 90	 mov	 eax, DWORD PTR tv215[ebp]
  001db	89 45 c8	 mov	 DWORD PTR $T95597[ebp], eax
  001de	8d 4d cc	 lea	 ecx, DWORD PTR $T95596[ebp]
  001e1	51		 push	 ecx
  001e2	8d 55 c8	 lea	 edx, DWORD PTR $T95597[ebp]
  001e5	52		 push	 edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  001ec	83 c4 08	 add	 esp, 8
  001ef	88 45 8f	 mov	 BYTE PTR tv216[ebp], al
  001f2	0f b6 45 8f	 movzx	 eax, BYTE PTR tv216[ebp]
  001f6	85 c0		 test	 eax, eax
  001f8	74 0b		 je	 SHORT $L92164

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  001fa	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001fd	83 c9 04	 or	 ecx, 4
  00200	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  00203	eb 05		 jmp	 SHORT $L92157
$L92164:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00205	e9 78 ff ff ff	 jmp	 $L92160
$L92157:
  0020a	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  0020e	0f 85 98 00 00
	00		 jne	 $L92165

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00214	eb 09		 jmp	 SHORT $L92166
$L92167:
  00216	8b 55 e8	 mov	 edx, DWORD PTR __Pad$[ebp]
  00219	83 ea 01	 sub	 edx, 1
  0021c	89 55 e8	 mov	 DWORD PTR __Pad$[ebp], edx
$L92166:
  0021f	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00223	0f 86 83 00 00
	00		 jbe	 $L92165

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  00229	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0022c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00231	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00234	8b ca		 mov	 ecx, edx
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0023c	88 45 8e	 mov	 BYTE PTR tv217[ebp], al
  0023f	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00242	8b 08		 mov	 ecx, DWORD PTR [eax]
  00244	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00247	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0024a	8b ca		 mov	 ecx, edx
  0024c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00252	89 45 88	 mov	 DWORD PTR tv218[ebp], eax
  00255	8a 45 8e	 mov	 al, BYTE PTR tv217[ebp]
  00258	50		 push	 eax
  00259	8b 4d 88	 mov	 ecx, DWORD PTR tv218[ebp]
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00262	89 45 84	 mov	 DWORD PTR tv219[ebp], eax
  00265	8b 4d 84	 mov	 ecx, DWORD PTR tv219[ebp]
  00268	89 4d c4	 mov	 DWORD PTR $T95598[ebp], ecx
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  00271	89 45 80	 mov	 DWORD PTR tv220[ebp], eax
  00274	8b 55 80	 mov	 edx, DWORD PTR tv220[ebp]
  00277	89 55 c0	 mov	 DWORD PTR $T95599[ebp], edx
  0027a	8d 45 c4	 lea	 eax, DWORD PTR $T95598[ebp]
  0027d	50		 push	 eax
  0027e	8d 4d c0	 lea	 ecx, DWORD PTR $T95599[ebp]
  00281	51		 push	 ecx
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00288	83 c4 08	 add	 esp, 8
  0028b	88 85 7f ff ff
	ff		 mov	 BYTE PTR tv221[ebp], al
  00291	0f b6 95 7f ff
	ff ff		 movzx	 edx, BYTE PTR tv221[ebp]
  00298	85 d2		 test	 edx, edx
  0029a	74 0b		 je	 SHORT $L92171

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  0029c	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0029f	83 c8 04	 or	 eax, 4
  002a2	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  002a5	eb 05		 jmp	 SHORT $L92165
$L92171:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  002a7	e9 6a ff ff ff	 jmp	 $L92167
$L92165:
  002ac	6a 00		 push	 0
  002ae	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  002b3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002b6	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  002bf	eb 1d		 jmp	 SHORT $L95601
$L95602:

; 581  : 		_CATCH_IO_(_Ostr)

  002c1	6a 01		 push	 1
  002c3	6a 04		 push	 4
  002c5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ca	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002cd	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002d0	8b ca		 mov	 ecx, edx
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  002d8	b8 00 00 00 00	 mov	 eax, $L95601
  002dd	c3		 ret	 0
$L95601:
  002de	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  002e5	6a 00		 push	 0
  002e7	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002ea	50		 push	 eax
  002eb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002f3	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 585  : 	return (_Ostr);

  002fc	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002ff	89 45 bc	 mov	 DWORD PTR $T95600[ebp], eax
  00302	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00309	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0030c	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00311	8b 45 bc	 mov	 eax, DWORD PTR $T95600[ebp]

; 586  : 	}

  00314	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00317	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0031e	5f		 pop	 edi
  0031f	5e		 pop	 esi
  00320	5b		 pop	 ebx
  00321	8b e5		 mov	 esp, ebp
  00323	5d		 pop	 ebp
  00324	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95603:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95605
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T95618	DD	0ffffffffH
	DD	FLAT:$L95614
$T95616	DD	019930520H
	DD	01H
	DD	FLAT:$T95618
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00037	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	74 30		 je	 SHORT $L91313
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  00058	85 c0		 test	 eax, eax
  0005a	74 1b		 je	 SHORT $L91313

; 90   : 				_Ostr.tie()->flush();

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b ca		 mov	 ecx, edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0006f	8b c8		 mov	 ecx, eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$L91313:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00077	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00082	8b ca		 mov	 ecx, edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95614:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95616
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:NEAR
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95627	DD	0ffffffffH
	DD	FLAT:$L95623
$T95625	DD	019930520H
	DD	01H
	DD	FLAT:$T95627
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0b		 jne	 SHORT $L91315

; 99   : 				this->_Myostr._Osfx();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$L91315:

; 100  : 			}

  0003b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95623:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95625
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L91685

; 70   : 				_Myostr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L91685:

; 71   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L91688

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L91688:

; 77   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB:DWORD
EXTRN	__imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z:NEAR
EXTRN	__imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ:NEAR
EXTRN	__imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@_W@std@@SAGXZ:NEAR
EXTRN	__imp_?is@?$ctype@_W@std@@QBE_NF_W@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T95650	DD	0ffffffffH
	DD	FLAT:$L95645
	DD	00H
	DD	FLAT:$L95646
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T95652	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L95644
$T95651	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T95652
$T95648	DD	019930520H
	DD	04H
	DD	FLAT:$T95650
	DD	01H
	DD	FLAT:$T95651
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv205 = -112						; size = 2
tv204 = -109						; size = 1
tv203 = -108						; size = 2
tv202 = -105						; size = 1
tv201 = -104						; size = 2
tv200 = -102						; size = 2
tv199 = -100						; size = 4
tv198 = -94						; size = 2
tv197 = -92						; size = 4
tv196 = -88						; size = 4
tv135 = -84						; size = 4
tv195 = -80						; size = 4
tv194 = -76						; size = 4
tv193 = -72						; size = 4
tv192 = -68						; size = 4
tv189 = -64						; size = 4
tv65 = -60						; size = 4
$T95642 = -56						; size = 4
$T95641 = -50						; size = 2
$T95638 = -48						; size = 4
__Meta$92188 = -44					; size = 2
__Size$92185 = -40					; size = 4
__Ctype_fac$92182 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 e9 01 00
	00		 je	 $L95643

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00055	8d 55 d0	 lea	 edx, DWORD PTR $T95638[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00061	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00064	8b ca		 mov	 ecx, edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0006c	89 45 c4	 mov	 DWORD PTR tv65[ebp], eax
  0006f	8b 45 c4	 mov	 eax, DWORD PTR tv65[ebp]
  00072	89 45 c0	 mov	 DWORD PTR tv189[ebp], eax
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00079	8b 4d c0	 mov	 ecx, DWORD PTR tv189[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 dc	 mov	 DWORD PTR __Ctype_fac$92182[ebp], eax
  00088	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0008c	8d 4d d0	 lea	 ecx, DWORD PTR $T95638[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	50		 push	 eax
  0009e	6a 00		 push	 0
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000a9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000be	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  000c1	83 7d bc 00	 cmp	 DWORD PTR tv192[ebp], 0
  000c5	7e 46		 jle	 SHORT $L95639
  000c7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000d2	8b ca		 mov	 ecx, edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000da	89 45 b8	 mov	 DWORD PTR tv193[ebp], eax
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  000e6	89 45 b4	 mov	 DWORD PTR tv194[ebp], eax
  000e9	8b 45 b8	 mov	 eax, DWORD PTR tv193[ebp]
  000ec	3b 45 b4	 cmp	 eax, DWORD PTR tv194[ebp]
  000ef	73 1c		 jae	 SHORT $L95639
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f9	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00102	89 45 b0	 mov	 DWORD PTR tv195[ebp], eax
  00105	8b 45 b0	 mov	 eax, DWORD PTR tv195[ebp]
  00108	89 45 ac	 mov	 DWORD PTR tv135[ebp], eax
  0010b	eb 12		 jmp	 SHORT $L95640
$L95639:
  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00116	89 45 a8	 mov	 DWORD PTR tv196[ebp], eax
  00119	8b 4d a8	 mov	 ecx, DWORD PTR tv196[ebp]
  0011c	89 4d ac	 mov	 DWORD PTR tv135[ebp], ecx
$L95640:
  0011f	8b 55 ac	 mov	 edx, DWORD PTR tv135[ebp]
  00122	89 55 d8	 mov	 DWORD PTR __Size$92185[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00125	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0012d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00130	8b ca		 mov	 ecx, edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00138	89 45 a4	 mov	 DWORD PTR tv197[ebp], eax
  0013b	8b 4d a4	 mov	 ecx, DWORD PTR tv197[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  00144	66 89 45 a2	 mov	 WORD PTR tv198[ebp], ax
  00148	66 8b 45 a2	 mov	 ax, WORD PTR tv198[ebp]
  0014c	66 89 45 d4	 mov	 WORD PTR __Meta$92188[ebp], ax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  00150	eb 32		 jmp	 SHORT $L92189
$L92190:
  00152	8b 4d d8	 mov	 ecx, DWORD PTR __Size$92185[ebp]
  00155	83 e9 01	 sub	 ecx, 1
  00158	89 4d d8	 mov	 DWORD PTR __Size$92185[ebp], ecx
  0015b	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0015e	8b 02		 mov	 eax, DWORD PTR [edx]
  00160	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00163	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0016c	89 45 9c	 mov	 DWORD PTR tv199[ebp], eax
  0016f	8b 4d 9c	 mov	 ecx, DWORD PTR tv199[ebp]
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  00178	66 89 45 9a	 mov	 WORD PTR tv200[ebp], ax
  0017c	66 8b 4d 9a	 mov	 cx, WORD PTR tv200[ebp]
  00180	66 89 4d d4	 mov	 WORD PTR __Meta$92188[ebp], cx
$L92189:
  00184	83 7d d8 00	 cmp	 DWORD PTR __Size$92185[ebp], 0
  00188	0f 86 91 00 00
	00		 jbe	 $L92191

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00194	66 89 45 98	 mov	 WORD PTR tv201[ebp], ax
  00198	66 8b 55 98	 mov	 dx, WORD PTR tv201[ebp]
  0019c	66 89 55 ce	 mov	 WORD PTR $T95641[ebp], dx
  001a0	8d 45 d4	 lea	 eax, DWORD PTR __Meta$92188[ebp]
  001a3	50		 push	 eax
  001a4	8d 4d ce	 lea	 ecx, DWORD PTR $T95641[ebp]
  001a7	51		 push	 ecx
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  001ae	83 c4 08	 add	 esp, 8
  001b1	88 45 97	 mov	 BYTE PTR tv202[ebp], al
  001b4	0f b6 55 97	 movzx	 edx, BYTE PTR tv202[ebp]
  001b8	85 d2		 test	 edx, edx
  001ba	74 0b		 je	 SHORT $L92193

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  001bc	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001bf	83 c8 01	 or	 eax, 1
  001c2	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  001c5	eb 58		 jmp	 SHORT $L92191
$L92193:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  001c7	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$92188[ebp]
  001ca	51		 push	 ecx
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  001d1	83 c4 04	 add	 esp, 4
  001d4	66 89 45 94	 mov	 WORD PTR tv203[ebp], ax
  001d8	66 8b 55 94	 mov	 dx, WORD PTR tv203[ebp]
  001dc	52		 push	 edx
  001dd	6a 48		 push	 72			; 00000048H
  001df	8b 4d dc	 mov	 ecx, DWORD PTR __Ctype_fac$92182[ebp]
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z
  001e8	88 45 93	 mov	 BYTE PTR tv204[ebp], al
  001eb	0f b6 45 93	 movzx	 eax, BYTE PTR tv204[ebp]
  001ef	85 c0		 test	 eax, eax
  001f1	74 02		 je	 SHORT $L92195

; 454  : 				break;	// whitespace, quit

  001f3	eb 2a		 jmp	 SHORT $L92191
$L92195:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  001f5	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$92188[ebp]
  001f8	51		 push	 ecx
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  001ff	83 c4 04	 add	 esp, 4
  00202	66 89 45 90	 mov	 WORD PTR tv205[ebp], ax
  00206	66 8b 55 90	 mov	 dx, WORD PTR tv205[ebp]
  0020a	52		 push	 edx
  0020b	6a 01		 push	 1
  0020d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z

; 458  : 				_Changed = true;

  00216	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  0021a	e9 33 ff ff ff	 jmp	 $L92190
$L92191:
  0021f	eb 1d		 jmp	 SHORT $L95643
$L95644:

; 460  : 		_CATCH_IO_(_Istr)

  00221	6a 01		 push	 1
  00223	6a 04		 push	 4
  00225	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00228	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0022d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00230	8b ca		 mov	 ecx, edx
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  00238	b8 00 00 00 00	 mov	 eax, $L95643
  0023d	c3		 ret	 0
$L95643:
  0023e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  00245	6a 00		 push	 0
  00247	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0024a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024c	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0024f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00252	8b ca		 mov	 ecx, edx
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z

; 464  : 	if (!_Changed)

  0025a	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  0025e	85 c0		 test	 eax, eax
  00260	75 09		 jne	 SHORT $L92197

; 465  : 		_State |= ios_base::failbit;

  00262	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00265	83 c9 02	 or	 ecx, 2
  00268	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L92197:

; 466  : 	_Istr.setstate(_State);

  0026b	6a 00		 push	 0
  0026d	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00270	52		 push	 edx
  00271	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00274	8b 08		 mov	 ecx, DWORD PTR [eax]
  00276	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00279	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0027c	8b ca		 mov	 ecx, edx
  0027e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 467  : 	return (_Istr);

  00284	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00287	89 45 c8	 mov	 DWORD PTR $T95642[ebp], eax
  0028a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00291	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00294	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00299	8b 45 c8	 mov	 eax, DWORD PTR $T95642[ebp]

; 468  : 	}

  0029c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0029f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002a6	5f		 pop	 edi
  002a7	5e		 pop	 esi
  002a8	5b		 pop	 ebx
  002a9	8b e5		 mov	 esp, ebp
  002ab	5d		 pop	 ebp
  002ac	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95645:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
$L95646:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T95638[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95648
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T95664	DD	0ffffffffH
	DD	FLAT:$L95660
$T95662	DD	019930520H
	DD	01H
	DD	FLAT:$T95664
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0002f	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95660:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95662
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L89746

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L89746:

; 61   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L91255

; 54   : 				_Myistr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L91255:

; 55   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
EXTRN	__imp_?id@?$ctype@_W@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95681	DD	0ffffffffH
	DD	FLAT:$L95677
$T95679	DD	019930520H
	DD	01H
	DD	FLAT:$T95681
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T95676 = -48						; size = 4
$T95675 = -44						; size = 12
__Pfmod$92055 = -32					; size = 4
__Psave$ = -28						; size = 4
__Lock$ = -24						; size = 4
__Id$ = -20						; size = 4
__Pf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 24	 sub	 esp, 36			; 00000024H

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	6a 00		 push	 0
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  00032	89 45 e4	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@_W@std@@2V0locale@2@A
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00041	89 45 ec	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00044	8b 4d ec	 mov	 ecx, DWORD PTR __Id$[ebp]
  00047	51		 push	 ecx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00051	89 45 f0	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00054	83 7d f0 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00058	74 02		 je	 SHORT $L92046

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  0005a	eb 62		 jmp	 SHORT $L92047
$L92046:
  0005c	83 7d e4 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  00060	74 08		 je	 SHORT $L92048

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00062	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  00065	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00068	eb 54		 jmp	 SHORT $L92047
$L92048:
  0006a	8d 45 e4	 lea	 eax, DWORD PTR __Psave$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z
  00074	83 c4 04	 add	 esp, 4
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	75 1c		 jne	 SHORT $L92051

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  00081	8d 4d d4	 lea	 ecx, DWORD PTR $T95675[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  0008f	8d 4d d4	 lea	 ecx, DWORD PTR $T95675[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 __CxxThrowException@8
$L92051:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  00098	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  0009b	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Psave$[ebp]
  000a1	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000a6	8b 4d e4	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000a9	89 4d e0	 mov	 DWORD PTR __Pfmod$92055[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ac	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$92055[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$92055[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L92047:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000be	8b 55 f0	 mov	 edx, DWORD PTR __Pf$[ebp]
  000c1	89 55 d0	 mov	 DWORD PTR $T95676[ebp], edx
  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d4	8b 45 d0	 mov	 eax, DWORD PTR $T95676[ebp]
$L95674:

; 347  : 	}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95677:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95679
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00003	6a 0a		 push	 10			; 0000000aH
  00005	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0000d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00010	8b ca		 mov	 ecx, edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  00018	50		 push	 eax
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
EXTRN	__imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95697	DD	0ffffffffH
	DD	FLAT:$L95693
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T95699	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L95692
$T95698	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T95699
$T95695	DD	019930520H
	DD	03H
	DD	FLAT:$T95697
	DD	01H
	DD	FLAT:$T95698
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT
tv175 = -86						; size = 2
tv174 = -84						; size = 4
tv173 = -80						; size = 4
tv172 = -76						; size = 4
tv171 = -70						; size = 1
tv170 = -69						; size = 1
tv169 = -68						; size = 2
tv168 = -66						; size = 2
tv167 = -64						; size = 4
tv166 = -58						; size = 2
tv165 = -56						; size = 4
tv65 = -50						; size = 2
$T95690 = -48						; size = 4
$T95689 = -42						; size = 2
__Meta$92208 = -40					; size = 2
__Metadelim$92207 = -36					; size = 2
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 2
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 48	 sub	 esp, 72			; 00000048H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 74 01 00
	00		 je	 $L95691

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  0006d	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z
  00077	83 c4 04	 add	 esp, 4
  0007a	66 89 45 ce	 mov	 WORD PTR tv65[ebp], ax
  0007e	66 8b 55 ce	 mov	 dx, WORD PTR tv65[ebp]
  00082	66 89 55 dc	 mov	 WORD PTR __Metadelim$92207[ebp], dx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00086	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0008e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00091	8b ca		 mov	 ecx, edx
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00099	89 45 c8	 mov	 DWORD PTR tv165[ebp], eax
  0009c	8b 4d c8	 mov	 ecx, DWORD PTR tv165[ebp]
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000a5	66 89 45 c6	 mov	 WORD PTR tv166[ebp], ax
  000a9	66 8b 45 c6	 mov	 ax, WORD PTR tv166[ebp]
  000ad	66 89 45 d8	 mov	 WORD PTR __Meta$92208[ebp], ax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000b1	eb 29		 jmp	 SHORT $L92209
$L92210:
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000bb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  000c4	89 45 c0	 mov	 DWORD PTR tv167[ebp], eax
  000c7	8b 4d c0	 mov	 ecx, DWORD PTR tv167[ebp]
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000d0	66 89 45 be	 mov	 WORD PTR tv168[ebp], ax
  000d4	66 8b 45 be	 mov	 ax, WORD PTR tv168[ebp]
  000d8	66 89 45 d8	 mov	 WORD PTR __Meta$92208[ebp], ax
$L92209:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  000e2	66 89 45 bc	 mov	 WORD PTR tv169[ebp], ax
  000e6	66 8b 4d bc	 mov	 cx, WORD PTR tv169[ebp]
  000ea	66 89 4d d6	 mov	 WORD PTR $T95689[ebp], cx
  000ee	8d 55 d8	 lea	 edx, DWORD PTR __Meta$92208[ebp]
  000f1	52		 push	 edx
  000f2	8d 45 d6	 lea	 eax, DWORD PTR $T95689[ebp]
  000f5	50		 push	 eax
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  000fc	83 c4 08	 add	 esp, 8
  000ff	88 45 bb	 mov	 BYTE PTR tv170[ebp], al
  00102	0f b6 4d bb	 movzx	 ecx, BYTE PTR tv170[ebp]
  00106	85 c9		 test	 ecx, ecx
  00108	74 0e		 je	 SHORT $L92213

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  0010a	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  0010d	83 ca 01	 or	 edx, 1
  00110	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  00113	e9 94 00 00 00	 jmp	 $L92211
$L92213:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  00118	8d 45 dc	 lea	 eax, DWORD PTR __Metadelim$92207[ebp]
  0011b	50		 push	 eax
  0011c	8d 4d d8	 lea	 ecx, DWORD PTR __Meta$92208[ebp]
  0011f	51		 push	 ecx
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  00126	83 c4 08	 add	 esp, 8
  00129	88 45 ba	 mov	 BYTE PTR tv171[ebp], al
  0012c	0f b6 55 ba	 movzx	 edx, BYTE PTR tv171[ebp]
  00130	85 d2		 test	 edx, edx
  00132	74 25		 je	 SHORT $L92215

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00134	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  00138	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0013b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00140	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00143	8b ca		 mov	 ecx, edx
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0014b	89 45 b4	 mov	 DWORD PTR tv172[ebp], eax
  0014e	8b 4d b4	 mov	 ecx, DWORD PTR tv172[ebp]
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ

; 501  : 				break;

  00157	eb 53		 jmp	 SHORT $L92211
$L92215:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  00159	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00162	89 45 b0	 mov	 DWORD PTR tv173[ebp], eax
  00165	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  0016e	89 45 ac	 mov	 DWORD PTR tv174[ebp], eax
  00171	8b 45 b0	 mov	 eax, DWORD PTR tv173[ebp]
  00174	3b 45 ac	 cmp	 eax, DWORD PTR tv174[ebp]
  00177	77 0b		 ja	 SHORT $L92217

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  00179	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  0017c	83 c9 02	 or	 ecx, 2
  0017f	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  00182	eb 28		 jmp	 SHORT $L92211
$L92217:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  00184	8d 55 d8	 lea	 edx, DWORD PTR __Meta$92208[ebp]
  00187	52		 push	 edx
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  0018e	83 c4 04	 add	 esp, 4
  00191	66 89 45 aa	 mov	 WORD PTR tv175[ebp], ax
  00195	66 8b 45 aa	 mov	 ax, WORD PTR tv175[ebp]
  00199	50		 push	 eax
  0019a	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z

; 511  : 				_Changed = true;

  001a3	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  001a7	e9 07 ff ff ff	 jmp	 $L92210
$L92211:
  001ac	eb 1b		 jmp	 SHORT $L95691
$L95692:

; 513  : 		_CATCH_IO_(_Istr)

  001ae	6a 01		 push	 1
  001b0	6a 04		 push	 4
  001b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b7	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001ba	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  001c3	b8 00 00 00 00	 mov	 eax, $L95691
  001c8	c3		 ret	 0
$L95691:
  001c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  001d0	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  001d4	85 c0		 test	 eax, eax
  001d6	75 09		 jne	 SHORT $L92219

; 517  : 		_State |= ios_base::failbit;

  001d8	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001db	83 c9 02	 or	 ecx, 2
  001de	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L92219:

; 518  : 	_Istr.setstate(_State);

  001e1	6a 00		 push	 0
  001e3	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001e6	52		 push	 edx
  001e7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ec	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001ef	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001f2	8b ca		 mov	 ecx, edx
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 519  : 	return (_Istr);

  001fa	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001fd	89 45 d0	 mov	 DWORD PTR $T95690[ebp], eax
  00200	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00207	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0020a	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0020f	8b 45 d0	 mov	 eax, DWORD PTR $T95690[ebp]

; 520  : 	}

  00212	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00215	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0021c	5f		 pop	 edi
  0021d	5e		 pop	 esi
  0021e	5b		 pop	 ebx
  0021f	8b e5		 mov	 esp, ebp
  00221	5d		 pop	 ebp
  00222	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95693:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
__ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95695
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z:NEAR
EXTRN	__imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z:NEAR
EXTRN	__imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95719	DD	0ffffffffH
	DD	FLAT:$L95715
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T95721	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L95714
$T95720	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T95721
$T95717	DD	019930520H
	DD	03H
	DD	FLAT:$T95719
	DD	01H
	DD	FLAT:$T95720
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv221 = -105						; size = 1
tv220 = -104						; size = 2
tv219 = -102						; size = 2
tv218 = -100						; size = 4
tv217 = -96						; size = 2
tv216 = -93						; size = 1
tv215 = -92						; size = 2
tv214 = -90						; size = 2
tv213 = -88						; size = 4
tv212 = -84						; size = 4
tv211 = -77						; size = 1
tv210 = -76						; size = 2
tv209 = -74						; size = 2
tv208 = -72						; size = 4
tv207 = -66						; size = 2
tv83 = -64						; size = 4
tv81 = -60						; size = 4
$T95712 = -56						; size = 4
$T95711 = -52						; size = 2
$T95710 = -50						; size = 2
$T95709 = -48						; size = 2
$T95708 = -46						; size = 2
$T95707 = -44						; size = 2
$T95706 = -42						; size = 2
__Count$92242 = -40					; size = 4
__Size$ = -36						; size = 4
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00032	89 45 dc	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0003d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00040	8b ca		 mov	 ecx, edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00048	85 c0		 test	 eax, eax
  0004a	7e 33		 jle	 SHORT $L95704
  0004c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00054	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00057	8b ca		 mov	 ecx, edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0005f	3b 45 dc	 cmp	 eax, DWORD PTR __Size$[ebp]
  00062	76 1b		 jbe	 SHORT $L95704
  00064	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00077	2b 45 dc	 sub	 eax, DWORD PTR __Size$[ebp]
  0007a	89 45 c4	 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 07		 jmp	 SHORT $L95705
$L95704:
  0007f	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L95705:
  00086	8b 45 c4	 mov	 eax, DWORD PTR tv81[ebp]
  00089	89 45 e8	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008f	51		 push	 ecx
  00090	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00093	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  0009f	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000a2	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  000a7	0f b6 d0	 movzx	 edx, al
  000aa	85 d2		 test	 edx, edx
  000ac	75 0e		 jne	 SHORT $L92231

; 550  : 		_State |= ios_base::badbit;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000b1	83 c8 04	 or	 eax, 4
  000b4	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000b7	e9 37 02 00 00	 jmp	 $L95713
$L92231:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  000d1	89 45 c0	 mov	 DWORD PTR tv83[ebp], eax
  000d4	8b 45 c0	 mov	 eax, DWORD PTR tv83[ebp]
  000d7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000dc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000df	0f 84 96 00 00
	00		 je	 $L92234

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000e5	eb 09		 jmp	 SHORT $L92235
$L92236:
  000e7	8b 4d e8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  000ea	83 e9 01	 sub	 ecx, 1
  000ed	89 4d e8	 mov	 DWORD PTR __Pad$[ebp], ecx
$L92235:
  000f0	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  000f4	0f 86 81 00 00
	00		 jbe	 $L92234

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  000fa	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00102	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  0010b	66 89 45 be	 mov	 WORD PTR tv207[ebp], ax
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00117	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00120	89 45 b8	 mov	 DWORD PTR tv208[ebp], eax
  00123	66 8b 45 be	 mov	 ax, WORD PTR tv207[ebp]
  00127	50		 push	 eax
  00128	8b 4d b8	 mov	 ecx, DWORD PTR tv208[ebp]
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00131	66 89 45 b6	 mov	 WORD PTR tv209[ebp], ax
  00135	66 8b 4d b6	 mov	 cx, WORD PTR tv209[ebp]
  00139	66 89 4d d6	 mov	 WORD PTR $T95706[ebp], cx
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00143	66 89 45 b4	 mov	 WORD PTR tv210[ebp], ax
  00147	66 8b 55 b4	 mov	 dx, WORD PTR tv210[ebp]
  0014b	66 89 55 d4	 mov	 WORD PTR $T95707[ebp], dx
  0014f	8d 45 d6	 lea	 eax, DWORD PTR $T95706[ebp]
  00152	50		 push	 eax
  00153	8d 4d d4	 lea	 ecx, DWORD PTR $T95707[ebp]
  00156	51		 push	 ecx
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  0015d	83 c4 08	 add	 esp, 8
  00160	88 45 b3	 mov	 BYTE PTR tv211[ebp], al
  00163	0f b6 55 b3	 movzx	 edx, BYTE PTR tv211[ebp]
  00167	85 d2		 test	 edx, edx
  00169	74 0b		 je	 SHORT $L92240

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  0016b	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0016e	83 c8 04	 or	 eax, 4
  00171	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  00174	eb 05		 jmp	 SHORT $L92234
$L92240:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  00176	e9 6c ff ff ff	 jmp	 $L92236
$L92234:
  0017b	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  0017f	0f 85 98 00 00
	00		 jne	 $L92241

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00185	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Count$92242[ebp], 0
  0018c	eb 09		 jmp	 SHORT $L92243
$L92244:
  0018e	8b 4d d8	 mov	 ecx, DWORD PTR __Count$92242[ebp]
  00191	83 c1 01	 add	 ecx, 1
  00194	89 4d d8	 mov	 DWORD PTR __Count$92242[ebp], ecx
$L92243:
  00197	8b 55 d8	 mov	 edx, DWORD PTR __Count$92242[ebp]
  0019a	3b 55 dc	 cmp	 edx, DWORD PTR __Size$[ebp]
  0019d	73 7e		 jae	 SHORT $L92241

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  0019f	8b 45 d8	 mov	 eax, DWORD PTR __Count$92242[ebp]
  001a2	50		 push	 eax
  001a3	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z
  001ac	89 45 ac	 mov	 DWORD PTR tv212[ebp], eax
  001af	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b4	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001b7	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  001c0	89 45 a8	 mov	 DWORD PTR tv213[ebp], eax
  001c3	8b 45 ac	 mov	 eax, DWORD PTR tv212[ebp]
  001c6	66 8b 08	 mov	 cx, WORD PTR [eax]
  001c9	51		 push	 ecx
  001ca	8b 4d a8	 mov	 ecx, DWORD PTR tv213[ebp]
  001cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  001d3	66 89 45 a6	 mov	 WORD PTR tv214[ebp], ax
  001d7	66 8b 55 a6	 mov	 dx, WORD PTR tv214[ebp]
  001db	66 89 55 d2	 mov	 WORD PTR $T95708[ebp], dx
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  001e5	66 89 45 a4	 mov	 WORD PTR tv215[ebp], ax
  001e9	66 8b 45 a4	 mov	 ax, WORD PTR tv215[ebp]
  001ed	66 89 45 d0	 mov	 WORD PTR $T95709[ebp], ax
  001f1	8d 4d d2	 lea	 ecx, DWORD PTR $T95708[ebp]
  001f4	51		 push	 ecx
  001f5	8d 55 d0	 lea	 edx, DWORD PTR $T95709[ebp]
  001f8	52		 push	 edx
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  001ff	83 c4 08	 add	 esp, 8
  00202	88 45 a3	 mov	 BYTE PTR tv216[ebp], al
  00205	0f b6 45 a3	 movzx	 eax, BYTE PTR tv216[ebp]
  00209	85 c0		 test	 eax, eax
  0020b	74 0b		 je	 SHORT $L92248

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  0020d	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00210	83 c9 04	 or	 ecx, 4
  00213	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  00216	eb 05		 jmp	 SHORT $L92241
$L92248:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00218	e9 71 ff ff ff	 jmp	 $L92244
$L92241:
  0021d	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00221	0f 85 9a 00 00
	00		 jne	 $L92249

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00227	eb 09		 jmp	 SHORT $L92250
$L92251:
  00229	8b 55 e8	 mov	 edx, DWORD PTR __Pad$[ebp]
  0022c	83 ea 01	 sub	 edx, 1
  0022f	89 55 e8	 mov	 DWORD PTR __Pad$[ebp], edx
$L92250:
  00232	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00236	0f 86 85 00 00
	00		 jbe	 $L92249

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  0023c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0023f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00241	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00244	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00247	8b ca		 mov	 ecx, edx
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  0024f	66 89 45 a0	 mov	 WORD PTR tv217[ebp], ax
  00253	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00256	8b 08		 mov	 ecx, DWORD PTR [eax]
  00258	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0025b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0025e	8b ca		 mov	 ecx, edx
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00266	89 45 9c	 mov	 DWORD PTR tv218[ebp], eax
  00269	66 8b 45 a0	 mov	 ax, WORD PTR tv217[ebp]
  0026d	50		 push	 eax
  0026e	8b 4d 9c	 mov	 ecx, DWORD PTR tv218[ebp]
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00277	66 89 45 9a	 mov	 WORD PTR tv219[ebp], ax
  0027b	66 8b 4d 9a	 mov	 cx, WORD PTR tv219[ebp]
  0027f	66 89 4d ce	 mov	 WORD PTR $T95710[ebp], cx
  00283	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00289	66 89 45 98	 mov	 WORD PTR tv220[ebp], ax
  0028d	66 8b 55 98	 mov	 dx, WORD PTR tv220[ebp]
  00291	66 89 55 cc	 mov	 WORD PTR $T95711[ebp], dx
  00295	8d 45 ce	 lea	 eax, DWORD PTR $T95710[ebp]
  00298	50		 push	 eax
  00299	8d 4d cc	 lea	 ecx, DWORD PTR $T95711[ebp]
  0029c	51		 push	 ecx
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  002a3	83 c4 08	 add	 esp, 8
  002a6	88 45 97	 mov	 BYTE PTR tv221[ebp], al
  002a9	0f b6 55 97	 movzx	 edx, BYTE PTR tv221[ebp]
  002ad	85 d2		 test	 edx, edx
  002af	74 0b		 je	 SHORT $L92255

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  002b1	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002b4	83 c8 04	 or	 eax, 4
  002b7	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  002ba	eb 05		 jmp	 SHORT $L92249
$L92255:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  002bc	e9 68 ff ff ff	 jmp	 $L92251
$L92249:
  002c1	6a 00		 push	 0
  002c3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002cb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  002d4	eb 1d		 jmp	 SHORT $L95713
$L95714:

; 581  : 		_CATCH_IO_(_Ostr)

  002d6	6a 01		 push	 1
  002d8	6a 04		 push	 4
  002da	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002df	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002e2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002e5	8b ca		 mov	 ecx, edx
  002e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  002ed	b8 00 00 00 00	 mov	 eax, $L95713
  002f2	c3		 ret	 0
$L95713:
  002f3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  002fa	6a 00		 push	 0
  002fc	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002ff	50		 push	 eax
  00300	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00303	8b 11		 mov	 edx, DWORD PTR [ecx]
  00305	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00308	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 585  : 	return (_Ostr);

  00311	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00314	89 45 c8	 mov	 DWORD PTR $T95712[ebp], eax
  00317	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0031e	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00321	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00326	8b 45 c8	 mov	 eax, DWORD PTR $T95712[ebp]

; 586  : 	}

  00329	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0032c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00333	5f		 pop	 edi
  00334	5e		 pop	 esi
  00335	5b		 pop	 ebx
  00336	8b e5		 mov	 esp, ebp
  00338	5d		 pop	 ebp
  00339	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95715:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95717
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T95730	DD	0ffffffffH
	DD	FLAT:$L95726
$T95728	DD	019930520H
	DD	01H
	DD	FLAT:$T95730
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00037	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	74 30		 je	 SHORT $L91321
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  00058	85 c0		 test	 eax, eax
  0005a	74 1b		 je	 SHORT $L91321

; 90   : 				_Ostr.tie()->flush();

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b ca		 mov	 ecx, edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  0006f	8b c8		 mov	 ecx, eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
$L91321:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00077	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00082	8b ca		 mov	 ecx, edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95726:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95728
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
EXTRN	__imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T95739	DD	0ffffffffH
	DD	FLAT:$L95735
$T95737	DD	019930520H
	DD	01H
	DD	FLAT:$T95739
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0b		 jne	 SHORT $L91323

; 99   : 				this->_Myostr._Osfx();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L91323:

; 100  : 			}

  0003b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95735:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95737
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L91691

; 70   : 				_Myostr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L91691:

; 71   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L91694

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L91694:

; 77   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iomanip
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Ostr$ = 8						; size = 4
__Manip$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z PROC NEAR ; std::operator<<<char,std::char_traits<char>,int>, COMDAT

; 72   : 	{	// insert by calling function with output stream and argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 73   : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

  00004	83 7d 08 00	 cmp	 DWORD PTR __Ostr$[ebp], 0
  00008	75 09		 jne	 SHORT $L95750
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00011	eb 0e		 jmp	 SHORT $L95751
$L95750:
  00013	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0001b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0001e	89 55 fc	 mov	 DWORD PTR tv69[ebp], edx
$L95751:
  00021	8b 45 0c	 mov	 eax, DWORD PTR __Manip$[ebp]
  00024	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00027	51		 push	 ecx
  00028	8b 55 fc	 mov	 edx, DWORD PTR tv69[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __Manip$[ebp]
  0002f	ff 10		 call	 DWORD PTR [eax]
  00031	83 c4 08	 add	 esp, 8

; 74   : 	return (_Ostr);

  00034	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]

; 75   : 	}

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
$T95754 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T95754[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T95754[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Odt
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z PROC NEAR ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC NEAR ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L92623
$L92624:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L92623:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L92622

; 226  : 		_Al.destroy(_First);

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001d	e8 00 00 00 00	 call	 ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
  00022	eb e1		 jmp	 SHORT $L92624
$L92622:

; 227  : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
_TEXT	ENDS
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Odt
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00003	6a 00		 push	 0
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z

; 50   : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00010	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	74 0c		 je	 SHORT $L92647
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00021	83 c4 04	 add	 esp, 4
$L92647:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
EXTRN	_atexit:NEAR
;	COMDAT CRT$XCU
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Odt
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 2602 : __declspec(selectany) CAtlWinModule _AtlWinModule;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
  00008	e8 00 00 00 00	 call	 ??0CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::CAtlWinModule
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:_$E2
  00012	e8 00 00 00 00	 call	 _atexit
  00017	83 c4 04	 add	 esp, 4
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
; Function compile flags: /Odt
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hr$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2573 : 	CAtlWinModule()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2574 : 	{
; 2575 : 		cbSize = sizeof(_ATL_WIN_MODULE);

  00011	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 2c 00 00
	00		 mov	 DWORD PTR [eax], 44	; 0000002cH

; 2576 : 		HRESULT hr = AtlWinModuleInit(this);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
  00023	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 2577 : 		if (FAILED(hr))

  00026	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002a	7d 07		 jge	 SHORT $L67282

; 2578 : 			CAtlBaseModule::m_bInitFailed = true;

  0002c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
$L67282:

; 2579 : 	}

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
; Function compile flags: /Odt
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ??0CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::CComCriticalSection
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 20	 add	 ecx, 32			; 00000020H
  00018	e8 00 00 00 00	 call	 ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC NEAR		; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	CComCriticalSection() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	{
; 116  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00007	6a 18		 push	 24			; 00000018H
  00009	6a 00		 push	 0
  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 117  : 	}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.inl
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC NEAR ; ATL::AtlWinModuleInit, COMDAT

; 352  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 353  : 	if (pWinModule == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _pWinModule$[ebp], 0
  00008	75 07		 jne	 SHORT $L71234

; 354  : 		return E_INVALIDARG;

  0000a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0000f	eb 2a		 jmp	 SHORT $L71233
$L71234:

; 355  : 		
; 356  : 	// check only in the DLL
; 357  : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  00011	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00014	83 38 2c	 cmp	 DWORD PTR [eax], 44	; 0000002cH
  00017	74 07		 je	 SHORT $L71237

; 358  : 		return E_INVALIDARG;

  00019	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001e	eb 1b		 jmp	 SHORT $L71233
$L71237:

; 359  : 
; 360  : 	pWinModule->m_pCreateWndList = NULL;

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00023	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 361  : 
; 362  : 	HRESULT hr = pWinModule->m_csWindowCreate.Init();

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  0002d	83 c1 04	 add	 ecx, 4
  00030	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  00035	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 363  : 	if (FAILED(hr))
; 364  : 	{
; 365  : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to initialize critical section in AtlWinModuleInit\n"));
; 366  : 		ATLASSERT(0);
; 367  : 	}
; 368  : 	return hr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L71233:

; 369  : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
EXTRN	__imp__InitializeCriticalSection@4:NEAR
;	COMDAT CONST
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
CONST	SEGMENT
$T95787	DD	0ffffffffH
	DD	FLAT:$L95782
	DD	FLAT:$L95783
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T95786 = -32						; size = 4
_hRes$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
?Init@CComCriticalSection@ATL@@QAEJXZ PROC NEAR		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 129  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 OFFSET FLAT:$T95787
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:__except_handler3
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00015	50		 push	 eax
  00016	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001d	83 c4 ec	 add	 esp, -20		; ffffffecH
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00026	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 130  : 		HRESULT hRes = S_OK;

  00029	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hRes$[ebp], 0

; 131  : 		__try

  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 132  : 		{
; 133  : 			InitializeCriticalSection(&m_sec);

  00037	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
  00041	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00048	eb 33		 jmp	 SHORT $L95785
$L95782:
$L95790:

; 134  : 		}
; 135  : 		// structured exception may be raised in low memory situations
; 136  : 		__except(EXCEPTION_EXECUTE_HANDLER)

  0004a	8b 4d ec	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+4]
  0004d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004f	8b 02		 mov	 eax, DWORD PTR [edx]
  00051	89 45 e0	 mov	 DWORD PTR $T95786[ebp], eax
  00054	b8 01 00 00 00	 mov	 eax, 1
$L95784:
$L95789:
  00059	c3		 ret	 0
$L95783:
  0005a	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 137  : 		{
; 138  : 			if (STATUS_NO_MEMORY == GetExceptionCode())

  0005d	81 7d e0 17 00
	00 c0		 cmp	 DWORD PTR $T95786[ebp], -1073741801 ; c0000017H
  00064	75 09		 jne	 SHORT $L57354

; 139  : 				hRes = E_OUTOFMEMORY;

  00066	c7 45 e4 0e 00
	07 80		 mov	 DWORD PTR _hRes$[ebp], -2147024882 ; 8007000eH

; 140  : 			else

  0006d	eb 07		 jmp	 SHORT $L57356
$L57354:

; 141  : 				hRes = E_FAIL;

  0006f	c7 45 e4 05 40
	00 80		 mov	 DWORD PTR _hRes$[ebp], -2147467259 ; 80004005H
$L57356:
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$L95785:

; 142  : 		}
; 143  : 		return hRes;

  0007d	8b 45 e4	 mov	 eax, DWORD PTR _hRes$[ebp]
$L95781:

; 144  : 	}

  00080	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 97   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odt
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
  00008	e8 00 00 00 00	 call	 ??1CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::~CAtlWinModule
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E2	ENDP
text$yd	ENDS
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
xdata$x	SEGMENT
$T95803	DD	0ffffffffH
	DD	FLAT:$L95799
$T95801	DD	019930520H
	DD	01H
	DD	FLAT:$T95803
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2582 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2583 : 		Term();

  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?Term@CAtlWinModule@ATL@@QAEXXZ ; ATL::CAtlWinModule::Term

; 2584 : 	}

  0002b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L95799:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T95801
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; Function compile flags: /Odt
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC NEAR		; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2587 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2588 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

  00007	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
  0000c	e8 00 00 00 00	 call	 ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
  00011	50		 push	 eax
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2589 : 	}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 206  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		return m_hInst;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 208  : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 20	 add	 ecx, 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
EXTRN	__imp__UnregisterClassA@8:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_i$70529 = -4						; size = 4
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC NEAR ; ATL::AtlWinModuleTerm, COMDAT

; 6215 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6216 : 	if (pWinModule == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _pWinModule$[ebp], 0
  00008	75 07		 jne	 SHORT $L70522

; 6217 : 		return E_INVALIDARG;

  0000a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0000f	eb 7d		 jmp	 SHORT $L70521
$L70522:

; 6218 : 	if (pWinModule->cbSize == 0)

  00011	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00014	83 38 00	 cmp	 DWORD PTR [eax], 0
  00017	75 04		 jne	 SHORT $L70524

; 6219 : 		return S_OK;

  00019	33 c0		 xor	 eax, eax
  0001b	eb 71		 jmp	 SHORT $L70521
$L70524:

; 6220 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00020	83 39 2c	 cmp	 DWORD PTR [ecx], 44	; 0000002cH
  00023	74 07		 je	 SHORT $L70527

; 6221 : 		return E_INVALIDARG;

  00025	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0002a	eb 62		 jmp	 SHORT $L70521
$L70527:

; 6222 : 
; 6223 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$70529[ebp], 0
  00033	eb 09		 jmp	 SHORT $L70530
$L70531:
  00035	8b 55 fc	 mov	 edx, DWORD PTR _i$70529[ebp]
  00038	83 c2 01	 add	 edx, 1
  0003b	89 55 fc	 mov	 DWORD PTR _i$70529[ebp], edx
$L70530:
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00041	83 c1 20	 add	 ecx, 32			; 00000020H
  00044	e8 00 00 00 00	 call	 ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
  00049	39 45 fc	 cmp	 DWORD PTR _i$70529[ebp], eax
  0004c	7d 1f		 jge	 SHORT $L70532

; 6224 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  0004e	8b 45 0c	 mov	 eax, DWORD PTR _hInst$[ebp]
  00051	50		 push	 eax
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _i$70529[ebp]
  00055	51		 push	 ecx
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00059	83 c1 20	 add	 ecx, 32			; 00000020H
  0005c	e8 00 00 00 00	 call	 ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
  00061	0f b7 10	 movzx	 edx, WORD PTR [eax]
  00064	52		 push	 edx
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  0006b	eb c8		 jmp	 SHORT $L70531
$L70532:

; 6225 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00070	83 c1 20	 add	 ecx, 32			; 00000020H
  00073	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 6226 : 	pWinModule->m_csWindowCreate.Term();

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  0007b	83 c1 04	 add	 ecx, 4
  0007e	e8 00 00 00 00	 call	 ?Term@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Term

; 6227 : 	pWinModule->cbSize = 0;

  00083	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00086	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 6228 : 	return S_OK;

  0008c	33 c0		 xor	 eax, eax
$L70521:

; 6229 : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
EXTRN	__imp__DeleteCriticalSection@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CComCriticalSection@ATL@@QAEJXZ PROC NEAR		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 147  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 148  : 		DeleteCriticalSection(&m_sec);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 149  : 		return S_OK;

  00011	33 c0		 xor	 eax, eax

; 150  : 	}	

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 100  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 101  : 		RemoveAll();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 102  : 	}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 135  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 136  : 		return m_nSize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 137  : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$88116 = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 173  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : 		if(m_aT != NULL)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 37		 je	 SHORT $L88115

; 175  : 		{
; 176  : 			for(int i = 0; i < m_nSize; i++)

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$88116[ebp], 0
  00018	eb 09		 jmp	 SHORT $L88117
$L88118:
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _i$88116[ebp]
  0001d	83 c1 01	 add	 ecx, 1
  00020	89 4d fc	 mov	 DWORD PTR _i$88116[ebp], ecx
$L88117:
  00023	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$88116[ebp]
  00029	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0002c	7d 02		 jge	 SHORT $L88119

; 177  : 				m_aT[i].~T();

  0002e	eb ea		 jmp	 SHORT $L88118
$L88119:

; 178  : 			free(m_aT);

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4

; 179  : 			m_aT = NULL;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L88115:

; 180  : 		}
; 181  : 		m_nSize = 0;

  00048	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 182  : 		m_nAllocSize = 0;

  00052	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00055	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 183  : 	}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
; Function compile flags: /Odt
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 194  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 195  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 196  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7c 0b		 jl	 SHORT $L88124
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00013	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00016	7c 0c		 jl	 SHORT $L88123
$L88124:

; 197  : 		{
; 198  : 			_AtlRaiseException(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);					

  00018	6a 01		 push	 1
  0001a	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  0001f	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$L88123:

; 199  : 		}
; 200  : 		return m_aT[nIndex];

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0002c	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
$L95824:

; 201  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
EXTRN	__imp__RaiseException@16:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC NEAR		; ATL::_AtlRaiseException, COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 27   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	8b 45 0c	 mov	 eax, DWORD PTR _dwExceptionFlags$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _dwExceptionCode$[ebp]
  0000e	51		 push	 ecx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16

; 28   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
END
