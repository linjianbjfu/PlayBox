; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\boxgit\PlayBox\CommonLib\common\YL_Ini.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __tcsncpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __tcsrev
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __tcsicmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GYL_Ini@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3YL_Ini@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVYL_Ini@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@YL_Ini@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_7YL_Ini@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R2YL_Ini@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4YL_Ini@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG56187 DB	00H
$SG56196 DB	00H
$SG56205 DB	00H
$SG56213 DB	00H
$SG56221 DB	00H
$SG56230 DB	00H
$SG56239 DB	00H
	ORG $+1
$SG56248 DB	'%f', 00H
	ORG $+1
$SG56250 DB	'%%.%df', 00H
$SG56252 DB	00H
$SG56266 DB	00H
$SG56308 DB	00H
	ORG $+2
$SG56329 DB	'%02X', 00H
$SG56372 DB	00H
$SG56397 DB	00H
$SG56404 DB	00H
$SG56437 DB	'%d', 00H
	ORG $+1
$SG56449 DB	'%o', 00H
	ORG $+1
$SG56451 DB	'%X', 00H
	ORG $+1
$SG56453 DB	'%u', 00H
	ORG $+1
$SG56460 DB	'true', 00H
	ORG $+3
$SG56461 DB	'yes', 00H
CONST	ENDS
PUBLIC	??_R4YL_Ini@@6B@				; YL_Ini::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVYL_Ini@@@8				; YL_Ini `RTTI Type Descriptor'
PUBLIC	??_R3YL_Ini@@8					; YL_Ini::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2YL_Ini@@8					; YL_Ini::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@YL_Ini@@8				; YL_Ini::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0YL_Ini@@QAE@XZ				; YL_Ini::YL_Ini
PUBLIC	??_7YL_Ini@@6B@					; YL_Ini::`vftable'
PUBLIC	??_GYL_Ini@@UAEPAXI@Z				; YL_Ini::`scalar deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EYL_Ini@@UAEPAXI@Z:NEAR			; YL_Ini::`vector deleting destructor'
;	COMDAT ??_7YL_Ini@@6B@
; File d:\boxgit\playbox\commonlib\common\yl_ini.cpp
CONST	SEGMENT
??_7YL_Ini@@6B@ DD FLAT:??_R4YL_Ini@@6B@		; YL_Ini::`vftable'
	DD	FLAT:??_EYL_Ini@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4YL_Ini@@6B@
rdata$r	SEGMENT
??_R4YL_Ini@@6B@ DD 00H					; YL_Ini::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVYL_Ini@@@8
	DD	FLAT:??_R3YL_Ini@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVYL_Ini@@@8
_DATA	SEGMENT
??_R0?AVYL_Ini@@@8 DD FLAT:??_7type_info@@6B@		; YL_Ini `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVYL_Ini@@', 00H
_DATA	ENDS
;	COMDAT ??_R3YL_Ini@@8
rdata$r	SEGMENT
??_R3YL_Ini@@8 DD 00H					; YL_Ini::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2YL_Ini@@8
rdata$r	ENDS
;	COMDAT ??_R2YL_Ini@@8
rdata$r	SEGMENT
??_R2YL_Ini@@8 DD FLAT:??_R1A@?0A@A@YL_Ini@@8		; YL_Ini::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@YL_Ini@@8
rdata$r	SEGMENT
??_R1A@?0A@A@YL_Ini@@8 DD FLAT:??_R0?AVYL_Ini@@@8	; YL_Ini::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0YL_Ini@@QAE@XZ PROC NEAR				; YL_Ini::YL_Ini
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7YL_Ini@@6B@

; 22   : 	m_pszPathName = NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 23   : }

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0YL_Ini@@QAE@XZ ENDP					; YL_Ini::YL_Ini
_TEXT	ENDS
PUBLIC	??1YL_Ini@@UAE@XZ				; YL_Ini::~YL_Ini
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt
;	COMDAT ??_GYL_Ini@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GYL_Ini@@UAEPAXI@Z PROC NEAR				; YL_Ini::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1YL_Ini@@UAE@XZ	; YL_Ini::~YL_Ini
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L56148
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L56148:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GYL_Ini@@UAEPAXI@Z ENDP				; YL_Ini::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0YL_Ini@@QAE@PBD@Z				; YL_Ini::YL_Ini
PUBLIC	?SetPathName@YL_Ini@@QAEXPBD@Z			; YL_Ini::SetPathName
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpPathName$ = 8					; size = 4
??0YL_Ini@@QAE@PBD@Z PROC NEAR				; YL_Ini::YL_Ini
; _this$ = ecx

; 26   : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	51		 push	 ecx
  00034	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7YL_Ini@@6B@

; 27   : 	m_pszPathName = NULL;

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 28   : 	SetPathName(lpPathName);

  0004a	8b 55 08	 mov	 edx, DWORD PTR _lpPathName$[ebp]
  0004d	52		 push	 edx
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?SetPathName@YL_Ini@@QAEXPBD@Z ; YL_Ini::SetPathName

; 29   : }

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
??0YL_Ini@@QAE@PBD@Z ENDP				; YL_Ini::YL_Ini
_TEXT	ENDS
EXTRN	__imp__free:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1YL_Ini@@UAE@XZ PROC NEAR				; YL_Ini::~YL_Ini
; _this$ = ecx

; 32   : {

  00060	55		 push	 ebp
  00061	8b ec		 mov	 ebp, esp
  00063	51		 push	 ecx
  00064	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7YL_Ini@@6B@

; 33   : 	if (m_pszPathName != NULL)

  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00077	74 1a		 je	 SHORT $L56155

; 34   : 	{
; 35   : 	//因为m_pszPathName是用_strdup生成，而_strdup调用的malloc来分配内存，因此需要用free来释放空间
; 36   : 		free(m_pszPathName);

  00079	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007f	50		 push	 eax
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00086	83 c4 04	 add	 esp, 4

; 37   : 		m_pszPathName = NULL;

  00089	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$L56155:

; 38   : 	}
; 39   : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
??1YL_Ini@@UAE@XZ ENDP					; YL_Ini::~YL_Ini
_TEXT	ENDS
EXTRN	__imp___strdup:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpPathName$ = 8					; size = 4
?SetPathName@YL_Ini@@QAEXPBD@Z PROC NEAR		; YL_Ini::SetPathName
; _this$ = ecx

; 47   : {

  000a0	55		 push	 ebp
  000a1	8b ec		 mov	 ebp, esp
  000a3	51		 push	 ecx
  000a4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 48   : 	if (lpPathName == NULL)

  000a7	83 7d 08 00	 cmp	 DWORD PTR _lpPathName$[ebp], 0
  000ab	75 14		 jne	 SHORT $L56161

; 49   : 	{
; 50   : 		if (m_pszPathName != NULL)

  000ad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000b4	74 09		 je	 SHORT $L56162

; 51   : 			*m_pszPathName = _T('\0');

  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000bc	c6 02 00	 mov	 BYTE PTR [edx], 0
$L56162:

; 52   : 	}
; 53   : 	else

  000bf	eb 36		 jmp	 SHORT $L56160
$L56161:

; 54   : 	{
; 55   : 		if (m_pszPathName != NULL)

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000c8	74 1a		 je	 SHORT $L56164

; 56   : 		{
; 57   : 			free(m_pszPathName);

  000ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d0	52		 push	 edx
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000d7	83 c4 04	 add	 esp, 4

; 58   : 			m_pszPathName = NULL;

  000da	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L56164:

; 59   : 		}
; 60   : 		m_pszPathName = _tcsdup(lpPathName);

  000e4	8b 4d 08	 mov	 ecx, DWORD PTR _lpPathName$[ebp]
  000e7	51		 push	 ecx
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  000ee	83 c4 04	 add	 esp, 4
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 42 04	 mov	 DWORD PTR [edx+4], eax
$L56160:

; 61   : 	}
; 62   : }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
?SetPathName@YL_Ini@@QAEXPBD@Z ENDP			; YL_Ini::SetPathName
_TEXT	ENDS
PUBLIC	__tcsncpy
PUBLIC	?GetString@YL_Ini@@QBEKPBD0PADK0@Z		; YL_Ini::GetString
PUBLIC	?__GetStringDynamic@YL_Ini@@IBEPADPBD00@Z	; YL_Ini::__GetStringDynamic
EXTRN	_strlen:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv77 = -20						; size = 4
_this$ = -16						; size = 4
$T56574 = -12						; size = 4
_dwLen$ = -8						; size = 4
_psz$ = -4						; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_lpBuffer$ = 16						; size = 4
_dwBufSize$ = 20					; size = 4
_lpDefault$ = 24					; size = 4
?GetString@YL_Ini@@QBEKPBD0PADK0@Z PROC NEAR		; YL_Ini::GetString
; _this$ = ecx

; 71   : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp
  00103	83 ec 14	 sub	 esp, 20			; 00000014H
  00106	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 72   : 	if (lpBuffer != NULL)

  00109	83 7d 10 00	 cmp	 DWORD PTR _lpBuffer$[ebp], 0
  0010d	74 06		 je	 SHORT $L56173

; 73   : 		*lpBuffer = _T('\0');

  0010f	8b 45 10	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  00112	c6 00 00	 mov	 BYTE PTR [eax], 0
$L56173:

; 74   : 
; 75   : 	LPTSTR psz = __GetStringDynamic(lpSection, lpKey, lpDefault);

  00115	8b 4d 18	 mov	 ecx, DWORD PTR _lpDefault$[ebp]
  00118	51		 push	 ecx
  00119	8b 55 0c	 mov	 edx, DWORD PTR _lpKey$[ebp]
  0011c	52		 push	 edx
  0011d	8b 45 08	 mov	 eax, DWORD PTR _lpSection$[ebp]
  00120	50		 push	 eax
  00121	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	e8 00 00 00 00	 call	 ?__GetStringDynamic@YL_Ini@@IBEPADPBD00@Z ; YL_Ini::__GetStringDynamic
  00129	89 45 fc	 mov	 DWORD PTR _psz$[ebp], eax

; 76   : 	DWORD dwLen = (DWORD)_tcslen(psz);

  0012c	8b 4d fc	 mov	 ecx, DWORD PTR _psz$[ebp]
  0012f	51		 push	 ecx
  00130	e8 00 00 00 00	 call	 _strlen
  00135	83 c4 04	 add	 esp, 4
  00138	89 45 f8	 mov	 DWORD PTR _dwLen$[ebp], eax

; 77   : 
; 78   : 	if (lpBuffer != NULL)

  0013b	83 7d 10 00	 cmp	 DWORD PTR _lpBuffer$[ebp], 0
  0013f	74 30		 je	 SHORT $L56177

; 79   : 	{
; 80   : 		_tcsncpy(lpBuffer, psz, dwBufSize);

  00141	8b 55 14	 mov	 edx, DWORD PTR _dwBufSize$[ebp]
  00144	52		 push	 edx
  00145	8b 45 fc	 mov	 eax, DWORD PTR _psz$[ebp]
  00148	50		 push	 eax
  00149	8b 4d 10	 mov	 ecx, DWORD PTR _lpBuffer$[ebp]
  0014c	51		 push	 ecx
  0014d	e8 00 00 00 00	 call	 __tcsncpy
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH

; 81   : 		dwLen = min(dwLen, dwBufSize);

  00155	8b 55 f8	 mov	 edx, DWORD PTR _dwLen$[ebp]
  00158	3b 55 14	 cmp	 edx, DWORD PTR _dwBufSize$[ebp]
  0015b	73 08		 jae	 SHORT $L56572
  0015d	8b 45 f8	 mov	 eax, DWORD PTR _dwLen$[ebp]
  00160	89 45 ec	 mov	 DWORD PTR tv77[ebp], eax
  00163	eb 06		 jmp	 SHORT $L56573
$L56572:
  00165	8b 4d 14	 mov	 ecx, DWORD PTR _dwBufSize$[ebp]
  00168	89 4d ec	 mov	 DWORD PTR tv77[ebp], ecx
$L56573:
  0016b	8b 55 ec	 mov	 edx, DWORD PTR tv77[ebp]
  0016e	89 55 f8	 mov	 DWORD PTR _dwLen$[ebp], edx
$L56177:

; 82   : 	}
; 83   : 
; 84   : 	delete [] psz;

  00171	8b 45 fc	 mov	 eax, DWORD PTR _psz$[ebp]
  00174	89 45 f4	 mov	 DWORD PTR $T56574[ebp], eax
  00177	8b 4d f4	 mov	 ecx, DWORD PTR $T56574[ebp]
  0017a	51		 push	 ecx
  0017b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00180	83 c4 04	 add	 esp, 4

; 85   : 	return dwLen;

  00183	8b 45 f8	 mov	 eax, DWORD PTR _dwLen$[ebp]

; 86   : }

  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c2 14 00	 ret	 20			; 00000014H
?GetString@YL_Ini@@QBEKPBD0PADK0@Z ENDP			; YL_Ini::GetString
_TEXT	ENDS
EXTRN	__imp___mbsnbcpy:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\tchar.h
;	COMDAT __tcsncpy
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__n$ = 16						; size = 4
__tcsncpy PROC NEAR					; COMDAT

; 843  : __inline _PC _tcsncpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcpy((_PUC)_s1,(_CPUC)_s2,_n);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __n$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __s2$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __s1$[ebp]
  0000e	52		 push	 edx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsnbcpy
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
__tcsncpy ENDP
_TEXT	ENDS
PUBLIC	?WriteString@YL_Ini@@QBEHPBD00@Z		; YL_Ini::WriteString
EXTRN	__imp__WritePrivateProfileStringA@16:NEAR
; Function compile flags: /Odt
; File d:\boxgit\playbox\commonlib\common\yl_ini.cpp
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_lpValue$ = 16						; size = 4
?WriteString@YL_Ini@@QBEHPBD00@Z PROC NEAR		; YL_Ini::WriteString
; _this$ = ecx

; 90   : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp
  00193	83 ec 08	 sub	 esp, 8
  00196	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 91   : 	if (lpSection == NULL || lpKey == NULL)

  00199	83 7d 08 00	 cmp	 DWORD PTR _lpSection$[ebp], 0
  0019d	74 06		 je	 SHORT $L56186
  0019f	83 7d 0c 00	 cmp	 DWORD PTR _lpKey$[ebp], 0
  001a3	75 04		 jne	 SHORT $L56185
$L56186:

; 92   : 		return FALSE;

  001a5	33 c0		 xor	 eax, eax
  001a7	eb 2e		 jmp	 SHORT $L56184
$L56185:

; 93   : 
; 94   : 	return ::WritePrivateProfileString(lpSection, lpKey, lpValue == NULL ? _T("") : lpValue, m_pszPathName);

  001a9	83 7d 10 00	 cmp	 DWORD PTR _lpValue$[ebp], 0
  001ad	75 09		 jne	 SHORT $L56578
  001af	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], OFFSET FLAT:$SG56187
  001b6	eb 06		 jmp	 SHORT $L56579
$L56578:
  001b8	8b 45 10	 mov	 eax, DWORD PTR _lpValue$[ebp]
  001bb	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L56579:
  001be	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001c4	52		 push	 edx
  001c5	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]
  001c8	50		 push	 eax
  001c9	8b 4d 0c	 mov	 ecx, DWORD PTR _lpKey$[ebp]
  001cc	51		 push	 ecx
  001cd	8b 55 08	 mov	 edx, DWORD PTR _lpSection$[ebp]
  001d0	52		 push	 edx
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16
$L56184:

; 95   : }

  001d7	8b e5		 mov	 esp, ebp
  001d9	5d		 pop	 ebp
  001da	c2 0c 00	 ret	 12			; 0000000cH
?WriteString@YL_Ini@@QBEHPBD00@Z ENDP			; YL_Ini::WriteString
_TEXT	ENDS
PUBLIC	?GetInt@YL_Ini@@QBEHPBD0HH@Z			; YL_Ini::GetInt
PUBLIC	?__ValidateBase@YL_Ini@@KAHH@Z			; YL_Ini::__ValidateBase
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__strtoul:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv86 = -88						; size = 4
_this$ = -84						; size = 4
_sz$ = -80						; size = 65
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_nDefault$ = 16						; size = 4
_nBase$ = 20						; size = 4
?GetInt@YL_Ini@@QBEHPBD0HH@Z PROC NEAR			; YL_Ini::GetInt
; _this$ = ecx

; 103  : {

  001e0	55		 push	 ebp
  001e1	8b ec		 mov	 ebp, esp
  001e3	83 ec 58	 sub	 esp, 88			; 00000058H
  001e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  001eb	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  001ee	57		 push	 edi
  001ef	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 104  : 	TCHAR sz[DEF_PROFILE_NUM_LEN + 1] = _T("");

  001f2	a0 00 00 00 00	 mov	 al, BYTE PTR $SG56196
  001f7	88 45 b0	 mov	 BYTE PTR _sz$[ebp], al
  001fa	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001ff	33 c0		 xor	 eax, eax
  00201	8d 7d b1	 lea	 edi, DWORD PTR _sz$[ebp+1]
  00204	f3 ab		 rep stosd

; 105  : 	GetString(lpSection, lpKey, sz, DEF_PROFILE_NUM_LEN);

  00206	6a 00		 push	 0
  00208	6a 40		 push	 64			; 00000040H
  0020a	8d 4d b0	 lea	 ecx, DWORD PTR _sz$[ebp]
  0020d	51		 push	 ecx
  0020e	8b 55 0c	 mov	 edx, DWORD PTR _lpKey$[ebp]
  00211	52		 push	 edx
  00212	8b 45 08	 mov	 eax, DWORD PTR _lpSection$[ebp]
  00215	50		 push	 eax
  00216	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00219	e8 00 00 00 00	 call	 ?GetString@YL_Ini@@QBEKPBD0PADK0@Z ; YL_Ini::GetString

; 106  : 	return *sz == _T('\0') ? nDefault : int(_tcstoul(sz, NULL, __ValidateBase(nBase)));

  0021e	0f be 4d b0	 movsx	 ecx, BYTE PTR _sz$[ebp]
  00222	85 c9		 test	 ecx, ecx
  00224	75 08		 jne	 SHORT $L56582
  00226	8b 55 10	 mov	 edx, DWORD PTR _nDefault$[ebp]
  00229	89 55 a8	 mov	 DWORD PTR tv86[ebp], edx
  0022c	eb 1f		 jmp	 SHORT $L56583
$L56582:
  0022e	8b 45 14	 mov	 eax, DWORD PTR _nBase$[ebp]
  00231	50		 push	 eax
  00232	e8 00 00 00 00	 call	 ?__ValidateBase@YL_Ini@@KAHH@Z ; YL_Ini::__ValidateBase
  00237	83 c4 04	 add	 esp, 4
  0023a	50		 push	 eax
  0023b	6a 00		 push	 0
  0023d	8d 4d b0	 lea	 ecx, DWORD PTR _sz$[ebp]
  00240	51		 push	 ecx
  00241	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtoul
  00247	83 c4 0c	 add	 esp, 12			; 0000000cH
  0024a	89 45 a8	 mov	 DWORD PTR tv86[ebp], eax
$L56583:
  0024d	8b 45 a8	 mov	 eax, DWORD PTR tv86[ebp]

; 107  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00258	5f		 pop	 edi
  00259	8b e5		 mov	 esp, ebp
  0025b	5d		 pop	 ebp
  0025c	c2 10 00	 ret	 16			; 00000010H
?GetInt@YL_Ini@@QBEHPBD0HH@Z ENDP			; YL_Ini::GetInt
_TEXT	ENDS
PUBLIC	?GetUInt@YL_Ini@@QBEIPBD0IH@Z			; YL_Ini::GetUInt
; Function compile flags: /Odt
_TEXT	SEGMENT
tv86 = -88						; size = 4
_this$ = -84						; size = 4
_sz$ = -80						; size = 65
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_nDefault$ = 16						; size = 4
_nBase$ = 20						; size = 4
?GetUInt@YL_Ini@@QBEIPBD0IH@Z PROC NEAR			; YL_Ini::GetUInt
; _this$ = ecx

; 111  : {

  00260	55		 push	 ebp
  00261	8b ec		 mov	 ebp, esp
  00263	83 ec 58	 sub	 esp, 88			; 00000058H
  00266	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0026b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0026e	57		 push	 edi
  0026f	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 	TCHAR sz[DEF_PROFILE_NUM_LEN + 1] = _T("");

  00272	a0 00 00 00 00	 mov	 al, BYTE PTR $SG56205
  00277	88 45 b0	 mov	 BYTE PTR _sz$[ebp], al
  0027a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0027f	33 c0		 xor	 eax, eax
  00281	8d 7d b1	 lea	 edi, DWORD PTR _sz$[ebp+1]
  00284	f3 ab		 rep stosd

; 113  : 	GetString(lpSection, lpKey, sz, DEF_PROFILE_NUM_LEN);

  00286	6a 00		 push	 0
  00288	6a 40		 push	 64			; 00000040H
  0028a	8d 4d b0	 lea	 ecx, DWORD PTR _sz$[ebp]
  0028d	51		 push	 ecx
  0028e	8b 55 0c	 mov	 edx, DWORD PTR _lpKey$[ebp]
  00291	52		 push	 edx
  00292	8b 45 08	 mov	 eax, DWORD PTR _lpSection$[ebp]
  00295	50		 push	 eax
  00296	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00299	e8 00 00 00 00	 call	 ?GetString@YL_Ini@@QBEKPBD0PADK0@Z ; YL_Ini::GetString

; 114  : 	return *sz == _T('\0') ? nDefault : UINT(_tcstoul(sz, NULL, __ValidateBase(nBase)));

  0029e	0f be 4d b0	 movsx	 ecx, BYTE PTR _sz$[ebp]
  002a2	85 c9		 test	 ecx, ecx
  002a4	75 08		 jne	 SHORT $L56589
  002a6	8b 55 10	 mov	 edx, DWORD PTR _nDefault$[ebp]
  002a9	89 55 a8	 mov	 DWORD PTR tv86[ebp], edx
  002ac	eb 1f		 jmp	 SHORT $L56590
$L56589:
  002ae	8b 45 14	 mov	 eax, DWORD PTR _nBase$[ebp]
  002b1	50		 push	 eax
  002b2	e8 00 00 00 00	 call	 ?__ValidateBase@YL_Ini@@KAHH@Z ; YL_Ini::__ValidateBase
  002b7	83 c4 04	 add	 esp, 4
  002ba	50		 push	 eax
  002bb	6a 00		 push	 0
  002bd	8d 4d b0	 lea	 ecx, DWORD PTR _sz$[ebp]
  002c0	51		 push	 ecx
  002c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtoul
  002c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ca	89 45 a8	 mov	 DWORD PTR tv86[ebp], eax
$L56590:
  002cd	8b 45 a8	 mov	 eax, DWORD PTR tv86[ebp]

; 115  : }

  002d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d8	5f		 pop	 edi
  002d9	8b e5		 mov	 esp, ebp
  002db	5d		 pop	 ebp
  002dc	c2 10 00	 ret	 16			; 00000010H
?GetUInt@YL_Ini@@QBEIPBD0IH@Z ENDP			; YL_Ini::GetUInt
_TEXT	ENDS
PUBLIC	?GetBool@YL_Ini@@QBEHPBD0H@Z			; YL_Ini::GetBool
PUBLIC	?StringToBool@YL_Ini@@SAHPBDH@Z			; YL_Ini::StringToBool
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -84						; size = 4
_sz$ = -80						; size = 65
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_bDefault$ = 16						; size = 4
?GetBool@YL_Ini@@QBEHPBD0H@Z PROC NEAR			; YL_Ini::GetBool
; _this$ = ecx

; 119  : {

  002e0	55		 push	 ebp
  002e1	8b ec		 mov	 ebp, esp
  002e3	83 ec 54	 sub	 esp, 84			; 00000054H
  002e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  002eb	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  002ee	57		 push	 edi
  002ef	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 120  : 	TCHAR sz[DEF_PROFILE_NUM_LEN + 1] = _T("");

  002f2	a0 00 00 00 00	 mov	 al, BYTE PTR $SG56213
  002f7	88 45 b0	 mov	 BYTE PTR _sz$[ebp], al
  002fa	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  002ff	33 c0		 xor	 eax, eax
  00301	8d 7d b1	 lea	 edi, DWORD PTR _sz$[ebp+1]
  00304	f3 ab		 rep stosd

; 121  : 	GetString(lpSection, lpKey, sz, DEF_PROFILE_NUM_LEN);

  00306	6a 00		 push	 0
  00308	6a 40		 push	 64			; 00000040H
  0030a	8d 4d b0	 lea	 ecx, DWORD PTR _sz$[ebp]
  0030d	51		 push	 ecx
  0030e	8b 55 0c	 mov	 edx, DWORD PTR _lpKey$[ebp]
  00311	52		 push	 edx
  00312	8b 45 08	 mov	 eax, DWORD PTR _lpSection$[ebp]
  00315	50		 push	 eax
  00316	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00319	e8 00 00 00 00	 call	 ?GetString@YL_Ini@@QBEKPBD0PADK0@Z ; YL_Ini::GetString

; 122  : 	return StringToBool(sz, bDefault);

  0031e	8b 4d 10	 mov	 ecx, DWORD PTR _bDefault$[ebp]
  00321	51		 push	 ecx
  00322	8d 55 b0	 lea	 edx, DWORD PTR _sz$[ebp]
  00325	52		 push	 edx
  00326	e8 00 00 00 00	 call	 ?StringToBool@YL_Ini@@SAHPBDH@Z ; YL_Ini::StringToBool
  0032b	83 c4 08	 add	 esp, 8

; 123  : }

  0032e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00331	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00336	5f		 pop	 edi
  00337	8b e5		 mov	 esp, ebp
  00339	5d		 pop	 ebp
  0033a	c2 0c 00	 ret	 12			; 0000000cH
?GetBool@YL_Ini@@QBEHPBD0H@Z ENDP			; YL_Ini::GetBool
_TEXT	ENDS
PUBLIC	?GetDouble@YL_Ini@@QBENPBD0N@Z			; YL_Ini::GetDouble
EXTRN	__fltused:NEAR
EXTRN	__imp__strtod:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv83 = -92						; size = 8
_this$ = -84						; size = 4
_sz$ = -80						; size = 65
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_fDefault$ = 16						; size = 8
?GetDouble@YL_Ini@@QBENPBD0N@Z PROC NEAR		; YL_Ini::GetDouble
; _this$ = ecx

; 127  : {

  00340	55		 push	 ebp
  00341	8b ec		 mov	 ebp, esp
  00343	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00346	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0034b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0034e	57		 push	 edi
  0034f	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 	TCHAR sz[DEF_PROFILE_NUM_LEN + 1] = _T("");

  00352	a0 00 00 00 00	 mov	 al, BYTE PTR $SG56221
  00357	88 45 b0	 mov	 BYTE PTR _sz$[ebp], al
  0035a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0035f	33 c0		 xor	 eax, eax
  00361	8d 7d b1	 lea	 edi, DWORD PTR _sz$[ebp+1]
  00364	f3 ab		 rep stosd

; 129  : 	GetString(lpSection, lpKey, sz, DEF_PROFILE_NUM_LEN);

  00366	6a 00		 push	 0
  00368	6a 40		 push	 64			; 00000040H
  0036a	8d 4d b0	 lea	 ecx, DWORD PTR _sz$[ebp]
  0036d	51		 push	 ecx
  0036e	8b 55 0c	 mov	 edx, DWORD PTR _lpKey$[ebp]
  00371	52		 push	 edx
  00372	8b 45 08	 mov	 eax, DWORD PTR _lpSection$[ebp]
  00375	50		 push	 eax
  00376	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00379	e8 00 00 00 00	 call	 ?GetString@YL_Ini@@QBEKPBD0PADK0@Z ; YL_Ini::GetString

; 130  : 	return *sz == _T('\0') ? fDefault : _tcstod(sz, NULL);

  0037e	0f be 4d b0	 movsx	 ecx, BYTE PTR _sz$[ebp]
  00382	85 c9		 test	 ecx, ecx
  00384	75 08		 jne	 SHORT $L56597
  00386	dd 45 10	 fld	 QWORD PTR _fDefault$[ebp]
  00389	dd 5d a4	 fstp	 QWORD PTR tv83[ebp]
  0038c	eb 12		 jmp	 SHORT $L56598
$L56597:
  0038e	6a 00		 push	 0
  00390	8d 55 b0	 lea	 edx, DWORD PTR _sz$[ebp]
  00393	52		 push	 edx
  00394	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtod
  0039a	83 c4 08	 add	 esp, 8
  0039d	dd 5d a4	 fstp	 QWORD PTR tv83[ebp]
$L56598:
  003a0	dd 45 a4	 fld	 QWORD PTR tv83[ebp]

; 131  : }

  003a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ab	5f		 pop	 edi
  003ac	8b e5		 mov	 esp, ebp
  003ae	5d		 pop	 ebp
  003af	c2 10 00	 ret	 16			; 00000010H
?GetDouble@YL_Ini@@QBENPBD0N@Z ENDP			; YL_Ini::GetDouble
_TEXT	ENDS
PUBLIC	?WriteInt@YL_Ini@@QBEHPBD0HH@Z			; YL_Ini::WriteInt
PUBLIC	?__IntToString@YL_Ini@@KAXHPADH@Z		; YL_Ini::__IntToString
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -84						; size = 4
_szValue$ = -80						; size = 65
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_nValue$ = 16						; size = 4
_nBase$ = 20						; size = 4
?WriteInt@YL_Ini@@QBEHPBD0HH@Z PROC NEAR		; YL_Ini::WriteInt
; _this$ = ecx

; 135  : {

  003c0	55		 push	 ebp
  003c1	8b ec		 mov	 ebp, esp
  003c3	83 ec 54	 sub	 esp, 84			; 00000054H
  003c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  003cb	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  003ce	57		 push	 edi
  003cf	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 136  : 	TCHAR szValue[DEF_PROFILE_NUM_LEN + 1] = _T("");

  003d2	a0 00 00 00 00	 mov	 al, BYTE PTR $SG56230
  003d7	88 45 b0	 mov	 BYTE PTR _szValue$[ebp], al
  003da	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  003df	33 c0		 xor	 eax, eax
  003e1	8d 7d b1	 lea	 edi, DWORD PTR _szValue$[ebp+1]
  003e4	f3 ab		 rep stosd

; 137  : 	__IntToString(nValue, szValue, nBase);

  003e6	8b 4d 14	 mov	 ecx, DWORD PTR _nBase$[ebp]
  003e9	51		 push	 ecx
  003ea	8d 55 b0	 lea	 edx, DWORD PTR _szValue$[ebp]
  003ed	52		 push	 edx
  003ee	8b 45 10	 mov	 eax, DWORD PTR _nValue$[ebp]
  003f1	50		 push	 eax
  003f2	e8 00 00 00 00	 call	 ?__IntToString@YL_Ini@@KAXHPADH@Z ; YL_Ini::__IntToString
  003f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 138  : 	return WriteString(lpSection, lpKey, szValue);

  003fa	8d 4d b0	 lea	 ecx, DWORD PTR _szValue$[ebp]
  003fd	51		 push	 ecx
  003fe	8b 55 0c	 mov	 edx, DWORD PTR _lpKey$[ebp]
  00401	52		 push	 edx
  00402	8b 45 08	 mov	 eax, DWORD PTR _lpSection$[ebp]
  00405	50		 push	 eax
  00406	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00409	e8 00 00 00 00	 call	 ?WriteString@YL_Ini@@QBEHPBD00@Z ; YL_Ini::WriteString

; 139  : }

  0040e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00411	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00416	5f		 pop	 edi
  00417	8b e5		 mov	 esp, ebp
  00419	5d		 pop	 ebp
  0041a	c2 10 00	 ret	 16			; 00000010H
?WriteInt@YL_Ini@@QBEHPBD0HH@Z ENDP			; YL_Ini::WriteInt
_TEXT	ENDS
PUBLIC	?WriteUInt@YL_Ini@@QBEHPBD0IH@Z			; YL_Ini::WriteUInt
PUBLIC	?__UIntToString@YL_Ini@@KAXIPADH@Z		; YL_Ini::__UIntToString
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -84						; size = 4
_szValue$ = -80						; size = 65
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_nValue$ = 16						; size = 4
_nBase$ = 20						; size = 4
?WriteUInt@YL_Ini@@QBEHPBD0IH@Z PROC NEAR		; YL_Ini::WriteUInt
; _this$ = ecx

; 143  : {

  00420	55		 push	 ebp
  00421	8b ec		 mov	 ebp, esp
  00423	83 ec 54	 sub	 esp, 84			; 00000054H
  00426	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0042b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0042e	57		 push	 edi
  0042f	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 144  : 	TCHAR szValue[DEF_PROFILE_NUM_LEN + 1] = _T("");

  00432	a0 00 00 00 00	 mov	 al, BYTE PTR $SG56239
  00437	88 45 b0	 mov	 BYTE PTR _szValue$[ebp], al
  0043a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0043f	33 c0		 xor	 eax, eax
  00441	8d 7d b1	 lea	 edi, DWORD PTR _szValue$[ebp+1]
  00444	f3 ab		 rep stosd

; 145  : 	__UIntToString(nValue, szValue, nBase);

  00446	8b 4d 14	 mov	 ecx, DWORD PTR _nBase$[ebp]
  00449	51		 push	 ecx
  0044a	8d 55 b0	 lea	 edx, DWORD PTR _szValue$[ebp]
  0044d	52		 push	 edx
  0044e	8b 45 10	 mov	 eax, DWORD PTR _nValue$[ebp]
  00451	50		 push	 eax
  00452	e8 00 00 00 00	 call	 ?__UIntToString@YL_Ini@@KAXIPADH@Z ; YL_Ini::__UIntToString
  00457	83 c4 0c	 add	 esp, 12			; 0000000cH

; 146  : 	return WriteString(lpSection, lpKey, szValue);

  0045a	8d 4d b0	 lea	 ecx, DWORD PTR _szValue$[ebp]
  0045d	51		 push	 ecx
  0045e	8b 55 0c	 mov	 edx, DWORD PTR _lpKey$[ebp]
  00461	52		 push	 edx
  00462	8b 45 08	 mov	 eax, DWORD PTR _lpSection$[ebp]
  00465	50		 push	 eax
  00466	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00469	e8 00 00 00 00	 call	 ?WriteString@YL_Ini@@QBEHPBD00@Z ; YL_Ini::WriteString

; 147  : }

  0046e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00471	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00476	5f		 pop	 edi
  00477	8b e5		 mov	 esp, ebp
  00479	5d		 pop	 ebp
  0047a	c2 10 00	 ret	 16			; 00000010H
?WriteUInt@YL_Ini@@QBEHPBD0IH@Z ENDP			; YL_Ini::WriteUInt
_TEXT	ENDS
PUBLIC	?WriteDouble@YL_Ini@@QBEHPBD0NH@Z		; YL_Ini::WriteDouble
EXTRN	__imp___snprintf:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -100						; size = 4
_szFmt$ = -96						; size = 16
_szValue$ = -80						; size = 65
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_fValue$ = 16						; size = 8
_nPrecision$ = 24					; size = 4
?WriteDouble@YL_Ini@@QBEHPBD0NH@Z PROC NEAR		; YL_Ini::WriteDouble
; _this$ = ecx

; 151  : {

  00480	55		 push	 ebp
  00481	8b ec		 mov	 ebp, esp
  00483	83 ec 64	 sub	 esp, 100		; 00000064H
  00486	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0048b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0048e	57		 push	 edi
  0048f	89 4d 9c	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 	TCHAR szFmt[16] = _T("%f");

  00492	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG56248
  00498	66 89 45 a0	 mov	 WORD PTR _szFmt$[ebp], ax
  0049c	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR $SG56248+2
  004a2	88 4d a2	 mov	 BYTE PTR _szFmt$[ebp+2], cl
  004a5	33 d2		 xor	 edx, edx
  004a7	89 55 a3	 mov	 DWORD PTR _szFmt$[ebp+3], edx
  004aa	89 55 a7	 mov	 DWORD PTR _szFmt$[ebp+7], edx
  004ad	89 55 ab	 mov	 DWORD PTR _szFmt$[ebp+11], edx
  004b0	88 55 af	 mov	 BYTE PTR _szFmt$[ebp+15], dl

; 153  : 
; 154  : 	if (nPrecision > 0)

  004b3	83 7d 18 00	 cmp	 DWORD PTR _nPrecision$[ebp], 0
  004b7	7e 18		 jle	 SHORT $L56249

; 155  : 		_sntprintf(szFmt, sizeof(szFmt)-1, _T("%%.%df"), nPrecision);

  004b9	8b 45 18	 mov	 eax, DWORD PTR _nPrecision$[ebp]
  004bc	50		 push	 eax
  004bd	68 00 00 00 00	 push	 OFFSET FLAT:$SG56250
  004c2	6a 0f		 push	 15			; 0000000fH
  004c4	8d 4d a0	 lea	 ecx, DWORD PTR _szFmt$[ebp]
  004c7	51		 push	 ecx
  004c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  004ce	83 c4 10	 add	 esp, 16			; 00000010H
$L56249:

; 156  : 
; 157  : 	TCHAR szValue[DEF_PROFILE_NUM_LEN + 1] = _T("");

  004d1	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR $SG56252
  004d7	88 55 b0	 mov	 BYTE PTR _szValue$[ebp], dl
  004da	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  004df	33 c0		 xor	 eax, eax
  004e1	8d 7d b1	 lea	 edi, DWORD PTR _szValue$[ebp+1]
  004e4	f3 ab		 rep stosd

; 158  : 	_sntprintf(szValue, DEF_PROFILE_NUM_LEN, szFmt, fValue);

  004e6	dd 45 10	 fld	 QWORD PTR _fValue$[ebp]
  004e9	83 ec 08	 sub	 esp, 8
  004ec	dd 1c 24	 fstp	 QWORD PTR [esp]
  004ef	8d 45 a0	 lea	 eax, DWORD PTR _szFmt$[ebp]
  004f2	50		 push	 eax
  004f3	6a 40		 push	 64			; 00000040H
  004f5	8d 4d b0	 lea	 ecx, DWORD PTR _szValue$[ebp]
  004f8	51		 push	 ecx
  004f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  004ff	83 c4 14	 add	 esp, 20			; 00000014H

; 159  : 	return WriteString(lpSection, lpKey, szValue);

  00502	8d 55 b0	 lea	 edx, DWORD PTR _szValue$[ebp]
  00505	52		 push	 edx
  00506	8b 45 0c	 mov	 eax, DWORD PTR _lpKey$[ebp]
  00509	50		 push	 eax
  0050a	8b 4d 08	 mov	 ecx, DWORD PTR _lpSection$[ebp]
  0050d	51		 push	 ecx
  0050e	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00511	e8 00 00 00 00	 call	 ?WriteString@YL_Ini@@QBEHPBD00@Z ; YL_Ini::WriteString

; 160  : }

  00516	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00519	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0051e	5f		 pop	 edi
  0051f	8b e5		 mov	 esp, ebp
  00521	5d		 pop	 ebp
  00522	c2 14 00	 ret	 20			; 00000014H
?WriteDouble@YL_Ini@@QBEHPBD0NH@Z ENDP			; YL_Ini::WriteDouble
_TEXT	ENDS
PUBLIC	?WriteBool@YL_Ini@@QBEHPBD0H@Z			; YL_Ini::WriteBool
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_bValue$ = 16						; size = 4
?WriteBool@YL_Ini@@QBEHPBD0H@Z PROC NEAR		; YL_Ini::WriteBool
; _this$ = ecx

; 165  : {

  00530	55		 push	 ebp
  00531	8b ec		 mov	 ebp, esp
  00533	51		 push	 ecx
  00534	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 	return WriteInt(lpSection, lpKey, bValue ? 1 : 0, BASE_DECIMAL);

  00537	6a 0a		 push	 10			; 0000000aH
  00539	33 c0		 xor	 eax, eax
  0053b	83 7d 10 00	 cmp	 DWORD PTR _bValue$[ebp], 0
  0053f	0f 95 c0	 setne	 al
  00542	50		 push	 eax
  00543	8b 4d 0c	 mov	 ecx, DWORD PTR _lpKey$[ebp]
  00546	51		 push	 ecx
  00547	8b 55 08	 mov	 edx, DWORD PTR _lpSection$[ebp]
  0054a	52		 push	 edx
  0054b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0054e	e8 00 00 00 00	 call	 ?WriteInt@YL_Ini@@QBEHPBD0HH@Z ; YL_Ini::WriteInt

; 167  : }

  00553	8b e5		 mov	 esp, ebp
  00555	5d		 pop	 ebp
  00556	c2 0c 00	 ret	 12			; 0000000cH
?WriteBool@YL_Ini@@QBEHPBD0H@Z ENDP			; YL_Ini::WriteBool
_TEXT	ENDS
PUBLIC	?GetChar@YL_Ini@@QBEDPBD0D@Z			; YL_Ini::GetChar
; Function compile flags: /Odt
_TEXT	SEGMENT
tv80 = -9						; size = 1
_this$ = -8						; size = 4
_sz$ = -4						; size = 2
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_cDefault$ = 16						; size = 1
?GetChar@YL_Ini@@QBEDPBD0D@Z PROC NEAR			; YL_Ini::GetChar
; _this$ = ecx

; 170  : {

  00560	55		 push	 ebp
  00561	8b ec		 mov	 ebp, esp
  00563	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00566	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 	TCHAR sz[2] = _T("");

  00569	a0 00 00 00 00	 mov	 al, BYTE PTR $SG56266
  0056e	88 45 fc	 mov	 BYTE PTR _sz$[ebp], al
  00571	33 c9		 xor	 ecx, ecx
  00573	88 4d fd	 mov	 BYTE PTR _sz$[ebp+1], cl

; 172  : 	GetString(lpSection, lpKey, sz, 1);

  00576	6a 00		 push	 0
  00578	6a 01		 push	 1
  0057a	8d 55 fc	 lea	 edx, DWORD PTR _sz$[ebp]
  0057d	52		 push	 edx
  0057e	8b 45 0c	 mov	 eax, DWORD PTR _lpKey$[ebp]
  00581	50		 push	 eax
  00582	8b 4d 08	 mov	 ecx, DWORD PTR _lpSection$[ebp]
  00585	51		 push	 ecx
  00586	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00589	e8 00 00 00 00	 call	 ?GetString@YL_Ini@@QBEKPBD0PADK0@Z ; YL_Ini::GetString

; 173  : 	return *sz == _T('\0') ? cDefault : sz[0];

  0058e	0f be 55 fc	 movsx	 edx, BYTE PTR _sz$[ebp]
  00592	85 d2		 test	 edx, edx
  00594	75 08		 jne	 SHORT $L56612
  00596	8a 45 10	 mov	 al, BYTE PTR _cDefault$[ebp]
  00599	88 45 f7	 mov	 BYTE PTR tv80[ebp], al
  0059c	eb 06		 jmp	 SHORT $L56613
$L56612:
  0059e	8a 4d fc	 mov	 cl, BYTE PTR _sz$[ebp]
  005a1	88 4d f7	 mov	 BYTE PTR tv80[ebp], cl
$L56613:
  005a4	8a 45 f7	 mov	 al, BYTE PTR tv80[ebp]

; 174  : }

  005a7	8b e5		 mov	 esp, ebp
  005a9	5d		 pop	 ebp
  005aa	c2 0c 00	 ret	 12			; 0000000cH
?GetChar@YL_Ini@@QBEDPBD0D@Z ENDP			; YL_Ini::GetChar
_TEXT	ENDS
PUBLIC	?WriteChar@YL_Ini@@QBEHPBD0D@Z			; YL_Ini::WriteChar
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -8						; size = 4
_sz$ = -4						; size = 2
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_c$ = 16						; size = 1
?WriteChar@YL_Ini@@QBEHPBD0D@Z PROC NEAR		; YL_Ini::WriteChar
; _this$ = ecx

; 177  : {

  005b0	55		 push	 ebp
  005b1	8b ec		 mov	 ebp, esp
  005b3	83 ec 08	 sub	 esp, 8
  005b6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 178  : 	TCHAR sz[2] = { c, _T('\0') };

  005b9	8a 45 10	 mov	 al, BYTE PTR _c$[ebp]
  005bc	88 45 fc	 mov	 BYTE PTR _sz$[ebp], al
  005bf	c6 45 fd 00	 mov	 BYTE PTR _sz$[ebp+1], 0

; 179  : 	return WriteString(lpSection, lpKey, sz);

  005c3	8d 4d fc	 lea	 ecx, DWORD PTR _sz$[ebp]
  005c6	51		 push	 ecx
  005c7	8b 55 0c	 mov	 edx, DWORD PTR _lpKey$[ebp]
  005ca	52		 push	 edx
  005cb	8b 45 08	 mov	 eax, DWORD PTR _lpSection$[ebp]
  005ce	50		 push	 eax
  005cf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005d2	e8 00 00 00 00	 call	 ?WriteString@YL_Ini@@QBEHPBD00@Z ; YL_Ini::WriteString

; 180  : }

  005d7	8b e5		 mov	 esp, ebp
  005d9	5d		 pop	 ebp
  005da	c2 0c 00	 ret	 12			; 0000000cH
?WriteChar@YL_Ini@@QBEHPBD0D@Z ENDP			; YL_Ini::WriteChar
_TEXT	ENDS
PUBLIC	?GetDataBlock@YL_Ini@@QBEKPBD0PAXKK@Z		; YL_Ini::GetDataBlock
; Function compile flags: /Odt
_TEXT	SEGMENT
tv128 = -56						; size = 4
_this$ = -52						; size = 4
$T56620 = -48						; size = 4
$T56617 = -44						; size = 4
$T56616 = -40						; size = 4
_sz$56307 = -36						; size = 3
_i$56303 = -32						; size = 4
_p$56302 = -28						; size = 4
_c$56291 = -21						; size = 1
_i$56287 = -20						; size = 4
_dwLen$ = -16						; size = 4
_lpb$ = -12						; size = 4
_dwProcLen$ = -8					; size = 4
_psz$ = -4						; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_lpBuffer$ = 16						; size = 4
_dwBufSize$ = 20					; size = 4
_dwOffset$ = 24						; size = 4
?GetDataBlock@YL_Ini@@QBEKPBD0PAXKK@Z PROC NEAR		; YL_Ini::GetDataBlock
; _this$ = ecx

; 188  : {

  005e0	55		 push	 ebp
  005e1	8b ec		 mov	 ebp, esp
  005e3	83 ec 38	 sub	 esp, 56			; 00000038H
  005e6	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 189  : 	LPTSTR psz = __GetStringDynamic(lpSection, lpKey);

  005e9	6a 00		 push	 0
  005eb	8b 45 0c	 mov	 eax, DWORD PTR _lpKey$[ebp]
  005ee	50		 push	 eax
  005ef	8b 4d 08	 mov	 ecx, DWORD PTR _lpSection$[ebp]
  005f2	51		 push	 ecx
  005f3	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  005f6	e8 00 00 00 00	 call	 ?__GetStringDynamic@YL_Ini@@IBEPADPBD00@Z ; YL_Ini::__GetStringDynamic
  005fb	89 45 fc	 mov	 DWORD PTR _psz$[ebp], eax

; 190  : 	DWORD dwLen = (DWORD)_tcslen(psz) / 2;

  005fe	8b 55 fc	 mov	 edx, DWORD PTR _psz$[ebp]
  00601	52		 push	 edx
  00602	e8 00 00 00 00	 call	 _strlen
  00607	83 c4 04	 add	 esp, 4
  0060a	d1 e8		 shr	 eax, 1
  0060c	89 45 f0	 mov	 DWORD PTR _dwLen$[ebp], eax

; 191  : 	if (dwLen <= dwOffset)

  0060f	8b 45 f0	 mov	 eax, DWORD PTR _dwLen$[ebp]
  00612	3b 45 18	 cmp	 eax, DWORD PTR _dwOffset$[ebp]
  00615	77 19		 ja	 SHORT $L56285

; 192  : 	{
; 193  : 		delete [] psz;

  00617	8b 4d fc	 mov	 ecx, DWORD PTR _psz$[ebp]
  0061a	89 4d d8	 mov	 DWORD PTR $T56616[ebp], ecx
  0061d	8b 55 d8	 mov	 edx, DWORD PTR $T56616[ebp]
  00620	52		 push	 edx
  00621	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00626	83 c4 04	 add	 esp, 4

; 194  : 		return 0;

  00629	33 c0		 xor	 eax, eax
  0062b	e9 41 01 00 00	 jmp	 $L56281
$L56285:

; 195  : 	}
; 196  : 
; 197  : 	// verify psz, must be all in hex format
; 198  : 	for (int i = 0; psz[i] != _T('\0'); i++)

  00630	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$56287[ebp], 0
  00637	eb 09		 jmp	 SHORT $L56288
$L56289:
  00639	8b 45 ec	 mov	 eax, DWORD PTR _i$56287[ebp]
  0063c	83 c0 01	 add	 eax, 1
  0063f	89 45 ec	 mov	 DWORD PTR _i$56287[ebp], eax
$L56288:
  00642	8b 4d fc	 mov	 ecx, DWORD PTR _psz$[ebp]
  00645	03 4d ec	 add	 ecx, DWORD PTR _i$56287[ebp]
  00648	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0064b	85 d2		 test	 edx, edx
  0064d	74 5e		 je	 SHORT $L56290

; 199  : 	{
; 200  : 		TCHAR c = psz[i];

  0064f	8b 45 fc	 mov	 eax, DWORD PTR _psz$[ebp]
  00652	03 45 ec	 add	 eax, DWORD PTR _i$56287[ebp]
  00655	8a 08		 mov	 cl, BYTE PTR [eax]
  00657	88 4d eb	 mov	 BYTE PTR _c$56291[ebp], cl

; 201  : 		if ((c >= _T('0') && c <= _T('9'))
; 202  : 			|| (c >= _T('a') && c <= _T('f'))
; 203  : 			|| (c >= _T('A') && c <= _T('F')))

  0065a	0f be 55 eb	 movsx	 edx, BYTE PTR _c$56291[ebp]
  0065e	83 fa 30	 cmp	 edx, 48			; 00000030H
  00661	7c 09		 jl	 SHORT $L56294
  00663	0f be 45 eb	 movsx	 eax, BYTE PTR _c$56291[ebp]
  00667	83 f8 39	 cmp	 eax, 57			; 00000039H
  0066a	7e 24		 jle	 SHORT $L56293
$L56294:
  0066c	0f be 4d eb	 movsx	 ecx, BYTE PTR _c$56291[ebp]
  00670	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00673	7c 09		 jl	 SHORT $L56295
  00675	0f be 55 eb	 movsx	 edx, BYTE PTR _c$56291[ebp]
  00679	83 fa 66	 cmp	 edx, 102		; 00000066H
  0067c	7e 12		 jle	 SHORT $L56293
$L56295:
  0067e	0f be 45 eb	 movsx	 eax, BYTE PTR _c$56291[ebp]
  00682	83 f8 41	 cmp	 eax, 65			; 00000041H
  00685	7c 0b		 jl	 SHORT $L56292
  00687	0f be 4d eb	 movsx	 ecx, BYTE PTR _c$56291[ebp]
  0068b	83 f9 46	 cmp	 ecx, 70			; 00000046H
  0068e	7f 02		 jg	 SHORT $L56292
$L56293:

; 204  : 		{
; 205  : 			// valid
; 206  : 		}
; 207  : 		else

  00690	eb 19		 jmp	 SHORT $L56296
$L56292:

; 208  : 		{
; 209  : 			delete [] psz;

  00692	8b 55 fc	 mov	 edx, DWORD PTR _psz$[ebp]
  00695	89 55 d4	 mov	 DWORD PTR $T56617[ebp], edx
  00698	8b 45 d4	 mov	 eax, DWORD PTR $T56617[ebp]
  0069b	50		 push	 eax
  0069c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  006a1	83 c4 04	 add	 esp, 4

; 210  : 			return 0;

  006a4	33 c0		 xor	 eax, eax
  006a6	e9 c6 00 00 00	 jmp	 $L56281
$L56296:

; 211  : 		}
; 212  : 	}

  006ab	eb 8c		 jmp	 SHORT $L56289
$L56290:

; 213  : 
; 214  : 	DWORD dwProcLen = 0;

  006ad	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwProcLen$[ebp], 0

; 215  : 	LPBYTE lpb = (LPBYTE)lpBuffer;

  006b4	8b 4d 10	 mov	 ecx, DWORD PTR _lpBuffer$[ebp]
  006b7	89 4d f4	 mov	 DWORD PTR _lpb$[ebp], ecx

; 216  : 
; 217  : 	if (lpb != NULL)

  006ba	83 7d f4 00	 cmp	 DWORD PTR _lpb$[ebp], 0
  006be	0f 84 8f 00 00
	00		 je	 $L56301

; 218  : 	{
; 219  : 		dwProcLen = min(dwLen - dwOffset, dwBufSize);

  006c4	8b 55 f0	 mov	 edx, DWORD PTR _dwLen$[ebp]
  006c7	2b 55 18	 sub	 edx, DWORD PTR _dwOffset$[ebp]
  006ca	3b 55 14	 cmp	 edx, DWORD PTR _dwBufSize$[ebp]
  006cd	73 0b		 jae	 SHORT $L56618
  006cf	8b 45 f0	 mov	 eax, DWORD PTR _dwLen$[ebp]
  006d2	2b 45 18	 sub	 eax, DWORD PTR _dwOffset$[ebp]
  006d5	89 45 c8	 mov	 DWORD PTR tv128[ebp], eax
  006d8	eb 06		 jmp	 SHORT $L56619
$L56618:
  006da	8b 4d 14	 mov	 ecx, DWORD PTR _dwBufSize$[ebp]
  006dd	89 4d c8	 mov	 DWORD PTR tv128[ebp], ecx
$L56619:
  006e0	8b 55 c8	 mov	 edx, DWORD PTR tv128[ebp]
  006e3	89 55 f8	 mov	 DWORD PTR _dwProcLen$[ebp], edx

; 220  : 		LPCTSTR p = &psz[dwOffset * 2];

  006e6	8b 45 18	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  006e9	8b 4d fc	 mov	 ecx, DWORD PTR _psz$[ebp]
  006ec	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  006ef	89 55 e4	 mov	 DWORD PTR _p$56302[ebp], edx

; 221  : 		for (DWORD i = 0; i < dwProcLen; i++)

  006f2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$56303[ebp], 0
  006f9	eb 09		 jmp	 SHORT $L56304
$L56305:
  006fb	8b 45 e0	 mov	 eax, DWORD PTR _i$56303[ebp]
  006fe	83 c0 01	 add	 eax, 1
  00701	89 45 e0	 mov	 DWORD PTR _i$56303[ebp], eax
$L56304:
  00704	8b 4d e0	 mov	 ecx, DWORD PTR _i$56303[ebp]
  00707	3b 4d f8	 cmp	 ecx, DWORD PTR _dwProcLen$[ebp]
  0070a	73 45		 jae	 SHORT $L56306

; 222  : 		{			
; 223  : 			TCHAR sz[3] = _T("");

  0070c	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR $SG56308
  00712	88 55 dc	 mov	 BYTE PTR _sz$56307[ebp], dl
  00715	33 c0		 xor	 eax, eax
  00717	66 89 45 dd	 mov	 WORD PTR _sz$56307[ebp+1], ax

; 224  : 			_tcsncpy(sz, p, 2);			

  0071b	6a 02		 push	 2
  0071d	8b 4d e4	 mov	 ecx, DWORD PTR _p$56302[ebp]
  00720	51		 push	 ecx
  00721	8d 55 dc	 lea	 edx, DWORD PTR _sz$56307[ebp]
  00724	52		 push	 edx
  00725	e8 00 00 00 00	 call	 __tcsncpy
  0072a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 225  : 			lpb[i] = BYTE(_tcstoul(sz, NULL, 16));

  0072d	6a 10		 push	 16			; 00000010H
  0072f	6a 00		 push	 0
  00731	8d 45 dc	 lea	 eax, DWORD PTR _sz$56307[ebp]
  00734	50		 push	 eax
  00735	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtoul
  0073b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0073e	8b 4d f4	 mov	 ecx, DWORD PTR _lpb$[ebp]
  00741	03 4d e0	 add	 ecx, DWORD PTR _i$56303[ebp]
  00744	88 01		 mov	 BYTE PTR [ecx], al

; 226  : 			p = &p[2];

  00746	8b 55 e4	 mov	 edx, DWORD PTR _p$56302[ebp]
  00749	83 c2 02	 add	 edx, 2
  0074c	89 55 e4	 mov	 DWORD PTR _p$56302[ebp], edx

; 227  : 		}			

  0074f	eb aa		 jmp	 SHORT $L56305
$L56306:

; 228  : 	}
; 229  : 	else

  00751	eb 09		 jmp	 SHORT $L56309
$L56301:

; 230  : 	{
; 231  : 		dwProcLen = dwLen - dwOffset;

  00753	8b 45 f0	 mov	 eax, DWORD PTR _dwLen$[ebp]
  00756	2b 45 18	 sub	 eax, DWORD PTR _dwOffset$[ebp]
  00759	89 45 f8	 mov	 DWORD PTR _dwProcLen$[ebp], eax
$L56309:

; 232  : 	}
; 233  : 	delete [] psz;

  0075c	8b 4d fc	 mov	 ecx, DWORD PTR _psz$[ebp]
  0075f	89 4d d0	 mov	 DWORD PTR $T56620[ebp], ecx
  00762	8b 55 d0	 mov	 edx, DWORD PTR $T56620[ebp]
  00765	52		 push	 edx
  00766	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0076b	83 c4 04	 add	 esp, 4

; 234  : 	return dwProcLen;

  0076e	8b 45 f8	 mov	 eax, DWORD PTR _dwProcLen$[ebp]
$L56281:

; 235  : }

  00771	8b e5		 mov	 esp, ebp
  00773	5d		 pop	 ebp
  00774	c2 14 00	 ret	 20			; 00000014H
?GetDataBlock@YL_Ini@@QBEKPBD0PAXKK@Z ENDP		; YL_Ini::GetDataBlock
_TEXT	ENDS
PUBLIC	?WriteDataBlock@YL_Ini@@QBEHPBD0PBXK@Z		; YL_Ini::WriteDataBlock
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	__imp__sprintf:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T56623 = -28						; size = 4
$T56622 = -24						; size = 4
_j$56325 = -20						; size = 4
_i$56324 = -16						; size = 4
_lpb$ = -12						; size = 4
_RES$ = -8						; size = 4
_psz$ = -4						; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_lpData$ = 16						; size = 4
_dwDataSize$ = 20					; size = 4
?WriteDataBlock@YL_Ini@@QBEHPBD0PBXK@Z PROC NEAR	; YL_Ini::WriteDataBlock
; _this$ = ecx

; 239  : {

  00780	55		 push	 ebp
  00781	8b ec		 mov	 ebp, esp
  00783	83 ec 20	 sub	 esp, 32			; 00000020H
  00786	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 240  : 	const BYTE* lpb = (const BYTE*)lpData;

  00789	8b 45 10	 mov	 eax, DWORD PTR _lpData$[ebp]
  0078c	89 45 f4	 mov	 DWORD PTR _lpb$[ebp], eax

; 241  : 	if (lpb == NULL)

  0078f	83 7d f4 00	 cmp	 DWORD PTR _lpb$[ebp], 0
  00793	75 07		 jne	 SHORT $L56320

; 242  : 		return FALSE;

  00795	33 c0		 xor	 eax, eax
  00797	e9 90 00 00 00	 jmp	 $L56317
$L56320:

; 243  : 
; 244  : 	LPTSTR psz = new TCHAR[dwDataSize * 2 + 1];

  0079c	8b 4d 14	 mov	 ecx, DWORD PTR _dwDataSize$[ebp]
  0079f	8d 54 09 01	 lea	 edx, DWORD PTR [ecx+ecx+1]
  007a3	52		 push	 edx
  007a4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  007a9	83 c4 04	 add	 esp, 4
  007ac	89 45 e8	 mov	 DWORD PTR $T56622[ebp], eax
  007af	8b 45 e8	 mov	 eax, DWORD PTR $T56622[ebp]
  007b2	89 45 fc	 mov	 DWORD PTR _psz$[ebp], eax

; 245  : 	for (DWORD i = 0, j = 0; i < dwDataSize; i++, j += 2)

  007b5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$56324[ebp], 0
  007bc	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _j$56325[ebp], 0
  007c3	eb 12		 jmp	 SHORT $L56326
$L56327:
  007c5	8b 4d f0	 mov	 ecx, DWORD PTR _i$56324[ebp]
  007c8	83 c1 01	 add	 ecx, 1
  007cb	89 4d f0	 mov	 DWORD PTR _i$56324[ebp], ecx
  007ce	8b 55 ec	 mov	 edx, DWORD PTR _j$56325[ebp]
  007d1	83 c2 02	 add	 edx, 2
  007d4	89 55 ec	 mov	 DWORD PTR _j$56325[ebp], edx
$L56326:
  007d7	8b 45 f0	 mov	 eax, DWORD PTR _i$56324[ebp]
  007da	3b 45 14	 cmp	 eax, DWORD PTR _dwDataSize$[ebp]
  007dd	73 21		 jae	 SHORT $L56328

; 246  : 		_stprintf(&psz[j], _T("%02X"), lpb[i]);

  007df	8b 4d f4	 mov	 ecx, DWORD PTR _lpb$[ebp]
  007e2	03 4d f0	 add	 ecx, DWORD PTR _i$56324[ebp]
  007e5	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  007e8	52		 push	 edx
  007e9	68 00 00 00 00	 push	 OFFSET FLAT:$SG56329
  007ee	8b 45 fc	 mov	 eax, DWORD PTR _psz$[ebp]
  007f1	03 45 ec	 add	 eax, DWORD PTR _j$56325[ebp]
  007f4	50		 push	 eax
  007f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  007fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  007fe	eb c5		 jmp	 SHORT $L56327
$L56328:

; 247  : 	const BOOL RES = WriteString(lpSection, lpKey, psz);

  00800	8b 4d fc	 mov	 ecx, DWORD PTR _psz$[ebp]
  00803	51		 push	 ecx
  00804	8b 55 0c	 mov	 edx, DWORD PTR _lpKey$[ebp]
  00807	52		 push	 edx
  00808	8b 45 08	 mov	 eax, DWORD PTR _lpSection$[ebp]
  0080b	50		 push	 eax
  0080c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0080f	e8 00 00 00 00	 call	 ?WriteString@YL_Ini@@QBEHPBD00@Z ; YL_Ini::WriteString
  00814	89 45 f8	 mov	 DWORD PTR _RES$[ebp], eax

; 248  : 	delete [] psz;

  00817	8b 4d fc	 mov	 ecx, DWORD PTR _psz$[ebp]
  0081a	89 4d e4	 mov	 DWORD PTR $T56623[ebp], ecx
  0081d	8b 55 e4	 mov	 edx, DWORD PTR $T56623[ebp]
  00820	52		 push	 edx
  00821	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00826	83 c4 04	 add	 esp, 4

; 249  : 	return RES;

  00829	8b 45 f8	 mov	 eax, DWORD PTR _RES$[ebp]
$L56317:

; 250  : }

  0082c	8b e5		 mov	 esp, ebp
  0082e	5d		 pop	 ebp
  0082f	c2 10 00	 ret	 16			; 00000010H
?WriteDataBlock@YL_Ini@@QBEHPBD0PBXK@Z ENDP		; YL_Ini::WriteDataBlock
_TEXT	ENDS
PUBLIC	?GetPoint@YL_Ini@@QBE?AUtagPOINT@@PBD0U2@@Z	; YL_Ini::GetPoint
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pt$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
_lpSection$ = 12					; size = 4
_lpKey$ = 16						; size = 4
_ptDefault$ = 20					; size = 8
?GetPoint@YL_Ini@@QBE?AUtagPOINT@@PBD0U2@@Z PROC NEAR	; YL_Ini::GetPoint
; _this$ = ecx

; 254  : {

  00840	55		 push	 ebp
  00841	8b ec		 mov	 ebp, esp
  00843	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00846	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 255  : 	POINT pt;
; 256  : 	if (GetDataBlock(lpSection, lpKey, &pt, sizeof(POINT)) != sizeof(POINT))

  00849	6a 00		 push	 0
  0084b	6a 08		 push	 8
  0084d	8d 45 f8	 lea	 eax, DWORD PTR _pt$[ebp]
  00850	50		 push	 eax
  00851	8b 4d 10	 mov	 ecx, DWORD PTR _lpKey$[ebp]
  00854	51		 push	 ecx
  00855	8b 55 0c	 mov	 edx, DWORD PTR _lpSection$[ebp]
  00858	52		 push	 edx
  00859	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0085c	e8 00 00 00 00	 call	 ?GetDataBlock@YL_Ini@@QBEKPBD0PAXKK@Z ; YL_Ini::GetDataBlock
  00861	83 f8 08	 cmp	 eax, 8
  00864	74 0c		 je	 SHORT $L56342

; 257  : 		pt = ptDefault;

  00866	8b 45 14	 mov	 eax, DWORD PTR _ptDefault$[ebp]
  00869	89 45 f8	 mov	 DWORD PTR _pt$[ebp], eax
  0086c	8b 4d 18	 mov	 ecx, DWORD PTR _ptDefault$[ebp+4]
  0086f	89 4d fc	 mov	 DWORD PTR _pt$[ebp+4], ecx
$L56342:

; 258  : 	return pt;

  00872	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00875	8b 45 f8	 mov	 eax, DWORD PTR _pt$[ebp]
  00878	89 02		 mov	 DWORD PTR [edx], eax
  0087a	8b 4d fc	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  0087d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00880	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 259  : }

  00883	8b e5		 mov	 esp, ebp
  00885	5d		 pop	 ebp
  00886	c2 14 00	 ret	 20			; 00000014H
?GetPoint@YL_Ini@@QBE?AUtagPOINT@@PBD0U2@@Z ENDP	; YL_Ini::GetPoint
_TEXT	ENDS
PUBLIC	?GetRect@YL_Ini@@QBE?AUtagRECT@@PBD0U2@@Z	; YL_Ini::GetRect
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -20						; size = 4
_rc$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_lpSection$ = 12					; size = 4
_lpKey$ = 16						; size = 4
_rcDefault$ = 20					; size = 16
?GetRect@YL_Ini@@QBE?AUtagRECT@@PBD0U2@@Z PROC NEAR	; YL_Ini::GetRect
; _this$ = ecx

; 263  : {

  00890	55		 push	 ebp
  00891	8b ec		 mov	 ebp, esp
  00893	83 ec 14	 sub	 esp, 20			; 00000014H
  00896	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 264  : 	RECT rc;
; 265  : 	if (GetDataBlock(lpSection, lpKey, &rc, sizeof(RECT)) != sizeof(RECT))

  00899	6a 00		 push	 0
  0089b	6a 10		 push	 16			; 00000010H
  0089d	8d 45 f0	 lea	 eax, DWORD PTR _rc$[ebp]
  008a0	50		 push	 eax
  008a1	8b 4d 10	 mov	 ecx, DWORD PTR _lpKey$[ebp]
  008a4	51		 push	 ecx
  008a5	8b 55 0c	 mov	 edx, DWORD PTR _lpSection$[ebp]
  008a8	52		 push	 edx
  008a9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  008ac	e8 00 00 00 00	 call	 ?GetDataBlock@YL_Ini@@QBEKPBD0PAXKK@Z ; YL_Ini::GetDataBlock
  008b1	83 f8 10	 cmp	 eax, 16			; 00000010H
  008b4	74 18		 je	 SHORT $L56353

; 266  : 		rc = rcDefault;

  008b6	8b 45 14	 mov	 eax, DWORD PTR _rcDefault$[ebp]
  008b9	89 45 f0	 mov	 DWORD PTR _rc$[ebp], eax
  008bc	8b 4d 18	 mov	 ecx, DWORD PTR _rcDefault$[ebp+4]
  008bf	89 4d f4	 mov	 DWORD PTR _rc$[ebp+4], ecx
  008c2	8b 55 1c	 mov	 edx, DWORD PTR _rcDefault$[ebp+8]
  008c5	89 55 f8	 mov	 DWORD PTR _rc$[ebp+8], edx
  008c8	8b 45 20	 mov	 eax, DWORD PTR _rcDefault$[ebp+12]
  008cb	89 45 fc	 mov	 DWORD PTR _rc$[ebp+12], eax
$L56353:

; 267  : 	return rc;

  008ce	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  008d1	8b 55 f0	 mov	 edx, DWORD PTR _rc$[ebp]
  008d4	89 11		 mov	 DWORD PTR [ecx], edx
  008d6	8b 45 f4	 mov	 eax, DWORD PTR _rc$[ebp+4]
  008d9	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  008dc	8b 55 f8	 mov	 edx, DWORD PTR _rc$[ebp+8]
  008df	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  008e2	8b 45 fc	 mov	 eax, DWORD PTR _rc$[ebp+12]
  008e5	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  008e8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 268  : }

  008eb	8b e5		 mov	 esp, ebp
  008ed	5d		 pop	 ebp
  008ee	c2 1c 00	 ret	 28			; 0000001cH
?GetRect@YL_Ini@@QBE?AUtagRECT@@PBD0U2@@Z ENDP		; YL_Ini::GetRect
_TEXT	ENDS
PUBLIC	?WritePoint@YL_Ini@@QBEHPBD0UtagPOINT@@@Z	; YL_Ini::WritePoint
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_pt$ = 16						; size = 8
?WritePoint@YL_Ini@@QBEHPBD0UtagPOINT@@@Z PROC NEAR	; YL_Ini::WritePoint
; _this$ = ecx

; 272  : {

  00900	55		 push	 ebp
  00901	8b ec		 mov	 ebp, esp
  00903	51		 push	 ecx
  00904	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 273  : 	return WriteDataBlock(lpSection, lpKey, &pt, sizeof(POINT));

  00907	6a 08		 push	 8
  00909	8d 45 10	 lea	 eax, DWORD PTR _pt$[ebp]
  0090c	50		 push	 eax
  0090d	8b 4d 0c	 mov	 ecx, DWORD PTR _lpKey$[ebp]
  00910	51		 push	 ecx
  00911	8b 55 08	 mov	 edx, DWORD PTR _lpSection$[ebp]
  00914	52		 push	 edx
  00915	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00918	e8 00 00 00 00	 call	 ?WriteDataBlock@YL_Ini@@QBEHPBD0PBXK@Z ; YL_Ini::WriteDataBlock

; 274  : }

  0091d	8b e5		 mov	 esp, ebp
  0091f	5d		 pop	 ebp
  00920	c2 10 00	 ret	 16			; 00000010H
?WritePoint@YL_Ini@@QBEHPBD0UtagPOINT@@@Z ENDP		; YL_Ini::WritePoint
_TEXT	ENDS
PUBLIC	?WriteRect@YL_Ini@@QBEHPBD0UtagRECT@@@Z		; YL_Ini::WriteRect
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_rc$ = 16						; size = 16
?WriteRect@YL_Ini@@QBEHPBD0UtagRECT@@@Z PROC NEAR	; YL_Ini::WriteRect
; _this$ = ecx

; 278  : {

  00930	55		 push	 ebp
  00931	8b ec		 mov	 ebp, esp
  00933	51		 push	 ecx
  00934	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 	return WriteDataBlock(lpSection, lpKey, &rc, sizeof(RECT));

  00937	6a 10		 push	 16			; 00000010H
  00939	8d 45 10	 lea	 eax, DWORD PTR _rc$[ebp]
  0093c	50		 push	 eax
  0093d	8b 4d 0c	 mov	 ecx, DWORD PTR _lpKey$[ebp]
  00940	51		 push	 ecx
  00941	8b 55 08	 mov	 edx, DWORD PTR _lpSection$[ebp]
  00944	52		 push	 edx
  00945	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00948	e8 00 00 00 00	 call	 ?WriteDataBlock@YL_Ini@@QBEHPBD0PBXK@Z ; YL_Ini::WriteDataBlock

; 280  : }

  0094d	8b e5		 mov	 esp, ebp
  0094f	5d		 pop	 ebp
  00950	c2 18 00	 ret	 24			; 00000018H
?WriteRect@YL_Ini@@QBEHPBD0UtagRECT@@@Z ENDP		; YL_Ini::WriteRect
_TEXT	ENDS
PUBLIC	?DeleteSection@YL_Ini@@QBEHPBD@Z		; YL_Ini::DeleteSection
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpSection$ = 8						; size = 4
?DeleteSection@YL_Ini@@QBEHPBD@Z PROC NEAR		; YL_Ini::DeleteSection
; _this$ = ecx

; 284  : {

  00960	55		 push	 ebp
  00961	8b ec		 mov	 ebp, esp
  00963	51		 push	 ecx
  00964	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 285  : 	return ::WritePrivateProfileString(lpSection, NULL, _T(""), m_pszPathName);

  00967	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0096a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0096d	51		 push	 ecx
  0096e	68 00 00 00 00	 push	 OFFSET FLAT:$SG56372
  00973	6a 00		 push	 0
  00975	8b 55 08	 mov	 edx, DWORD PTR _lpSection$[ebp]
  00978	52		 push	 edx
  00979	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16

; 286  : }

  0097f	8b e5		 mov	 esp, ebp
  00981	5d		 pop	 ebp
  00982	c2 04 00	 ret	 4
?DeleteSection@YL_Ini@@QBEHPBD@Z ENDP			; YL_Ini::DeleteSection
_TEXT	ENDS
PUBLIC	?DeleteValue@YL_Ini@@QBEHPBD0@Z			; YL_Ini::DeleteValue
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
?DeleteValue@YL_Ini@@QBEHPBD0@Z PROC NEAR		; YL_Ini::DeleteValue
; _this$ = ecx

; 290  : {

  00990	55		 push	 ebp
  00991	8b ec		 mov	 ebp, esp
  00993	51		 push	 ecx
  00994	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 291  : 	return ::WritePrivateProfileString(lpSection, lpKey, NULL, m_pszPathName);

  00997	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0099a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0099d	51		 push	 ecx
  0099e	6a 00		 push	 0
  009a0	8b 55 0c	 mov	 edx, DWORD PTR _lpKey$[ebp]
  009a3	52		 push	 edx
  009a4	8b 45 08	 mov	 eax, DWORD PTR _lpSection$[ebp]
  009a7	50		 push	 eax
  009a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16

; 292  : }

  009ae	8b e5		 mov	 esp, ebp
  009b0	5d		 pop	 ebp
  009b1	c2 08 00	 ret	 8
?DeleteValue@YL_Ini@@QBEHPBD0@Z ENDP			; YL_Ini::DeleteValue
_TEXT	ENDS
EXTRN	__imp__GetPrivateProfileStringA@24:NEAR
EXTRN	_strcpy:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv134 = -44						; size = 4
tv85 = -40						; size = 4
_this$ = -36						; size = 4
$T56637 = -32						; size = 4
$T56636 = -28						; size = 4
$T56633 = -24						; size = 4
$T56632 = -20						; size = 4
$T56631 = -16						; size = 4
_dwLen$ = -12						; size = 4
_dwCopied$ = -8						; size = 4
_psz$ = -4						; size = 4
_lpSection$ = 8						; size = 4
_lpKey$ = 12						; size = 4
_lpDefault$ = 16					; size = 4
?__GetStringDynamic@YL_Ini@@IBEPADPBD00@Z PROC NEAR	; YL_Ini::__GetStringDynamic
; _this$ = ecx

; 303  : {

  009c0	55		 push	 ebp
  009c1	8b ec		 mov	 ebp, esp
  009c3	83 ec 2c	 sub	 esp, 44			; 0000002cH
  009c6	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 304  : 	TCHAR* psz = NULL;

  009c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _psz$[ebp], 0

; 305  : 	if (lpSection == NULL || lpKey == NULL)

  009d0	83 7d 08 00	 cmp	 DWORD PTR _lpSection$[ebp], 0
  009d4	74 06		 je	 SHORT $L56386
  009d6	83 7d 0c 00	 cmp	 DWORD PTR _lpKey$[ebp], 0
  009da	75 5a		 jne	 SHORT $L56385
$L56386:

; 306  : 	{
; 307  : 		// Invalid section or key name, just return the default string
; 308  : 		if (lpDefault == NULL)

  009dc	83 7d 10 00	 cmp	 DWORD PTR _lpDefault$[ebp], 0
  009e0	75 1b		 jne	 SHORT $L56387

; 309  : 		{
; 310  : 			// Empty string
; 311  : 			psz = new TCHAR[1];

  009e2	6a 01		 push	 1
  009e4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  009e9	83 c4 04	 add	 esp, 4
  009ec	89 45 f0	 mov	 DWORD PTR $T56631[ebp], eax
  009ef	8b 45 f0	 mov	 eax, DWORD PTR $T56631[ebp]
  009f2	89 45 fc	 mov	 DWORD PTR _psz$[ebp], eax

; 312  : 			*psz = _T('\0');

  009f5	8b 4d fc	 mov	 ecx, DWORD PTR _psz$[ebp]
  009f8	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 313  : 		}
; 314  : 		else

  009fb	eb 31		 jmp	 SHORT $L56390
$L56387:

; 315  : 		{
; 316  : 			psz = new TCHAR[_tcslen(lpDefault) + 1];

  009fd	8b 55 10	 mov	 edx, DWORD PTR _lpDefault$[ebp]
  00a00	52		 push	 edx
  00a01	e8 00 00 00 00	 call	 _strlen
  00a06	83 c4 04	 add	 esp, 4
  00a09	83 c0 01	 add	 eax, 1
  00a0c	50		 push	 eax
  00a0d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00a12	83 c4 04	 add	 esp, 4
  00a15	89 45 ec	 mov	 DWORD PTR $T56632[ebp], eax
  00a18	8b 45 ec	 mov	 eax, DWORD PTR $T56632[ebp]
  00a1b	89 45 fc	 mov	 DWORD PTR _psz$[ebp], eax

; 317  : 			_tcscpy(psz, lpDefault);

  00a1e	8b 4d 10	 mov	 ecx, DWORD PTR _lpDefault$[ebp]
  00a21	51		 push	 ecx
  00a22	8b 55 fc	 mov	 edx, DWORD PTR _psz$[ebp]
  00a25	52		 push	 edx
  00a26	e8 00 00 00 00	 call	 _strcpy
  00a2b	83 c4 08	 add	 esp, 8
$L56390:

; 318  : 		}
; 319  : 		
; 320  : 		return psz;

  00a2e	8b 45 fc	 mov	 eax, DWORD PTR _psz$[ebp]
  00a31	e9 d7 00 00 00	 jmp	 $L56383
$L56385:

; 321  : 	}
; 322  : 	
; 323  : 	// Keep enlarging the buffer size until being certain on that the string we
; 324  : 	// retrieved was original(not truncated).
; 325  : 	DWORD dwLen = DEF_PROFILE_THRESHOLD;

  00a36	c7 45 f4 00 02
	00 00		 mov	 DWORD PTR _dwLen$[ebp], 512 ; 00000200H

; 326  : 	psz = new TCHAR[dwLen + 1];

  00a3d	8b 45 f4	 mov	 eax, DWORD PTR _dwLen$[ebp]
  00a40	83 c0 01	 add	 eax, 1
  00a43	50		 push	 eax
  00a44	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00a49	83 c4 04	 add	 esp, 4
  00a4c	89 45 e8	 mov	 DWORD PTR $T56633[ebp], eax
  00a4f	8b 4d e8	 mov	 ecx, DWORD PTR $T56633[ebp]
  00a52	89 4d fc	 mov	 DWORD PTR _psz$[ebp], ecx

; 327  : 	DWORD dwCopied = ::GetPrivateProfileString(lpSection, lpKey, lpDefault == NULL ? _T("") : lpDefault, psz, dwLen, m_pszPathName);

  00a55	83 7d 10 00	 cmp	 DWORD PTR _lpDefault$[ebp], 0
  00a59	75 09		 jne	 SHORT $L56634
  00a5b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], OFFSET FLAT:$SG56397
  00a62	eb 06		 jmp	 SHORT $L56635
$L56634:
  00a64	8b 55 10	 mov	 edx, DWORD PTR _lpDefault$[ebp]
  00a67	89 55 d8	 mov	 DWORD PTR tv85[ebp], edx
$L56635:
  00a6a	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00a6d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a70	51		 push	 ecx
  00a71	8b 55 f4	 mov	 edx, DWORD PTR _dwLen$[ebp]
  00a74	52		 push	 edx
  00a75	8b 45 fc	 mov	 eax, DWORD PTR _psz$[ebp]
  00a78	50		 push	 eax
  00a79	8b 4d d8	 mov	 ecx, DWORD PTR tv85[ebp]
  00a7c	51		 push	 ecx
  00a7d	8b 55 0c	 mov	 edx, DWORD PTR _lpKey$[ebp]
  00a80	52		 push	 edx
  00a81	8b 45 08	 mov	 eax, DWORD PTR _lpSection$[ebp]
  00a84	50		 push	 eax
  00a85	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24
  00a8b	89 45 f8	 mov	 DWORD PTR _dwCopied$[ebp], eax
$L56399:

; 328  : 	while (dwCopied + 1 >= dwLen)

  00a8e	8b 4d f8	 mov	 ecx, DWORD PTR _dwCopied$[ebp]
  00a91	83 c1 01	 add	 ecx, 1
  00a94	3b 4d f4	 cmp	 ecx, DWORD PTR _dwLen$[ebp]
  00a97	72 71		 jb	 SHORT $L56400

; 329  : 	{		
; 330  : 		dwLen += DEF_PROFILE_THRESHOLD;

  00a99	8b 55 f4	 mov	 edx, DWORD PTR _dwLen$[ebp]
  00a9c	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  00aa2	89 55 f4	 mov	 DWORD PTR _dwLen$[ebp], edx

; 331  : 		delete [] psz;

  00aa5	8b 45 fc	 mov	 eax, DWORD PTR _psz$[ebp]
  00aa8	89 45 e4	 mov	 DWORD PTR $T56636[ebp], eax
  00aab	8b 4d e4	 mov	 ecx, DWORD PTR $T56636[ebp]
  00aae	51		 push	 ecx
  00aaf	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ab4	83 c4 04	 add	 esp, 4

; 332  : 		psz = new TCHAR[dwLen + 1];

  00ab7	8b 55 f4	 mov	 edx, DWORD PTR _dwLen$[ebp]
  00aba	83 c2 01	 add	 edx, 1
  00abd	52		 push	 edx
  00abe	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00ac3	83 c4 04	 add	 esp, 4
  00ac6	89 45 e0	 mov	 DWORD PTR $T56637[ebp], eax
  00ac9	8b 45 e0	 mov	 eax, DWORD PTR $T56637[ebp]
  00acc	89 45 fc	 mov	 DWORD PTR _psz$[ebp], eax

; 333  : 		dwCopied = ::GetPrivateProfileString(lpSection, lpKey, lpDefault == NULL ? _T("") : lpDefault, psz, dwLen, m_pszPathName);

  00acf	83 7d 10 00	 cmp	 DWORD PTR _lpDefault$[ebp], 0
  00ad3	75 09		 jne	 SHORT $L56638
  00ad5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv134[ebp], OFFSET FLAT:$SG56404
  00adc	eb 06		 jmp	 SHORT $L56639
$L56638:
  00ade	8b 4d 10	 mov	 ecx, DWORD PTR _lpDefault$[ebp]
  00ae1	89 4d d4	 mov	 DWORD PTR tv134[ebp], ecx
$L56639:
  00ae4	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00ae7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00aea	50		 push	 eax
  00aeb	8b 4d f4	 mov	 ecx, DWORD PTR _dwLen$[ebp]
  00aee	51		 push	 ecx
  00aef	8b 55 fc	 mov	 edx, DWORD PTR _psz$[ebp]
  00af2	52		 push	 edx
  00af3	8b 45 d4	 mov	 eax, DWORD PTR tv134[ebp]
  00af6	50		 push	 eax
  00af7	8b 4d 0c	 mov	 ecx, DWORD PTR _lpKey$[ebp]
  00afa	51		 push	 ecx
  00afb	8b 55 08	 mov	 edx, DWORD PTR _lpSection$[ebp]
  00afe	52		 push	 edx
  00aff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24
  00b05	89 45 f8	 mov	 DWORD PTR _dwCopied$[ebp], eax

; 334  : 	}

  00b08	eb 84		 jmp	 SHORT $L56399
$L56400:

; 335  : 	
; 336  : 	return psz; // !!! Requires the caller to free this memory !!!

  00b0a	8b 45 fc	 mov	 eax, DWORD PTR _psz$[ebp]
$L56383:

; 337  : }

  00b0d	8b e5		 mov	 esp, ebp
  00b0f	5d		 pop	 ebp
  00b10	c2 0c 00	 ret	 12			; 0000000cH
?__GetStringDynamic@YL_Ini@@IBEPADPBD00@Z ENDP		; YL_Ini::__GetStringDynamic
_TEXT	ENDS
PUBLIC	__tcsrev
PUBLIC	?__ToBinaryString@YL_Ini@@KAXIPADK@Z		; YL_Ini::__ToBinaryString
; Function compile flags: /Odt
_TEXT	SEGMENT
_dwIndex$ = -4						; size = 4
_nNumber$ = 8						; size = 4
_lpBuffer$ = 12						; size = 4
_dwBufSize$ = 16					; size = 4
?__ToBinaryString@YL_Ini@@KAXIPADK@Z PROC NEAR		; YL_Ini::__ToBinaryString

; 342  : {

  00b20	55		 push	 ebp
  00b21	8b ec		 mov	 ebp, esp
  00b23	51		 push	 ecx

; 343  : 	if (dwBufSize == 0)

  00b24	83 7d 10 00	 cmp	 DWORD PTR _dwBufSize$[ebp], 0
  00b28	75 02		 jne	 SHORT $L56410

; 344  : 		return;

  00b2a	eb 57		 jmp	 SHORT $L56409
$L56410:

; 345  : 	
; 346  : 	DWORD dwIndex = 0;	

  00b2c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwIndex$[ebp], 0
$L56412:

; 347  : 	do
; 348  : 	{
; 349  : 		lpBuffer[dwIndex++] = (nNumber % 2) ? _T('1') : _T('0');

  00b33	8b 45 08	 mov	 eax, DWORD PTR _nNumber$[ebp]
  00b36	33 d2		 xor	 edx, edx
  00b38	b9 02 00 00 00	 mov	 ecx, 2
  00b3d	f7 f1		 div	 ecx
  00b3f	85 d2		 test	 edx, edx
  00b41	0f 95 c2	 setne	 dl
  00b44	80 c2 30	 add	 dl, 48			; 00000030H
  00b47	8b 45 0c	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  00b4a	03 45 fc	 add	 eax, DWORD PTR _dwIndex$[ebp]
  00b4d	88 10		 mov	 BYTE PTR [eax], dl
  00b4f	8b 4d fc	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00b52	83 c1 01	 add	 ecx, 1
  00b55	89 4d fc	 mov	 DWORD PTR _dwIndex$[ebp], ecx

; 350  : 		nNumber /= 2;

  00b58	8b 55 08	 mov	 edx, DWORD PTR _nNumber$[ebp]
  00b5b	d1 ea		 shr	 edx, 1
  00b5d	89 55 08	 mov	 DWORD PTR _nNumber$[ebp], edx

; 351  : 	} while (nNumber > 0 && dwIndex < dwBufSize);

  00b60	83 7d 08 00	 cmp	 DWORD PTR _nNumber$[ebp], 0
  00b64	76 08		 jbe	 SHORT $L56414
  00b66	8b 45 fc	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00b69	3b 45 10	 cmp	 eax, DWORD PTR _dwBufSize$[ebp]
  00b6c	72 c5		 jb	 SHORT $L56412
$L56414:

; 352  : 
; 353  : 	lpBuffer[dwIndex] = _T('\0');

  00b6e	8b 4d 0c	 mov	 ecx, DWORD PTR _lpBuffer$[ebp]
  00b71	03 4d fc	 add	 ecx, DWORD PTR _dwIndex$[ebp]
  00b74	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 354  : 	_tcsrev(lpBuffer);

  00b77	8b 55 0c	 mov	 edx, DWORD PTR _lpBuffer$[ebp]
  00b7a	52		 push	 edx
  00b7b	e8 00 00 00 00	 call	 __tcsrev
  00b80	83 c4 04	 add	 esp, 4
$L56409:

; 355  : }

  00b83	8b e5		 mov	 esp, ebp
  00b85	5d		 pop	 ebp
  00b86	c3		 ret	 0
?__ToBinaryString@YL_Ini@@KAXIPADK@Z ENDP		; YL_Ini::__ToBinaryString
_TEXT	ENDS
EXTRN	__imp___mbsrev:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\tchar.h
;	COMDAT __tcsrev
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__tcsrev PROC NEAR					; COMDAT

; 851  : __inline _PC _tcsrev(_PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __s1$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsrev
  0000d	83 c4 04	 add	 esp, 4
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
__tcsrev ENDP
; Function compile flags: /Odt
; File d:\boxgit\playbox\commonlib\common\yl_ini.cpp
_TEXT	ENDS
_TEXT	SEGMENT
tv64 = -4						; size = 4
_nBase$ = 8						; size = 4
?__ValidateBase@YL_Ini@@KAHH@Z PROC NEAR		; YL_Ini::__ValidateBase

; 359  : {

  00b90	55		 push	 ebp
  00b91	8b ec		 mov	 ebp, esp
  00b93	51		 push	 ecx

; 360  : 	switch (nBase)

  00b94	8b 45 08	 mov	 eax, DWORD PTR _nBase$[ebp]
  00b97	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  00b9a	83 7d fc 02	 cmp	 DWORD PTR tv64[ebp], 2
  00b9e	74 0e		 je	 SHORT $L56423
  00ba0	83 7d fc 08	 cmp	 DWORD PTR tv64[ebp], 8
  00ba4	74 08		 je	 SHORT $L56423
  00ba6	83 7d fc 10	 cmp	 DWORD PTR tv64[ebp], 16	; 00000010H
  00baa	74 02		 je	 SHORT $L56423
  00bac	eb 02		 jmp	 SHORT $L56424
$L56423:

; 361  : 	{
; 362  : 	case BASE_BINARY:
; 363  : 	case BASE_OCTAL:
; 364  : 	case BASE_HEXADECIMAL:
; 365  : 		break;

  00bae	eb 07		 jmp	 SHORT $L56420
$L56424:

; 366  : 
; 367  : 	default:
; 368  : 		nBase = BASE_DECIMAL;

  00bb0	c7 45 08 0a 00
	00 00		 mov	 DWORD PTR _nBase$[ebp], 10 ; 0000000aH
$L56420:

; 369  : 	}
; 370  : 
; 371  : 	return nBase;

  00bb7	8b 45 08	 mov	 eax, DWORD PTR _nBase$[ebp]

; 372  : }

  00bba	8b e5		 mov	 esp, ebp
  00bbc	5d		 pop	 ebp
  00bbd	c3		 ret	 0
?__ValidateBase@YL_Ini@@KAHH@Z ENDP			; YL_Ini::__ValidateBase
; Function compile flags: /Odt
tv64 = -4						; size = 4
_nNumber$ = 8						; size = 4
_lpBuffer$ = 12						; size = 4
_nBase$ = 16						; size = 4
?__IntToString@YL_Ini@@KAXHPADH@Z PROC NEAR		; YL_Ini::__IntToString

; 376  : {

  00bc0	55		 push	 ebp
  00bc1	8b ec		 mov	 ebp, esp
  00bc3	51		 push	 ecx

; 377  : 	switch (nBase)

  00bc4	8b 45 10	 mov	 eax, DWORD PTR _nBase$[ebp]
  00bc7	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  00bca	83 7d fc 02	 cmp	 DWORD PTR tv64[ebp], 2
  00bce	74 0e		 je	 SHORT $L56434
  00bd0	83 7d fc 08	 cmp	 DWORD PTR tv64[ebp], 8
  00bd4	74 08		 je	 SHORT $L56434
  00bd6	83 7d fc 10	 cmp	 DWORD PTR tv64[ebp], 16	; 00000010H
  00bda	74 02		 je	 SHORT $L56434
  00bdc	eb 16		 jmp	 SHORT $L56436
$L56434:

; 378  : 	{
; 379  : 	case BASE_BINARY:
; 380  : 	case BASE_OCTAL:
; 381  : 	case BASE_HEXADECIMAL:
; 382  : 		__UIntToString((UINT)nNumber, lpBuffer, nBase);

  00bde	8b 4d 10	 mov	 ecx, DWORD PTR _nBase$[ebp]
  00be1	51		 push	 ecx
  00be2	8b 55 0c	 mov	 edx, DWORD PTR _lpBuffer$[ebp]
  00be5	52		 push	 edx
  00be6	8b 45 08	 mov	 eax, DWORD PTR _nNumber$[ebp]
  00be9	50		 push	 eax
  00bea	e8 00 00 00 00	 call	 ?__UIntToString@YL_Ini@@KAXIPADH@Z ; YL_Ini::__UIntToString
  00bef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 383  : 		break;

  00bf2	eb 16		 jmp	 SHORT $L56429
$L56436:

; 384  : 
; 385  : 	default:
; 386  : 		_stprintf(lpBuffer, _T("%d"), nNumber);

  00bf4	8b 4d 08	 mov	 ecx, DWORD PTR _nNumber$[ebp]
  00bf7	51		 push	 ecx
  00bf8	68 00 00 00 00	 push	 OFFSET FLAT:$SG56437
  00bfd	8b 55 0c	 mov	 edx, DWORD PTR _lpBuffer$[ebp]
  00c00	52		 push	 edx
  00c01	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00c07	83 c4 0c	 add	 esp, 12			; 0000000cH
$L56429:

; 387  : 		break;
; 388  : 	}	
; 389  : }

  00c0a	8b e5		 mov	 esp, ebp
  00c0c	5d		 pop	 ebp
  00c0d	c3		 ret	 0
?__IntToString@YL_Ini@@KAXHPADH@Z ENDP			; YL_Ini::__IntToString
; Function compile flags: /Odt
tv64 = -4						; size = 4
_nNumber$ = 8						; size = 4
_lpBuffer$ = 12						; size = 4
_nBase$ = 16						; size = 4
?__UIntToString@YL_Ini@@KAXIPADH@Z PROC NEAR		; YL_Ini::__UIntToString

; 393  : {

  00c10	55		 push	 ebp
  00c11	8b ec		 mov	 ebp, esp
  00c13	51		 push	 ecx

; 394  : 	switch (nBase)

  00c14	8b 45 10	 mov	 eax, DWORD PTR _nBase$[ebp]
  00c17	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  00c1a	83 7d fc 02	 cmp	 DWORD PTR tv64[ebp], 2
  00c1e	74 0e		 je	 SHORT $L56447
  00c20	83 7d fc 08	 cmp	 DWORD PTR tv64[ebp], 8
  00c24	74 1c		 je	 SHORT $L56448
  00c26	83 7d fc 10	 cmp	 DWORD PTR tv64[ebp], 16	; 00000010H
  00c2a	74 2e		 je	 SHORT $L56450
  00c2c	eb 44		 jmp	 SHORT $L56452
$L56447:

; 395  : 	{
; 396  : 	case BASE_BINARY:
; 397  : 		__ToBinaryString(nNumber, lpBuffer, DEF_PROFILE_NUM_LEN);

  00c2e	6a 40		 push	 64			; 00000040H
  00c30	8b 4d 0c	 mov	 ecx, DWORD PTR _lpBuffer$[ebp]
  00c33	51		 push	 ecx
  00c34	8b 55 08	 mov	 edx, DWORD PTR _nNumber$[ebp]
  00c37	52		 push	 edx
  00c38	e8 00 00 00 00	 call	 ?__ToBinaryString@YL_Ini@@KAXIPADK@Z ; YL_Ini::__ToBinaryString
  00c3d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 398  : 		break;

  00c40	eb 46		 jmp	 SHORT $L56442
$L56448:

; 399  : 
; 400  : 	case BASE_OCTAL:
; 401  : 		_stprintf(lpBuffer, _T("%o"), nNumber);

  00c42	8b 45 08	 mov	 eax, DWORD PTR _nNumber$[ebp]
  00c45	50		 push	 eax
  00c46	68 00 00 00 00	 push	 OFFSET FLAT:$SG56449
  00c4b	8b 4d 0c	 mov	 ecx, DWORD PTR _lpBuffer$[ebp]
  00c4e	51		 push	 ecx
  00c4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00c55	83 c4 0c	 add	 esp, 12			; 0000000cH

; 402  : 		break;

  00c58	eb 2e		 jmp	 SHORT $L56442
$L56450:

; 403  : 
; 404  : 	case BASE_HEXADECIMAL:
; 405  : 		_stprintf(lpBuffer, _T("%X"), nNumber);

  00c5a	8b 55 08	 mov	 edx, DWORD PTR _nNumber$[ebp]
  00c5d	52		 push	 edx
  00c5e	68 00 00 00 00	 push	 OFFSET FLAT:$SG56451
  00c63	8b 45 0c	 mov	 eax, DWORD PTR _lpBuffer$[ebp]
  00c66	50		 push	 eax
  00c67	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00c6d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 406  : 		break;

  00c70	eb 16		 jmp	 SHORT $L56442
$L56452:

; 407  : 
; 408  : 	default:
; 409  : 		_stprintf(lpBuffer, _T("%u"), nNumber);

  00c72	8b 4d 08	 mov	 ecx, DWORD PTR _nNumber$[ebp]
  00c75	51		 push	 ecx
  00c76	68 00 00 00 00	 push	 OFFSET FLAT:$SG56453
  00c7b	8b 55 0c	 mov	 edx, DWORD PTR _lpBuffer$[ebp]
  00c7e	52		 push	 edx
  00c7f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00c85	83 c4 0c	 add	 esp, 12			; 0000000cH
$L56442:

; 410  : 		break;
; 411  : 	}	
; 412  : }

  00c88	8b e5		 mov	 esp, ebp
  00c8a	5d		 pop	 ebp
  00c8b	c3		 ret	 0
?__UIntToString@YL_Ini@@KAXIPADH@Z ENDP			; YL_Ini::__UIntToString
_TEXT	ENDS
PUBLIC	__tcsicmp
EXTRN	__imp__strtol:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv80 = -4						; size = 4
_lpString$ = 8						; size = 4
_bDefault$ = 12						; size = 4
?StringToBool@YL_Ini@@SAHPBDH@Z PROC NEAR		; YL_Ini::StringToBool

; 415  : {

  00c90	55		 push	 ebp
  00c91	8b ec		 mov	 ebp, esp
  00c93	51		 push	 ecx

; 416  : 	// Default: empty string
; 417  : 	// TRUE: "true", "yes", non-zero decimal numner
; 418  : 	// FALSE: all other cases
; 419  : 	if (lpString == NULL || *lpString == _T('\0'))

  00c94	83 7d 08 00	 cmp	 DWORD PTR _lpString$[ebp], 0
  00c98	74 0a		 je	 SHORT $L56459
  00c9a	8b 45 08	 mov	 eax, DWORD PTR _lpString$[ebp]
  00c9d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00ca0	85 c9		 test	 ecx, ecx
  00ca2	75 05		 jne	 SHORT $L56458
$L56459:

; 420  : 		return bDefault;

  00ca4	8b 45 0c	 mov	 eax, DWORD PTR _bDefault$[ebp]
  00ca7	eb 52		 jmp	 SHORT $L56457
$L56458:

; 421  : 
; 422  : 	return (_tcsicmp(lpString, _T("true")) == 0
; 423  : 		|| _tcsicmp(lpString, _T("yes")) == 0
; 424  : 		|| _tcstol(lpString, NULL, BASE_DECIMAL) != 0);

  00ca9	68 00 00 00 00	 push	 OFFSET FLAT:$SG56460
  00cae	8b 55 08	 mov	 edx, DWORD PTR _lpString$[ebp]
  00cb1	52		 push	 edx
  00cb2	e8 00 00 00 00	 call	 __tcsicmp
  00cb7	83 c4 08	 add	 esp, 8
  00cba	85 c0		 test	 eax, eax
  00cbc	74 33		 je	 SHORT $L56647
  00cbe	68 00 00 00 00	 push	 OFFSET FLAT:$SG56461
  00cc3	8b 45 08	 mov	 eax, DWORD PTR _lpString$[ebp]
  00cc6	50		 push	 eax
  00cc7	e8 00 00 00 00	 call	 __tcsicmp
  00ccc	83 c4 08	 add	 esp, 8
  00ccf	85 c0		 test	 eax, eax
  00cd1	74 1e		 je	 SHORT $L56647
  00cd3	6a 0a		 push	 10			; 0000000aH
  00cd5	6a 00		 push	 0
  00cd7	8b 4d 08	 mov	 ecx, DWORD PTR _lpString$[ebp]
  00cda	51		 push	 ecx
  00cdb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  00ce1	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ce4	85 c0		 test	 eax, eax
  00ce6	75 09		 jne	 SHORT $L56647
  00ce8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  00cef	eb 07		 jmp	 SHORT $L56648
$L56647:
  00cf1	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
$L56648:
  00cf8	8b 45 fc	 mov	 eax, DWORD PTR tv80[ebp]
$L56457:

; 425  : }

  00cfb	8b e5		 mov	 esp, ebp
  00cfd	5d		 pop	 ebp
  00cfe	c3		 ret	 0
?StringToBool@YL_Ini@@SAHPBDH@Z ENDP			; YL_Ini::StringToBool
_TEXT	ENDS
EXTRN	__imp___mbsicmp:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\tchar.h
;	COMDAT __tcsicmp
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcsicmp PROC NEAR					; COMDAT

; 855  : __inline int _tcsicmp(_CPC _s1,_CPC _s2) {return _mbsicmp((_CPUC)_s1,(_CPUC)_s2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __s2$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsicmp
  00011	83 c4 08	 add	 esp, 8
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
__tcsicmp ENDP
_TEXT	ENDS
PUBLIC	?__TrimString@YL_Ini@@KAHPAD@Z			; YL_Ini::__TrimString
; Function compile flags: /Odt
; File d:\boxgit\playbox\commonlib\common\yl_ini.cpp
_TEXT	SEGMENT
$T56652 = -20						; size = 4
_psz$56479 = -16					; size = 4
_bTrimmed$ = -12					; size = 4
_nLen$ = -8						; size = 4
_p$ = -4						; size = 4
_lpString$ = 8						; size = 4
?__TrimString@YL_Ini@@KAHPAD@Z PROC NEAR		; YL_Ini::__TrimString

; 428  : {

  00d00	55		 push	 ebp
  00d01	8b ec		 mov	 ebp, esp
  00d03	83 ec 14	 sub	 esp, 20			; 00000014H

; 429  : 	if (lpString == NULL)

  00d06	83 7d 08 00	 cmp	 DWORD PTR _lpString$[ebp], 0
  00d0a	75 07		 jne	 SHORT $L56465

; 430  : 		return FALSE;

  00d0c	33 c0		 xor	 eax, eax
  00d0e	e9 f4 00 00 00	 jmp	 $L56464
$L56465:

; 431  : 
; 432  : 	BOOL bTrimmed = FALSE;

  00d13	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _bTrimmed$[ebp], 0

; 433  : 	int nLen = (int)_tcslen(lpString);

  00d1a	8b 45 08	 mov	 eax, DWORD PTR _lpString$[ebp]
  00d1d	50		 push	 eax
  00d1e	e8 00 00 00 00	 call	 _strlen
  00d23	83 c4 04	 add	 esp, 4
  00d26	89 45 f8	 mov	 DWORD PTR _nLen$[ebp], eax
$L56470:

; 434  : 
; 435  : 	// '\n' and '\r' are actually not possible in this case, but anyway...
; 436  : 	
; 437  : 	// Trim right side
; 438  : 	while (nLen >= 0
; 439  : 		&& (lpString[nLen - 1] == _T(' ')
; 440  : 			|| lpString[nLen - 1] == _T('\t')
; 441  : 			|| lpString[nLen - 1] == _T('\r')
; 442  : 			|| lpString[nLen - 1] == _T('\n')))

  00d29	83 7d f8 00	 cmp	 DWORD PTR _nLen$[ebp], 0
  00d2d	7c 57		 jl	 SHORT $L56471
  00d2f	8b 4d 08	 mov	 ecx, DWORD PTR _lpString$[ebp]
  00d32	03 4d f8	 add	 ecx, DWORD PTR _nLen$[ebp]
  00d35	0f be 51 ff	 movsx	 edx, BYTE PTR [ecx-1]
  00d39	83 fa 20	 cmp	 edx, 32			; 00000020H
  00d3c	74 2d		 je	 SHORT $L56472
  00d3e	8b 45 08	 mov	 eax, DWORD PTR _lpString$[ebp]
  00d41	03 45 f8	 add	 eax, DWORD PTR _nLen$[ebp]
  00d44	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  00d48	83 f9 09	 cmp	 ecx, 9
  00d4b	74 1e		 je	 SHORT $L56472
  00d4d	8b 55 08	 mov	 edx, DWORD PTR _lpString$[ebp]
  00d50	03 55 f8	 add	 edx, DWORD PTR _nLen$[ebp]
  00d53	0f be 42 ff	 movsx	 eax, BYTE PTR [edx-1]
  00d57	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00d5a	74 0f		 je	 SHORT $L56472
  00d5c	8b 4d 08	 mov	 ecx, DWORD PTR _lpString$[ebp]
  00d5f	03 4d f8	 add	 ecx, DWORD PTR _nLen$[ebp]
  00d62	0f be 51 ff	 movsx	 edx, BYTE PTR [ecx-1]
  00d66	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00d69	75 1b		 jne	 SHORT $L56471
$L56472:

; 443  : 	{
; 444  : 		lpString[--nLen] = _T('\0');

  00d6b	8b 45 f8	 mov	 eax, DWORD PTR _nLen$[ebp]
  00d6e	83 e8 01	 sub	 eax, 1
  00d71	89 45 f8	 mov	 DWORD PTR _nLen$[ebp], eax
  00d74	8b 4d 08	 mov	 ecx, DWORD PTR _lpString$[ebp]
  00d77	03 4d f8	 add	 ecx, DWORD PTR _nLen$[ebp]
  00d7a	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 445  : 		bTrimmed = TRUE;		

  00d7d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _bTrimmed$[ebp], 1

; 446  : 	}

  00d84	eb a3		 jmp	 SHORT $L56470
$L56471:

; 447  : 
; 448  : 	// Trim left side
; 449  : 	LPCTSTR p = lpString; 

  00d86	8b 55 08	 mov	 edx, DWORD PTR _lpString$[ebp]
  00d89	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx
$L56475:

; 450  : 	while (*p == _T(' ')
; 451  : 			|| *p == _T('\t')
; 452  : 			|| *p == _T('\r')
; 453  : 			|| *p == _T('\n'))

  00d8c	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00d8f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00d92	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00d95	74 21		 je	 SHORT $L56477
  00d97	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00d9a	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00d9d	83 f8 09	 cmp	 eax, 9
  00da0	74 16		 je	 SHORT $L56477
  00da2	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00da5	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00da8	83 fa 0d	 cmp	 edx, 13			; 0000000dH
  00dab	74 0b		 je	 SHORT $L56477
  00dad	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00db0	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00db3	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00db6	75 12		 jne	 SHORT $L56476
$L56477:

; 454  : 	{
; 455  : 		p = &p[1];

  00db8	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00dbb	83 c2 01	 add	 edx, 1
  00dbe	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 456  : 		bTrimmed = TRUE;

  00dc1	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _bTrimmed$[ebp], 1

; 457  : 	}

  00dc8	eb c2		 jmp	 SHORT $L56475
$L56476:

; 458  : 
; 459  : 	if (p != lpString)

  00dca	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00dcd	3b 45 08	 cmp	 eax, DWORD PTR _lpString$[ebp]
  00dd0	74 32		 je	 SHORT $L56478

; 460  : 	{
; 461  : 		LPTSTR psz = _tcsdup(p);

  00dd2	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00dd5	51		 push	 ecx
  00dd6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  00ddc	83 c4 04	 add	 esp, 4
  00ddf	89 45 f0	 mov	 DWORD PTR _psz$56479[ebp], eax

; 462  : 		_tcscpy(lpString, psz);

  00de2	8b 55 f0	 mov	 edx, DWORD PTR _psz$56479[ebp]
  00de5	52		 push	 edx
  00de6	8b 45 08	 mov	 eax, DWORD PTR _lpString$[ebp]
  00de9	50		 push	 eax
  00dea	e8 00 00 00 00	 call	 _strcpy
  00def	83 c4 08	 add	 esp, 8

; 463  : 		delete [] psz;

  00df2	8b 4d f0	 mov	 ecx, DWORD PTR _psz$56479[ebp]
  00df5	89 4d ec	 mov	 DWORD PTR $T56652[ebp], ecx
  00df8	8b 55 ec	 mov	 edx, DWORD PTR $T56652[ebp]
  00dfb	52		 push	 edx
  00dfc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00e01	83 c4 04	 add	 esp, 4
$L56478:

; 464  : 	}
; 465  : 
; 466  : 	return bTrimmed;

  00e04	8b 45 f4	 mov	 eax, DWORD PTR _bTrimmed$[ebp]
$L56464:

; 467  : }

  00e07	8b e5		 mov	 esp, ebp
  00e09	5d		 pop	 ebp
  00e0a	c3		 ret	 0
?__TrimString@YL_Ini@@KAHPAD@Z ENDP			; YL_Ini::__TrimString
_TEXT	ENDS
PUBLIC	?__StrDupEx@YL_Ini@@KAPADPBD0@Z			; YL_Ini::__StrDupEx
; Function compile flags: /Odt
_TEXT	SEGMENT
$T56654 = -12						; size = 4
_LEN$ = -8						; size = 4
_psz$ = -4						; size = 4
_lpStart$ = 8						; size = 4
_lpEnd$ = 12						; size = 4
?__StrDupEx@YL_Ini@@KAPADPBD0@Z PROC NEAR		; YL_Ini::__StrDupEx

; 470  : {

  00e10	55		 push	 ebp
  00e11	8b ec		 mov	 ebp, esp
  00e13	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 471  : 	const DWORD LEN = ((DWORD)(lpEnd - lpStart)) / sizeof(TCHAR);

  00e16	8b 45 0c	 mov	 eax, DWORD PTR _lpEnd$[ebp]
  00e19	2b 45 08	 sub	 eax, DWORD PTR _lpStart$[ebp]
  00e1c	89 45 f8	 mov	 DWORD PTR _LEN$[ebp], eax

; 472  : 	LPTSTR psz = new TCHAR[LEN + 1];

  00e1f	8b 4d f8	 mov	 ecx, DWORD PTR _LEN$[ebp]
  00e22	83 c1 01	 add	 ecx, 1
  00e25	51		 push	 ecx
  00e26	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00e2b	83 c4 04	 add	 esp, 4
  00e2e	89 45 f4	 mov	 DWORD PTR $T56654[ebp], eax
  00e31	8b 55 f4	 mov	 edx, DWORD PTR $T56654[ebp]
  00e34	89 55 fc	 mov	 DWORD PTR _psz$[ebp], edx

; 473  : 	_tcsncpy(psz, lpStart, LEN);

  00e37	8b 45 f8	 mov	 eax, DWORD PTR _LEN$[ebp]
  00e3a	50		 push	 eax
  00e3b	8b 4d 08	 mov	 ecx, DWORD PTR _lpStart$[ebp]
  00e3e	51		 push	 ecx
  00e3f	8b 55 fc	 mov	 edx, DWORD PTR _psz$[ebp]
  00e42	52		 push	 edx
  00e43	e8 00 00 00 00	 call	 __tcsncpy
  00e48	83 c4 0c	 add	 esp, 12			; 0000000cH

; 474  : 	psz[LEN] = _T('\0');

  00e4b	8b 45 fc	 mov	 eax, DWORD PTR _psz$[ebp]
  00e4e	03 45 f8	 add	 eax, DWORD PTR _LEN$[ebp]
  00e51	c6 00 00	 mov	 BYTE PTR [eax], 0

; 475  : 	return psz; // !!! Requires the caller to free this memory !!!

  00e54	8b 45 fc	 mov	 eax, DWORD PTR _psz$[ebp]

; 476  : }

  00e57	8b e5		 mov	 esp, ebp
  00e59	5d		 pop	 ebp
  00e5a	c3		 ret	 0
?__StrDupEx@YL_Ini@@KAPADPBD0@Z ENDP			; YL_Ini::__StrDupEx
_TEXT	ENDS
END
