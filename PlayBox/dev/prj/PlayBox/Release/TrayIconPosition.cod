; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\Gui\tray\TrayIconPosition.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??_GCTrayIconPosition@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckIfColorIsBlackOrNearBlack@CTrayIconPosition@@IAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CTrayIconPosition@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CTrayIconPosition@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTrayIconPosition@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCTrayIconPosition@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CTrayIconPosition@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@HHHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CRect@@QAEXABUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRect@CRect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __tcscmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CenterPoint@CRect@@QBE?AVCPoint@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AfxGetApp@@YGPAVCWinApp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTimeSpan@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CTrayIconPosition@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG197522 DB	'TrayNotifyWnd', 00H
	ORG $+2
$SG197531 DB	'ToolbarWindow32', 00H
$SG197539 DB	'Shell_TrayWnd', 00H
CONST	ENDS
PUBLIC	??0CPoint@@QAE@XZ				; CPoint::CPoint
PUBLIC	??0CRect@@QAE@XZ				; CRect::CRect
PUBLIC	??_R4CTrayIconPosition@@6B@			; CTrayIconPosition::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTrayIconPosition@@@8			; CTrayIconPosition `RTTI Type Descriptor'
PUBLIC	??_R3CTrayIconPosition@@8			; CTrayIconPosition::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTrayIconPosition@@8			; CTrayIconPosition::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CTrayIconPosition@@8		; CTrayIconPosition::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0CTime@ATL@@QAE@XZ				; ATL::CTime::CTime
PUBLIC	??0CTrayIconPosition@@QAE@XZ			; CTrayIconPosition::CTrayIconPosition
PUBLIC	??_7CTrayIconPosition@@6B@			; CTrayIconPosition::`vftable'
PUBLIC	??_GCTrayIconPosition@@UAEPAXI@Z		; CTrayIconPosition::`scalar deleting destructor'
EXTRN	__imp__GetVersionExA@4:NEAR
EXTRN	??_ECTrayIconPosition@@UAEPAXI@Z:NEAR		; CTrayIconPosition::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_7CTrayIconPosition@@6B@
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\tray\trayiconposition.cpp
CONST	SEGMENT
??_7CTrayIconPosition@@6B@ DD FLAT:??_R4CTrayIconPosition@@6B@ ; CTrayIconPosition::`vftable'
	DD	FLAT:??_ECTrayIconPosition@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CTrayIconPosition@@6B@
rdata$r	SEGMENT
??_R4CTrayIconPosition@@6B@ DD 00H			; CTrayIconPosition::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTrayIconPosition@@@8
	DD	FLAT:??_R3CTrayIconPosition@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTrayIconPosition@@@8
_DATA	SEGMENT
??_R0?AVCTrayIconPosition@@@8 DD FLAT:??_7type_info@@6B@ ; CTrayIconPosition `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTrayIconPosition@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CTrayIconPosition@@8
rdata$r	SEGMENT
??_R3CTrayIconPosition@@8 DD 00H			; CTrayIconPosition::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CTrayIconPosition@@8
rdata$r	ENDS
;	COMDAT ??_R2CTrayIconPosition@@8
rdata$r	SEGMENT
??_R2CTrayIconPosition@@8 DD FLAT:??_R1A@?0A@A@CTrayIconPosition@@8 ; CTrayIconPosition::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTrayIconPosition@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CTrayIconPosition@@8 DD FLAT:??_R0?AVCTrayIconPosition@@@8 ; CTrayIconPosition::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CTrayIconPosition@@QAE@XZ PROC NEAR			; CTrayIconPosition::CTrayIconPosition
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTrayIconPosition@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00021	e8 00 00 00 00	 call	 ??0CTime@ATL@@QAE@XZ	; ATL::CTime::CTime
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	83 c1 24	 add	 ecx, 36			; 00000024H
  0002c	e8 00 00 00 00	 call	 ??0CPoint@@QAE@XZ	; CPoint::CPoint

; 23   : 	m_hWndOfIconOwner = NULL;

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 24   : 	m_iTrayIconID = -1;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	c7 42 2c ff ff
	ff ff		 mov	 DWORD PTR [edx+44], -1

; 25   : 	m_prDefaultPrecision = High;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	c7 40 18 03 00
	00 00		 mov	 DWORD PTR [eax+24], 3

; 26   : 	m_iPrecisions[0] = 60; //seconds for low precision mode

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	c7 41 34 3c 00
	00 00		 mov	 DWORD PTR [ecx+52], 60	; 0000003cH

; 27   : 	m_iPrecisions[1] = 30; //seconds for medium precision mode

  00059	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	c7 42 38 1e 00
	00 00		 mov	 DWORD PTR [edx+56], 30	; 0000001eH

; 28   : 	m_iPrecisions[2] = 10; //seconds for high precision mode

  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00066	c7 40 3c 0a 00
	00 00		 mov	 DWORD PTR [eax+60], 10	; 0000000aH

; 29   : 
; 30   : 	m_osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	c7 41 40 94 00
	00 00		 mov	 DWORD PTR [ecx+64], 148	; 00000094H

; 31   : 	GetVersionEx( &m_osVer );

  00077	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	83 c2 40	 add	 edx, 64			; 00000040H
  0007d	52		 push	 edx
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 32   : }

  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
??0CTrayIconPosition@@QAE@XZ ENDP			; CTrayIconPosition::CTrayIconPosition
_TEXT	ENDS
PUBLIC	??1CTrayIconPosition@@UAE@XZ			; CTrayIconPosition::~CTrayIconPosition
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt
;	COMDAT ??_GCTrayIconPosition@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTrayIconPosition@@UAEPAXI@Z PROC NEAR		; CTrayIconPosition::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTrayIconPosition@@UAE@XZ ; CTrayIconPosition::~CTrayIconPosition
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L197449
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L197449:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCTrayIconPosition@@UAEPAXI@Z ENDP			; CTrayIconPosition::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CTrayIconPosition@@UAE@XZ PROC NEAR			; CTrayIconPosition::~CTrayIconPosition
; _this$ = ecx

; 35   : {

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp
  00093	51		 push	 ecx
  00094	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00097	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTrayIconPosition@@6B@

; 36   : 
; 37   : }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
??1CTrayIconPosition@@UAE@XZ ENDP			; CTrayIconPosition::~CTrayIconPosition
_TEXT	ENDS
PUBLIC	?InitializePositionTracking@CTrayIconPosition@@QAEXPAUHWND__@@H@Z ; CTrayIconPosition::InitializePositionTracking
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hwndOfIconOwner$ = 8					; size = 4
_iIconID$ = 12						; size = 4
?InitializePositionTracking@CTrayIconPosition@@QAEXPAUHWND__@@H@Z PROC NEAR ; CTrayIconPosition::InitializePositionTracking
; _this$ = ecx

; 40   : {

  000b0	55		 push	 ebp
  000b1	8b ec		 mov	 ebp, esp
  000b3	51		 push	 ecx
  000b4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 	m_hWndOfIconOwner = hwndOfIconOwner;

  000b7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _hwndOfIconOwner$[ebp]
  000bd	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 42   : 	m_iTrayIconID = iIconID;

  000c0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c3	8b 45 0c	 mov	 eax, DWORD PTR _iIconID$[ebp]
  000c6	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 43   : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 08 00	 ret	 8
?InitializePositionTracking@CTrayIconPosition@@QAEXPAUHWND__@@H@Z ENDP ; CTrayIconPosition::InitializePositionTracking
_TEXT	ENDS
PUBLIC	?CenterPoint@CRect@@QBE?AVCPoint@@XZ		; CRect::CenterPoint
PUBLIC	?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ		; ATL::CTimeSpan::GetTotalSeconds
PUBLIC	?GetTickCount@CTime@ATL@@SG?AV12@XZ		; ATL::CTime::GetTickCount
PUBLIC	??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z		; ATL::CTime::operator-
PUBLIC	?AfxGetApp@@YGPAVCWinApp@@XZ			; AfxGetApp
PUBLIC	?FindOutPositionOfIcon@CTrayIconPosition@@IAEHPAUHICON__@@@Z ; CTrayIconPosition::FindOutPositionOfIcon
PUBLIC	?GetTrayIconPositionVisualScan@CTrayIconPosition@@IAEHAAVCPoint@@W4Precision@1@@Z ; CTrayIconPosition::GetTrayIconPositionVisualScan
PUBLIC	?GetTrayWndRect@CTrayIconPosition@@KA?AVCRect@@XZ ; CTrayIconPosition::GetTrayWndRect
PUBLIC	?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z		; CWinApp::LoadIconA
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -72						; size = 4
$T198086 = -68						; size = 8
$T198085 = -60						; size = 8
$T198084 = -52						; size = 8
$T198083 = -44						; size = 16
$T198082 = -28						; size = 8
$T198081 = -20						; size = 8
_iTotalSec$ = -12					; size = 4
_prec$ = -8						; size = 4
_bUpdateRequired$ = -4					; size = 4
_a_ptPoint$ = 8						; size = 4
_a_ePrec$ = 12						; size = 4
?GetTrayIconPositionVisualScan@CTrayIconPosition@@IAEHAAVCPoint@@W4Precision@1@@Z PROC NEAR ; CTrayIconPosition::GetTrayIconPositionVisualScan
; _this$ = ecx

; 46   : {

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	83 ec 48	 sub	 esp, 72			; 00000048H
  000d6	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 47   : 	//let's find the time from last tray icon position calculation
; 48   : 	int iTotalSec = (m_tLastUpdate - CTime::GetCurrentTime()).GetTotalSeconds();

  000d9	8d 45 ec	 lea	 eax, DWORD PTR $T198081[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ?GetTickCount@CTime@ATL@@SG?AV12@XZ ; ATL::CTime::GetTickCount
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e5	51		 push	 ecx
  000e6	8b 10		 mov	 edx, DWORD PTR [eax]
  000e8	52		 push	 edx
  000e9	8d 45 e4	 lea	 eax, DWORD PTR $T198082[ebp]
  000ec	50		 push	 eax
  000ed	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000f3	e8 00 00 00 00	 call	 ??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z ; ATL::CTime::operator-
  000f8	8b c8		 mov	 ecx, eax
  000fa	e8 00 00 00 00	 call	 ?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ ; ATL::CTimeSpan::GetTotalSeconds
  000ff	89 45 f4	 mov	 DWORD PTR _iTotalSec$[ebp], eax

; 49   : 	if(iTotalSec < 0)

  00102	83 7d f4 00	 cmp	 DWORD PTR _iTotalSec$[ebp], 0
  00106	7d 08		 jge	 SHORT $L197466

; 50   : 	{
; 51   : 		iTotalSec = -iTotalSec;

  00108	8b 4d f4	 mov	 ecx, DWORD PTR _iTotalSec$[ebp]
  0010b	f7 d9		 neg	 ecx
  0010d	89 4d f4	 mov	 DWORD PTR _iTotalSec$[ebp], ecx
$L197466:

; 52   : 	}
; 53   : 
; 54   : 	Precision prec;
; 55   : 	if(a_ePrec == Default)

  00110	83 7d 0c 00	 cmp	 DWORD PTR _a_ePrec$[ebp], 0
  00114	75 0b		 jne	 SHORT $L197468

; 56   : 	{
; 57   : 		prec = m_prDefaultPrecision;

  00116	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00119	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0011c	89 45 f8	 mov	 DWORD PTR _prec$[ebp], eax

; 58   : 	}
; 59   : 	else

  0011f	eb 06		 jmp	 SHORT $L197469
$L197468:

; 60   : 	{
; 61   : 		prec = a_ePrec;

  00121	8b 4d 0c	 mov	 ecx, DWORD PTR _a_ePrec$[ebp]
  00124	89 4d f8	 mov	 DWORD PTR _prec$[ebp], ecx
$L197469:

; 62   : 	}
; 63   : 
; 64   : 	BOOL bUpdateRequired = FALSE;

  00127	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bUpdateRequired$[ebp], 0

; 65   : 	if(prec == Low && iTotalSec > m_iPrecisions[0]	  ||
; 66   : 	   prec == Medium && iTotalSec > m_iPrecisions[1] ||
; 67   : 	   prec == High && iTotalSec > m_iPrecisions[2]	    )

  0012e	83 7d f8 01	 cmp	 DWORD PTR _prec$[ebp], 1
  00132	75 0b		 jne	 SHORT $L197473
  00134	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00137	8b 45 f4	 mov	 eax, DWORD PTR _iTotalSec$[ebp]
  0013a	3b 42 34	 cmp	 eax, DWORD PTR [edx+52]
  0013d	7f 22		 jg	 SHORT $L197472
$L197473:
  0013f	83 7d f8 02	 cmp	 DWORD PTR _prec$[ebp], 2
  00143	75 0b		 jne	 SHORT $L197474
  00145	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	8b 55 f4	 mov	 edx, DWORD PTR _iTotalSec$[ebp]
  0014b	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  0014e	7f 11		 jg	 SHORT $L197472
$L197474:
  00150	83 7d f8 03	 cmp	 DWORD PTR _prec$[ebp], 3
  00154	75 12		 jne	 SHORT $L197471
  00156	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00159	8b 4d f4	 mov	 ecx, DWORD PTR _iTotalSec$[ebp]
  0015c	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  0015f	7e 07		 jle	 SHORT $L197471
$L197472:

; 68   : 	   {
; 69   : 		bUpdateRequired = TRUE;

  00161	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bUpdateRequired$[ebp], 1
$L197471:

; 70   : 	   }
; 71   : 
; 72   : 	if(bUpdateRequired)

  00168	83 7d fc 00	 cmp	 DWORD PTR _bUpdateRequired$[ebp], 0
  0016c	0f 84 d4 00 00
	00		 je	 $L197475

; 73   : 	{
; 74   : 		m_rtRectangleOfTheTray = GetTrayWndRect();

  00172	8d 55 d4	 lea	 edx, DWORD PTR $T198083[ebp]
  00175	52		 push	 edx
  00176	e8 00 00 00 00	 call	 ?GetTrayWndRect@CTrayIconPosition@@KA?AVCRect@@XZ ; CTrayIconPosition::GetTrayWndRect
  0017b	83 c4 04	 add	 esp, 4
  0017e	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	83 c1 08	 add	 ecx, 8
  00184	8b 10		 mov	 edx, DWORD PTR [eax]
  00186	89 11		 mov	 DWORD PTR [ecx], edx
  00188	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0018b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0018e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00191	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00194	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00197	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 75   : 		
; 76   : 		if(FindOutPositionOfIcon(AfxGetApp()->LoadIcon(IDI_BLANK_BLACK)) == TRUE)

  0019a	68 e2 01 00 00	 push	 482			; 000001e2H
  0019f	e8 00 00 00 00	 call	 ?AfxGetApp@@YGPAVCWinApp@@XZ ; AfxGetApp
  001a4	8b c8		 mov	 ecx, eax
  001a6	e8 00 00 00 00	 call	 ?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z ; CWinApp::LoadIconA
  001ab	50		 push	 eax
  001ac	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	e8 00 00 00 00	 call	 ?FindOutPositionOfIcon@CTrayIconPosition@@IAEHPAUHICON__@@@Z ; CTrayIconPosition::FindOutPositionOfIcon
  001b4	83 f8 01	 cmp	 eax, 1
  001b7	75 2f		 jne	 SHORT $L197477

; 77   : 		{
; 78   : 			//we were able to find position of icon in tray - that's GREAT!
; 79   : 			m_tLastUpdate = CTime::GetCurrentTime();

  001b9	8d 4d cc	 lea	 ecx, DWORD PTR $T198084[ebp]
  001bc	51		 push	 ecx
  001bd	e8 00 00 00 00	 call	 ?GetTickCount@CTime@ATL@@SG?AV12@XZ ; ATL::CTime::GetTickCount
  001c2	8b 10		 mov	 edx, DWORD PTR [eax]
  001c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c7	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ca	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
  001cd	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 80   : 			a_ptPoint = m_ptPosition;

  001d0	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  001d3	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  001d6	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  001d9	8b 55 08	 mov	 edx, DWORD PTR _a_ptPoint$[ebp]
  001dc	89 02		 mov	 DWORD PTR [edx], eax
  001de	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 81   : 			return TRUE;

  001e1	b8 01 00 00 00	 mov	 eax, 1
  001e6	eb 74		 jmp	 SHORT $L197462
$L197477:

; 82   : 		}
; 83   : 		else
; 84   : 		{
; 85   : 			//We were unable to locate our icon - this is not a tragedy - usually there is a solution:
; 86   : 
; 87   : 			if(m_osVer.dwPlatformId == VER_PLATFORM_WIN32_NT && m_osVer.dwMajorVersion >= 5)

  001e8	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  001eb	83 78 50 02	 cmp	 DWORD PTR [eax+80], 2
  001ef	75 35		 jne	 SHORT $L197480
  001f1	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f4	83 79 44 05	 cmp	 DWORD PTR [ecx+68], 5
  001f8	72 2c		 jb	 SHORT $L197480

; 88   : 			{
; 89   : 				//We're under Win XP
; 90   : 				//It's quite possible that icon is hidden now let's return Left-Center point of tray - it's most likely WinXP hide-tray-icons button.
; 91   : 				a_ptPoint = m_rtRectangleOfTheTray.CenterPoint();

  001fa	8d 55 c4	 lea	 edx, DWORD PTR $T198085[ebp]
  001fd	52		 push	 edx
  001fe	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00201	83 c1 08	 add	 ecx, 8
  00204	e8 00 00 00 00	 call	 ?CenterPoint@CRect@@QBE?AVCPoint@@XZ ; CRect::CenterPoint
  00209	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0020e	8b 45 08	 mov	 eax, DWORD PTR _a_ptPoint$[ebp]
  00211	89 08		 mov	 DWORD PTR [eax], ecx
  00213	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 92   : 				a_ptPoint.x = m_rtRectangleOfTheTray.left + 6;

  00216	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00219	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0021c	83 c2 06	 add	 edx, 6
  0021f	8b 45 08	 mov	 eax, DWORD PTR _a_ptPoint$[ebp]
  00222	89 10		 mov	 DWORD PTR [eax], edx

; 93   : 			}
; 94   : 			else

  00224	eb 1c		 jmp	 SHORT $L197482
$L197480:

; 95   : 			{
; 96   : 				//we're not under XP - I have no idea why but we were unable to locate our icon - let's retunr center of the tray area
; 97   : 				a_ptPoint = m_rtRectangleOfTheTray.CenterPoint();

  00226	8d 4d bc	 lea	 ecx, DWORD PTR $T198086[ebp]
  00229	51		 push	 ecx
  0022a	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0022d	83 c1 08	 add	 ecx, 8
  00230	e8 00 00 00 00	 call	 ?CenterPoint@CRect@@QBE?AVCPoint@@XZ ; CRect::CenterPoint
  00235	8b 10		 mov	 edx, DWORD PTR [eax]
  00237	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0023a	8b 4d 08	 mov	 ecx, DWORD PTR _a_ptPoint$[ebp]
  0023d	89 11		 mov	 DWORD PTR [ecx], edx
  0023f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L197482:

; 98   : 			}
; 99   : 			return FALSE;

  00242	33 c0		 xor	 eax, eax
  00244	eb 16		 jmp	 SHORT $L197462
$L197475:

; 100  : 		}
; 101  : 		
; 102  : 	}
; 103  : 	else
; 104  : 	{
; 105  : 		a_ptPoint = m_ptPosition;

  00246	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00249	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0024c	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  0024f	8b 55 08	 mov	 edx, DWORD PTR _a_ptPoint$[ebp]
  00252	89 02		 mov	 DWORD PTR [edx], eax
  00254	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 106  : 	}
; 107  : 
; 108  : 	return TRUE;

  00257	b8 01 00 00 00	 mov	 eax, 1
$L197462:

; 109  : }

  0025c	8b e5		 mov	 esp, ebp
  0025e	5d		 pop	 ebp
  0025f	c2 08 00	 ret	 8
?GetTrayIconPositionVisualScan@CTrayIconPosition@@IAEHAAVCPoint@@W4Precision@1@@Z ENDP ; CTrayIconPosition::GetTrayIconPositionVisualScan
_TEXT	ENDS
PUBLIC	?GetTrayIconPosition@CTrayIconPosition@@QAEHAAVCPoint@@W4TrackType@1@W4Precision@1@@Z ; CTrayIconPosition::GetTrayIconPosition
PUBLIC	?FindOutPositionOfIconDirectly@CTrayIconPosition@@KAHQAUHWND__@@HAAVCRect@@@Z ; CTrayIconPosition::FindOutPositionOfIconDirectly
; Function compile flags: /Odt
_TEXT	SEGMENT
tv69 = -40						; size = 4
_this$ = -36						; size = 4
_bOK$197506 = -32					; size = 4
_bOK$197504 = -28					; size = 4
_rcDirectRect$ = -24					; size = 16
_iOffsetX$ = -8						; size = 4
_iOffsetY$ = -4						; size = 4
_a_ptPoint$ = 8						; size = 4
_a_eTrackType$ = 12					; size = 4
_a_ePrec$ = 16						; size = 4
?GetTrayIconPosition@CTrayIconPosition@@QAEHAAVCPoint@@W4TrackType@1@W4Precision@1@@Z PROC NEAR ; CTrayIconPosition::GetTrayIconPosition
; _this$ = ecx

; 112  : {

  00270	55		 push	 ebp
  00271	8b ec		 mov	 ebp, esp
  00273	83 ec 28	 sub	 esp, 40			; 00000028H
  00276	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 	if(m_hWndOfIconOwner == NULL || m_iTrayIconID == -1)

  00279	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0027c	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  00280	74 09		 je	 SHORT $L197492
  00282	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00285	83 79 2c ff	 cmp	 DWORD PTR [ecx+44], -1
  00289	75 08		 jne	 SHORT $L197491
$L197492:

; 114  : 	{
; 115  : 		return -1;

  0028b	83 c8 ff	 or	 eax, -1
  0028e	e9 25 01 00 00	 jmp	 $L197490
$L197491:

; 116  : 	}
; 117  : 	
; 118  : 	//remove it if you need exact point of left/top corner of the icon
; 119  : 	const int iOffsetX = 4;

  00293	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _iOffsetX$[ebp], 4

; 120  : 	const int iOffsetY = 6;

  0029a	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR _iOffsetY$[ebp], 6

; 121  : 
; 122  : 	CRect rcDirectRect;

  002a1	8d 4d e8	 lea	 ecx, DWORD PTR _rcDirectRect$[ebp]
  002a4	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 123  : 	
; 124  : 	switch (a_eTrackType) 

  002a9	8b 55 0c	 mov	 edx, DWORD PTR _a_eTrackType$[ebp]
  002ac	89 55 d8	 mov	 DWORD PTR tv69[ebp], edx
  002af	83 7d d8 03	 cmp	 DWORD PTR tv69[ebp], 3
  002b3	0f 87 fd 00 00
	00		 ja	 $L197497
  002b9	8b 45 d8	 mov	 eax, DWORD PTR tv69[ebp]
  002bc	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L198088[eax*4]
$L197500:

; 125  : 	{
; 126  : 	case UseBothTechniquesDirectPrefered:
; 127  : 		if( FindOutPositionOfIconDirectly(m_hWndOfIconOwner, m_iTrayIconID, rcDirectRect) == FALSE )

  002c3	8d 4d e8	 lea	 ecx, DWORD PTR _rcDirectRect$[ebp]
  002c6	51		 push	 ecx
  002c7	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  002ca	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  002cd	50		 push	 eax
  002ce	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d1	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  002d4	52		 push	 edx
  002d5	e8 00 00 00 00	 call	 ?FindOutPositionOfIconDirectly@CTrayIconPosition@@KAHQAUHWND__@@HAAVCRect@@@Z ; CTrayIconPosition::FindOutPositionOfIconDirectly
  002da	83 c4 0c	 add	 esp, 12			; 0000000cH
  002dd	85 c0		 test	 eax, eax
  002df	75 15		 jne	 SHORT $L197501

; 128  : 		{
; 129  : 			return GetTrayIconPositionVisualScan(a_ptPoint, a_ePrec);

  002e1	8b 45 10	 mov	 eax, DWORD PTR _a_ePrec$[ebp]
  002e4	50		 push	 eax
  002e5	8b 4d 08	 mov	 ecx, DWORD PTR _a_ptPoint$[ebp]
  002e8	51		 push	 ecx
  002e9	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ec	e8 00 00 00 00	 call	 ?GetTrayIconPositionVisualScan@CTrayIconPosition@@IAEHAAVCPoint@@W4Precision@1@@Z ; CTrayIconPosition::GetTrayIconPositionVisualScan
  002f1	e9 c2 00 00 00	 jmp	 $L197490
$L197501:

; 130  : 		}
; 131  : 		
; 132  : 		a_ptPoint.x = rcDirectRect.left + iOffsetX;

  002f6	8b 55 e8	 mov	 edx, DWORD PTR _rcDirectRect$[ebp]
  002f9	83 c2 04	 add	 edx, 4
  002fc	8b 45 08	 mov	 eax, DWORD PTR _a_ptPoint$[ebp]
  002ff	89 10		 mov	 DWORD PTR [eax], edx

; 133  : 		a_ptPoint.y = rcDirectRect.top  + iOffsetY;

  00301	8b 4d ec	 mov	 ecx, DWORD PTR _rcDirectRect$[ebp+4]
  00304	83 c1 06	 add	 ecx, 6
  00307	8b 55 08	 mov	 edx, DWORD PTR _a_ptPoint$[ebp]
  0030a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 134  : 		return TRUE;

  0030d	b8 01 00 00 00	 mov	 eax, 1
  00312	e9 a1 00 00 00	 jmp	 $L197490
$L197502:

; 135  : 
; 136  : 	case UseBothTechniquesVisualScanPrefered:
; 137  : 		if( GetTrayIconPositionVisualScan(a_ptPoint, a_ePrec) == FALSE )

  00317	8b 45 10	 mov	 eax, DWORD PTR _a_ePrec$[ebp]
  0031a	50		 push	 eax
  0031b	8b 4d 08	 mov	 ecx, DWORD PTR _a_ptPoint$[ebp]
  0031e	51		 push	 ecx
  0031f	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00322	e8 00 00 00 00	 call	 ?GetTrayIconPositionVisualScan@CTrayIconPosition@@IAEHAAVCPoint@@W4Precision@1@@Z ; CTrayIconPosition::GetTrayIconPositionVisualScan
  00327	85 c0		 test	 eax, eax
  00329	75 39		 jne	 SHORT $L197503

; 138  : 		{
; 139  : 			BOOL bOK = FindOutPositionOfIconDirectly(m_hWndOfIconOwner, m_iTrayIconID, rcDirectRect);

  0032b	8d 55 e8	 lea	 edx, DWORD PTR _rcDirectRect$[ebp]
  0032e	52		 push	 edx
  0032f	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00332	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00335	51		 push	 ecx
  00336	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00339	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0033c	50		 push	 eax
  0033d	e8 00 00 00 00	 call	 ?FindOutPositionOfIconDirectly@CTrayIconPosition@@KAHQAUHWND__@@HAAVCRect@@@Z ; CTrayIconPosition::FindOutPositionOfIconDirectly
  00342	83 c4 0c	 add	 esp, 12			; 0000000cH
  00345	89 45 e4	 mov	 DWORD PTR _bOK$197504[ebp], eax

; 140  : 
; 141  : 			a_ptPoint.x = rcDirectRect.left + iOffsetX;

  00348	8b 4d e8	 mov	 ecx, DWORD PTR _rcDirectRect$[ebp]
  0034b	83 c1 04	 add	 ecx, 4
  0034e	8b 55 08	 mov	 edx, DWORD PTR _a_ptPoint$[ebp]
  00351	89 0a		 mov	 DWORD PTR [edx], ecx

; 142  : 			a_ptPoint.y = rcDirectRect.top  + iOffsetY;

  00353	8b 45 ec	 mov	 eax, DWORD PTR _rcDirectRect$[ebp+4]
  00356	83 c0 06	 add	 eax, 6
  00359	8b 4d 08	 mov	 ecx, DWORD PTR _a_ptPoint$[ebp]
  0035c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 143  : 			return bOK;

  0035f	8b 45 e4	 mov	 eax, DWORD PTR _bOK$197504[ebp]
  00362	eb 54		 jmp	 SHORT $L197490
$L197503:

; 144  : 		}
; 145  : 		return TRUE;

  00364	b8 01 00 00 00	 mov	 eax, 1
  00369	eb 4d		 jmp	 SHORT $L197490
$L197505:

; 146  : 
; 147  : 	case UseDirectOnly:
; 148  : 		{
; 149  : 			BOOL bOK = FindOutPositionOfIconDirectly(m_hWndOfIconOwner, m_iTrayIconID, rcDirectRect);

  0036b	8d 55 e8	 lea	 edx, DWORD PTR _rcDirectRect$[ebp]
  0036e	52		 push	 edx
  0036f	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00372	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00375	51		 push	 ecx
  00376	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00379	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0037c	50		 push	 eax
  0037d	e8 00 00 00 00	 call	 ?FindOutPositionOfIconDirectly@CTrayIconPosition@@KAHQAUHWND__@@HAAVCRect@@@Z ; CTrayIconPosition::FindOutPositionOfIconDirectly
  00382	83 c4 0c	 add	 esp, 12			; 0000000cH
  00385	89 45 e0	 mov	 DWORD PTR _bOK$197506[ebp], eax

; 150  : 
; 151  : 			a_ptPoint.x = rcDirectRect.left + iOffsetX;

  00388	8b 4d e8	 mov	 ecx, DWORD PTR _rcDirectRect$[ebp]
  0038b	83 c1 04	 add	 ecx, 4
  0038e	8b 55 08	 mov	 edx, DWORD PTR _a_ptPoint$[ebp]
  00391	89 0a		 mov	 DWORD PTR [edx], ecx

; 152  : 			a_ptPoint.y = rcDirectRect.top  + iOffsetY;

  00393	8b 45 ec	 mov	 eax, DWORD PTR _rcDirectRect$[ebp+4]
  00396	83 c0 06	 add	 eax, 6
  00399	8b 4d 08	 mov	 ecx, DWORD PTR _a_ptPoint$[ebp]
  0039c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 153  : 			return bOK;

  0039f	8b 45 e0	 mov	 eax, DWORD PTR _bOK$197506[ebp]
  003a2	eb 14		 jmp	 SHORT $L197490
$L197507:

; 154  : 		}
; 155  : 
; 156  : 	case UseVisualScanOnly:
; 157  : 		return GetTrayIconPositionVisualScan(a_ptPoint, a_ePrec);

  003a4	8b 55 10	 mov	 edx, DWORD PTR _a_ePrec$[ebp]
  003a7	52		 push	 edx
  003a8	8b 45 08	 mov	 eax, DWORD PTR _a_ptPoint$[ebp]
  003ab	50		 push	 eax
  003ac	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  003af	e8 00 00 00 00	 call	 ?GetTrayIconPositionVisualScan@CTrayIconPosition@@IAEHAAVCPoint@@W4Precision@1@@Z ; CTrayIconPosition::GetTrayIconPositionVisualScan
  003b4	eb 02		 jmp	 SHORT $L197490
$L197497:

; 158  : 		
; 159  : 	default:
; 160  : 		ASSERT(0);
; 161  : 		break;
; 162  : 	}
; 163  : 	
; 164  : 
; 165  : 	return FALSE;

  003b6	33 c0		 xor	 eax, eax
$L197490:

; 166  : }

  003b8	8b e5		 mov	 esp, ebp
  003ba	5d		 pop	 ebp
  003bb	c2 0c 00	 ret	 12			; 0000000cH
$L198088:
  003be	00 00 00 00	 DD	 $L197500
  003c2	00 00 00 00	 DD	 $L197502
  003c6	00 00 00 00	 DD	 $L197505
  003ca	00 00 00 00	 DD	 $L197507
?GetTrayIconPosition@CTrayIconPosition@@QAEHAAVCPoint@@W4TrackType@1@W4Precision@1@@Z ENDP ; CTrayIconPosition::GetTrayIconPosition
_TEXT	ENDS
PUBLIC	?SetPrecisionTimeOuts@CTrayIconPosition@@QAEXHHH@Z ; CTrayIconPosition::SetPrecisionTimeOuts
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iLowSec$ = 8						; size = 4
_iMedSec$ = 12						; size = 4
_iHighSec$ = 16						; size = 4
?SetPrecisionTimeOuts@CTrayIconPosition@@QAEXHHH@Z PROC NEAR ; CTrayIconPosition::SetPrecisionTimeOuts
; _this$ = ecx

; 182  : {

  003d0	55		 push	 ebp
  003d1	8b ec		 mov	 ebp, esp
  003d3	51		 push	 ecx
  003d4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 183  : 	m_iPrecisions[0] = iLowSec;

  003d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003da	8b 4d 08	 mov	 ecx, DWORD PTR _iLowSec$[ebp]
  003dd	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 184  : 	m_iPrecisions[1] = iMedSec;

  003e0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003e3	8b 45 0c	 mov	 eax, DWORD PTR _iMedSec$[ebp]
  003e6	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 185  : 	m_iPrecisions[2] = iHighSec;

  003e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ec	8b 55 10	 mov	 edx, DWORD PTR _iHighSec$[ebp]
  003ef	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 186  : }

  003f2	8b e5		 mov	 esp, ebp
  003f4	5d		 pop	 ebp
  003f5	c2 0c 00	 ret	 12			; 0000000cH
?SetPrecisionTimeOuts@CTrayIconPosition@@QAEXHHH@Z ENDP	; CTrayIconPosition::SetPrecisionTimeOuts
_TEXT	ENDS
PUBLIC	__tcscmp
PUBLIC	?FindTrayWnd@CTrayIconPosition@@KGHPAUHWND__@@J@Z ; CTrayIconPosition::FindTrayWnd
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__GetClassNameA@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_pWnd$197523 = -268					; size = 4
_szClassName$ = -264					; size = 256
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_hwnd$ = 8						; size = 4
_lParam$ = 12						; size = 4
?FindTrayWnd@CTrayIconPosition@@KGHPAUHWND__@@J@Z PROC NEAR ; CTrayIconPosition::FindTrayWnd

; 194  : {    

  00400	55		 push	 ebp
  00401	8b ec		 mov	 ebp, esp
  00403	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00409	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0040e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 195  : 	TCHAR szClassName[256];
; 196  :     GetClassName(hwnd, szClassName, 255);    // Did we find the Main System Tray? If so, then get its size and quit

  00411	68 ff 00 00 00	 push	 255			; 000000ffH
  00416	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szClassName$[ebp]
  0041c	50		 push	 eax
  0041d	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00420	51		 push	 ecx
  00421	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClassNameA@12

; 197  : 	if (_tcscmp(szClassName, _T("TrayNotifyWnd")) == 0)    

  00427	68 00 00 00 00	 push	 OFFSET FLAT:$SG197522
  0042c	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szClassName$[ebp]
  00432	52		 push	 edx
  00433	e8 00 00 00 00	 call	 __tcscmp
  00438	83 c4 08	 add	 esp, 8
  0043b	85 c0		 test	 eax, eax
  0043d	75 18		 jne	 SHORT $L197521

; 198  : 	{        
; 199  : 		HWND* pWnd = (HWND*)lParam;

  0043f	8b 45 0c	 mov	 eax, DWORD PTR _lParam$[ebp]
  00442	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _pWnd$197523[ebp], eax

; 200  : 		*pWnd = hwnd;

  00448	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _pWnd$197523[ebp]
  0044e	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00451	89 11		 mov	 DWORD PTR [ecx], edx

; 201  :         return FALSE;    

  00453	33 c0		 xor	 eax, eax
  00455	eb 05		 jmp	 SHORT $L197519
$L197521:

; 202  : 	}    
; 203  : 	
; 204  : 	//Oryginal code I found on Internet were seeking here for system clock and it was assumming that clock is on the right side of tray.
; 205  : 	//After that calculated size of tray was adjusted by removing space occupied by clock.
; 206  : 	//This is not a good idea - some clocks are ABOVE or somewhere else on the screen. I found that is far safer to just ignore clock space.
; 207  : 	
; 208  : 	return TRUE;

  00457	b8 01 00 00 00	 mov	 eax, 1
$L197519:

; 209  : }

  0045c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0045f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00464	8b e5		 mov	 esp, ebp
  00466	5d		 pop	 ebp
  00467	c2 08 00	 ret	 8
?FindTrayWnd@CTrayIconPosition@@KGHPAUHWND__@@J@Z ENDP	; CTrayIconPosition::FindTrayWnd
_TEXT	ENDS
PUBLIC	?FindToolBarInTrayWnd@CTrayIconPosition@@KGHPAUHWND__@@J@Z ; CTrayIconPosition::FindToolBarInTrayWnd
; Function compile flags: /Odt
_TEXT	SEGMENT
_pWnd$197532 = -268					; size = 4
_szClassName$ = -264					; size = 256
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_hwnd$ = 8						; size = 4
_lParam$ = 12						; size = 4
?FindToolBarInTrayWnd@CTrayIconPosition@@KGHPAUHWND__@@J@Z PROC NEAR ; CTrayIconPosition::FindToolBarInTrayWnd

; 212  : {    

  00470	55		 push	 ebp
  00471	8b ec		 mov	 ebp, esp
  00473	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00479	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0047e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 213  : 	TCHAR szClassName[256];
; 214  :     GetClassName(hwnd, szClassName, 255);    // Did we find the Main System Tray? If so, then get its size and quit

  00481	68 ff 00 00 00	 push	 255			; 000000ffH
  00486	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szClassName$[ebp]
  0048c	50		 push	 eax
  0048d	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00490	51		 push	 ecx
  00491	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClassNameA@12

; 215  : 	if (_tcscmp(szClassName, _T("ToolbarWindow32")) == 0)    

  00497	68 00 00 00 00	 push	 OFFSET FLAT:$SG197531
  0049c	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szClassName$[ebp]
  004a2	52		 push	 edx
  004a3	e8 00 00 00 00	 call	 __tcscmp
  004a8	83 c4 08	 add	 esp, 8
  004ab	85 c0		 test	 eax, eax
  004ad	75 18		 jne	 SHORT $L197530

; 216  : 	{        
; 217  : 		HWND* pWnd = (HWND*)lParam;

  004af	8b 45 0c	 mov	 eax, DWORD PTR _lParam$[ebp]
  004b2	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _pWnd$197532[ebp], eax

; 218  : 		*pWnd = hwnd;

  004b8	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _pWnd$197532[ebp]
  004be	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  004c1	89 11		 mov	 DWORD PTR [ecx], edx

; 219  :         return FALSE;    

  004c3	33 c0		 xor	 eax, eax
  004c5	eb 05		 jmp	 SHORT $L197528
$L197530:

; 220  : 	}    
; 221  : 	return TRUE;

  004c7	b8 01 00 00 00	 mov	 eax, 1
$L197528:

; 222  : }

  004cc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004d4	8b e5		 mov	 esp, ebp
  004d6	5d		 pop	 ebp
  004d7	c2 08 00	 ret	 8
?FindToolBarInTrayWnd@CTrayIconPosition@@KGHPAUHWND__@@J@Z ENDP ; CTrayIconPosition::FindToolBarInTrayWnd
_TEXT	ENDS
PUBLIC	?GetTrayNotifyWnd@CTrayIconPosition@@KAPAUHWND__@@H@Z ; CTrayIconPosition::GetTrayNotifyWnd
EXTRN	__imp__IsWindow@4:NEAR
EXTRN	__imp__EnumChildWindows@12:NEAR
EXTRN	__imp__FindWindowA@8:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_hWndToolBarWnd$197543 = -12				; size = 4
_hWndTrayNotifyWnd$ = -8				; size = 4
_hWndShellTrayWnd$ = -4					; size = 4
_a_bSeekForEmbedToolbar$ = 8				; size = 4
?GetTrayNotifyWnd@CTrayIconPosition@@KAPAUHWND__@@H@Z PROC NEAR ; CTrayIconPosition::GetTrayNotifyWnd

; 227  : {

  004e0	55		 push	 ebp
  004e1	8b ec		 mov	 ebp, esp
  004e3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 228  : 	HWND hWndTrayNotifyWnd = NULL;

  004e6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hWndTrayNotifyWnd$[ebp], 0

; 229  : 	
; 230  :     HWND hWndShellTrayWnd = FindWindow(_T("Shell_TrayWnd"), NULL);

  004ed	6a 00		 push	 0
  004ef	68 00 00 00 00	 push	 OFFSET FLAT:$SG197539
  004f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindWindowA@8
  004fa	89 45 fc	 mov	 DWORD PTR _hWndShellTrayWnd$[ebp], eax

; 231  :     if (hWndShellTrayWnd)    

  004fd	83 7d fc 00	 cmp	 DWORD PTR _hWndShellTrayWnd$[ebp], 0
  00501	74 51		 je	 SHORT $L197540

; 232  : 	{        
; 233  : 		EnumChildWindows(hWndShellTrayWnd, CTrayIconPosition::FindTrayWnd, (LPARAM)&hWndTrayNotifyWnd);   

  00503	8d 45 f8	 lea	 eax, DWORD PTR _hWndTrayNotifyWnd$[ebp]
  00506	50		 push	 eax
  00507	68 00 00 00 00	 push	 OFFSET FLAT:?FindTrayWnd@CTrayIconPosition@@KGHPAUHWND__@@J@Z ; CTrayIconPosition::FindTrayWnd
  0050c	8b 4d fc	 mov	 ecx, DWORD PTR _hWndShellTrayWnd$[ebp]
  0050f	51		 push	 ecx
  00510	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnumChildWindows@12

; 234  : 		
; 235  : 		if(hWndTrayNotifyWnd && IsWindow(hWndTrayNotifyWnd))

  00516	83 7d f8 00	 cmp	 DWORD PTR _hWndTrayNotifyWnd$[ebp], 0
  0051a	74 33		 je	 SHORT $L197542
  0051c	8b 55 f8	 mov	 edx, DWORD PTR _hWndTrayNotifyWnd$[ebp]
  0051f	52		 push	 edx
  00520	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsWindow@4
  00526	85 c0		 test	 eax, eax
  00528	74 25		 je	 SHORT $L197542

; 236  : 		{
; 237  : 			HWND hWndToolBarWnd = NULL;

  0052a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hWndToolBarWnd$197543[ebp], 0

; 238  : 			EnumChildWindows(hWndTrayNotifyWnd, CTrayIconPosition::FindToolBarInTrayWnd, (LPARAM)&hWndToolBarWnd);   

  00531	8d 45 f4	 lea	 eax, DWORD PTR _hWndToolBarWnd$197543[ebp]
  00534	50		 push	 eax
  00535	68 00 00 00 00	 push	 OFFSET FLAT:?FindToolBarInTrayWnd@CTrayIconPosition@@KGHPAUHWND__@@J@Z ; CTrayIconPosition::FindToolBarInTrayWnd
  0053a	8b 4d f8	 mov	 ecx, DWORD PTR _hWndTrayNotifyWnd$[ebp]
  0053d	51		 push	 ecx
  0053e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnumChildWindows@12

; 239  : 			if(hWndToolBarWnd)

  00544	83 7d f4 00	 cmp	 DWORD PTR _hWndToolBarWnd$197543[ebp], 0
  00548	74 05		 je	 SHORT $L197542

; 240  : 			{
; 241  : 				return hWndToolBarWnd;

  0054a	8b 45 f4	 mov	 eax, DWORD PTR _hWndToolBarWnd$197543[ebp]
  0054d	eb 08		 jmp	 SHORT $L197536
$L197542:

; 242  : 			}
; 243  : 		}
; 244  : 
; 245  : 		return hWndTrayNotifyWnd;

  0054f	8b 45 f8	 mov	 eax, DWORD PTR _hWndTrayNotifyWnd$[ebp]
  00552	eb 03		 jmp	 SHORT $L197536
$L197540:

; 246  : 	}  
; 247  : 
; 248  : 	return hWndShellTrayWnd;

  00554	8b 45 fc	 mov	 eax, DWORD PTR _hWndShellTrayWnd$[ebp]
$L197536:

; 249  : }

  00557	8b e5		 mov	 esp, ebp
  00559	5d		 pop	 ebp
  0055a	c3		 ret	 0
?GetTrayNotifyWnd@CTrayIconPosition@@KAPAUHWND__@@H@Z ENDP ; CTrayIconPosition::GetTrayNotifyWnd
_TEXT	ENDS
PUBLIC	??0CRect@@QAE@HHHH@Z				; CRect::CRect
PUBLIC	?SetRect@CRect@@QAEXHHHH@Z			; CRect::SetRect
EXTRN	__imp__GetWindowRect@8:NEAR
EXTRN	__imp__GetSystemMetrics@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_nHeight$ = -28						; size = 4
_nWidth$ = -24						; size = 4
_rect$ = -20						; size = 16
_hWndTrayWnd$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetTrayWndRect@CTrayIconPosition@@KA?AVCRect@@XZ PROC NEAR ; CTrayIconPosition::GetTrayWndRect

; 252  : {    

  00560	55		 push	 ebp
  00561	8b ec		 mov	 ebp, esp
  00563	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 253  : 	CRect rect(0,0,0,0);

  00566	6a 00		 push	 0
  00568	6a 00		 push	 0
  0056a	6a 00		 push	 0
  0056c	6a 00		 push	 0
  0056e	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  00571	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect

; 254  : 	
; 255  : 	HWND hWndTrayWnd = GetTrayNotifyWnd(FALSE);

  00576	6a 00		 push	 0
  00578	e8 00 00 00 00	 call	 ?GetTrayNotifyWnd@CTrayIconPosition@@KAPAUHWND__@@H@Z ; CTrayIconPosition::GetTrayNotifyWnd
  0057d	83 c4 04	 add	 esp, 4
  00580	89 45 fc	 mov	 DWORD PTR _hWndTrayWnd$[ebp], eax

; 256  : 	if(hWndTrayWnd)

  00583	83 7d fc 00	 cmp	 DWORD PTR _hWndTrayWnd$[ebp], 0
  00587	74 2d		 je	 SHORT $L197551

; 257  : 	{
; 258  : 		GetWindowRect(hWndTrayWnd, &rect);

  00589	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  0058c	50		 push	 eax
  0058d	8b 4d fc	 mov	 ecx, DWORD PTR _hWndTrayWnd$[ebp]
  00590	51		 push	 ecx
  00591	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8

; 259  : 		return rect;

  00597	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0059a	8b 45 ec	 mov	 eax, DWORD PTR _rect$[ebp]
  0059d	89 02		 mov	 DWORD PTR [edx], eax
  0059f	8b 4d f0	 mov	 ecx, DWORD PTR _rect$[ebp+4]
  005a2	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  005a5	8b 45 f4	 mov	 eax, DWORD PTR _rect$[ebp+8]
  005a8	89 42 08	 mov	 DWORD PTR [edx+8], eax
  005ab	8b 4d f8	 mov	 ecx, DWORD PTR _rect$[ebp+12]
  005ae	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  005b1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005b4	eb 51		 jmp	 SHORT $L197548
$L197551:

; 260  : 	}
; 261  : 
; 262  : 	int nWidth  = GetSystemMetrics(SM_CXSCREEN);

  005b6	6a 00		 push	 0
  005b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  005be	89 45 e8	 mov	 DWORD PTR _nWidth$[ebp], eax

; 263  :     int nHeight = GetSystemMetrics(SM_CYSCREEN);

  005c1	6a 01		 push	 1
  005c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  005c9	89 45 e4	 mov	 DWORD PTR _nHeight$[ebp], eax

; 264  :     rect.SetRect(nWidth-40, nHeight-20, nWidth, nHeight);

  005cc	8b 55 e4	 mov	 edx, DWORD PTR _nHeight$[ebp]
  005cf	52		 push	 edx
  005d0	8b 45 e8	 mov	 eax, DWORD PTR _nWidth$[ebp]
  005d3	50		 push	 eax
  005d4	8b 4d e4	 mov	 ecx, DWORD PTR _nHeight$[ebp]
  005d7	83 e9 14	 sub	 ecx, 20			; 00000014H
  005da	51		 push	 ecx
  005db	8b 55 e8	 mov	 edx, DWORD PTR _nWidth$[ebp]
  005de	83 ea 28	 sub	 edx, 40			; 00000028H
  005e1	52		 push	 edx
  005e2	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  005e5	e8 00 00 00 00	 call	 ?SetRect@CRect@@QAEXHHHH@Z ; CRect::SetRect

; 265  : 
; 266  : 	return rect;

  005ea	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005ed	8b 4d ec	 mov	 ecx, DWORD PTR _rect$[ebp]
  005f0	89 08		 mov	 DWORD PTR [eax], ecx
  005f2	8b 55 f0	 mov	 edx, DWORD PTR _rect$[ebp+4]
  005f5	89 50 04	 mov	 DWORD PTR [eax+4], edx
  005f8	8b 4d f4	 mov	 ecx, DWORD PTR _rect$[ebp+8]
  005fb	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  005fe	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp+12]
  00601	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00604	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L197548:

; 267  : }

  00607	8b e5		 mov	 esp, ebp
  00609	5d		 pop	 ebp
  0060a	c3		 ret	 0
?GetTrayWndRect@CTrayIconPosition@@KA?AVCRect@@XZ ENDP	; CTrayIconPosition::GetTrayWndRect
_TEXT	ENDS
PUBLIC	??4CRect@@QAEXABUtagRECT@@@Z			; CRect::operator=
EXTRN	__imp__SendMessageA@16:NEAR
EXTRN	__imp__VirtualAllocEx@20:NEAR
EXTRN	__imp__VirtualFreeEx@16:NEAR
EXTRN	__imp__OpenProcess@12:NEAR
EXTRN	__imp__ReadProcessMemory@20:NEAR
EXTRN	__imp__MapWindowPoints@16:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	__imp__GetWindowThreadProcessId@8:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
$T198102 = -104						; size = 16
_dwBytesRead$197575 = -88				; size = 4
_hWndOfIconOwner$197584 = -84				; size = 4
_buttonData$197576 = -80				; size = 20
__$ArrayPad$ = -60					; size = 4
_iIconId$197586 = -56					; size = 4
_dwExtraData$197581 = -52				; size = 8
_rcPosition$197591 = -44				; size = 16
_iButton$197571 = -28					; size = 4
_dwTrayProcessID$ = -24					; size = 4
_bIconFound$ = -20					; size = 4
_iButtonsCount$ = -16					; size = 4
_lpData$ = -12						; size = 4
_hTrayProc$ = -8					; size = 4
_hWndTray$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
_a_hWndOwner$ = 8					; size = 4
_a_iButtonID$ = 12					; size = 4
_a_rcIcon$ = 16						; size = 4
?FindOutPositionOfIconDirectly@CTrayIconPosition@@KAHQAUHWND__@@HAAVCRect@@@Z PROC NEAR ; CTrayIconPosition::FindOutPositionOfIconDirectly

; 274  : {

  00610	55		 push	 ebp
  00611	8b ec		 mov	 ebp, esp
  00613	83 ec 68	 sub	 esp, 104		; 00000068H
  00616	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0061b	89 45 c4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 275  : 	//first of all let's find a Tool bar control embed in Tray window
; 276  : 	HWND hWndTray = GetTrayNotifyWnd(TRUE);

  0061e	6a 01		 push	 1
  00620	e8 00 00 00 00	 call	 ?GetTrayNotifyWnd@CTrayIconPosition@@KAPAUHWND__@@H@Z ; CTrayIconPosition::GetTrayNotifyWnd
  00625	83 c4 04	 add	 esp, 4
  00628	89 45 fc	 mov	 DWORD PTR _hWndTray$[ebp], eax

; 277  :     if (hWndTray == NULL)    

  0062b	83 7d fc 00	 cmp	 DWORD PTR _hWndTray$[ebp], 0
  0062f	75 07		 jne	 SHORT $L197560

; 278  : 	{
; 279  : 		return FALSE;

  00631	33 c0		 xor	 eax, eax
  00633	e9 10 02 00 00	 jmp	 $L197558
$L197560:

; 280  : 	}
; 281  : 
; 282  : 	//now we have to get an ID of the parent process for system tray
; 283  : 	DWORD dwTrayProcessID = -1;

  00638	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _dwTrayProcessID$[ebp], -1

; 284  : 	GetWindowThreadProcessId(hWndTray, &dwTrayProcessID);

  0063f	8d 45 e8	 lea	 eax, DWORD PTR _dwTrayProcessID$[ebp]
  00642	50		 push	 eax
  00643	8b 4d fc	 mov	 ecx, DWORD PTR _hWndTray$[ebp]
  00646	51		 push	 ecx
  00647	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowThreadProcessId@8

; 285  : 	if(dwTrayProcessID <= 0)

  0064d	83 7d e8 00	 cmp	 DWORD PTR _dwTrayProcessID$[ebp], 0
  00651	77 07		 ja	 SHORT $L197562

; 286  : 	{
; 287  : 		return FALSE;

  00653	33 c0		 xor	 eax, eax
  00655	e9 ee 01 00 00	 jmp	 $L197558
$L197562:

; 288  : 	}
; 289  : 
; 290  : 	HANDLE hTrayProc = OpenProcess(PROCESS_ALL_ACCESS, 0, dwTrayProcessID);

  0065a	8b 55 e8	 mov	 edx, DWORD PTR _dwTrayProcessID$[ebp]
  0065d	52		 push	 edx
  0065e	6a 00		 push	 0
  00660	68 ff 0f 1f 00	 push	 2035711			; 001f0fffH
  00665	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcess@12
  0066b	89 45 f8	 mov	 DWORD PTR _hTrayProc$[ebp], eax

; 291  : 	if(hTrayProc == NULL)

  0066e	83 7d f8 00	 cmp	 DWORD PTR _hTrayProc$[ebp], 0
  00672	75 07		 jne	 SHORT $L197564

; 292  : 	{
; 293  : 		return FALSE;

  00674	33 c0		 xor	 eax, eax
  00676	e9 cd 01 00 00	 jmp	 $L197558
$L197564:

; 294  : 	}
; 295  :  
; 296  : 	//now we check how many buttons is there - should be more than 0
; 297  : 	int iButtonsCount = SendMessage(hWndTray, TB_BUTTONCOUNT, 0, 0);

  0067b	6a 00		 push	 0
  0067d	6a 00		 push	 0
  0067f	68 18 04 00 00	 push	 1048			; 00000418H
  00684	8b 45 fc	 mov	 eax, DWORD PTR _hWndTray$[ebp]
  00687	50		 push	 eax
  00688	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  0068e	89 45 f0	 mov	 DWORD PTR _iButtonsCount$[ebp], eax

; 298  : 
; 299  : 	//We want to get data from another process - it's not possible to just send messages like TB_GETBUTTON with a localy
; 300  : 	//allocated buffer for return data. Pointer to localy allocated data has no usefull meaning in a context of another
; 301  : 	//process (since Win95) - so we need to allocate some memory inside Tray process.
; 302  : 	//We allocate sizeof(TBBUTTON) bytes of memory - because TBBUTTON is the biggest structure we will fetch. But this buffer
; 303  : 	//will be also used to get smaller pieces of data like RECT structures.
; 304  : 	LPVOID lpData = VirtualAllocEx(hTrayProc, NULL, sizeof(TBBUTTON), MEM_COMMIT, PAGE_READWRITE);

  00691	6a 04		 push	 4
  00693	68 00 10 00 00	 push	 4096			; 00001000H
  00698	6a 14		 push	 20			; 00000014H
  0069a	6a 00		 push	 0
  0069c	8b 4d f8	 mov	 ecx, DWORD PTR _hTrayProc$[ebp]
  0069f	51		 push	 ecx
  006a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAllocEx@20
  006a6	89 45 f4	 mov	 DWORD PTR _lpData$[ebp], eax

; 305  : 	if( lpData == NULL || iButtonsCount < 1 )

  006a9	83 7d f4 00	 cmp	 DWORD PTR _lpData$[ebp], 0
  006ad	74 06		 je	 SHORT $L197569
  006af	83 7d f0 01	 cmp	 DWORD PTR _iButtonsCount$[ebp], 1
  006b3	7d 11		 jge	 SHORT $L197568
$L197569:

; 306  : 	{
; 307  : 		CloseHandle(hTrayProc);

  006b5	8b 55 f8	 mov	 edx, DWORD PTR _hTrayProc$[ebp]
  006b8	52		 push	 edx
  006b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 308  : 		return FALSE;

  006bf	33 c0		 xor	 eax, eax
  006c1	e9 82 01 00 00	 jmp	 $L197558
$L197568:

; 309  : 	}
; 310  : 
; 311  : 	BOOL bIconFound = FALSE;

  006c6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bIconFound$[ebp], 0

; 312  : 
; 313  : 	for(int iButton=0; iButton<iButtonsCount; iButton++)

  006cd	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iButton$197571[ebp], 0
  006d4	eb 09		 jmp	 SHORT $L197572
$L197573:
  006d6	8b 45 e4	 mov	 eax, DWORD PTR _iButton$197571[ebp]
  006d9	83 c0 01	 add	 eax, 1
  006dc	89 45 e4	 mov	 DWORD PTR _iButton$197571[ebp], eax
$L197572:
  006df	8b 4d e4	 mov	 ecx, DWORD PTR _iButton$197571[ebp]
  006e2	3b 4d f0	 cmp	 ecx, DWORD PTR _iButtonsCount$[ebp]
  006e5	0f 8d 10 01 00
	00		 jge	 $L197574

; 314  : 	{
; 315  : 		//first let's read TBUTTON information about each button in a task bar of tray
; 316  : 
; 317  : 		DWORD dwBytesRead = -1;

  006eb	c7 45 a8 ff ff
	ff ff		 mov	 DWORD PTR _dwBytesRead$197575[ebp], -1

; 318  : 		TBBUTTON buttonData;
; 319  : 		SendMessage(hWndTray, TB_GETBUTTON, iButton, (LPARAM)lpData);

  006f2	8b 55 f4	 mov	 edx, DWORD PTR _lpData$[ebp]
  006f5	52		 push	 edx
  006f6	8b 45 e4	 mov	 eax, DWORD PTR _iButton$197571[ebp]
  006f9	50		 push	 eax
  006fa	68 17 04 00 00	 push	 1047			; 00000417H
  006ff	8b 4d fc	 mov	 ecx, DWORD PTR _hWndTray$[ebp]
  00702	51		 push	 ecx
  00703	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 320  : 		ReadProcessMemory(hTrayProc, lpData, &buttonData, sizeof(TBBUTTON), &dwBytesRead);

  00709	8d 55 a8	 lea	 edx, DWORD PTR _dwBytesRead$197575[ebp]
  0070c	52		 push	 edx
  0070d	6a 14		 push	 20			; 00000014H
  0070f	8d 45 b0	 lea	 eax, DWORD PTR _buttonData$197576[ebp]
  00712	50		 push	 eax
  00713	8b 4d f4	 mov	 ecx, DWORD PTR _lpData$[ebp]
  00716	51		 push	 ecx
  00717	8b 55 f8	 mov	 edx, DWORD PTR _hTrayProc$[ebp]
  0071a	52		 push	 edx
  0071b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20

; 321  : 		if(dwBytesRead < sizeof(TBBUTTON))

  00721	83 7d a8 14	 cmp	 DWORD PTR _dwBytesRead$197575[ebp], 20 ; 00000014H
  00725	73 02		 jae	 SHORT $L197580

; 322  : 		{
; 323  : 			continue;

  00727	eb ad		 jmp	 SHORT $L197573
$L197580:

; 324  : 		}
; 325  : 
; 326  : 		//now let's read extra data associated with each button: there will be a HWND of the window that created an icon and icon ID
; 327  : 		DWORD dwExtraData[2] = { 0,0 };

  00729	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _dwExtraData$197581[ebp], 0
  00730	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _dwExtraData$197581[ebp+4], 0

; 328  : 		ReadProcessMemory(hTrayProc, (LPVOID)buttonData.dwData, dwExtraData, sizeof(dwExtraData), &dwBytesRead);

  00737	8d 45 a8	 lea	 eax, DWORD PTR _dwBytesRead$197575[ebp]
  0073a	50		 push	 eax
  0073b	6a 08		 push	 8
  0073d	8d 4d cc	 lea	 ecx, DWORD PTR _dwExtraData$197581[ebp]
  00740	51		 push	 ecx
  00741	8b 55 bc	 mov	 edx, DWORD PTR _buttonData$197576[ebp+12]
  00744	52		 push	 edx
  00745	8b 45 f8	 mov	 eax, DWORD PTR _hTrayProc$[ebp]
  00748	50		 push	 eax
  00749	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20

; 329  : 		if(dwBytesRead < sizeof(dwExtraData))

  0074f	83 7d a8 08	 cmp	 DWORD PTR _dwBytesRead$197575[ebp], 8
  00753	73 05		 jae	 SHORT $L197583

; 330  : 		{
; 331  : 			continue;

  00755	e9 7c ff ff ff	 jmp	 $L197573
$L197583:

; 332  : 		}
; 333  : 
; 334  : 		HWND hWndOfIconOwner = (HWND) dwExtraData[0];

  0075a	8b 4d cc	 mov	 ecx, DWORD PTR _dwExtraData$197581[ebp]
  0075d	89 4d ac	 mov	 DWORD PTR _hWndOfIconOwner$197584[ebp], ecx

; 335  : 		int  iIconId		 = (int)  dwExtraData[1];

  00760	8b 55 d0	 mov	 edx, DWORD PTR _dwExtraData$197581[ebp+4]
  00763	89 55 c8	 mov	 DWORD PTR _iIconId$197586[ebp], edx

; 336  : 		
; 337  : 		if(hWndOfIconOwner != a_hWndOwner || iIconId != a_iButtonID)

  00766	8b 45 ac	 mov	 eax, DWORD PTR _hWndOfIconOwner$197584[ebp]
  00769	3b 45 08	 cmp	 eax, DWORD PTR _a_hWndOwner$[ebp]
  0076c	75 08		 jne	 SHORT $L197589
  0076e	8b 4d c8	 mov	 ecx, DWORD PTR _iIconId$197586[ebp]
  00771	3b 4d 0c	 cmp	 ecx, DWORD PTR _a_iButtonID$[ebp]
  00774	74 05		 je	 SHORT $L197588
$L197589:

; 338  : 		{
; 339  : 			continue;

  00776	e9 5b ff ff ff	 jmp	 $L197573
$L197588:

; 340  : 		}
; 341  : 		
; 342  : 		//we found our icon - in WinXP it could be hidden - let's check it:
; 343  : 		if( buttonData.fsState & TBSTATE_HIDDEN )

  0077b	0f b6 55 b8	 movzx	 edx, BYTE PTR _buttonData$197576[ebp+8]
  0077f	83 e2 08	 and	 edx, 8
  00782	74 02		 je	 SHORT $L197590

; 344  : 		{
; 345  : 			break;

  00784	eb 75		 jmp	 SHORT $L197574
$L197590:

; 346  : 		}
; 347  : 
; 348  : 		//now just ask a tool bar of rectangle of our icon
; 349  : 		RECT rcPosition = {0,0};

  00786	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _rcPosition$197591[ebp], 0
  0078d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _rcPosition$197591[ebp+4], 0
  00794	33 c0		 xor	 eax, eax
  00796	89 45 dc	 mov	 DWORD PTR _rcPosition$197591[ebp+8], eax
  00799	89 45 e0	 mov	 DWORD PTR _rcPosition$197591[ebp+12], eax

; 350  : 		SendMessage(hWndTray, TB_GETITEMRECT, iButton, (LPARAM)lpData);

  0079c	8b 4d f4	 mov	 ecx, DWORD PTR _lpData$[ebp]
  0079f	51		 push	 ecx
  007a0	8b 55 e4	 mov	 edx, DWORD PTR _iButton$197571[ebp]
  007a3	52		 push	 edx
  007a4	68 1d 04 00 00	 push	 1053			; 0000041dH
  007a9	8b 45 fc	 mov	 eax, DWORD PTR _hWndTray$[ebp]
  007ac	50		 push	 eax
  007ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 351  : 		ReadProcessMemory(hTrayProc, lpData, &rcPosition, sizeof(RECT), &dwBytesRead);

  007b3	8d 4d a8	 lea	 ecx, DWORD PTR _dwBytesRead$197575[ebp]
  007b6	51		 push	 ecx
  007b7	6a 10		 push	 16			; 00000010H
  007b9	8d 55 d4	 lea	 edx, DWORD PTR _rcPosition$197591[ebp]
  007bc	52		 push	 edx
  007bd	8b 45 f4	 mov	 eax, DWORD PTR _lpData$[ebp]
  007c0	50		 push	 eax
  007c1	8b 4d f8	 mov	 ecx, DWORD PTR _hTrayProc$[ebp]
  007c4	51		 push	 ecx
  007c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20

; 352  : 
; 353  : 		if(dwBytesRead < sizeof(RECT))

  007cb	83 7d a8 10	 cmp	 DWORD PTR _dwBytesRead$197575[ebp], 16 ; 00000010H
  007cf	73 05		 jae	 SHORT $L197595

; 354  : 		{
; 355  : 			continue;

  007d1	e9 00 ff ff ff	 jmp	 $L197573
$L197595:

; 356  : 		}
; 357  : 
; 358  : 		MapWindowPoints(hWndTray, NULL, (LPPOINT)&rcPosition, 2);

  007d6	6a 02		 push	 2
  007d8	8d 55 d4	 lea	 edx, DWORD PTR _rcPosition$197591[ebp]
  007db	52		 push	 edx
  007dc	6a 00		 push	 0
  007de	8b 45 fc	 mov	 eax, DWORD PTR _hWndTray$[ebp]
  007e1	50		 push	 eax
  007e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapWindowPoints@16

; 359  : 		a_rcIcon = rcPosition;

  007e8	8d 4d d4	 lea	 ecx, DWORD PTR _rcPosition$197591[ebp]
  007eb	51		 push	 ecx
  007ec	8b 4d 10	 mov	 ecx, DWORD PTR _a_rcIcon$[ebp]
  007ef	e8 00 00 00 00	 call	 ??4CRect@@QAEXABUtagRECT@@@Z ; CRect::operator=

; 360  : 		
; 361  : 		bIconFound = TRUE;

  007f4	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bIconFound$[ebp], 1
$L197574:

; 362  : 		break;
; 363  : 	}
; 364  : 
; 365  : 	if(bIconFound == FALSE)

  007fb	83 7d ec 00	 cmp	 DWORD PTR _bIconFound$[ebp], 0
  007ff	75 25		 jne	 SHORT $L197597

; 366  : 	{
; 367  : 		a_rcIcon = GetTrayWndRect(); //we failed to detect position of icon - let's return fail safe cooridinates of system tray

  00801	8d 55 98	 lea	 edx, DWORD PTR $T198102[ebp]
  00804	52		 push	 edx
  00805	e8 00 00 00 00	 call	 ?GetTrayWndRect@CTrayIconPosition@@KA?AVCRect@@XZ ; CTrayIconPosition::GetTrayWndRect
  0080a	83 c4 04	 add	 esp, 4
  0080d	8b 4d 10	 mov	 ecx, DWORD PTR _a_rcIcon$[ebp]
  00810	8b 10		 mov	 edx, DWORD PTR [eax]
  00812	89 11		 mov	 DWORD PTR [ecx], edx
  00814	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00817	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0081a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0081d	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00820	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00823	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$L197597:

; 368  : 	}
; 369  : 
; 370  : 	VirtualFreeEx(hTrayProc, lpData, NULL, MEM_RELEASE);

  00826	68 00 80 00 00	 push	 32768			; 00008000H
  0082b	6a 00		 push	 0
  0082d	8b 4d f4	 mov	 ecx, DWORD PTR _lpData$[ebp]
  00830	51		 push	 ecx
  00831	8b 55 f8	 mov	 edx, DWORD PTR _hTrayProc$[ebp]
  00834	52		 push	 edx
  00835	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFreeEx@16

; 371  : 	CloseHandle(hTrayProc);

  0083b	8b 45 f8	 mov	 eax, DWORD PTR _hTrayProc$[ebp]
  0083e	50		 push	 eax
  0083f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 372  : 
; 373  : 	return bIconFound;	

  00845	8b 45 ec	 mov	 eax, DWORD PTR _bIconFound$[ebp]
$L197558:

; 374  : }

  00848	8b 4d c4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0084b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00850	8b e5		 mov	 esp, ebp
  00852	5d		 pop	 ebp
  00853	c3		 ret	 0
?FindOutPositionOfIconDirectly@CTrayIconPosition@@KAHQAUHWND__@@HAAVCRect@@@Z ENDP ; CTrayIconPosition::FindOutPositionOfIconDirectly
_TEXT	ENDS
EXTRN	__imp___mbscmp:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\tchar.h
;	COMDAT __tcscmp
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcscmp PROC NEAR					; COMDAT

; 854  : __inline int _tcscmp(_CPC _s1,_CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __s2$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbscmp
  00011	83 c4 08	 add	 esp, 8
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
__tcscmp ENDP
_TEXT	ENDS
PUBLIC	?CheckIfColorIsBlackOrNearBlack@CTrayIconPosition@@IAEHK@Z ; CTrayIconPosition::CheckIfColorIsBlackOrNearBlack
EXTRN	__imp__Shell_NotifyIconA@8:NEAR
EXTRN	__imp__GetDC@4:NEAR
EXTRN	__imp__ReleaseDC@8:NEAR
EXTRN	__imp__GetPixel@12:NEAR
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\tray\trayiconposition.cpp
_TEXT	SEGMENT
_this$ = -528						; size = 4
_crPixel$197620 = -524					; size = 4
_crPixel3$197622 = -520					; size = 4
_crPixel2$197621 = -516					; size = 4
_ix$197616 = -512					; size = 4
_iNoOfPixelsInLine$197615 = -508			; size = 4
_iy$197611 = -504					; size = 4
_bWeFoundIt$ = -500					; size = 4
_nid$ = -496						; size = 488
__$ArrayPad$ = -8					; size = 4
_hdcScreen$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_icon$ = 8						; size = 4
?FindOutPositionOfIcon@CTrayIconPosition@@IAEHPAUHICON__@@@Z PROC NEAR ; CTrayIconPosition::FindOutPositionOfIcon
; _this$ = ecx

; 387  : {

  00860	55		 push	 ebp
  00861	8b ec		 mov	 ebp, esp
  00863	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00869	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0086e	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00871	89 8d f0 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 	//First: let's set a BLANK icon in the tray.
; 389  : 	NOTIFYICONDATA nid; 
; 390  : 	nid.cbSize = sizeof(nid); 

  00877	c7 85 10 fe ff
	ff e8 01 00 00	 mov	 DWORD PTR _nid$[ebp], 488 ; 000001e8H

; 391  : 	nid.hWnd = m_hWndOfIconOwner; 

  00881	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00887	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0088a	89 8d 14 fe ff
	ff		 mov	 DWORD PTR _nid$[ebp+4], ecx

; 392  : 	nid.uID = m_iTrayIconID; 

  00890	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00896	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00899	89 85 18 fe ff
	ff		 mov	 DWORD PTR _nid$[ebp+8], eax

; 393  : 	nid.uFlags = NIF_ICON; 

  0089f	c7 85 1c fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _nid$[ebp+12], 2

; 394  : 	nid.hIcon = icon;

  008a9	8b 4d 08	 mov	 ecx, DWORD PTR _icon$[ebp]
  008ac	89 8d 24 fe ff
	ff		 mov	 DWORD PTR _nid$[ebp+20], ecx

; 395  : 	Shell_NotifyIcon(NIM_MODIFY, &nid);

  008b2	8d 95 10 fe ff
	ff		 lea	 edx, DWORD PTR _nid$[ebp]
  008b8	52		 push	 edx
  008b9	6a 01		 push	 1
  008bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Shell_NotifyIconA@8

; 396  : 	BOOL bWeFoundIt = FALSE;

  008c1	c7 85 0c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _bWeFoundIt$[ebp], 0

; 397  : 	
; 398  : 	HDC hdcScreen = GetDC(NULL);

  008cb	6a 00		 push	 0
  008cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  008d3	89 45 fc	 mov	 DWORD PTR _hdcScreen$[ebp], eax

; 399  : 	
; 400  : 	//since tray window can be strethed verticaly let's scan this area in few steps starting from the bottom to the top.
; 401  : 	for(int iy = m_rtRectangleOfTheTray.bottom-3; iy > m_rtRectangleOfTheTray.top; iy--)

  008d6	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008dc	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  008df	83 e9 03	 sub	 ecx, 3
  008e2	89 8d 08 fe ff
	ff		 mov	 DWORD PTR _iy$197611[ebp], ecx
  008e8	eb 0f		 jmp	 SHORT $L197612
$L197613:
  008ea	8b 95 08 fe ff
	ff		 mov	 edx, DWORD PTR _iy$197611[ebp]
  008f0	83 ea 01	 sub	 edx, 1
  008f3	89 95 08 fe ff
	ff		 mov	 DWORD PTR _iy$197611[ebp], edx
$L197612:
  008f9	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008ff	8b 8d 08 fe ff
	ff		 mov	 ecx, DWORD PTR _iy$197611[ebp]
  00905	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00908	0f 8e 4a 01 00
	00		 jle	 $L197614

; 402  : 	{
; 403  : 		int iNoOfPixelsInLine=0;

  0090e	c7 85 04 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iNoOfPixelsInLine$197615[ebp], 0

; 404  : 		for(int ix=m_rtRectangleOfTheTray.left;ix<m_rtRectangleOfTheTray.right;ix++)

  00918	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0091e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00921	89 85 00 fe ff
	ff		 mov	 DWORD PTR _ix$197616[ebp], eax
  00927	eb 0f		 jmp	 SHORT $L197617
$L197618:
  00929	8b 8d 00 fe ff
	ff		 mov	 ecx, DWORD PTR _ix$197616[ebp]
  0092f	83 c1 01	 add	 ecx, 1
  00932	89 8d 00 fe ff
	ff		 mov	 DWORD PTR _ix$197616[ebp], ecx
$L197617:
  00938	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0093e	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR _ix$197616[ebp]
  00944	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00947	0f 8d fb 00 00
	00		 jge	 $L197619

; 405  : 		{
; 406  : 			COLORREF crPixel = GetPixel(hdcScreen, ix, iy);

  0094d	8b 8d 08 fe ff
	ff		 mov	 ecx, DWORD PTR _iy$197611[ebp]
  00953	51		 push	 ecx
  00954	8b 95 00 fe ff
	ff		 mov	 edx, DWORD PTR _ix$197616[ebp]
  0095a	52		 push	 edx
  0095b	8b 45 fc	 mov	 eax, DWORD PTR _hdcScreen$[ebp]
  0095e	50		 push	 eax
  0095f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPixel@12
  00965	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _crPixel$197620[ebp], eax

; 407  : 			COLORREF crPixel2 = GetPixel(hdcScreen, ix, iy-2);

  0096b	8b 8d 08 fe ff
	ff		 mov	 ecx, DWORD PTR _iy$197611[ebp]
  00971	83 e9 02	 sub	 ecx, 2
  00974	51		 push	 ecx
  00975	8b 95 00 fe ff
	ff		 mov	 edx, DWORD PTR _ix$197616[ebp]
  0097b	52		 push	 edx
  0097c	8b 45 fc	 mov	 eax, DWORD PTR _hdcScreen$[ebp]
  0097f	50		 push	 eax
  00980	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPixel@12
  00986	89 85 fc fd ff
	ff		 mov	 DWORD PTR _crPixel2$197621[ebp], eax

; 408  : 			COLORREF crPixel3 = GetPixel(hdcScreen, ix, iy+2);

  0098c	8b 8d 08 fe ff
	ff		 mov	 ecx, DWORD PTR _iy$197611[ebp]
  00992	83 c1 02	 add	 ecx, 2
  00995	51		 push	 ecx
  00996	8b 95 00 fe ff
	ff		 mov	 edx, DWORD PTR _ix$197616[ebp]
  0099c	52		 push	 edx
  0099d	8b 45 fc	 mov	 eax, DWORD PTR _hdcScreen$[ebp]
  009a0	50		 push	 eax
  009a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPixel@12
  009a7	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _crPixel3$197622[ebp], eax

; 409  : 			if(CheckIfColorIsBlackOrNearBlack(crPixel)  && CheckIfColorIsBlackOrNearBlack(crPixel2)  && CheckIfColorIsBlackOrNearBlack(crPixel3))

  009ad	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR _crPixel$197620[ebp]
  009b3	51		 push	 ecx
  009b4	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009ba	e8 00 00 00 00	 call	 ?CheckIfColorIsBlackOrNearBlack@CTrayIconPosition@@IAEHK@Z ; CTrayIconPosition::CheckIfColorIsBlackOrNearBlack
  009bf	85 c0		 test	 eax, eax
  009c1	74 3d		 je	 SHORT $L197623
  009c3	8b 95 fc fd ff
	ff		 mov	 edx, DWORD PTR _crPixel2$197621[ebp]
  009c9	52		 push	 edx
  009ca	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009d0	e8 00 00 00 00	 call	 ?CheckIfColorIsBlackOrNearBlack@CTrayIconPosition@@IAEHK@Z ; CTrayIconPosition::CheckIfColorIsBlackOrNearBlack
  009d5	85 c0		 test	 eax, eax
  009d7	74 27		 je	 SHORT $L197623
  009d9	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _crPixel3$197622[ebp]
  009df	50		 push	 eax
  009e0	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009e6	e8 00 00 00 00	 call	 ?CheckIfColorIsBlackOrNearBlack@CTrayIconPosition@@IAEHK@Z ; CTrayIconPosition::CheckIfColorIsBlackOrNearBlack
  009eb	85 c0		 test	 eax, eax
  009ed	74 11		 je	 SHORT $L197623

; 410  : 			{
; 411  : 				iNoOfPixelsInLine++;

  009ef	8b 8d 04 fe ff
	ff		 mov	 ecx, DWORD PTR _iNoOfPixelsInLine$197615[ebp]
  009f5	83 c1 01	 add	 ecx, 1
  009f8	89 8d 04 fe ff
	ff		 mov	 DWORD PTR _iNoOfPixelsInLine$197615[ebp], ecx

; 412  : 			}
; 413  : 			else

  009fe	eb 0a		 jmp	 SHORT $L197624
$L197623:

; 414  : 			{
; 415  : 				iNoOfPixelsInLine = 0;

  00a00	c7 85 04 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iNoOfPixelsInLine$197615[ebp], 0
$L197624:

; 416  : 			}
; 417  : 			
; 418  : 			if(iNoOfPixelsInLine > 8)

  00a0a	83 bd 04 fe ff
	ff 08		 cmp	 DWORD PTR _iNoOfPixelsInLine$197615[ebp], 8
  00a11	7e 30		 jle	 SHORT $L197625

; 419  : 			{
; 420  : 				//well I think we found it!
; 421  : 				m_ptPosition.x = ix-1;

  00a13	8b 95 00 fe ff
	ff		 mov	 edx, DWORD PTR _ix$197616[ebp]
  00a19	83 ea 01	 sub	 edx, 1
  00a1c	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a22	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 422  : 				m_ptPosition.y = iy-6;

  00a25	8b 8d 08 fe ff
	ff		 mov	 ecx, DWORD PTR _iy$197611[ebp]
  00a2b	83 e9 06	 sub	 ecx, 6
  00a2e	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00a34	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 423  : 				bWeFoundIt = TRUE;

  00a37	c7 85 0c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _bWeFoundIt$[ebp], 1

; 424  : 				break;

  00a41	eb 05		 jmp	 SHORT $L197619
$L197625:

; 425  : 			}
; 426  : 		}

  00a43	e9 e1 fe ff ff	 jmp	 $L197618
$L197619:

; 427  : 		
; 428  : 		if(bWeFoundIt)

  00a48	83 bd 0c fe ff
	ff 00		 cmp	 DWORD PTR _bWeFoundIt$[ebp], 0
  00a4f	74 02		 je	 SHORT $L197626

; 429  : 		{
; 430  : 			break;

  00a51	eb 05		 jmp	 SHORT $L197614
$L197626:

; 431  : 		}
; 432  : 	}

  00a53	e9 92 fe ff ff	 jmp	 $L197613
$L197614:

; 433  : 
; 434  : 	ReleaseDC(NULL, hdcScreen);

  00a58	8b 45 fc	 mov	 eax, DWORD PTR _hdcScreen$[ebp]
  00a5b	50		 push	 eax
  00a5c	6a 00		 push	 0
  00a5e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 435  : 	return bWeFoundIt;

  00a64	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _bWeFoundIt$[ebp]

; 436  : }

  00a6a	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a6d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a72	8b e5		 mov	 esp, ebp
  00a74	5d		 pop	 ebp
  00a75	c2 04 00	 ret	 4
?FindOutPositionOfIcon@CTrayIconPosition@@IAEHPAUHICON__@@@Z ENDP ; CTrayIconPosition::FindOutPositionOfIcon
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?CheckIfColorIsBlackOrNearBlack@CTrayIconPosition@@IAEHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_crColor$ = 8						; size = 4
?CheckIfColorIsBlackOrNearBlack@CTrayIconPosition@@IAEHK@Z PROC NEAR ; CTrayIconPosition::CheckIfColorIsBlackOrNearBlack, COMDAT
; _this$ = ecx

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 380  : 	//code improved by Harald according to
; 381  : 	//http://www.codeproject.com/shell/ctrayiconposition.asp?forumid=14631&select=786426&df=100#xx786426xx
; 382  : 
; 383  : 	return !(((DWORD)crColor)&0xFCFCFC);

  00007	8b 45 08	 mov	 eax, DWORD PTR _crColor$[ebp]
  0000a	25 fc fc fc 00	 and	 eax, 16579836		; 00fcfcfcH
  0000f	f7 d8		 neg	 eax
  00011	1b c0		 sbb	 eax, eax
  00013	40		 inc	 eax

; 384  : }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?CheckIfColorIsBlackOrNearBlack@CTrayIconPosition@@IAEHK@Z ENDP ; CTrayIconPosition::CheckIfColorIsBlackOrNearBlack
_TEXT	ENDS
PUBLIC	?RestoreTrayIcon@CTrayIconPosition@@QAEXPAUHICON__@@@Z ; CTrayIconPosition::RestoreTrayIcon
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -500						; size = 4
_nid$ = -496						; size = 488
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_icon$ = 8						; size = 4
?RestoreTrayIcon@CTrayIconPosition@@QAEXPAUHICON__@@@Z PROC NEAR ; CTrayIconPosition::RestoreTrayIcon
; _this$ = ecx

; 439  : {

  00a80	55		 push	 ebp
  00a81	8b ec		 mov	 ebp, esp
  00a83	81 ec f4 01 00
	00		 sub	 esp, 500		; 000001f4H
  00a89	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00a8e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00a91	89 8d 0c fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 440  : 	  NOTIFYICONDATA nid; 
; 441  : 	  nid.cbSize = sizeof(nid); 

  00a97	c7 85 10 fe ff
	ff e8 01 00 00	 mov	 DWORD PTR _nid$[ebp], 488 ; 000001e8H

; 442  : 	  nid.hWnd = m_hWndOfIconOwner; 

  00aa1	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00aa7	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00aaa	89 8d 14 fe ff
	ff		 mov	 DWORD PTR _nid$[ebp+4], ecx

; 443  : 	  nid.uID = m_iTrayIconID; 

  00ab0	8b 95 0c fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00ab6	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00ab9	89 85 18 fe ff
	ff		 mov	 DWORD PTR _nid$[ebp+8], eax

; 444  : 	  nid.uFlags = NIF_ICON; 

  00abf	c7 85 1c fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _nid$[ebp+12], 2

; 445  : 	  nid.hIcon = icon;

  00ac9	8b 4d 08	 mov	 ecx, DWORD PTR _icon$[ebp]
  00acc	89 8d 24 fe ff
	ff		 mov	 DWORD PTR _nid$[ebp+20], ecx

; 446  : 	  Shell_NotifyIcon(NIM_MODIFY, &nid);	

  00ad2	8d 95 10 fe ff
	ff		 lea	 edx, DWORD PTR _nid$[ebp]
  00ad8	52		 push	 edx
  00ad9	6a 01		 push	 1
  00adb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Shell_NotifyIconA@8

; 447  : }

  00ae1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ae4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ae9	8b e5		 mov	 esp, ebp
  00aeb	5d		 pop	 ebp
  00aec	c2 04 00	 ret	 4
?RestoreTrayIcon@CTrayIconPosition@@QAEXPAUHICON__@@@Z ENDP ; CTrayIconPosition::RestoreTrayIcon
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@HHHHHHH@Z			; ATL::CTime::CTime
PUBLIC	?Invalidate@CTrayIconPosition@@QAEXXZ		; CTrayIconPosition::Invalidate
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T198115 = -8						; size = 8
?Invalidate@CTrayIconPosition@@QAEXXZ PROC NEAR		; CTrayIconPosition::Invalidate
; _this$ = ecx

; 450  : {

  00af0	55		 push	 ebp
  00af1	8b ec		 mov	 ebp, esp
  00af3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00af6	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 451  : 	m_tLastUpdate = CTime(2000,1,1,1,1,1);

  00af9	6a ff		 push	 -1
  00afb	6a 01		 push	 1
  00afd	6a 01		 push	 1
  00aff	6a 01		 push	 1
  00b01	6a 01		 push	 1
  00b03	6a 01		 push	 1
  00b05	68 d0 07 00 00	 push	 2000			; 000007d0H
  00b0a	8d 4d f8	 lea	 ecx, DWORD PTR $T198115[ebp]
  00b0d	e8 00 00 00 00	 call	 ??0CTime@ATL@@QAE@HHHHHHH@Z ; ATL::CTime::CTime
  00b12	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b14	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00b17	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00b1a	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00b1d	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 452  : }

  00b20	8b e5		 mov	 esp, ebp
  00b22	5d		 pop	 ebp
  00b23	c3		 ret	 0
?Invalidate@CTrayIconPosition@@QAEXXZ ENDP		; CTrayIconPosition::Invalidate
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
_TEXT	ENDS
;	COMDAT ?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ PROC NEAR	; ATL::CTimeSpan::GetTotalSeconds, COMDAT
; _this$ = ecx

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 68   : 	return( m_timeSpan );

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 69   : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ ENDP		; ATL::CTimeSpan::GetTotalSeconds
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@_J@Z				; ATL::CTime::CTime
EXTRN	__imp___time64:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ PROC NEAR		; ATL::CTime::GetTickCount, COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  : 	return( CTime( ::_time64( NULL ) ) );

  00003	6a 00		 push	 0
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  0000b	83 c4 04	 add	 esp, 4
  0000e	52		 push	 edx
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CTime@ATL@@QAE@_J@Z	; ATL::CTime::CTime
  00018	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 140  : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ ENDP		; ATL::CTime::GetTickCount
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CTime@ATL@@QAE@XZ PROC NEAR				; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 145  : }

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CTime@ATL@@QAE@XZ ENDP				; ATL::CTime::CTime
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_time$ = 8						; size = 8
??0CTime@ATL@@QAE@_J@Z PROC NEAR			; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _time$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _time$[ebp+4]
  00012	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 150  : }

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
??0CTime@ATL@@QAE@_J@Z ENDP				; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
EXTRN	__imp___mktime64:NEAR
; Function compile flags: /Odt
;	COMDAT ??0CTime@ATL@@QAE@HHHHHHH@Z
_TEXT	SEGMENT
tv86 = -44						; size = 4
_this$ = -40						; size = 4
_atm$ = -36						; size = 36
_nYear$ = 8						; size = 4
_nMonth$ = 12						; size = 4
_nDay$ = 16						; size = 4
_nHour$ = 20						; size = 4
_nMin$ = 24						; size = 4
_nSec$ = 28						; size = 4
_nDST$ = 32						; size = 4
??0CTime@ATL@@QAE@HHHHHHH@Z PROC NEAR			; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 155  : 	struct tm atm;
; 156  : 	atm.tm_sec = nSec;

  00009	8b 45 1c	 mov	 eax, DWORD PTR _nSec$[ebp]
  0000c	89 45 dc	 mov	 DWORD PTR _atm$[ebp], eax

; 157  : 	atm.tm_min = nMin;

  0000f	8b 4d 18	 mov	 ecx, DWORD PTR _nMin$[ebp]
  00012	89 4d e0	 mov	 DWORD PTR _atm$[ebp+4], ecx

; 158  : 	atm.tm_hour = nHour;

  00015	8b 55 14	 mov	 edx, DWORD PTR _nHour$[ebp]
  00018	89 55 e4	 mov	 DWORD PTR _atm$[ebp+8], edx

; 159  : 	ATLASSERT(nDay >= 1 && nDay <= 31);
; 160  : 	atm.tm_mday = nDay;

  0001b	8b 45 10	 mov	 eax, DWORD PTR _nDay$[ebp]
  0001e	89 45 e8	 mov	 DWORD PTR _atm$[ebp+12], eax

; 161  : 	ATLASSERT(nMonth >= 1 && nMonth <= 12);
; 162  : 	atm.tm_mon = nMonth - 1;        // tm_mon is 0 based

  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _nMonth$[ebp]
  00024	83 e9 01	 sub	 ecx, 1
  00027	89 4d ec	 mov	 DWORD PTR _atm$[ebp+16], ecx

; 163  : 	ATLASSERT(nYear >= 1900);
; 164  : 	atm.tm_year = nYear - 1900;     // tm_year is 1900 based

  0002a	8b 55 08	 mov	 edx, DWORD PTR _nYear$[ebp]
  0002d	81 ea 6c 07 00
	00		 sub	 edx, 1900		; 0000076cH
  00033	89 55 f0	 mov	 DWORD PTR _atm$[ebp+20], edx

; 165  : 	atm.tm_isdst = nDST;

  00036	8b 45 20	 mov	 eax, DWORD PTR _nDST$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR _atm$[ebp+32], eax

; 166  : 	m_time = _mktime64(&atm);

  0003c	8d 4d dc	 lea	 ecx, DWORD PTR _atm$[ebp]
  0003f	51		 push	 ecx
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
  00046	83 c4 04	 add	 esp, 4
  00049	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	89 01		 mov	 DWORD PTR [ecx], eax
  0004e	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 167  : 	ATLASSERT(m_time != -1);       // indicates an illegal input time
; 168  : 	
; 169  : 	if(m_time == -1)

  00051	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00054	89 55 d4	 mov	 DWORD PTR tv86[ebp], edx
  00057	8b 45 d4	 mov	 eax, DWORD PTR tv86[ebp]
  0005a	8b 4d d4	 mov	 ecx, DWORD PTR tv86[ebp]
  0005d	8b 10		 mov	 edx, DWORD PTR [eax]
  0005f	23 51 04	 and	 edx, DWORD PTR [ecx+4]
  00062	83 fa ff	 cmp	 edx, -1
  00065	75 0a		 jne	 SHORT $L28549

; 170  : 		AtlThrow(E_INVALIDARG);

  00067	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0006c	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L28549:

; 171  : }

  00071	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
$L198124:
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 1c 00	 ret	 28			; 0000001cH
??0CTime@ATL@@QAE@HHHHHHH@Z ENDP			; ATL::CTime::CTime
_TEXT	ENDS
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00003	81 7d 08 0e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
  0000a	75 05		 jne	 SHORT $L24681

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000c	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L24681:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00011	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L198126:

; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );
; 74   : #endif
; 75   : };

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	??0CTimeSpan@ATL@@QAE@_J@Z			; ATL::CTimeSpan::CTimeSpan
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_time$ = 12						; size = 8
??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z PROC NEAR	; ATL::CTime::operator-, COMDAT
; _this$ = ecx

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 258  : 	return( CTimeSpan( m_time-time.m_time ) );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	2b 4d 0c	 sub	 ecx, DWORD PTR _time$[ebp]
  0000f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00012	1b 55 10	 sbb	 edx, DWORD PTR _time$[ebp+4]
  00015	52		 push	 edx
  00016	51		 push	 ecx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0CTimeSpan@ATL@@QAE@_J@Z ; ATL::CTimeSpan::CTimeSpan
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 259  : }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z ENDP		; ATL::CTime::operator-
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CTimeSpan@ATL@@QAE@_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_time$ = 8						; size = 8
??0CTimeSpan@ATL@@QAE@_J@Z PROC NEAR			; ATL::CTimeSpan::CTimeSpan, COMDAT
; _this$ = ecx

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _time$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _time$[ebp+4]
  00012	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 34   : }

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
??0CTimeSpan@ATL@@QAE@_J@Z ENDP				; ATL::CTimeSpan::CTimeSpan
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CPoint@@QAE@XZ PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 61   : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CPoint@@QAE@XZ ENDP					; CPoint::CPoint
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRect@@QAE@XZ PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 110  : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CRect@@QAE@XZ ENDP					; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
??0CRect@@QAE@HHHH@Z PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 112  : 	{ left = l; top = t; right = r; bottom = b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _r$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _b$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
??0CRect@@QAE@HHHH@Z ENDP				; CRect::CRect
_TEXT	ENDS
PUBLIC	??0CPoint@@QAE@HH@Z				; CPoint::CPoint
; Function compile flags: /Odt
;	COMDAT ?CenterPoint@CRect@@QBE?AVCPoint@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?CenterPoint@CRect@@QBE?AVCPoint@@XZ PROC NEAR		; CRect::CenterPoint, COMDAT
; _this$ = ecx

; 137  : 	{ return CPoint((left+right)/2, (top+bottom)/2); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  00013	99		 cdq
  00014	2b c2		 sub	 eax, edx
  00016	d1 f8		 sar	 eax, 1
  00018	50		 push	 eax
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 02		 mov	 eax, DWORD PTR [edx]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00024	99		 cdq
  00025	2b c2		 sub	 eax, edx
  00027	d1 f8		 sar	 eax, 1
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?CenterPoint@CRect@@QBE?AVCPoint@@XZ ENDP		; CRect::CenterPoint
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initX$ = 8						; size = 4
_initY$ = 12						; size = 4
??0CPoint@@QAE@HH@Z PROC NEAR				; CPoint::CPoint, COMDAT
; _this$ = ecx

; 63   : 	{ x = initX; y = initY; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _initX$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _initY$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0CPoint@@QAE@HH@Z ENDP				; CPoint::CPoint
_TEXT	ENDS
EXTRN	__imp__SetRect@20:NEAR
; Function compile flags: /Odt
;	COMDAT ?SetRect@CRect@@QAEXHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?SetRect@CRect@@QAEXHHHH@Z PROC NEAR			; CRect::SetRect, COMDAT
; _this$ = ecx

; 153  : 	{ ::SetRect(this, x1, y1, x2, y2); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 14	 mov	 eax, DWORD PTR _y2$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _x2$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _y1$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR _x1$[ebp]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 10 00	 ret	 16			; 00000010H
?SetRect@CRect@@QAEXHHHH@Z ENDP				; CRect::SetRect
_TEXT	ENDS
EXTRN	__imp__CopyRect@8:NEAR
; Function compile flags: /Odt
;	COMDAT ??4CRect@@QAEXABUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_srcRect$ = 8						; size = 4
??4CRect@@QAEXABUtagRECT@@@Z PROC NEAR			; CRect::operator=, COMDAT
; _this$ = ecx

; 189  : 	{ ::CopyRect(this, &srcRect); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _srcRect$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyRect@8
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??4CRect@@QAEXABUtagRECT@@@Z ENDP			; CRect::operator=
_TEXT	ENDS
EXTRN	?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ:NEAR ; AfxGetModuleState
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin1.inl
;	COMDAT ?AfxGetApp@@YGPAVCWinApp@@XZ
_TEXT	SEGMENT
?AfxGetApp@@YGPAVCWinApp@@XZ PROC NEAR			; AfxGetApp, COMDAT

; 21   : 	{ return afxCurrentWinApp; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 ?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ ; AfxGetModuleState
  00008	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?AfxGetApp@@YGPAVCWinApp@@XZ ENDP			; AfxGetApp
_TEXT	ENDS
EXTRN	?AfxFindResourceHandle@@YGPAUHINSTANCE__@@PBD0@Z:NEAR ; AfxFindResourceHandle
EXTRN	__imp__LoadIconA@8:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin2.inl
;	COMDAT ?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIDResource$ = 8					; size = 4
?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z PROC NEAR	; CWinApp::LoadIconA, COMDAT
; _this$ = ecx

; 1014 : 	{ return ::LoadIcon(AfxFindResourceHandle(MAKEINTRESOURCE(nIDResource),

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1015 : 		RT_GROUP_ICON), MAKEINTRESOURCE(nIDResource)); }

  00007	0f b7 45 08	 movzx	 eax, WORD PTR _nIDResource$[ebp]
  0000b	50		 push	 eax
  0000c	6a 0e		 push	 14			; 0000000eH
  0000e	0f b7 4d 08	 movzx	 ecx, WORD PTR _nIDResource$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?AfxFindResourceHandle@@YGPAUHINSTANCE__@@PBD0@Z ; AfxFindResourceHandle
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z ENDP		; CWinApp::LoadIconA
_TEXT	ENDS
END
