; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\module\httpDown\LocalGameData.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04JAADICNI@?5?$DN?1?$FL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GJIJNDEK@ISO?98859?91?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??1IData@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppStart@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppExit@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIData@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OneLocalGame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@OneLocalGame@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAtlStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAtlStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringW@?$ChTraitsOS@_W@ATL@@KGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExW@?$ChTraitsOS@_W@ATL@@KGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiW@?$ChTraitsOS@_W@ATL@@KGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerW@?$ChTraitsOS@_W@ATL@@KGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperW@?$ChTraitsOS@_W@ATL@@KGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strchr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strrchr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strrev@?$ChTraitsOS@_W@ATL@@SAPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strstr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strspn@?$ChTraitsOS@_W@ATL@@SAHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strcspn@?$ChTraitsOS@_W@ATL@@SAHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strpbrk@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMarkup@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMarkup@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddElem@CMarkup@@QAE_NPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChildElem@CMarkup@@QAE_NPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAttrib@CMarkup@@QAE_NPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetPos@CMarkup@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrib@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ElemPos@CMarkup@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@ElemPos@CMarkup@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@TokenPos@CMarkup@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?x_SetPos@CMarkup@@IAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMarkup@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMarkupArchive@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddElem@CMarkupArchive@@UAE_NPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChildElem@CMarkupArchive@@UAE_NPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindElem@CMarkupArchive@@UAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindChildElem@CMarkupArchive@@UAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMarkupArchive@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0LocalGameData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GLocalGameData@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ILocalGameData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ILocalGameData@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LocalGameData@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GILocalGameData@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OneLocalGame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OneLocalGame@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXABUOneLocalGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEAAUOneLocalGame@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@ABUOneLocalGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXPAUOneLocalGame@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU3@IABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE@V?$allocator@UOneLocalGame@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UOneLocalGame@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEABUOneLocalGame@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXViterator@12@IABUOneLocalGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UOneLocalGame@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UOneLocalGame@@@std@@QAEPAUOneLocalGame@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OneLocalGame@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UOneLocalGame@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlAlignUp@H@ATL@@YGHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CArray@UElemPos@CMarkup@@AAU12@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CArray@UElemPos@CMarkup@@AAU12@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CArray@UElemPos@CMarkup@@AAU12@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$back_inserter@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAUOneLocalGame@@@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU2@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAUOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@0ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@UOneLocalGame@@@std@@YAPAUOneLocalGame@@IPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CArray@UElemPos@CMarkup@@AAU12@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAE@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$SerializeElements@UElemPos@CMarkup@@@@YGXAAVCArchive@@PAUElemPos@CMarkup@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUOneLocalGame@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOneLocalGame@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@ABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@ABUOneLocalGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UOneLocalGame@@@std@@YAXPAUOneLocalGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOneLocalGame@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@UElemPos@CMarkup@@AAU12@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CMarkup@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3LocalGameData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ILocalGameData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CMarkupArchive@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@UElemPos@CMarkup@@AAU12@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CMarkup@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2LocalGameData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ILocalGameData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CMarkupArchive@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUIAtlStringMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$CArray@UElemPos@CMarkup@@AAU12@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@LocalGameData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ILocalGameData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMarkup@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMarkupArchive@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCAtlStringMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$CArray@UElemPos@CMarkup@@AAU12@@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVLocalGameData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVIData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVILocalGameData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCMarkup@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCMarkupArchive@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4IData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CAtlStringMgr@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$CArray@UElemPos@CMarkup@@AAU12@@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CMarkup@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4LocalGameData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ILocalGameData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CMarkupArchive@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CArchive@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CArray@UElemPos@CMarkup@@AAU12@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVIQQItemCountChangeObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ILocalGameData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7LocalGameData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMarkupArchive@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __tcschr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __tcsnccmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMarkup@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNilStringData@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CAtlStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_pData@LocalGameData@@2PAV1@A			; LocalGameData::m_pData
PUBLIC	?_strthunks@ATL@@3U_AtlStringThunks@1@A		; ATL::_strthunks
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
PUBLIC	?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWThunk
PUBLIC	?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z	; ATL::CompareStringWThunk
PUBLIC	?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWThunk
PUBLIC	?lstrcmpiWThunk@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWThunk
PUBLIC	?CharLowerWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWThunk
PUBLIC	?CharUpperWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWThunk
PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
_BSS	SEGMENT
?m_pData@LocalGameData@@2PAV1@A DD 01H DUP (?)		; LocalGameData::m_pData
_BSS	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
CONST	ENDS
CONST	SEGMENT
$SG200009 DB	'%s\Resources\Profiles\usergame.xml', 00H
	ORG $+1
$SG200012 DB	'm_strDataFilePath:%s', 00H
	ORG $+3
$SG200013 DB	'DataAppStart', 00H
	ORG $+3
$SG200014 DB	'LocalGameData.txt', 00H
	ORG $+2
$SG200033 DB	'id', 00H
	ORG $+1
$SG200036 DB	'name', 00H
	ORG $+3
$SG200039 DB	'intro', 00H
	ORG $+2
$SG200042 DB	'pic', 00H
$SG200045 DB	'swf', 00H
$SG200048 DB	'lastplaytime', 00H
	ORG $+3
$SG200051 DB	'playcount', 00H
	ORG $+2
$SG200054 DB	'type', 00H
	ORG $+3
$SG200057 DB	'MD5', 00H
$SG200058 DB	'id', 00H
	ORG $+1
$SG200059 DB	'name', 00H
	ORG $+3
$SG200060 DB	'intro', 00H
	ORG $+2
$SG200061 DB	'pic', 00H
$SG200062 DB	'swf', 00H
$SG200063 DB	'lastplaytime', 00H
	ORG $+3
$SG200064 DB	'playcount', 00H
	ORG $+2
$SG200065 DB	'type', 00H
	ORG $+3
$SG200066 DB	'MD5', 00H
$SG200072 DB	'm_strDataFilePath:%s', 00H
	ORG $+3
$SG200073 DB	'LoadGameData', 00H
	ORG $+3
$SG200074 DB	'LocalGameData.txt', 00H
	ORG $+2
$SG200079 DB	'CMarkupArchive::Open success', 00H
	ORG $+3
$SG200080 DB	'LoadGameData', 00H
	ORG $+3
$SG200081 DB	'LocalGameData.txt', 00H
	ORG $+2
$SG200088 DB	'Id', 00H
	ORG $+1
$SG200090 DB	'Name', 00H
	ORG $+3
$SG200092 DB	'Intro', 00H
	ORG $+2
$SG200094 DB	'Img', 00H
$SG200096 DB	'AppPath', 00H
$SG200100 DB	0ceH, 0c4H, 0bcH, 0feH, 0b4H, 0e6H, 0d4H, 0daH, ':%s', 00H
$SG200101 DB	'LoadGameData', 00H
	ORG $+3
$SG200102 DB	'LocalGameData.txt', 00H
	ORG $+2
$SG200106 DB	0ceH, 0c4H, 0bcH, 0feH, 0b2H, 0bbH, 0b4H, 0e6H, 0d4H, 0daH
	DB	':%s', 00H
	ORG $+2
$SG200107 DB	'LoadGameData', 00H
	ORG $+3
$SG200108 DB	'LocalGameData.txt', 00H
	ORG $+2
$SG200116 DB	'.1', 00H
	ORG $+1
$SG200118 DB	'<?xml version="1.0" encoding="GBK"?><root/>', 00H
$SG200245 DB	'app', 00H
$SG200246 DB	'Id', 00H
	ORG $+1
$SG200247 DB	'Name', 00H
	ORG $+3
$SG200248 DB	'Intro', 00H
	ORG $+2
$SG200249 DB	'Img', 00H
$SG200250 DB	'AppPath', 00H
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT
?_strthunks@ATL@@3U_AtlStringThunks@1@A DD FLAT:?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ; ATL::_strthunks
	DD	FLAT:?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
	DD	FLAT:?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
	DD	FLAT:?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_DATA	ENDS
CONST	SEGMENT
_ID_MESSAGE_QQ_ITEM_CHANGE DD 0eH
CONST	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -160						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

  00011	c7 85 60 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _ver$[ebp], 148 ; 00000094H

; 139  : 	::GetVersionEx( &ver );

  0001b	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _ver$[ebp]
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00028	83 bd 70 ff ff
	ff 02		 cmp	 DWORD PTR _ver$[ebp+16], 2
  0002f	75 15		 jne	 SHORT $L24173
  00031	83 bd 64 ff ff
	ff 05		 cmp	 DWORD PTR _ver$[ebp+4], 5
  00038	72 0c		 jb	 SHORT $L24173

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  0003a	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

  00044	eb 0a		 jmp	 SHORT $L24174
$L24173:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00046	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L24174:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  00050	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pfnGetThreadACP$[ebp]
  00056	51		 push	 ecx
  00057	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0005c	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pNew$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pp$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 93   : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$24161 = -24					; size = 4
_lcidThread$ = -20					; size = 4
_szACP$ = -16						; size = 7
__$ArrayPad$ = -8					; size = 4
_nACP$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0
  0001b	89 45 ec	 mov	 DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  0001e	6a 07		 push	 7
  00020	8d 45 f0	 lea	 eax, DWORD PTR _szACP$[ebp]
  00023	50		 push	 eax
  00024	68 04 10 00 00	 push	 4100			; 00001004H
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _lcidThread$[ebp]
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00033	85 c0		 test	 eax, eax
  00035	74 34		 je	 SHORT $L24160

; 111  : 	{
; 112  : 		char* pch = szACP;

  00037	8d 55 f0	 lea	 edx, DWORD PTR _szACP$[ebp]
  0003a	89 55 e8	 mov	 DWORD PTR _pch$24161[ebp], edx
$L24163:

; 113  : 		while (*pch != '\0')

  0003d	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00040	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00043	85 c9		 test	 ecx, ecx
  00045	74 24		 je	 SHORT $L24160

; 114  : 		{
; 115  : 			nACP *= 10;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  0004a	6b d2 0a	 imul	 edx, 10			; 0000000aH
  0004d	89 55 fc	 mov	 DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

  00050	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  00059	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  0005d	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
  00060	8b 4d e8	 mov	 ecx, DWORD PTR _pch$24161[ebp]
  00063	83 c1 01	 add	 ecx, 1
  00066	89 4d e8	 mov	 DWORD PTR _pch$24161[ebp], ecx

; 117  : 		}

  00069	eb d2		 jmp	 SHORT $L24163
$L24160:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  0006b	83 7d fc 00	 cmp	 DWORD PTR _nACP$[ebp], 0
  0006f	75 09		 jne	 SHORT $L24165

; 121  : 		nACP = ::GetACP();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  00077	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
$L24165:

; 122  : 
; 123  : 	return nACP;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _nACP$[ebp]

; 124  : }

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  : 	return( CP_THREAD_ACP );

  00003	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
PUBLIC	?GetInstance@LocalGameData@@SAPAVIData@@XZ	; LocalGameData::GetInstance
PUBLIC	??0LocalGameData@@QAE@XZ			; LocalGameData::LocalGameData
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T202565 DD	0ffffffffH
	DD	FLAT:$L202558
$T202562 DD	019930520H
	DD	01H
	DD	FLAT:$T202565
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\httpdown\localgamedata.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv72 = -24						; size = 4
$T202555 = -20						; size = 4
$T202554 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?GetInstance@LocalGameData@@SAPAVIData@@XZ PROC NEAR	; LocalGameData::GetInstance

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetInstance@LocalGameData@@SAPAVIData@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 16   : 	if(m_pData == NULL)

  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pData@LocalGameData@@2PAV1@A, 0 ; LocalGameData::m_pData
  00022	75 44		 jne	 SHORT $L199977

; 17   : 		m_pData = new LocalGameData();

  00024	6a 30		 push	 48			; 00000030H
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 45 ec	 mov	 DWORD PTR $T202555[ebp], eax
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	83 7d ec 00	 cmp	 DWORD PTR $T202555[ebp], 0
  0003c	74 0d		 je	 SHORT $L202556
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR $T202555[ebp]
  00041	e8 00 00 00 00	 call	 ??0LocalGameData@@QAE@XZ
  00046	89 45 e8	 mov	 DWORD PTR tv72[ebp], eax
  00049	eb 07		 jmp	 SHORT $L202557
$L202556:
  0004b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L202557:
  00052	8b 45 e8	 mov	 eax, DWORD PTR tv72[ebp]
  00055	89 45 f0	 mov	 DWORD PTR $T202554[ebp], eax
  00058	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR $T202554[ebp]
  00062	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_pData@LocalGameData@@2PAV1@A, ecx ; LocalGameData::m_pData
$L199977:

; 18   : 	return m_pData;

  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pData@LocalGameData@@2PAV1@A ; LocalGameData::m_pData

; 19   : }

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202558:
  00000	8b 45 ec	 mov	 eax, DWORD PTR $T202555[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?GetInstance@LocalGameData@@SAPAVIData@@XZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202562
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetInstance@LocalGameData@@SAPAVIData@@XZ ENDP		; LocalGameData::GetInstance
PUBLIC	?DataAppStart@LocalGameData@@UAEXXZ		; LocalGameData::DataAppStart
PUBLIC	?DataAppExit@LocalGameData@@UAEXXZ		; LocalGameData::DataAppExit
PUBLIC	?ILocalGameData_GetGameByID@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAUOneLocalGame@@@Z ; LocalGameData::ILocalGameData_GetGameByID
PUBLIC	?ILocalGameData_AddGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0000I0@Z ; LocalGameData::ILocalGameData_AddGame
PUBLIC	?ILocalGameData_DelGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; LocalGameData::ILocalGameData_DelGame
PUBLIC	?ILocalGameData_GetAllGame@LocalGameData@@UAE_NAAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@Z ; LocalGameData::ILocalGameData_GetAllGame
PUBLIC	?ILocalGameData_GetGameCount@LocalGameData@@UAEIXZ ; LocalGameData::ILocalGameData_GetGameCount
PUBLIC	??_7LocalGameData@@6B@				; LocalGameData::`vftable'
PUBLIC	??_GLocalGameData@@UAEPAXI@Z			; LocalGameData::`scalar deleting destructor'
PUBLIC	??_R0?AVILocalGameData@@@8			; ILocalGameData `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@ILocalGameData@@8			; ILocalGameData::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@IData@@8				; IData::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVIData@@@8				; IData `RTTI Type Descriptor'
PUBLIC	??_R4LocalGameData@@6B@				; LocalGameData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVLocalGameData@@@8			; LocalGameData `RTTI Type Descriptor'
PUBLIC	??_R3LocalGameData@@8				; LocalGameData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2LocalGameData@@8				; LocalGameData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@LocalGameData@@8			; LocalGameData::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0ILocalGameData@@QAE@XZ			; ILocalGameData::ILocalGameData
PUBLIC	??1ILocalGameData@@UAE@XZ			; ILocalGameData::~ILocalGameData
PUBLIC	??0?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::vector<OneLocalGame,std::allocator<OneLocalGame> >
PUBLIC	??1?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::~vector<OneLocalGame,std::allocator<OneLocalGame> >
EXTRN	??_ELocalGameData@@UAEPAXI@Z:NEAR		; LocalGameData::`vector deleting destructor'
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202574 DD	0ffffffffH
	DD	FLAT:$L202568
	DD	00H
	DD	FLAT:$L202569
$T202572 DD	019930520H
	DD	02H
	DD	FLAT:$T202574
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7LocalGameData@@6B@
CONST	SEGMENT
??_7LocalGameData@@6B@ DD FLAT:??_R4LocalGameData@@6B@	; LocalGameData::`vftable'
	DD	FLAT:??_ELocalGameData@@UAEPAXI@Z
	DD	FLAT:?DataAppStart@LocalGameData@@UAEXXZ
	DD	FLAT:?DataAppExit@LocalGameData@@UAEXXZ
	DD	FLAT:?ILocalGameData_GetGameByID@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAUOneLocalGame@@@Z
	DD	FLAT:?ILocalGameData_AddGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0000I0@Z
	DD	FLAT:?ILocalGameData_DelGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?ILocalGameData_GetAllGame@LocalGameData@@UAE_NAAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@Z
	DD	FLAT:?ILocalGameData_GetGameCount@LocalGameData@@UAEIXZ
CONST	ENDS
;	COMDAT ??_R4LocalGameData@@6B@
rdata$r	SEGMENT
??_R4LocalGameData@@6B@ DD 00H				; LocalGameData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVLocalGameData@@@8
	DD	FLAT:??_R3LocalGameData@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVLocalGameData@@@8
_DATA	SEGMENT
??_R0?AVLocalGameData@@@8 DD FLAT:??_7type_info@@6B@	; LocalGameData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVLocalGameData@@', 00H
_DATA	ENDS
;	COMDAT ??_R3LocalGameData@@8
rdata$r	SEGMENT
??_R3LocalGameData@@8 DD 00H				; LocalGameData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2LocalGameData@@8
rdata$r	ENDS
;	COMDAT ??_R2LocalGameData@@8
rdata$r	SEGMENT
??_R2LocalGameData@@8 DD FLAT:??_R1A@?0A@A@LocalGameData@@8 ; LocalGameData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@ILocalGameData@@8
	DD	FLAT:??_R1A@?0A@A@IData@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@LocalGameData@@8
rdata$r	SEGMENT
??_R1A@?0A@A@LocalGameData@@8 DD FLAT:??_R0?AVLocalGameData@@@8 ; LocalGameData::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ILocalGameData@@8
rdata$r	SEGMENT
??_R1A@?0A@A@ILocalGameData@@8 DD FLAT:??_R0?AVILocalGameData@@@8 ; ILocalGameData::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVILocalGameData@@@8
_DATA	SEGMENT
??_R0?AVILocalGameData@@@8 DD FLAT:??_7type_info@@6B@	; ILocalGameData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVILocalGameData@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@IData@@8
rdata$r	SEGMENT
??_R1A@?0A@A@IData@@8 DD FLAT:??_R0?AVIData@@@8		; IData::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVIData@@@8
_DATA	SEGMENT
??_R0?AVIData@@@8 DD FLAT:??_7type_info@@6B@		; IData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIData@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0LocalGameData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0LocalGameData@@QAE@XZ PROC NEAR			; LocalGameData::LocalGameData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0LocalGameData@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0ILocalGameData@@QAE@XZ
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7LocalGameData@@6B@
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 04	 add	 ecx, 4
  0003a	e8 00 00 00 00	 call	 ??0?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::vector<OneLocalGame,std::allocator<OneLocalGame> >
  0003f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 14	 add	 ecx, 20			; 00000014H
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0004f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202568:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ILocalGameData@@UAE@XZ
$L202569:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::~vector<OneLocalGame,std::allocator<OneLocalGame> >
__ehhandler$??0LocalGameData@@QAE@XZ:
  00013	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202572
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0LocalGameData@@QAE@XZ ENDP				; LocalGameData::LocalGameData
PUBLIC	??1LocalGameData@@UAE@XZ			; LocalGameData::~LocalGameData
; Function compile flags: /Odt
;	COMDAT ??_GLocalGameData@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GLocalGameData@@UAEPAXI@Z PROC NEAR			; LocalGameData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1LocalGameData@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L199987
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L199987:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GLocalGameData@@UAEPAXI@Z ENDP			; LocalGameData::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4ILocalGameData@@6B@			; ILocalGameData::`RTTI Complete Object Locator'
PUBLIC	??_R3ILocalGameData@@8				; ILocalGameData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ILocalGameData@@8				; ILocalGameData::`RTTI Base Class Array'
PUBLIC	?DataAppStart@IData@@UAEXXZ			; IData::DataAppStart
PUBLIC	?DataAppExit@IData@@UAEXXZ			; IData::DataAppExit
PUBLIC	??0IData@@QAE@XZ				; IData::IData
PUBLIC	??_7ILocalGameData@@6B@				; ILocalGameData::`vftable'
PUBLIC	??_GILocalGameData@@UAEPAXI@Z			; ILocalGameData::`scalar deleting destructor'
EXTRN	__purecall:NEAR
EXTRN	??_EILocalGameData@@UAEPAXI@Z:NEAR		; ILocalGameData::`vector deleting destructor'
;	COMDAT ??_7ILocalGameData@@6B@
CONST	SEGMENT
??_7ILocalGameData@@6B@ DD FLAT:??_R4ILocalGameData@@6B@ ; ILocalGameData::`vftable'
	DD	FLAT:??_EILocalGameData@@UAEPAXI@Z
	DD	FLAT:?DataAppStart@IData@@UAEXXZ
	DD	FLAT:?DataAppExit@IData@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4ILocalGameData@@6B@
rdata$r	SEGMENT
??_R4ILocalGameData@@6B@ DD 00H				; ILocalGameData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVILocalGameData@@@8
	DD	FLAT:??_R3ILocalGameData@@8
rdata$r	ENDS
;	COMDAT ??_R3ILocalGameData@@8
rdata$r	SEGMENT
??_R3ILocalGameData@@8 DD 00H				; ILocalGameData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ILocalGameData@@8
rdata$r	ENDS
;	COMDAT ??_R2ILocalGameData@@8
rdata$r	SEGMENT
??_R2ILocalGameData@@8 DD FLAT:??_R1A@?0A@A@ILocalGameData@@8 ; ILocalGameData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@IData@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0ILocalGameData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ILocalGameData@@QAE@XZ PROC NEAR			; ILocalGameData::ILocalGameData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IData@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ILocalGameData@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0ILocalGameData@@QAE@XZ ENDP				; ILocalGameData::ILocalGameData
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\datainterface\idata.h
_TEXT	ENDS
;	COMDAT ?DataAppStart@IData@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DataAppStart@IData@@UAEXXZ PROC NEAR			; IData::DataAppStart, COMDAT
; _this$ = ecx

; 15   : 	virtual void	DataAppStart(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?DataAppStart@IData@@UAEXXZ ENDP			; IData::DataAppStart
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?DataAppExit@IData@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DataAppExit@IData@@UAEXXZ PROC NEAR			; IData::DataAppExit, COMDAT
; _this$ = ecx

; 18   : 	virtual void	DataAppExit(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?DataAppExit@IData@@UAEXXZ ENDP				; IData::DataAppExit
_TEXT	ENDS
PUBLIC	??1IData@@MAE@XZ				; IData::~IData
; Function compile flags: /Odt
;	COMDAT ??1ILocalGameData@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ILocalGameData@@UAE@XZ PROC NEAR			; ILocalGameData::~ILocalGameData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1IData@@MAE@XZ	; IData::~IData
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1ILocalGameData@@UAE@XZ ENDP				; ILocalGameData::~ILocalGameData
_TEXT	ENDS
PUBLIC	??_R4IData@@6B@					; IData::`RTTI Complete Object Locator'
PUBLIC	??_R3IData@@8					; IData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IData@@8					; IData::`RTTI Base Class Array'
PUBLIC	??_7IData@@6B@					; IData::`vftable'
PUBLIC	??_GIData@@MAEPAXI@Z				; IData::`scalar deleting destructor'
EXTRN	??_EIData@@MAEPAXI@Z:NEAR			; IData::`vector deleting destructor'
;	COMDAT ??_7IData@@6B@
CONST	SEGMENT
??_7IData@@6B@ DD FLAT:??_R4IData@@6B@			; IData::`vftable'
	DD	FLAT:??_EIData@@MAEPAXI@Z
	DD	FLAT:?DataAppStart@IData@@UAEXXZ
	DD	FLAT:?DataAppExit@IData@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4IData@@6B@
rdata$r	SEGMENT
??_R4IData@@6B@ DD 00H					; IData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIData@@@8
	DD	FLAT:??_R3IData@@8
rdata$r	ENDS
;	COMDAT ??_R3IData@@8
rdata$r	SEGMENT
??_R3IData@@8 DD 00H					; IData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IData@@8
rdata$r	ENDS
;	COMDAT ??_R2IData@@8
rdata$r	SEGMENT
??_R2IData@@8 DD FLAT:??_R1A@?0A@A@IData@@8		; IData::`RTTI Base Class Array'
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??1IData@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1IData@@MAE@XZ PROC NEAR				; IData::~IData, COMDAT
; _this$ = ecx

; 10   : 	virtual ~IData(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IData@@6B@
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1IData@@MAE@XZ ENDP					; IData::~IData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GIData@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIData@@MAEPAXI@Z PROC NEAR				; IData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1IData@@MAE@XZ	; IData::~IData
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L197393
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L197393:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GIData@@MAEPAXI@Z ENDP				; IData::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202600 DD	0ffffffffH
	DD	FLAT:$L202594
	DD	00H
	DD	FLAT:$L202595
$T202598 DD	019930520H
	DD	02H
	DD	FLAT:$T202600
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1LocalGameData@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1LocalGameData@@UAE@XZ PROC NEAR			; LocalGameData::~LocalGameData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1LocalGameData@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 14	 add	 ecx, 20			; 00000014H
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00033	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	83 c1 04	 add	 ecx, 4
  00039	e8 00 00 00 00	 call	 ??1?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::~vector<OneLocalGame,std::allocator<OneLocalGame> >
  0003e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ??1ILocalGameData@@UAE@XZ
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202594:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ILocalGameData@@UAE@XZ
$L202595:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::~vector<OneLocalGame,std::allocator<OneLocalGame> >
__ehhandler$??1LocalGameData@@UAE@XZ:
  00013	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202598
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1LocalGameData@@UAE@XZ ENDP				; LocalGameData::~LocalGameData
; Function compile flags: /Odt
;	COMDAT ??_GILocalGameData@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GILocalGameData@@UAEPAXI@Z PROC NEAR			; ILocalGameData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1ILocalGameData@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L199997
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L199997:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GILocalGameData@@UAEPAXI@Z ENDP			; ILocalGameData::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IData@@QAE@XZ PROC NEAR				; IData::IData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IData@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0IData@@QAE@XZ ENDP					; IData::IData
_TEXT	ENDS
PUBLIC	?DelInstance@LocalGameData@@SAXXZ		; LocalGameData::DelInstance
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\httpdown\localgamedata.cpp
_TEXT	SEGMENT
tv71 = -12						; size = 4
$T202610 = -8						; size = 4
$T202609 = -4						; size = 4
?DelInstance@LocalGameData@@SAXXZ PROC NEAR		; LocalGameData::DelInstance

; 22   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 23   : 	if(m_pData != NULL)

  00086	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pData@LocalGameData@@2PAV1@A, 0 ; LocalGameData::m_pData
  0008d	74 2c		 je	 SHORT $L200002

; 24   : 		delete m_pData;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pData@LocalGameData@@2PAV1@A ; LocalGameData::m_pData
  00094	89 45 f8	 mov	 DWORD PTR $T202610[ebp], eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR $T202610[ebp]
  0009a	89 4d fc	 mov	 DWORD PTR $T202609[ebp], ecx
  0009d	83 7d fc 00	 cmp	 DWORD PTR $T202609[ebp], 0
  000a1	74 11		 je	 SHORT $L202611
  000a3	6a 01		 push	 1
  000a5	8b 55 fc	 mov	 edx, DWORD PTR $T202609[ebp]
  000a8	8b 02		 mov	 eax, DWORD PTR [edx]
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR $T202609[ebp]
  000ad	ff 10		 call	 DWORD PTR [eax]
  000af	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  000b2	eb 07		 jmp	 SHORT $L200002
$L202611:
  000b4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L200002:

; 25   : 	m_pData = NULL;

  000bb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_pData@LocalGameData@@2PAV1@A, 0 ; LocalGameData::m_pData

; 26   : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
?DelInstance@LocalGameData@@SAXXZ ENDP			; LocalGameData::DelInstance
_TEXT	ENDS
PUBLIC	?LoadGameData@LocalGameData@@AAEXXZ		; LocalGameData::LoadGameData
EXTRN	?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ:NEAR ; YL_StringUtil::Format
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
EXTRN	__imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	?GetHomePath@CLhcImg@@SA_NQADH@Z:NEAR		; CLhcImg::GetHomePath
xdata$x	SEGMENT
$T202623 DD	0ffffffffH
	DD	FLAT:$L202617
	DD	00H
	DD	FLAT:$L202618
$T202620 DD	019930520H
	DD	02H
	DD	FLAT:$T202623
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -344						; size = 4
$T202616 = -340						; size = 28
$T202615 = -312						; size = 28
_szHomePath$ = -284					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?DataAppStart@LocalGameData@@UAEXXZ PROC NEAR		; LocalGameData::DataAppStart
; _this$ = ecx

; 29   : {

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	6a ff		 push	 -1
  000d5	68 00 00 00 00	 push	 __ehhandler$?DataAppStart@LocalGameData@@UAEXXZ
  000da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  000e0	50		 push	 eax
  000e1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  000e8	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  000ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000f3	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  000f6	89 8d a8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 30   : 	char szHomePath[MAX_PATH];
; 31   : 	CLhcImg::GetHomePath( szHomePath, MAX_PATH );

  000fc	68 04 01 00 00	 push	 260			; 00000104H
  00101	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _szHomePath$[ebp]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 ?GetHomePath@CLhcImg@@SA_NQADH@Z ; CLhcImg::GetHomePath
  0010d	83 c4 08	 add	 esp, 8

; 32   : 
; 33   : 	YL_StringUtil::Format( m_strDataFilePath, "%s\\Resources\\Profiles\\usergame.xml", szHomePath );

  00110	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _szHomePath$[ebp]
  00116	51		 push	 ecx
  00117	68 00 00 00 00	 push	 OFFSET FLAT:$SG200009
  0011c	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00122	83 c2 14	 add	 edx, 20			; 00000014H
  00125	52		 push	 edx
  00126	e8 00 00 00 00	 call	 ?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; YL_StringUtil::Format
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 34   : 	YL_Log( "LocalGameData.txt", LOG_DEBUG, "DataAppStart",	"m_strDataFilePath:%s", m_strDataFilePath.c_str() );

  0012e	68 00 00 00 00	 push	 OFFSET FLAT:$SG200013
  00133	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T202615[ebp]
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0013f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00146	68 00 00 00 00	 push	 OFFSET FLAT:$SG200014
  0014b	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR $T202616[ebp]
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00157	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0015b	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00161	83 c1 14	 add	 ecx, 20			; 00000014H
  00164	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0016a	50		 push	 eax
  0016b	68 00 00 00 00	 push	 OFFSET FLAT:$SG200012
  00170	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T202615[ebp]
  00176	50		 push	 eax
  00177	6a 00		 push	 0
  00179	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR $T202616[ebp]
  0017f	51		 push	 ecx
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00186	83 c4 14	 add	 esp, 20			; 00000014H
  00189	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0018d	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR $T202616[ebp]
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00199	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001a0	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T202615[ebp]
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 35   : 
; 36   : 	LoadGameData();

  001ac	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001b2	e8 00 00 00 00	 call	 ?LoadGameData@LocalGameData@@AAEXXZ ; LocalGameData::LoadGameData

; 37   : }

  001b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202617:
  00015	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T202615[ebp]
  0001b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202618:
  00021	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR $T202616[ebp]
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?DataAppStart@LocalGameData@@UAEXXZ:
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202620
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DataAppStart@LocalGameData@@UAEXXZ ENDP		; LocalGameData::DataAppStart
PUBLIC	?UnLoadGameData@LocalGameData@@AAEXXZ		; LocalGameData::UnLoadGameData
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DataAppExit@LocalGameData@@UAEXXZ PROC NEAR		; LocalGameData::DataAppExit
; _this$ = ecx

; 40   : {

  001d0	55		 push	 ebp
  001d1	8b ec		 mov	 ebp, esp
  001d3	51		 push	 ecx
  001d4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 	UnLoadGameData();

  001d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001da	e8 00 00 00 00	 call	 ?UnLoadGameData@LocalGameData@@AAEXXZ ; LocalGameData::UnLoadGameData

; 42   : }

  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c3		 ret	 0
?DataAppExit@LocalGameData@@UAEXXZ ENDP			; LocalGameData::DataAppExit
_TEXT	ENDS
PUBLIC	?clear@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::clear
PUBLIC	??0CMarkupArchive@@QAE@K@Z			; CMarkupArchive::CMarkupArchive
PUBLIC	?FindElem@CMarkupArchive@@UAE_NPBD@Z		; CMarkupArchive::FindElem
PUBLIC	?FindChildElem@CMarkupArchive@@UAE_NPBD@Z	; CMarkupArchive::FindChildElem
PUBLIC	??0OneLocalGame@@QAE@XZ				; OneLocalGame::OneLocalGame
PUBLIC	??1OneLocalGame@@QAE@XZ				; OneLocalGame::~OneLocalGame
PUBLIC	?ResetPos@CMarkup@@QAEXXZ			; CMarkup::ResetPos
PUBLIC	?GetAttrib@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CMarkup::GetAttrib
PUBLIC	?push_back@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXABUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::push_back
EXTRN	__imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:NEAR
EXTRN	??1CMarkupArchive@@UAE@XZ:NEAR			; CMarkupArchive::~CMarkupArchive
EXTRN	?Open@CMarkupArchive@@QAE_NPBD@Z:NEAR		; CMarkupArchive::Open
EXTRN	?Close@CMarkupArchive@@QAE_NXZ:NEAR		; CMarkupArchive::Close
EXTRN	?IsValid@YL_FileInfo@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:NEAR ; YL_FileInfo::IsValid
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	?IntoElem@CMarkup@@QAE_NXZ:NEAR			; CMarkup::IntoElem
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
xdata$x	SEGMENT
$T202659 DD	0ffffffffH
	DD	FLAT:$L202640
	DD	00H
	DD	FLAT:$L202641
	DD	0ffffffffH
	DD	FLAT:$L202642
	DD	02H
	DD	FLAT:$L202643
	DD	03H
	DD	FLAT:$L202644
	DD	02H
	DD	FLAT:$L202645
	DD	05H
	DD	FLAT:$L202646
	DD	05H
	DD	FLAT:$L202647
	DD	05H
	DD	FLAT:$L202648
	DD	05H
	DD	FLAT:$L202649
	DD	05H
	DD	FLAT:$L202650
	DD	05H
	DD	FLAT:$L202651
	DD	0bH
	DD	FLAT:$L202652
	DD	05H
	DD	FLAT:$L202653
	DD	0dH
	DD	FLAT:$L202654
$T202656 DD	019930520H
	DD	0fH
	DD	FLAT:$T202659
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv256 = -796						; size = 4
tv78 = -792						; size = 4
tv254 = -788						; size = 4
tv83 = -784						; size = 4
tv252 = -780						; size = 4
tv128 = -776						; size = 4
tv250 = -772						; size = 4
tv134 = -768						; size = 4
tv248 = -764						; size = 4
tv150 = -760						; size = 4
_this$ = -756						; size = 4
$T202639 = -752						; size = 28
$T202638 = -724						; size = 28
$T202637 = -696						; size = 28
$T202636 = -668						; size = 28
$T202635 = -640						; size = 4
$T202634 = -636						; size = 4
$T202633 = -632						; size = 4
$T202632 = -628						; size = 4
$T202631 = -624						; size = 4
$T202630 = -620						; size = 28
$T202629 = -592						; size = 28
$T202628 = -564						; size = 28
$T202627 = -536						; size = 28
_olg$200086 = -508					; size = 144
_xml$ = -364						; size = 76
_szHomePath$ = -284					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?LoadGameData@LocalGameData@@AAEXXZ PROC NEAR		; LocalGameData::LoadGameData
; _this$ = ecx

; 97   : {

  001f0	55		 push	 ebp
  001f1	8b ec		 mov	 ebp, esp
  001f3	6a ff		 push	 -1
  001f5	68 00 00 00 00	 push	 __ehhandler$?LoadGameData@LocalGameData@@AAEXXZ
  001fa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00200	50		 push	 eax
  00201	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00208	81 ec 10 03 00
	00		 sub	 esp, 784		; 00000310H
  0020e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00213	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00216	89 8d 0c fd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 98   : 	m_vecGame.clear();

  0021c	8b 8d 0c fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00222	83 c1 04	 add	 ecx, 4
  00225	e8 00 00 00 00	 call	 ?clear@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::clear

; 99   : 	YL_Log( "LocalGameData.txt", LOG_DEBUG, "LoadGameData","m_strDataFilePath:%s", m_strDataFilePath.c_str() );

  0022a	68 00 00 00 00	 push	 OFFSET FLAT:$SG200073
  0022f	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T202627[ebp]
  00235	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0023b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00242	68 00 00 00 00	 push	 OFFSET FLAT:$SG200074
  00247	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR $T202628[ebp]
  0024d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00253	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00257	8b 8d 0c fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0025d	83 c1 14	 add	 ecx, 20			; 00000014H
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00266	50		 push	 eax
  00267	68 00 00 00 00	 push	 OFFSET FLAT:$SG200072
  0026c	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T202627[ebp]
  00272	50		 push	 eax
  00273	6a 00		 push	 0
  00275	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR $T202628[ebp]
  0027b	51		 push	 ecx
  0027c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00282	83 c4 14	 add	 esp, 20			; 00000014H
  00285	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00289	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR $T202628[ebp]
  0028f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00295	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0029c	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T202627[ebp]
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 100  : 
; 101  : 	CMarkupArchive xml;

  002a8	6a 03		 push	 3
  002aa	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  002b0	e8 00 00 00 00	 call	 ??0CMarkupArchive@@QAE@K@Z ; CMarkupArchive::CMarkupArchive
  002b5	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 102  : 	if( !xml.Open(m_strDataFilePath.c_str()) )

  002bc	8b 8d 0c fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002c2	83 c1 14	 add	 ecx, 20			; 00000014H
  002c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  002cb	50		 push	 eax
  002cc	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  002d2	e8 00 00 00 00	 call	 ?Open@CMarkupArchive@@QAE_NPBD@Z ; CMarkupArchive::Open
  002d7	0f b6 d0	 movzx	 edx, al
  002da	85 d2		 test	 edx, edx
  002dc	75 17		 jne	 SHORT $L200076

; 103  : 		return;

  002de	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002e5	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  002eb	e8 00 00 00 00	 call	 ??1CMarkupArchive@@UAE@XZ ; CMarkupArchive::~CMarkupArchive
  002f0	e9 c0 03 00 00	 jmp	 $L200069
$L200076:

; 104  : 
; 105  : 	YL_Log( "LocalGameData.txt", LOG_DEBUG, "LoadGameData","CMarkupArchive::Open success" );

  002f5	68 00 00 00 00	 push	 OFFSET FLAT:$SG200080
  002fa	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR $T202629[ebp]
  00300	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00306	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0030a	68 00 00 00 00	 push	 OFFSET FLAT:$SG200081
  0030f	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T202630[ebp]
  00315	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0031b	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0031f	68 00 00 00 00	 push	 OFFSET FLAT:$SG200079
  00324	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR $T202629[ebp]
  0032a	50		 push	 eax
  0032b	6a 00		 push	 0
  0032d	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T202630[ebp]
  00333	51		 push	 ecx
  00334	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  0033a	83 c4 10	 add	 esp, 16			; 00000010H
  0033d	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00341	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T202630[ebp]
  00347	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0034d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00351	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR $T202629[ebp]
  00357	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 106  : 
; 107  : 	char szHomePath[MAX_PATH];
; 108  : 	CLhcImg::GetHomePath( szHomePath, MAX_PATH );

  0035d	68 04 01 00 00	 push	 260			; 00000104H
  00362	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _szHomePath$[ebp]
  00368	52		 push	 edx
  00369	e8 00 00 00 00	 call	 ?GetHomePath@CLhcImg@@SA_NQADH@Z ; CLhcImg::GetHomePath
  0036e	83 c4 08	 add	 esp, 8

; 109  : 
; 110  : 	xml.ResetPos();

  00371	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00377	e8 00 00 00 00	 call	 ?ResetPos@CMarkup@@QAEXXZ ; CMarkup::ResetPos

; 111  : 	xml.FindElem();

  0037c	6a 00		 push	 0
  0037e	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00384	e8 00 00 00 00	 call	 ?FindElem@CMarkupArchive@@UAE_NPBD@Z ; CMarkupArchive::FindElem

; 112  : 	xml.IntoElem();

  00389	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  0038f	e8 00 00 00 00	 call	 ?IntoElem@CMarkup@@QAE_NXZ ; CMarkup::IntoElem
$L200084:

; 113  : 
; 114  : 	while( xml.FindChildElem() )

  00394	6a 00		 push	 0
  00396	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  0039c	e8 00 00 00 00	 call	 ?FindChildElem@CMarkupArchive@@UAE_NPBD@Z ; CMarkupArchive::FindChildElem
  003a1	0f b6 c0	 movzx	 eax, al
  003a4	85 c0		 test	 eax, eax
  003a6	0f 84 ec 02 00
	00		 je	 $L200085

; 115  : 	{
; 116  : 		OneLocalGame olg;

  003ac	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _olg$200086[ebp]
  003b2	e8 00 00 00 00	 call	 ??0OneLocalGame@@QAE@XZ	; OneLocalGame::OneLocalGame
  003b7	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 117  : 		olg.strID    = xml.GetAttrib( "Id" );

  003bb	68 00 00 00 00	 push	 OFFSET FLAT:$SG200088
  003c0	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR $T202631[ebp]
  003c6	51		 push	 ecx
  003c7	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  003cd	e8 00 00 00 00	 call	 ?GetAttrib@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CMarkup::GetAttrib
  003d2	89 85 08 fd ff
	ff		 mov	 DWORD PTR tv150[ebp], eax
  003d8	8b 95 08 fd ff
	ff		 mov	 edx, DWORD PTR tv150[ebp]
  003de	89 95 04 fd ff
	ff		 mov	 DWORD PTR tv248[ebp], edx
  003e4	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  003e8	8b 8d 04 fd ff
	ff		 mov	 ecx, DWORD PTR tv248[ebp]
  003ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  003f4	50		 push	 eax
  003f5	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _olg$200086[ebp]
  003fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  00401	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00405	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR $T202631[ebp]
  0040b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 118  : 		olg.strName  = xml.GetAttrib( "Name" );

  00411	68 00 00 00 00	 push	 OFFSET FLAT:$SG200090
  00416	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR $T202632[ebp]
  0041c	50		 push	 eax
  0041d	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00423	e8 00 00 00 00	 call	 ?GetAttrib@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CMarkup::GetAttrib
  00428	89 85 00 fd ff
	ff		 mov	 DWORD PTR tv134[ebp], eax
  0042e	8b 8d 00 fd ff
	ff		 mov	 ecx, DWORD PTR tv134[ebp]
  00434	89 8d fc fc ff
	ff		 mov	 DWORD PTR tv250[ebp], ecx
  0043a	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0043e	8b 8d fc fc ff
	ff		 mov	 ecx, DWORD PTR tv250[ebp]
  00444	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0044a	50		 push	 eax
  0044b	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _olg$200086[ebp+28]
  00451	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  00457	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0045b	8d 8d 8c fd ff
	ff		 lea	 ecx, DWORD PTR $T202632[ebp]
  00461	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 119  : 		olg.strIntro  = xml.GetAttrib( "Intro" );

  00467	68 00 00 00 00	 push	 OFFSET FLAT:$SG200092
  0046c	8d 95 88 fd ff
	ff		 lea	 edx, DWORD PTR $T202633[ebp]
  00472	52		 push	 edx
  00473	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00479	e8 00 00 00 00	 call	 ?GetAttrib@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CMarkup::GetAttrib
  0047e	89 85 f8 fc ff
	ff		 mov	 DWORD PTR tv128[ebp], eax
  00484	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR tv128[ebp]
  0048a	89 85 f4 fc ff
	ff		 mov	 DWORD PTR tv252[ebp], eax
  00490	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00494	8b 8d f4 fc ff
	ff		 mov	 ecx, DWORD PTR tv252[ebp]
  0049a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  004a0	50		 push	 eax
  004a1	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR _olg$200086[ebp+112]
  004a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  004ad	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  004b1	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T202633[ebp]
  004b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 120  : 		//YL_Log( "LocalGameData.txt", LOG_DEBUG, "LoadGameData","id:%s|name:%s|intro:%s",
; 121  : 		//	olg.strID.c_str(), olg.strName.c_str(), olg.strIntro.c_str() );
; 122  : 		olg.strPicPath = xml.GetAttrib( "Img" );

  004bd	68 00 00 00 00	 push	 OFFSET FLAT:$SG200094
  004c2	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T202634[ebp]
  004c8	51		 push	 ecx
  004c9	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  004cf	e8 00 00 00 00	 call	 ?GetAttrib@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CMarkup::GetAttrib
  004d4	89 85 f0 fc ff
	ff		 mov	 DWORD PTR tv83[ebp], eax
  004da	8b 95 f0 fc ff
	ff		 mov	 edx, DWORD PTR tv83[ebp]
  004e0	89 95 ec fc ff
	ff		 mov	 DWORD PTR tv254[ebp], edx
  004e6	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  004ea	8b 8d ec fc ff
	ff		 mov	 ecx, DWORD PTR tv254[ebp]
  004f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  004f6	50		 push	 eax
  004f7	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _olg$200086[ebp+84]
  004fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  00503	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00507	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T202634[ebp]
  0050d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 123  : 		olg.strGamePath = xml.GetAttrib( "AppPath" );

  00513	68 00 00 00 00	 push	 OFFSET FLAT:$SG200096
  00518	8d 85 80 fd ff
	ff		 lea	 eax, DWORD PTR $T202635[ebp]
  0051e	50		 push	 eax
  0051f	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00525	e8 00 00 00 00	 call	 ?GetAttrib@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CMarkup::GetAttrib
  0052a	89 85 e8 fc ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  00530	8b 8d e8 fc ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  00536	89 8d e4 fc ff
	ff		 mov	 DWORD PTR tv256[ebp], ecx
  0053c	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00540	8b 8d e4 fc ff
	ff		 mov	 ecx, DWORD PTR tv256[ebp]
  00546	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0054c	50		 push	 eax
  0054d	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR _olg$200086[ebp+56]
  00553	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  00559	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0055d	8d 8d 80 fd ff
	ff		 lea	 ecx, DWORD PTR $T202635[ebp]
  00563	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 124  : 
; 125  : 		if( YL_FileInfo::IsValid( olg.strGamePath ) )

  00569	8d 95 3c fe ff
	ff		 lea	 edx, DWORD PTR _olg$200086[ebp+56]
  0056f	52		 push	 edx
  00570	e8 00 00 00 00	 call	 ?IsValid@YL_FileInfo@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_FileInfo::IsValid
  00575	83 c4 04	 add	 esp, 4
  00578	0f b6 c0	 movzx	 eax, al
  0057b	85 c0		 test	 eax, eax
  0057d	0f 84 8c 00 00
	00		 je	 $L200097

; 126  : 		{
; 127  : 			YL_Log( "LocalGameData.txt", LOG_DEBUG, "LoadGameData",":%s",
; 128  : 				olg.strGamePath.c_str() );

  00583	68 00 00 00 00	 push	 OFFSET FLAT:$SG200101
  00588	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR $T202636[ebp]
  0058e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00594	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00598	68 00 00 00 00	 push	 OFFSET FLAT:$SG200102
  0059d	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T202637[ebp]
  005a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  005a9	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  005ad	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR _olg$200086[ebp+56]
  005b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  005b9	50		 push	 eax
  005ba	68 00 00 00 00	 push	 OFFSET FLAT:$SG200100
  005bf	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR $T202636[ebp]
  005c5	51		 push	 ecx
  005c6	6a 00		 push	 0
  005c8	8d 95 48 fd ff
	ff		 lea	 edx, DWORD PTR $T202637[ebp]
  005ce	52		 push	 edx
  005cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  005d5	83 c4 14	 add	 esp, 20			; 00000014H
  005d8	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  005dc	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T202637[ebp]
  005e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  005e8	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  005ec	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR $T202636[ebp]
  005f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 129  : 
; 130  : 			m_vecGame.push_back( olg );

  005f8	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR _olg$200086[ebp]
  005fe	50		 push	 eax
  005ff	8b 8d 0c fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00605	83 c1 04	 add	 ecx, 4
  00608	e8 00 00 00 00	 call	 ?push_back@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXABUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::push_back

; 131  : 		}else

  0060d	eb 75		 jmp	 SHORT $L200103
$L200097:

; 132  : 		{
; 133  : 			YL_Log( "LocalGameData.txt", LOG_DEBUG, "LoadGameData",":%s",
; 134  : 				olg.strGamePath.c_str() );

  0060f	68 00 00 00 00	 push	 OFFSET FLAT:$SG200107
  00614	8d 8d 2c fd ff
	ff		 lea	 ecx, DWORD PTR $T202638[ebp]
  0061a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00620	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00624	68 00 00 00 00	 push	 OFFSET FLAT:$SG200108
  00629	8d 8d 10 fd ff
	ff		 lea	 ecx, DWORD PTR $T202639[ebp]
  0062f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00635	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00639	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR _olg$200086[ebp+56]
  0063f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00645	50		 push	 eax
  00646	68 00 00 00 00	 push	 OFFSET FLAT:$SG200106
  0064b	8d 8d 2c fd ff
	ff		 lea	 ecx, DWORD PTR $T202638[ebp]
  00651	51		 push	 ecx
  00652	6a 00		 push	 0
  00654	8d 95 10 fd ff
	ff		 lea	 edx, DWORD PTR $T202639[ebp]
  0065a	52		 push	 edx
  0065b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00661	83 c4 14	 add	 esp, 20			; 00000014H
  00664	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00668	8d 8d 10 fd ff
	ff		 lea	 ecx, DWORD PTR $T202639[ebp]
  0066e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00674	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00678	8d 8d 2c fd ff
	ff		 lea	 ecx, DWORD PTR $T202638[ebp]
  0067e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200103:

; 135  : 		}
; 136  : 	}

  00684	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00688	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _olg$200086[ebp]
  0068e	e8 00 00 00 00	 call	 ??1OneLocalGame@@QAE@XZ
  00693	e9 fc fc ff ff	 jmp	 $L200084
$L200085:

; 137  : 	xml.Close();

  00698	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  0069e	e8 00 00 00 00	 call	 ?Close@CMarkupArchive@@QAE_NXZ ; CMarkupArchive::Close

; 138  : }

  006a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  006aa	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  006b0	e8 00 00 00 00	 call	 ??1CMarkupArchive@@UAE@XZ ; CMarkupArchive::~CMarkupArchive
$L200069:
  006b5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006b8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  006bf	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006c7	8b e5		 mov	 esp, ebp
  006c9	5d		 pop	 ebp
  006ca	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202640:
  00037	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T202627[ebp]
  0003d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202641:
  00043	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR $T202628[ebp]
  00049	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202642:
  0004f	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00055	e9 00 00 00 00	 jmp	 ??1CMarkupArchive@@UAE@XZ ; CMarkupArchive::~CMarkupArchive
$L202643:
  0005a	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR $T202629[ebp]
  00060	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202644:
  00066	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T202630[ebp]
  0006c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202645:
  00072	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _olg$200086[ebp]
  00078	e9 00 00 00 00	 jmp	 ??1OneLocalGame@@QAE@XZ
$L202646:
  0007d	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR $T202631[ebp]
  00083	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L202647:
  00089	8d 8d 8c fd ff
	ff		 lea	 ecx, DWORD PTR $T202632[ebp]
  0008f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L202648:
  00095	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T202633[ebp]
  0009b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L202649:
  000a1	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T202634[ebp]
  000a7	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L202650:
  000ad	8d 8d 80 fd ff
	ff		 lea	 ecx, DWORD PTR $T202635[ebp]
  000b3	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L202651:
  000b9	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR $T202636[ebp]
  000bf	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202652:
  000c5	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T202637[ebp]
  000cb	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202653:
  000d1	8d 8d 2c fd ff
	ff		 lea	 ecx, DWORD PTR $T202638[ebp]
  000d7	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202654:
  000dd	8d 8d 10 fd ff
	ff		 lea	 ecx, DWORD PTR $T202639[ebp]
  000e3	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LoadGameData@LocalGameData@@AAEXXZ:
  000e9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202656
  000ee	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadGameData@LocalGameData@@AAEXXZ ENDP		; LocalGameData::LoadGameData
PUBLIC	?clear@OneLocalGame@@QAEXXZ			; OneLocalGame::clear
;	COMDAT xdata$x
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\datainterface\ilocalgamedata.h
xdata$x	SEGMENT
$T202669 DD	0ffffffffH
	DD	FLAT:$L202661
	DD	00H
	DD	FLAT:$L202662
	DD	01H
	DD	FLAT:$L202663
	DD	02H
	DD	FLAT:$L202664
	DD	03H
	DD	FLAT:$L202665
$T202667 DD	019930520H
	DD	05H
	DD	FLAT:$T202669
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0OneLocalGame@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0OneLocalGame@@QAE@XZ PROC NEAR			; OneLocalGame::OneLocalGame, COMDAT
; _this$ = ecx

; 20   : 	OneLocalGame()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0OneLocalGame@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 c1 38	 add	 ecx, 56			; 00000038H
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00048	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	83 c1 54	 add	 ecx, 84			; 00000054H
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00058	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	83 c1 70	 add	 ecx, 112		; 00000070H
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00068	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 21   : 	{
; 22   : 		clear();

  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?clear@OneLocalGame@@QAEXXZ ; OneLocalGame::clear

; 23   : 	}

  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202661:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202662:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0000f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202663:
  00015	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 38	 add	 ecx, 56			; 00000038H
  0001b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202664:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 54	 add	 ecx, 84			; 00000054H
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202665:
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 70	 add	 ecx, 112		; 00000070H
  00033	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0OneLocalGame@@QAE@XZ:
  00039	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202667
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0OneLocalGame@@QAE@XZ ENDP				; OneLocalGame::OneLocalGame
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ?clear@OneLocalGame@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@OneLocalGame@@QAEXXZ PROC NEAR			; OneLocalGame::clear, COMDAT
; _this$ = ecx

; 25   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 26   : 		strID.clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 27   : 		strName.clear();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 28   : 		strGamePath.clear();

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 38	 add	 ecx, 56			; 00000038H
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 29   : 		strPicPath.clear();

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	83 c1 54	 add	 ecx, 84			; 00000054H
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 30   : 		strIntro.clear();

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 70	 add	 ecx, 112		; 00000070H
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 31   : 		uiFileSize    = 0;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 80 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+140], 0

; 32   : 	}

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?clear@OneLocalGame@@QAEXXZ ENDP			; OneLocalGame::clear
_TEXT	ENDS
PUBLIC	?x_SetPos@CMarkup@@IAEXHHH@Z			; CMarkup::x_SetPos
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.h
;	COMDAT ?ResetPos@CMarkup@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetPos@CMarkup@@QAEXXZ PROC NEAR			; CMarkup::ResetPos, COMDAT
; _this$ = ecx

; 53   : 	void ResetPos() { x_SetPos(0,0,0); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?x_SetPos@CMarkup@@IAEXHHH@Z ; CMarkup::x_SetPos
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?ResetPos@CMarkup@@QAEXXZ ENDP				; CMarkup::ResetPos
_TEXT	ENDS
EXTRN	?x_GetAttrib@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPBD@Z:NEAR ; CMarkup::x_GetAttrib
; Function compile flags: /Odt
;	COMDAT ?GetAttrib@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T202679 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_szAttrib$ = 12						; size = 4
?GetAttrib@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z PROC NEAR ; CMarkup::GetAttrib, COMDAT
; _this$ = ecx

; 58   : 	CString GetAttrib( LPCTSTR szAttrib ) const { return x_GetAttrib(m_iPos,szAttrib); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T202679[ebp], 0
  00010	8b 45 0c	 mov	 eax, DWORD PTR _szAttrib$[ebp]
  00013	50		 push	 eax
  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?x_GetAttrib@CMarkup@@IBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPBD@Z ; CMarkup::x_GetAttrib
  00027	8b 4d fc	 mov	 ecx, DWORD PTR $T202679[ebp]
  0002a	83 c9 01	 or	 ecx, 1
  0002d	89 4d fc	 mov	 DWORD PTR $T202679[ebp], ecx
  00030	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?GetAttrib@CMarkup@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ENDP ; CMarkup::GetAttrib
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?x_SetPos@CMarkup@@IAEXHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iPosParent$ = 8					; size = 4
_iPos$ = 12						; size = 4
_iPosChild$ = 16					; size = 4
?x_SetPos@CMarkup@@IAEXHHH@Z PROC NEAR			; CMarkup::x_SetPos, COMDAT
; _this$ = ecx

; 132  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 133  : 		m_iPosParent = iPosParent;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _iPosParent$[ebp]
  0000d	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 134  : 		m_iPos = iPos;

  00010	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00013	8b 45 0c	 mov	 eax, DWORD PTR _iPos$[ebp]
  00016	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 135  : 		m_iPosChild = iPosChild;

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 55 10	 mov	 edx, DWORD PTR _iPosChild$[ebp]
  0001f	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 136  : 		m_nNodeType = iPos?MNT_ELEMENT:0;

  00022	33 c0		 xor	 eax, eax
  00024	83 7d 0c 00	 cmp	 DWORD PTR _iPos$[ebp], 0
  00028	0f 95 c0	 setne	 al
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 137  : 		MARKUP_SETDEBUGSTATE;
; 138  : 	};

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?x_SetPos@CMarkup@@IAEXHHH@Z ENDP			; CMarkup::x_SetPos
_TEXT	ENDS
PUBLIC	?AddElem@CMarkupArchive@@UAE_NPBD0@Z		; CMarkupArchive::AddElem
PUBLIC	?AddChildElem@CMarkupArchive@@UAE_NPBD0@Z	; CMarkupArchive::AddChildElem
PUBLIC	??_R4CMarkupArchive@@6B@			; CMarkupArchive::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMarkupArchive@@@8			; CMarkupArchive `RTTI Type Descriptor'
PUBLIC	??_R3CMarkupArchive@@8				; CMarkupArchive::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMarkupArchive@@8				; CMarkupArchive::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CMarkupArchive@@8			; CMarkupArchive::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@CMarkup@@8				; CMarkup::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCMarkup@@@8				; CMarkup `RTTI Type Descriptor'
PUBLIC	??_7CMarkupArchive@@6B@				; CMarkupArchive::`vftable'
PUBLIC	??_GCMarkupArchive@@UAEPAXI@Z			; CMarkupArchive::`scalar deleting destructor'
PUBLIC	??_C@_0L@GJIJNDEK@ISO?98859?91?$AA@		; `string'
PUBLIC	??0CMarkup@@QAE@XZ				; CMarkup::CMarkup
PUBLIC	??1CMarkup@@UAE@XZ				; CMarkup::~CMarkup
EXTRN	??_ECMarkupArchive@@UAEPAXI@Z:NEAR		; CMarkupArchive::`vector deleting destructor'
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:NEAR
;	COMDAT xdata$x
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markuparchive.h
xdata$x	SEGMENT
$T202693 DD	0ffffffffH
	DD	FLAT:$L202685
	DD	00H
	DD	FLAT:$L202686
	DD	01H
	DD	FLAT:$L202687
	DD	02H
	DD	FLAT:$L202688
	DD	03H
	DD	FLAT:$L202689
$T202691 DD	019930520H
	DD	05H
	DD	FLAT:$T202693
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CMarkupArchive@@6B@
CONST	SEGMENT
??_7CMarkupArchive@@6B@ DD FLAT:??_R4CMarkupArchive@@6B@ ; CMarkupArchive::`vftable'
	DD	FLAT:??_ECMarkupArchive@@UAEPAXI@Z
	DD	FLAT:?AddElem@CMarkupArchive@@UAE_NPBD0@Z
	DD	FLAT:?AddChildElem@CMarkupArchive@@UAE_NPBD0@Z
	DD	FLAT:?FindElem@CMarkupArchive@@UAE_NPBD@Z
	DD	FLAT:?FindChildElem@CMarkupArchive@@UAE_NPBD@Z
CONST	ENDS
;	COMDAT ??_C@_0L@GJIJNDEK@ISO?98859?91?$AA@
CONST	SEGMENT
??_C@_0L@GJIJNDEK@ISO?98859?91?$AA@ DB 'ISO-8859-1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R4CMarkupArchive@@6B@
rdata$r	SEGMENT
??_R4CMarkupArchive@@6B@ DD 00H				; CMarkupArchive::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMarkupArchive@@@8
	DD	FLAT:??_R3CMarkupArchive@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMarkupArchive@@@8
_DATA	SEGMENT
??_R0?AVCMarkupArchive@@@8 DD FLAT:??_7type_info@@6B@	; CMarkupArchive `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMarkupArchive@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CMarkupArchive@@8
rdata$r	SEGMENT
??_R3CMarkupArchive@@8 DD 00H				; CMarkupArchive::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CMarkupArchive@@8
rdata$r	ENDS
;	COMDAT ??_R2CMarkupArchive@@8
rdata$r	SEGMENT
??_R2CMarkupArchive@@8 DD FLAT:??_R1A@?0A@A@CMarkupArchive@@8 ; CMarkupArchive::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CMarkup@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMarkupArchive@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CMarkupArchive@@8 DD FLAT:??_R0?AVCMarkupArchive@@@8 ; CMarkupArchive::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CMarkup@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CMarkup@@8 DD FLAT:??_R0?AVCMarkup@@@8	; CMarkup::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCMarkup@@@8
_DATA	SEGMENT
??_R0?AVCMarkup@@@8 DD FLAT:??_7type_info@@6B@		; CMarkup `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMarkup@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0CMarkupArchive@@QAE@K@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dwMode$ = 8						; size = 4
??0CMarkupArchive@@QAE@K@Z PROC NEAR			; CMarkupArchive::CMarkupArchive, COMDAT
; _this$ = ecx

; 56   : 	CMarkupArchive(DWORD dwMode = ArchiveModeCreate | ArchiveModeStoring): CMarkup() {	m_dwMode = dwMode; m_bOpened=false; m_strEncodingString = _T("ISO-8859-1");};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CMarkupArchive@@QAE@K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0CMarkup@@QAE@XZ	; CMarkup::CMarkup
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMarkupArchive@@6B@
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 38	 add	 ecx, 56			; 00000038H
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00040	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00044	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	83 c1 40	 add	 ecx, 64			; 00000040H
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00050	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00054	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	83 c1 44	 add	 ecx, 68			; 00000044H
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00060	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00064	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	83 c1 48	 add	 ecx, 72			; 00000048H
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00070	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00074	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	8b 55 08	 mov	 edx, DWORD PTR _dwMode$[ebp]
  0007a	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	c6 40 3c 00	 mov	 BYTE PTR [eax+60], 0
  00084	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@GJIJNDEK@ISO?98859?91?$AA@
  00089	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	83 c1 38	 add	 ecx, 56			; 00000038H
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
  00095	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202685:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMarkup@@UAE@XZ	; CMarkup::~CMarkup
$L202686:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 38	 add	 ecx, 56			; 00000038H
  0000e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L202687:
  00014	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 c1 40	 add	 ecx, 64			; 00000040H
  0001a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L202688:
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	83 c1 44	 add	 ecx, 68			; 00000044H
  00026	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L202689:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 48	 add	 ecx, 72			; 00000048H
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$??0CMarkupArchive@@QAE@K@Z:
  00038	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202691
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CMarkupArchive@@QAE@K@Z ENDP				; CMarkupArchive::CMarkupArchive
PUBLIC	??_7CMarkup@@6B@				; CMarkup::`vftable'
PUBLIC	??_GCMarkup@@UAEPAXI@Z				; CMarkup::`scalar deleting destructor'
PUBLIC	??_R4CMarkup@@6B@				; CMarkup::`RTTI Complete Object Locator'
PUBLIC	??_R3CMarkup@@8					; CMarkup::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMarkup@@8					; CMarkup::`RTTI Base Class Array'
PUBLIC	??0?$CArray@UElemPos@CMarkup@@AAU12@@@QAE@XZ	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::CArray<CMarkup::ElemPos,CMarkup::ElemPos &>
PUBLIC	??1?$CArray@UElemPos@CMarkup@@AAU12@@@UAE@XZ	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::~CArray<CMarkup::ElemPos,CMarkup::ElemPos &>
EXTRN	??_ECMarkup@@UAEPAXI@Z:NEAR			; CMarkup::`vector deleting destructor'
EXTRN	?SetDoc@CMarkup@@QAE_NPBD@Z:NEAR		; CMarkup::SetDoc
;	COMDAT xdata$x
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.h
xdata$x	SEGMENT
$T202704 DD	0ffffffffH
	DD	FLAT:$L202698
	DD	00H
	DD	FLAT:$L202699
	DD	01H
	DD	FLAT:$L202700
$T202702 DD	019930520H
	DD	03H
	DD	FLAT:$T202704
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CMarkup@@6B@
CONST	SEGMENT
??_7CMarkup@@6B@ DD FLAT:??_R4CMarkup@@6B@		; CMarkup::`vftable'
	DD	FLAT:??_ECMarkup@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CMarkup@@6B@
rdata$r	SEGMENT
??_R4CMarkup@@6B@ DD 00H				; CMarkup::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMarkup@@@8
	DD	FLAT:??_R3CMarkup@@8
rdata$r	ENDS
;	COMDAT ??_R3CMarkup@@8
rdata$r	SEGMENT
??_R3CMarkup@@8 DD 00H					; CMarkup::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMarkup@@8
rdata$r	ENDS
;	COMDAT ??_R2CMarkup@@8
rdata$r	SEGMENT
??_R2CMarkup@@8 DD FLAT:??_R1A@?0A@A@CMarkup@@8		; CMarkup::`RTTI Base Class Array'
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0CMarkup@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CMarkup@@QAE@XZ PROC NEAR				; CMarkup::CMarkup, COMDAT
; _this$ = ecx

; 29   : 	CMarkup() { SetDoc( NULL ); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CMarkup@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMarkup@@6B@
  00025	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 c1 04	 add	 ecx, 4
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 08	 add	 ecx, 8
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00044	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004e	e8 00 00 00 00	 call	 ??0?$CArray@UElemPos@CMarkup@@AAU12@@@QAE@XZ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::CArray<CMarkup::ElemPos,CMarkup::ElemPos &>
  00053	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00057	6a 00		 push	 0
  00059	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?SetDoc@CMarkup@@QAE_NPBD@Z ; CMarkup::SetDoc
  00061	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00068	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202698:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L202699:
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 08	 add	 ecx, 8
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L202700:
  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001e	e9 00 00 00 00	 jmp	 ??1?$CArray@UElemPos@CMarkup@@AAU12@@@UAE@XZ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::~CArray<CMarkup::ElemPos,CMarkup::ElemPos &>
__ehhandler$??0CMarkup@@QAE@XZ:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202702
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CMarkup@@QAE@XZ ENDP					; CMarkup::CMarkup
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202715 DD	0ffffffffH
	DD	FLAT:$L202709
	DD	00H
	DD	FLAT:$L202710
$T202713 DD	019930520H
	DD	02H
	DD	FLAT:$T202715
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1CMarkup@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CMarkup@@UAE@XZ PROC NEAR				; CMarkup::~CMarkup, COMDAT
; _this$ = ecx

; 33   : 	virtual ~CMarkup() {};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CMarkup@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMarkup@@6B@
  00025	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	e8 00 00 00 00	 call	 ??1?$CArray@UElemPos@CMarkup@@AAU12@@@UAE@XZ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::~CArray<CMarkup::ElemPos,CMarkup::ElemPos &>
  00037	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	83 c1 08	 add	 ecx, 8
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00047	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	83 c1 04	 add	 ecx, 4
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202709:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L202710:
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 08	 add	 ecx, 8
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$??1CMarkup@@UAE@XZ:
  00018	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202713
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CMarkup@@UAE@XZ ENDP					; CMarkup::~CMarkup
; Function compile flags: /Odt
;	COMDAT ??_GCMarkup@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCMarkup@@UAEPAXI@Z PROC NEAR			; CMarkup::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMarkup@@UAE@XZ	; CMarkup::~CMarkup
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L199766
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L199766:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCMarkup@@UAEPAXI@Z ENDP				; CMarkup::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
PUBLIC	?AddElem@CMarkup@@QAE_NPBD0@Z			; CMarkup::AddElem
EXTRN	__imp_?IsEmpty@?$CSimpleStringT@D$00@ATL@@QBE_NXZ:NEAR
;	COMDAT xdata$x
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markuparchive.h
xdata$x	SEGMENT
$T202728 DD	0ffffffffH
	DD	FLAT:$L202724
$T202726 DD	019930520H
	DD	01H
	DD	FLAT:$T202728
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?AddElem@CMarkupArchive@@UAE_NPBD0@Z
_TEXT	SEGMENT
tv88 = -32						; size = 4
tv89 = -28						; size = 4
_this$ = -24						; size = 4
$T202723 = -20						; size = 4
$T202722 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_szName$ = 8						; size = 4
_szData$ = 12						; size = 4
?AddElem@CMarkupArchive@@UAE_NPBD0@Z PROC NEAR		; CMarkupArchive::AddElem, COMDAT
; _this$ = ecx

; 144  : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddElem@CMarkupArchive@@UAE_NPBD0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 14	 sub	 esp, 20			; 00000014H
  0001b	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 145  : 		if (m_sNameSpace.IsEmpty()) 

  0001e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 44	 add	 ecx, 68			; 00000044H
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@?$CSimpleStringT@D$00@ATL@@QBE_NXZ
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 12		 je	 SHORT $L199868

; 146  : 			return CMarkup::AddElem( szName, szData); 

  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _szData$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 08	 mov	 edx, DWORD PTR _szName$[ebp]
  00038	52		 push	 edx
  00039	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?AddElem@CMarkup@@QAE_NPBD0@Z ; CMarkup::AddElem
  00041	eb 53		 jmp	 SHORT $L199867
$L199868:

; 147  : 		else 
; 148  : 			return CMarkup::AddElem( m_sNameSpace+szName, szData);

  00043	8b 45 08	 mov	 eax, DWORD PTR _szName$[ebp]
  00046	50		 push	 eax
  00047	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	83 c1 44	 add	 ecx, 68			; 00000044H
  0004d	51		 push	 ecx
  0004e	8d 55 ec	 lea	 edx, DWORD PTR $T202723[ebp]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	89 45 e4	 mov	 DWORD PTR tv89[ebp], eax
  0005d	8b 45 e4	 mov	 eax, DWORD PTR tv89[ebp]
  00060	89 45 e0	 mov	 DWORD PTR tv88[ebp], eax
  00063	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _szData$[ebp]
  0006d	51		 push	 ecx
  0006e	8b 4d e0	 mov	 ecx, DWORD PTR tv88[ebp]
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00077	50		 push	 eax
  00078	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?AddElem@CMarkup@@QAE_NPBD0@Z ; CMarkup::AddElem
  00080	88 45 f3	 mov	 BYTE PTR $T202722[ebp], al
  00083	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8d 4d ec	 lea	 ecx, DWORD PTR $T202723[ebp]
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00093	8a 45 f3	 mov	 al, BYTE PTR $T202722[ebp]
$L199867:

; 149  : 	};

  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202724:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T202723[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?AddElem@CMarkupArchive@@UAE_NPBD0@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202726
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddElem@CMarkupArchive@@UAE_NPBD0@Z ENDP		; CMarkupArchive::AddElem
EXTRN	?x_AddElem@CMarkup@@IAE_NPBD0_N1@Z:NEAR		; CMarkup::x_AddElem
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.h
;	COMDAT ?AddElem@CMarkup@@QAE_NPBD0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szName$ = 8						; size = 4
_szData$ = 12						; size = 4
?AddElem@CMarkup@@QAE_NPBD0@Z PROC NEAR			; CMarkup::AddElem, COMDAT
; _this$ = ecx

; 37   : 	bool AddElem( LPCTSTR szName, LPCTSTR szData=NULL ) { return x_AddElem(szName,szData,false,false); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _szData$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _szName$[ebp]
  00012	51		 push	 ecx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?x_AddElem@CMarkup@@IAE_NPBD0_N1@Z ; CMarkup::x_AddElem
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?AddElem@CMarkup@@QAE_NPBD0@Z ENDP			; CMarkup::AddElem
_TEXT	ENDS
PUBLIC	?AddChildElem@CMarkup@@QAE_NPBD0@Z		; CMarkup::AddChildElem
;	COMDAT xdata$x
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markuparchive.h
xdata$x	SEGMENT
$T202741 DD	0ffffffffH
	DD	FLAT:$L202737
$T202739 DD	019930520H
	DD	01H
	DD	FLAT:$T202741
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?AddChildElem@CMarkupArchive@@UAE_NPBD0@Z
_TEXT	SEGMENT
tv88 = -32						; size = 4
tv89 = -28						; size = 4
_this$ = -24						; size = 4
$T202736 = -20						; size = 4
$T202735 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_szName$ = 8						; size = 4
_szData$ = 12						; size = 4
?AddChildElem@CMarkupArchive@@UAE_NPBD0@Z PROC NEAR	; CMarkupArchive::AddChildElem, COMDAT
; _this$ = ecx

; 152  : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddChildElem@CMarkupArchive@@UAE_NPBD0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 14	 sub	 esp, 20			; 00000014H
  0001b	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 		if (m_sNameSpace.IsEmpty()) 

  0001e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 44	 add	 ecx, 68			; 00000044H
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@?$CSimpleStringT@D$00@ATL@@QBE_NXZ
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 12		 je	 SHORT $L199874

; 154  : 			return CMarkup::AddChildElem( szName, szData); 

  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _szData$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 08	 mov	 edx, DWORD PTR _szName$[ebp]
  00038	52		 push	 edx
  00039	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?AddChildElem@CMarkup@@QAE_NPBD0@Z ; CMarkup::AddChildElem
  00041	eb 53		 jmp	 SHORT $L199873
$L199874:

; 155  : 		else 
; 156  : 			return CMarkup::AddChildElem( m_sNameSpace+szName, szData);

  00043	8b 45 08	 mov	 eax, DWORD PTR _szName$[ebp]
  00046	50		 push	 eax
  00047	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	83 c1 44	 add	 ecx, 68			; 00000044H
  0004d	51		 push	 ecx
  0004e	8d 55 ec	 lea	 edx, DWORD PTR $T202736[ebp]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	89 45 e4	 mov	 DWORD PTR tv89[ebp], eax
  0005d	8b 45 e4	 mov	 eax, DWORD PTR tv89[ebp]
  00060	89 45 e0	 mov	 DWORD PTR tv88[ebp], eax
  00063	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _szData$[ebp]
  0006d	51		 push	 ecx
  0006e	8b 4d e0	 mov	 ecx, DWORD PTR tv88[ebp]
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00077	50		 push	 eax
  00078	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?AddChildElem@CMarkup@@QAE_NPBD0@Z ; CMarkup::AddChildElem
  00080	88 45 f3	 mov	 BYTE PTR $T202735[ebp], al
  00083	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8d 4d ec	 lea	 ecx, DWORD PTR $T202736[ebp]
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00093	8a 45 f3	 mov	 al, BYTE PTR $T202735[ebp]
$L199873:

; 157  : 	};

  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202737:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T202736[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?AddChildElem@CMarkupArchive@@UAE_NPBD0@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202739
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddChildElem@CMarkupArchive@@UAE_NPBD0@Z ENDP		; CMarkupArchive::AddChildElem
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.h
;	COMDAT ?AddChildElem@CMarkup@@QAE_NPBD0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szName$ = 8						; size = 4
_szData$ = 12						; size = 4
?AddChildElem@CMarkup@@QAE_NPBD0@Z PROC NEAR		; CMarkup::AddChildElem, COMDAT
; _this$ = ecx

; 38   : 	bool AddChildElem( LPCTSTR szName, LPCTSTR szData=NULL ) { return x_AddElem(szName,szData,false,true); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 01		 push	 1
  00009	6a 00		 push	 0
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _szData$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _szName$[ebp]
  00012	51		 push	 ecx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?x_AddElem@CMarkup@@IAE_NPBD0_N1@Z ; CMarkup::x_AddElem
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?AddChildElem@CMarkup@@QAE_NPBD0@Z ENDP			; CMarkup::AddChildElem
_TEXT	ENDS
EXTRN	?FindElem@CMarkup@@QAE_NPBD@Z:NEAR		; CMarkup::FindElem
;	COMDAT xdata$x
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markuparchive.h
xdata$x	SEGMENT
$T202754 DD	0ffffffffH
	DD	FLAT:$L202750
$T202752 DD	019930520H
	DD	01H
	DD	FLAT:$T202754
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?FindElem@CMarkupArchive@@UAE_NPBD@Z
_TEXT	SEGMENT
tv90 = -32						; size = 4
tv91 = -28						; size = 4
_this$ = -24						; size = 4
$T202749 = -20						; size = 4
$T202748 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_szName$ = 8						; size = 4
?FindElem@CMarkupArchive@@UAE_NPBD@Z PROC NEAR		; CMarkupArchive::FindElem, COMDAT
; _this$ = ecx

; 160  : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FindElem@CMarkupArchive@@UAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 14	 sub	 esp, 20			; 00000014H
  0001b	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 		if (szName==NULL) 

  0001e	83 7d 08 00	 cmp	 DWORD PTR _szName$[ebp], 0
  00022	75 0c		 jne	 SHORT $L199880

; 162  : 			return CMarkup::FindElem( NULL); 

  00024	6a 00		 push	 0
  00026	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?FindElem@CMarkup@@QAE_NPBD@Z ; CMarkup::FindElem
  0002e	eb 70		 jmp	 SHORT $L199879
$L199880:

; 163  : 		else 
; 164  : 			if (m_sNameSpace.IsEmpty())

  00030	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 44	 add	 ecx, 68			; 00000044H
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@?$CSimpleStringT@D$00@ATL@@QBE_NXZ
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	85 c0		 test	 eax, eax
  00041	74 0e		 je	 SHORT $L199882

; 165  : 				return CMarkup::FindElem(szName);

  00043	8b 4d 08	 mov	 ecx, DWORD PTR _szName$[ebp]
  00046	51		 push	 ecx
  00047	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?FindElem@CMarkup@@QAE_NPBD@Z ; CMarkup::FindElem
  0004f	eb 4f		 jmp	 SHORT $L199879
$L199882:

; 166  : 			else
; 167  : 				return CMarkup::FindElem( m_sNameSpace+szName);

  00051	8b 55 08	 mov	 edx, DWORD PTR _szName$[ebp]
  00054	52		 push	 edx
  00055	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	83 c0 44	 add	 eax, 68			; 00000044H
  0005b	50		 push	 eax
  0005c	8d 4d ec	 lea	 ecx, DWORD PTR $T202749[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	89 45 e4	 mov	 DWORD PTR tv91[ebp], eax
  0006b	8b 55 e4	 mov	 edx, DWORD PTR tv91[ebp]
  0006e	89 55 e0	 mov	 DWORD PTR tv90[ebp], edx
  00071	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00078	8b 4d e0	 mov	 ecx, DWORD PTR tv90[ebp]
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00081	50		 push	 eax
  00082	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?FindElem@CMarkup@@QAE_NPBD@Z ; CMarkup::FindElem
  0008a	88 45 f3	 mov	 BYTE PTR $T202748[ebp], al
  0008d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00094	8d 4d ec	 lea	 ecx, DWORD PTR $T202749[ebp]
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0009d	8a 45 f3	 mov	 al, BYTE PTR $T202748[ebp]
$L199879:

; 168  : 	};

  000a0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202750:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T202749[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?FindElem@CMarkupArchive@@UAE_NPBD@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202752
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FindElem@CMarkupArchive@@UAE_NPBD@Z ENDP		; CMarkupArchive::FindElem
EXTRN	?FindChildElem@CMarkup@@QAE_NPBD@Z:NEAR		; CMarkup::FindChildElem
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202765 DD	0ffffffffH
	DD	FLAT:$L202761
$T202763 DD	019930520H
	DD	01H
	DD	FLAT:$T202765
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?FindChildElem@CMarkupArchive@@UAE_NPBD@Z
_TEXT	SEGMENT
tv90 = -32						; size = 4
tv91 = -28						; size = 4
_this$ = -24						; size = 4
$T202760 = -20						; size = 4
$T202759 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_szName$ = 8						; size = 4
?FindChildElem@CMarkupArchive@@UAE_NPBD@Z PROC NEAR	; CMarkupArchive::FindChildElem, COMDAT
; _this$ = ecx

; 171  : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FindChildElem@CMarkupArchive@@UAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 14	 sub	 esp, 20			; 00000014H
  0001b	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 172  : 		if (szName==NULL) 

  0001e	83 7d 08 00	 cmp	 DWORD PTR _szName$[ebp], 0
  00022	75 0c		 jne	 SHORT $L199888

; 173  : 			return CMarkup::FindElem( NULL); 

  00024	6a 00		 push	 0
  00026	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?FindElem@CMarkup@@QAE_NPBD@Z ; CMarkup::FindElem
  0002e	eb 70		 jmp	 SHORT $L199887
$L199888:

; 174  : 		else 
; 175  : 			if (m_sNameSpace.IsEmpty())

  00030	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 44	 add	 ecx, 68			; 00000044H
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@?$CSimpleStringT@D$00@ATL@@QBE_NXZ
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	85 c0		 test	 eax, eax
  00041	74 0e		 je	 SHORT $L199890

; 176  : 				return CMarkup::FindChildElem(szName);

  00043	8b 4d 08	 mov	 ecx, DWORD PTR _szName$[ebp]
  00046	51		 push	 ecx
  00047	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?FindChildElem@CMarkup@@QAE_NPBD@Z ; CMarkup::FindChildElem
  0004f	eb 4f		 jmp	 SHORT $L199887
$L199890:

; 177  : 			else
; 178  : 				return CMarkup::FindChildElem( m_sNameSpace+szName);

  00051	8b 55 08	 mov	 edx, DWORD PTR _szName$[ebp]
  00054	52		 push	 edx
  00055	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	83 c0 44	 add	 eax, 68			; 00000044H
  0005b	50		 push	 eax
  0005c	8d 4d ec	 lea	 ecx, DWORD PTR $T202760[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	89 45 e4	 mov	 DWORD PTR tv91[ebp], eax
  0006b	8b 55 e4	 mov	 edx, DWORD PTR tv91[ebp]
  0006e	89 55 e0	 mov	 DWORD PTR tv90[ebp], edx
  00071	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00078	8b 4d e0	 mov	 ecx, DWORD PTR tv90[ebp]
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00081	50		 push	 eax
  00082	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?FindChildElem@CMarkup@@QAE_NPBD@Z ; CMarkup::FindChildElem
  0008a	88 45 f3	 mov	 BYTE PTR $T202759[ebp], al
  0008d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00094	8d 4d ec	 lea	 ecx, DWORD PTR $T202760[ebp]
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0009d	8a 45 f3	 mov	 al, BYTE PTR $T202759[ebp]
$L199887:

; 179  : 	};

  000a0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202761:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T202760[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?FindChildElem@CMarkupArchive@@UAE_NPBD@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202763
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FindChildElem@CMarkupArchive@@UAE_NPBD@Z ENDP		; CMarkupArchive::FindChildElem
; Function compile flags: /Odt
;	COMDAT ??_GCMarkupArchive@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCMarkupArchive@@UAEPAXI@Z PROC NEAR			; CMarkupArchive::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMarkupArchive@@UAE@XZ ; CMarkupArchive::~CMarkupArchive
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L199900
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L199900:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCMarkupArchive@@UAEPAXI@Z ENDP			; CMarkupArchive::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202780 DD	0ffffffffH
	DD	FLAT:$L202772
	DD	00H
	DD	FLAT:$L202773
	DD	01H
	DD	FLAT:$L202774
	DD	02H
	DD	FLAT:$L202775
$T202778 DD	019930520H
	DD	04H
	DD	FLAT:$T202780
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1OneLocalGame@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1OneLocalGame@@QAE@XZ PROC NEAR			; OneLocalGame::~OneLocalGame, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1OneLocalGame@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 70	 add	 ecx, 112		; 00000070H
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00033	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	83 c1 54	 add	 ecx, 84			; 00000054H
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0003f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 38	 add	 ecx, 56			; 00000038H
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0004f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0005f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202772:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202773:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0000f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202774:
  00015	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 38	 add	 ecx, 56			; 00000038H
  0001b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202775:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 54	 add	 ecx, 84			; 00000054H
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1OneLocalGame@@QAE@XZ:
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202778
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1OneLocalGame@@QAE@XZ ENDP				; OneLocalGame::~OneLocalGame
PUBLIC	??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator!=
PUBLIC	??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
PUBLIC	??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AV012@H@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?SetAttrib@CMarkup@@QAE_NPBD0@Z			; CMarkup::SetAttrib
PUBLIC	?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::begin
PUBLIC	?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end
EXTRN	?Save@CMarkupArchive@@QAE_NXZ:NEAR		; CMarkupArchive::Save
EXTRN	__imp__CopyFileA@12:NEAR
EXTRN	?MakeDir@YL_DirInfo@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:NEAR ; YL_DirInfo::MakeDir
EXTRN	?GetFileDirPath@YL_FileInfo@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z:NEAR ; YL_FileInfo::GetFileDirPath
EXTRN	?SetFileContent@YL_FileInfo@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z:NEAR ; YL_FileInfo::SetFileContent
EXTRN	?OutOfElem@CMarkup@@QAE_NXZ:NEAR		; CMarkup::OutOfElem
xdata$x	SEGMENT
$T202796 DD	0ffffffffH
	DD	FLAT:$L202788
	DD	00H
	DD	FLAT:$L202789
	DD	01H
	DD	FLAT:$L202790
	DD	02H
	DD	FLAT:$L202791
$T202793 DD	019930520H
	DD	04H
	DD	FLAT:$T202796
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\httpdown\localgamedata.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -200						; size = 4
$T202787 = -196						; size = 4
$T202786 = -192						; size = 4
_it1$200238 = -188					; size = 4
_strTmp$ = -184						; size = 28
_xml$ = -156						; size = 76
_strFileDir$ = -72					; size = 28
_strContent$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?UnLoadGameData@LocalGameData@@AAEXXZ PROC NEAR		; LocalGameData::UnLoadGameData
; _this$ = ecx

; 141  : {

  006d0	55		 push	 ebp
  006d1	8b ec		 mov	 ebp, esp
  006d3	6a ff		 push	 -1
  006d5	68 00 00 00 00	 push	 __ehhandler$?UnLoadGameData@LocalGameData@@AAEXXZ
  006da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  006e0	50		 push	 eax
  006e1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  006e8	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  006ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  006f3	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  006f6	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 142  : 	string strTmp = m_strDataFilePath + ".1";

  006fc	68 00 00 00 00	 push	 OFFSET FLAT:$SG200116
  00701	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00707	83 c0 14	 add	 eax, 20			; 00000014H
  0070a	50		 push	 eax
  0070b	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strTmp$[ebp]
  00711	51		 push	 ecx
  00712	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00717	83 c4 0c	 add	 esp, 12			; 0000000cH
  0071a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 143  : 	string strContent = "<?xml version=\"1.0\" encoding=\"GBK\"?><root/>";

  00721	68 00 00 00 00	 push	 OFFSET FLAT:$SG200118
  00726	8d 4d d4	 lea	 ecx, DWORD PTR _strContent$[ebp]
  00729	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0072f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 144  : 
; 145  : 	string strFileDir;

  00733	8d 4d b8	 lea	 ecx, DWORD PTR _strFileDir$[ebp]
  00736	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0073c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 146  : 	YL_FileInfo::GetFileDirPath( strTmp, strFileDir );

  00740	8d 55 b8	 lea	 edx, DWORD PTR _strFileDir$[ebp]
  00743	52		 push	 edx
  00744	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _strTmp$[ebp]
  0074a	50		 push	 eax
  0074b	e8 00 00 00 00	 call	 ?GetFileDirPath@YL_FileInfo@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; YL_FileInfo::GetFileDirPath
  00750	83 c4 08	 add	 esp, 8

; 147  : 	YL_DirInfo::MakeDir( strFileDir );

  00753	8d 4d b8	 lea	 ecx, DWORD PTR _strFileDir$[ebp]
  00756	51		 push	 ecx
  00757	e8 00 00 00 00	 call	 ?MakeDir@YL_DirInfo@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_DirInfo::MakeDir
  0075c	83 c4 04	 add	 esp, 4

; 148  : 
; 149  : 	YL_FileInfo::SetFileContent( strTmp, strContent );

  0075f	8d 55 d4	 lea	 edx, DWORD PTR _strContent$[ebp]
  00762	52		 push	 edx
  00763	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _strTmp$[ebp]
  00769	50		 push	 eax
  0076a	e8 00 00 00 00	 call	 ?SetFileContent@YL_FileInfo@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; YL_FileInfo::SetFileContent
  0076f	83 c4 08	 add	 esp, 8

; 150  : 	
; 151  : 	CMarkupArchive xml;

  00772	6a 03		 push	 3
  00774	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  0077a	e8 00 00 00 00	 call	 ??0CMarkupArchive@@QAE@K@Z ; CMarkupArchive::CMarkupArchive
  0077f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 152  : 	if( !xml.Open(strTmp.c_str()) )

  00783	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strTmp$[ebp]
  00789	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0078f	50		 push	 eax
  00790	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00796	e8 00 00 00 00	 call	 ?Open@CMarkupArchive@@QAE_NPBD@Z ; CMarkupArchive::Open
  0079b	0f b6 c8	 movzx	 ecx, al
  0079e	85 c9		 test	 ecx, ecx
  007a0	75 41		 jne	 SHORT $L200121

; 153  : 		return;

  007a2	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  007a6	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  007ac	e8 00 00 00 00	 call	 ??1CMarkupArchive@@UAE@XZ ; CMarkupArchive::~CMarkupArchive
  007b1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  007b5	8d 4d b8	 lea	 ecx, DWORD PTR _strFileDir$[ebp]
  007b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  007be	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  007c2	8d 4d d4	 lea	 ecx, DWORD PTR _strContent$[ebp]
  007c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  007cb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  007d2	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strTmp$[ebp]
  007d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  007de	e9 d3 01 00 00	 jmp	 $L200113
$L200121:

; 154  : 
; 155  : 	xml.ResetPos();

  007e3	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  007e9	e8 00 00 00 00	 call	 ?ResetPos@CMarkup@@QAEXXZ ; CMarkup::ResetPos

; 156  : 	xml.FindElem();

  007ee	6a 00		 push	 0
  007f0	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  007f6	e8 00 00 00 00	 call	 ?FindElem@CMarkupArchive@@UAE_NPBD@Z ; CMarkupArchive::FindElem

; 157  : 
; 158  : 	for( LocalGameList::iterator it1 = m_vecGame.begin(); it1 != m_vecGame.end(); it1++ )

  007fb	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _it1$200238[ebp]
  00801	52		 push	 edx
  00802	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00808	83 c1 04	 add	 ecx, 4
  0080b	e8 00 00 00 00	 call	 ?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::begin
  00810	eb 14		 jmp	 SHORT $L200242
$L200243:
  00812	6a 00		 push	 0
  00814	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR $T202786[ebp]
  0081a	50		 push	 eax
  0081b	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _it1$200238[ebp]
  00821	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AV012@H@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++
$L200242:
  00826	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR $T202787[ebp]
  0082c	51		 push	 ecx
  0082d	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00833	83 c1 04	 add	 ecx, 4
  00836	e8 00 00 00 00	 call	 ?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end
  0083b	50		 push	 eax
  0083c	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _it1$200238[ebp]
  00842	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator!=
  00847	0f b6 d0	 movzx	 edx, al
  0084a	85 d2		 test	 edx, edx
  0084c	0f 84 ed 00 00
	00		 je	 $L200244

; 159  : 	{
; 160  : 		xml.AddChildElem( "app" );		

  00852	6a 00		 push	 0
  00854	68 00 00 00 00	 push	 OFFSET FLAT:$SG200245
  00859	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  0085f	e8 00 00 00 00	 call	 ?AddChildElem@CMarkupArchive@@UAE_NPBD0@Z ; CMarkupArchive::AddChildElem

; 161  : 		xml.IntoElem();

  00864	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  0086a	e8 00 00 00 00	 call	 ?IntoElem@CMarkup@@QAE_NXZ ; CMarkup::IntoElem

; 162  : 		xml.SetAttrib( "Id", it1->strID.c_str() );

  0086f	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _it1$200238[ebp]
  00875	e8 00 00 00 00	 call	 ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
  0087a	8b c8		 mov	 ecx, eax
  0087c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00882	50		 push	 eax
  00883	68 00 00 00 00	 push	 OFFSET FLAT:$SG200246
  00888	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  0088e	e8 00 00 00 00	 call	 ?SetAttrib@CMarkup@@QAE_NPBD0@Z ; CMarkup::SetAttrib

; 163  : 		xml.SetAttrib( "Name", it1->strName.c_str() );

  00893	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _it1$200238[ebp]
  00899	e8 00 00 00 00	 call	 ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
  0089e	83 c0 1c	 add	 eax, 28			; 0000001cH
  008a1	8b c8		 mov	 ecx, eax
  008a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  008a9	50		 push	 eax
  008aa	68 00 00 00 00	 push	 OFFSET FLAT:$SG200247
  008af	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  008b5	e8 00 00 00 00	 call	 ?SetAttrib@CMarkup@@QAE_NPBD0@Z ; CMarkup::SetAttrib

; 164  : 		xml.SetAttrib( "Intro", it1->strIntro.c_str() );

  008ba	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _it1$200238[ebp]
  008c0	e8 00 00 00 00	 call	 ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
  008c5	83 c0 70	 add	 eax, 112		; 00000070H
  008c8	8b c8		 mov	 ecx, eax
  008ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  008d0	50		 push	 eax
  008d1	68 00 00 00 00	 push	 OFFSET FLAT:$SG200248
  008d6	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  008dc	e8 00 00 00 00	 call	 ?SetAttrib@CMarkup@@QAE_NPBD0@Z ; CMarkup::SetAttrib

; 165  : 		xml.SetAttrib( "Img", it1->strPicPath.c_str() );

  008e1	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _it1$200238[ebp]
  008e7	e8 00 00 00 00	 call	 ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
  008ec	83 c0 54	 add	 eax, 84			; 00000054H
  008ef	8b c8		 mov	 ecx, eax
  008f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  008f7	50		 push	 eax
  008f8	68 00 00 00 00	 push	 OFFSET FLAT:$SG200249
  008fd	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00903	e8 00 00 00 00	 call	 ?SetAttrib@CMarkup@@QAE_NPBD0@Z ; CMarkup::SetAttrib

; 166  : 		xml.SetAttrib( "AppPath", it1->strGamePath.c_str() );

  00908	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _it1$200238[ebp]
  0090e	e8 00 00 00 00	 call	 ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
  00913	83 c0 38	 add	 eax, 56			; 00000038H
  00916	8b c8		 mov	 ecx, eax
  00918	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0091e	50		 push	 eax
  0091f	68 00 00 00 00	 push	 OFFSET FLAT:$SG200250
  00924	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  0092a	e8 00 00 00 00	 call	 ?SetAttrib@CMarkup@@QAE_NPBD0@Z ; CMarkup::SetAttrib

; 167  : 		xml.OutOfElem();

  0092f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00935	e8 00 00 00 00	 call	 ?OutOfElem@CMarkup@@QAE_NXZ ; CMarkup::OutOfElem

; 168  : 	}

  0093a	e9 d3 fe ff ff	 jmp	 $L200243
$L200244:

; 169  : 	xml.Close();

  0093f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00945	e8 00 00 00 00	 call	 ?Close@CMarkupArchive@@QAE_NXZ ; CMarkupArchive::Close

; 170  : 	xml.Save();

  0094a	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00950	e8 00 00 00 00	 call	 ?Save@CMarkupArchive@@QAE_NXZ ; CMarkupArchive::Save

; 171  : 
; 172  : 	CopyFile( strTmp.c_str(), m_strDataFilePath.c_str(), FALSE );

  00955	6a 00		 push	 0
  00957	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0095d	83 c1 14	 add	 ecx, 20			; 00000014H
  00960	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00966	50		 push	 eax
  00967	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strTmp$[ebp]
  0096d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00973	50		 push	 eax
  00974	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyFileA@12

; 173  : }

  0097a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0097e	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00984	e8 00 00 00 00	 call	 ??1CMarkupArchive@@UAE@XZ ; CMarkupArchive::~CMarkupArchive
  00989	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0098d	8d 4d b8	 lea	 ecx, DWORD PTR _strFileDir$[ebp]
  00990	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00996	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0099a	8d 4d d4	 lea	 ecx, DWORD PTR _strContent$[ebp]
  0099d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  009a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  009aa	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strTmp$[ebp]
  009b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200113:
  009b6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  009b9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  009c0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009c8	8b e5		 mov	 esp, ebp
  009ca	5d		 pop	 ebp
  009cb	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202788:
  000f3	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strTmp$[ebp]
  000f9	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202789:
  000ff	8d 4d d4	 lea	 ecx, DWORD PTR _strContent$[ebp]
  00102	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202790:
  00108	8d 4d b8	 lea	 ecx, DWORD PTR _strFileDir$[ebp]
  0010b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202791:
  00111	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _xml$[ebp]
  00117	e9 00 00 00 00	 jmp	 ??1CMarkupArchive@@UAE@XZ ; CMarkupArchive::~CMarkupArchive
__ehhandler$?UnLoadGameData@LocalGameData@@AAEXXZ:
  0011c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202793
  00121	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?UnLoadGameData@LocalGameData@@AAEXXZ ENDP		; LocalGameData::UnLoadGameData
EXTRN	?x_SetAttrib@CMarkup@@IAE_NHPBD0@Z:NEAR		; CMarkup::x_SetAttrib
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.h
;	COMDAT ?SetAttrib@CMarkup@@QAE_NPBD0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szAttrib$ = 8						; size = 4
_szValue$ = 12						; size = 4
?SetAttrib@CMarkup@@QAE_NPBD0@Z PROC NEAR		; CMarkup::SetAttrib, COMDAT
; _this$ = ecx

; 41   : 	bool SetAttrib( LPCTSTR szAttrib, LPCTSTR szValue ) { return x_SetAttrib(m_iPos,szAttrib,szValue); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _szValue$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _szAttrib$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?x_SetAttrib@CMarkup@@IAE_NHPBD0@Z ; CMarkup::x_SetAttrib
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?SetAttrib@CMarkup@@QAE_NPBD0@Z ENDP			; CMarkup::SetAttrib
_TEXT	ENDS
PUBLIC	?erase@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::erase
PUBLIC	??Diterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEAAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator*
PUBLIC	??4OneLocalGame@@QAEAAU0@ABU0@@Z		; OneLocalGame::operator=
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z:NEAR
xdata$x	SEGMENT
$T202811 DD	0ffffffffH
	DD	FLAT:$L202807
$T202809 DD	019930520H
	DD	01H
	DD	FLAT:$T202811
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\httpdown\localgamedata.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T202806 = -38						; size = 1
$T202805 = -37						; size = 1
$T202804 = -36						; size = 4
$T202803 = -29						; size = 1
$T202802 = -28						; size = 4
$T202801 = -24						; size = 4
$T202800 = -20						; size = 4
_it1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_strID$ = 8						; size = 28
_og$ = 36						; size = 4
?ILocalGameData_GetGameByID@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAUOneLocalGame@@@Z PROC NEAR ; LocalGameData::ILocalGameData_GetGameByID
; _this$ = ecx

; 176  : {

  009d0	55		 push	 ebp
  009d1	8b ec		 mov	 ebp, esp
  009d3	6a ff		 push	 -1
  009d5	68 00 00 00 00	 push	 __ehhandler$?ILocalGameData_GetGameByID@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAUOneLocalGame@@@Z
  009da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  009e0	50		 push	 eax
  009e1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  009e8	83 ec 20	 sub	 esp, 32			; 00000020H
  009eb	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
  009ee	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 177  : 	LocalGameList::iterator it1 = m_vecGame.begin();

  009f5	8d 45 f0	 lea	 eax, DWORD PTR _it1$[ebp]
  009f8	50		 push	 eax
  009f9	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  009fc	83 c1 04	 add	 ecx, 4
  009ff	e8 00 00 00 00	 call	 ?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::begin

; 178  : 	for( ; it1 != m_vecGame.end(); it1 ++ )

  00a04	eb 0e		 jmp	 SHORT $L200260
$L200261:
  00a06	6a 00		 push	 0
  00a08	8d 4d ec	 lea	 ecx, DWORD PTR $T202800[ebp]
  00a0b	51		 push	 ecx
  00a0c	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00a0f	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AV012@H@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++
$L200260:
  00a14	8d 55 e8	 lea	 edx, DWORD PTR $T202801[ebp]
  00a17	52		 push	 edx
  00a18	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00a1b	83 c1 04	 add	 ecx, 4
  00a1e	e8 00 00 00 00	 call	 ?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end
  00a23	50		 push	 eax
  00a24	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00a27	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator!=
  00a2c	0f b6 c0	 movzx	 eax, al
  00a2f	85 c0		 test	 eax, eax
  00a31	74 21		 je	 SHORT $L200262

; 179  : 	{
; 180  : 		if( strID == it1->strID)

  00a33	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00a36	e8 00 00 00 00	 call	 ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
  00a3b	50		 push	 eax
  00a3c	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  00a3f	51		 push	 ecx
  00a40	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
  00a46	83 c4 08	 add	 esp, 8
  00a49	0f b6 d0	 movzx	 edx, al
  00a4c	85 d2		 test	 edx, edx
  00a4e	74 02		 je	 SHORT $L200263

; 181  : 		{
; 182  : 			break;

  00a50	eb 02		 jmp	 SHORT $L200262
$L200263:

; 183  : 		}
; 184  : 	}

  00a52	eb b2		 jmp	 SHORT $L200261
$L200262:

; 185  : 	if( it1 != m_vecGame.end() )

  00a54	8d 45 e4	 lea	 eax, DWORD PTR $T202802[ebp]
  00a57	50		 push	 eax
  00a58	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00a5b	83 c1 04	 add	 ecx, 4
  00a5e	e8 00 00 00 00	 call	 ?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end
  00a63	50		 push	 eax
  00a64	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00a67	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator!=
  00a6c	0f b6 c8	 movzx	 ecx, al
  00a6f	85 c9		 test	 ecx, ecx
  00a71	74 79		 je	 SHORT $L200265

; 186  : 	{
; 187  : 		if( YL_FileInfo::IsValid( it1->strGamePath ) )

  00a73	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00a76	e8 00 00 00 00	 call	 ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
  00a7b	83 c0 38	 add	 eax, 56			; 00000038H
  00a7e	50		 push	 eax
  00a7f	e8 00 00 00 00	 call	 ?IsValid@YL_FileInfo@@SA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_FileInfo::IsValid
  00a84	83 c4 04	 add	 esp, 4
  00a87	0f b6 d0	 movzx	 edx, al
  00a8a	85 d2		 test	 edx, edx
  00a8c	74 2a		 je	 SHORT $L200266

; 188  : 		{
; 189  : 			og = *it1;

  00a8e	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00a91	e8 00 00 00 00	 call	 ??Diterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEAAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator*
  00a96	50		 push	 eax
  00a97	8b 4d 24	 mov	 ecx, DWORD PTR _og$[ebp]
  00a9a	e8 00 00 00 00	 call	 ??4OneLocalGame@@QAEAAU0@ABU0@@Z

; 190  : 			return true;

  00a9f	c6 45 e3 01	 mov	 BYTE PTR $T202803[ebp], 1
  00aa3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00aaa	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  00aad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00ab3	8a 45 e3	 mov	 al, BYTE PTR $T202803[ebp]
  00ab6	eb 53		 jmp	 SHORT $L200255
$L200266:

; 191  : 		}else
; 192  : 		{
; 193  : 			m_vecGame.erase( it1 );

  00ab8	8b 45 f0	 mov	 eax, DWORD PTR _it1$[ebp]
  00abb	50		 push	 eax
  00abc	8d 4d dc	 lea	 ecx, DWORD PTR $T202804[ebp]
  00abf	51		 push	 ecx
  00ac0	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00ac3	83 c1 04	 add	 ecx, 4
  00ac6	e8 00 00 00 00	 call	 ?erase@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::erase

; 194  : 			og.clear();

  00acb	8b 4d 24	 mov	 ecx, DWORD PTR _og$[ebp]
  00ace	e8 00 00 00 00	 call	 ?clear@OneLocalGame@@QAEXXZ ; OneLocalGame::clear

; 195  : 			return false;

  00ad3	c6 45 db 00	 mov	 BYTE PTR $T202805[ebp], 0
  00ad7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ade	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  00ae1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00ae7	8a 45 db	 mov	 al, BYTE PTR $T202805[ebp]
  00aea	eb 1f		 jmp	 SHORT $L200255
$L200265:

; 196  : 		}
; 197  : 	}else
; 198  : 	{
; 199  : 		og.clear();

  00aec	8b 4d 24	 mov	 ecx, DWORD PTR _og$[ebp]
  00aef	e8 00 00 00 00	 call	 ?clear@OneLocalGame@@QAEXXZ ; OneLocalGame::clear

; 200  : 		return false;

  00af4	c6 45 da 00	 mov	 BYTE PTR $T202806[ebp], 0
  00af8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00aff	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  00b02	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00b08	8a 45 da	 mov	 al, BYTE PTR $T202806[ebp]
$L200255:

; 201  : 	}
; 202  : }

  00b0b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00b0e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00b15	8b e5		 mov	 esp, ebp
  00b17	5d		 pop	 ebp
  00b18	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
text$x	SEGMENT
$L202807:
  00126	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  00129	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?ILocalGameData_GetGameByID@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAUOneLocalGame@@@Z:
  0012f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202809
  00134	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ILocalGameData_GetGameByID@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAUOneLocalGame@@@Z ENDP ; LocalGameData::ILocalGameData_GetGameByID
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
; Function compile flags: /Odt
;	COMDAT ??4OneLocalGame@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4OneLocalGame@@QAEAAU0@ABU0@@Z PROC NEAR		; OneLocalGame::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00017	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0001a	51		 push	 ecx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00027	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0002a	83 c2 38	 add	 edx, 56			; 00000038H
  0002d	52		 push	 edx
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 38	 add	 ecx, 56			; 00000038H
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0003d	83 c0 54	 add	 eax, 84			; 00000054H
  00040	50		 push	 eax
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	83 c1 54	 add	 ecx, 84			; 00000054H
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00050	83 c1 70	 add	 ecx, 112		; 00000070H
  00053	51		 push	 ecx
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	83 c1 70	 add	 ecx, 112		; 00000070H
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00060	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00063	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00066	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  0006c	89 8a 8c 00 00
	00		 mov	 DWORD PTR [edx+140], ecx
  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
??4OneLocalGame@@QAEAAU0@ABU0@@Z ENDP			; OneLocalGame::operator=
_TEXT	ENDS
PUBLIC	?NotifyQQItemCountChange@LocalGameData@@AAEXXZ	; LocalGameData::NotifyQQItemCountChange
EXTRN	?GetFileSize@YL_FileInfo@@SA_NPBDPAI1@Z:NEAR	; YL_FileInfo::GetFileSize
xdata$x	SEGMENT
$T202832 DD	0ffffffffH
	DD	FLAT:$L202821
	DD	00H
	DD	FLAT:$L202822
	DD	01H
	DD	FLAT:$L202823
	DD	02H
	DD	FLAT:$L202824
	DD	03H
	DD	FLAT:$L202825
	DD	04H
	DD	FLAT:$L202826
	DD	05H
	DD	FLAT:$L202827
$T202829 DD	019930520H
	DD	07H
	DD	FLAT:$T202832
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -184						; size = 4
$T202820 = -178						; size = 1
$T202819 = -177						; size = 1
$T202818 = -176						; size = 4
$T202817 = -172						; size = 4
$T202816 = -168						; size = 4
_olg$ = -164						; size = 144
__$ArrayPad$ = -20					; size = 4
_it1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_strID$ = 8						; size = 28
_strName$ = 36						; size = 28
_strPicPath$ = 64					; size = 28
_strSwfPath$ = 92					; size = 28
_strIntro$ = 120					; size = 28
_type$ = 148						; size = 4
_strMD5$ = 152						; size = 28
?ILocalGameData_AddGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0000I0@Z PROC NEAR ; LocalGameData::ILocalGameData_AddGame
; _this$ = ecx

; 206  : {

  00b20	55		 push	 ebp
  00b21	8b ec		 mov	 ebp, esp
  00b23	6a ff		 push	 -1
  00b25	68 00 00 00 00	 push	 __ehhandler$?ILocalGameData_AddGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0000I0@Z
  00b2a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00b30	50		 push	 eax
  00b31	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00b38	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00b3e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00b43	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00b46	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00b4c	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5

; 207  : 	//
; 208  : 	LocalGameList::iterator it1 = m_vecGame.begin();

  00b53	8d 45 f0	 lea	 eax, DWORD PTR _it1$[ebp]
  00b56	50		 push	 eax
  00b57	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b5d	83 c1 04	 add	 ecx, 4
  00b60	e8 00 00 00 00	 call	 ?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::begin

; 209  : 	for( ; it1 != m_vecGame.end(); it1 ++ )

  00b65	eb 11		 jmp	 SHORT $L200290
$L200291:
  00b67	6a 00		 push	 0
  00b69	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T202816[ebp]
  00b6f	51		 push	 ecx
  00b70	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00b73	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AV012@H@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++
$L200290:
  00b78	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR $T202817[ebp]
  00b7e	52		 push	 edx
  00b7f	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b85	83 c1 04	 add	 ecx, 4
  00b88	e8 00 00 00 00	 call	 ?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end
  00b8d	50		 push	 eax
  00b8e	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00b91	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator!=
  00b96	0f b6 c0	 movzx	 eax, al
  00b99	85 c0		 test	 eax, eax
  00b9b	74 21		 je	 SHORT $L200292

; 210  : 	{
; 211  : 		if( strID == it1->strID)

  00b9d	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00ba0	e8 00 00 00 00	 call	 ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
  00ba5	50		 push	 eax
  00ba6	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  00ba9	51		 push	 ecx
  00baa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
  00bb0	83 c4 08	 add	 esp, 8
  00bb3	0f b6 d0	 movzx	 edx, al
  00bb6	85 d2		 test	 edx, edx
  00bb8	74 02		 je	 SHORT $L200293

; 212  : 		{
; 213  : 			break;

  00bba	eb 02		 jmp	 SHORT $L200292
$L200293:

; 214  : 		}
; 215  : 	}

  00bbc	eb a9		 jmp	 SHORT $L200291
$L200292:

; 216  : 	if( it1 != m_vecGame.end() )

  00bbe	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T202818[ebp]
  00bc4	50		 push	 eax
  00bc5	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00bcb	83 c1 04	 add	 ecx, 4
  00bce	e8 00 00 00 00	 call	 ?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end
  00bd3	50		 push	 eax
  00bd4	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00bd7	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator!=
  00bdc	0f b6 c8	 movzx	 ecx, al
  00bdf	85 c9		 test	 ecx, ecx
  00be1	74 66		 je	 SHORT $L200295

; 217  : 	{
; 218  : 		return false;

  00be3	c6 85 4f ff ff
	ff 00		 mov	 BYTE PTR $T202819[ebp], 0
  00bea	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00bee	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  00bf1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00bf7	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00bfb	8d 4d 24	 lea	 ecx, DWORD PTR _strName$[ebp]
  00bfe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00c04	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00c08	8d 4d 40	 lea	 ecx, DWORD PTR _strPicPath$[ebp]
  00c0b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00c11	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00c15	8d 4d 5c	 lea	 ecx, DWORD PTR _strSwfPath$[ebp]
  00c18	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00c1e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00c22	8d 4d 78	 lea	 ecx, DWORD PTR _strIntro$[ebp]
  00c25	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00c2b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c32	8d 8d 98 00 00
	00		 lea	 ecx, DWORD PTR _strMD5$[ebp]
  00c38	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00c3e	8a 85 4f ff ff
	ff		 mov	 al, BYTE PTR $T202819[ebp]
  00c44	e9 fe 00 00 00	 jmp	 $L200285
$L200295:

; 219  : 	}
; 220  : 	//
; 221  : 	OneLocalGame olg;

  00c49	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _olg$[ebp]
  00c4f	e8 00 00 00 00	 call	 ??0OneLocalGame@@QAE@XZ	; OneLocalGame::OneLocalGame
  00c54	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 222  : 	olg.strID = strID;

  00c58	8d 55 08	 lea	 edx, DWORD PTR _strID$[ebp]
  00c5b	52		 push	 edx
  00c5c	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _olg$[ebp]
  00c62	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 223  : 	olg.strName = strName;

  00c68	8d 45 24	 lea	 eax, DWORD PTR _strName$[ebp]
  00c6b	50		 push	 eax
  00c6c	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _olg$[ebp+28]
  00c72	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 224  : 	olg.strGamePath = strSwfPath;

  00c78	8d 4d 5c	 lea	 ecx, DWORD PTR _strSwfPath$[ebp]
  00c7b	51		 push	 ecx
  00c7c	8d 4d 94	 lea	 ecx, DWORD PTR _olg$[ebp+56]
  00c7f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 225  : 	olg.strIntro = strIntro;

  00c85	8d 55 78	 lea	 edx, DWORD PTR _strIntro$[ebp]
  00c88	52		 push	 edx
  00c89	8d 4d cc	 lea	 ecx, DWORD PTR _olg$[ebp+112]
  00c8c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 226  : 	YL_FileInfo::GetFileSize( olg.strGamePath.c_str(), &(olg.uiFileSize) );

  00c92	6a 00		 push	 0
  00c94	8d 45 e8	 lea	 eax, DWORD PTR _olg$[ebp+140]
  00c97	50		 push	 eax
  00c98	8d 4d 94	 lea	 ecx, DWORD PTR _olg$[ebp+56]
  00c9b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00ca1	50		 push	 eax
  00ca2	e8 00 00 00 00	 call	 ?GetFileSize@YL_FileInfo@@SA_NPBDPAI1@Z ; YL_FileInfo::GetFileSize
  00ca7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 227  : 	olg.strPicPath  = strPicPath;	//

  00caa	8d 4d 40	 lea	 ecx, DWORD PTR _strPicPath$[ebp]
  00cad	51		 push	 ecx
  00cae	8d 4d b0	 lea	 ecx, DWORD PTR _olg$[ebp+84]
  00cb1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 228  : 
; 229  : 	m_vecGame.push_back( olg );

  00cb7	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR _olg$[ebp]
  00cbd	52		 push	 edx
  00cbe	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00cc4	83 c1 04	 add	 ecx, 4
  00cc7	e8 00 00 00 00	 call	 ?push_back@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXABUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::push_back

; 230  : 	NotifyQQItemCountChange();

  00ccc	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00cd2	e8 00 00 00 00	 call	 ?NotifyQQItemCountChange@LocalGameData@@AAEXXZ ; LocalGameData::NotifyQQItemCountChange

; 231  : 	return true;

  00cd7	c6 85 4e ff ff
	ff 01		 mov	 BYTE PTR $T202820[ebp], 1
  00cde	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00ce2	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _olg$[ebp]
  00ce8	e8 00 00 00 00	 call	 ??1OneLocalGame@@QAE@XZ
  00ced	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00cf1	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  00cf4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00cfa	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00cfe	8d 4d 24	 lea	 ecx, DWORD PTR _strName$[ebp]
  00d01	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00d07	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00d0b	8d 4d 40	 lea	 ecx, DWORD PTR _strPicPath$[ebp]
  00d0e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00d14	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00d18	8d 4d 5c	 lea	 ecx, DWORD PTR _strSwfPath$[ebp]
  00d1b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00d21	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00d25	8d 4d 78	 lea	 ecx, DWORD PTR _strIntro$[ebp]
  00d28	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00d2e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d35	8d 8d 98 00 00
	00		 lea	 ecx, DWORD PTR _strMD5$[ebp]
  00d3b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00d41	8a 85 4e ff ff
	ff		 mov	 al, BYTE PTR $T202820[ebp]
$L200285:

; 232  : }

  00d47	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00d4a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00d51	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d54	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d59	8b e5		 mov	 esp, ebp
  00d5b	5d		 pop	 ebp
  00d5c	c2 ac 00	 ret	 172			; 000000acH
_TEXT	ENDS
text$x	SEGMENT
$L202821:
  00139	8d 8d 98 00 00
	00		 lea	 ecx, DWORD PTR _strMD5$[ebp]
  0013f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202822:
  00145	8d 4d 78	 lea	 ecx, DWORD PTR _strIntro$[ebp]
  00148	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202823:
  0014e	8d 4d 5c	 lea	 ecx, DWORD PTR _strSwfPath$[ebp]
  00151	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202824:
  00157	8d 4d 40	 lea	 ecx, DWORD PTR _strPicPath$[ebp]
  0015a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202825:
  00160	8d 4d 24	 lea	 ecx, DWORD PTR _strName$[ebp]
  00163	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202826:
  00169	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  0016c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L202827:
  00172	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _olg$[ebp]
  00178	e9 00 00 00 00	 jmp	 ??1OneLocalGame@@QAE@XZ
__ehhandler$?ILocalGameData_AddGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0000I0@Z:
  0017d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202829
  00182	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ILocalGameData_AddGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0000I0@Z ENDP ; LocalGameData::ILocalGameData_AddGame
EXTRN	__imp__DeleteFileA@4:NEAR
xdata$x	SEGMENT
$T202844 DD	0ffffffffH
	DD	FLAT:$L202840
$T202842 DD	019930520H
	DD	01H
	DD	FLAT:$T202844
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T202839 = -34						; size = 1
$T202838 = -33						; size = 1
$T202837 = -32						; size = 4
$T202836 = -28						; size = 4
$T202835 = -24						; size = 4
$T202834 = -20						; size = 4
_it1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_strID$ = 8						; size = 28
?ILocalGameData_DelGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; LocalGameData::ILocalGameData_DelGame
; _this$ = ecx

; 235  : {

  00d60	55		 push	 ebp
  00d61	8b ec		 mov	 ebp, esp
  00d63	6a ff		 push	 -1
  00d65	68 00 00 00 00	 push	 __ehhandler$?ILocalGameData_DelGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00d6a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00d70	50		 push	 eax
  00d71	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00d78	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00d7b	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00d7e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 236  : 	LocalGameList::iterator it1 = m_vecGame.begin();

  00d85	8d 45 f0	 lea	 eax, DWORD PTR _it1$[ebp]
  00d88	50		 push	 eax
  00d89	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d8c	83 c1 04	 add	 ecx, 4
  00d8f	e8 00 00 00 00	 call	 ?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::begin

; 237  : 	for( ; it1 != m_vecGame.end(); it1 ++ )

  00d94	eb 0e		 jmp	 SHORT $L200307
$L200308:
  00d96	6a 00		 push	 0
  00d98	8d 4d ec	 lea	 ecx, DWORD PTR $T202834[ebp]
  00d9b	51		 push	 ecx
  00d9c	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00d9f	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AV012@H@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++
$L200307:
  00da4	8d 55 e8	 lea	 edx, DWORD PTR $T202835[ebp]
  00da7	52		 push	 edx
  00da8	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00dab	83 c1 04	 add	 ecx, 4
  00dae	e8 00 00 00 00	 call	 ?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end
  00db3	50		 push	 eax
  00db4	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00db7	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator!=
  00dbc	0f b6 c0	 movzx	 eax, al
  00dbf	85 c0		 test	 eax, eax
  00dc1	74 21		 je	 SHORT $L200309

; 238  : 	{
; 239  : 		if( strID == it1->strID )

  00dc3	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00dc6	e8 00 00 00 00	 call	 ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
  00dcb	50		 push	 eax
  00dcc	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  00dcf	51		 push	 ecx
  00dd0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
  00dd6	83 c4 08	 add	 esp, 8
  00dd9	0f b6 d0	 movzx	 edx, al
  00ddc	85 d2		 test	 edx, edx
  00dde	74 02		 je	 SHORT $L200310

; 240  : 		{
; 241  : 			break;

  00de0	eb 02		 jmp	 SHORT $L200309
$L200310:

; 242  : 		}
; 243  : 	}

  00de2	eb b2		 jmp	 SHORT $L200308
$L200309:

; 244  : 	if( it1 != m_vecGame.end() )

  00de4	8d 45 e4	 lea	 eax, DWORD PTR $T202836[ebp]
  00de7	50		 push	 eax
  00de8	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00deb	83 c1 04	 add	 ecx, 4
  00dee	e8 00 00 00 00	 call	 ?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end
  00df3	50		 push	 eax
  00df4	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00df7	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator!=
  00dfc	0f b6 c8	 movzx	 ecx, al
  00dff	85 c9		 test	 ecx, ecx
  00e01	74 68		 je	 SHORT $L200312

; 245  : 	{
; 246  : 		//
; 247  : 		::DeleteFile( it1->strPicPath.c_str() );

  00e03	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00e06	e8 00 00 00 00	 call	 ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
  00e0b	83 c0 54	 add	 eax, 84			; 00000054H
  00e0e	8b c8		 mov	 ecx, eax
  00e10	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00e16	50		 push	 eax
  00e17	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4

; 248  : 		//swf
; 249  : 		::DeleteFile( it1->strGamePath.c_str() );

  00e1d	8d 4d f0	 lea	 ecx, DWORD PTR _it1$[ebp]
  00e20	e8 00 00 00 00	 call	 ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
  00e25	83 c0 38	 add	 eax, 56			; 00000038H
  00e28	8b c8		 mov	 ecx, eax
  00e2a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00e30	50		 push	 eax
  00e31	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4

; 250  : 
; 251  : 		m_vecGame.erase( it1 );

  00e37	8b 55 f0	 mov	 edx, DWORD PTR _it1$[ebp]
  00e3a	52		 push	 edx
  00e3b	8d 45 e0	 lea	 eax, DWORD PTR $T202837[ebp]
  00e3e	50		 push	 eax
  00e3f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e42	83 c1 04	 add	 ecx, 4
  00e45	e8 00 00 00 00	 call	 ?erase@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::erase

; 252  : 		NotifyQQItemCountChange();

  00e4a	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e4d	e8 00 00 00 00	 call	 ?NotifyQQItemCountChange@LocalGameData@@AAEXXZ ; LocalGameData::NotifyQQItemCountChange

; 253  : 		return true;

  00e52	c6 45 df 01	 mov	 BYTE PTR $T202838[ebp], 1
  00e56	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00e5d	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  00e60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00e66	8a 45 df	 mov	 al, BYTE PTR $T202838[ebp]
  00e69	eb 17		 jmp	 SHORT $L200302
$L200312:

; 254  : 	}else
; 255  : 	{
; 256  : 		return false;

  00e6b	c6 45 de 00	 mov	 BYTE PTR $T202839[ebp], 0
  00e6f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00e76	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  00e79	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00e7f	8a 45 de	 mov	 al, BYTE PTR $T202839[ebp]
$L200302:

; 257  : 	}	
; 258  : }

  00e82	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00e85	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00e8c	8b e5		 mov	 esp, ebp
  00e8e	5d		 pop	 ebp
  00e8f	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
text$x	SEGMENT
$L202840:
  00187	8d 4d 08	 lea	 ecx, DWORD PTR _strID$[ebp]
  0018a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?ILocalGameData_DelGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00190	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202842
  00195	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ILocalGameData_DelGame@LocalGameData@@UAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; LocalGameData::ILocalGameData_DelGame
PUBLIC	??$back_inserter@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@@Z ; std::back_inserter<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >
PUBLIC	??$copy@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@@Z ; std::copy<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T202849 = -16						; size = 4
$T202848 = -12						; size = 4
$T202847 = -8						; size = 4
$T202846 = -4						; size = 4
_lgl$ = 8						; size = 4
?ILocalGameData_GetAllGame@LocalGameData@@UAE_NAAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@Z PROC NEAR ; LocalGameData::ILocalGameData_GetAllGame
; _this$ = ecx

; 261  : {

  00ea0	55		 push	 ebp
  00ea1	8b ec		 mov	 ebp, esp
  00ea3	83 ec 14	 sub	 esp, 20			; 00000014H
  00ea6	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 	lgl.clear();

  00ea9	8b 4d 08	 mov	 ecx, DWORD PTR _lgl$[ebp]
  00eac	e8 00 00 00 00	 call	 ?clear@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::clear

; 263  : 	copy( m_vecGame.begin(), m_vecGame.end(), back_inserter(lgl) );

  00eb1	8b 45 08	 mov	 eax, DWORD PTR _lgl$[ebp]
  00eb4	50		 push	 eax
  00eb5	8d 4d fc	 lea	 ecx, DWORD PTR $T202846[ebp]
  00eb8	51		 push	 ecx
  00eb9	e8 00 00 00 00	 call	 ??$back_inserter@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@@Z ; std::back_inserter<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >
  00ebe	83 c4 08	 add	 esp, 8
  00ec1	8b 10		 mov	 edx, DWORD PTR [eax]
  00ec3	52		 push	 edx
  00ec4	8d 45 f8	 lea	 eax, DWORD PTR $T202847[ebp]
  00ec7	50		 push	 eax
  00ec8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00ecb	83 c1 04	 add	 ecx, 4
  00ece	e8 00 00 00 00	 call	 ?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end
  00ed3	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ed5	51		 push	 ecx
  00ed6	8d 55 f4	 lea	 edx, DWORD PTR $T202848[ebp]
  00ed9	52		 push	 edx
  00eda	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00edd	83 c1 04	 add	 ecx, 4
  00ee0	e8 00 00 00 00	 call	 ?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::begin
  00ee5	8b 00		 mov	 eax, DWORD PTR [eax]
  00ee7	50		 push	 eax
  00ee8	8d 4d f0	 lea	 ecx, DWORD PTR $T202849[ebp]
  00eeb	51		 push	 ecx
  00eec	e8 00 00 00 00	 call	 ??$copy@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@@Z ; std::copy<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >
  00ef1	83 c4 10	 add	 esp, 16			; 00000010H

; 264  : 	return true;

  00ef4	b0 01		 mov	 al, 1

; 265  : }

  00ef6	8b e5		 mov	 esp, ebp
  00ef8	5d		 pop	 ebp
  00ef9	c2 04 00	 ret	 4
?ILocalGameData_GetAllGame@LocalGameData@@UAE_NAAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@Z ENDP ; LocalGameData::ILocalGameData_GetAllGame
_TEXT	ENDS
PUBLIC	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z	; ATL::_AtlInstallStringThunk
PUBLIC	?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableW@12:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWThunk, COMDAT

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 184  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
; 185  : 		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetEnvironmentVariableW@12
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
  0000e	68 14 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 186  : 
; 187  : 	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);

  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 0c	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  00022	52		 push	 edx
  00023	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  00026	50		 push	 eax
  00027	ff 15 14 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20

; 188  : }

  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWThunk
_TEXT	ENDS
PUBLIC	?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
PUBLIC	??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
EXTRN	__imp__GetVersion@0:NEAR
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT
?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA DB 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT
??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 DD 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
; Function compile flags: /Odt
_BSS	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT
_pfn$ = -4						; size = 4
_ppThunk$ = 8						; size = 4
_pfnWin9x$ = 12						; size = 4
_pfnNT$ = 16						; size = 4
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z PROC NEAR	; ATL::_AtlInstallStringThunk, COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 116  : #pragma warning (push)
; 117  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 118  : 
; 119  : 	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
  00009	83 e0 01	 and	 eax, 1
  0000c	75 25		 jne	 SHORT $L25641
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
  00014	83 c9 01	 or	 ecx, 1
  00017	89 0d 00 00 00
	00		 mov	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, ecx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00023	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00028	f7 d8		 neg	 eax
  0002a	1b c0		 sbb	 eax, eax
  0002c	f7 d8		 neg	 eax
  0002e	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L25641:

; 120  : 	
; 121  : #pragma warning (pop)
; 122  : 
; 123  : 	void* pfn;
; 124  : 	if (s_bWin9x)

  00033	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  0003a	85 d2		 test	 edx, edx
  0003c	74 08		 je	 SHORT $L25643

; 125  : 		pfn = pfnWin9x;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _pfnWin9x$[ebp]
  00041	89 45 fc	 mov	 DWORD PTR _pfn$[ebp], eax

; 126  : 	else

  00044	eb 06		 jmp	 SHORT $L25644
$L25643:

; 127  : 	{
; 128  : #ifdef _CSTRING_ALWAYS_THUNK
; 129  : 		pfn = pfnWin9x;
; 130  : 		(void)pfnNT;
; 131  : #else
; 132  : 		pfn = pfnNT;

  00046	8b 4d 10	 mov	 ecx, DWORD PTR _pfnNT$[ebp]
  00049	89 4d fc	 mov	 DWORD PTR _pfn$[ebp], ecx
$L25644:

; 133  : #endif
; 134  : 	}
; 135  : 	InterlockedExchangePointer(ppThunk, pfn);

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _pfn$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 08	 mov	 eax, DWORD PTR _ppThunk$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 136  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ENDP	; ATL::_AtlInstallStringThunk
_TEXT	ENDS
PUBLIC	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
PUBLIC	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
PUBLIC	??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z		; ATL::CW2AEX<128>::CW2AEX<128>
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
PUBLIC	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CW2AEX<128>::operator char *
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
EXTRN	__imp__MultiByteToWideChar@24:NEAR
EXTRN	__imp__GetEnvironmentVariableA@12:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202865 DD	0ffffffffH
	DD	FLAT:$L202859
	DD	00H
	DD	FLAT:$L202860
$T202862 DD	019930520H
	DD	02H
	DD	FLAT:$T202865
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
$T202858 = -312						; size = 4
$T202857 = -308						; size = 4
$T202856 = -304						; size = 4
_pszBufferA$ = -300					; size = 132
_nSizeW$ = -160						; size = 4
_pszNameA$ = -156					; size = 132
__$ArrayPad$ = -20					; size = 4
_nSizeA$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWFake, COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 160  : 	ULONG nSizeA;
; 161  : 	ULONG nSizeW;
; 162  : 	CTempBuffer<char> pszBufferA;

  00026	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 163  : 	CW2A pszNameA(pszName);

  00038	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  0003b	50		 push	 eax
  0003c	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ; ATL::CW2AEX<128>::CW2AEX<128>
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 164  : 
; 165  : 	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00055	e8 00 00 00 00	 call	 ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ; ATL::CW2AEX<128>::operator char *
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12
  00061	89 45 f0	 mov	 DWORD PTR _nSizeA$[ebp], eax

; 166  : 	if (nSizeA == 0)

  00064	83 7d f0 00	 cmp	 DWORD PTR _nSizeA$[ebp], 0
  00068	75 36		 jne	 SHORT $L25746

; 167  : 		return 0;

  0006a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T202856[ebp], 0
  00074	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00078	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  0007e	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  00083	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00090	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  00095	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T202856[ebp]
  0009b	e9 ee 00 00 00	 jmp	 $L25687
$L25746:

; 168  : 
; 169  : 	pszBufferA.Allocate(nSizeA*2);

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _nSizeA$[ebp]
  000a3	d1 e1		 shl	 ecx, 1
  000a5	51		 push	 ecx
  000a6	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000ac	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 170  : 	::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA);

  000b1	8b 55 f0	 mov	 edx, DWORD PTR _nSizeA$[ebp]
  000b4	52		 push	 edx
  000b5	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000bb	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000c0	50		 push	 eax
  000c1	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  000c7	e8 00 00 00 00	 call	 ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ; ATL::CW2AEX<128>::operator char *
  000cc	50		 push	 eax
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12

; 171  : 
; 172  : 	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);

  000d3	6a 00		 push	 0
  000d5	6a 00		 push	 0
  000d7	6a ff		 push	 -1
  000d9	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000df	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  000ec	50		 push	 eax
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  000f3	89 85 60 ff ff
	ff		 mov	 DWORD PTR _nSizeW$[ebp], eax

; 173  : 	if (nSize == 0)

  000f9	83 7d 10 00	 cmp	 DWORD PTR _nSize$[ebp], 0
  000fd	75 35		 jne	 SHORT $L25748

; 174  : 		return nSizeW;

  000ff	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nSizeW$[ebp]
  00105	89 85 cc fe ff
	ff		 mov	 DWORD PTR $T202857[ebp], eax
  0010b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0010f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00115	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00121	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00127	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  0012c	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T202857[ebp]
  00132	eb 5a		 jmp	 SHORT $L25687
$L25748:

; 175  : 	ATLASSERT(nSize >= nSizeW);
; 176  : 	::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW);

  00134	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _nSizeW$[ebp]
  0013a	51		 push	 ecx
  0013b	8b 55 0c	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  0013e	52		 push	 edx
  0013f	6a ff		 push	 -1
  00141	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00147	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  0014c	50		 push	 eax
  0014d	6a 00		 push	 0
  0014f	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00154	50		 push	 eax
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 177  : 
; 178  : 	return nSizeW;

  0015b	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nSizeW$[ebp]
  00161	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T202858[ebp], eax
  00167	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0016b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00171	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  00176	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0017d	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00183	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  00188	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T202858[ebp]
$L25687:

; 179  : }

  0018e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00191	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00198	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202859:
  00000	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
$L202860:
  0000b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202862
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 158  : 	return( g_pfnGetThreadACP() );

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 159  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\httpdown\localgamedata.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ILocalGameData_GetGameCount@LocalGameData@@UAEIXZ PROC NEAR ; LocalGameData::ILocalGameData_GetGameCount
; _this$ = ecx

; 268  : {

  00f00	55		 push	 ebp
  00f01	8b ec		 mov	 ebp, esp
  00f03	51		 push	 ecx
  00f04	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 269  : 	return (unsigned int)(m_vecGame.size());

  00f07	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f0a	83 c1 04	 add	 ecx, 4
  00f0d	e8 00 00 00 00	 call	 ?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size

; 270  : }

  00f12	8b e5		 mov	 esp, ebp
  00f14	5d		 pop	 ebp
  00f15	c3		 ret	 0
?ILocalGameData_GetGameCount@LocalGameData@@UAEIXZ ENDP	; LocalGameData::ILocalGameData_GetGameCount
_TEXT	ENDS
PUBLIC	??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
PUBLIC	??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
PUBLIC	??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
PUBLIC	??_R0?AVIQQItemCountChangeObserver@@@8		; IQQItemCountChangeObserver `RTTI Type Descriptor'
PUBLIC	??_R0?AVIMessageObserver@@@8			; IMessageObserver `RTTI Type Descriptor'
PUBLIC	??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
PUBLIC	?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
EXTRN	___RTDynamicCast:NEAR
EXTRN	?AfxGetMessageManager@@YAPAVIMessageManager@@XZ:NEAR ; AfxGetMessageManager
xdata$x	SEGMENT
$T202879 DD	0ffffffffH
	DD	FLAT:$L202875
$T202877 DD	019930520H
	DD	01H
	DD	FLAT:$T202879
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0?AVIQQItemCountChangeObserver@@@8
_DATA	SEGMENT
??_R0?AVIQQItemCountChangeObserver@@@8 DD FLAT:??_7type_info@@6B@ ; IQQItemCountChangeObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIQQItemCountChangeObserver@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT
??_R0?AVIMessageObserver@@@8 DD FLAT:??_7type_info@@6B@	; IMessageObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIMessageObserver@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVIMessageObserver@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
tv69 = -48						; size = 4
_this$ = -44						; size = 4
$T202874 = -40						; size = 4
$T202873 = -36						; size = 4
_pOb$200862 = -32					; size = 4
_itOb$200855 = -28					; size = 4
_listOb$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
?NotifyQQItemCountChange@LocalGameData@@AAEXXZ PROC NEAR ; LocalGameData::NotifyQQItemCountChange
; _this$ = ecx

; 273  : {

  00f20	55		 push	 ebp
  00f21	8b ec		 mov	 ebp, esp
  00f23	6a ff		 push	 -1
  00f25	68 00 00 00 00	 push	 __ehhandler$?NotifyQQItemCountChange@LocalGameData@@AAEXXZ
  00f2a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00f30	50		 push	 eax
  00f31	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00f38	83 ec 24	 sub	 esp, 36			; 00000024H
  00f3b	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 274  : 	list<IMessageObserver*> listOb;

  00f3e	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00f41	e8 00 00 00 00	 call	 ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
  00f46	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 275  : 	AfxGetMessageManager()->QueryObservers( ID_MESSAGE_QQ_ITEM_CHANGE,listOb);

  00f4d	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  00f52	89 45 d0	 mov	 DWORD PTR tv69[ebp], eax
  00f55	8d 45 e8	 lea	 eax, DWORD PTR _listOb$[ebp]
  00f58	50		 push	 eax
  00f59	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_QQ_ITEM_CHANGE
  00f5e	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  00f61	8b 11		 mov	 edx, DWORD PTR [ecx]
  00f63	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  00f66	ff 52 0c	 call	 DWORD PTR [edx+12]

; 276  : 
; 277  : 	for( list<IMessageObserver*>::iterator itOb = listOb.begin();itOb != listOb.end();itOb++ )

  00f69	8d 45 e4	 lea	 eax, DWORD PTR _itOb$200855[ebp]
  00f6c	50		 push	 eax
  00f6d	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00f70	e8 00 00 00 00	 call	 ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
  00f75	eb 0e		 jmp	 SHORT $L200859
$L200860:
  00f77	6a 00		 push	 0
  00f79	8d 4d dc	 lea	 ecx, DWORD PTR $T202873[ebp]
  00f7c	51		 push	 ecx
  00f7d	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$200855[ebp]
  00f80	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
$L200859:
  00f85	8d 55 d8	 lea	 edx, DWORD PTR $T202874[ebp]
  00f88	52		 push	 edx
  00f89	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00f8c	e8 00 00 00 00	 call	 ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
  00f91	50		 push	 eax
  00f92	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$200855[ebp]
  00f95	e8 00 00 00 00	 call	 ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
  00f9a	0f b6 c0	 movzx	 eax, al
  00f9d	85 c0		 test	 eax, eax
  00f9f	74 3d		 je	 SHORT $L200861

; 278  : 	{
; 279  : 		IQQItemCountChangeObserver* pOb = dynamic_cast<IQQItemCountChangeObserver*>(*itOb);

  00fa1	6a 00		 push	 0
  00fa3	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIQQItemCountChangeObserver@@@8
  00fa8	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIMessageObserver@@@8
  00fad	6a 00		 push	 0
  00faf	8d 4d e4	 lea	 ecx, DWORD PTR _itOb$200855[ebp]
  00fb2	e8 00 00 00 00	 call	 ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
  00fb7	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fb9	51		 push	 ecx
  00fba	e8 00 00 00 00	 call	 ___RTDynamicCast
  00fbf	83 c4 14	 add	 esp, 20			; 00000014H
  00fc2	89 45 e0	 mov	 DWORD PTR _pOb$200862[ebp], eax

; 280  : 		pOb->IQQItemChangeOb_CountChange( m_vecGame.size() );

  00fc5	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00fc8	83 c1 04	 add	 ecx, 4
  00fcb	e8 00 00 00 00	 call	 ?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size
  00fd0	50		 push	 eax
  00fd1	8b 55 e0	 mov	 edx, DWORD PTR _pOb$200862[ebp]
  00fd4	8b 02		 mov	 eax, DWORD PTR [edx]
  00fd6	8b 4d e0	 mov	 ecx, DWORD PTR _pOb$200862[ebp]
  00fd9	ff 50 04	 call	 DWORD PTR [eax+4]

; 281  : 	}

  00fdc	eb 99		 jmp	 SHORT $L200860
$L200861:

; 282  : }

  00fde	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00fe5	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00fe8	e8 00 00 00 00	 call	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
  00fed	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00ff0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00ff7	8b e5		 mov	 esp, ebp
  00ff9	5d		 pop	 ebp
  00ffa	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L202875:
  0019a	8d 4d e8	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0019d	e9 00 00 00 00	 jmp	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
__ehhandler$?NotifyQQItemCountChange@LocalGameData@@AAEXXZ:
  001a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202877
  001a7	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NotifyQQItemCountChange@LocalGameData@@AAEXXZ ENDP	; LocalGameData::NotifyQQItemCountChange
PUBLIC	?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringW@24:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWThunk, COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 217  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CompareStringW@24
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ; ATL::CompareStringWFake
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A ; ATL::_strthunks
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : 
; 219  : 	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);

  0001b	8b 4d 1c	 mov	 ecx, DWORD PTR _nLength2$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 18	 mov	 edx, DWORD PTR _pszString2$[ebp]
  00022	52		 push	 edx
  00023	8b 45 14	 mov	 eax, DWORD PTR _nLength1$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR _pszString1$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR _lcid$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A

; 220  : }

  00039	5d		 pop	 ebp
  0003a	c2 18 00	 ret	 24			; 00000018H
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWThunk
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
PUBLIC	?AtlW2AHelper@@YGPADPADPB_WHI@Z			; AtlW2AHelper
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
EXTRN	__alloca_probe:NEAR
EXTRN	__imp__lstrlenW@4:NEAR
EXTRN	__imp__CompareStringA@24:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202897 DD	0ffffffffH
	DD	FLAT:$L202892
$T202894 DD	019930520H
	DD	01H
	DD	FLAT:$T202897
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
tv147 = -68						; size = 4
tv142 = -64						; size = 4
tv149 = -60						; size = 4
tv89 = -56						; size = 4
tv84 = -52						; size = 4
tv91 = -48						; size = 4
$T202891 = -44						; size = 4
_pszAString1$ = -40					; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__convert_ex$ = -32					; size = 4
__acp_ex$ = -28						; size = 4
_pszAString2$ = -24					; size = 4
__lpw_ex$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWFake, COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 38	 sub	 esp, 56			; 00000038H

; 193  : 	USES_CONVERSION_EX;

  0001b	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00020	89 45 e4	 mov	 DWORD PTR __acp_ex$[ebp], eax
  00023	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 194  : 	
; 195  : 	LPCSTR pszAString1 = NULL;

  00032	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pszAString1$[ebp], 0

; 196  : 	if(pszString1 != NULL)

  00039	83 7d 10 00	 cmp	 DWORD PTR _pszString1$[ebp], 0
  0003d	0f 84 98 00 00
	00		 je	 $L25772

; 197  : 	{
; 198  : 		pszAString1 = W2A_EX(pszString1,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00043	8b 45 10	 mov	 eax, DWORD PTR _pszString1$[ebp]
  00046	89 45 f0	 mov	 DWORD PTR __lpw_ex$[ebp], eax
  00049	83 7d f0 00	 cmp	 DWORD PTR __lpw_ex$[ebp], 0
  0004d	75 09		 jne	 SHORT $L202885
  0004f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
  00056	eb 6d		 jmp	 SHORT $L202886
$L202885:
  00058	8b 4d f0	 mov	 ecx, DWORD PTR __lpw_ex$[ebp]
  0005b	51		 push	 ecx
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00062	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00066	89 55 e0	 mov	 DWORD PTR __convert_ex$[ebp], edx
  00069	81 7d e0 00 04
	00 00		 cmp	 DWORD PTR __convert_ex$[ebp], 1024 ; 00000400H
  00070	7f 2c		 jg	 SHORT $L202883
  00072	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0007b	83 c4 04	 add	 esp, 4
  0007e	0f b6 c8	 movzx	 ecx, al
  00081	85 c9		 test	 ecx, ecx
  00083	74 19		 je	 SHORT $L202883
  00085	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00088	83 c0 03	 add	 eax, 3
  0008b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008e	e8 00 00 00 00	 call	 __alloca_probe
  00093	89 65 cc	 mov	 DWORD PTR tv84[ebp], esp
  00096	8b 55 cc	 mov	 edx, DWORD PTR tv84[ebp]
  00099	89 55 c8	 mov	 DWORD PTR tv89[ebp], edx
  0009c	eb 0f		 jmp	 SHORT $L202884
$L202883:
  0009e	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  000a1	50		 push	 eax
  000a2	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000a5	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  000aa	89 45 c8	 mov	 DWORD PTR tv89[ebp], eax
$L202884:
  000ad	8b 4d e4	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 e0	 mov	 edx, DWORD PTR __convert_ex$[ebp]
  000b4	52		 push	 edx
  000b5	8b 45 f0	 mov	 eax, DWORD PTR __lpw_ex$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d c8	 mov	 ecx, DWORD PTR tv89[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  000c2	89 45 d0	 mov	 DWORD PTR tv91[ebp], eax
$L202886:
  000c5	8b 55 d0	 mov	 edx, DWORD PTR tv91[ebp]
  000c8	89 55 d8	 mov	 DWORD PTR _pszAString1$[ebp], edx

; 199  : 		if(pszAString1 == NULL)

  000cb	83 7d d8 00	 cmp	 DWORD PTR _pszAString1$[ebp], 0
  000cf	75 0a		 jne	 SHORT $L25772

; 200  : 			AtlThrow(E_OUTOFMEMORY);

  000d1	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  000d6	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L25772:

; 201  : 	}
; 202  : 
; 203  : 	LPCSTR pszAString2 = NULL;

  000db	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pszAString2$[ebp], 0

; 204  : 	if(pszString2 != NULL)

  000e2	83 7d 18 00	 cmp	 DWORD PTR _pszString2$[ebp], 0
  000e6	0f 84 98 00 00
	00		 je	 $L25778

; 205  : 	{
; 206  : 		pszAString2 = W2A_EX(pszString2,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  000ec	8b 45 18	 mov	 eax, DWORD PTR _pszString2$[ebp]
  000ef	89 45 f0	 mov	 DWORD PTR __lpw_ex$[ebp], eax
  000f2	83 7d f0 00	 cmp	 DWORD PTR __lpw_ex$[ebp], 0
  000f6	75 09		 jne	 SHORT $L202889
  000f8	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv149[ebp], 0
  000ff	eb 6d		 jmp	 SHORT $L202890
$L202889:
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __lpw_ex$[ebp]
  00104	51		 push	 ecx
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0010b	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  0010f	89 55 e0	 mov	 DWORD PTR __convert_ex$[ebp], edx
  00112	81 7d e0 00 04
	00 00		 cmp	 DWORD PTR __convert_ex$[ebp], 1024 ; 00000400H
  00119	7f 2c		 jg	 SHORT $L202887
  0011b	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  00124	83 c4 04	 add	 esp, 4
  00127	0f b6 c8	 movzx	 ecx, al
  0012a	85 c9		 test	 ecx, ecx
  0012c	74 19		 je	 SHORT $L202887
  0012e	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00131	83 c0 03	 add	 eax, 3
  00134	83 e0 fc	 and	 eax, -4			; fffffffcH
  00137	e8 00 00 00 00	 call	 __alloca_probe
  0013c	89 65 c0	 mov	 DWORD PTR tv142[ebp], esp
  0013f	8b 55 c0	 mov	 edx, DWORD PTR tv142[ebp]
  00142	89 55 bc	 mov	 DWORD PTR tv147[ebp], edx
  00145	eb 0f		 jmp	 SHORT $L202888
$L202887:
  00147	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  0014a	50		 push	 eax
  0014b	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  0014e	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  00153	89 45 bc	 mov	 DWORD PTR tv147[ebp], eax
$L202888:
  00156	8b 4d e4	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  00159	51		 push	 ecx
  0015a	8b 55 e0	 mov	 edx, DWORD PTR __convert_ex$[ebp]
  0015d	52		 push	 edx
  0015e	8b 45 f0	 mov	 eax, DWORD PTR __lpw_ex$[ebp]
  00161	50		 push	 eax
  00162	8b 4d bc	 mov	 ecx, DWORD PTR tv147[ebp]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0016b	89 45 c4	 mov	 DWORD PTR tv149[ebp], eax
$L202890:
  0016e	8b 55 c4	 mov	 edx, DWORD PTR tv149[ebp]
  00171	89 55 e8	 mov	 DWORD PTR _pszAString2$[ebp], edx

; 207  : 		if(pszAString2 == NULL)

  00174	83 7d e8 00	 cmp	 DWORD PTR _pszAString2$[ebp], 0
  00178	75 0a		 jne	 SHORT $L25778

; 208  : 			AtlThrow(E_OUTOFMEMORY);

  0017a	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0017f	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L25778:

; 209  : 	}
; 210  : 
; 211  : 	return ::CompareStringA(lcid, dwFlags, pszAString1, nLength1, pszAString2, nLength2);

  00184	8b 45 1c	 mov	 eax, DWORD PTR _nLength2$[ebp]
  00187	50		 push	 eax
  00188	8b 4d e8	 mov	 ecx, DWORD PTR _pszAString2$[ebp]
  0018b	51		 push	 ecx
  0018c	8b 55 14	 mov	 edx, DWORD PTR _nLength1$[ebp]
  0018f	52		 push	 edx
  00190	8b 45 d8	 mov	 eax, DWORD PTR _pszAString1$[ebp]
  00193	50		 push	 eax
  00194	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00197	51		 push	 ecx
  00198	8b 55 08	 mov	 edx, DWORD PTR _lcid$[ebp]
  0019b	52		 push	 edx
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CompareStringA@24
  001a2	89 45 d4	 mov	 DWORD PTR $T202891[ebp], eax
  001a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001ac	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  001af	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  001b4	8b 45 d4	 mov	 eax, DWORD PTR $T202891[ebp]
$L202882:

; 212  : }

  001b7	8d 65 bc	 lea	 esp, DWORD PTR [ebp-68]
  001ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202892:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202894
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWFake
EXTRN	__except_handler3:NEAR
EXTRN	__imp___resetstkoflw:NEAR
;	COMDAT CONST
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
CONST	SEGMENT
$T202908 DD	0ffffffffH
	DD	FLAT:$L202903
	DD	FLAT:$L202904
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
tv65 = -40						; size = 4
$T202907 = -36						; size = 4
_p$24118 = -32						; size = 4
_bStackAvailable$ = -25					; size = 1
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 OFFSET FLAT:$T202908
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:__except_handler3
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00015	50		 push	 eax
  00016	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001d	83 c4 e8	 add	 esp, -24		; ffffffe8H
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 332  :     bool bStackAvailable = true;

  00026	c6 45 e7 01	 mov	 BYTE PTR _bStackAvailable$[ebp], 1

; 333  : 
; 334  :     __try

  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 335  :     {
; 336  :         PVOID p = _alloca(Size + _ATL_STACK_MARGIN);

  00031	8b 45 08	 mov	 eax, DWORD PTR _Size$[ebp]
  00034	05 03 20 00 00	 add	 eax, 8195		; 00002003H
  00039	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003c	e8 00 00 00 00	 call	 __alloca_probe
  00041	89 65 d8	 mov	 DWORD PTR tv65[ebp], esp
  00044	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00047	8b 45 d8	 mov	 eax, DWORD PTR tv65[ebp]
  0004a	89 45 e0	 mov	 DWORD PTR _p$24118[ebp], eax
  0004d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00054	eb 2c		 jmp	 SHORT $L202906
$L202903:
$L202912:

; 337  :         (p);
; 338  :     }
; 339  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 340  :                    EXCEPTION_EXECUTE_HANDLER :
; 341  :                    EXCEPTION_CONTINUE_SEARCH)

  00056	8b 4d ec	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+4]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8b 02		 mov	 eax, DWORD PTR [edx]
  0005d	89 45 dc	 mov	 DWORD PTR $T202907[ebp], eax
  00060	8b 45 dc	 mov	 eax, DWORD PTR $T202907[ebp]
  00063	2d fd 00 00 c0	 sub	 eax, -1073741571	; c00000fdH
  00068	f7 d8		 neg	 eax
  0006a	1b c0		 sbb	 eax, eax
  0006c	40		 inc	 eax
$L202905:
$L202911:
  0006d	c3		 ret	 0
$L202904:
  0006e	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 342  :     {
; 343  :         bStackAvailable = false;

  00071	c6 45 e7 00	 mov	 BYTE PTR _bStackAvailable$[ebp], 0

; 344  :         _resetstkoflw();

  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___resetstkoflw
  0007b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$L202906:

; 345  :     }
; 346  :     return bStackAvailable;

  00082	8a 45 e7	 mov	 al, BYTE PTR _bStackAvailable$[ebp]
$L202902:

; 347  : }

  00085	8d 65 cc	 lea	 esp, DWORD PTR [ebp-52]
  00088	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
EXTRN	__imp__WideCharToMultiByte@32:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPB_WHI@Z PROC NEAR		; AtlW2AHelper, COMDAT

; 573  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 574  : 	ATLASSERT(lpw != NULL);
; 575  : 	ATLASSERT(lpa != NULL);
; 576  : 	if (lpa == NULL || lpw == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpa$[ebp], 0
  00008	74 06		 je	 SHORT $L24319
  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpw$[ebp], 0
  0000e	75 04		 jne	 SHORT $L24318
$L24319:

; 577  : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 34		 jmp	 SHORT $L24315
$L24318:

; 578  : 	// verify that no illegal character present
; 579  : 	// since lpa was allocated based on the size of lpw
; 580  : 	// don't worry about the number of chars
; 581  : 	lpa[0] = '\0';

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpa$[ebp]
  00017	c6 00 00	 mov	 BYTE PTR [eax], 0

; 582  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR _nChars$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _lpa$[ebp]
  00025	52		 push	 edx
  00026	6a ff		 push	 -1
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lpw$[ebp]
  0002b	50		 push	 eax
  0002c	6a 00		 push	 0
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _acp$[ebp]
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00038	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 583  : 	if(ret == 0)

  0003b	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0003f	75 04		 jne	 SHORT $L24321

; 584  : 	{
; 585  : 		ATLASSERT(FALSE);
; 586  : 		return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	eb 03		 jmp	 SHORT $L24315
$L24321:

; 587  : 	}
; 588  : 	return lpa;

  00045	8b 45 08	 mov	 eax, DWORD PTR _lpa$[ebp]
$L24315:

; 589  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 10 00	 ret	 16			; 00000010H
?AtlW2AHelper@@YGPADPADPB_WHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00003	81 7d 08 0e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
  0000a	75 05		 jne	 SHORT $L24681

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000c	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L24681:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00011	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L202918:

; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );
; 74   : #endif
; 75   : };

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
EXTRN	__imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ:NEAR
EXTRN	__imp_?GetManager@?$CSimpleStringT@D$00@ATL@@QBEPAUIAtlStringMgr@2@XZ:NEAR
EXTRN	__imp_?StringLength@?$CSimpleStringT@D$00@ATL@@SAHPBD@Z:NEAR
EXTRN	__imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z:NEAR
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z:NEAR
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
xdata$x	SEGMENT
$T202928 DD	0ffffffffH
	DD	FLAT:$L202921
$T202926 DD	019930520H
	DD	01H
	DD	FLAT:$T202928
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z
_TEXT	SEGMENT
$T202923 = -20						; size = 4
_strResult$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_str1$ = 12						; size = 4
_psz2$ = 16						; size = 4
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z PROC NEAR ; ATL::operator+, COMDAT

; 2023 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T202923[ebp], 0

; 2024 : 		CStringT strResult( str1.GetManager() );

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _str1$[ebp]
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CSimpleStringT@D$00@ATL@@QBEPAUIAtlStringMgr@2@XZ
  0002b	50		 push	 eax
  0002c	8d 4d f0	 lea	 ecx, DWORD PTR _strResult$[ebp]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2025 : 
; 2026 : 		Concatenate( strResult, str1, str1.GetLength(), psz2, StringLength( psz2 ) );

  0003c	8b 45 10	 mov	 eax, DWORD PTR _psz2$[ebp]
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StringLength@?$CSimpleStringT@D$00@ATL@@SAHPBD@Z
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8b 4d 10	 mov	 ecx, DWORD PTR _psz2$[ebp]
  0004d	51		 push	 ecx
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _str1$[ebp]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  00057	50		 push	 eax
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _str1$[ebp]
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00061	50		 push	 eax
  00062	8d 55 f0	 lea	 edx, DWORD PTR _strResult$[ebp]
  00065	52		 push	 edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  0006c	83 c4 14	 add	 esp, 20			; 00000014H

; 2027 : 
; 2028 : 		return( strResult );

  0006f	8d 45 f0	 lea	 eax, DWORD PTR _strResult$[ebp]
  00072	50		 push	 eax
  00073	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0007c	8b 4d ec	 mov	 ecx, DWORD PTR $T202923[ebp]
  0007f	83 c9 01	 or	 ecx, 1
  00082	89 4d ec	 mov	 DWORD PTR $T202923[ebp], ecx
  00085	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008c	8d 4d f0	 lea	 ecx, DWORD PTR _strResult$[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00095	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2029 : 	}

  00098	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202921:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _strResult$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202926
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ENDP ; ATL::operator+
PUBLIC	?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExW@20:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWThunk, COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 241  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetStringTypeExW@20
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ; ATL::GetStringTypeExWFake
  0000e	68 04 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  : 
; 243  : 	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);

  0001b	8b 4d 18	 mov	 ecx, DWORD PTR _pwCharType$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 14	 mov	 edx, DWORD PTR _nLength$[ebp]
  00022	52		 push	 edx
  00023	8b 45 10	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _dwInfoType$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _lcid$[ebp]
  0002e	52		 push	 edx
  0002f	ff 15 04 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4

; 244  : }

  00035	5d		 pop	 ebp
  00036	c2 14 00	 ret	 20			; 00000014H
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z ENDP	; ATL::GetStringTypeExWThunk
_TEXT	ENDS
EXTRN	__imp__GetStringTypeExA@20:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T202942 DD	0ffffffffH
	DD	FLAT:$L202937
$T202939 DD	019930520H
	DD	01H
	DD	FLAT:$T202942
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
$T202936 = -164						; size = 4
_nLengthA$ = -160					; size = 4
_pszA$ = -156						; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWFake, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 225  : 	int nLengthA;
; 226  : 	CTempBuffer<char> pszA;

  00026	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 227  : 
; 228  : 	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	8b 45 14	 mov	 eax, DWORD PTR _nLength$[ebp]
  00043	50		 push	 eax
  00044	8b 4d 10	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  00047	51		 push	 ecx
  00048	6a 00		 push	 0
  0004a	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00056	89 85 60 ff ff
	ff		 mov	 DWORD PTR _nLengthA$[ebp], eax

; 229  : 	pszA.Allocate(nLengthA);

  0005c	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _nLengthA$[ebp]
  00062	52		 push	 edx
  00063	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  00069	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 230  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nLengthA$[ebp]
  00078	50		 push	 eax
  00079	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  0007f	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  00084	50		 push	 eax
  00085	8b 4d 14	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 10	 mov	 edx, DWORD PTR _pszSrc$[ebp]
  0008c	52		 push	 edx
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 231  : 
; 232  : 	if (nLength == -1)

  0009b	83 7d 14 ff	 cmp	 DWORD PTR _nLength$[ebp], -1
  0009f	75 0a		 jne	 SHORT $L25804

; 233  : 		nLengthA = -1;

  000a1	c7 85 60 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _nLengthA$[ebp], -1
$L25804:

; 234  : 
; 235  : 	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);

  000ab	8b 45 18	 mov	 eax, DWORD PTR _pwCharType$[ebp]
  000ae	50		 push	 eax
  000af	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _nLengthA$[ebp]
  000b5	51		 push	 ecx
  000b6	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  000bc	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000c1	50		 push	 eax
  000c2	8b 55 0c	 mov	 edx, DWORD PTR _dwInfoType$[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 08	 mov	 eax, DWORD PTR _lcid$[ebp]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStringTypeExA@20
  000d0	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T202936[ebp], eax
  000d6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000dd	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  000e3	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  000e8	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T202936[ebp]

; 236  : }

  000ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L202937:
  00000	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T202939
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ENDP		; ATL::GetStringTypeExWFake
PUBLIC	?lstrcmpiWFake@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiW@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWThunk, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 255  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__lstrcmpiW@8
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?lstrcmpiWFake@ATL@@YGHPB_W0@Z ; ATL::lstrcmpiWFake
  0000e	68 08 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 256  : 
; 257  : 	return _strthunks.pfnlstrcmpiW(psz1, psz2);

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _psz2$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _psz1$[ebp]
  00022	52		 push	 edx
  00023	ff 15 08 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8

; 258  : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWThunk
_TEXT	ENDS
EXTRN	__imp__lstrcmpiA@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv94 = -28						; size = 4
tv76 = -24						; size = 4
tv79 = -20						; size = 4
__acp$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWFake@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWFake, COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 248  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f4	 mov	 DWORD PTR __acp$[ebp], eax

; 249  : 
; 250  : 	return ::lstrcmpiA(W2A(psz1), W2A(psz2));

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _psz2$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L202949
  0001a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L202950
$L202949:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e8	 mov	 DWORD PTR tv76[ebp], esp
  00045	8b 45 f4	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e8	 mov	 eax, DWORD PTR tv76[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
$L202950:
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _psz1$[ebp]
  00060	89 4d f8	 mov	 DWORD PTR __lpw$[ebp], ecx
  00063	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00067	75 09		 jne	 SHORT $L202951
  00069	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00070	eb 3a		 jmp	 SHORT $L202952
$L202951:
  00072	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00075	52		 push	 edx
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0007c	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00080	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00083	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008c	e8 00 00 00 00	 call	 __alloca_probe
  00091	89 65 e0	 mov	 DWORD PTR tv91[ebp], esp
  00094	8b 4d f4	 mov	 ecx, DWORD PTR __acp$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 fc	 mov	 edx, DWORD PTR __convert$[ebp]
  0009b	52		 push	 edx
  0009c	8b 45 f8	 mov	 eax, DWORD PTR __lpw$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d e0	 mov	 ecx, DWORD PTR tv91[ebp]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  000a9	89 45 e4	 mov	 DWORD PTR tv94[ebp], eax
$L202952:
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000af	52		 push	 edx
  000b0	8b 45 e4	 mov	 eax, DWORD PTR tv94[ebp]
  000b3	50		 push	 eax
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8

; 251  : }

  000ba	8d 65 e0	 lea	 esp, DWORD PTR [ebp-32]
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
?lstrcmpiWFake@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWFake
_TEXT	ENDS
PUBLIC	?CharLowerWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWFake
EXTRN	__imp__CharLowerW@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWThunk, COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 274  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharLowerW@4
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CharLowerWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharLowerWFake
  0000e	68 0c 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  : 
; 276  : 	return _strthunks.pfnCharLowerW(psz);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 15 0c 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12

; 277  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWThunk
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z		; AtlA2WHelper
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	__imp__CharLowerA@4:NEAR
EXTRN	__imp__wcscpy:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
__lpa$ = -20						; size = 4
__acp$ = -16						; size = 4
_pszA$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWFake, COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 262  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f0	 mov	 DWORD PTR __acp$[ebp], eax

; 263  : 	LPSTR pszA;
; 264  : 
; 265  : 	pszA = W2A(psz);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L202957
  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L202958
$L202957:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e4	 mov	 DWORD PTR tv75[ebp], esp
  00045	8b 45 f0	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$L202958:
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00060	89 4d f4	 mov	 DWORD PTR _pszA$[ebp], ecx

; 266  : 	::CharLowerA(pszA);

  00063	8b 55 f4	 mov	 edx, DWORD PTR _pszA$[ebp]
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharLowerA@4

; 267  : 	wcscpy(psz, A2W(pszA));

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _pszA$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR __lpa$[ebp], eax
  00073	83 7d ec 00	 cmp	 DWORD PTR __lpa$[ebp], 0
  00077	75 09		 jne	 SHORT $L202959
  00079	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00080	eb 3b		 jmp	 SHORT $L202960
$L202959:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00092	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00095	d1 e0		 shl	 eax, 1
  00097	83 c0 03	 add	 eax, 3
  0009a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0009d	e8 00 00 00 00	 call	 __alloca_probe
  000a2	89 65 dc	 mov	 DWORD PTR tv90[ebp], esp
  000a5	8b 55 f0	 mov	 edx, DWORD PTR __acp$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  000ba	89 45 e0	 mov	 DWORD PTR tv94[ebp], eax
$L202960:
  000bd	8b 45 e0	 mov	 eax, DWORD PTR tv94[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  000c4	51		 push	 ecx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000cb	83 c4 08	 add	 esp, 8

; 268  : 
; 269  : 	return psz;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]

; 270  : }

  000d1	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z PROC NEAR		; AtlA2WHelper, COMDAT

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 555  : 	ATLASSERT(lpa != NULL);
; 556  : 	ATLASSERT(lpw != NULL);
; 557  : 	if (lpw == NULL || lpa == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpw$[ebp], 0
  00008	74 06		 je	 SHORT $L24306
  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpa$[ebp], 0
  0000e	75 04		 jne	 SHORT $L24305
$L24306:

; 558  : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 32		 jmp	 SHORT $L24302
$L24305:

; 559  : 	// verify that no illegal character present
; 560  : 	// since lpw was allocated based on the size of lpa
; 561  : 	// don't worry about the number of chars
; 562  : 	lpw[0] = '\0';

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
  00017	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 563  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _nChars$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 08	 mov	 edx, DWORD PTR _lpw$[ebp]
  00023	52		 push	 edx
  00024	6a ff		 push	 -1
  00026	8b 45 0c	 mov	 eax, DWORD PTR _lpa$[ebp]
  00029	50		 push	 eax
  0002a	6a 00		 push	 0
  0002c	8b 4d 14	 mov	 ecx, DWORD PTR _acp$[ebp]
  0002f	51		 push	 ecx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00036	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 564  : 	if(ret == 0)

  00039	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0003d	75 04		 jne	 SHORT $L24308

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);
; 567  : 		return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	eb 03		 jmp	 SHORT $L24302
$L24308:

; 568  : 	}		
; 569  : 	return lpw;

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
$L24302:

; 570  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?CharUpperWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWFake
EXTRN	__imp__CharUpperW@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWThunk, COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharUpperW@4
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CharUpperWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharUpperWFake
  0000e	68 10 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 294  : 
; 295  : 	return _strthunks.pfnCharUpperW(psz);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 15 10 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16

; 296  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWThunk
_TEXT	ENDS
EXTRN	__imp__CharUpperA@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
__lpa$ = -20						; size = 4
__acp$ = -16						; size = 4
_pszA$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWFake, COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 281  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f0	 mov	 DWORD PTR __acp$[ebp], eax

; 282  : 	LPSTR pszA;
; 283  : 
; 284  : 	pszA = W2A(psz);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L202967
  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L202968
$L202967:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e4	 mov	 DWORD PTR tv75[ebp], esp
  00045	8b 45 f0	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$L202968:
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00060	89 4d f4	 mov	 DWORD PTR _pszA$[ebp], ecx

; 285  : 	::CharUpperA(pszA);

  00063	8b 55 f4	 mov	 edx, DWORD PTR _pszA$[ebp]
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharUpperA@4

; 286  : 	wcscpy(psz, A2W(pszA));

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _pszA$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR __lpa$[ebp], eax
  00073	83 7d ec 00	 cmp	 DWORD PTR __lpa$[ebp], 0
  00077	75 09		 jne	 SHORT $L202969
  00079	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00080	eb 3b		 jmp	 SHORT $L202970
$L202969:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00092	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00095	d1 e0		 shl	 eax, 1
  00097	83 c0 03	 add	 eax, 3
  0009a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0009d	e8 00 00 00 00	 call	 __alloca_probe
  000a2	89 65 dc	 mov	 DWORD PTR tv90[ebp], esp
  000a5	8b 55 f0	 mov	 edx, DWORD PTR __acp$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  000ba	89 45 e0	 mov	 DWORD PTR tv94[ebp], eax
$L202970:
  000bd	8b 45 e0	 mov	 eax, DWORD PTR tv94[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  000c4	51		 push	 ecx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000cb	83 c4 08	 add	 esp, 8

; 287  : 
; 288  : 	return psz;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]

; 289  : }

  000d1	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWFake
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE_NI@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Buy
PUBLIC	??0?$_Vector_val@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE@V?$allocator@UOneLocalGame@@@1@@Z ; std::_Vector_val<OneLocalGame,std::allocator<OneLocalGame> >::_Vector_val<OneLocalGame,std::allocator<OneLocalGame> >
PUBLIC	??0?$allocator@UOneLocalGame@@@std@@QAE@XZ	; std::allocator<OneLocalGame>::allocator<OneLocalGame>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::vector<OneLocalGame,std::allocator<OneLocalGame> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@UOneLocalGame@@@std@@QAE@XZ ; std::allocator<OneLocalGame>::allocator<OneLocalGame>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE@V?$allocator@UOneLocalGame@@@1@@Z ; std::_Vector_val<OneLocalGame,std::allocator<OneLocalGame> >::_Vector_val<OneLocalGame,std::allocator<OneLocalGame> >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE_NI@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::vector<OneLocalGame,std::allocator<OneLocalGame> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::~vector<OneLocalGame,std::allocator<OneLocalGame> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@XZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::~vector<OneLocalGame,std::allocator<OneLocalGame> >
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L202982
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L202983
$L202982:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L202983:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU3@IABU3@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ufill
PUBLIC	?capacity@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::capacity
PUBLIC	?insert@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@ABUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::insert
; Function compile flags: /Odt
;	COMDAT ?push_back@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXABUOneLocalGame@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T202987 = -8						; size = 4
$T202986 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXABUOneLocalGame@@@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0000a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size
  00012	8b f0		 mov	 esi, eax
  00014	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?capacity@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::capacity
  0001c	3b f0		 cmp	 esi, eax
  0001e	73 1d		 jae	 SHORT $L200957

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	50		 push	 eax
  00024	6a 01		 push	 1
  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	52		 push	 edx
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU3@IABU3@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ufill
  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  0003b	eb 1f		 jmp	 SHORT $L200956
$L200957:

; 583  : 			insert(end(), _Val);

  0003d	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00040	52		 push	 edx
  00041	8d 45 fc	 lea	 eax, DWORD PTR $T202986[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?end@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::end
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	51		 push	 ecx
  00050	8d 55 f8	 lea	 edx, DWORD PTR $T202987[ebp]
  00053	52		 push	 edx
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?insert@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@ABUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::insert
$L200956:

; 584  : 		}

  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?push_back@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXABUOneLocalGame@@@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::push_back
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXPAUOneLocalGame@@0@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Destroy
PUBLIC	??$copy@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z ; std::copy<OneLocalGame *,OneLocalGame *>
; Function compile flags: /Odt
;	COMDAT ?erase@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::erase, COMDAT
; _this$ = ecx

; 723  : 		{	// erase element at where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 724  : 		copy(_ITER_BASE(_Where) + 1, _Mylast, _ITER_BASE(_Where));

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00011	52		 push	 edx
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00015	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$copy@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z ; std::copy<OneLocalGame *,OneLocalGame *>
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  : 		_Destroy(_Mylast - 1, _Mylast);

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00029	52		 push	 edx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00030	81 e9 90 00 00
	00		 sub	 ecx, 144		; 00000090H
  00036	51		 push	 ecx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXPAUOneLocalGame@@0@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Destroy

; 726  : 		--_Mylast;

  0003f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00045	2d 90 00 00 00	 sub	 eax, 144		; 00000090H
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 727  : 		return (_Where);

  00050	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00053	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00056	89 02		 mov	 DWORD PTR [edx], eax
  00058	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 728  : 		}

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
?erase@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::erase
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Tidy

; 745  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?clear@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXXZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::clear
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEABUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEAAUOneLocalGame@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEAAUOneLocalGame@@XZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEABUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEAAUOneLocalGame@@XZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->, COMDAT
; _this$ = ecx

; 224  : 			{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 225  : 			return (&**this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Diterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEAAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator*

; 226  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Citerator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEPAUOneLocalGame@@XZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 236  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 237  : 			++*this;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++

; 238  : 			return (_Tmp);

  00019	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 239  : 			}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator==
; Function compile flags: /Odt
;	COMDAT ??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 159  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 161  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
PUBLIC	??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
PUBLIC	??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00027	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 281  : 		}

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 364  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 365  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy

; 366  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
PUBLIC	?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
; Function compile flags: /Odt
;	COMDAT ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin, COMDAT
; _this$ = ecx

; 376  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 377  : 		return (iterator(_Nextnode(_Myhead)));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00013	83 c4 04	 add	 esp, 4
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	52		 push	 edx
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 378  : 		}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end, COMDAT
; _this$ = ecx

; 386  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 387  : 		return (iterator(_Myhead));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 388  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 239  : 			{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 240  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*

; 241  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 255  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 257  : 			++*this;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++

; 258  : 			return (_Tmp);

  00019	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 259  : 			}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
; Function compile flags: /Odt
;	COMDAT ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 201  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 203  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L203017
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 17		 jmp	 SHORT $L203018
$L203017:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	99		 cdq
  00028	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  0002d	f7 f9		 idiv	 ecx
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L203018:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?capacity@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::capacity
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXViterator@12@IABUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Insert_n
PUBLIC	??Hiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE?AV012@H@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator+
PUBLIC	??Giterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator-
; Function compile flags: /Odt
;	COMDAT ?insert@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@ABUOneLocalGame@@@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
_this$ = -16						; size = 4
$T203024 = -12						; size = 4
$T203021 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@ABUOneLocalGame@@@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size
  00011	85 c0		 test	 eax, eax
  00013	75 09		 jne	 SHORT $L203022
  00015	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0001c	eb 18		 jmp	 SHORT $L203023
$L203022:
  0001e	8d 45 f8	 lea	 eax, DWORD PTR $T203021[ebp]
  00021	50		 push	 eax
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::begin
  0002a	50		 push	 eax
  0002b	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002e	e8 00 00 00 00	 call	 ??Giterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator-
  00033	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$L203023:
  00036	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00039	89 4d fc	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0003c	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0003f	52		 push	 edx
  00040	6a 01		 push	 1
  00042	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00045	50		 push	 eax
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXViterator@12@IABUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Insert_n

; 623  : 		return (begin() + _Off);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	52		 push	 edx
  00056	8d 45 f4	 lea	 eax, DWORD PTR $T203024[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?begin@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::begin
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE?AV012@H@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator+
  00069	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE?AViterator@12@V312@ABUOneLocalGame@@@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::insert
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IBEXXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Xlen
PUBLIC	?allocate@?$allocator@UOneLocalGame@@@std@@QAEPAUOneLocalGame@@I@Z ; std::allocator<OneLocalGame>::allocate
PUBLIC	?max_size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::max_size
; Function compile flags: /Odt
;	COMDAT ?_Buy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L201064

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 4c		 jmp	 SHORT $L201063
$L201064:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L201066

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IBEXXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Xlen

; 776  : 		else

  00044	eb 33		 jmp	 SHORT $L201065
$L201066:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@UOneLocalGame@@@std@@QAEPAUOneLocalGame@@I@Z ; std::allocator<OneLocalGame>::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00067	69 d2 90 00 00
	00		 imul	 edx, 144		; 00000090H
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L201065:

; 781  : 			}
; 782  : 		return (true);

  00079	b0 01		 mov	 al, 1
$L201063:

; 783  : 		}

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
?_Buy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@@Z ; std::_Destroy_range<OneLocalGame,std::allocator<OneLocalGame> >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXPAUOneLocalGame@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXPAUOneLocalGame@@0@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@@Z ; std::_Destroy_range<OneLocalGame,std::allocator<OneLocalGame> >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXPAUOneLocalGame@@0@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Destroy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@I@Z ; std::allocator<OneLocalGame>::deallocate
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 3c		 je	 SHORT $L201079

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXPAUOneLocalGame@@0@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	8b c1		 mov	 eax, ecx
  00034	99		 cdq
  00035	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  0003a	f7 f9		 idiv	 ecx
  0003c	50		 push	 eax
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@I@Z ; std::allocator<OneLocalGame>::deallocate
$L201079:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?_Tidy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXXZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@@Z ; std::_Uninitialized_fill_n<OneLocalGame *,unsigned int,OneLocalGame,std::allocator<OneLocalGame> >
; Function compile flags: /Odt
;	COMDAT ?_Ufill@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU3@IABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU3@IABU3@@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@@Z ; std::_Uninitialized_fill_n<OneLocalGame *,unsigned int,OneLocalGame,std::allocator<OneLocalGame> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	69 c0 90 00 00
	00		 imul	 eax, 144		; 00000090H
  00028	03 45 08	 add	 eax, DWORD PTR __Ptr$[ebp]

; 880  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU3@IABU3@@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$allocator@UOneLocalGame@@@std@@QAE@ABV01@@Z ; std::allocator<OneLocalGame>::allocator<OneLocalGame>
; Function compile flags: /Odt
;	COMDAT ??0?$_Vector_val@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE@V?$allocator@UOneLocalGame@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE@V?$allocator@UOneLocalGame@@@1@@Z PROC NEAR ; std::_Vector_val<OneLocalGame,std::allocator<OneLocalGame> >::_Vector_val<OneLocalGame,std::allocator<OneLocalGame> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@UOneLocalGame@@@std@@QAE@ABV01@@Z ; std::allocator<OneLocalGame>::allocator<OneLocalGame>

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAE@V?$allocator@UOneLocalGame@@@1@@Z ENDP ; std::_Vector_val<OneLocalGame,std::allocator<OneLocalGame> >::_Vector_val<OneLocalGame,std::allocator<OneLocalGame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UOneLocalGame@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UOneLocalGame@@@std@@QAE@XZ PROC NEAR	; std::allocator<OneLocalGame>::allocator<OneLocalGame>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@UOneLocalGame@@@std@@QAE@XZ ENDP		; std::allocator<OneLocalGame>::allocator<OneLocalGame>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 			++this->_Myptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 232  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEABUOneLocalGame@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEABUOneLocalGame@@XZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEABUOneLocalGame@@XZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 152  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 156  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator==
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode, COMDAT

; 107  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 109  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
PUBLIC	?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203055 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T203057 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L203051
$T203056 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T203057
$T203053 DD	019930520H
	DD	02H
	DD	FLAT:$T203055
	DD	01H
	DD	FLAT:$T203056
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
_TEXT	SEGMENT
tv93 = -36						; size = 4
tv92 = -32						; size = 4
_this$ = -28						; size = 4
__Pnode$ = -24						; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode, COMDAT
; _this$ = ecx

; 898  : 		{	// allocate a head node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 14	 sub	 esp, 20			; 00000014H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00025	6a 01		 push	 1
  00027	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
  0002f	89 45 e8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 900  : 		int _Linkcnt = 0;

  00032	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Linkcnt$[ebp], 0

; 901  : 
; 902  : 		_TRY_BEGIN

  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

  00040	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00049	83 c4 04	 add	 esp, 4
  0004c	89 45 e0	 mov	 DWORD PTR tv92[ebp], eax
  0004f	8d 4d e8	 lea	 ecx, DWORD PTR __Pnode$[ebp]
  00052	51		 push	 ecx
  00053	8b 55 e0	 mov	 edx, DWORD PTR tv92[ebp]
  00056	52		 push	 edx
  00057	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 01	 add	 ecx, 1
  0005d	e8 00 00 00 00	 call	 ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct

; 904  : 		++_Linkcnt;

  00062	8b 45 ec	 mov	 eax, DWORD PTR __Linkcnt$[ebp]
  00065	83 c0 01	 add	 eax, 1
  00068	89 45 ec	 mov	 DWORD PTR __Linkcnt$[ebp], eax

; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

  0006b	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  00074	83 c4 04	 add	 esp, 4
  00077	89 45 dc	 mov	 DWORD PTR tv93[ebp], eax
  0007a	8d 55 e8	 lea	 edx, DWORD PTR __Pnode$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 dc	 mov	 eax, DWORD PTR tv93[ebp]
  00081	50		 push	 eax
  00082	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	83 c1 01	 add	 ecx, 1
  00088	e8 00 00 00 00	 call	 ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
  0008d	eb 35		 jmp	 SHORT $L203050
$L203051:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)

  0008f	83 7d ec 00	 cmp	 DWORD PTR __Linkcnt$[ebp], 0
  00093	7e 18		 jle	 SHORT $L201123

; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));

  00095	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  0009e	83 c4 04	 add	 esp, 4
  000a1	50		 push	 eax
  000a2	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	83 c1 01	 add	 ecx, 1
  000a8	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
$L201123:

; 909  : 		this->_Alnod.deallocate(_Pnode, 1);

  000ad	6a 01		 push	 1
  000af	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000b2	52		 push	 edx
  000b3	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 910  : 		_RERAISE;

  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203050:

; 911  : 		_CATCH_END

  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 912  : 		return (_Pnode);

  000cb	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$L203048:

; 913  : 		}

  000ce	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000d1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203053
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
PUBLIC	?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy, COMDAT
; _this$ = ecx

; 929  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 930  : 		clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 01	 add	 ecx, 1
  00025	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy

; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  00036	83 c4 04	 add	 esp, 4
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 01	 add	 ecx, 1
  00040	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy

; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

  00045	6a 01		 push	 1
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004d	52		 push	 edx
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 934  : 		_Myhead = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 935  : 		}

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
PUBLIC	??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
;	COMDAT ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 82   : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
  0001d	8d 4d 08	 lea	 ecx, DWORD PTR __Al$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 02	 add	 ecx, 2
  00027	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>

; 83   : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ PROC NEAR ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ENDP	; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator

; 236  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 249  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 250  : 			++(*(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++

; 251  : 			return (*this);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 252  : 			}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
; Function compile flags: /Odt
;	COMDAT ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 160  : 			{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 			return (_Myval(_Ptr));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
  00012	83 c4 04	 add	 esp, 4

; 162  : 			}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 196  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 			return (_Ptr == _Right._Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 198  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UOneLocalGame@@@std@@QBEIXZ ; std::allocator<OneLocalGame>::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@UOneLocalGame@@@std@@QBEIXZ ; std::allocator<OneLocalGame>::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::max_size
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAUOneLocalGame@@@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU2@00@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ucopy<OneLocalGame *>
PUBLIC	??$fill@PAUOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@0ABU1@@Z ; std::fill<OneLocalGame *,OneLocalGame>
PUBLIC	??$copy_backward@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z ; std::copy_backward<OneLocalGame *,OneLocalGame *>
PUBLIC	??0OneLocalGame@@QAE@ABU0@@Z			; OneLocalGame::OneLocalGame
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203091 DD	0ffffffffH
	DD	FLAT:$L203086
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T203093 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L203083
$T203094 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L203085
$T203092 DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T203093
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T203094
$T203088 DD	019930520H
	DD	05H
	DD	FLAT:$T203091
	DD	02H
	DD	FLAT:$T203092
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXViterator@12@IABUOneLocalGame@@@Z
_TEXT	SEGMENT
tv244 = -200						; size = 4
tv65 = -196						; size = 4
tv89 = -192						; size = 4
_this$ = -188						; size = 4
__Oldend$201226 = -184					; size = 4
__Newvec$201205 = -180					; size = 4
__Ptr$201206 = -176					; size = 4
__Capacity$ = -172					; size = 4
__Tmp$ = -168						; size = 144
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXViterator@12@IABUOneLocalGame@@@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXViterator@12@IABUOneLocalGame@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00027	53		 push	 ebx
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002d	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00033	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00036	50		 push	 eax
  00037	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0003d	e8 00 00 00 00	 call	 ??0OneLocalGame@@QAE@ABU0@@Z
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 811  : 		size_type _Capacity = capacity();

  00049	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?capacity@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::capacity
  00054	89 85 54 ff ff
	ff		 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  0005a	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0005e	75 05		 jne	 SHORT $L201199

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00060	e9 e9 03 00 00	 jmp	 $L201200
$L201199:
  00065	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size
  00070	8b f0		 mov	 esi, eax
  00072	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?max_size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::max_size
  0007d	2b c6		 sub	 eax, esi
  0007f	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  00082	73 10		 jae	 SHORT $L201201

; 816  : 			_Xlen();	// result too long

  00084	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IBEXXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  0008f	e9 ba 03 00 00	 jmp	 $L201200
$L201201:
  00094	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size
  0009f	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000a2	39 85 54 ff ff
	ff		 cmp	 DWORD PTR __Capacity$[ebp], eax
  000a8	0f 83 13 02 00
	00		 jae	 $L201203

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  000ae	8b b5 54 ff ff
	ff		 mov	 esi, DWORD PTR __Capacity$[ebp]
  000b4	d1 ee		 shr	 esi, 1
  000b6	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ?max_size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::max_size
  000c1	2b c6		 sub	 eax, esi
  000c3	3b 85 54 ff ff
	ff		 cmp	 eax, DWORD PTR __Capacity$[ebp]
  000c9	73 0c		 jae	 SHORT $L203080
  000cb	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv89[ebp], 0
  000d5	eb 14		 jmp	 SHORT $L203081
$L203080:
  000d7	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR __Capacity$[ebp]
  000dd	d1 e9		 shr	 ecx, 1
  000df	03 8d 54 ff ff
	ff		 add	 ecx, DWORD PTR __Capacity$[ebp]
  000e5	89 8d 40 ff ff
	ff		 mov	 DWORD PTR tv89[ebp], ecx
$L203081:
  000eb	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv89[ebp]
  000f1	89 95 54 ff ff
	ff		 mov	 DWORD PTR __Capacity$[ebp], edx

; 821  : 			if (_Capacity < size() + _Count)

  000f7	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	e8 00 00 00 00	 call	 ?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size
  00102	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00105	39 85 54 ff ff
	ff		 cmp	 DWORD PTR __Capacity$[ebp], eax
  0010b	73 14		 jae	 SHORT $L201204

; 822  : 				_Capacity = size() + _Count;

  0010d	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00113	e8 00 00 00 00	 call	 ?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size
  00118	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  0011b	89 85 54 ff ff
	ff		 mov	 DWORD PTR __Capacity$[ebp], eax
$L201204:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  00121	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR __Capacity$[ebp]
  00127	50		 push	 eax
  00128	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	e8 00 00 00 00	 call	 ?allocate@?$allocator@UOneLocalGame@@@std@@QAEPAUOneLocalGame@@I@Z ; std::allocator<OneLocalGame>::allocate
  00133	89 85 4c ff ff
	ff		 mov	 DWORD PTR __Newvec$201205[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  00139	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR __Newvec$201205[ebp]
  0013f	89 8d 50 ff ff
	ff		 mov	 DWORD PTR __Ptr$201206[ebp], ecx

; 825  : 
; 826  : 			_TRY_BEGIN

  00145	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  00149	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR __Newvec$201205[ebp]
  0014f	52		 push	 edx
  00150	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00153	50		 push	 eax
  00154	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0015d	52		 push	 edx
  0015e	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00164	e8 00 00 00 00	 call	 ??$_Ucopy@PAUOneLocalGame@@@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU2@00@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ucopy<OneLocalGame *>
  00169	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0016f	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  00175	89 85 50 ff ff
	ff		 mov	 DWORD PTR __Ptr$201206[ebp], eax

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  0017b	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00181	51		 push	 ecx
  00182	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00185	52		 push	 edx
  00186	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR __Ptr$201206[ebp]
  0018c	50		 push	 eax
  0018d	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00193	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU3@IABU3@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ufill
  00198	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv244[ebp], eax
  0019e	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv244[ebp]
  001a4	89 8d 50 ff ff
	ff		 mov	 DWORD PTR __Ptr$201206[ebp], ecx

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  001aa	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR __Ptr$201206[ebp]
  001b0	52		 push	 edx
  001b1	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001b7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001ba	51		 push	 ecx
  001bb	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  001be	52		 push	 edx
  001bf	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001c5	e8 00 00 00 00	 call	 ??$_Ucopy@PAUOneLocalGame@@@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU2@00@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ucopy<OneLocalGame *>
  001ca	eb 3b		 jmp	 SHORT $L203082
$L203083:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  001cc	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR __Ptr$201206[ebp]
  001d2	50		 push	 eax
  001d3	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR __Newvec$201205[ebp]
  001d9	51		 push	 ecx
  001da	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001e0	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXPAUOneLocalGame@@0@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  001e5	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR __Capacity$[ebp]
  001eb	52		 push	 edx
  001ec	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR __Newvec$201205[ebp]
  001f2	50		 push	 eax
  001f3	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001f9	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@I@Z ; std::allocator<OneLocalGame>::deallocate

; 834  : 			_RERAISE;

  001fe	6a 00		 push	 0
  00200	6a 00		 push	 0
  00202	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203082:

; 835  : 			_CATCH_END

  00207	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 836  : 
; 837  : 			_Count += size();

  0020e	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00214	e8 00 00 00 00	 call	 ?size@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEIXZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::size
  00219	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  0021c	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  0021f	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00225	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00229	74 4f		 je	 SHORT $L201213

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  0022b	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00231	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00234	50		 push	 eax
  00235	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0023e	52		 push	 edx
  0023f	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00245	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXPAUOneLocalGame@@0@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0024a	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00250	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00256	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00259	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  0025c	99		 cdq
  0025d	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  00262	f7 f9		 idiv	 ecx
  00264	50		 push	 eax
  00265	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0026b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0026e	50		 push	 eax
  0026f	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00275	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@I@Z ; std::allocator<OneLocalGame>::deallocate
$L201213:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  0027a	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00280	69 c9 90 00 00
	00		 imul	 ecx, 144		; 00000090H
  00286	03 8d 4c ff ff
	ff		 add	 ecx, DWORD PTR __Newvec$201205[ebp]
  0028c	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00292	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 844  : 			_Mylast = _Newvec + _Count;

  00295	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00298	69 c0 90 00 00
	00		 imul	 eax, 144		; 00000090H
  0029e	03 85 4c ff ff
	ff		 add	 eax, DWORD PTR __Newvec$201205[ebp]
  002a4	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

  002ad	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002b3	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR __Newvec$201205[ebp]
  002b9	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  002bc	e9 8d 01 00 00	 jmp	 $L201200
$L201203:
  002c1	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  002ca	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  002cd	99		 cdq
  002ce	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  002d3	f7 f9		 idiv	 ecx
  002d5	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  002d8	0f 83 e5 00 00
	00		 jae	 $L201216

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  002de	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  002e1	69 d2 90 00 00
	00		 imul	 edx, 144		; 00000090H
  002e7	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  002ea	52		 push	 edx
  002eb	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002f1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002f4	51		 push	 ecx
  002f5	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  002f8	52		 push	 edx
  002f9	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ff	e8 00 00 00 00	 call	 ??$_Ucopy@PAUOneLocalGame@@@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU2@00@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ucopy<OneLocalGame *>

; 851  : 
; 852  : 			_TRY_BEGIN

  00304	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  00308	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$[ebp]
  0030e	50		 push	 eax
  0030f	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00315	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00318	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  0031b	99		 cdq
  0031c	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  00321	f7 f9		 idiv	 ecx
  00323	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00326	2b d0		 sub	 edx, eax
  00328	52		 push	 edx
  00329	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0032f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00332	51		 push	 ecx
  00333	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU3@IABU3@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ufill
  0033e	eb 34		 jmp	 SHORT $L203084
$L203085:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  00340	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00343	69 d2 90 00 00
	00		 imul	 edx, 144		; 00000090H
  00349	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0034f	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00352	52		 push	 edx
  00353	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00356	69 c9 90 00 00
	00		 imul	 ecx, 144		; 00000090H
  0035c	03 4d 08	 add	 ecx, DWORD PTR __Where$[ebp]
  0035f	51		 push	 ecx
  00360	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00366	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXPAUOneLocalGame@@0@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Destroy

; 857  : 			_RERAISE;

  0036b	6a 00		 push	 0
  0036d	6a 00		 push	 0
  0036f	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203084:

; 858  : 			_CATCH_END

  00374	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 859  : 
; 860  : 			_Mylast += _Count;

  0037b	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0037e	69 d2 90 00 00
	00		 imul	 edx, 144		; 00000090H
  00384	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0038a	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0038d	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00393	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00396	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR __Tmp$[ebp]
  0039c	52		 push	 edx
  0039d	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  003a0	69 c0 90 00 00
	00		 imul	 eax, 144		; 00000090H
  003a6	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003ac	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003af	2b d0		 sub	 edx, eax
  003b1	52		 push	 edx
  003b2	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  003b5	50		 push	 eax
  003b6	e8 00 00 00 00	 call	 ??$fill@PAUOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@0ABU1@@Z ; std::fill<OneLocalGame *,OneLocalGame>
  003bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  003be	e9 8b 00 00 00	 jmp	 $L201200
$L201216:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  003c3	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003c9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003cc	89 95 48 ff ff
	ff		 mov	 DWORD PTR __Oldend$201226[ebp], edx

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  003d2	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003d8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003db	51		 push	 ecx
  003dc	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR __Oldend$201226[ebp]
  003e2	52		 push	 edx
  003e3	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  003e6	69 c0 90 00 00
	00		 imul	 eax, 144		; 00000090H
  003ec	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR __Oldend$201226[ebp]
  003f2	2b c8		 sub	 ecx, eax
  003f4	51		 push	 ecx
  003f5	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003fb	e8 00 00 00 00	 call	 ??$_Ucopy@PAUOneLocalGame@@@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU2@00@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ucopy<OneLocalGame *>
  00400	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00406	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  00409	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR __Oldend$201226[ebp]
  0040f	50		 push	 eax
  00410	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00413	69 c9 90 00 00
	00		 imul	 ecx, 144		; 00000090H
  00419	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR __Oldend$201226[ebp]
  0041f	2b d1		 sub	 edx, ecx
  00421	52		 push	 edx
  00422	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00425	50		 push	 eax
  00426	e8 00 00 00 00	 call	 ??$copy_backward@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z ; std::copy_backward<OneLocalGame *,OneLocalGame *>
  0042b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  0042e	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00434	51		 push	 ecx
  00435	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00438	69 d2 90 00 00
	00		 imul	 edx, 144		; 00000090H
  0043e	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  00441	52		 push	 edx
  00442	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00445	50		 push	 eax
  00446	e8 00 00 00 00	 call	 ??$fill@PAUOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@0ABU1@@Z ; std::fill<OneLocalGame *,OneLocalGame>
  0044b	83 c4 0c	 add	 esp, 12			; 0000000cH
$L201200:

; 873  : 			}
; 874  : 		}

  0044e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00455	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0045b	e8 00 00 00 00	 call	 ??1OneLocalGame@@QAE@XZ
$L203079:
  00460	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00463	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0046a	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0046d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00472	5f		 pop	 edi
  00473	5e		 pop	 esi
  00474	5b		 pop	 ebx
  00475	8b e5		 mov	 esp, ebp
  00477	5d		 pop	 ebp
  00478	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203086:
  00000	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1OneLocalGame@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXViterator@12@IABUOneLocalGame@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203088
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEXViterator@12@IABUOneLocalGame@@@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Insert_n
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203105 DD	0ffffffffH
	DD	FLAT:$L203101
$T203103 DD	019930520H
	DD	01H
	DD	FLAT:$T203105
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
	ORG $-30
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T203100 = -80						; size = 28
$T203099 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T203100[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T203100[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T203099[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T203099[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203098:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203101:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T203100[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203103
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IBEXXZ ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@UOneLocalGame@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UOneLocalGame@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<OneLocalGame>::allocator<OneLocalGame>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@UOneLocalGame@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<OneLocalGame>::allocator<OneLocalGame>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@I@Z PROC NEAR ; std::allocator<OneLocalGame>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@I@Z ENDP ; std::allocator<OneLocalGame>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UOneLocalGame@@@std@@YAPAUOneLocalGame@@IPAU1@@Z ; std::_Allocate<OneLocalGame>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@UOneLocalGame@@@std@@QAEPAUOneLocalGame@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UOneLocalGame@@@std@@QAEPAUOneLocalGame@@I@Z PROC NEAR ; std::allocator<OneLocalGame>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@UOneLocalGame@@@std@@YAPAUOneLocalGame@@IPAU1@@Z ; std::_Allocate<OneLocalGame>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@UOneLocalGame@@@std@@QAEPAUOneLocalGame@@I@Z ENDP ; std::allocator<OneLocalGame>::allocate
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@H@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator+=
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Hiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@H@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator-
; Function compile flags: /Odt
;	COMDAT ??Giterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T203118 = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR $T203118[ebp], ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR $T203118[ebp]
  00018	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator-

; 280  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Giterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator-
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAE@PAUOneLocalGame@@@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode, COMDAT

; 112  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 114  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval, COMDAT

; 117  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 119  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy
; Function compile flags: /Odt
;	COMDAT ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnext$ = -8						; size = 4
__Pnode$ = -4						; size = 4
?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear, COMDAT
; _this$ = ecx

; 610  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00015	83 c4 04	 add	 esp, 4
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	89 55 fc	 mov	 DWORD PTR __Pnode$[ebp], edx

; 613  : 		_Nextnode(_Myhead) = _Myhead;

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00029	83 c4 04	 add	 esp, 4
  0002c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00032	89 08		 mov	 DWORD PTR [eax], ecx

; 614  : 		_Prevnode(_Myhead) = _Myhead;

  00034	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  00040	83 c4 04	 add	 esp, 4
  00043	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	89 10		 mov	 DWORD PTR [eax], edx

; 615  : 		_Mysize = 0;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

  00055	eb 06		 jmp	 SHORT $L201273
$L201274:
  00057	8b 4d f8	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  0005a	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx
$L201273:
  0005d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00063	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00066	74 2d		 je	 SHORT $L201270

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

  00068	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00071	83 c4 04	 add	 esp, 4
  00074	8b 10		 mov	 edx, DWORD PTR [eax]
  00076	89 55 f8	 mov	 DWORD PTR __Pnext$[ebp], edx

; 620  : 			this->_Alnod.destroy(_Pnode);

  00079	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy

; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

  00085	6a 01		 push	 1
  00087	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 622  : 			}

  00093	eb c2		 jmp	 SHORT $L201274
$L201270:

; 623  : 		}

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear
_TEXT	ENDS
PUBLIC	??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>
PUBLIC	??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
;	COMDAT ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = 8						; size = 1
??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 64   : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
  0001d	8d 4d 08	 lea	 ecx, DWORD PTR __Al$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 01	 add	 ecx, 1
  00027	e8 00 00 00 00	 call	 ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>

; 65   : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 157  : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 170  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 			_Ptr = _Nextnode(_Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00012	83 c4 04	 add	 esp, 4
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 02		 mov	 DWORD PTR [edx], eax

; 172  : 			return (*this);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 173  : 			}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++
_TEXT	ENDS
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203154 DD	0ffffffffH
	DD	FLAT:$L203146
	DD	00H
	DD	FLAT:$L203147
	DD	01H
	DD	FLAT:$L203148
	DD	02H
	DD	FLAT:$L203149
$T203152 DD	019930520H
	DD	04H
	DD	FLAT:$T203154
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0OneLocalGame@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0OneLocalGame@@QAE@ABU0@@Z PROC NEAR			; OneLocalGame::OneLocalGame, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0OneLocalGame@@QAE@ABU0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00033	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00036	51		 push	 ecx
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00043	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00047	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0004a	83 c2 38	 add	 edx, 56			; 00000038H
  0004d	52		 push	 edx
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	83 c1 38	 add	 ecx, 56			; 00000038H
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0005a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0005e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00061	83 c0 54	 add	 eax, 84			; 00000054H
  00064	50		 push	 eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	83 c1 54	 add	 ecx, 84			; 00000054H
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00071	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00075	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00078	83 c1 70	 add	 ecx, 112		; 00000070H
  0007b	51		 push	 ecx
  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	83 c1 70	 add	 ecx, 112		; 00000070H
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00088	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0008e	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00094	89 8a 8c 00 00
	00		 mov	 DWORD PTR [edx+140], ecx
  0009a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203146:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203147:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0000f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203148:
  00015	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 38	 add	 ecx, 56			; 00000038H
  0001b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203149:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 54	 add	 ecx, 84			; 00000054H
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0OneLocalGame@@QAE@ABU0@@Z:
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203152
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0OneLocalGame@@QAE@ABU0@@Z ENDP			; OneLocalGame::OneLocalGame
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UOneLocalGame@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UOneLocalGame@@@std@@QBEIXZ PROC NEAR ; std::allocator<OneLocalGame>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc 71 1c
	c7 01		 mov	 DWORD PTR __Count$[ebp], 29826161 ; 01c71c71H

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L203162
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L203163
$L203162:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L203163:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@UOneLocalGame@@@std@@QBEIXZ ENDP	; std::allocator<OneLocalGame>::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	69 c0 90 00 00
	00		 imul	 eax, 144		; 00000090H
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	03 01		 add	 eax, DWORD PTR [ecx]
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	89 02		 mov	 DWORD PTR [edx], eax

; 257  : 			return (*this);

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Yiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator+=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	99		 cdq
  00012	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  00017	f7 f9		 idiv	 ecx

; 144  : 			}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 44   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>

; 45   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??_R4?$CArray@UElemPos@CMarkup@@AAU12@@@6B@	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CArray@UElemPos@CMarkup@@AAU12@@@@8	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &> `RTTI Type Descriptor'
PUBLIC	??_R3?$CArray@UElemPos@CMarkup@@AAU12@@@8	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CArray@UElemPos@CMarkup@@AAU12@@@8	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@?$CArray@UElemPos@CMarkup@@AAU12@@@8 ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??0CObject@@IAE@XZ				; CObject::CObject
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	?Serialize@?$CArray@UElemPos@CMarkup@@AAU12@@@UAEXAAVCArchive@@@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::Serialize
PUBLIC	??_7?$CArray@UElemPos@CMarkup@@AAU12@@@6B@	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`vftable'
PUBLIC	??_G?$CArray@UElemPos@CMarkup@@AAU12@@@UAEPAXI@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ:NEAR ; CObject::GetRuntimeClass
EXTRN	??_E?$CArray@UElemPos@CMarkup@@AAU12@@@UAEPAXI@Z:NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`vector deleting destructor'
;	COMDAT ??_7?$CArray@UElemPos@CMarkup@@AAU12@@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
CONST	SEGMENT
??_7?$CArray@UElemPos@CMarkup@@AAU12@@@6B@ DD FLAT:??_R4?$CArray@UElemPos@CMarkup@@AAU12@@@6B@ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CArray@UElemPos@CMarkup@@AAU12@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@UElemPos@CMarkup@@AAU12@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4?$CArray@UElemPos@CMarkup@@AAU12@@@6B@
rdata$r	SEGMENT
??_R4?$CArray@UElemPos@CMarkup@@AAU12@@@6B@ DD 00H	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CArray@UElemPos@CMarkup@@AAU12@@@@8
	DD	FLAT:??_R3?$CArray@UElemPos@CMarkup@@AAU12@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CArray@UElemPos@CMarkup@@AAU12@@@@8
_DATA	SEGMENT
??_R0?AV?$CArray@UElemPos@CMarkup@@AAU12@@@@8 DD FLAT:??_7type_info@@6B@ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CArray@UElemPos@CMarkup@@AAU12@@@', 00H
_DATA	ENDS
;	COMDAT ??_R3?$CArray@UElemPos@CMarkup@@AAU12@@@8
rdata$r	SEGMENT
??_R3?$CArray@UElemPos@CMarkup@@AAU12@@@8 DD 00H	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CArray@UElemPos@CMarkup@@AAU12@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@UElemPos@CMarkup@@AAU12@@@8
rdata$r	SEGMENT
??_R2?$CArray@UElemPos@CMarkup@@AAU12@@@8 DD FLAT:??_R1A@?0A@A@?$CArray@UElemPos@CMarkup@@AAU12@@@8 ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$CArray@UElemPos@CMarkup@@AAU12@@@8
rdata$r	SEGMENT
??_R1A@?0A@A@?$CArray@UElemPos@CMarkup@@AAU12@@@8 DD FLAT:??_R0?AV?$CArray@UElemPos@CMarkup@@AAU12@@@@8 ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??0?$CArray@UElemPos@CMarkup@@AAU12@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CArray@UElemPos@CMarkup@@AAU12@@@QAE@XZ PROC NEAR	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::CArray<CMarkup::ElemPos,CMarkup::ElemPos &>, COMDAT
; _this$ = ecx

; 349  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CObject@@IAE@XZ	; CObject::CObject
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@UElemPos@CMarkup@@AAU12@@@6B@

; 350  : 	m_pData = NULL;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 351  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 352  : }

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??0?$CArray@UElemPos@CMarkup@@AAU12@@@QAE@XZ ENDP	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::CArray<CMarkup::ElemPos,CMarkup::ElemPos &>
_TEXT	ENDS
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Odt
;	COMDAT ??1?$CArray@UElemPos@CMarkup@@AAU12@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T203177 = -8						; size = 4
_i$201364 = -4						; size = 4
??1?$CArray@UElemPos@CMarkup@@AAU12@@@UAE@XZ PROC NEAR	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::~CArray<CMarkup::ElemPos,CMarkup::ElemPos &>, COMDAT
; _this$ = ecx

; 356  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@UElemPos@CMarkup@@AAU12@@@6B@

; 357  : 	ASSERT_VALID(this);
; 358  : 
; 359  : 	if (m_pData != NULL)

  00012	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00019	74 34		 je	 SHORT $L201361

; 360  : 	{
; 361  : 		for( int i = 0; i < m_nSize; i++ )

  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$201364[ebp], 0
  00022	eb 09		 jmp	 SHORT $L201365
$L201366:
  00024	8b 55 fc	 mov	 edx, DWORD PTR _i$201364[ebp]
  00027	83 c2 01	 add	 edx, 1
  0002a	89 55 fc	 mov	 DWORD PTR _i$201364[ebp], edx
$L201365:
  0002d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _i$201364[ebp]
  00033	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00036	7d 02		 jge	 SHORT $L201367

; 362  : 			(m_pData + i)->~TYPE();

  00038	eb ea		 jmp	 SHORT $L201366
$L201367:

; 363  : 		delete[] (BYTE*)m_pData;

  0003a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00040	89 45 f8	 mov	 DWORD PTR $T203177[ebp], eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR $T203177[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0004c	83 c4 04	 add	 esp, 4
$L201361:

; 364  : 	}
; 365  : }

  0004f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ??1CObject@@UAE@XZ	; CObject::~CObject
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
??1?$CArray@UElemPos@CMarkup@@AAU12@@@UAE@XZ ENDP	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::~CArray<CMarkup::ElemPos,CMarkup::ElemPos &>
_TEXT	ENDS
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?IsStoring@CArchive@@QBEHXZ			; CArchive::IsStoring
PUBLIC	??$SerializeElements@UElemPos@CMarkup@@@@YGXAAVCArchive@@PAUElemPos@CMarkup@@H@Z ; SerializeElements<CMarkup::ElemPos>
PUBLIC	?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::SetSize
EXTRN	?ReadCount@CArchive@@QAEKXZ:NEAR		; CArchive::ReadCount
EXTRN	?WriteCount@CArchive@@QAEXK@Z:NEAR		; CArchive::WriteCount
; Function compile flags: /Odt
;	COMDAT ?Serialize@?$CArray@UElemPos@CMarkup@@AAU12@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nOldSize$201379 = -4					; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CArray@UElemPos@CMarkup@@AAU12@@@UAEXAAVCArchive@@@Z PROC NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::Serialize, COMDAT
; _this$ = ecx

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 630  : 	ASSERT_VALID(this);
; 631  : 
; 632  : 	CObject::Serialize(ar);

  00009	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?Serialize@CObject@@UAEXAAVCArchive@@@Z ; CObject::Serialize

; 633  : 	if (ar.IsStoring())

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00018	e8 00 00 00 00	 call	 ?IsStoring@CArchive@@QBEHXZ ; CArchive::IsStoring
  0001d	85 c0		 test	 eax, eax
  0001f	74 11		 je	 SHORT $L201377

; 634  : 	{
; 635  : 		ar.WriteCount(m_nSize);

  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00027	52		 push	 edx
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0002b	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 636  : 	}
; 637  : 	else

  00030	eb 19		 jmp	 SHORT $L201378
$L201377:

; 638  : 	{
; 639  : 		DWORD_PTR nOldSize = ar.ReadCount();

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00035	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount
  0003a	89 45 fc	 mov	 DWORD PTR _nOldSize$201379[ebp], eax

; 640  : 		SetSize(nOldSize, -1);

  0003d	6a ff		 push	 -1
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _nOldSize$201379[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::SetSize
$L201378:

; 641  : 	}
; 642  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00051	52		 push	 edx
  00052	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00058	51		 push	 ecx
  00059	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ??$SerializeElements@UElemPos@CMarkup@@@@YGXAAVCArchive@@PAUElemPos@CMarkup@@H@Z ; SerializeElements<CMarkup::ElemPos>

; 643  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?Serialize@?$CArray@UElemPos@CMarkup@@AAU12@@@UAEXAAVCArchive@@@Z ENDP ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::Serialize
_TEXT	ENDS
PUBLIC	??0?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAE@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@1@@Z ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
;	COMDAT ??$back_inserter@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Cont$ = 12						; size = 4
??$back_inserter@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@@Z PROC NEAR ; std::back_inserter<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >, COMDAT

; 55   : 	{	// return a back_insert_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   : 	return (std::back_insert_iterator<_Container>(_Cont));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Cont$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAE@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@1@@Z ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 57   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$back_inserter@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@@Z ENDP ; std::back_inserter<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@@Z ; std::_Ptr_cat<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >
PUBLIC	??$_Copy_opt@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T203185 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$copy@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@@Z PROC NEAR ; std::copy<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >, COMDAT

; 1039 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00004	8d 45 14	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@@Z ; std::_Ptr_cat<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203185[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203185[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Copy_opt@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >
  00030	83 c4 14	 add	 esp, 20			; 00000014H
  00033	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1041 : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$copy@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@@Z ENDP ; std::copy<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUOneLocalGame@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOneLocalGame@@0@Z ; std::_Ptr_cat<OneLocalGame *,OneLocalGame *>
PUBLIC	??$_Copy_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<OneLocalGame *,OneLocalGame *>
; Function compile flags: /Odt
;	COMDAT ??$copy@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z
_TEXT	SEGMENT
$T203188 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z PROC NEAR ; std::copy<OneLocalGame *,OneLocalGame *>, COMDAT

; 1039 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUOneLocalGame@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOneLocalGame@@0@Z ; std::_Ptr_cat<OneLocalGame *,OneLocalGame *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203188[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203188[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<OneLocalGame *,OneLocalGame *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1041 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z ENDP ; std::copy<OneLocalGame *,OneLocalGame *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<OneLocalGame,std::allocator<OneLocalGame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@@Z
_TEXT	SEGMENT
$T203191 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@@Z PROC NEAR ; std::_Destroy_range<OneLocalGame,std::allocator<OneLocalGame> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUOneLocalGame@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOneLocalGame@@0@Z ; std::_Ptr_cat<OneLocalGame *,OneLocalGame *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203191[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203191[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<OneLocalGame,std::allocator<OneLocalGame> >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@@Z ENDP ; std::_Destroy_range<OneLocalGame,std::allocator<OneLocalGame> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<OneLocalGame *,unsigned int,OneLocalGame,std::allocator<OneLocalGame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@@Z
_TEXT	SEGMENT
$T203194 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<OneLocalGame *,unsigned int,OneLocalGame,std::allocator<OneLocalGame> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00004	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUOneLocalGame@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOneLocalGame@@0@Z ; std::_Ptr_cat<OneLocalGame *,OneLocalGame *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203194[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203194[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<OneLocalGame *,unsigned int,OneLocalGame,std::allocator<OneLocalGame> >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@@Z ENDP ; std::_Uninitialized_fill_n<OneLocalGame *,unsigned int,OneLocalGame,std::allocator<OneLocalGame> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@@Z ; std::_Uninitialized_copy<OneLocalGame *,OneLocalGame *,std::allocator<OneLocalGame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAUOneLocalGame@@@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUOneLocalGame@@@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU2@00@Z PROC NEAR ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ucopy<OneLocalGame *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@@Z ; std::_Uninitialized_copy<OneLocalGame *,OneLocalGame *,std::allocator<OneLocalGame> >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAUOneLocalGame@@@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@IAEPAUOneLocalGame@@PAU2@00@Z ENDP ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::_Ucopy<OneLocalGame *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAUOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@0ABU1@@Z PROC NEAR ; std::fill<OneLocalGame *,OneLocalGame>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1135 : 	for (; _First != _Last; ++_First)

  00003	eb 0b		 jmp	 SHORT $L201573
$L201574:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0000d	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L201573:
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00013	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00016	74 0e		 je	 SHORT $L201572

; 1136 : 		*_First = _Val;

  00018	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0001b	52		 push	 edx
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	e8 00 00 00 00	 call	 ??4OneLocalGame@@QAEAAU0@ABU0@@Z
  00024	eb df		 jmp	 SHORT $L201574
$L201572:

; 1137 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$fill@PAUOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@0ABU1@@Z ENDP ; std::fill<OneLocalGame *,OneLocalGame>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<OneLocalGame *,OneLocalGame *>
; Function compile flags: /Odt
;	COMDAT ??$copy_backward@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z
_TEXT	SEGMENT
$T203201 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z PROC NEAR ; std::copy_backward<OneLocalGame *,OneLocalGame *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUOneLocalGame@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOneLocalGame@@0@Z ; std::_Ptr_cat<OneLocalGame *,OneLocalGame *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203201[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203201[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<OneLocalGame *,OneLocalGame *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy_backward@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00@Z ENDP ; std::copy_backward<OneLocalGame *,OneLocalGame *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@UOneLocalGame@@@std@@YAPAUOneLocalGame@@IPAU1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UOneLocalGame@@@std@@YAPAUOneLocalGame@@IPAU1@@Z PROC NEAR ; std::_Allocate<OneLocalGame>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	69 c0 90 00 00
	00		 imul	 eax, 144		; 00000090H
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00012	83 c4 04	 add	 esp, 4

; 35   : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$_Allocate@UOneLocalGame@@@std@@YAPAUOneLocalGame@@IPAU1@@Z ENDP ; std::_Allocate<OneLocalGame>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Odt
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
$T203210 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	50		 push	 eax
  0000a	6a 04		 push	 4
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00011	83 c4 08	 add	 esp, 8
  00014	89 45 fc	 mov	 DWORD PTR $T203210[ebp], eax
  00017	83 7d fc 00	 cmp	 DWORD PTR $T203210[ebp], 0
  0001b	74 12		 je	 SHORT $L203211
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T203210[ebp]
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	89 01		 mov	 DWORD PTR [ecx], eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR $T203210[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0002d	eb 07		 jmp	 SHORT $L201602
$L203211:
  0002f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L201602:

; 43   : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
_TEXT	ENDS
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
; Function compile flags: /Odt
;	COMDAT ??_G?$CArray@UElemPos@CMarkup@@AAU12@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CArray@UElemPos@CMarkup@@AAU12@@@UAEPAXI@Z PROC NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CArray@UElemPos@CMarkup@@AAU12@@@UAE@XZ ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::~CArray<CMarkup::ElemPos,CMarkup::ElemPos &>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $L201613
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L201613:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_G?$CArray@UElemPos@CMarkup@@AAU12@@@UAEPAXI@Z ENDP	; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
_TEXT	ENDS
;	COMDAT ??0?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAE@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Cont$ = 8						; size = 4
??0?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAE@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@1@@Z PROC NEAR ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >, COMDAT
; _this$ = ecx

; 23   : 		{	// construct with container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Cont$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 24   : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAE@AAV?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@1@@Z ENDP ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0ElemPos@CMarkup@@QAE@XZ			; CMarkup::ElemPos::ElemPos
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:NEAR	; AfxThrowInvalidArgException
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
xdata$x	SEGMENT
$T203255 DD	0ffffffffH
	DD	FLAT:$L203249
	DD	0ffffffffH
	DD	FLAT:$L203250
	DD	0ffffffffH
	DD	FLAT:$L203251
$T203253 DD	019930520H
	DD	03H
	DD	FLAT:$T203255
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z
_TEXT	SEGMENT
tv246 = -112						; size = 4
tv196 = -108						; size = 4
tv197 = -104						; size = 4
tv183 = -100						; size = 4
tv142 = -96						; size = 4
tv83 = -92						; size = 4
_this$ = -88						; size = 4
$T203248 = -84						; size = 4
$T203245 = -80						; size = 4
$T203244 = -76						; size = 4
$T203243 = -72						; size = 4
$T203236 = -68						; size = 4
$T203235 = -64						; size = 4
$T203232 = -60						; size = 4
$T203231 = -56						; size = 4
$T203230 = -52						; size = 4
$T203227 = -48						; size = 4
_i$201699 = -44						; size = 4
_pNewData$201687 = -40					; size = 4
_nNewMax$201681 = -36					; size = 4
_i$201675 = -32						; size = 4
_i$201663 = -28						; size = 4
_i$201647 = -24						; size = 4
_nAllocSize$201638 = -20				; size = 4
_i$201629 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_nNewSize$ = 8						; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z PROC NEAR ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::SetSize, COMDAT
; _this$ = ecx

; 369  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 64	 sub	 esp, 100		; 00000064H
  0001b	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx

; 370  : 	ASSERT_VALID(this);
; 371  : 	ASSERT(nNewSize >= 0);
; 372  : 
; 373  : 	if(nNewSize < 0 )

  0001e	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  00022	7d 05		 jge	 SHORT $L201625

; 374  : 		AfxThrowInvalidArgException();

  00024	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L201625:

; 375  : 
; 376  : 	if (nGrowBy >= 0)

  00029	83 7d 0c 00	 cmp	 DWORD PTR _nGrowBy$[ebp], 0
  0002d	7c 09		 jl	 SHORT $L201626

; 377  : 		m_nGrowBy = nGrowBy;  // set new size

  0002f	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _nGrowBy$[ebp]
  00035	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$L201626:

; 378  : 
; 379  : 	if (nNewSize == 0)

  00038	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  0003c	75 60		 jne	 SHORT $L201627

; 380  : 	{
; 381  : 		// shrink to nothing
; 382  : 		if (m_pData != NULL)

  0003e	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00041	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00045	74 3e		 je	 SHORT $L201628

; 383  : 		{
; 384  : 			for( int i = 0; i < m_nSize; i++ )

  00047	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$201629[ebp], 0
  0004e	eb 09		 jmp	 SHORT $L201630
$L201631:
  00050	8b 45 f0	 mov	 eax, DWORD PTR _i$201629[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 45 f0	 mov	 DWORD PTR _i$201629[ebp], eax
$L201630:
  00059	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	8b 55 f0	 mov	 edx, DWORD PTR _i$201629[ebp]
  0005f	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00062	7d 02		 jge	 SHORT $L201632

; 385  : 				(m_pData + i)->~TYPE();

  00064	eb ea		 jmp	 SHORT $L201631
$L201632:

; 386  : 			delete[] (BYTE*)m_pData;

  00066	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006c	89 4d d0	 mov	 DWORD PTR $T203227[ebp], ecx
  0006f	8b 55 d0	 mov	 edx, DWORD PTR $T203227[ebp]
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00078	83 c4 04	 add	 esp, 4

; 387  : 			m_pData = NULL;

  0007b	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L201628:

; 388  : 		}
; 389  : 		m_nSize = m_nMaxSize = 0;

  00085	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0008f	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00092	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 390  : 	}
; 391  : 	else if (m_pData == NULL)

  00099	e9 57 03 00 00	 jmp	 $L203226
$L201627:
  0009e	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000a5	0f 85 d0 00 00
	00		 jne	 $L201636

; 392  : 	{
; 393  : 		// create buffer big enough to hold number of requested elements or
; 394  : 		// m_nGrowBy elements, whichever is larger.
; 395  : #ifdef SIZE_T_MAX
; 396  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 397  : #endif
; 398  : 		size_t nAllocSize = max(nNewSize, m_nGrowBy);

  000ab	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  000b1	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000b4	7e 08		 jle	 SHORT $L203228
  000b6	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  000b9	89 45 a4	 mov	 DWORD PTR tv83[ebp], eax
  000bc	eb 09		 jmp	 SHORT $L203229
$L203228:
  000be	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000c4	89 55 a4	 mov	 DWORD PTR tv83[ebp], edx
$L203229:
  000c7	8b 45 a4	 mov	 eax, DWORD PTR tv83[ebp]
  000ca	89 45 ec	 mov	 DWORD PTR _nAllocSize$201638[ebp], eax

; 399  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  000cd	8b 4d ec	 mov	 ecx, DWORD PTR _nAllocSize$201638[ebp]
  000d0	c1 e1 05	 shl	 ecx, 5
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000d9	83 c4 04	 add	 esp, 4
  000dc	89 45 cc	 mov	 DWORD PTR $T203230[ebp], eax
  000df	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  000e2	8b 45 cc	 mov	 eax, DWORD PTR $T203230[ebp]
  000e5	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 400  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  000e8	8b 4d ec	 mov	 ecx, DWORD PTR _nAllocSize$201638[ebp]
  000eb	c1 e1 05	 shl	 ecx, 5
  000ee	51		 push	 ecx
  000ef	6a 00		 push	 0
  000f1	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _memset
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 401  : 		for( int i = 0; i < nNewSize; i++ )

  00100	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$201647[ebp], 0
  00107	eb 09		 jmp	 SHORT $L201648
$L201649:
  00109	8b 4d e8	 mov	 ecx, DWORD PTR _i$201647[ebp]
  0010c	83 c1 01	 add	 ecx, 1
  0010f	89 4d e8	 mov	 DWORD PTR _i$201647[ebp], ecx
$L201648:
  00112	8b 55 e8	 mov	 edx, DWORD PTR _i$201647[ebp]
  00115	3b 55 08	 cmp	 edx, DWORD PTR _nNewSize$[ebp]
  00118	7d 4a		 jge	 SHORT $L201650

; 402  : #pragma push_macro("new")
; 403  : #undef new
; 404  : 			::new( (void*)( m_pData + i ) ) TYPE;

  0011a	8b 45 e8	 mov	 eax, DWORD PTR _i$201647[ebp]
  0011d	c1 e0 05	 shl	 eax, 5
  00120	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00126	50		 push	 eax
  00127	6a 20		 push	 32			; 00000020H
  00129	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0012e	83 c4 08	 add	 esp, 8
  00131	89 45 c4	 mov	 DWORD PTR $T203232[ebp], eax
  00134	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0013b	83 7d c4 00	 cmp	 DWORD PTR $T203232[ebp], 0
  0013f	74 0d		 je	 SHORT $L203233
  00141	8b 4d c4	 mov	 ecx, DWORD PTR $T203232[ebp]
  00144	e8 00 00 00 00	 call	 ??0ElemPos@CMarkup@@QAE@XZ ; CMarkup::ElemPos::ElemPos
  00149	89 45 a0	 mov	 DWORD PTR tv142[ebp], eax
  0014c	eb 07		 jmp	 SHORT $L203234
$L203233:
  0014e	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
$L203234:
  00155	8b 55 a0	 mov	 edx, DWORD PTR tv142[ebp]
  00158	89 55 c8	 mov	 DWORD PTR $T203231[ebp], edx
  0015b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00162	eb a5		 jmp	 SHORT $L201649
$L201650:

; 405  : #pragma pop_macro("new")
; 406  : 		m_nSize = nNewSize;

  00164	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00167	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  0016a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 407  : 		m_nMaxSize = nAllocSize;

  0016d	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00170	8b 45 ec	 mov	 eax, DWORD PTR _nAllocSize$201638[ebp]
  00173	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 408  : 	}
; 409  : 	else if (nNewSize <= m_nMaxSize)

  00176	e9 7a 02 00 00	 jmp	 $L203226
$L201636:
  0017b	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00181	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00184	0f 8f ea 00 00
	00		 jg	 $L201658

; 410  : 	{
; 411  : 		// it fits
; 412  : 		if (nNewSize > m_nSize)

  0018a	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0018d	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  00190	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00193	0f 8e a0 00 00
	00		 jle	 $L201659

; 413  : 		{
; 414  : 			// initialize the new elements
; 415  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00199	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  0019c	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  0019f	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  001a2	c1 e0 05	 shl	 eax, 5
  001a5	50		 push	 eax
  001a6	6a 00		 push	 0
  001a8	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001ae	c1 e2 05	 shl	 edx, 5
  001b1	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001b4	03 50 04	 add	 edx, DWORD PTR [eax+4]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 _memset
  001bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 416  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )

  001c0	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$201663[ebp], 0
  001c7	eb 09		 jmp	 SHORT $L201664
$L201665:
  001c9	8b 4d e4	 mov	 ecx, DWORD PTR _i$201663[ebp]
  001cc	83 c1 01	 add	 ecx, 1
  001cf	89 4d e4	 mov	 DWORD PTR _i$201663[ebp], ecx
$L201664:
  001d2	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  001d5	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  001d8	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  001db	39 45 e4	 cmp	 DWORD PTR _i$201663[ebp], eax
  001de	7d 57		 jge	 SHORT $L201666

; 417  : #pragma push_macro("new")
; 418  : #undef new
; 419  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;

  001e0	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001e6	c1 e2 05	 shl	 edx, 5
  001e9	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001ec	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ef	03 ca		 add	 ecx, edx
  001f1	8b 55 e4	 mov	 edx, DWORD PTR _i$201663[ebp]
  001f4	c1 e2 05	 shl	 edx, 5
  001f7	03 ca		 add	 ecx, edx
  001f9	51		 push	 ecx
  001fa	6a 20		 push	 32			; 00000020H
  001fc	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00201	83 c4 08	 add	 esp, 8
  00204	89 45 bc	 mov	 DWORD PTR $T203236[ebp], eax
  00207	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0020e	83 7d bc 00	 cmp	 DWORD PTR $T203236[ebp], 0
  00212	74 0d		 je	 SHORT $L203237
  00214	8b 4d bc	 mov	 ecx, DWORD PTR $T203236[ebp]
  00217	e8 00 00 00 00	 call	 ??0ElemPos@CMarkup@@QAE@XZ ; CMarkup::ElemPos::ElemPos
  0021c	89 45 9c	 mov	 DWORD PTR tv183[ebp], eax
  0021f	eb 07		 jmp	 SHORT $L203238
$L203237:
  00221	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv183[ebp], 0
$L203238:
  00228	8b 45 9c	 mov	 eax, DWORD PTR tv183[ebp]
  0022b	89 45 c0	 mov	 DWORD PTR $T203235[ebp], eax
  0022e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00235	eb 92		 jmp	 SHORT $L201665
$L201666:

; 420  : #pragma pop_macro("new")
; 421  : 		}
; 422  : 		else if (m_nSize > nNewSize)

  00237	eb 2d		 jmp	 SHORT $L201673
$L201659:
  00239	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0023f	3b 55 08	 cmp	 edx, DWORD PTR _nNewSize$[ebp]
  00242	7e 22		 jle	 SHORT $L201673

; 423  : 		{
; 424  : 			// destroy the old elements
; 425  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )

  00244	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$201675[ebp], 0
  0024b	eb 09		 jmp	 SHORT $L201676
$L201677:
  0024d	8b 45 e0	 mov	 eax, DWORD PTR _i$201675[ebp]
  00250	83 c0 01	 add	 eax, 1
  00253	89 45 e0	 mov	 DWORD PTR _i$201675[ebp], eax
$L201676:
  00256	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00259	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0025c	2b 55 08	 sub	 edx, DWORD PTR _nNewSize$[ebp]
  0025f	39 55 e0	 cmp	 DWORD PTR _i$201675[ebp], edx
  00262	7d 02		 jge	 SHORT $L201673

; 426  : 				(m_pData + nNewSize + i)->~TYPE();

  00264	eb e7		 jmp	 SHORT $L201677
$L201673:

; 427  : 		}
; 428  : 		m_nSize = nNewSize;

  00266	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00269	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  0026c	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 429  : 	}
; 430  : 	else

  0026f	e9 81 01 00 00	 jmp	 $L203226
$L201658:

; 431  : 	{
; 432  : 		// otherwise, grow array
; 433  : 		nGrowBy = m_nGrowBy;

  00274	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00277	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0027a	89 45 0c	 mov	 DWORD PTR _nGrowBy$[ebp], eax

; 434  : 		if (nGrowBy == 0)

  0027d	83 7d 0c 00	 cmp	 DWORD PTR _nGrowBy$[ebp], 0
  00281	75 45		 jne	 SHORT $L201680

; 435  : 		{
; 436  : 			// heuristically determine growth when nGrowBy == 0
; 437  : 			//  (this avoids heap fragmentation in many situations)
; 438  : 			nGrowBy = m_nSize / 8;

  00283	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00286	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00289	99		 cdq
  0028a	83 e2 07	 and	 edx, 7
  0028d	03 c2		 add	 eax, edx
  0028f	c1 f8 03	 sar	 eax, 3
  00292	89 45 0c	 mov	 DWORD PTR _nGrowBy$[ebp], eax

; 439  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  00295	83 7d 0c 04	 cmp	 DWORD PTR _nGrowBy$[ebp], 4
  00299	7d 09		 jge	 SHORT $L203241
  0029b	c7 45 98 04 00
	00 00		 mov	 DWORD PTR tv197[ebp], 4
  002a2	eb 1e		 jmp	 SHORT $L203242
$L203241:
  002a4	81 7d 0c 00 04
	00 00		 cmp	 DWORD PTR _nGrowBy$[ebp], 1024 ; 00000400H
  002ab	7e 09		 jle	 SHORT $L203239
  002ad	c7 45 94 00 04
	00 00		 mov	 DWORD PTR tv196[ebp], 1024 ; 00000400H
  002b4	eb 06		 jmp	 SHORT $L203240
$L203239:
  002b6	8b 55 0c	 mov	 edx, DWORD PTR _nGrowBy$[ebp]
  002b9	89 55 94	 mov	 DWORD PTR tv196[ebp], edx
$L203240:
  002bc	8b 45 94	 mov	 eax, DWORD PTR tv196[ebp]
  002bf	89 45 98	 mov	 DWORD PTR tv197[ebp], eax
$L203242:
  002c2	8b 4d 98	 mov	 ecx, DWORD PTR tv197[ebp]
  002c5	89 4d 0c	 mov	 DWORD PTR _nGrowBy$[ebp], ecx
$L201680:

; 440  : 		}
; 441  : 		INT_PTR nNewMax;
; 442  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  002c8	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  002cb	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  002ce	03 45 0c	 add	 eax, DWORD PTR _nGrowBy$[ebp]
  002d1	39 45 08	 cmp	 DWORD PTR _nNewSize$[ebp], eax
  002d4	7d 0e		 jge	 SHORT $L201682

; 443  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity

  002d6	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  002dc	03 55 0c	 add	 edx, DWORD PTR _nGrowBy$[ebp]
  002df	89 55 dc	 mov	 DWORD PTR _nNewMax$201681[ebp], edx

; 444  : 		else

  002e2	eb 06		 jmp	 SHORT $L201683
$L201682:

; 445  : 			nNewMax = nNewSize;  // no slush

  002e4	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  002e7	89 45 dc	 mov	 DWORD PTR _nNewMax$201681[ebp], eax
$L201683:

; 446  : 
; 447  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 448  : 		
; 449  : 		if(nNewMax  < m_nMaxSize)

  002ea	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  002ed	8b 55 dc	 mov	 edx, DWORD PTR _nNewMax$201681[ebp]
  002f0	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  002f3	7d 05		 jge	 SHORT $L201685

; 450  : 			AfxThrowInvalidArgException();

  002f5	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L201685:

; 451  : 
; 452  : #ifdef SIZE_T_MAX
; 453  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 454  : #endif
; 455  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  002fa	8b 45 dc	 mov	 eax, DWORD PTR _nNewMax$201681[ebp]
  002fd	c1 e0 05	 shl	 eax, 5
  00300	50		 push	 eax
  00301	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00306	83 c4 04	 add	 esp, 4
  00309	89 45 b8	 mov	 DWORD PTR $T203243[ebp], eax
  0030c	8b 4d b8	 mov	 ecx, DWORD PTR $T203243[ebp]
  0030f	89 4d d8	 mov	 DWORD PTR _pNewData$201687[ebp], ecx

; 456  : 
; 457  : 		// copy new data from old
; 458  : 		memcpy(pNewData, m_pData, (size_t)m_nSize * sizeof(TYPE));

  00312	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00315	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00318	c1 e0 05	 shl	 eax, 5
  0031b	50		 push	 eax
  0031c	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0031f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00322	52		 push	 edx
  00323	8b 45 d8	 mov	 eax, DWORD PTR _pNewData$201687[ebp]
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 _memcpy
  0032c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 459  : 
; 460  : 		// construct remaining elements
; 461  : 		ASSERT(nNewSize > m_nSize);
; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  0032f	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00332	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00335	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  00338	c1 e2 05	 shl	 edx, 5
  0033b	52		 push	 edx
  0033c	6a 00		 push	 0
  0033e	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00341	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00344	c1 e1 05	 shl	 ecx, 5
  00347	03 4d d8	 add	 ecx, DWORD PTR _pNewData$201687[ebp]
  0034a	51		 push	 ecx
  0034b	e8 00 00 00 00	 call	 _memset
  00350	83 c4 0c	 add	 esp, 12			; 0000000cH

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )

  00353	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$201699[ebp], 0
  0035a	eb 09		 jmp	 SHORT $L201700
$L201701:
  0035c	8b 55 d4	 mov	 edx, DWORD PTR _i$201699[ebp]
  0035f	83 c2 01	 add	 edx, 1
  00362	89 55 d4	 mov	 DWORD PTR _i$201699[ebp], edx
$L201700:
  00365	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00368	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  0036b	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  0036e	39 4d d4	 cmp	 DWORD PTR _i$201699[ebp], ecx
  00371	7d 52		 jge	 SHORT $L201702

; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;

  00373	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00376	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00379	c1 e0 05	 shl	 eax, 5
  0037c	03 45 d8	 add	 eax, DWORD PTR _pNewData$201687[ebp]
  0037f	8b 4d d4	 mov	 ecx, DWORD PTR _i$201699[ebp]
  00382	c1 e1 05	 shl	 ecx, 5
  00385	03 c1		 add	 eax, ecx
  00387	50		 push	 eax
  00388	6a 20		 push	 32			; 00000020H
  0038a	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0038f	83 c4 08	 add	 esp, 8
  00392	89 45 b0	 mov	 DWORD PTR $T203245[ebp], eax
  00395	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0039c	83 7d b0 00	 cmp	 DWORD PTR $T203245[ebp], 0
  003a0	74 0d		 je	 SHORT $L203246
  003a2	8b 4d b0	 mov	 ecx, DWORD PTR $T203245[ebp]
  003a5	e8 00 00 00 00	 call	 ??0ElemPos@CMarkup@@QAE@XZ ; CMarkup::ElemPos::ElemPos
  003aa	89 45 90	 mov	 DWORD PTR tv246[ebp], eax
  003ad	eb 07		 jmp	 SHORT $L203247
$L203246:
  003af	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv246[ebp], 0
$L203247:
  003b6	8b 55 90	 mov	 edx, DWORD PTR tv246[ebp]
  003b9	89 55 b4	 mov	 DWORD PTR $T203244[ebp], edx
  003bc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003c3	eb 97		 jmp	 SHORT $L201701
$L201702:

; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  003c5	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  003c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003cb	89 4d ac	 mov	 DWORD PTR $T203248[ebp], ecx
  003ce	8b 55 ac	 mov	 edx, DWORD PTR $T203248[ebp]
  003d1	52		 push	 edx
  003d2	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  003d7	83 c4 04	 add	 esp, 4

; 471  : 		m_pData = pNewData;

  003da	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  003dd	8b 4d d8	 mov	 ecx, DWORD PTR _pNewData$201687[ebp]
  003e0	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 472  : 		m_nSize = nNewSize;

  003e3	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  003e6	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  003e9	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 473  : 		m_nMaxSize = nNewMax;

  003ec	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ef	8b 55 dc	 mov	 edx, DWORD PTR _nNewMax$201681[ebp]
  003f2	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L203226:

; 474  : 	}
; 475  : }

  003f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  003ff	8b e5		 mov	 esp, ebp
  00401	5d		 pop	 ebp
  00402	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203249:
  00000	8b 45 e8	 mov	 eax, DWORD PTR _i$201647[ebp]
  00003	c1 e0 05	 shl	 eax, 5
  00006	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00009	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0000c	50		 push	 eax
  0000d	8b 55 c4	 mov	 edx, DWORD PTR $T203232[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00016	83 c4 08	 add	 esp, 8
  00019	c3		 ret	 0
$L203250:
  0001a	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00020	c1 e1 05	 shl	 ecx, 5
  00023	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00029	03 c1		 add	 eax, ecx
  0002b	8b 4d e4	 mov	 ecx, DWORD PTR _i$201663[ebp]
  0002e	c1 e1 05	 shl	 ecx, 5
  00031	03 c1		 add	 eax, ecx
  00033	50		 push	 eax
  00034	8b 55 bc	 mov	 edx, DWORD PTR $T203236[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0003d	83 c4 08	 add	 esp, 8
  00040	c3		 ret	 0
$L203251:
  00041	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00047	c1 e1 05	 shl	 ecx, 5
  0004a	03 4d d8	 add	 ecx, DWORD PTR _pNewData$201687[ebp]
  0004d	8b 55 d4	 mov	 edx, DWORD PTR _i$201699[ebp]
  00050	c1 e2 05	 shl	 edx, 5
  00053	03 ca		 add	 ecx, edx
  00055	51		 push	 ecx
  00056	8b 45 b0	 mov	 eax, DWORD PTR $T203245[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0005f	83 c4 08	 add	 esp, 8
  00062	c3		 ret	 0
__ehhandler$?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z:
  00063	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203253
  00068	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SetSize@?$CArray@UElemPos@CMarkup@@AAU12@@@QAEXHH@Z ENDP ; CArray<CMarkup::ElemPos,CMarkup::ElemPos &>::SetSize
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?Clear@ElemPos@CMarkup@@QAEXXZ			; CMarkup::ElemPos::Clear
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\markup.h
;	COMDAT ??0ElemPos@CMarkup@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ElemPos@CMarkup@@QAE@XZ PROC NEAR			; CMarkup::ElemPos::ElemPos, COMDAT
; _this$ = ecx

; 86   : 		ElemPos() { Clear(); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Clear@ElemPos@CMarkup@@QAEXXZ ; CMarkup::ElemPos::Clear
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0ElemPos@CMarkup@@QAE@XZ ENDP				; CMarkup::ElemPos::ElemPos
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Clear@ElemPos@CMarkup@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@ElemPos@CMarkup@@QAEXXZ PROC NEAR		; CMarkup::ElemPos::Clear, COMDAT
; _this$ = ecx

; 90   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 91   : 			nStartL=0; nStartR=0; nEndL=0; nEndR=0; nReserved=0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 92   : 			iElemParent=0; iElemChild=0; iElemNext=0;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 93   : 		};

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?Clear@ElemPos@CMarkup@@QAEXXZ ENDP			; CMarkup::ElemPos::Clear
_TEXT	ENDS
EXTRN	?Read@CArchive@@QAEIPAXI@Z:NEAR			; CArchive::Read
EXTRN	?Write@CArchive@@QAEXPBXI@Z:NEAR		; CArchive::Write
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@UElemPos@CMarkup@@@@YGXAAVCArchive@@PAUElemPos@CMarkup@@H@Z
_TEXT	SEGMENT
tv79 = -32						; size = 4
tv69 = -28						; size = 4
_nElementsToRead$201729 = -24				; size = 4
_nElementsLeft$201725 = -20				; size = 4
_pData$201724 = -16					; size = 4
_nElementsToWrite$201719 = -12				; size = 4
_nElementsLeft$201715 = -8				; size = 4
_pData$201714 = -4					; size = 4
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@UElemPos@CMarkup@@@@YGXAAVCArchive@@PAUElemPos@CMarkup@@H@Z PROC NEAR ; SerializeElements<CMarkup::ElemPos>, COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 70   : 	ASSERT(nCount == 0 ||
; 71   : 		AfxIsValidAddress(pElements, (size_t)nCount * sizeof(TYPE)));
; 72   : 
; 73   : 	// default is bit-wise read/write
; 74   : 	if (ar.IsStoring())

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00009	e8 00 00 00 00	 call	 ?IsStoring@CArchive@@QBEHXZ ; CArchive::IsStoring
  0000e	85 c0		 test	 eax, eax
  00010	74 5c		 je	 SHORT $L201713

; 75   :    {
; 76   : 	  TYPE* pData;
; 77   : 	  UINT_PTR nElementsLeft;
; 78   : 
; 79   : 	  nElementsLeft = nCount;

  00012	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR _nElementsLeft$201715[ebp], eax

; 80   : 	  pData = pElements;

  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0001b	89 4d fc	 mov	 DWORD PTR _pData$201714[ebp], ecx
$L201717:

; 81   : 	  while( nElementsLeft > 0 )

  0001e	83 7d f8 00	 cmp	 DWORD PTR _nElementsLeft$201715[ebp], 0
  00022	76 48		 jbe	 SHORT $L201718

; 82   : 	  {
; 83   : 		 UINT nElementsToWrite;
; 84   : 
; 85   : 		 nElementsToWrite = UINT(min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00024	81 7d f8 ff ff
	ff 03		 cmp	 DWORD PTR _nElementsLeft$201715[ebp], 67108863 ; 03ffffffH
  0002b	73 08		 jae	 SHORT $L203266
  0002d	8b 55 f8	 mov	 edx, DWORD PTR _nElementsLeft$201715[ebp]
  00030	89 55 e4	 mov	 DWORD PTR tv69[ebp], edx
  00033	eb 07		 jmp	 SHORT $L203267
$L203266:
  00035	c7 45 e4 ff ff
	ff 03		 mov	 DWORD PTR tv69[ebp], 67108863 ; 03ffffffH
$L203267:
  0003c	8b 45 e4	 mov	 eax, DWORD PTR tv69[ebp]
  0003f	89 45 f4	 mov	 DWORD PTR _nElementsToWrite$201719[ebp], eax

; 86   : 		 ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  00042	8b 4d f4	 mov	 ecx, DWORD PTR _nElementsToWrite$201719[ebp]
  00045	c1 e1 05	 shl	 ecx, 5
  00048	51		 push	 ecx
  00049	8b 55 fc	 mov	 edx, DWORD PTR _pData$201714[ebp]
  0004c	52		 push	 edx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00050	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 87   : 		 nElementsLeft -= nElementsToWrite;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _nElementsLeft$201715[ebp]
  00058	2b 45 f4	 sub	 eax, DWORD PTR _nElementsToWrite$201719[ebp]
  0005b	89 45 f8	 mov	 DWORD PTR _nElementsLeft$201715[ebp], eax

; 88   : 		 pData += nElementsToWrite;

  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _nElementsToWrite$201719[ebp]
  00061	c1 e1 05	 shl	 ecx, 5
  00064	03 4d fc	 add	 ecx, DWORD PTR _pData$201714[ebp]
  00067	89 4d fc	 mov	 DWORD PTR _pData$201714[ebp], ecx

; 89   : 	  }

  0006a	eb b2		 jmp	 SHORT $L201717
$L201718:

; 90   :    }
; 91   : 	else

  0006c	eb 5a		 jmp	 SHORT $L201711
$L201713:

; 92   :    {
; 93   : 	  TYPE* pData;
; 94   : 	  UINT_PTR nElementsLeft;
; 95   : 
; 96   : 	  nElementsLeft = nCount;

  0006e	8b 55 10	 mov	 edx, DWORD PTR _nCount$[ebp]
  00071	89 55 ec	 mov	 DWORD PTR _nElementsLeft$201725[ebp], edx

; 97   : 	  pData = pElements;

  00074	8b 45 0c	 mov	 eax, DWORD PTR _pElements$[ebp]
  00077	89 45 f0	 mov	 DWORD PTR _pData$201724[ebp], eax
$L201727:

; 98   : 	  while( nElementsLeft > 0 )

  0007a	83 7d ec 00	 cmp	 DWORD PTR _nElementsLeft$201725[ebp], 0
  0007e	76 48		 jbe	 SHORT $L201711

; 99   : 	  {
; 100  : 		 UINT nElementsToRead;
; 101  : 
; 102  : 		 nElementsToRead = UINT(min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00080	81 7d ec ff ff
	ff 03		 cmp	 DWORD PTR _nElementsLeft$201725[ebp], 67108863 ; 03ffffffH
  00087	73 08		 jae	 SHORT $L203268
  00089	8b 4d ec	 mov	 ecx, DWORD PTR _nElementsLeft$201725[ebp]
  0008c	89 4d e0	 mov	 DWORD PTR tv79[ebp], ecx
  0008f	eb 07		 jmp	 SHORT $L203269
$L203268:
  00091	c7 45 e0 ff ff
	ff 03		 mov	 DWORD PTR tv79[ebp], 67108863 ; 03ffffffH
$L203269:
  00098	8b 55 e0	 mov	 edx, DWORD PTR tv79[ebp]
  0009b	89 55 e8	 mov	 DWORD PTR _nElementsToRead$201729[ebp], edx

; 103  : 		 ar.Read(pData, nElementsToRead*sizeof(TYPE));

  0009e	8b 45 e8	 mov	 eax, DWORD PTR _nElementsToRead$201729[ebp]
  000a1	c1 e0 05	 shl	 eax, 5
  000a4	50		 push	 eax
  000a5	8b 4d f0	 mov	 ecx, DWORD PTR _pData$201724[ebp]
  000a8	51		 push	 ecx
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  000ac	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 104  : 		 nElementsLeft -= nElementsToRead;

  000b1	8b 55 ec	 mov	 edx, DWORD PTR _nElementsLeft$201725[ebp]
  000b4	2b 55 e8	 sub	 edx, DWORD PTR _nElementsToRead$201729[ebp]
  000b7	89 55 ec	 mov	 DWORD PTR _nElementsLeft$201725[ebp], edx

; 105  : 		 pData += nElementsToRead;

  000ba	8b 45 e8	 mov	 eax, DWORD PTR _nElementsToRead$201729[ebp]
  000bd	c1 e0 05	 shl	 eax, 5
  000c0	03 45 f0	 add	 eax, DWORD PTR _pData$201724[ebp]
  000c3	89 45 f0	 mov	 DWORD PTR _pData$201724[ebp], eax

; 106  : 	  }

  000c6	eb b2		 jmp	 SHORT $L201727
$L201711:

; 107  :    }
; 108  : }

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 0c 00	 ret	 12			; 0000000cH
??$SerializeElements@UElemPos@CMarkup@@@@YGXAAVCArchive@@PAUElemPos@CMarkup@@H@Z ENDP ; SerializeElements<CMarkup::ElemPos>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@@Z PROC NEAR ; std::_Ptr_cat<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@@Z ENDP ; std::_Ptr_cat<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >
_TEXT	ENDS
PUBLIC	??4?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@ABUOneLocalGame@@@Z ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator=
PUBLIC	??D?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator*
PUBLIC	??E?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator++
; Function compile flags: /Odt
;	COMDAT ??$_Copy_opt@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Copy_opt@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >, COMDAT

; 1020 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1021 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	eb 10		 jmp	 SHORT $L201737
$L201738:
  00005	8d 4d 14	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00008	e8 00 00 00 00	 call	 ??E?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator++
  0000d	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEAAV012@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator++
$L201737:
  00015	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00018	50		 push	 eax
  00019	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0001c	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBE_NABV012@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::const_iterator::operator!=
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 1a		 je	 SHORT $L201739

; 1022 : 		*_Dest = *_First;

  00028	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0002b	e8 00 00 00 00	 call	 ??Diterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QBEAAUOneLocalGame@@XZ ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator::operator*
  00030	50		 push	 eax
  00031	8d 4d 14	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00034	e8 00 00 00 00	 call	 ??D?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator*
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 ??4?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@ABUOneLocalGame@@@Z ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator=
  00040	eb c3		 jmp	 SHORT $L201738
$L201739:

; 1023 : 	return (_Dest);

  00042	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00045	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
  00048	89 02		 mov	 DWORD PTR [edx], eax
  0004a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1024 : 	}

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??$_Copy_opt@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@V?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@0@Viterator@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::vector<OneLocalGame,std::allocator<OneLocalGame> >::iterator,std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > > >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUOneLocalGame@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOneLocalGame@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUOneLocalGame@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOneLocalGame@@0@Z PROC NEAR ; std::_Ptr_cat<OneLocalGame *,OneLocalGame *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAUOneLocalGame@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOneLocalGame@@0@Z ENDP ; std::_Ptr_cat<OneLocalGame *,OneLocalGame *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<OneLocalGame *,OneLocalGame *>, COMDAT

; 1020 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1021 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	eb 17		 jmp	 SHORT $L201743
$L201744:
  00005	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00008	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0000d	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00013	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00019	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$L201743:
  0001c	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001f	3b 55 0c	 cmp	 edx, DWORD PTR __Last$[ebp]
  00022	74 0e		 je	 SHORT $L201745

; 1022 : 		*_Dest = *_First;

  00024	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0002b	e8 00 00 00 00	 call	 ??4OneLocalGame@@QAEAAU0@ABU0@@Z
  00030	eb d3		 jmp	 SHORT $L201744
$L201745:

; 1023 : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1024 : 	}

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Copy_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<OneLocalGame *,OneLocalGame *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@@Z ; std::allocator<OneLocalGame>::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<OneLocalGame,std::allocator<OneLocalGame> >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 0b		 jmp	 SHORT $L201747
$L201748:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0000d	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L201747:
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00013	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00016	74 0e		 je	 SHORT $L201746

; 226  : 		_Al.destroy(_First);

  00018	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001b	52		 push	 edx
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001f	e8 00 00 00 00	 call	 ?destroy@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@@Z ; std::allocator<OneLocalGame>::destroy
  00024	eb df		 jmp	 SHORT $L201748
$L201746:

; 227  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Destroy_range@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@0AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<OneLocalGame,std::allocator<OneLocalGame> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@ABU3@@Z ; std::allocator<OneLocalGame>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T203287 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T203289 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L203283
$T203288 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T203289
$T203285 DD	019930520H
	DD	02H
	DD	FLAT:$T203287
	DD	01H
	DD	FLAT:$T203288
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<OneLocalGame *,unsigned int,OneLocalGame,std::allocator<OneLocalGame> >, COMDAT

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 208  : 	_FwdIt _Next = _First;

  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 209  : 
; 210  : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  0002d	eb 15		 jmp	 SHORT $L201753
$L201754:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00032	83 e9 01	 sub	 ecx, 1
  00035	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	81 c2 90 00 00
	00		 add	 edx, 144		; 00000090H
  00041	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L201753:
  00044	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00048	76 12		 jbe	 SHORT $L201755

; 212  : 		_Al.construct(_First, _Val);

  0004a	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00051	51		 push	 ecx
  00052	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00055	e8 00 00 00 00	 call	 ?construct@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@ABU3@@Z ; std::allocator<OneLocalGame>::construct
  0005a	eb d3		 jmp	 SHORT $L201754
$L201755:
  0005c	eb 2d		 jmp	 SHORT $L203282
$L203283:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

  0005e	eb 0c		 jmp	 SHORT $L201756
$L201757:
  00060	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00063	81 c2 90 00 00
	00		 add	 edx, 144		; 00000090H
  00069	89 55 ec	 mov	 DWORD PTR __Next$[ebp], edx
$L201756:
  0006c	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0006f	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  00072	74 0e		 je	 SHORT $L201758

; 215  : 		_Al.destroy(_Next);

  00074	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00077	51		 push	 ecx
  00078	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0007b	e8 00 00 00 00	 call	 ?destroy@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@@Z ; std::allocator<OneLocalGame>::destroy
  00080	eb de		 jmp	 SHORT $L201757
$L201758:

; 216  : 	_RERAISE;

  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203282:

; 217  : 	_CATCH_END

  0008b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$L203281:

; 218  : 	}

  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203285
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAUOneLocalGame@@IU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAXPAUOneLocalGame@@IABU1@AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<OneLocalGame *,unsigned int,OneLocalGame,std::allocator<OneLocalGame> >
PUBLIC	??$_Uninit_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<OneLocalGame *,OneLocalGame *,std::allocator<OneLocalGame> >
; Function compile flags: /Odt
;	COMDAT ??$_Uninitialized_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@@Z
_TEXT	SEGMENT
$T203294 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<OneLocalGame *,OneLocalGame *,std::allocator<OneLocalGame> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUOneLocalGame@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOneLocalGame@@0@Z ; std::_Ptr_cat<OneLocalGame *,OneLocalGame *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T203294[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T203294[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<OneLocalGame *,OneLocalGame *,std::allocator<OneLocalGame> >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@@Z ENDP ; std::_Uninitialized_copy<OneLocalGame *,OneLocalGame *,std::allocator<OneLocalGame> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<OneLocalGame *,OneLocalGame *>, COMDAT

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L201801:

; 1049 : 	while (_First != _Last)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00009	74 26		 je	 SHORT $L201802

; 1050 : 		*--_Dest = *--_Last;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	81 e9 90 00 00
	00		 sub	 ecx, 144		; 00000090H
  00014	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  00017	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0001a	81 ea 90 00 00
	00		 sub	 edx, 144		; 00000090H
  00020	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0002a	e8 00 00 00 00	 call	 ??4OneLocalGame@@QAEAAU0@ABU0@@Z
  0002f	eb d2		 jmp	 SHORT $L201801
$L201802:

; 1051 : 	return (_Dest);

  00031	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1052 : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Copy_backward_opt@PAUOneLocalGame@@PAU1@@std@@YAPAUOneLocalGame@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<OneLocalGame *,OneLocalGame *>
_TEXT	ENDS
PUBLIC	??$_Construct@UOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@ABU1@@Z ; std::_Construct<OneLocalGame,OneLocalGame>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@ABU3@@Z PROC NEAR ; std::allocator<OneLocalGame>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@UOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@ABU1@@Z ; std::_Construct<OneLocalGame,OneLocalGame>
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@ABU3@@Z ENDP ; std::allocator<OneLocalGame>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UOneLocalGame@@@std@@YAXPAUOneLocalGame@@@Z ; std::_Destroy<OneLocalGame>
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@@Z PROC NEAR ; std::allocator<OneLocalGame>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@UOneLocalGame@@@std@@YAXPAUOneLocalGame@@@Z ; std::_Destroy<OneLocalGame>
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@@Z ENDP ; std::allocator<OneLocalGame>::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
_TEXT	ENDS
;	COMDAT ??4?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@ABUOneLocalGame@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??4?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@ABUOneLocalGame@@@Z PROC NEAR ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator=, COMDAT
; _this$ = ecx

; 28   : 		{	// push value into container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 		container->push_back(_Val);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00010	e8 00 00 00 00	 call	 ?push_back@?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@QAEXABUOneLocalGame@@@Z ; std::vector<OneLocalGame,std::allocator<OneLocalGame> >::push_back

; 30   : 		return (*this);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 31   : 		}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??4?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@ABUOneLocalGame@@@Z ENDP ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??D?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ PROC NEAR ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator*, COMDAT
; _this$ = ecx

; 34   : 		{	// pretend to return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 36   : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??D?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??E?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ PROC NEAR ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator++, COMDAT
; _this$ = ecx

; 39   : 		{	// pretend to preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 41   : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??E?$back_insert_iterator@V?$vector@UOneLocalGame@@V?$allocator@UOneLocalGame@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::back_insert_iterator<std::vector<OneLocalGame,std::allocator<OneLocalGame> > >::operator++
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T203314 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T203316 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L203310
$T203315 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T203316
$T203312 DD	019930520H
	DD	02H
	DD	FLAT:$T203314
	DD	01H
	DD	FLAT:$T203315
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<OneLocalGame *,OneLocalGame *,std::allocator<OneLocalGame> >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 78   : 	_FwdIt _Next = _Dest;

  00020	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 79   : 
; 80   : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  0002d	eb 18		 jmp	 SHORT $L201826
$L201827:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00038	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003e	81 c2 90 00 00
	00		 add	 edx, 144		; 00000090H
  00044	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L201826:
  00047	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0004a	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0004d	74 12		 je	 SHORT $L201828

; 82   : 		_Al.construct(_Dest, *_First);

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00052	51		 push	 ecx
  00053	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00056	52		 push	 edx
  00057	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0005a	e8 00 00 00 00	 call	 ?construct@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@ABU3@@Z ; std::allocator<OneLocalGame>::construct
  0005f	eb ce		 jmp	 SHORT $L201827
$L201828:
  00061	eb 2c		 jmp	 SHORT $L203309
$L203310:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  00063	eb 0b		 jmp	 SHORT $L201829
$L201830:
  00065	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00068	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0006d	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$L201829:
  00070	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00073	3b 4d 10	 cmp	 ecx, DWORD PTR __Dest$[ebp]
  00076	74 0e		 je	 SHORT $L201831

; 85   : 		_Al.destroy(_Next);

  00078	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  0007b	52		 push	 edx
  0007c	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0007f	e8 00 00 00 00	 call	 ?destroy@?$allocator@UOneLocalGame@@@std@@QAEXPAUOneLocalGame@@@Z ; std::allocator<OneLocalGame>::destroy
  00084	eb df		 jmp	 SHORT $L201830
$L201831:

; 86   : 	_RERAISE;

  00086	6a 00		 push	 0
  00088	6a 00		 push	 0
  0008a	e8 00 00 00 00	 call	 __CxxThrowException@8
$L203309:

; 87   : 	_CATCH_END

  0008f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 88   : 	return (_Dest);

  00096	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$L203308:

; 89   : 	}

  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203312
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAUOneLocalGame@@PAU1@V?$allocator@UOneLocalGame@@@std@@@std@@YAPAUOneLocalGame@@PAU1@00AAV?$allocator@UOneLocalGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<OneLocalGame *,OneLocalGame *,std::allocator<OneLocalGame> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T203329 DD	0ffffffffH
	DD	FLAT:$L203325
$T203327 DD	019930520H
	DD	01H
	DD	FLAT:$T203329
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Construct@UOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -24						; size = 4
$T203322 = -20						; size = 4
$T203321 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@ABU1@@Z PROC NEAR ; std::_Construct<OneLocalGame,OneLocalGame>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001e	50		 push	 eax
  0001f	68 90 00 00 00	 push	 144			; 00000090H
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 ec	 mov	 DWORD PTR $T203322[ebp], eax
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	83 7d ec 00	 cmp	 DWORD PTR $T203322[ebp], 0
  0003a	74 11		 je	 SHORT $L203323
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0003f	51		 push	 ecx
  00040	8b 4d ec	 mov	 ecx, DWORD PTR $T203322[ebp]
  00043	e8 00 00 00 00	 call	 ??0OneLocalGame@@QAE@ABU0@@Z
  00048	89 45 e8	 mov	 DWORD PTR tv74[ebp], eax
  0004b	eb 07		 jmp	 SHORT $L203324
$L203323:
  0004d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L203324:
  00054	8b 55 e8	 mov	 edx, DWORD PTR tv74[ebp]
  00057	89 55 f0	 mov	 DWORD PTR $T203321[ebp], edx
  0005a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 43   : 	}

  00061	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00064	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203325:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ec	 mov	 ecx, DWORD PTR $T203322[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@ABU1@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203327
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Construct@UOneLocalGame@@U1@@std@@YAXPAUOneLocalGame@@ABU1@@Z ENDP ; std::_Construct<OneLocalGame,OneLocalGame>
PUBLIC	??_GOneLocalGame@@QAEPAXI@Z			; OneLocalGame::`scalar deleting destructor'
; Function compile flags: /Odt
;	COMDAT ??$_Destroy@UOneLocalGame@@@std@@YAXPAUOneLocalGame@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UOneLocalGame@@@std@@YAXPAUOneLocalGame@@@Z PROC NEAR ; std::_Destroy<OneLocalGame>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00003	6a 00		 push	 0
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??_GOneLocalGame@@QAEPAXI@Z

; 50   : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy@UOneLocalGame@@@std@@YAXPAUOneLocalGame@@@Z ENDP ; std::_Destroy<OneLocalGame>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GOneLocalGame@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GOneLocalGame@@QAEPAXI@Z PROC NEAR			; OneLocalGame::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1OneLocalGame@@QAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L201843
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L201843:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GOneLocalGame@@QAEPAXI@Z ENDP			; OneLocalGame::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.inl
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CObject@@IAE@XZ PROC NEAR				; CObject::CObject, COMDAT
; _this$ = ecx

; 21   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CObject@@IAE@XZ ENDP					; CObject::CObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CObject@@UAE@XZ PROC NEAR				; CObject::~CObject, COMDAT
; _this$ = ecx

; 23   : 	{ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC NEAR	; CObject::Serialize, COMDAT
; _this$ = ecx

; 25   : 	{ /* CObject does not serialize anything by default */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC NEAR				; CObject::operator delete, COMDAT

; 31   : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AssertValid@CObject@@UBEXXZ PROC NEAR			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 41   : 	{ /* no asserts in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC NEAR	; CObject::Dump, COMDAT
; _this$ = ecx

; 43   : 	{ /* no dumping in release builds */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsStoring@CArchive@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStoring@CArchive@@QBEHXZ PROC NEAR			; CArchive::IsStoring, COMDAT
; _this$ = ecx

; 133  : 	{ return (m_nMode & CArchive::load) == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000d	83 e0 01	 and	 eax, 1
  00010	f7 d8		 neg	 eax
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?IsStoring@CArchive@@QBEHXZ ENDP			; CArchive::IsStoring
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 28   : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203362 DD	0ffffffffH
	DD	FLAT:$L203357
$T203360 DD	019930520H
	DD	01H
	DD	FLAT:$T203362
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 20   : 		}

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203357:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203360
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102266
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102266:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203374 DD	0ffffffffH
	DD	FLAT:$L203369
$T203372 DD	019930520H
	DD	01H
	DD	FLAT:$T203374
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203369:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203372
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102332
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102332:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 373  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
; Function compile flags: /Odt
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = -4						; size = 4
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 375  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));

  00009	8b 45 08	 mov	 eax, DWORD PTR _nRequestedSize$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 377  : 		if (p == NULL)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0001f	75 04		 jne	 SHORT $L191833

; 378  : 			return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	eb 1a		 jmp	 SHORT $L191820
$L191833:

; 379  : 		
; 380  : 		// Add buffer to the list
; 381  : 		p->m_pNext = m_pHead;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00028	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	89 01		 mov	 DWORD PTR [ecx], eax

; 382  : 		m_pHead = p;

  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00035	89 11		 mov	 DWORD PTR [ecx], edx

; 383  : 		
; 384  : 		return p->GetData();

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
$L191820:

; 385  : 	}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
EXTRN	__imp__malloc:NEAR
; Function compile flags: /Odt
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC NEAR		; ATL::CCRTAllocator::Allocate, COMDAT

; 30   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 		return malloc(nBytes);

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0000d	83 c4 04	 add	 esp, 4

; 32   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
; Function compile flags: /Odt
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$191839 = -4						; size = 4
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 387  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$L191837:

; 388  : 		// Walk the list and free the buffers
; 389  : 		while (m_pHead != NULL)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 22		 je	 SHORT $L191835

; 390  : 		{
; 391  : 			CAtlSafeAllocBufferNode* p = m_pHead;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 fc	 mov	 DWORD PTR _p$191839[ebp], edx

; 392  : 			m_pHead = m_pHead->m_pNext;

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	89 02		 mov	 DWORD PTR [edx], eax

; 393  : 			Allocator::Free(p);

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _p$191839[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  0002e	83 c4 04	 add	 esp, 4

; 394  : 		}

  00031	eb d6		 jmp	 SHORT $L191837
$L191835:

; 395  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
EXTRN	__imp__free:NEAR
; Function compile flags: /Odt
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC NEAR		; ATL::CCRTAllocator::Free, COMDAT

; 35   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   : 		free(p);

  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000d	83 c4 04	 add	 esp, 4

; 37   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 217  : 	}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	39 01		 cmp	 DWORD PTR [ecx], eax
  00012	74 08		 je	 SHORT $L191843

; 227  : 		{
; 228  : 			FreeHeap();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L191843:

; 229  : 		}
; 230  : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 233  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 235  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z		; ATL::CW2AEX<128>::Init
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z PROC NEAR		; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 419  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	89 01		 mov	 DWORD PTR [ecx], eax

; 420  : 		Init( psz, _AtlGetConversionACP() );

  00012	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00017	50		 push	 eax
  00018	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  0001b	52		 push	 edx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init

; 421  : 	}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC NEAR			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 428  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 429  : 		if( m_psz != m_szBuffer )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	39 01		 cmp	 DWORD PTR [ecx], eax
  00012	74 0f		 je	 SHORT $L191854

; 430  : 		{
; 431  : 			free( m_psz );

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 02		 mov	 eax, DWORD PTR [edx]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00020	83 c4 04	 add	 esp, 4
$L191854:

; 432  : 		}
; 433  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC NEAR		; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 436  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 437  : 		return( m_psz );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 438  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );
; 278  : 		if( nBytes > t_nFixedBytes )

  00007	81 7d 08 80 00
	00 00		 cmp	 DWORD PTR _nBytes$[ebp], 128 ; 00000080H
  0000e	76 0e		 jbe	 SHORT $L193612

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

  00010	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

  0001c	eb 0b		 jmp	 SHORT $L193613
$L193612:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 04	 add	 ecx, 4
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	89 0a		 mov	 DWORD PTR [edx], ecx
$L193613:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]

; 288  : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  00012	83 c4 04	 add	 esp, 4

; 314  : 	}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nLengthW$ = -8						; size = 4
_nLengthA$ = -4						; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z PROC NEAR		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 442  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 443  : 		if (psz == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  0000d	75 0b		 jne	 SHORT $L193619

; 444  : 		{
; 445  : 			m_psz = NULL;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 446  : 			return;

  00018	eb 70		 jmp	 SHORT $L203411
$L193619:

; 447  : 		}
; 448  : 		int nLengthW = lstrlenW( psz )+1;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001d	51		 push	 ecx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00024	83 c0 01	 add	 eax, 1
  00027	89 45 f8	 mov	 DWORD PTR _nLengthW$[ebp], eax

; 449  : 		int nLengthA = nLengthW*2;

  0002a	8b 55 f8	 mov	 edx, DWORD PTR _nLengthW$[ebp]
  0002d	d1 e2		 shl	 edx, 1
  0002f	89 55 fc	 mov	 DWORD PTR _nLengthA$[ebp], edx

; 450  : 
; 451  : 		if( nLengthA > t_nBufferLength )

  00032	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _nLengthA$[ebp], 128 ; 00000080H
  00039	7e 24		 jle	 SHORT $L193622

; 452  : 		{
; 453  : 			m_psz = static_cast< LPSTR >( malloc( nLengthA*sizeof( char ) ) );

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _nLengthA$[ebp]
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00045	83 c4 04	 add	 esp, 4
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 454  : 			if (m_psz == NULL)

  0004d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00050	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00053	75 0a		 jne	 SHORT $L193622

; 455  : 			{
; 456  : 				AtlThrow( E_OUTOFMEMORY );

  00055	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0005a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L193622:

; 457  : 			}
; 458  : 		}
; 459  : 
; 460  : 		if (::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ) == 0)

  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	8b 45 fc	 mov	 eax, DWORD PTR _nLengthA$[ebp]
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	52		 push	 edx
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _nLengthW$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  00074	51		 push	 ecx
  00075	6a 00		 push	 0
  00077	8b 55 0c	 mov	 edx, DWORD PTR _nCodePage$[ebp]
  0007a	52		 push	 edx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00081	85 c0		 test	 eax, eax
  00083	75 05		 jne	 SHORT $L203411

; 461  : 		{
; 462  : 			AtlThrowLastWin32();

  00085	e8 00 00 00 00	 call	 ?AtlThrowLastWin32@ATL@@YGXXZ ; ATL::AtlThrowLastWin32
$L203411:

; 463  : 		}
; 464  : 	}

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ENDP		; ATL::CW2AEX<128>::Init
_TEXT	ENDS
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_dwError$ = -4						; size = 4
?AtlThrowLastWin32@ATL@@YGXXZ PROC NEAR			; ATL::AtlThrowLastWin32, COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 81   : 	DWORD dwError = ::GetLastError();

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0000c	89 45 fc	 mov	 DWORD PTR _dwError$[ebp], eax

; 82   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

  0000f	83 7d fc 00	 cmp	 DWORD PTR _dwError$[ebp], 0
  00013	7f 08		 jg	 SHORT $L203414
  00015	8b 45 fc	 mov	 eax, DWORD PTR _dwError$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001b	eb 18		 jmp	 SHORT $L203415
$L203414:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _dwError$[ebp]
  00020	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00026	81 c9 00 00 07
	00		 or	 ecx, 458752		; 00070000H
  0002c	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  00032	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
$L203415:
  00035	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L203413:

; 83   : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 365  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 366  : 			return (this + 1);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8

; 367  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00009	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

  00018	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0001c	75 0a		 jne	 SHORT $L194985

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

  0001e	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00023	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L194985:

; 297  : 		}
; 298  : 		m_p = p;

  00028	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0002e	89 11		 mov	 DWORD PTR [ecx], edx
$L203419:

; 299  : 	}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T203427 DD	0ffffffffH
	DD	FLAT:$L203422
$T203425 DD	019930520H
	DD	01H
	DD	FLAT:$T203427
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0003f	52		 push	 edx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203422:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203425
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T203440 DD	0ffffffffH
	DD	FLAT:$L203434
	DD	00H
	DD	FLAT:$L203433
$T203438 DD	019930520H
	DD	02H
	DD	FLAT:$T203440
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T203435 = -44						; size = 4
$T203432 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T203435[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T203432[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T203435[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T203435[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T203432[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L203433:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T203432[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203434:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T203435[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L203436
  00015	83 65 d4 fe	 and	 DWORD PTR $T203435[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L203436:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T203438
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
END
