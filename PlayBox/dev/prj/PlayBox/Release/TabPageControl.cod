; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\module\TabMan\TabPageControl.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0P@CLMBAKJD@JSCall?5Error?3?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??1IData@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppStart@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppExit@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIData@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@OneLocalGame@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAtlStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAtlStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringW@?$ChTraitsOS@_W@ATL@@KGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExW@?$ChTraitsOS@_W@ATL@@KGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiW@?$ChTraitsOS@_W@ATL@@KGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerW@?$ChTraitsOS@_W@ATL@@KGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperW@?$ChTraitsOS@_W@ATL@@KGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strchr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strrchr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strrev@?$ChTraitsOS@_W@ATL@@SAPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strstr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strspn@?$ChTraitsOS@_W@ATL@@SAHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strcspn@?$ChTraitsOS@_W@ATL@@SAHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strpbrk@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1HTTPObserver@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HTTPOb_DownStart@HTTPObserver@@UAEXPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HTTPOb_DownFinish@HTTPObserver@@UAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HTTPOb_DownFailed@HTTPObserver@@UAEXPBDW4HTTP_DOWN_FAILED_REASON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HTTPOb_DownProgress@HTTPObserver@@UAEXPBDII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HTTPOb_DownloadPause@HTTPObserver@@UAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GHTTPObserver@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClsid@CShockwaveFlash@@QAEABU_GUID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCustomControlSite@@QAE@PAVCOleControlContainer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCustomControlSite@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XDocHostShowUI@CCustomControlSite@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XDocHostUIHandler@CCustomControlSite@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCustomControlSite@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDocHostShowUI@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDocHostUIHandler@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateSite@CCustomOccManager@@UAEPAVCOleControlSite@@PAVCOleControlContainer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCustomOccManager@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0COccManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1COccManager@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCustomOccManager@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCOccManager@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNoTrackObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CSyncObject@@UAEHJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CCriticalSection@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCriticalSection@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCriticalSection@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CCriticalSection@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CCriticalSection@@UAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CCriticalSection@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_tagLMCItemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1BCMenuMemDC@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GBCMenuMemDC@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGdiPlusBitmap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@CGdiPlusBitmap@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CGdiPlusBitmap@@QAE_NPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCGdiPlusBitmap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E5
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??_GCTabPageControl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ITabBarObserver@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ITabBarObserver@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GITabBarObserver@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IMessageObserver@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIHTMLDocument2@@@ATL@@QBEPAUIHTMLDocument2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEXABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringCompare@?$ChTraitsCRT@D@ATL@@SAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindChar@?$ChTraitsCRT@D@ATL@@SAPBDPBDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringSpanIncluding@?$ChTraitsCRT@D@ATL@@SAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringSpanExcluding@?$ChTraitsCRT@D@ATL@@SAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@ABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@PAU32@IABU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEAAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXViterator@12@IABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlAlignUp@H@ATL@@YGHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CArray@HAAH@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CArray@HAAH@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@1@PAU21@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0ABU10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IPAU10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CArray@HAAH@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSize@?$CArray@HAAH@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$SerializeElements@H@@YGXAAVCArchive@@PAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@ABU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@ABU10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@HAAH@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IDocHostShowUI@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IDocHostUIHandler@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CCustomOccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3BCMenuMemDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CGdiPlusBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CTabPageControl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3XDocHostUIHandler@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ITabBarObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3COccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3HTTPObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3XDocHostShowUI@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@HAAH@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IDocHostShowUI@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IDocHostUIHandler@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CCustomOccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2BCMenuMemDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CGdiPlusBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CTabPageControl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2XDocHostUIHandler@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ITabBarObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2COccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2HTTPObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2XDocHostShowUI@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCmdTarget@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@COleControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$CArray@HAAH@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCustomOccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSyncObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CCriticalSection@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCDC@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@BCMenuMemDC@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUIAtlStringMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiPlusBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTabPageControl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IDocHostUIHandler@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@XDocHostUIHandler@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IMessageObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@ITabBarObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CNoTrackObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCNoTrackObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@COccManager@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@HTTPObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IUnknown@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknown@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@IDocHostShowUI@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@XDocHostShowUI@CCustomControlSite@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCOleControlSite@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCCustomControlSite@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVIData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$CArray@HAAH@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCCustomOccManager@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCSyncObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCCriticalSection@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVBCMenuMemDC@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCAtlStringMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCGdiPlusBitmap@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCTabPageControl@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AUIDocHostUIHandler@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVXDocHostUIHandler@CCustomControlSite@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVITabBarObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCOccManager@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVHTTPObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AUIDocHostShowUI@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVXDocHostShowUI@CCustomControlSite@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CCustomControlSite@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$CArray@HAAH@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IDocHostShowUI@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IDocHostUIHandler@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CCustomOccManager@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CCriticalSection@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?Escape@CDC@@UAEHHHPBDPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrayStringA@CDC@@UAEHPAVCBrush@@P6GHPAUHDC__@@JH@ZJHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHandle@CGdiObject@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawTextExA@CDC@@UAEHPADHPAUtagRECT@@IPAUtagDRAWTEXTPARAMS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawTextA@CDC@@UAEHPBDHPAUtagRECT@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TabbedTextOutA@CDC@@UAE?AVCSize@@HHPBDHHPAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtTextOutA@CDC@@UAEHHHIPBUtagRECT@@PBDIPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TextOutA@CDC@@UAEHHHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RectVisible@CDC@@UBEHPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PtVisible@CDC@@UBEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4BCMenuMemDC@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CAtlStringMgr@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CGdiPlusBitmap@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CTabPageControl@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4XDocHostUIHandler@CCustomControlSite@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ITabBarObserver@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4COccManager@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4HTTPObserver@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4XDocHostShowUI@CCustomControlSite@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CArchive@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CArray@HAAH@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCRect@@QAEPAUtagRECT@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7IMessageObserver@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4IMessageObserver@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IMessageObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IMessageObserver@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GIMessageObserver@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ITabBarObserver@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1IMessageObserver@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CTabPageControl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetLastStatus@Image@Gdiplus@@QBE?AW4Status@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FromFile@Bitmap@Gdiplus@@SAPAV12@PB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2GdiplusBase@Gdiplus@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3GdiplusBase@Gdiplus@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@Gdiplus@@QAE@PB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Image@Gdiplus@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7Image@Gdiplus@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4Image@Gdiplus@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVImage@Gdiplus@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3Image@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2Image@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@Image@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R13?0A@A@GdiplusBase@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVGdiplusBase@Gdiplus@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GImage@Gdiplus@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@Image@Gdiplus@@UAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatus@Image@Gdiplus@@IBE?AW4Status@2@W432@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Image@Gdiplus@@IAE@PAVGpImage@1@W4Status@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Image@Gdiplus@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7Bitmap@Gdiplus@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4Bitmap@Gdiplus@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVBitmap@Gdiplus@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3Bitmap@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2Bitmap@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@Bitmap@Gdiplus@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GBitmap@Gdiplus@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Bitmap@Gdiplus@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNativeImage@Image@Gdiplus@@IAEXPAVGpImage@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CGdiPlusBitmap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?BitBlt@CDC@@QAEHHHHHPAV1@HHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectObject@CDC@@QAEPAVCBitmap@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCompatibleBitmap@CBitmap@@QAEHPAVCDC@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCompatibleDC@CDC@@QAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPrinting@CDC@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyRect@CRect@@QAEXPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBitmap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBitmap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CBitmap@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCBitmap@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_GCBitmap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBitmap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7BCMenuMemDC@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CCriticalSection@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7COccManager@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CNoTrackObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CObject@@SGPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CCustomOccManager@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XDocHostUIHandler@CCustomControlSite@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7XDocHostShowUI@CCustomControlSite@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CCustomControlSite@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?clsid@?1??GetClsid@CShockwaveFlash@@QAEABU_GUID@@XZ@4U3@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7HTTPObserver@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNilStringData@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CAtlStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_pTabPageControl@CTabPageControl@@2PAV1@A	; CTabPageControl::m_pTabPageControl
PUBLIC	?_strthunks@ATL@@3U_AtlStringThunks@1@A		; ATL::_strthunks
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
PUBLIC	?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWThunk
PUBLIC	?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z	; ATL::CompareStringWThunk
PUBLIC	?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWThunk
PUBLIC	?lstrcmpiWThunk@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWThunk
PUBLIC	?CharLowerWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWThunk
PUBLIC	?CharUpperWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWThunk
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
_BSS	SEGMENT
?m_pTabPageControl@CTabPageControl@@2PAV1@A DD 01H DUP (?) ; CTabPageControl::m_pTabPageControl
_BSS	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
CONST	ENDS
CONST	SEGMENT
$SG204457 DB	'int', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_INT DD FLAT:$SG204457
_DATA	ENDS
CONST	SEGMENT
$SG204459 DB	'str', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_STR DD FLAT:$SG204459
_DATA	ENDS
CONST	SEGMENT
$SG204461 DB	'double', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_DOUBLE DD FLAT:$SG204461
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG204463 DB	'bool', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_BOOL DD FLAT:$SG204463
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG204465 DB	'sepint', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_INT_HASSEP DD FLAT:$SG204465
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG204467 DB	'sepstr', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_STR_HASSEP DD FLAT:$SG204467
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG204469 DB	'sepdouble', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_DOUBLE_HASSEP DD FLAT:$SG204469
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG204471 DB	'sepbool', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_BOOL_HASSEP DD FLAT:$SG204471
_DATA	ENDS
CONST	SEGMENT
$SG204473 DB	'Setting', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_MODULE_NAME DD FLAT:$SG204473
_DATA	ENDS
CONST	SEGMENT
$SG204475 DB	'skin', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_SKIN_IDX DD FLAT:$SG204475
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG204477 DB	'MainPage', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_CONFIG_MAIN_PAGE DD FLAT:$SG204477
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG204479 DB	'ProblemReport', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_CONFIG_PROBLEM_REPORT DD FLAT:$SG204479
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG204481 DB	'HomePage', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_CONFIG_HOME_PAGE DD FLAT:$SG204481
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG204483 DB	'askexit', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_CONFIG_IFASKEXIT DD FLAT:$SG204483
_DATA	ENDS
CONST	SEGMENT
$SG204485 DB	'exitchoice', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_CONFIG_EXITCHOICE DD FLAT:$SG204485
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG204487 DB	'UN', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_LOGIN_USER_NAME DD FLAT:$SG204487
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG204489 DB	'PW', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_LOGIN_PASSWORD DD FLAT:$SG204489
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG204491 DB	'NetID', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_NETID DD FLAT:$SG204491
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG204493 DB	'ChangeColorValue', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_COLOR DD FLAT:$SG204493
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG204495 DB	'changeColorLight', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_LIGHT DD FLAT:$SG204495
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG204497 DB	'ColorIndex', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_COLOR_BTN_INDEX DD FLAT:$SG204497
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG204499 DB	'ColorUser', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_COLOR_USER DD FLAT:$SG204499
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG204501 DB	'FirstTimeChangeSkin', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_FIRST_TIME_CHANGESKIN DD FLAT:$SG204501
_DATA	ENDS
CONST	SEGMENT
$SG205598 DB	'url', 00H
$SG205618 DB	'param', 00H
$SG205664 DB	00H
	ORG $+1
$SG205679 DB	0aH, 00H
$SG205683 DB	00H
	ORG $+1
$SG205688 DB	0aH, 00H
	ORG $+2
$SG205867 DB	0ceH, 0d2H, 0b5H, 0c4H, 0d3H, 0ceH, 0cfH, 0b7H, 00H
$SG205868 DB	00H
	ORG $+2
$SG205871 DB	0d3H, 0ceH, 0cfH, 0b7H, 0b4H, 0f3H, 0ccH, 0fcH, 00H
	ORG $+3
$SG205876 DB	'http://box.7k7k.com/client/', 00H
$SG205877 DB	'%s', 00H
	ORG $+1
$SG205878 DB	'url=%s', 00H
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT
?_strthunks@ATL@@3U_AtlStringThunks@1@A DD FLAT:?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ; ATL::_strthunks
	DD	FLAT:?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
	DD	FLAT:?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
	DD	FLAT:?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
_ID_MESSAGE_TABBAR DD 0bH
_ID_DATA_TABBAR DD 07H
CONST	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -160						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

  00011	c7 85 60 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _ver$[ebp], 148 ; 00000094H

; 139  : 	::GetVersionEx( &ver );

  0001b	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _ver$[ebp]
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00028	83 bd 70 ff ff
	ff 02		 cmp	 DWORD PTR _ver$[ebp+16], 2
  0002f	75 15		 jne	 SHORT $L24173
  00031	83 bd 64 ff ff
	ff 05		 cmp	 DWORD PTR _ver$[ebp+4], 5
  00038	72 0c		 jb	 SHORT $L24173

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  0003a	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

  00044	eb 0a		 jmp	 SHORT $L24174
$L24173:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00046	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L24174:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  00050	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pfnGetThreadACP$[ebp]
  00056	51		 push	 ecx
  00057	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0005c	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pNew$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pp$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 93   : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$24161 = -24					; size = 4
_lcidThread$ = -20					; size = 4
_szACP$ = -16						; size = 7
__$ArrayPad$ = -8					; size = 4
_nACP$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0
  0001b	89 45 ec	 mov	 DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  0001e	6a 07		 push	 7
  00020	8d 45 f0	 lea	 eax, DWORD PTR _szACP$[ebp]
  00023	50		 push	 eax
  00024	68 04 10 00 00	 push	 4100			; 00001004H
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _lcidThread$[ebp]
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00033	85 c0		 test	 eax, eax
  00035	74 34		 je	 SHORT $L24160

; 111  : 	{
; 112  : 		char* pch = szACP;

  00037	8d 55 f0	 lea	 edx, DWORD PTR _szACP$[ebp]
  0003a	89 55 e8	 mov	 DWORD PTR _pch$24161[ebp], edx
$L24163:

; 113  : 		while (*pch != '\0')

  0003d	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00040	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00043	85 c9		 test	 ecx, ecx
  00045	74 24		 je	 SHORT $L24160

; 114  : 		{
; 115  : 			nACP *= 10;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  0004a	6b d2 0a	 imul	 edx, 10			; 0000000aH
  0004d	89 55 fc	 mov	 DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

  00050	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  00059	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  0005d	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
  00060	8b 4d e8	 mov	 ecx, DWORD PTR _pch$24161[ebp]
  00063	83 c1 01	 add	 ecx, 1
  00066	89 4d e8	 mov	 DWORD PTR _pch$24161[ebp], ecx

; 117  : 		}

  00069	eb d2		 jmp	 SHORT $L24163
$L24160:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  0006b	83 7d fc 00	 cmp	 DWORD PTR _nACP$[ebp], 0
  0006f	75 09		 jne	 SHORT $L24165

; 121  : 		nACP = ::GetACP();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  00077	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
$L24165:

; 122  : 
; 123  : 	return nACP;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _nACP$[ebp]

; 124  : }

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  : 	return( CP_THREAD_ACP );

  00003	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
PUBLIC	?GetInstance@CTabPageControl@@SAPAV1@XZ		; CTabPageControl::GetInstance
PUBLIC	??0CTabPageControl@@QAE@XZ			; CTabPageControl::CTabPageControl
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T207667 DD	0ffffffffH
	DD	FLAT:$L207660
$T207664 DD	019930520H
	DD	01H
	DD	FLAT:$T207667
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabpagecontrol.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv72 = -24						; size = 4
$T207657 = -20						; size = 4
$T207656 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?GetInstance@CTabPageControl@@SAPAV1@XZ PROC NEAR	; CTabPageControl::GetInstance

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetInstance@CTabPageControl@@SAPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 25   : 	if( m_pTabPageControl == NULL )

  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pTabPageControl@CTabPageControl@@2PAV1@A, 0 ; CTabPageControl::m_pTabPageControl
  00022	75 44		 jne	 SHORT $L205552

; 26   : 	{
; 27   : 		m_pTabPageControl = new CTabPageControl;

  00024	6a 18		 push	 24			; 00000018H
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 45 ec	 mov	 DWORD PTR $T207657[ebp], eax
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	83 7d ec 00	 cmp	 DWORD PTR $T207657[ebp], 0
  0003c	74 0d		 je	 SHORT $L207658
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR $T207657[ebp]
  00041	e8 00 00 00 00	 call	 ??0CTabPageControl@@QAE@XZ ; CTabPageControl::CTabPageControl
  00046	89 45 e8	 mov	 DWORD PTR tv72[ebp], eax
  00049	eb 07		 jmp	 SHORT $L207659
$L207658:
  0004b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L207659:
  00052	8b 45 e8	 mov	 eax, DWORD PTR tv72[ebp]
  00055	89 45 f0	 mov	 DWORD PTR $T207656[ebp], eax
  00058	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR $T207656[ebp]
  00062	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_pTabPageControl@CTabPageControl@@2PAV1@A, ecx ; CTabPageControl::m_pTabPageControl
$L205552:

; 28   : 	}
; 29   : 	return m_pTabPageControl;

  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pTabPageControl@CTabPageControl@@2PAV1@A ; CTabPageControl::m_pTabPageControl

; 30   : }

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L207660:
  00000	8b 45 ec	 mov	 eax, DWORD PTR $T207657[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?GetInstance@CTabPageControl@@SAPAV1@XZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207664
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetInstance@CTabPageControl@@SAPAV1@XZ ENDP		; CTabPageControl::GetInstance
PUBLIC	?DelInstance@CTabPageControl@@SAXXZ		; CTabPageControl::DelInstance
; Function compile flags: /Odt
_TEXT	SEGMENT
tv71 = -12						; size = 4
$T207671 = -8						; size = 4
$T207670 = -4						; size = 4
?DelInstance@CTabPageControl@@SAXXZ PROC NEAR		; CTabPageControl::DelInstance

; 33   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 34   : 	if( m_pTabPageControl != NULL )

  00086	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pTabPageControl@CTabPageControl@@2PAV1@A, 0 ; CTabPageControl::m_pTabPageControl
  0008d	74 36		 je	 SHORT $L205558

; 35   : 	{
; 36   : 		delete m_pTabPageControl;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pTabPageControl@CTabPageControl@@2PAV1@A ; CTabPageControl::m_pTabPageControl
  00094	89 45 f8	 mov	 DWORD PTR $T207671[ebp], eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR $T207671[ebp]
  0009a	89 4d fc	 mov	 DWORD PTR $T207670[ebp], ecx
  0009d	83 7d fc 00	 cmp	 DWORD PTR $T207670[ebp], 0
  000a1	74 11		 je	 SHORT $L207672
  000a3	6a 01		 push	 1
  000a5	8b 55 fc	 mov	 edx, DWORD PTR $T207670[ebp]
  000a8	8b 02		 mov	 eax, DWORD PTR [edx]
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR $T207670[ebp]
  000ad	ff 10		 call	 DWORD PTR [eax]
  000af	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  000b2	eb 07		 jmp	 SHORT $L207673
$L207672:
  000b4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L207673:

; 37   : 		m_pTabPageControl = NULL;

  000bb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_pTabPageControl@CTabPageControl@@2PAV1@A, 0 ; CTabPageControl::m_pTabPageControl
$L205558:

; 38   : 	}
; 39   : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
?DelInstance@CTabPageControl@@SAXXZ ENDP		; CTabPageControl::DelInstance
_TEXT	ENDS
PUBLIC	?ITabBarOb_CreateNewTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z ; CTabPageControl::ITabBarOb_CreateNewTab
PUBLIC	?ITabBarOb_OpenExistTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z ; CTabPageControl::ITabBarOb_OpenExistTab
PUBLIC	?ITabBarOb_DelTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z ; CTabPageControl::ITabBarOb_DelTab
PUBLIC	?ITabBarOb_OpenTabError@CTabPageControl@@UAEXH@Z ; CTabPageControl::ITabBarOb_OpenTabError
PUBLIC	??_7CTabPageControl@@6B@			; CTabPageControl::`vftable'
PUBLIC	??_GCTabPageControl@@UAEPAXI@Z			; CTabPageControl::`scalar deleting destructor'
PUBLIC	??_R0?AVIMessageObserver@@@8			; IMessageObserver `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@IMessageObserver@@8		; IMessageObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0ITabBarObserver@@QAE@XZ			; ITabBarObserver::ITabBarObserver
PUBLIC	??1ITabBarObserver@@UAE@XZ			; ITabBarObserver::~ITabBarObserver
PUBLIC	??0?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
PUBLIC	??_R0?AVITabBarObserver@@@8			; ITabBarObserver `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@ITabBarObserver@@8			; ITabBarObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4CTabPageControl@@6B@			; CTabPageControl::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTabPageControl@@@8			; CTabPageControl `RTTI Type Descriptor'
PUBLIC	??_R3CTabPageControl@@8				; CTabPageControl::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTabPageControl@@8				; CTabPageControl::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CTabPageControl@@8			; CTabPageControl::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??1?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::~vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
EXTRN	??_ECTabPageControl@@UAEPAXI@Z:NEAR		; CTabPageControl::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?AfxGetMessageManager@@YAPAVIMessageManager@@XZ:NEAR ; AfxGetMessageManager
xdata$x	SEGMENT
$T207680 DD	0ffffffffH
	DD	FLAT:$L207675
	DD	00H
	DD	FLAT:$L207676
$T207678 DD	019930520H
	DD	02H
	DD	FLAT:$T207680
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CTabPageControl@@6B@
CONST	SEGMENT
??_7CTabPageControl@@6B@ DD FLAT:??_R4CTabPageControl@@6B@ ; CTabPageControl::`vftable'
	DD	FLAT:??_ECTabPageControl@@UAEPAXI@Z
	DD	FLAT:?ITabBarOb_CreateNewTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBarOb_OpenExistTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBarOb_DelTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBarOb_OpenTabError@CTabPageControl@@UAEXH@Z
CONST	ENDS
;	COMDAT ??_R4CTabPageControl@@6B@
rdata$r	SEGMENT
??_R4CTabPageControl@@6B@ DD 00H			; CTabPageControl::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTabPageControl@@@8
	DD	FLAT:??_R3CTabPageControl@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTabPageControl@@@8
_DATA	SEGMENT
??_R0?AVCTabPageControl@@@8 DD FLAT:??_7type_info@@6B@	; CTabPageControl `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTabPageControl@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CTabPageControl@@8
rdata$r	SEGMENT
??_R3CTabPageControl@@8 DD 00H				; CTabPageControl::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CTabPageControl@@8
rdata$r	ENDS
;	COMDAT ??_R2CTabPageControl@@8
rdata$r	SEGMENT
??_R2CTabPageControl@@8 DD FLAT:??_R1A@?0A@A@CTabPageControl@@8 ; CTabPageControl::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@ITabBarObserver@@8
	DD	FLAT:??_R1A@?0A@A@IMessageObserver@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTabPageControl@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CTabPageControl@@8 DD FLAT:??_R0?AVCTabPageControl@@@8 ; CTabPageControl::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ITabBarObserver@@8
rdata$r	SEGMENT
??_R1A@?0A@A@ITabBarObserver@@8 DD FLAT:??_R0?AVITabBarObserver@@@8 ; ITabBarObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVITabBarObserver@@@8
_DATA	SEGMENT
??_R0?AVITabBarObserver@@@8 DD FLAT:??_7type_info@@6B@	; ITabBarObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVITabBarObserver@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@IMessageObserver@@8
rdata$r	SEGMENT
??_R1A@?0A@A@IMessageObserver@@8 DD FLAT:??_R0?AVIMessageObserver@@@8 ; IMessageObserver::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT
??_R0?AVIMessageObserver@@@8 DD FLAT:??_7type_info@@6B@	; IMessageObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIMessageObserver@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
_TEXT	SEGMENT
tv76 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CTabPageControl@@QAE@XZ PROC NEAR			; CTabPageControl::CTabPageControl
; _this$ = ecx

; 42   : {

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	6a ff		 push	 -1
  000d5	68 00 00 00 00	 push	 __ehhandler$??0CTabPageControl@@QAE@XZ
  000da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  000e0	50		 push	 eax
  000e1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  000e8	83 ec 08	 sub	 esp, 8
  000eb	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  000ee	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	e8 00 00 00 00	 call	 ??0ITabBarObserver@@QAE@XZ
  000f6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000fd	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00100	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTabPageControl@@6B@
  00106	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	83 c1 04	 add	 ecx, 4
  0010c	e8 00 00 00 00	 call	 ??0?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
  00111	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 43   : 	AfxGetMessageManager()->AttachMessage( ID_MESSAGE_TABBAR,(ITabBarObserver*) this);

  00115	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  0011a	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  0011d	6a 02		 push	 2
  0011f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	51		 push	 ecx
  00123	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  00128	8b 55 ec	 mov	 edx, DWORD PTR tv76[ebp]
  0012b	8b 02		 mov	 eax, DWORD PTR [edx]
  0012d	8b 4d ec	 mov	 ecx, DWORD PTR tv76[ebp]
  00130	ff 50 04	 call	 DWORD PTR [eax+4]

; 44   : }

  00133	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0013a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0013d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00140	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L207675:
  00015	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e9 00 00 00 00	 jmp	 ??1ITabBarObserver@@UAE@XZ
$L207676:
  0001d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	83 c1 04	 add	 ecx, 4
  00023	e9 00 00 00 00	 jmp	 ??1?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::~vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
__ehhandler$??0CTabPageControl@@QAE@XZ:
  00028	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207678
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CTabPageControl@@QAE@XZ ENDP				; CTabPageControl::CTabPageControl
PUBLIC	??1CTabPageControl@@UAE@XZ			; CTabPageControl::~CTabPageControl
; Function compile flags: /Odt
;	COMDAT ??_GCTabPageControl@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTabPageControl@@UAEPAXI@Z PROC NEAR		; CTabPageControl::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTabPageControl@@UAE@XZ ; CTabPageControl::~CTabPageControl
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L205569
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L205569:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCTabPageControl@@UAEPAXI@Z ENDP			; CTabPageControl::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ITabBarObserver@@6B@			; ITabBarObserver::`vftable'
PUBLIC	??_GITabBarObserver@@UAEPAXI@Z			; ITabBarObserver::`scalar deleting destructor'
PUBLIC	??_R4ITabBarObserver@@6B@			; ITabBarObserver::`RTTI Complete Object Locator'
PUBLIC	??_R3ITabBarObserver@@8				; ITabBarObserver::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITabBarObserver@@8				; ITabBarObserver::`RTTI Base Class Array'
PUBLIC	??0IMessageObserver@@QAE@XZ			; IMessageObserver::IMessageObserver
EXTRN	__purecall:NEAR
EXTRN	??_EITabBarObserver@@UAEPAXI@Z:NEAR		; ITabBarObserver::`vector deleting destructor'
;	COMDAT ??_7ITabBarObserver@@6B@
CONST	SEGMENT
??_7ITabBarObserver@@6B@ DD FLAT:??_R4ITabBarObserver@@6B@ ; ITabBarObserver::`vftable'
	DD	FLAT:??_EITabBarObserver@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4ITabBarObserver@@6B@
rdata$r	SEGMENT
??_R4ITabBarObserver@@6B@ DD 00H			; ITabBarObserver::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVITabBarObserver@@@8
	DD	FLAT:??_R3ITabBarObserver@@8
rdata$r	ENDS
;	COMDAT ??_R3ITabBarObserver@@8
rdata$r	SEGMENT
??_R3ITabBarObserver@@8 DD 00H				; ITabBarObserver::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITabBarObserver@@8
rdata$r	ENDS
;	COMDAT ??_R2ITabBarObserver@@8
rdata$r	SEGMENT
??_R2ITabBarObserver@@8 DD FLAT:??_R1A@?0A@A@ITabBarObserver@@8 ; ITabBarObserver::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@IMessageObserver@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0ITabBarObserver@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ITabBarObserver@@QAE@XZ PROC NEAR			; ITabBarObserver::ITabBarObserver, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IMessageObserver@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ITabBarObserver@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0ITabBarObserver@@QAE@XZ ENDP				; ITabBarObserver::ITabBarObserver
_TEXT	ENDS
PUBLIC	??1IMessageObserver@@UAE@XZ			; IMessageObserver::~IMessageObserver
; Function compile flags: /Odt
;	COMDAT ??1ITabBarObserver@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ITabBarObserver@@UAE@XZ PROC NEAR			; ITabBarObserver::~ITabBarObserver, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1IMessageObserver@@UAE@XZ ; IMessageObserver::~IMessageObserver
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1ITabBarObserver@@UAE@XZ ENDP				; ITabBarObserver::~ITabBarObserver
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GITabBarObserver@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GITabBarObserver@@UAEPAXI@Z PROC NEAR		; ITabBarObserver::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1ITabBarObserver@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L205577
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L205577:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GITabBarObserver@@UAEPAXI@Z ENDP			; ITabBarObserver::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4IMessageObserver@@6B@			; IMessageObserver::`RTTI Complete Object Locator'
PUBLIC	??_R3IMessageObserver@@8			; IMessageObserver::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IMessageObserver@@8			; IMessageObserver::`RTTI Base Class Array'
PUBLIC	??_7IMessageObserver@@6B@			; IMessageObserver::`vftable'
PUBLIC	??_GIMessageObserver@@UAEPAXI@Z			; IMessageObserver::`scalar deleting destructor'
EXTRN	??_EIMessageObserver@@UAEPAXI@Z:NEAR		; IMessageObserver::`vector deleting destructor'
;	COMDAT ??_7IMessageObserver@@6B@
CONST	SEGMENT
??_7IMessageObserver@@6B@ DD FLAT:??_R4IMessageObserver@@6B@ ; IMessageObserver::`vftable'
	DD	FLAT:??_EIMessageObserver@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4IMessageObserver@@6B@
rdata$r	SEGMENT
??_R4IMessageObserver@@6B@ DD 00H			; IMessageObserver::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIMessageObserver@@@8
	DD	FLAT:??_R3IMessageObserver@@8
rdata$r	ENDS
;	COMDAT ??_R3IMessageObserver@@8
rdata$r	SEGMENT
??_R3IMessageObserver@@8 DD 00H				; IMessageObserver::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IMessageObserver@@8
rdata$r	ENDS
;	COMDAT ??_R2IMessageObserver@@8
rdata$r	SEGMENT
??_R2IMessageObserver@@8 DD FLAT:??_R1A@?0A@A@IMessageObserver@@8 ; IMessageObserver::`RTTI Base Class Array'
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0IMessageObserver@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IMessageObserver@@QAE@XZ PROC NEAR			; IMessageObserver::IMessageObserver, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IMessageObserver@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0IMessageObserver@@QAE@XZ ENDP			; IMessageObserver::IMessageObserver
_TEXT	ENDS
xdata$x	SEGMENT
$T207698 DD	0ffffffffH
	DD	FLAT:$L207693
	DD	00H
	DD	FLAT:$L207694
$T207696 DD	019930520H
	DD	02H
	DD	FLAT:$T207698
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv71 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CTabPageControl@@UAE@XZ PROC NEAR			; CTabPageControl::~CTabPageControl
; _this$ = ecx

; 47   : {

  00150	55		 push	 ebp
  00151	8b ec		 mov	 ebp, esp
  00153	6a ff		 push	 -1
  00155	68 00 00 00 00	 push	 __ehhandler$??1CTabPageControl@@UAE@XZ
  0015a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00160	50		 push	 eax
  00161	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00168	83 ec 08	 sub	 esp, 8
  0016b	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0016e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00171	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTabPageControl@@6B@
  00177	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 48   : 	AfxGetMessageManager()->DetachMessage( ID_MESSAGE_TABBAR,(ITabBarObserver*) this);

  0017e	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  00183	89 45 ec	 mov	 DWORD PTR tv71[ebp], eax
  00186	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00189	51		 push	 ecx
  0018a	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  0018f	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  00192	8b 02		 mov	 eax, DWORD PTR [edx]
  00194	8b 4d ec	 mov	 ecx, DWORD PTR tv71[ebp]
  00197	ff 50 08	 call	 DWORD PTR [eax+8]

; 49   : }

  0019a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0019e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	83 c1 04	 add	 ecx, 4
  001a4	e8 00 00 00 00	 call	 ??1?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::~vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
  001a9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001b0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ??1ITabBarObserver@@UAE@XZ
  001b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L207693:
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e9 00 00 00 00	 jmp	 ??1ITabBarObserver@@UAE@XZ
$L207694:
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 04	 add	 ecx, 4
  00040	e9 00 00 00 00	 jmp	 ??1?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::~vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
__ehhandler$??1CTabPageControl@@UAE@XZ:
  00045	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207696
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CTabPageControl@@UAE@XZ ENDP				; CTabPageControl::~CTabPageControl
PUBLIC	?SetParentWnd@CTabPageControl@@QAEXPAVCWnd@@@Z	; CTabPageControl::SetParentWnd
EXTRN	?GetInstance@TabWndFactory@@SAPAV1@XZ:NEAR	; TabWndFactory::GetInstance
EXTRN	?SetParent@TabWndFactory@@QAEXPAVCWnd@@@Z:NEAR	; TabWndFactory::SetParent
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pWnd$ = 8						; size = 4
?SetParentWnd@CTabPageControl@@QAEXPAVCWnd@@@Z PROC NEAR ; CTabPageControl::SetParentWnd
; _this$ = ecx

; 52   : {

  001d0	55		 push	 ebp
  001d1	8b ec		 mov	 ebp, esp
  001d3	51		 push	 ecx
  001d4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 53   : 	m_pWndParent = pWnd;

  001d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001da	8b 4d 08	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  001dd	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 54   : 	TabWndFactory::GetInstance()->SetParent( pWnd );

  001e0	8b 55 08	 mov	 edx, DWORD PTR _pWnd$[ebp]
  001e3	52		 push	 edx
  001e4	e8 00 00 00 00	 call	 ?GetInstance@TabWndFactory@@SAPAV1@XZ ; TabWndFactory::GetInstance
  001e9	8b c8		 mov	 ecx, eax
  001eb	e8 00 00 00 00	 call	 ?SetParent@TabWndFactory@@QAEXPAVCWnd@@@Z ; TabWndFactory::SetParent

; 55   : }

  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c2 04 00	 ret	 4
?SetParentWnd@CTabPageControl@@QAEXPAVCWnd@@@Z ENDP	; CTabPageControl::SetParentWnd
_TEXT	ENDS
PUBLIC	?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z		; CWnd::GetClientRect
PUBLIC	??0CRect@@QAE@XZ				; CRect::CRect
PUBLIC	??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ	; std::pair<TAB_ITEM,CWnd *>::pair<TAB_ITEM,CWnd *>
PUBLIC	??1?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ	; std::pair<TAB_ITEM,CWnd *>::~pair<TAB_ITEM,CWnd *>
PUBLIC	?push_back@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEXABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::push_back
PUBLIC	??0TAB_ITEM@@QAE@ABU0@@Z			; TAB_ITEM::TAB_ITEM
PUBLIC	??4TAB_ITEM@@QAEAAU0@ABU0@@Z			; TAB_ITEM::operator=
EXTRN	__imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	?Navigate@MyWebBrowserWnd@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:NEAR ; MyWebBrowserWnd::Navigate
EXTRN	?SetHomePage@MyWebBrowserWnd@@QAEX_N@Z:NEAR	; MyWebBrowserWnd::SetHomePage
EXTRN	?GetInstance@CWebManager@@SAPAV1@XZ:NEAR	; CWebManager::GetInstance
EXTRN	?GetValue@CWebManager@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@V23@@Z:NEAR ; CWebManager::GetValue
EXTRN	?SetTabItem@GamePanelWnd@@QAEXUTAB_ITEM@@@Z:NEAR ; GamePanelWnd::SetTabItem
EXTRN	?SetTabItem@WebGamePanelWnd@@QAEXUTAB_ITEM@@@Z:NEAR ; WebGamePanelWnd::SetTabItem
EXTRN	?CreateWndPlayedGame@TabWndFactory@@QAEPAVPlayedGameWnd@@XZ:NEAR ; TabWndFactory::CreateWndPlayedGame
EXTRN	?CreateWndGamePanel@TabWndFactory@@QAEPAVGamePanelWnd@@XZ:NEAR ; TabWndFactory::CreateWndGamePanel
EXTRN	?CreateWndWebGamePanel@TabWndFactory@@QAEPAVWebGamePanelWnd@@XZ:NEAR ; TabWndFactory::CreateWndWebGamePanel
EXTRN	?CreateWndMyWebBrowser@TabWndFactory@@QAEPAVMyWebBrowserWnd@@XZ:NEAR ; TabWndFactory::CreateWndMyWebBrowser
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
xdata$x	SEGMENT
$T207721 DD	0ffffffffH
	DD	FLAT:$L207708
	DD	0ffffffffH
	DD	FLAT:$L207709
	DD	0ffffffffH
	DD	FLAT:$L207713
	DD	0ffffffffH
	DD	FLAT:$L207714
	DD	0ffffffffH
	DD	FLAT:$L207716
$T207718 DD	019930520H
	DD	05H
	DD	FLAT:$T207721
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
tv269 = -248						; size = 4
tv266 = -244						; size = 4
tv265 = -240						; size = 4
tv272 = -236						; size = 4
tv263 = -232						; size = 4
tv261 = -228						; size = 4
tv259 = -224						; size = 4
tv256 = -220						; size = 4
tv255 = -216						; size = 4
tv271 = -212						; size = 4
_this$ = -208						; size = 4
$T207707 = -204						; size = 4
$T207706 = -200						; size = 4
$T207705 = -196						; size = 4
$T207704 = -192						; size = 4
$T207703 = -188						; size = 4
$T207702 = -184						; size = 4
_ot$205648 = -180					; size = 64
_pWnd$205622 = -112					; size = 4
_pWnd$205614 = -108					; size = 4
_strUrl$205615 = -104					; size = 28
_pWnd$205610 = -76					; size = 4
_pWnd$205606 = -72					; size = 4
_pWnd$205600 = -68					; size = 4
_strUrl$205595 = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
_pWndTmp$ = -32						; size = 4
_rc$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_item$ = 8						; size = 4
?ITabBarOb_CreateNewTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabPageControl::ITabBarOb_CreateNewTab
; _this$ = ecx

; 60   : {

  00200	55		 push	 ebp
  00201	8b ec		 mov	 ebp, esp
  00203	6a ff		 push	 -1
  00205	68 00 00 00 00	 push	 __ehhandler$?ITabBarOb_CreateNewTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z
  0020a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00210	50		 push	 eax
  00211	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00218	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  0021e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00223	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00226	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 61   : 	CRect rc;

  0022c	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  0022f	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 62   : 	m_pWndParent->GetClientRect(&rc);

  00234	8d 45 e4	 lea	 eax, DWORD PTR _rc$[ebp]
  00237	50		 push	 eax
  00238	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0023e	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00241	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 63   : 
; 64   : 	CWnd* pWndTmp = NULL;

  00246	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pWndTmp$[ebp], 0

; 65   : 	if( item.eumType == TAB_HOME )

  0024d	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00250	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  00254	0f 85 be 00 00
	00		 jne	 $L205594

; 66   : 	{
; 67   : 		string strUrl = CWebManager::GetInstance()->GetValue( item.strParam, "url" );

  0025a	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0025d	8b cc		 mov	 ecx, esp
  0025f	89 a5 48 ff ff
	ff		 mov	 DWORD PTR $T207702[ebp], esp
  00265	68 00 00 00 00	 push	 OFFSET FLAT:$SG205598
  0026a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00270	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv271[ebp], eax
  00276	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv271[ebp]
  0027c	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv255[ebp], eax
  00282	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00289	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0028c	83 c1 20	 add	 ecx, 32			; 00000020H
  0028f	51		 push	 ecx
  00290	8d 55 c0	 lea	 edx, DWORD PTR _strUrl$205595[ebp]
  00293	52		 push	 edx
  00294	e8 00 00 00 00	 call	 ?GetInstance@CWebManager@@SAPAV1@XZ ; CWebManager::GetInstance
  00299	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002a0	8b c8		 mov	 ecx, eax
  002a2	e8 00 00 00 00	 call	 ?GetValue@CWebManager@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@V23@@Z ; CWebManager::GetValue
  002a7	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv256[ebp], eax
  002ad	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 68   : 		if( strUrl.length() != 0 )

  002b4	8d 4d c0	 lea	 ecx, DWORD PTR _strUrl$205595[ebp]
  002b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  002bd	85 c0		 test	 eax, eax
  002bf	74 42		 je	 SHORT $L205599

; 69   : 		{
; 70   : 			MyWebBrowserWnd* pWnd = TabWndFactory::GetInstance()->CreateWndMyWebBrowser();

  002c1	e8 00 00 00 00	 call	 ?GetInstance@TabWndFactory@@SAPAV1@XZ ; TabWndFactory::GetInstance
  002c6	8b c8		 mov	 ecx, eax
  002c8	e8 00 00 00 00	 call	 ?CreateWndMyWebBrowser@TabWndFactory@@QAEPAVMyWebBrowserWnd@@XZ ; TabWndFactory::CreateWndMyWebBrowser
  002cd	89 45 bc	 mov	 DWORD PTR _pWnd$205600[ebp], eax

; 71   : 			pWnd->Navigate( strUrl );

  002d0	83 ec 1c	 sub	 esp, 28			; 0000001cH
  002d3	8b cc		 mov	 ecx, esp
  002d5	89 a5 44 ff ff
	ff		 mov	 DWORD PTR $T207703[ebp], esp
  002db	8d 45 c0	 lea	 eax, DWORD PTR _strUrl$205595[ebp]
  002de	50		 push	 eax
  002df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  002e5	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv259[ebp], eax
  002eb	8b 4d bc	 mov	 ecx, DWORD PTR _pWnd$205600[ebp]
  002ee	e8 00 00 00 00	 call	 ?Navigate@MyWebBrowserWnd@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; MyWebBrowserWnd::Navigate

; 72   : 			pWnd->SetHomePage( true );

  002f3	6a 01		 push	 1
  002f5	8b 4d bc	 mov	 ecx, DWORD PTR _pWnd$205600[ebp]
  002f8	e8 00 00 00 00	 call	 ?SetHomePage@MyWebBrowserWnd@@QAEX_N@Z ; MyWebBrowserWnd::SetHomePage

; 73   : 			pWndTmp = pWnd;

  002fd	8b 4d bc	 mov	 ecx, DWORD PTR _pWnd$205600[ebp]
  00300	89 4d e0	 mov	 DWORD PTR _pWndTmp$[ebp], ecx
$L205599:

; 74   : 		}
; 75   : 	}else

  00303	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0030a	8d 4d c0	 lea	 ecx, DWORD PTR _strUrl$205595[ebp]
  0030d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00313	e9 81 01 00 00	 jmp	 $L205602
$L205594:

; 76   : 	if( item.eumType == TAB_GAME
; 77   : 		|| item.eumType == TAB_PLAYED_GAME
; 78   : 		|| item.eumType == TAB_WEB
; 79   : 		|| item.eumType == TAB_WEBGAME )

  00318	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  0031b	83 7a 1c 03	 cmp	 DWORD PTR [edx+28], 3
  0031f	74 1f		 je	 SHORT $L205604
  00321	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00324	83 78 1c 04	 cmp	 DWORD PTR [eax+28], 4
  00328	74 16		 je	 SHORT $L205604
  0032a	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0032d	83 79 1c 02	 cmp	 DWORD PTR [ecx+28], 2
  00331	74 0d		 je	 SHORT $L205604
  00333	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00336	83 7a 1c 01	 cmp	 DWORD PTR [edx+28], 1
  0033a	0f 85 59 01 00
	00		 jne	 $L205602
$L205604:

; 80   : 	{
; 81   : 		if( item.eumType == TAB_GAME )

  00340	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00343	83 78 1c 03	 cmp	 DWORD PTR [eax+28], 3
  00347	75 3c		 jne	 SHORT $L205605

; 82   : 		{
; 83   : 			GamePanelWnd *pWnd = TabWndFactory::GetInstance()->CreateWndGamePanel();

  00349	e8 00 00 00 00	 call	 ?GetInstance@TabWndFactory@@SAPAV1@XZ ; TabWndFactory::GetInstance
  0034e	8b c8		 mov	 ecx, eax
  00350	e8 00 00 00 00	 call	 ?CreateWndGamePanel@TabWndFactory@@QAEPAVGamePanelWnd@@XZ ; TabWndFactory::CreateWndGamePanel
  00355	89 45 b8	 mov	 DWORD PTR _pWnd$205606[ebp], eax

; 84   : 			pWnd->SetTabItem( item );

  00358	83 ec 3c	 sub	 esp, 60			; 0000003cH
  0035b	8b cc		 mov	 ecx, esp
  0035d	89 a5 40 ff ff
	ff		 mov	 DWORD PTR $T207704[ebp], esp
  00363	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00366	52		 push	 edx
  00367	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@ABU0@@Z
  0036c	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv261[ebp], eax
  00372	8b 4d b8	 mov	 ecx, DWORD PTR _pWnd$205606[ebp]
  00375	e8 00 00 00 00	 call	 ?SetTabItem@GamePanelWnd@@QAEXUTAB_ITEM@@@Z ; GamePanelWnd::SetTabItem

; 85   : 			pWndTmp = pWnd;

  0037a	8b 45 b8	 mov	 eax, DWORD PTR _pWnd$205606[ebp]
  0037d	89 45 e0	 mov	 DWORD PTR _pWndTmp$[ebp], eax

; 86   : 		}else

  00380	e9 14 01 00 00	 jmp	 $L205602
$L205605:

; 87   : 		if( item.eumType == TAB_WEBGAME )

  00385	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00388	83 79 1c 01	 cmp	 DWORD PTR [ecx+28], 1
  0038c	75 3c		 jne	 SHORT $L205609

; 88   : 		{
; 89   : 			WebGamePanelWnd *pWnd = TabWndFactory::GetInstance()->CreateWndWebGamePanel();

  0038e	e8 00 00 00 00	 call	 ?GetInstance@TabWndFactory@@SAPAV1@XZ ; TabWndFactory::GetInstance
  00393	8b c8		 mov	 ecx, eax
  00395	e8 00 00 00 00	 call	 ?CreateWndWebGamePanel@TabWndFactory@@QAEPAVWebGamePanelWnd@@XZ ; TabWndFactory::CreateWndWebGamePanel
  0039a	89 45 b4	 mov	 DWORD PTR _pWnd$205610[ebp], eax

; 90   : 			pWnd->SetTabItem( item );

  0039d	83 ec 3c	 sub	 esp, 60			; 0000003cH
  003a0	8b cc		 mov	 ecx, esp
  003a2	89 a5 3c ff ff
	ff		 mov	 DWORD PTR $T207705[ebp], esp
  003a8	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  003ab	52		 push	 edx
  003ac	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@ABU0@@Z
  003b1	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv263[ebp], eax
  003b7	8b 4d b4	 mov	 ecx, DWORD PTR _pWnd$205610[ebp]
  003ba	e8 00 00 00 00	 call	 ?SetTabItem@WebGamePanelWnd@@QAEXUTAB_ITEM@@@Z ; WebGamePanelWnd::SetTabItem

; 91   : 			pWndTmp = pWnd;

  003bf	8b 45 b4	 mov	 eax, DWORD PTR _pWnd$205610[ebp]
  003c2	89 45 e0	 mov	 DWORD PTR _pWndTmp$[ebp], eax

; 92   : 		}else

  003c5	e9 cf 00 00 00	 jmp	 $L205602
$L205609:

; 93   : 		if( item.eumType == TAB_WEB )

  003ca	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  003cd	83 79 1c 02	 cmp	 DWORD PTR [ecx+28], 2
  003d1	0f 85 a4 00 00
	00		 jne	 $L205613

; 94   : 		{
; 95   : 			MyWebBrowserWnd *pWnd = TabWndFactory::GetInstance()->CreateWndMyWebBrowser();

  003d7	e8 00 00 00 00	 call	 ?GetInstance@TabWndFactory@@SAPAV1@XZ ; TabWndFactory::GetInstance
  003dc	8b c8		 mov	 ecx, eax
  003de	e8 00 00 00 00	 call	 ?CreateWndMyWebBrowser@TabWndFactory@@QAEPAVMyWebBrowserWnd@@XZ ; TabWndFactory::CreateWndMyWebBrowser
  003e3	89 45 94	 mov	 DWORD PTR _pWnd$205614[ebp], eax

; 96   : 			string strUrl = CWebManager::GetInstance()->GetValue( item.strParam, "param" );

  003e6	83 ec 1c	 sub	 esp, 28			; 0000001cH
  003e9	8b cc		 mov	 ecx, esp
  003eb	89 a5 38 ff ff
	ff		 mov	 DWORD PTR $T207706[ebp], esp
  003f1	68 00 00 00 00	 push	 OFFSET FLAT:$SG205618
  003f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  003fc	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv272[ebp], eax
  00402	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR tv272[ebp]
  00408	89 95 10 ff ff
	ff		 mov	 DWORD PTR tv265[ebp], edx
  0040e	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00415	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00418	83 c0 20	 add	 eax, 32			; 00000020H
  0041b	50		 push	 eax
  0041c	8d 4d 98	 lea	 ecx, DWORD PTR _strUrl$205615[ebp]
  0041f	51		 push	 ecx
  00420	e8 00 00 00 00	 call	 ?GetInstance@CWebManager@@SAPAV1@XZ ; CWebManager::GetInstance
  00425	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0042c	8b c8		 mov	 ecx, eax
  0042e	e8 00 00 00 00	 call	 ?GetValue@CWebManager@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@V23@@Z ; CWebManager::GetValue
  00433	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv266[ebp], eax
  00439	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 97   : 			pWnd->Navigate( strUrl );

  00440	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00443	8b cc		 mov	 ecx, esp
  00445	89 a5 34 ff ff
	ff		 mov	 DWORD PTR $T207707[ebp], esp
  0044b	8d 55 98	 lea	 edx, DWORD PTR _strUrl$205615[ebp]
  0044e	52		 push	 edx
  0044f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00455	89 85 08 ff ff
	ff		 mov	 DWORD PTR tv269[ebp], eax
  0045b	8b 4d 94	 mov	 ecx, DWORD PTR _pWnd$205614[ebp]
  0045e	e8 00 00 00 00	 call	 ?Navigate@MyWebBrowserWnd@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; MyWebBrowserWnd::Navigate

; 98   : 			pWndTmp = pWnd;

  00463	8b 45 94	 mov	 eax, DWORD PTR _pWnd$205614[ebp]
  00466	89 45 e0	 mov	 DWORD PTR _pWndTmp$[ebp], eax

; 99   : 		}else if( item.eumType == TAB_PLAYED_GAME )

  00469	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00470	8d 4d 98	 lea	 ecx, DWORD PTR _strUrl$205615[ebp]
  00473	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00479	eb 1e		 jmp	 SHORT $L205602
$L205613:
  0047b	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0047e	83 79 1c 04	 cmp	 DWORD PTR [ecx+28], 4
  00482	75 15		 jne	 SHORT $L205602

; 100  : 		{
; 101  : 			PlayedGameWnd* pWnd = TabWndFactory::GetInstance()->CreateWndPlayedGame();

  00484	e8 00 00 00 00	 call	 ?GetInstance@TabWndFactory@@SAPAV1@XZ ; TabWndFactory::GetInstance
  00489	8b c8		 mov	 ecx, eax
  0048b	e8 00 00 00 00	 call	 ?CreateWndPlayedGame@TabWndFactory@@QAEPAVPlayedGameWnd@@XZ ; TabWndFactory::CreateWndPlayedGame
  00490	89 45 90	 mov	 DWORD PTR _pWnd$205622[ebp], eax

; 102  : 			pWndTmp = pWnd;

  00493	8b 55 90	 mov	 edx, DWORD PTR _pWnd$205622[ebp]
  00496	89 55 e0	 mov	 DWORD PTR _pWndTmp$[ebp], edx
$L205602:

; 103  : 		}
; 104  : 	}
; 105  : 	if( pWndTmp != NULL )

  00499	83 7d e0 00	 cmp	 DWORD PTR _pWndTmp$[ebp], 0
  0049d	74 63		 je	 SHORT $L205591

; 106  : 	{
; 107  : 		ONE_TAB ot;

  0049f	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _ot$205648[ebp]
  004a5	e8 00 00 00 00	 call	 ??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ ; std::pair<TAB_ITEM,CWnd *>::pair<TAB_ITEM,CWnd *>
  004aa	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4

; 108  : 		ot.first = item;

  004b1	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  004b4	50		 push	 eax
  004b5	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _ot$205648[ebp]
  004bb	e8 00 00 00 00	 call	 ??4TAB_ITEM@@QAEAAU0@ABU0@@Z

; 109  : 		ot.second = pWndTmp;

  004c0	8b 4d e0	 mov	 ecx, DWORD PTR _pWndTmp$[ebp]
  004c3	89 4d 88	 mov	 DWORD PTR _ot$205648[ebp+60], ecx

; 110  : 		m_mapTab.push_back( ot );

  004c6	8d 95 4c ff ff
	ff		 lea	 edx, DWORD PTR _ot$205648[ebp]
  004cc	52		 push	 edx
  004cd	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004d3	83 c1 04	 add	 ecx, 4
  004d6	e8 00 00 00 00	 call	 ?push_back@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEXABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::push_back

; 111  : 
; 112  : 		ITabBarOb_OpenExistTab( item );

  004db	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  004de	50		 push	 eax
  004df	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  004e7	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004ed	ff 52 08	 call	 DWORD PTR [edx+8]

; 113  : 	}

  004f0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004f7	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _ot$205648[ebp]
  004fd	e8 00 00 00 00	 call	 ??1?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ
$L205591:

; 114  : }

  00502	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00505	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0050c	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0050f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00514	8b e5		 mov	 esp, ebp
  00516	5d		 pop	 ebp
  00517	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L207708:
  0004f	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR $T207702[ebp]
  00055	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L207709:
  0005b	8d 4d c0	 lea	 ecx, DWORD PTR _strUrl$205595[ebp]
  0005e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L207713:
  00064	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR $T207706[ebp]
  0006a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L207714:
  00070	8d 4d 98	 lea	 ecx, DWORD PTR _strUrl$205615[ebp]
  00073	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L207716:
  00079	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _ot$205648[ebp]
  0007f	e9 00 00 00 00	 jmp	 ??1?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ
__ehhandler$?ITabBarOb_CreateNewTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z:
  00084	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207718
  00089	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ITabBarOb_CreateNewTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z ENDP ; CTabPageControl::ITabBarOb_CreateNewTab
;	COMDAT xdata$x
xdata$x	SEGMENT
$T207728 DD	0ffffffffH
	DD	FLAT:$L207723
$T207726 DD	019930520H
	DD	01H
	DD	FLAT:$T207728
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0TAB_ITEM@@QAE@ABU0@@Z PROC NEAR			; TAB_ITEM::TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0TAB_ITEM@@QAE@ABU0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00036	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00039	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0003f	83 c1 20	 add	 ecx, 32			; 00000020H
  00042	51		 push	 ecx
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 20	 add	 ecx, 32			; 00000020H
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L207723:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0TAB_ITEM@@QAE@ABU0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207726
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0TAB_ITEM@@QAE@ABU0@@Z ENDP				; TAB_ITEM::TAB_ITEM
PUBLIC	??1TAB_ITEM@@QAE@XZ				; TAB_ITEM::~TAB_ITEM
; Function compile flags: /Odt
;	COMDAT ??1?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ PROC NEAR	; std::pair<TAB_ITEM,CWnd *>::~pair<TAB_ITEM,CWnd *>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ ENDP		; std::pair<TAB_ITEM,CWnd *>::~pair<TAB_ITEM,CWnd *>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T207741 DD	0ffffffffH
	DD	FLAT:$L207736
$T207739 DD	019930520H
	DD	01H
	DD	FLAT:$T207741
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TAB_ITEM@@QAE@XZ PROC NEAR				; TAB_ITEM::~TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1TAB_ITEM@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 20	 add	 ecx, 32			; 00000020H
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L207736:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1TAB_ITEM@@QAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207739
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1TAB_ITEM@@QAE@XZ ENDP				; TAB_ITEM::~TAB_ITEM
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
; Function compile flags: /Odt
;	COMDAT ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4TAB_ITEM@@QAEAAU0@ABU0@@Z PROC NEAR			; TAB_ITEM::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0001a	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00020	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00023	83 c1 20	 add	 ecx, 32			; 00000020H
  00026	51		 push	 ecx
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 c1 20	 add	 ecx, 32			; 00000020H
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??4TAB_ITEM@@QAEAAU0@ABU0@@Z ENDP			; TAB_ITEM::operator=
_TEXT	ENDS
PUBLIC	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z	; ATL::_AtlInstallStringThunk
PUBLIC	?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableW@12:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWThunk, COMDAT

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 184  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
; 185  : 		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetEnvironmentVariableW@12
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
  0000e	68 14 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 186  : 
; 187  : 	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);

  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 0c	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  00022	52		 push	 edx
  00023	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  00026	50		 push	 eax
  00027	ff 15 14 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20

; 188  : }

  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWThunk
_TEXT	ENDS
PUBLIC	?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
PUBLIC	??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
EXTRN	__imp__GetVersion@0:NEAR
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT
?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA DB 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT
??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 DD 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
; Function compile flags: /Odt
_BSS	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT
_pfn$ = -4						; size = 4
_ppThunk$ = 8						; size = 4
_pfnWin9x$ = 12						; size = 4
_pfnNT$ = 16						; size = 4
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z PROC NEAR	; ATL::_AtlInstallStringThunk, COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 116  : #pragma warning (push)
; 117  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 118  : 
; 119  : 	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
  00009	83 e0 01	 and	 eax, 1
  0000c	75 25		 jne	 SHORT $L25641
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
  00014	83 c9 01	 or	 ecx, 1
  00017	89 0d 00 00 00
	00		 mov	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, ecx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00023	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00028	f7 d8		 neg	 eax
  0002a	1b c0		 sbb	 eax, eax
  0002c	f7 d8		 neg	 eax
  0002e	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L25641:

; 120  : 	
; 121  : #pragma warning (pop)
; 122  : 
; 123  : 	void* pfn;
; 124  : 	if (s_bWin9x)

  00033	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  0003a	85 d2		 test	 edx, edx
  0003c	74 08		 je	 SHORT $L25643

; 125  : 		pfn = pfnWin9x;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _pfnWin9x$[ebp]
  00041	89 45 fc	 mov	 DWORD PTR _pfn$[ebp], eax

; 126  : 	else

  00044	eb 06		 jmp	 SHORT $L25644
$L25643:

; 127  : 	{
; 128  : #ifdef _CSTRING_ALWAYS_THUNK
; 129  : 		pfn = pfnWin9x;
; 130  : 		(void)pfnNT;
; 131  : #else
; 132  : 		pfn = pfnNT;

  00046	8b 4d 10	 mov	 ecx, DWORD PTR _pfnNT$[ebp]
  00049	89 4d fc	 mov	 DWORD PTR _pfn$[ebp], ecx
$L25644:

; 133  : #endif
; 134  : 	}
; 135  : 	InterlockedExchangePointer(ppThunk, pfn);

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _pfn$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 08	 mov	 eax, DWORD PTR _ppThunk$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 136  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ENDP	; ATL::_AtlInstallStringThunk
_TEXT	ENDS
PUBLIC	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
PUBLIC	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
PUBLIC	??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z		; ATL::CW2AEX<128>::CW2AEX<128>
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
PUBLIC	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CW2AEX<128>::operator char *
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
EXTRN	__imp__MultiByteToWideChar@24:NEAR
EXTRN	__imp__GetEnvironmentVariableA@12:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T207762 DD	0ffffffffH
	DD	FLAT:$L207756
	DD	00H
	DD	FLAT:$L207757
$T207759 DD	019930520H
	DD	02H
	DD	FLAT:$T207762
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
$T207755 = -312						; size = 4
$T207754 = -308						; size = 4
$T207753 = -304						; size = 4
_pszBufferA$ = -300					; size = 132
_nSizeW$ = -160						; size = 4
_pszNameA$ = -156					; size = 132
__$ArrayPad$ = -20					; size = 4
_nSizeA$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWFake, COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 160  : 	ULONG nSizeA;
; 161  : 	ULONG nSizeW;
; 162  : 	CTempBuffer<char> pszBufferA;

  00026	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 163  : 	CW2A pszNameA(pszName);

  00038	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  0003b	50		 push	 eax
  0003c	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ; ATL::CW2AEX<128>::CW2AEX<128>
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 164  : 
; 165  : 	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00055	e8 00 00 00 00	 call	 ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ; ATL::CW2AEX<128>::operator char *
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12
  00061	89 45 f0	 mov	 DWORD PTR _nSizeA$[ebp], eax

; 166  : 	if (nSizeA == 0)

  00064	83 7d f0 00	 cmp	 DWORD PTR _nSizeA$[ebp], 0
  00068	75 36		 jne	 SHORT $L25746

; 167  : 		return 0;

  0006a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T207753[ebp], 0
  00074	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00078	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  0007e	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  00083	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00090	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  00095	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T207753[ebp]
  0009b	e9 ee 00 00 00	 jmp	 $L25687
$L25746:

; 168  : 
; 169  : 	pszBufferA.Allocate(nSizeA*2);

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _nSizeA$[ebp]
  000a3	d1 e1		 shl	 ecx, 1
  000a5	51		 push	 ecx
  000a6	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000ac	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 170  : 	::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA);

  000b1	8b 55 f0	 mov	 edx, DWORD PTR _nSizeA$[ebp]
  000b4	52		 push	 edx
  000b5	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000bb	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000c0	50		 push	 eax
  000c1	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  000c7	e8 00 00 00 00	 call	 ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ; ATL::CW2AEX<128>::operator char *
  000cc	50		 push	 eax
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12

; 171  : 
; 172  : 	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);

  000d3	6a 00		 push	 0
  000d5	6a 00		 push	 0
  000d7	6a ff		 push	 -1
  000d9	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000df	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  000ec	50		 push	 eax
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  000f3	89 85 60 ff ff
	ff		 mov	 DWORD PTR _nSizeW$[ebp], eax

; 173  : 	if (nSize == 0)

  000f9	83 7d 10 00	 cmp	 DWORD PTR _nSize$[ebp], 0
  000fd	75 35		 jne	 SHORT $L25748

; 174  : 		return nSizeW;

  000ff	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nSizeW$[ebp]
  00105	89 85 cc fe ff
	ff		 mov	 DWORD PTR $T207754[ebp], eax
  0010b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0010f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00115	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00121	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00127	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  0012c	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T207754[ebp]
  00132	eb 5a		 jmp	 SHORT $L25687
$L25748:

; 175  : 	ATLASSERT(nSize >= nSizeW);
; 176  : 	::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW);

  00134	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _nSizeW$[ebp]
  0013a	51		 push	 ecx
  0013b	8b 55 0c	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  0013e	52		 push	 edx
  0013f	6a ff		 push	 -1
  00141	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00147	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  0014c	50		 push	 eax
  0014d	6a 00		 push	 0
  0014f	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00154	50		 push	 eax
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 177  : 
; 178  : 	return nSizeW;

  0015b	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nSizeW$[ebp]
  00161	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T207755[ebp], eax
  00167	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0016b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00171	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  00176	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0017d	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00183	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  00188	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T207755[ebp]
$L25687:

; 179  : }

  0018e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00191	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00198	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L207756:
  00000	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
$L207757:
  0000b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207759
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 158  : 	return( g_pfnGetThreadACP() );

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 159  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	??9const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator!=
PUBLIC	?begin@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::begin
PUBLIC	?end@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::end
PUBLIC	??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
PUBLIC	??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AV012@H@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator++
EXTRN	?ShowWindow@CWnd@@QAEHH@Z:NEAR			; CWnd::ShowWindow
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z:NEAR
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabpagecontrol.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T207770 = -12						; size = 4
$T207769 = -8						; size = 4
_it$205810 = -4						; size = 4
_item$ = 8						; size = 4
?ITabBarOb_OpenExistTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabPageControl::ITabBarOb_OpenExistTab
; _this$ = ecx

; 151  : {

  00520	55		 push	 ebp
  00521	8b ec		 mov	 ebp, esp
  00523	83 ec 10	 sub	 esp, 16			; 00000010H
  00526	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 	for( vector<ONE_TAB>::iterator it = m_mapTab.begin();

  00529	8d 45 fc	 lea	 eax, DWORD PTR _it$205810[ebp]
  0052c	50		 push	 eax
  0052d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00530	83 c1 04	 add	 ecx, 4
  00533	e8 00 00 00 00	 call	 ?begin@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::begin

; 153  : 		it != m_mapTab.end(); it++ )

  00538	eb 0e		 jmp	 SHORT $L205814
$L205815:
  0053a	6a 00		 push	 0
  0053c	8d 4d f8	 lea	 ecx, DWORD PTR $T207769[ebp]
  0053f	51		 push	 ecx
  00540	8d 4d fc	 lea	 ecx, DWORD PTR _it$205810[ebp]
  00543	e8 00 00 00 00	 call	 ??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AV012@H@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator++
$L205814:
  00548	8d 55 f4	 lea	 edx, DWORD PTR $T207770[ebp]
  0054b	52		 push	 edx
  0054c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0054f	83 c1 04	 add	 ecx, 4
  00552	e8 00 00 00 00	 call	 ?end@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::end
  00557	50		 push	 eax
  00558	8d 4d fc	 lea	 ecx, DWORD PTR _it$205810[ebp]
  0055b	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator!=
  00560	0f b6 c0	 movzx	 eax, al
  00563	85 c0		 test	 eax, eax
  00565	74 5b		 je	 SHORT $L205692

; 154  : 	{
; 155  : 		if( it->first.strName == item.strName 
; 156  : 			&& it->first.eumType == item.eumType )

  00567	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0056a	51		 push	 ecx
  0056b	8d 4d fc	 lea	 ecx, DWORD PTR _it$205810[ebp]
  0056e	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  00573	50		 push	 eax
  00574	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
  0057a	83 c4 08	 add	 esp, 8
  0057d	0f b6 d0	 movzx	 edx, al
  00580	85 d2		 test	 edx, edx
  00582	74 27		 je	 SHORT $L205817
  00584	8d 4d fc	 lea	 ecx, DWORD PTR _it$205810[ebp]
  00587	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  0058c	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0058f	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00592	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00595	75 14		 jne	 SHORT $L205817

; 157  : 		{
; 158  : 			it->second->ShowWindow( SW_SHOW );

  00597	6a 05		 push	 5
  00599	8d 4d fc	 lea	 ecx, DWORD PTR _it$205810[ebp]
  0059c	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  005a1	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  005a4	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 159  : 		}else

  005a9	eb 12		 jmp	 SHORT $L205818
$L205817:

; 160  : 		{
; 161  : // 			it->second->MoveWindow( &rectNull, TRUE);
; 162  : 			it->second->ShowWindow( SW_HIDE);

  005ab	6a 00		 push	 0
  005ad	8d 4d fc	 lea	 ecx, DWORD PTR _it$205810[ebp]
  005b0	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  005b5	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  005b8	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow
$L205818:

; 163  : 		}
; 164  : 	}

  005bd	e9 78 ff ff ff	 jmp	 $L205815
$L205692:

; 165  : }

  005c2	8b e5		 mov	 esp, ebp
  005c4	5d		 pop	 ebp
  005c5	c2 04 00	 ret	 4
?ITabBarOb_OpenExistTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z ENDP ; CTabPageControl::ITabBarOb_OpenExistTab
_TEXT	ENDS
PUBLIC	?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringW@24:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWThunk, COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 217  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CompareStringW@24
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ; ATL::CompareStringWFake
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A ; ATL::_strthunks
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : 
; 219  : 	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);

  0001b	8b 4d 1c	 mov	 ecx, DWORD PTR _nLength2$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 18	 mov	 edx, DWORD PTR _pszString2$[ebp]
  00022	52		 push	 edx
  00023	8b 45 14	 mov	 eax, DWORD PTR _nLength1$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR _pszString1$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR _lcid$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A

; 220  : }

  00039	5d		 pop	 ebp
  0003a	c2 18 00	 ret	 24			; 00000018H
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWThunk
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
PUBLIC	?AtlW2AHelper@@YGPADPADPB_WHI@Z			; AtlW2AHelper
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
EXTRN	__imp__lstrlenW@4:NEAR
EXTRN	__imp__CompareStringA@24:NEAR
EXTRN	__alloca_probe:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T207788 DD	0ffffffffH
	DD	FLAT:$L207783
$T207785 DD	019930520H
	DD	01H
	DD	FLAT:$T207788
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
tv147 = -68						; size = 4
tv142 = -64						; size = 4
tv149 = -60						; size = 4
tv89 = -56						; size = 4
tv84 = -52						; size = 4
tv91 = -48						; size = 4
$T207782 = -44						; size = 4
_pszAString1$ = -40					; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__convert_ex$ = -32					; size = 4
__acp_ex$ = -28						; size = 4
_pszAString2$ = -24					; size = 4
__lpw_ex$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWFake, COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 38	 sub	 esp, 56			; 00000038H

; 193  : 	USES_CONVERSION_EX;

  0001b	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00020	89 45 e4	 mov	 DWORD PTR __acp_ex$[ebp], eax
  00023	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 194  : 	
; 195  : 	LPCSTR pszAString1 = NULL;

  00032	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pszAString1$[ebp], 0

; 196  : 	if(pszString1 != NULL)

  00039	83 7d 10 00	 cmp	 DWORD PTR _pszString1$[ebp], 0
  0003d	0f 84 98 00 00
	00		 je	 $L25772

; 197  : 	{
; 198  : 		pszAString1 = W2A_EX(pszString1,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00043	8b 45 10	 mov	 eax, DWORD PTR _pszString1$[ebp]
  00046	89 45 f0	 mov	 DWORD PTR __lpw_ex$[ebp], eax
  00049	83 7d f0 00	 cmp	 DWORD PTR __lpw_ex$[ebp], 0
  0004d	75 09		 jne	 SHORT $L207776
  0004f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
  00056	eb 6d		 jmp	 SHORT $L207777
$L207776:
  00058	8b 4d f0	 mov	 ecx, DWORD PTR __lpw_ex$[ebp]
  0005b	51		 push	 ecx
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00062	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00066	89 55 e0	 mov	 DWORD PTR __convert_ex$[ebp], edx
  00069	81 7d e0 00 04
	00 00		 cmp	 DWORD PTR __convert_ex$[ebp], 1024 ; 00000400H
  00070	7f 2c		 jg	 SHORT $L207774
  00072	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0007b	83 c4 04	 add	 esp, 4
  0007e	0f b6 c8	 movzx	 ecx, al
  00081	85 c9		 test	 ecx, ecx
  00083	74 19		 je	 SHORT $L207774
  00085	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00088	83 c0 03	 add	 eax, 3
  0008b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008e	e8 00 00 00 00	 call	 __alloca_probe
  00093	89 65 cc	 mov	 DWORD PTR tv84[ebp], esp
  00096	8b 55 cc	 mov	 edx, DWORD PTR tv84[ebp]
  00099	89 55 c8	 mov	 DWORD PTR tv89[ebp], edx
  0009c	eb 0f		 jmp	 SHORT $L207775
$L207774:
  0009e	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  000a1	50		 push	 eax
  000a2	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000a5	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  000aa	89 45 c8	 mov	 DWORD PTR tv89[ebp], eax
$L207775:
  000ad	8b 4d e4	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 e0	 mov	 edx, DWORD PTR __convert_ex$[ebp]
  000b4	52		 push	 edx
  000b5	8b 45 f0	 mov	 eax, DWORD PTR __lpw_ex$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d c8	 mov	 ecx, DWORD PTR tv89[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  000c2	89 45 d0	 mov	 DWORD PTR tv91[ebp], eax
$L207777:
  000c5	8b 55 d0	 mov	 edx, DWORD PTR tv91[ebp]
  000c8	89 55 d8	 mov	 DWORD PTR _pszAString1$[ebp], edx

; 199  : 		if(pszAString1 == NULL)

  000cb	83 7d d8 00	 cmp	 DWORD PTR _pszAString1$[ebp], 0
  000cf	75 0a		 jne	 SHORT $L25772

; 200  : 			AtlThrow(E_OUTOFMEMORY);

  000d1	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  000d6	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L25772:

; 201  : 	}
; 202  : 
; 203  : 	LPCSTR pszAString2 = NULL;

  000db	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pszAString2$[ebp], 0

; 204  : 	if(pszString2 != NULL)

  000e2	83 7d 18 00	 cmp	 DWORD PTR _pszString2$[ebp], 0
  000e6	0f 84 98 00 00
	00		 je	 $L25778

; 205  : 	{
; 206  : 		pszAString2 = W2A_EX(pszString2,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  000ec	8b 45 18	 mov	 eax, DWORD PTR _pszString2$[ebp]
  000ef	89 45 f0	 mov	 DWORD PTR __lpw_ex$[ebp], eax
  000f2	83 7d f0 00	 cmp	 DWORD PTR __lpw_ex$[ebp], 0
  000f6	75 09		 jne	 SHORT $L207780
  000f8	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv149[ebp], 0
  000ff	eb 6d		 jmp	 SHORT $L207781
$L207780:
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __lpw_ex$[ebp]
  00104	51		 push	 ecx
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0010b	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  0010f	89 55 e0	 mov	 DWORD PTR __convert_ex$[ebp], edx
  00112	81 7d e0 00 04
	00 00		 cmp	 DWORD PTR __convert_ex$[ebp], 1024 ; 00000400H
  00119	7f 2c		 jg	 SHORT $L207778
  0011b	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  00124	83 c4 04	 add	 esp, 4
  00127	0f b6 c8	 movzx	 ecx, al
  0012a	85 c9		 test	 ecx, ecx
  0012c	74 19		 je	 SHORT $L207778
  0012e	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00131	83 c0 03	 add	 eax, 3
  00134	83 e0 fc	 and	 eax, -4			; fffffffcH
  00137	e8 00 00 00 00	 call	 __alloca_probe
  0013c	89 65 c0	 mov	 DWORD PTR tv142[ebp], esp
  0013f	8b 55 c0	 mov	 edx, DWORD PTR tv142[ebp]
  00142	89 55 bc	 mov	 DWORD PTR tv147[ebp], edx
  00145	eb 0f		 jmp	 SHORT $L207779
$L207778:
  00147	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  0014a	50		 push	 eax
  0014b	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  0014e	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  00153	89 45 bc	 mov	 DWORD PTR tv147[ebp], eax
$L207779:
  00156	8b 4d e4	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  00159	51		 push	 ecx
  0015a	8b 55 e0	 mov	 edx, DWORD PTR __convert_ex$[ebp]
  0015d	52		 push	 edx
  0015e	8b 45 f0	 mov	 eax, DWORD PTR __lpw_ex$[ebp]
  00161	50		 push	 eax
  00162	8b 4d bc	 mov	 ecx, DWORD PTR tv147[ebp]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0016b	89 45 c4	 mov	 DWORD PTR tv149[ebp], eax
$L207781:
  0016e	8b 55 c4	 mov	 edx, DWORD PTR tv149[ebp]
  00171	89 55 e8	 mov	 DWORD PTR _pszAString2$[ebp], edx

; 207  : 		if(pszAString2 == NULL)

  00174	83 7d e8 00	 cmp	 DWORD PTR _pszAString2$[ebp], 0
  00178	75 0a		 jne	 SHORT $L25778

; 208  : 			AtlThrow(E_OUTOFMEMORY);

  0017a	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0017f	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L25778:

; 209  : 	}
; 210  : 
; 211  : 	return ::CompareStringA(lcid, dwFlags, pszAString1, nLength1, pszAString2, nLength2);

  00184	8b 45 1c	 mov	 eax, DWORD PTR _nLength2$[ebp]
  00187	50		 push	 eax
  00188	8b 4d e8	 mov	 ecx, DWORD PTR _pszAString2$[ebp]
  0018b	51		 push	 ecx
  0018c	8b 55 14	 mov	 edx, DWORD PTR _nLength1$[ebp]
  0018f	52		 push	 edx
  00190	8b 45 d8	 mov	 eax, DWORD PTR _pszAString1$[ebp]
  00193	50		 push	 eax
  00194	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00197	51		 push	 ecx
  00198	8b 55 08	 mov	 edx, DWORD PTR _lcid$[ebp]
  0019b	52		 push	 edx
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CompareStringA@24
  001a2	89 45 d4	 mov	 DWORD PTR $T207782[ebp], eax
  001a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001ac	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  001af	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  001b4	8b 45 d4	 mov	 eax, DWORD PTR $T207782[ebp]
$L207773:

; 212  : }

  001b7	8d 65 bc	 lea	 esp, DWORD PTR [ebp-68]
  001ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L207783:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207785
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWFake
EXTRN	__imp___resetstkoflw:NEAR
EXTRN	__except_handler3:NEAR
;	COMDAT CONST
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
CONST	SEGMENT
$T207799 DD	0ffffffffH
	DD	FLAT:$L207794
	DD	FLAT:$L207795
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
tv65 = -40						; size = 4
$T207798 = -36						; size = 4
_p$24118 = -32						; size = 4
_bStackAvailable$ = -25					; size = 1
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 OFFSET FLAT:$T207799
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:__except_handler3
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00015	50		 push	 eax
  00016	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001d	83 c4 e8	 add	 esp, -24		; ffffffe8H
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 332  :     bool bStackAvailable = true;

  00026	c6 45 e7 01	 mov	 BYTE PTR _bStackAvailable$[ebp], 1

; 333  : 
; 334  :     __try

  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 335  :     {
; 336  :         PVOID p = _alloca(Size + _ATL_STACK_MARGIN);

  00031	8b 45 08	 mov	 eax, DWORD PTR _Size$[ebp]
  00034	05 03 20 00 00	 add	 eax, 8195		; 00002003H
  00039	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003c	e8 00 00 00 00	 call	 __alloca_probe
  00041	89 65 d8	 mov	 DWORD PTR tv65[ebp], esp
  00044	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00047	8b 45 d8	 mov	 eax, DWORD PTR tv65[ebp]
  0004a	89 45 e0	 mov	 DWORD PTR _p$24118[ebp], eax
  0004d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00054	eb 2c		 jmp	 SHORT $L207797
$L207794:
$L207803:

; 337  :         (p);
; 338  :     }
; 339  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 340  :                    EXCEPTION_EXECUTE_HANDLER :
; 341  :                    EXCEPTION_CONTINUE_SEARCH)

  00056	8b 4d ec	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+4]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8b 02		 mov	 eax, DWORD PTR [edx]
  0005d	89 45 dc	 mov	 DWORD PTR $T207798[ebp], eax
  00060	8b 45 dc	 mov	 eax, DWORD PTR $T207798[ebp]
  00063	2d fd 00 00 c0	 sub	 eax, -1073741571	; c00000fdH
  00068	f7 d8		 neg	 eax
  0006a	1b c0		 sbb	 eax, eax
  0006c	40		 inc	 eax
$L207796:
$L207802:
  0006d	c3		 ret	 0
$L207795:
  0006e	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 342  :     {
; 343  :         bStackAvailable = false;

  00071	c6 45 e7 00	 mov	 BYTE PTR _bStackAvailable$[ebp], 0

; 344  :         _resetstkoflw();

  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___resetstkoflw
  0007b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$L207797:

; 345  :     }
; 346  :     return bStackAvailable;

  00082	8a 45 e7	 mov	 al, BYTE PTR _bStackAvailable$[ebp]
$L207793:

; 347  : }

  00085	8d 65 cc	 lea	 esp, DWORD PTR [ebp-52]
  00088	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
EXTRN	__imp__WideCharToMultiByte@32:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPB_WHI@Z PROC NEAR		; AtlW2AHelper, COMDAT

; 573  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 574  : 	ATLASSERT(lpw != NULL);
; 575  : 	ATLASSERT(lpa != NULL);
; 576  : 	if (lpa == NULL || lpw == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpa$[ebp], 0
  00008	74 06		 je	 SHORT $L24319
  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpw$[ebp], 0
  0000e	75 04		 jne	 SHORT $L24318
$L24319:

; 577  : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 34		 jmp	 SHORT $L24315
$L24318:

; 578  : 	// verify that no illegal character present
; 579  : 	// since lpa was allocated based on the size of lpw
; 580  : 	// don't worry about the number of chars
; 581  : 	lpa[0] = '\0';

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpa$[ebp]
  00017	c6 00 00	 mov	 BYTE PTR [eax], 0

; 582  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR _nChars$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _lpa$[ebp]
  00025	52		 push	 edx
  00026	6a ff		 push	 -1
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lpw$[ebp]
  0002b	50		 push	 eax
  0002c	6a 00		 push	 0
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _acp$[ebp]
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00038	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 583  : 	if(ret == 0)

  0003b	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0003f	75 04		 jne	 SHORT $L24321

; 584  : 	{
; 585  : 		ATLASSERT(FALSE);
; 586  : 		return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	eb 03		 jmp	 SHORT $L24315
$L24321:

; 587  : 	}
; 588  : 	return lpa;

  00045	8b 45 08	 mov	 eax, DWORD PTR _lpa$[ebp]
$L24315:

; 589  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 10 00	 ret	 16			; 00000010H
?AtlW2AHelper@@YGPADPADPB_WHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00003	81 7d 08 0e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
  0000a	75 05		 jne	 SHORT $L24681

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000c	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L24681:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00011	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L207809:

; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );
; 74   : #endif
; 75   : };

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?erase@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::erase
PUBLIC	??0TAB_ITEM@@QAE@XZ				; TAB_ITEM::TAB_ITEM
EXTRN	?Recycle@TabWndFactory@@QAEXPAVCWnd@@@Z:NEAR	; TabWndFactory::Recycle
EXTRN	?AfxGetDataManager2@@YAPAVIDataManager@@XZ:NEAR	; AfxGetDataManager2
xdata$x	SEGMENT
$T207822 DD	0ffffffffH
	DD	FLAT:$L207817
$T207819 DD	019930520H
	DD	01H
	DD	FLAT:$T207822
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabpagecontrol.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv153 = -108						; size = 4
tv147 = -104						; size = 4
_this$ = -100						; size = 4
$T207816 = -96						; size = 4
$T207815 = -92						; size = 4
$T207814 = -88						; size = 4
$T207813 = -84						; size = 4
_ti$ = -80						; size = 60
__$ArrayPad$ = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_item$ = 8						; size = 4
?ITabBarOb_DelTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabPageControl::ITabBarOb_DelTab
; _this$ = ecx

; 168  : {

  005d0	55		 push	 ebp
  005d1	8b ec		 mov	 ebp, esp
  005d3	6a ff		 push	 -1
  005d5	68 00 00 00 00	 push	 __ehhandler$?ITabBarOb_DelTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z
  005da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  005e0	50		 push	 eax
  005e1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  005e8	83 ec 60	 sub	 esp, 96			; 00000060H
  005eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  005f0	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  005f3	89 4d 9c	 mov	 DWORD PTR _this$[ebp], ecx

; 169  : 	vector<ONE_TAB>::iterator it = m_mapTab.begin();

  005f6	8d 45 f0	 lea	 eax, DWORD PTR _it$[ebp]
  005f9	50		 push	 eax
  005fa	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  005fd	83 c1 04	 add	 ecx, 4
  00600	e8 00 00 00 00	 call	 ?begin@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::begin

; 170  : 	for( ; it != m_mapTab.end(); it++ )

  00605	eb 0e		 jmp	 SHORT $L205828
$L205829:
  00607	6a 00		 push	 0
  00609	8d 4d ac	 lea	 ecx, DWORD PTR $T207813[ebp]
  0060c	51		 push	 ecx
  0060d	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  00610	e8 00 00 00 00	 call	 ??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AV012@H@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator++
$L205828:
  00615	8d 55 a8	 lea	 edx, DWORD PTR $T207814[ebp]
  00618	52		 push	 edx
  00619	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0061c	83 c1 04	 add	 ecx, 4
  0061f	e8 00 00 00 00	 call	 ?end@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::end
  00624	50		 push	 eax
  00625	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  00628	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator!=
  0062d	0f b6 c0	 movzx	 eax, al
  00630	85 c0		 test	 eax, eax
  00632	74 34		 je	 SHORT $L205830

; 171  : 	{
; 172  : 		if( it->first.strName == item.strName
; 173  : 			&& it->first.eumType == item.eumType )

  00634	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00637	51		 push	 ecx
  00638	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  0063b	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  00640	50		 push	 eax
  00641	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
  00647	83 c4 08	 add	 esp, 8
  0064a	0f b6 d0	 movzx	 edx, al
  0064d	85 d2		 test	 edx, edx
  0064f	74 15		 je	 SHORT $L205831
  00651	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  00654	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  00659	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0065c	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0065f	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00662	75 02		 jne	 SHORT $L205831

; 174  : 		{
; 175  : 			break;

  00664	eb 02		 jmp	 SHORT $L205830
$L205831:

; 176  : 		}
; 177  : 	}

  00666	eb 9f		 jmp	 SHORT $L205829
$L205830:

; 178  : 	if( it != m_mapTab.end() )

  00668	8d 45 a4	 lea	 eax, DWORD PTR $T207815[ebp]
  0066b	50		 push	 eax
  0066c	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0066f	83 c1 04	 add	 ecx, 4
  00672	e8 00 00 00 00	 call	 ?end@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::end
  00677	50		 push	 eax
  00678	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  0067b	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator!=
  00680	0f b6 c8	 movzx	 ecx, al
  00683	85 c9		 test	 ecx, ecx
  00685	74 2b		 je	 SHORT $L205833

; 179  : 	{
; 180  : 		TabWndFactory::GetInstance()->Recycle( it->second );

  00687	8d 4d f0	 lea	 ecx, DWORD PTR _it$[ebp]
  0068a	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  0068f	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  00692	52		 push	 edx
  00693	e8 00 00 00 00	 call	 ?GetInstance@TabWndFactory@@SAPAV1@XZ ; TabWndFactory::GetInstance
  00698	8b c8		 mov	 ecx, eax
  0069a	e8 00 00 00 00	 call	 ?Recycle@TabWndFactory@@QAEXPAVCWnd@@@Z ; TabWndFactory::Recycle

; 181  : 		m_mapTab.erase( it );

  0069f	8b 45 f0	 mov	 eax, DWORD PTR _it$[ebp]
  006a2	50		 push	 eax
  006a3	8d 4d a0	 lea	 ecx, DWORD PTR $T207816[ebp]
  006a6	51		 push	 ecx
  006a7	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  006aa	83 c1 04	 add	 ecx, 4
  006ad	e8 00 00 00 00	 call	 ?erase@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::erase
$L205833:

; 182  : 	}
; 183  : 	//tab
; 184  : 	TAB_ITEM ti;

  006b2	8d 4d b0	 lea	 ecx, DWORD PTR _ti$[ebp]
  006b5	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@XZ
  006ba	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 185  : 	GLOBAL_TABBARDATA->ITabBar_GetCurItem( ti );

  006c1	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  006c6	89 45 98	 mov	 DWORD PTR tv147[ebp], eax
  006c9	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_TABBAR
  006ce	8b 55 98	 mov	 edx, DWORD PTR tv147[ebp]
  006d1	8b 02		 mov	 eax, DWORD PTR [edx]
  006d3	8b 4d 98	 mov	 ecx, DWORD PTR tv147[ebp]
  006d6	ff 50 0c	 call	 DWORD PTR [eax+12]
  006d9	89 45 94	 mov	 DWORD PTR tv153[ebp], eax
  006dc	8d 4d b0	 lea	 ecx, DWORD PTR _ti$[ebp]
  006df	51		 push	 ecx
  006e0	8b 55 94	 mov	 edx, DWORD PTR tv153[ebp]
  006e3	8b 02		 mov	 eax, DWORD PTR [edx]
  006e5	8b 4d 94	 mov	 ecx, DWORD PTR tv153[ebp]
  006e8	ff 50 18	 call	 DWORD PTR [eax+24]

; 186  : 	{
; 187  : 		ITabBarOb_OpenExistTab( ti );

  006eb	8d 4d b0	 lea	 ecx, DWORD PTR _ti$[ebp]
  006ee	51		 push	 ecx
  006ef	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  006f2	8b 02		 mov	 eax, DWORD PTR [edx]
  006f4	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  006f7	ff 50 08	 call	 DWORD PTR [eax+8]

; 188  : 	}
; 189  : }

  006fa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00701	8d 4d b0	 lea	 ecx, DWORD PTR _ti$[ebp]
  00704	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
  00709	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0070c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00713	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00716	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0071b	8b e5		 mov	 esp, ebp
  0071d	5d		 pop	 ebp
  0071e	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L207817:
  0008e	8d 4d b0	 lea	 ecx, DWORD PTR _ti$[ebp]
  00091	e9 00 00 00 00	 jmp	 ??1TAB_ITEM@@QAE@XZ
__ehhandler$?ITabBarOb_DelTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z:
  00096	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207819
  0009b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ITabBarOb_DelTab@CTabPageControl@@UAEXAAUTAB_ITEM@@@Z ENDP ; CTabPageControl::ITabBarOb_DelTab
PUBLIC	?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExW@20:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWThunk, COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 241  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetStringTypeExW@20
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ; ATL::GetStringTypeExWFake
  0000e	68 04 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  : 
; 243  : 	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);

  0001b	8b 4d 18	 mov	 ecx, DWORD PTR _pwCharType$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 14	 mov	 edx, DWORD PTR _nLength$[ebp]
  00022	52		 push	 edx
  00023	8b 45 10	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _dwInfoType$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _lcid$[ebp]
  0002e	52		 push	 edx
  0002f	ff 15 04 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4

; 244  : }

  00035	5d		 pop	 ebp
  00036	c2 14 00	 ret	 20			; 00000014H
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z ENDP	; ATL::GetStringTypeExWThunk
_TEXT	ENDS
EXTRN	__imp__GetStringTypeExA@20:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T207833 DD	0ffffffffH
	DD	FLAT:$L207828
$T207830 DD	019930520H
	DD	01H
	DD	FLAT:$T207833
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
$T207827 = -164						; size = 4
_nLengthA$ = -160					; size = 4
_pszA$ = -156						; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWFake, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 225  : 	int nLengthA;
; 226  : 	CTempBuffer<char> pszA;

  00026	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 227  : 
; 228  : 	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	8b 45 14	 mov	 eax, DWORD PTR _nLength$[ebp]
  00043	50		 push	 eax
  00044	8b 4d 10	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  00047	51		 push	 ecx
  00048	6a 00		 push	 0
  0004a	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00056	89 85 60 ff ff
	ff		 mov	 DWORD PTR _nLengthA$[ebp], eax

; 229  : 	pszA.Allocate(nLengthA);

  0005c	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _nLengthA$[ebp]
  00062	52		 push	 edx
  00063	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  00069	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 230  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nLengthA$[ebp]
  00078	50		 push	 eax
  00079	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  0007f	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  00084	50		 push	 eax
  00085	8b 4d 14	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 10	 mov	 edx, DWORD PTR _pszSrc$[ebp]
  0008c	52		 push	 edx
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 231  : 
; 232  : 	if (nLength == -1)

  0009b	83 7d 14 ff	 cmp	 DWORD PTR _nLength$[ebp], -1
  0009f	75 0a		 jne	 SHORT $L25804

; 233  : 		nLengthA = -1;

  000a1	c7 85 60 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _nLengthA$[ebp], -1
$L25804:

; 234  : 
; 235  : 	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);

  000ab	8b 45 18	 mov	 eax, DWORD PTR _pwCharType$[ebp]
  000ae	50		 push	 eax
  000af	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _nLengthA$[ebp]
  000b5	51		 push	 ecx
  000b6	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  000bc	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000c1	50		 push	 eax
  000c2	8b 55 0c	 mov	 edx, DWORD PTR _dwInfoType$[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 08	 mov	 eax, DWORD PTR _lcid$[ebp]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStringTypeExA@20
  000d0	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T207827[ebp], eax
  000d6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000dd	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  000e3	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  000e8	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T207827[ebp]

; 236  : }

  000ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L207828:
  00000	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207830
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ENDP		; ATL::GetStringTypeExWFake
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T207843 DD	0ffffffffH
	DD	FLAT:$L207838
$T207841 DD	019930520H
	DD	01H
	DD	FLAT:$T207843
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0TAB_ITEM@@QAE@XZ PROC NEAR				; TAB_ITEM::TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0TAB_ITEM@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 20	 add	 ecx, 32			; 00000020H
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00045	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L207838:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0TAB_ITEM@@QAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207841
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0TAB_ITEM@@QAE@XZ ENDP				; TAB_ITEM::TAB_ITEM
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabpagecontrol.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iErrorCode$ = 8					; size = 4
?ITabBarOb_OpenTabError@CTabPageControl@@UAEXH@Z PROC NEAR ; CTabPageControl::ITabBarOb_OpenTabError
; _this$ = ecx

; 192  : {

  00730	55		 push	 ebp
  00731	8b ec		 mov	 ebp, esp
  00733	51		 push	 ecx
  00734	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 193  : }

  00737	8b e5		 mov	 esp, ebp
  00739	5d		 pop	 ebp
  0073a	c2 04 00	 ret	 4
?ITabBarOb_OpenTabError@CTabPageControl@@UAEXH@Z ENDP	; CTabPageControl::ITabBarOb_OpenTabError
_TEXT	ENDS
PUBLIC	?lstrcmpiWFake@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiW@8:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWThunk, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 255  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__lstrcmpiW@8
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?lstrcmpiWFake@ATL@@YGHPB_W0@Z ; ATL::lstrcmpiWFake
  0000e	68 08 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 256  : 
; 257  : 	return _strthunks.pfnlstrcmpiW(psz1, psz2);

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _psz2$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _psz1$[ebp]
  00022	52		 push	 edx
  00023	ff 15 08 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8

; 258  : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWThunk
_TEXT	ENDS
EXTRN	__imp__lstrcmpiA@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv94 = -28						; size = 4
tv76 = -24						; size = 4
tv79 = -20						; size = 4
__acp$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWFake@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWFake, COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 248  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f4	 mov	 DWORD PTR __acp$[ebp], eax

; 249  : 
; 250  : 	return ::lstrcmpiA(W2A(psz1), W2A(psz2));

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _psz2$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L207851
  0001a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L207852
$L207851:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e8	 mov	 DWORD PTR tv76[ebp], esp
  00045	8b 45 f4	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e8	 mov	 eax, DWORD PTR tv76[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
$L207852:
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _psz1$[ebp]
  00060	89 4d f8	 mov	 DWORD PTR __lpw$[ebp], ecx
  00063	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00067	75 09		 jne	 SHORT $L207853
  00069	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00070	eb 3a		 jmp	 SHORT $L207854
$L207853:
  00072	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00075	52		 push	 edx
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0007c	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00080	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00083	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008c	e8 00 00 00 00	 call	 __alloca_probe
  00091	89 65 e0	 mov	 DWORD PTR tv91[ebp], esp
  00094	8b 4d f4	 mov	 ecx, DWORD PTR __acp$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 fc	 mov	 edx, DWORD PTR __convert$[ebp]
  0009b	52		 push	 edx
  0009c	8b 45 f8	 mov	 eax, DWORD PTR __lpw$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d e0	 mov	 ecx, DWORD PTR tv91[ebp]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  000a9	89 45 e4	 mov	 DWORD PTR tv94[ebp], eax
$L207854:
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000af	52		 push	 edx
  000b0	8b 45 e4	 mov	 eax, DWORD PTR tv94[ebp]
  000b3	50		 push	 eax
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8

; 251  : }

  000ba	8d 65 e0	 lea	 esp, DWORD PTR [ebp-32]
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
?lstrcmpiWFake@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWFake
_TEXT	ENDS
PUBLIC	?ResizePage@CTabPageControl@@QAEXXZ		; CTabPageControl::ResizePage
PUBLIC	??0CRect@@QAE@HHHH@Z				; CRect::CRect
PUBLIC	??BCRect@@QAEPAUtagRECT@@XZ			; CRect::operator tagRECT *
PUBLIC	?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::size
PUBLIC	?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z		; CWnd::MoveWindow
xdata$x	SEGMENT
$T207865 DD	0ffffffffH
	DD	FLAT:$L207860
$T207862 DD	019930520H
	DD	01H
	DD	FLAT:$T207865
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabpagecontrol.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv79 = -132						; size = 4
tv73 = -128						; size = 4
_this$ = -124						; size = 4
$T207859 = -120						; size = 4
$T207858 = -116						; size = 4
_it$205852 = -112					; size = 4
_ti$ = -108						; size = 60
__$ArrayPad$ = -48					; size = 4
_rcNull$ = -44						; size = 16
_rc$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?ResizePage@CTabPageControl@@QAEXXZ PROC NEAR		; CTabPageControl::ResizePage
; _this$ = ecx

; 196  : {

  00740	55		 push	 ebp
  00741	8b ec		 mov	 ebp, esp
  00743	6a ff		 push	 -1
  00745	68 00 00 00 00	 push	 __ehhandler$?ResizePage@CTabPageControl@@QAEXXZ
  0074a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00750	50		 push	 eax
  00751	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00758	83 ec 78	 sub	 esp, 120		; 00000078H
  0075b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00760	89 45 d0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00763	89 4d 84	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 	if( m_mapTab.size() <= 0 )

  00766	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  00769	83 c1 04	 add	 ecx, 4
  0076c	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::size
  00771	85 c0		 test	 eax, eax
  00773	77 05		 ja	 SHORT $L205846

; 198  : 		return;

  00775	e9 81 01 00 00	 jmp	 $L205845
$L205846:

; 199  : 	//tabitem
; 200  : 	TAB_ITEM ti;

  0077a	8d 4d 94	 lea	 ecx, DWORD PTR _ti$[ebp]
  0077d	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@XZ
  00782	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 201  : 	GLOBAL_TABBARDATA->ITabBar_GetCurItem( ti );

  00789	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  0078e	89 45 80	 mov	 DWORD PTR tv73[ebp], eax
  00791	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_TABBAR
  00796	8b 45 80	 mov	 eax, DWORD PTR tv73[ebp]
  00799	8b 10		 mov	 edx, DWORD PTR [eax]
  0079b	8b 4d 80	 mov	 ecx, DWORD PTR tv73[ebp]
  0079e	ff 52 0c	 call	 DWORD PTR [edx+12]
  007a1	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  007a7	8d 45 94	 lea	 eax, DWORD PTR _ti$[ebp]
  007aa	50		 push	 eax
  007ab	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv79[ebp]
  007b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  007b3	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv79[ebp]
  007b9	ff 52 18	 call	 DWORD PTR [edx+24]

; 202  : 
; 203  : 	//
; 204  : 	CRect rc;

  007bc	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  007bf	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect

; 205  : 	m_pWndParent->GetClientRect(&rc);

  007c4	8d 45 e4	 lea	 eax, DWORD PTR _rc$[ebp]
  007c7	50		 push	 eax
  007c8	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  007cb	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  007ce	e8 00 00 00 00	 call	 ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::GetClientRect

; 206  : 	//rc.bottom -= 30;
; 207  : 
; 208  : 	//
; 209  : 	CRect rcNull(0,0,0,0);

  007d3	6a 00		 push	 0
  007d5	6a 00		 push	 0
  007d7	6a 00		 push	 0
  007d9	6a 00		 push	 0
  007db	8d 4d d4	 lea	 ecx, DWORD PTR _rcNull$[ebp]
  007de	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect

; 210  : 
; 211  : 	for( vector<ONE_TAB>::iterator it = m_mapTab.begin();

  007e3	8d 55 90	 lea	 edx, DWORD PTR _it$205852[ebp]
  007e6	52		 push	 edx
  007e7	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  007ea	83 c1 04	 add	 ecx, 4
  007ed	e8 00 00 00 00	 call	 ?begin@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::begin

; 212  : 		it != m_mapTab.end(); it++ )

  007f2	eb 0e		 jmp	 SHORT $L205856
$L205857:
  007f4	6a 00		 push	 0
  007f6	8d 45 8c	 lea	 eax, DWORD PTR $T207858[ebp]
  007f9	50		 push	 eax
  007fa	8d 4d 90	 lea	 ecx, DWORD PTR _it$205852[ebp]
  007fd	e8 00 00 00 00	 call	 ??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AV012@H@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator++
$L205856:
  00802	8d 4d 88	 lea	 ecx, DWORD PTR $T207859[ebp]
  00805	51		 push	 ecx
  00806	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  00809	83 c1 04	 add	 ecx, 4
  0080c	e8 00 00 00 00	 call	 ?end@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::end
  00811	50		 push	 eax
  00812	8d 4d 90	 lea	 ecx, DWORD PTR _it$205852[ebp]
  00815	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator!=
  0081a	0f b6 d0	 movzx	 edx, al
  0081d	85 d2		 test	 edx, edx
  0081f	0f 84 c7 00 00
	00		 je	 $L205858

; 213  : 	{
; 214  : 		if( it->first.eumType == ti.eumType
; 215  : 			&& it->first.strName == ti.strName )

  00825	8d 4d 90	 lea	 ecx, DWORD PTR _it$205852[ebp]
  00828	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  0082d	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00830	3b 45 b0	 cmp	 eax, DWORD PTR _ti$[ebp+28]
  00833	0f 85 81 00 00
	00		 jne	 $L205859
  00839	8d 4d 94	 lea	 ecx, DWORD PTR _ti$[ebp]
  0083c	51		 push	 ecx
  0083d	8d 4d 90	 lea	 ecx, DWORD PTR _it$205852[ebp]
  00840	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  00845	50		 push	 eax
  00846	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
  0084c	83 c4 08	 add	 esp, 8
  0084f	0f b6 d0	 movzx	 edx, al
  00852	85 d2		 test	 edx, edx
  00854	74 64		 je	 SHORT $L205859

; 216  : 		{
; 217  : 			if (ti.eumType == TAB_PLAYED_GAME)

  00856	83 7d b0 04	 cmp	 DWORD PTR _ti$[ebp+28], 4
  0085a	75 2f		 jne	 SHORT $L205860

; 218  : 			{
; 219  : 				it->second->MoveWindow (rc, FALSE);

  0085c	6a 00		 push	 0
  0085e	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  00861	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  00866	50		 push	 eax
  00867	8d 4d 90	 lea	 ecx, DWORD PTR _it$205852[ebp]
  0086a	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  0086f	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00872	e8 00 00 00 00	 call	 ?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::MoveWindow

; 220  : 				it->second->ShowWindow (SW_SHOW);

  00877	6a 05		 push	 5
  00879	8d 4d 90	 lea	 ecx, DWORD PTR _it$205852[ebp]
  0087c	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  00881	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00884	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 221  : 			}
; 222  : 			else

  00889	eb 2d		 jmp	 SHORT $L205861
$L205860:

; 223  : 			{
; 224  : 				it->second->MoveWindow(rc, FALSE);

  0088b	6a 00		 push	 0
  0088d	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  00890	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  00895	50		 push	 eax
  00896	8d 4d 90	 lea	 ecx, DWORD PTR _it$205852[ebp]
  00899	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  0089e	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  008a1	e8 00 00 00 00	 call	 ?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::MoveWindow

; 225  : 				it->second->ShowWindow (SW_SHOW);

  008a6	6a 05		 push	 5
  008a8	8d 4d 90	 lea	 ecx, DWORD PTR _it$205852[ebp]
  008ab	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  008b0	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  008b3	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow
$L205861:

; 226  : 			}
; 227  : 		}else

  008b8	eb 2d		 jmp	 SHORT $L205862
$L205859:

; 228  : 		{
; 229  : // 			it->second->MoveWindow(rcNull, FALSE);
; 230  : 			it->second->MoveWindow (rc, FALSE);

  008ba	6a 00		 push	 0
  008bc	8d 4d e4	 lea	 ecx, DWORD PTR _rc$[ebp]
  008bf	e8 00 00 00 00	 call	 ??BCRect@@QAEPAUtagRECT@@XZ ; CRect::operator tagRECT *
  008c4	50		 push	 eax
  008c5	8d 4d 90	 lea	 ecx, DWORD PTR _it$205852[ebp]
  008c8	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  008cd	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  008d0	e8 00 00 00 00	 call	 ?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z ; CWnd::MoveWindow

; 231  : 			it->second->ShowWindow (SW_HIDE);

  008d5	6a 00		 push	 0
  008d7	8d 4d 90	 lea	 ecx, DWORD PTR _it$205852[ebp]
  008da	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  008df	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  008e2	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow
$L205862:

; 232  : 		}
; 233  : 	}

  008e7	e9 08 ff ff ff	 jmp	 $L205857
$L205858:

; 234  : }

  008ec	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  008f3	8d 4d 94	 lea	 ecx, DWORD PTR _ti$[ebp]
  008f6	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
$L205845:
  008fb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  008fe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00905	8b 4d d0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00908	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0090d	8b e5		 mov	 esp, ebp
  0090f	5d		 pop	 ebp
  00910	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L207860:
  000a0	8d 4d 94	 lea	 ecx, DWORD PTR _ti$[ebp]
  000a3	e9 00 00 00 00	 jmp	 ??1TAB_ITEM@@QAE@XZ
__ehhandler$?ResizePage@CTabPageControl@@QAEXXZ:
  000a8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207862
  000ad	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ResizePage@CTabPageControl@@QAEXXZ ENDP		; CTabPageControl::ResizePage
PUBLIC	?CharLowerWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWFake
EXTRN	__imp__CharLowerW@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWThunk, COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 274  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharLowerW@4
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CharLowerWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharLowerWFake
  0000e	68 0c 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  : 
; 276  : 	return _strthunks.pfnCharLowerW(psz);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 15 0c 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12

; 277  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWThunk
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z		; AtlA2WHelper
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	__imp__CharLowerA@4:NEAR
EXTRN	__imp__wcscpy:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
__lpa$ = -20						; size = 4
__acp$ = -16						; size = 4
_pszA$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWFake, COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 262  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f0	 mov	 DWORD PTR __acp$[ebp], eax

; 263  : 	LPSTR pszA;
; 264  : 
; 265  : 	pszA = W2A(psz);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L207869
  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L207870
$L207869:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e4	 mov	 DWORD PTR tv75[ebp], esp
  00045	8b 45 f0	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$L207870:
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00060	89 4d f4	 mov	 DWORD PTR _pszA$[ebp], ecx

; 266  : 	::CharLowerA(pszA);

  00063	8b 55 f4	 mov	 edx, DWORD PTR _pszA$[ebp]
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharLowerA@4

; 267  : 	wcscpy(psz, A2W(pszA));

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _pszA$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR __lpa$[ebp], eax
  00073	83 7d ec 00	 cmp	 DWORD PTR __lpa$[ebp], 0
  00077	75 09		 jne	 SHORT $L207871
  00079	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00080	eb 3b		 jmp	 SHORT $L207872
$L207871:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00092	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00095	d1 e0		 shl	 eax, 1
  00097	83 c0 03	 add	 eax, 3
  0009a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0009d	e8 00 00 00 00	 call	 __alloca_probe
  000a2	89 65 dc	 mov	 DWORD PTR tv90[ebp], esp
  000a5	8b 55 f0	 mov	 edx, DWORD PTR __acp$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  000ba	89 45 e0	 mov	 DWORD PTR tv94[ebp], eax
$L207872:
  000bd	8b 45 e0	 mov	 eax, DWORD PTR tv94[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  000c4	51		 push	 ecx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000cb	83 c4 08	 add	 esp, 8

; 268  : 
; 269  : 	return psz;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]

; 270  : }

  000d1	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z PROC NEAR		; AtlA2WHelper, COMDAT

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 555  : 	ATLASSERT(lpa != NULL);
; 556  : 	ATLASSERT(lpw != NULL);
; 557  : 	if (lpw == NULL || lpa == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpw$[ebp], 0
  00008	74 06		 je	 SHORT $L24306
  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpa$[ebp], 0
  0000e	75 04		 jne	 SHORT $L24305
$L24306:

; 558  : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 32		 jmp	 SHORT $L24302
$L24305:

; 559  : 	// verify that no illegal character present
; 560  : 	// since lpw was allocated based on the size of lpa
; 561  : 	// don't worry about the number of chars
; 562  : 	lpw[0] = '\0';

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
  00017	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 563  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _nChars$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 08	 mov	 edx, DWORD PTR _lpw$[ebp]
  00023	52		 push	 edx
  00024	6a ff		 push	 -1
  00026	8b 45 0c	 mov	 eax, DWORD PTR _lpa$[ebp]
  00029	50		 push	 eax
  0002a	6a 00		 push	 0
  0002c	8b 4d 14	 mov	 ecx, DWORD PTR _acp$[ebp]
  0002f	51		 push	 ecx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00036	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 564  : 	if(ret == 0)

  00039	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0003d	75 04		 jne	 SHORT $L24308

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);
; 567  : 		return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	eb 03		 jmp	 SHORT $L24302
$L24308:

; 568  : 	}		
; 569  : 	return lpw;

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
$L24302:

; 570  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?CharUpperWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWFake
EXTRN	__imp__CharUpperW@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWThunk, COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharUpperW@4
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CharUpperWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharUpperWFake
  0000e	68 10 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 294  : 
; 295  : 	return _strthunks.pfnCharUpperW(psz);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 15 10 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16

; 296  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWThunk
_TEXT	ENDS
EXTRN	__imp__CharUpperA@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
__lpa$ = -20						; size = 4
__acp$ = -16						; size = 4
_pszA$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWFake, COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 281  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f0	 mov	 DWORD PTR __acp$[ebp], eax

; 282  : 	LPSTR pszA;
; 283  : 
; 284  : 	pszA = W2A(psz);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L207879
  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L207880
$L207879:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e4	 mov	 DWORD PTR tv75[ebp], esp
  00045	8b 45 f0	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$L207880:
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00060	89 4d f4	 mov	 DWORD PTR _pszA$[ebp], ecx

; 285  : 	::CharUpperA(pszA);

  00063	8b 55 f4	 mov	 edx, DWORD PTR _pszA$[ebp]
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharUpperA@4

; 286  : 	wcscpy(psz, A2W(pszA));

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _pszA$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR __lpa$[ebp], eax
  00073	83 7d ec 00	 cmp	 DWORD PTR __lpa$[ebp], 0
  00077	75 09		 jne	 SHORT $L207881
  00079	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00080	eb 3b		 jmp	 SHORT $L207882
$L207881:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00092	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00095	d1 e0		 shl	 eax, 1
  00097	83 c0 03	 add	 eax, 3
  0009a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0009d	e8 00 00 00 00	 call	 __alloca_probe
  000a2	89 65 dc	 mov	 DWORD PTR tv90[ebp], esp
  000a5	8b 55 f0	 mov	 edx, DWORD PTR __acp$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  000ba	89 45 e0	 mov	 DWORD PTR tv94[ebp], eax
$L207882:
  000bd	8b 45 e0	 mov	 eax, DWORD PTR tv94[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  000c4	51		 push	 ecx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000cb	83 c4 08	 add	 esp, 8

; 287  : 
; 288  : 	return psz;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]

; 289  : }

  000d1	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWFake
_TEXT	ENDS
PUBLIC	?OpenHomePage@CTabPageControl@@QAEXXZ		; CTabPageControl::OpenHomePage
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
EXTRN	?GetConfigStringValue@AfxUserConfig@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV23@@Z:NEAR ; AfxUserConfig::GetConfigStringValue
EXTRN	?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ:NEAR ; YL_StringUtil::Format
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
EXTRN	?AfxGetUserConfig@@YAPAVAfxUserConfig@@XZ:NEAR	; AfxGetUserConfig
xdata$x	SEGMENT
$T207897 DD	0ffffffffH
	DD	FLAT:$L207888
	DD	00H
	DD	FLAT:$L207889
	DD	01H
	DD	FLAT:$L207890
	DD	02H
	DD	FLAT:$L207891
	DD	03H
	DD	FLAT:$L207892
$T207894 DD	019930520H
	DD	05H
	DD	FLAT:$T207897
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabpagecontrol.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv155 = -240						; size = 4
tv149 = -236						; size = 4
tv79 = -232						; size = 4
tv73 = -228						; size = 4
_this$ = -224						; size = 4
$T207887 = -220						; size = 28
$T207886 = -192						; size = 28
_ti$205870 = -164					; size = 60
_strUrl$205872 = -104					; size = 28
_ti$ = -76						; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?OpenHomePage@CTabPageControl@@QAEXXZ PROC NEAR		; CTabPageControl::OpenHomePage
; _this$ = ecx

; 237  : {

  00920	55		 push	 ebp
  00921	8b ec		 mov	 ebp, esp
  00923	6a ff		 push	 -1
  00925	68 00 00 00 00	 push	 __ehhandler$?OpenHomePage@CTabPageControl@@QAEXXZ
  0092a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00930	50		 push	 eax
  00931	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00938	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  0093e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00943	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00946	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 238  : 	TAB_ITEM ti;

  0094c	8d 4d b4	 lea	 ecx, DWORD PTR _ti$[ebp]
  0094f	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@XZ
  00954	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 239  : 	ti.strName = "";

  0095b	68 00 00 00 00	 push	 OFFSET FLAT:$SG205867
  00960	8d 4d b4	 lea	 ecx, DWORD PTR _ti$[ebp]
  00963	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 240  : 	ti.strParam = "";

  00969	68 00 00 00 00	 push	 OFFSET FLAT:$SG205868
  0096e	8d 4d d4	 lea	 ecx, DWORD PTR _ti$[ebp+32]
  00971	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 241  : 	ti.eumType  = TAB_PLAYED_GAME;

  00977	c7 45 d0 04 00
	00 00		 mov	 DWORD PTR _ti$[ebp+28], 4

; 242  : 	GLOBAL_TABBARDATA->ITabBar_ChangeTab( ti );

  0097e	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  00983	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  00989	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_TABBAR
  0098e	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]
  00994	8b 10		 mov	 edx, DWORD PTR [eax]
  00996	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  0099c	ff 52 0c	 call	 DWORD PTR [edx+12]
  0099f	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  009a5	8d 45 b4	 lea	 eax, DWORD PTR _ti$[ebp]
  009a8	50		 push	 eax
  009a9	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv79[ebp]
  009af	8b 11		 mov	 edx, DWORD PTR [ecx]
  009b1	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv79[ebp]
  009b7	ff 52 0c	 call	 DWORD PTR [edx+12]

; 243  : 
; 244  : 	{
; 245  : 		TAB_ITEM ti;

  009ba	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _ti$205870[ebp]
  009c0	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@XZ
  009c5	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 246  : 		ti.strName = "";

  009c9	68 00 00 00 00	 push	 OFFSET FLAT:$SG205871
  009ce	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _ti$205870[ebp]
  009d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 247  : 		string strUrl;

  009da	8d 4d 98	 lea	 ecx, DWORD PTR _strUrl$205872[ebp]
  009dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  009e3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 248  : 		AfxGetUserConfig()->GetConfigStringValue( CONF_SETTING_MODULE_NAME,CONF_SETTING_CONFIG_HOME_PAGE,strUrl);

  009e7	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_SETTING_CONFIG_HOME_PAGE
  009ec	50		 push	 eax
  009ed	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T207886[ebp]
  009f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  009f9	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  009fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_SETTING_MODULE_NAME
  00a03	51		 push	 ecx
  00a04	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR $T207887[ebp]
  00a0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00a10	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00a14	8d 55 98	 lea	 edx, DWORD PTR _strUrl$205872[ebp]
  00a17	52		 push	 edx
  00a18	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR $T207886[ebp]
  00a1e	50		 push	 eax
  00a1f	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR $T207887[ebp]
  00a25	51		 push	 ecx
  00a26	e8 00 00 00 00	 call	 ?AfxGetUserConfig@@YAPAVAfxUserConfig@@XZ ; AfxGetUserConfig
  00a2b	8b c8		 mov	 ecx, eax
  00a2d	e8 00 00 00 00	 call	 ?GetConfigStringValue@AfxUserConfig@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV23@@Z ; AfxUserConfig::GetConfigStringValue
  00a32	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00a36	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR $T207887[ebp]
  00a3c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00a42	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00a46	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T207886[ebp]
  00a4c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 249  : 		if( strUrl.length() == 0 )

  00a52	8d 4d 98	 lea	 ecx, DWORD PTR _strUrl$205872[ebp]
  00a55	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00a5b	85 c0		 test	 eax, eax
  00a5d	75 16		 jne	 SHORT $L205875

; 250  : 		{
; 251  : 			YL_StringUtil::Format( strUrl, "%s", "http://box.7k7k.com/client/" );

  00a5f	68 00 00 00 00	 push	 OFFSET FLAT:$SG205876
  00a64	68 00 00 00 00	 push	 OFFSET FLAT:$SG205877
  00a69	8d 55 98	 lea	 edx, DWORD PTR _strUrl$205872[ebp]
  00a6c	52		 push	 edx
  00a6d	e8 00 00 00 00	 call	 ?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; YL_StringUtil::Format
  00a72	83 c4 0c	 add	 esp, 12			; 0000000cH
$L205875:

; 252  : 		}
; 253  : 		
; 254  : 		YL_StringUtil::Format( ti.strParam, "url=%s", strUrl.c_str() );

  00a75	8d 4d 98	 lea	 ecx, DWORD PTR _strUrl$205872[ebp]
  00a78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00a7e	50		 push	 eax
  00a7f	68 00 00 00 00	 push	 OFFSET FLAT:$SG205878
  00a84	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _ti$205870[ebp+32]
  00a8a	50		 push	 eax
  00a8b	e8 00 00 00 00	 call	 ?Format@YL_StringUtil@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; YL_StringUtil::Format
  00a90	83 c4 0c	 add	 esp, 12			; 0000000cH

; 255  : 		ti.eumType  = TAB_HOME;

  00a93	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ti$205870[ebp+28], 0

; 256  : 		GLOBAL_TABBARDATA->ITabBar_ChangeTab( ti );

  00a9d	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  00aa2	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv149[ebp], eax
  00aa8	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_TABBAR
  00aad	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR tv149[ebp]
  00ab3	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ab5	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR tv149[ebp]
  00abb	ff 52 0c	 call	 DWORD PTR [edx+12]
  00abe	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv155[ebp], eax
  00ac4	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _ti$205870[ebp]
  00aca	50		 push	 eax
  00acb	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv155[ebp]
  00ad1	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ad3	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv155[ebp]
  00ad9	ff 52 0c	 call	 DWORD PTR [edx+12]

; 257  : 	}

  00adc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00ae0	8d 4d 98	 lea	 ecx, DWORD PTR _strUrl$205872[ebp]
  00ae3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00ae9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00aed	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _ti$205870[ebp]
  00af3	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
  00af8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 258  : }

  00aff	8d 4d b4	 lea	 ecx, DWORD PTR _ti$[ebp]
  00b02	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
  00b07	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00b0a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00b11	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b14	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b19	8b e5		 mov	 esp, ebp
  00b1b	5d		 pop	 ebp
  00b1c	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L207888:
  000b2	8d 4d b4	 lea	 ecx, DWORD PTR _ti$[ebp]
  000b5	e9 00 00 00 00	 jmp	 ??1TAB_ITEM@@QAE@XZ
$L207889:
  000ba	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _ti$205870[ebp]
  000c0	e9 00 00 00 00	 jmp	 ??1TAB_ITEM@@QAE@XZ
$L207890:
  000c5	8d 4d 98	 lea	 ecx, DWORD PTR _strUrl$205872[ebp]
  000c8	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L207891:
  000ce	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T207886[ebp]
  000d4	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L207892:
  000da	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR $T207887[ebp]
  000e0	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?OpenHomePage@CTabPageControl@@QAEXXZ:
  000e6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207894
  000eb	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OpenHomePage@CTabPageControl@@QAEXXZ ENDP		; CTabPageControl::OpenHomePage
PUBLIC	?CallJS@CTabPageControl@@QAEXPAX@Z		; CTabPageControl::CallJS
EXTRN	?OnCallJavaScript@MyWebBrowserWnd@@QAEJIJ@Z:NEAR ; MyWebBrowserWnd::OnCallJavaScript
EXTRN	__imp__IsWindow@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T207900 = -16						; size = 4
$T207899 = -12						; size = 4
_pBrowser$205892 = -8					; size = 4
_it$205885 = -4						; size = 4
_lpVoid$ = 8						; size = 4
?CallJS@CTabPageControl@@QAEXPAX@Z PROC NEAR		; CTabPageControl::CallJS
; _this$ = ecx

; 261  : {

  00b20	55		 push	 ebp
  00b21	8b ec		 mov	 ebp, esp
  00b23	83 ec 14	 sub	 esp, 20			; 00000014H
  00b26	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 	for( vector<ONE_TAB>::iterator it = m_mapTab.begin();

  00b29	8d 45 fc	 lea	 eax, DWORD PTR _it$205885[ebp]
  00b2c	50		 push	 eax
  00b2d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b30	83 c1 04	 add	 ecx, 4
  00b33	e8 00 00 00 00	 call	 ?begin@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::begin

; 263  : 		it != m_mapTab.end(); it++ )

  00b38	eb 0e		 jmp	 SHORT $L205889
$L205890:
  00b3a	6a 00		 push	 0
  00b3c	8d 4d f4	 lea	 ecx, DWORD PTR $T207899[ebp]
  00b3f	51		 push	 ecx
  00b40	8d 4d fc	 lea	 ecx, DWORD PTR _it$205885[ebp]
  00b43	e8 00 00 00 00	 call	 ??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AV012@H@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator++
$L205889:
  00b48	8d 55 f0	 lea	 edx, DWORD PTR $T207900[ebp]
  00b4b	52		 push	 edx
  00b4c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b4f	83 c1 04	 add	 ecx, 4
  00b52	e8 00 00 00 00	 call	 ?end@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::end
  00b57	50		 push	 eax
  00b58	8d 4d fc	 lea	 ecx, DWORD PTR _it$205885[ebp]
  00b5b	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator!=
  00b60	0f b6 c0	 movzx	 eax, al
  00b63	85 c0		 test	 eax, eax
  00b65	74 37		 je	 SHORT $L205883

; 264  : 	{
; 265  : 		MyWebBrowserWnd * pBrowser = (MyWebBrowserWnd *)it->second;

  00b67	8d 4d fc	 lea	 ecx, DWORD PTR _it$205885[ebp]
  00b6a	e8 00 00 00 00	 call	 ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
  00b6f	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00b72	89 4d f8	 mov	 DWORD PTR _pBrowser$205892[ebp], ecx

; 266  : 		if (pBrowser != NULL && ::IsWindow (pBrowser->m_hWnd))

  00b75	83 7d f8 00	 cmp	 DWORD PTR _pBrowser$205892[ebp], 0
  00b79	74 21		 je	 SHORT $L205894
  00b7b	8b 55 f8	 mov	 edx, DWORD PTR _pBrowser$205892[ebp]
  00b7e	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00b81	50		 push	 eax
  00b82	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsWindow@4
  00b88	85 c0		 test	 eax, eax
  00b8a	74 10		 je	 SHORT $L205894

; 267  : 		{
; 268  : 			pBrowser->OnCallJavaScript ((WPARAM)pBrowser, (LPARAM)lpVoid);

  00b8c	8b 4d 08	 mov	 ecx, DWORD PTR _lpVoid$[ebp]
  00b8f	51		 push	 ecx
  00b90	8b 55 f8	 mov	 edx, DWORD PTR _pBrowser$205892[ebp]
  00b93	52		 push	 edx
  00b94	8b 4d f8	 mov	 ecx, DWORD PTR _pBrowser$205892[ebp]
  00b97	e8 00 00 00 00	 call	 ?OnCallJavaScript@MyWebBrowserWnd@@QAEJIJ@Z ; MyWebBrowserWnd::OnCallJavaScript
$L205894:

; 269  : 		}
; 270  : 	}

  00b9c	eb 9c		 jmp	 SHORT $L205890
$L205883:

; 271  : }

  00b9e	8b e5		 mov	 esp, ebp
  00ba0	5d		 pop	 ebp
  00ba1	c2 04 00	 ret	 4
?CallJS@CTabPageControl@@QAEXPAX@Z ENDP			; CTabPageControl::CallJS
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Buy
PUBLIC	??0?$_Vector_val@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@1@@Z ; std::_Vector_val<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Vector_val<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
PUBLIC	??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocator<std::pair<TAB_ITEM,CWnd *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	51		 push	 ecx
  0000a	8b cc		 mov	 ecx, esp
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocator<std::pair<TAB_ITEM,CWnd *> >
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@1@@Z ; std::_Vector_val<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Vector_val<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >

; 300  : 		_Buy(0);

  00019	6a 00		 push	 0
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Buy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Buy

; 301  : 		}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Tidy
; Function compile flags: /Odt
;	COMDAT ??1?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::~vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Tidy

; 389  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::~vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::iterator
; Function compile flags: /Odt
;	COMDAT ?begin@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?begin@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::begin
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?end@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::iterator
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?end@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::end
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L207911
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 12		 jmp	 SHORT $L207912
$L207911:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	c1 f8 06	 sar	 eax, 6
  0002a	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L207912:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::size
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@PAU32@IABU32@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ufill
PUBLIC	?capacity@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::capacity
PUBLIC	?insert@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@ABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::insert
; Function compile flags: /Odt
;	COMDAT ?push_back@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEXABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T207916 = -8						; size = 4
$T207915 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEXABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0000a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::size
  00012	8b f0		 mov	 esi, eax
  00014	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?capacity@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::capacity
  0001c	3b f0		 cmp	 esi, eax
  0001e	73 1d		 jae	 SHORT $L206027

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	50		 push	 eax
  00024	6a 01		 push	 1
  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	52		 push	 edx
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Ufill@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@PAU32@IABU32@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ufill
  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  0003b	eb 1f		 jmp	 SHORT $L206026
$L206027:

; 583  : 			insert(end(), _Val);

  0003d	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00040	52		 push	 edx
  00041	8d 45 fc	 lea	 eax, DWORD PTR $T207915[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?end@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::end
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	51		 push	 ecx
  00050	8d 55 f8	 lea	 edx, DWORD PTR $T207916[ebp]
  00053	52		 push	 edx
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?insert@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@ABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::insert
$L206026:

; 584  : 		}

  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?push_back@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEXABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::push_back
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@0@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Destroy
PUBLIC	??$copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z ; std::copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
; Function compile flags: /Odt
;	COMDAT ?erase@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::erase, COMDAT
; _this$ = ecx

; 723  : 		{	// erase element at where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 724  : 		copy(_ITER_BASE(_Where) + 1, _Mylast, _ITER_BASE(_Where));

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00011	52		 push	 edx
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00015	83 c0 40	 add	 eax, 64			; 00000040H
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z ; std::copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  : 		_Destroy(_Mylast - 1, _Mylast);

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00027	52		 push	 edx
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002e	83 e9 40	 sub	 ecx, 64			; 00000040H
  00031	51		 push	 ecx
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@0@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Destroy

; 726  : 		--_Mylast;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00040	83 e8 40	 sub	 eax, 64			; 00000040H
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 727  : 		return (_Where);

  00049	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0004c	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0004f	89 02		 mov	 DWORD PTR [edx], eax
  00051	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 728  : 		}

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?erase@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::erase
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ PROC NEAR	; std::pair<TAB_ITEM,CWnd *>::pair<TAB_ITEM,CWnd *>, COMDAT
; _this$ = ecx

; 29   : 		{	// construct from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 30   : 		}

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ ENDP		; std::pair<TAB_ITEM,CWnd *>::pair<TAB_ITEM,CWnd *>
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEAAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator*
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->, COMDAT
; _this$ = ecx

; 224  : 			{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 225  : 			return (&**this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Diterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEAAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator*

; 226  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Citerator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator++
; Function compile flags: /Odt
;	COMDAT ??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AV012@H@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 236  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 237  : 			++*this;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator++

; 238  : 			return (_Tmp);

  00019	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 239  : 			}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AV012@H@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator==
; Function compile flags: /Odt
;	COMDAT ??9const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 159  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : 			return (!(*this == _Right));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator==
  00013	0f b6 c0	 movzx	 eax, al
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 161  : 			}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??9const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator!=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $L207930
  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00019	eb 12		 jmp	 SHORT $L207931
$L207930:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00027	c1 f8 06	 sar	 eax, 6
  0002a	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L207931:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?capacity@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::capacity
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXViterator@12@IABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Insert_n
PUBLIC	??Hiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE?AV012@H@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator+
PUBLIC	??Giterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator-
; Function compile flags: /Odt
;	COMDAT ?insert@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@ABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
_this$ = -16						; size = 4
$T207937 = -12						; size = 4
$T207934 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@ABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::size
  00011	85 c0		 test	 eax, eax
  00013	75 09		 jne	 SHORT $L207935
  00015	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0001c	eb 18		 jmp	 SHORT $L207936
$L207935:
  0001e	8d 45 f8	 lea	 eax, DWORD PTR $T207934[ebp]
  00021	50		 push	 eax
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?begin@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::begin
  0002a	50		 push	 eax
  0002b	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002e	e8 00 00 00 00	 call	 ??Giterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator-
  00033	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$L207936:
  00036	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00039	89 4d fc	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0003c	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0003f	52		 push	 edx
  00040	6a 01		 push	 1
  00042	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00045	50		 push	 eax
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXViterator@12@IABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Insert_n

; 623  : 		return (begin() + _Off);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Off$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	52		 push	 edx
  00056	8d 45 f4	 lea	 eax, DWORD PTR $T207937[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?begin@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::begin
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ??Hiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE?AV012@H@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator+
  00069	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE?AViterator@12@V312@ABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::insert
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IBEXXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Xlen
PUBLIC	?allocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocate
PUBLIC	?max_size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::max_size
; Function compile flags: /Odt
;	COMDAT ?_Buy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE_NI@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00029	75 04		 jne	 SHORT $L206116

; 773  : 			return (false);

  0002b	32 c0		 xor	 al, al
  0002d	eb 49		 jmp	 SHORT $L206115
$L206116:

; 774  : 		else if (max_size() < _Capacity)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003a	73 0a		 jae	 SHORT $L206118

; 775  : 			_Xlen();	// result too long

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IBEXXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Xlen

; 776  : 		else

  00044	eb 30		 jmp	 SHORT $L206117
$L206118:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocate
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00064	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00067	c1 e2 06	 shl	 edx, 6
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L206117:

; 781  : 			}
; 782  : 		return (true);

  00076	b0 01		 mov	 al, 1
$L206115:

; 783  : 		}

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Buy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z ; std::_Destroy_range<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
; Function compile flags: /Odt
;	COMDAT ?_Destroy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@0@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z ; std::_Destroy_range<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?_Destroy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@0@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Destroy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::deallocate
; Function compile flags: /Odt
;	COMDAT ?_Tidy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXXZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 35		 je	 SHORT $L206131

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@0@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0002f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00032	c1 f9 06	 sar	 ecx, 6
  00035	51		 push	 ecx
  00036	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00039	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003c	50		 push	 eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::deallocate
$L206131:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?_Tidy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::pair<TAB_ITEM,CWnd *> *,unsigned int,std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
; Function compile flags: /Odt
;	COMDAT ?_Ufill@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@PAU32@IABU32@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@PAU32@IABU32@@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::pair<TAB_ITEM,CWnd *> *,unsigned int,std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	c1 e0 06	 shl	 eax, 6
  00025	03 45 08	 add	 eax, DWORD PTR __Ptr$[ebp]

; 880  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@PAU32@IABU32@@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocator<std::pair<TAB_ITEM,CWnd *> >
; Function compile flags: /Odt
;	COMDAT ??0?$_Vector_val@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@1@@Z PROC NEAR ; std::_Vector_val<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Vector_val<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocator<std::pair<TAB_ITEM,CWnd *> >

; 22   : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_val@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAE@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@1@@Z ENDP ; std::_Vector_val<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Vector_val<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocator<std::pair<TAB_ITEM,CWnd *> >, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocator<std::pair<TAB_ITEM,CWnd *> >
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::const_iterator
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::const_iterator

; 216  : 			}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator*
; Function compile flags: /Odt
;	COMDAT ??Diterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEAAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEAAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator*

; 221  : 			}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Diterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEAAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 			++this->_Myptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	83 c1 40	 add	 ecx, 64			; 00000040H
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 232  : 			}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??Eiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator++
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 152  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 156  : 			}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??8const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::max_size
; Function compile flags: /Odt
;	COMDAT ?max_size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::max_size

; 522  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::max_size
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@1@PAU21@00@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ucopy<std::pair<TAB_ITEM,CWnd *> *>
PUBLIC	??$fill@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0ABU10@@Z ; std::fill<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> >
PUBLIC	??$copy_backward@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z ; std::copy_backward<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
PUBLIC	??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@ABU01@@Z ; std::pair<TAB_ITEM,CWnd *>::pair<TAB_ITEM,CWnd *>
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T207975 DD	0ffffffffH
	DD	FLAT:$L207970
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T207977 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L207967
$T207978 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L207969
$T207976 DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T207977
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T207978
$T207972 DD	019930520H
	DD	05H
	DD	FLAT:$T207975
	DD	02H
	DD	FLAT:$T207976
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXViterator@12@IABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT
tv244 = -120						; size = 4
tv65 = -116						; size = 4
tv89 = -112						; size = 4
_this$ = -108						; size = 4
__Oldend$206246 = -104					; size = 4
__Newvec$206225 = -100					; size = 4
__Ptr$206226 = -96					; size = 4
__Capacity$ = -92					; size = 4
__Tmp$ = -88						; size = 64
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXViterator@12@IABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXViterator@12@IABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 68	 sub	 esp, 104		; 00000068H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00024	53		 push	 ebx
  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002a	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0002d	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00030	50		 push	 eax
  00031	8d 4d a8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00034	e8 00 00 00 00	 call	 ??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@ABU01@@Z
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 811  : 		size_type _Capacity = capacity();

  00040	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?capacity@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::capacity
  00048	89 45 a4	 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  0004b	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0004f	75 05		 jne	 SHORT $L206219

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00051	e9 c0 02 00 00	 jmp	 $L206220
$L206219:
  00056	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::size
  0005e	8b f0		 mov	 esi, eax
  00060	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?max_size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::max_size
  00068	2b c6		 sub	 eax, esi
  0006a	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0006d	73 0d		 jae	 SHORT $L206221

; 816  : 			_Xlen();	// result too long

  0006f	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IBEXXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  00077	e9 9a 02 00 00	 jmp	 $L206220
$L206221:
  0007c	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::size
  00084	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00087	39 45 a4	 cmp	 DWORD PTR __Capacity$[ebp], eax
  0008a	0f 83 63 01 00
	00		 jae	 $L206223

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00090	8b 75 a4	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00093	d1 ee		 shr	 esi, 1
  00095	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?max_size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::max_size
  0009d	2b c6		 sub	 eax, esi
  0009f	3b 45 a4	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  000a2	73 09		 jae	 SHORT $L207963
  000a4	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  000ab	eb 0b		 jmp	 SHORT $L207964
$L207963:
  000ad	8b 4d a4	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  000b0	d1 e9		 shr	 ecx, 1
  000b2	03 4d a4	 add	 ecx, DWORD PTR __Capacity$[ebp]
  000b5	89 4d 90	 mov	 DWORD PTR tv89[ebp], ecx
$L207964:
  000b8	8b 55 90	 mov	 edx, DWORD PTR tv89[ebp]
  000bb	89 55 a4	 mov	 DWORD PTR __Capacity$[ebp], edx

; 821  : 			if (_Capacity < size() + _Count)

  000be	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::size
  000c6	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000c9	39 45 a4	 cmp	 DWORD PTR __Capacity$[ebp], eax
  000cc	73 0e		 jae	 SHORT $L206224

; 822  : 				_Capacity = size() + _Count;

  000ce	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::size
  000d6	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000d9	89 45 a4	 mov	 DWORD PTR __Capacity$[ebp], eax
$L206224:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000dc	8b 45 a4	 mov	 eax, DWORD PTR __Capacity$[ebp]
  000df	50		 push	 eax
  000e0	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocate
  000e8	89 45 9c	 mov	 DWORD PTR __Newvec$206225[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  000eb	8b 4d 9c	 mov	 ecx, DWORD PTR __Newvec$206225[ebp]
  000ee	89 4d a0	 mov	 DWORD PTR __Ptr$206226[ebp], ecx

; 825  : 
; 826  : 			_TRY_BEGIN

  000f1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000f5	8b 55 9c	 mov	 edx, DWORD PTR __Newvec$206225[ebp]
  000f8	52		 push	 edx
  000f9	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00103	52		 push	 edx
  00104	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ??$_Ucopy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@1@PAU21@00@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ucopy<std::pair<TAB_ITEM,CWnd *> *>
  0010c	89 45 8c	 mov	 DWORD PTR tv65[ebp], eax
  0010f	8b 45 8c	 mov	 eax, DWORD PTR tv65[ebp]
  00112	89 45 a0	 mov	 DWORD PTR __Ptr$206226[ebp], eax

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00115	8d 4d a8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00118	51		 push	 ecx
  00119	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0011c	52		 push	 edx
  0011d	8b 45 a0	 mov	 eax, DWORD PTR __Ptr$206226[ebp]
  00120	50		 push	 eax
  00121	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	e8 00 00 00 00	 call	 ?_Ufill@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@PAU32@IABU32@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ufill
  00129	89 45 88	 mov	 DWORD PTR tv244[ebp], eax
  0012c	8b 4d 88	 mov	 ecx, DWORD PTR tv244[ebp]
  0012f	89 4d a0	 mov	 DWORD PTR __Ptr$206226[ebp], ecx

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00132	8b 55 a0	 mov	 edx, DWORD PTR __Ptr$206226[ebp]
  00135	52		 push	 edx
  00136	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00139	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0013c	51		 push	 ecx
  0013d	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00140	52		 push	 edx
  00141	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	e8 00 00 00 00	 call	 ??$_Ucopy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@1@PAU21@00@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ucopy<std::pair<TAB_ITEM,CWnd *> *>
  00149	eb 29		 jmp	 SHORT $L207966
$L207967:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  0014b	8b 45 a0	 mov	 eax, DWORD PTR __Ptr$206226[ebp]
  0014e	50		 push	 eax
  0014f	8b 4d 9c	 mov	 ecx, DWORD PTR __Newvec$206225[ebp]
  00152	51		 push	 ecx
  00153	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@0@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  0015b	8b 55 a4	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0015e	52		 push	 edx
  0015f	8b 45 9c	 mov	 eax, DWORD PTR __Newvec$206225[ebp]
  00162	50		 push	 eax
  00163	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::deallocate

; 834  : 			_RERAISE;

  0016b	6a 00		 push	 0
  0016d	6a 00		 push	 0
  0016f	e8 00 00 00 00	 call	 __CxxThrowException@8
$L207966:

; 835  : 			_CATCH_END

  00174	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 836  : 
; 837  : 			_Count += size();

  0017b	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::size
  00183	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00186	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  00189	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00190	74 35		 je	 SHORT $L206233

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  00192	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00195	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00198	50		 push	 eax
  00199	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0019c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0019f	52		 push	 edx
  001a0	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@0@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  001a8	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  001ab	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  001ae	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  001b1	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  001b4	c1 fa 06	 sar	 edx, 6
  001b7	52		 push	 edx
  001b8	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  001bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001be	51		 push	 ecx
  001bf	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  001c2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::deallocate
$L206233:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001c7	8b 55 a4	 mov	 edx, DWORD PTR __Capacity$[ebp]
  001ca	c1 e2 06	 shl	 edx, 6
  001cd	03 55 9c	 add	 edx, DWORD PTR __Newvec$206225[ebp]
  001d0	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  001d3	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 844  : 			_Mylast = _Newvec + _Count;

  001d6	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  001d9	c1 e1 06	 shl	 ecx, 6
  001dc	03 4d 9c	 add	 ecx, DWORD PTR __Newvec$206225[ebp]
  001df	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  001e2	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 845  : 			_Myfirst = _Newvec;

  001e5	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  001e8	8b 4d 9c	 mov	 ecx, DWORD PTR __Newvec$206225[ebp]
  001eb	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001ee	e9 23 01 00 00	 jmp	 $L206220
$L206223:
  001f3	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  001f6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001f9	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  001fc	c1 f8 06	 sar	 eax, 6
  001ff	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  00202	0f 83 aa 00 00
	00		 jae	 $L206236

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00208	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0020b	c1 e1 06	 shl	 ecx, 6
  0020e	03 4d 08	 add	 ecx, DWORD PTR __Where$[ebp]
  00211	51		 push	 ecx
  00212	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00215	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00218	50		 push	 eax
  00219	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  0021c	51		 push	 ecx
  0021d	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00220	e8 00 00 00 00	 call	 ??$_Ucopy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@1@PAU21@00@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ucopy<std::pair<TAB_ITEM,CWnd *> *>

; 851  : 
; 852  : 			_TRY_BEGIN

  00225	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  00229	8d 55 a8	 lea	 edx, DWORD PTR __Tmp$[ebp]
  0022c	52		 push	 edx
  0022d	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00230	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00233	2b 4d 08	 sub	 ecx, DWORD PTR __Where$[ebp]
  00236	c1 f9 06	 sar	 ecx, 6
  00239	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0023c	2b d1		 sub	 edx, ecx
  0023e	52		 push	 edx
  0023f	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00242	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00245	51		 push	 ecx
  00246	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00249	e8 00 00 00 00	 call	 ?_Ufill@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@PAU32@IABU32@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ufill
  0024e	eb 28		 jmp	 SHORT $L207968
$L207969:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  00250	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00253	c1 e2 06	 shl	 edx, 6
  00256	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00259	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0025c	52		 push	 edx
  0025d	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00260	c1 e1 06	 shl	 ecx, 6
  00263	03 4d 08	 add	 ecx, DWORD PTR __Where$[ebp]
  00266	51		 push	 ecx
  00267	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0026a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@0@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Destroy

; 857  : 			_RERAISE;

  0026f	6a 00		 push	 0
  00271	6a 00		 push	 0
  00273	e8 00 00 00 00	 call	 __CxxThrowException@8
$L207968:

; 858  : 			_CATCH_END

  00278	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 859  : 
; 860  : 			_Mylast += _Count;

  0027f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00282	c1 e2 06	 shl	 edx, 6
  00285	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00288	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0028b	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0028e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00291	8d 55 a8	 lea	 edx, DWORD PTR __Tmp$[ebp]
  00294	52		 push	 edx
  00295	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00298	c1 e0 06	 shl	 eax, 6
  0029b	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0029e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002a1	2b d0		 sub	 edx, eax
  002a3	52		 push	 edx
  002a4	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  002a7	50		 push	 eax
  002a8	e8 00 00 00 00	 call	 ??$fill@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0ABU10@@Z ; std::fill<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> >
  002ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002b0	eb 64		 jmp	 SHORT $L206220
$L206236:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  002b2	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  002b5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002b8	89 55 98	 mov	 DWORD PTR __Oldend$206246[ebp], edx

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002bb	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  002be	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002c1	51		 push	 ecx
  002c2	8b 55 98	 mov	 edx, DWORD PTR __Oldend$206246[ebp]
  002c5	52		 push	 edx
  002c6	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002c9	c1 e0 06	 shl	 eax, 6
  002cc	8b 4d 98	 mov	 ecx, DWORD PTR __Oldend$206246[ebp]
  002cf	2b c8		 sub	 ecx, eax
  002d1	51		 push	 ecx
  002d2	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  002d5	e8 00 00 00 00	 call	 ??$_Ucopy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@1@PAU21@00@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ucopy<std::pair<TAB_ITEM,CWnd *> *>
  002da	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  002dd	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  002e0	8b 45 98	 mov	 eax, DWORD PTR __Oldend$206246[ebp]
  002e3	50		 push	 eax
  002e4	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002e7	c1 e1 06	 shl	 ecx, 6
  002ea	8b 55 98	 mov	 edx, DWORD PTR __Oldend$206246[ebp]
  002ed	2b d1		 sub	 edx, ecx
  002ef	52		 push	 edx
  002f0	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  002f3	50		 push	 eax
  002f4	e8 00 00 00 00	 call	 ??$copy_backward@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z ; std::copy_backward<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
  002f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  002fc	8d 4d a8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  002ff	51		 push	 ecx
  00300	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00303	c1 e2 06	 shl	 edx, 6
  00306	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  00309	52		 push	 edx
  0030a	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0030d	50		 push	 eax
  0030e	e8 00 00 00 00	 call	 ??$fill@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0ABU10@@Z ; std::fill<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> >
  00313	83 c4 0c	 add	 esp, 12			; 0000000cH
$L206220:

; 873  : 			}
; 874  : 		}

  00316	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0031d	8d 4d a8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00320	e8 00 00 00 00	 call	 ??1?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ
$L207962:
  00325	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00328	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0032f	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00332	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00337	5f		 pop	 edi
  00338	5e		 pop	 esi
  00339	5b		 pop	 ebx
  0033a	8b e5		 mov	 esp, ebp
  0033c	5d		 pop	 ebp
  0033d	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L207970:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXViterator@12@IABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207972
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEXViterator@12@IABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Insert_n
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
;	COMDAT xdata$x
xdata$x	SEGMENT
$T207989 DD	0ffffffffH
	DD	FLAT:$L207985
$T207987 DD	019930520H
	DD	01H
	DD	FLAT:$T207989
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
	ORG $-30
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T207984 = -80						; size = 28
$T207983 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IBEXXZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00023	8d 4d b0	 lea	 ecx, DWORD PTR $T207984[ebp]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8d 45 b0	 lea	 eax, DWORD PTR $T207984[ebp]
  00036	50		 push	 eax
  00037	8d 4d cc	 lea	 ecx, DWORD PTR $T207983[ebp]
  0003a	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00044	8d 4d cc	 lea	 ecx, DWORD PTR $T207983[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$L207982:

; 885  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L207985:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T207984[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IBEXXZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207987
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Xlen
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocator<std::pair<TAB_ITEM,CWnd *> >, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocator<std::pair<TAB_ITEM,CWnd *> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z PROC NEAR ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4

; 133  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z ENDP ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IPAU10@@Z ; std::_Allocate<std::pair<TAB_ITEM,CWnd *> >
; Function compile flags: /Odt
;	COMDAT ?allocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z PROC NEAR ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IPAU10@@Z ; std::_Allocate<std::pair<TAB_ITEM,CWnd *> >
  00012	83 c4 08	 add	 esp, 8

; 138  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@I@Z ENDP ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::allocate
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@H@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator+=
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Hiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Yiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@H@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator+=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??Hiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBE?AV012@H@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABV012@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator-
; Function compile flags: /Odt
;	COMDAT ??Giterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T208002 = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR $T208002[ebp], ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR $T208002[ebp]
  00018	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABV012@@Z ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator-

; 280  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??Giterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator-
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0const_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAE@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::const_iterator
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??Dconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEABU?$pair@UTAB_ITEM@@PAVCWnd@@@2@XZ ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator*
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@ABU01@@Z PROC NEAR ; std::pair<TAB_ITEM,CWnd *>::pair<TAB_ITEM,CWnd *>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@ABU0@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00019	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0001c	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@ABU01@@Z ENDP	; std::pair<TAB_ITEM,CWnd *>::pair<TAB_ITEM,CWnd *>
_TEXT	ENDS
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  00009	c7 45 fc ff ff
	ff 03		 mov	 DWORD PTR __Count$[ebp], 67108863 ; 03ffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

  00010	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	76 08		 jbe	 SHORT $L208015
  00016	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	eb 07		 jmp	 SHORT $L208016
$L208015:
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L208016:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?max_size@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::max_size
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	c1 e0 06	 shl	 eax, 6
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 01		 add	 eax, DWORD PTR [ecx]
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	89 02		 mov	 DWORD PTR [edx], eax

; 257  : 			return (*this);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??Yiterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QAEAAV012@H@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::iterator::operator+=
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00011	c1 f8 06	 sar	 eax, 6

; 144  : 			}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@QBEHABV012@@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0@Z ; std::_Ptr_cat<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
PUBLIC	??$_Copy_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z
_TEXT	SEGMENT
$T208023 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z PROC NEAR ; std::copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>, COMDAT

; 1039 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0@Z ; std::_Ptr_cat<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T208023[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T208023[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1041 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z ENDP ; std::copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z
_TEXT	SEGMENT
$T208026 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z PROC NEAR ; std::_Destroy_range<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0@Z ; std::_Ptr_cat<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T208026[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T208026[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<TAB_ITEM,CWnd *> *,unsigned int,std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z
_TEXT	SEGMENT
$T208029 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<std::pair<TAB_ITEM,CWnd *> *,unsigned int,std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00004	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0@Z ; std::_Ptr_cat<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T208029[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T208029[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<TAB_ITEM,CWnd *> *,unsigned int,std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<std::pair<TAB_ITEM,CWnd *> *,unsigned int,std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z ; std::_Uninitialized_copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@1@PAU21@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@1@PAU21@00@Z PROC NEAR ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ucopy<std::pair<TAB_ITEM,CWnd *> *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z ; std::_Uninitialized_copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@?$vector@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@IAEPAU?$pair@UTAB_ITEM@@PAVCWnd@@@1@PAU21@00@Z ENDP ; std::vector<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >::_Ucopy<std::pair<TAB_ITEM,CWnd *> *>
_TEXT	ENDS
PUBLIC	??4?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEAAU01@ABU01@@Z ; std::pair<TAB_ITEM,CWnd *>::operator=
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0ABU10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0ABU10@@Z PROC NEAR ; std::fill<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> >, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1135 : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L206503
$L206504:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 40	 add	 eax, 64			; 00000040H
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L206503:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L206502

; 1136 : 		*_First = _Val;

  00016	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001d	e8 00 00 00 00	 call	 ??4?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEAAU01@ABU01@@Z
  00022	eb e1		 jmp	 SHORT $L206504
$L206502:

; 1137 : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$fill@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0ABU10@@Z ENDP ; std::fill<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
; Function compile flags: /Odt
;	COMDAT ??$copy_backward@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z
_TEXT	SEGMENT
$T208036 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z PROC NEAR ; std::copy_backward<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0@Z ; std::_Ptr_cat<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T208036[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T208036[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$copy_backward@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00@Z ENDP ; std::copy_backward<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IPAU10@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IPAU10@@Z PROC NEAR ; std::_Allocate<std::pair<TAB_ITEM,CWnd *> >, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 06	 shl	 eax, 6
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Allocate@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<TAB_ITEM,CWnd *> >
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??4?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEAAU01@ABU01@@Z PROC NEAR ; std::pair<TAB_ITEM,CWnd *>::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00019	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0001c	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??4?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEAAU01@ABU01@@Z ENDP ; std::pair<TAB_ITEM,CWnd *>::operator=
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0@Z PROC NEAR ; std::_Ptr_cat<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0@Z ENDP ; std::_Ptr_cat<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>, COMDAT

; 1020 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1021 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	eb 12		 jmp	 SHORT $L206645
$L206646:
  00005	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00008	83 c0 40	 add	 eax, 64			; 00000040H
  0000b	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	83 c1 40	 add	 ecx, 64			; 00000040H
  00014	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$L206645:
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	3b 55 0c	 cmp	 edx, DWORD PTR __Last$[ebp]
  0001d	74 0e		 je	 SHORT $L206647

; 1022 : 		*_Dest = *_First;

  0001f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00026	e8 00 00 00 00	 call	 ??4?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEAAU01@ABU01@@Z
  0002b	eb d8		 jmp	 SHORT $L206646
$L206647:

; 1023 : 	return (_Dest);

  0002d	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1024 : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$_Copy_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::destroy
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L206649
$L206650:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 40	 add	 eax, 64			; 00000040H
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L206649:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L206648

; 226  : 		_Al.destroy(_First);

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001d	e8 00 00 00 00	 call	 ?destroy@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::destroy
  00022	eb e1		 jmp	 SHORT $L206650
$L206648:

; 227  : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Destroy_range@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@ABU32@@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T208054 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T208056 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L208050
$T208055 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T208056
$T208052 DD	019930520H
	DD	02H
	DD	FLAT:$T208054
	DD	01H
	DD	FLAT:$T208055
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<std::pair<TAB_ITEM,CWnd *> *,unsigned int,std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >, COMDAT

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 208  : 	_FwdIt _Next = _First;

  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 209  : 
; 210  : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  0002d	eb 12		 jmp	 SHORT $L206655
$L206656:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00032	83 e9 01	 sub	 ecx, 1
  00035	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 40	 add	 edx, 64			; 00000040H
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L206655:
  00041	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00045	76 12		 jbe	 SHORT $L206657

; 212  : 		_Al.construct(_First, _Val);

  00047	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00052	e8 00 00 00 00	 call	 ?construct@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@ABU32@@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::construct
  00057	eb d6		 jmp	 SHORT $L206656
$L206657:
  00059	eb 2a		 jmp	 SHORT $L208049
$L208050:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

  0005b	eb 09		 jmp	 SHORT $L206658
$L206659:
  0005d	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00060	83 c2 40	 add	 edx, 64			; 00000040H
  00063	89 55 ec	 mov	 DWORD PTR __Next$[ebp], edx
$L206658:
  00066	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00069	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  0006c	74 0e		 je	 SHORT $L206660

; 215  : 		_Al.destroy(_Next);

  0006e	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00071	51		 push	 ecx
  00072	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00075	e8 00 00 00 00	 call	 ?destroy@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::destroy
  0007a	eb e1		 jmp	 SHORT $L206659
$L206660:

; 216  : 	_RERAISE;

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	e8 00 00 00 00	 call	 __CxxThrowException@8
$L208049:

; 217  : 	_CATCH_END

  00085	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$L208048:

; 218  : 	}

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T208052
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@IU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@IABU10@AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::pair<TAB_ITEM,CWnd *> *,unsigned int,std::pair<TAB_ITEM,CWnd *>,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
PUBLIC	??$_Uninit_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
; Function compile flags: /Odt
;	COMDAT ??$_Uninitialized_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z
_TEXT	SEGMENT
$T208061 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *,std::allocator<std::pair<TAB_ITEM,CWnd *> > >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@0@Z ; std::_Ptr_cat<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T208061[ebp], al
  00017	8a 55 ff	 mov	 dl, BYTE PTR $T208061[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>, COMDAT

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L206703:

; 1049 : 	while (_First != _Last)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00009	74 20		 je	 SHORT $L206704

; 1050 : 		*--_Dest = *--_Last;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	83 e9 40	 sub	 ecx, 64			; 00000040H
  00011	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  00014	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00017	83 ea 40	 sub	 edx, 64			; 00000040H
  0001a	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0001d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00024	e8 00 00 00 00	 call	 ??4?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEAAU01@ABU01@@Z
  00029	eb d8		 jmp	 SHORT $L206703
$L206704:

; 1051 : 	return (_Dest);

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1052 : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Copy_backward_opt@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *>
_TEXT	ENDS
PUBLIC	??$_Construct@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@ABU10@@Z ; std::_Construct<std::pair<TAB_ITEM,CWnd *>,std::pair<TAB_ITEM,CWnd *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@ABU32@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@ABU32@@Z PROC NEAR ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Construct@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@ABU10@@Z ; std::_Construct<std::pair<TAB_ITEM,CWnd *>,std::pair<TAB_ITEM,CWnd *> >
  00014	83 c4 08	 add	 esp, 8

; 148  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@ABU32@@Z ENDP ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@@Z ; std::_Destroy<std::pair<TAB_ITEM,CWnd *> >
; Function compile flags: /Odt
;	COMDAT ?destroy@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z PROC NEAR ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@@Z ; std::_Destroy<std::pair<TAB_ITEM,CWnd *> >
  00010	83 c4 04	 add	 esp, 4

; 153  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ENDP ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::destroy
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T208075 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T208077 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L208071
$T208076 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T208077
$T208073 DD	019930520H
	DD	02H
	DD	FLAT:$T208075
	DD	01H
	DD	FLAT:$T208076
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *,std::allocator<std::pair<TAB_ITEM,CWnd *> > >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 78   : 	_FwdIt _Next = _Dest;

  00020	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 79   : 
; 80   : 	_TRY_BEGIN

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  0002d	eb 12		 jmp	 SHORT $L206722
$L206723:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	83 c1 40	 add	 ecx, 64			; 00000040H
  00035	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003b	83 c2 40	 add	 edx, 64			; 00000040H
  0003e	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L206722:
  00041	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00044	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00047	74 12		 je	 SHORT $L206724

; 82   : 		_Al.construct(_Dest, *_First);

  00049	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00050	52		 push	 edx
  00051	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00054	e8 00 00 00 00	 call	 ?construct@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@ABU32@@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::construct
  00059	eb d4		 jmp	 SHORT $L206723
$L206724:
  0005b	eb 2a		 jmp	 SHORT $L208070
$L208071:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  0005d	eb 09		 jmp	 SHORT $L206725
$L206726:
  0005f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00062	83 c0 40	 add	 eax, 64			; 00000040H
  00065	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$L206725:
  00068	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  0006b	3b 4d 10	 cmp	 ecx, DWORD PTR __Dest$[ebp]
  0006e	74 0e		 je	 SHORT $L206727

; 85   : 		_Al.destroy(_Next);

  00070	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00073	52		 push	 edx
  00074	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00077	e8 00 00 00 00	 call	 ?destroy@?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@QAEXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@2@@Z ; std::allocator<std::pair<TAB_ITEM,CWnd *> >::destroy
  0007c	eb e1		 jmp	 SHORT $L206726
$L206727:

; 86   : 	_RERAISE;

  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	e8 00 00 00 00	 call	 __CxxThrowException@8
$L208070:

; 87   : 	_CATCH_END

  00087	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 88   : 	return (_Dest);

  0008e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$L208069:

; 89   : 	}

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T208073
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAU?$pair@UTAB_ITEM@@PAVCWnd@@@std@@PAU12@V?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@2@@std@@YAPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@PAU10@00AAV?$allocator@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<TAB_ITEM,CWnd *> *,std::pair<TAB_ITEM,CWnd *> *,std::allocator<std::pair<TAB_ITEM,CWnd *> > >
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T208090 DD	0ffffffffH
	DD	FLAT:$L208086
$T208088 DD	019930520H
	DD	01H
	DD	FLAT:$T208090
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$_Construct@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@ABU10@@Z
_TEXT	SEGMENT
tv74 = -24						; size = 4
$T208083 = -20						; size = 4
$T208082 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@ABU10@@Z PROC NEAR ; std::_Construct<std::pair<TAB_ITEM,CWnd *>,std::pair<TAB_ITEM,CWnd *> >, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@ABU10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001e	50		 push	 eax
  0001f	6a 40		 push	 64			; 00000040H
  00021	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00026	83 c4 08	 add	 esp, 8
  00029	89 45 ec	 mov	 DWORD PTR $T208083[ebp], eax
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	83 7d ec 00	 cmp	 DWORD PTR $T208083[ebp], 0
  00037	74 11		 je	 SHORT $L208084
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR $T208083[ebp]
  00040	e8 00 00 00 00	 call	 ??0?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@ABU01@@Z
  00045	89 45 e8	 mov	 DWORD PTR tv74[ebp], eax
  00048	eb 07		 jmp	 SHORT $L208085
$L208084:
  0004a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L208085:
  00051	8b 55 e8	 mov	 edx, DWORD PTR tv74[ebp]
  00054	89 55 f0	 mov	 DWORD PTR $T208082[ebp], edx
  00057	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 43   : 	}

  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00061	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L208086:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ec	 mov	 ecx, DWORD PTR $T208083[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@ABU10@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T208088
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Construct@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@U12@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@ABU10@@Z ENDP ; std::_Construct<std::pair<TAB_ITEM,CWnd *>,std::pair<TAB_ITEM,CWnd *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRect@@QAE@XZ PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 110  : 	{ /* random filled */ }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CRect@@QAE@XZ ENDP					; CRect::CRect
_TEXT	ENDS
PUBLIC	??_G?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEPAXI@Z	; std::pair<TAB_ITEM,CWnd *>::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@@Z PROC NEAR ; std::_Destroy<std::pair<TAB_ITEM,CWnd *> >, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00003	6a 00		 push	 0
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??_G?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEPAXI@Z

; 50   : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy@U?$pair@UTAB_ITEM@@PAVCWnd@@@std@@@std@@YAXPAU?$pair@UTAB_ITEM@@PAVCWnd@@@0@@Z ENDP ; std::_Destroy<std::pair<TAB_ITEM,CWnd *> >
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
??0CRect@@QAE@HHHH@Z PROC NEAR				; CRect::CRect, COMDAT
; _this$ = ecx

; 112  : 	{ left = l; top = t; right = r; bottom = b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _r$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _b$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
??0CRect@@QAE@HHHH@Z ENDP				; CRect::CRect
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_G?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEPAXI@Z PROC NEAR ; std::pair<TAB_ITEM,CWnd *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L206739
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L206739:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_G?$pair@UTAB_ITEM@@PAVCWnd@@@std@@QAEPAXI@Z ENDP	; std::pair<TAB_ITEM,CWnd *>::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??BCRect@@QAEPAUtagRECT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCRect@@QAEPAUtagRECT@@XZ PROC NEAR			; CRect::operator tagRECT *, COMDAT
; _this$ = ecx

; 143  : 	{ return this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??BCRect@@QAEPAUtagRECT@@XZ ENDP			; CRect::operator tagRECT *
_TEXT	ENDS
EXTRN	?MoveWindow@CWnd@@QAEXHHHHH@Z:NEAR		; CWnd::MoveWindow
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxwin2.inl
;	COMDAT ?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
_bRepaint$ = 12						; size = 4
?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z PROC NEAR		; CWnd::MoveWindow, COMDAT
; _this$ = ecx

; 89   : 	{ MoveWindow(lpRect->left, lpRect->top, lpRect->right - lpRect->left,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   : 		lpRect->bottom - lpRect->top, bRepaint); }

  00007	8b 45 0c	 mov	 eax, DWORD PTR _bRepaint$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _lpRect$[ebp]
  00011	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00014	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _lpRect$[ebp]
  0001e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00021	2b 02		 sub	 eax, DWORD PTR [edx]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  00027	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002a	52		 push	 edx
  0002b	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	51		 push	 ecx
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?MoveWindow@CWnd@@QAEXHHHHH@Z ; CWnd::MoveWindow
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?MoveWindow@CWnd@@QAEXPBUtagRECT@@H@Z ENDP		; CWnd::MoveWindow
_TEXT	ENDS
EXTRN	__imp__GetClientRect@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z PROC NEAR	; CWnd::GetClientRect, COMDAT
; _this$ = ecx

; 107  : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ENDP		; CWnd::GetClientRect
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 28   : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T208123 DD	0ffffffffH
	DD	FLAT:$L208118
$T208121 DD	019930520H
	DD	01H
	DD	FLAT:$T208123
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 20   : 		}

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L208118:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T208121
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102266
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102266:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T208135 DD	0ffffffffH
	DD	FLAT:$L208130
$T208133 DD	019930520H
	DD	01H
	DD	FLAT:$T208135
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L208130:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T208133
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L102332
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L102332:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\core\imessageobserver.h
_TEXT	ENDS
;	COMDAT ??1IMessageObserver@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1IMessageObserver@@UAE@XZ PROC NEAR			; IMessageObserver::~IMessageObserver, COMDAT
; _this$ = ecx

; 16   : 	virtual ~IMessageObserver(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IMessageObserver@@6B@
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1IMessageObserver@@UAE@XZ ENDP			; IMessageObserver::~IMessageObserver
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GIMessageObserver@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIMessageObserver@@UAEPAXI@Z PROC NEAR		; IMessageObserver::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1IMessageObserver@@UAE@XZ ; IMessageObserver::~IMessageObserver
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L109524
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L109524:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GIMessageObserver@@UAEPAXI@Z ENDP			; IMessageObserver::`scalar deleting destructor'
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 373  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
; Function compile flags: /Odt
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = -4						; size = 4
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 375  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));

  00009	8b 45 08	 mov	 eax, DWORD PTR _nRequestedSize$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 377  : 		if (p == NULL)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0001f	75 04		 jne	 SHORT $L191833

; 378  : 			return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	eb 1a		 jmp	 SHORT $L191820
$L191833:

; 379  : 		
; 380  : 		// Add buffer to the list
; 381  : 		p->m_pNext = m_pHead;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00028	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	89 01		 mov	 DWORD PTR [ecx], eax

; 382  : 		m_pHead = p;

  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00035	89 11		 mov	 DWORD PTR [ecx], edx

; 383  : 		
; 384  : 		return p->GetData();

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
$L191820:

; 385  : 	}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
EXTRN	__imp__malloc:NEAR
; Function compile flags: /Odt
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC NEAR		; ATL::CCRTAllocator::Allocate, COMDAT

; 30   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 		return malloc(nBytes);

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0000d	83 c4 04	 add	 esp, 4

; 32   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
; Function compile flags: /Odt
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$191839 = -4						; size = 4
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 387  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$L191837:

; 388  : 		// Walk the list and free the buffers
; 389  : 		while (m_pHead != NULL)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 22		 je	 SHORT $L191835

; 390  : 		{
; 391  : 			CAtlSafeAllocBufferNode* p = m_pHead;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 fc	 mov	 DWORD PTR _p$191839[ebp], edx

; 392  : 			m_pHead = m_pHead->m_pNext;

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	89 02		 mov	 DWORD PTR [edx], eax

; 393  : 			Allocator::Free(p);

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _p$191839[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  0002e	83 c4 04	 add	 esp, 4

; 394  : 		}

  00031	eb d6		 jmp	 SHORT $L191837
$L191835:

; 395  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
EXTRN	__imp__free:NEAR
; Function compile flags: /Odt
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC NEAR		; ATL::CCRTAllocator::Free, COMDAT

; 35   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   : 		free(p);

  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000d	83 c4 04	 add	 esp, 4

; 37   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 217  : 	}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	39 01		 cmp	 DWORD PTR [ecx], eax
  00012	74 08		 je	 SHORT $L191843

; 227  : 		{
; 228  : 			FreeHeap();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L191843:

; 229  : 		}
; 230  : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 233  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 235  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z		; ATL::CW2AEX<128>::Init
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z PROC NEAR		; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 419  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	89 01		 mov	 DWORD PTR [ecx], eax

; 420  : 		Init( psz, _AtlGetConversionACP() );

  00012	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00017	50		 push	 eax
  00018	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  0001b	52		 push	 edx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init

; 421  : 	}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC NEAR			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 428  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 429  : 		if( m_psz != m_szBuffer )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	39 01		 cmp	 DWORD PTR [ecx], eax
  00012	74 0f		 je	 SHORT $L191854

; 430  : 		{
; 431  : 			free( m_psz );

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 02		 mov	 eax, DWORD PTR [edx]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00020	83 c4 04	 add	 esp, 4
$L191854:

; 432  : 		}
; 433  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC NEAR		; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 436  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 437  : 		return( m_psz );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 438  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );
; 278  : 		if( nBytes > t_nFixedBytes )

  00007	81 7d 08 80 00
	00 00		 cmp	 DWORD PTR _nBytes$[ebp], 128 ; 00000080H
  0000e	76 0e		 jbe	 SHORT $L193612

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

  00010	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

  0001c	eb 0b		 jmp	 SHORT $L193613
$L193612:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 04	 add	 ecx, 4
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	89 0a		 mov	 DWORD PTR [edx], ecx
$L193613:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]

; 288  : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  00012	83 c4 04	 add	 esp, 4

; 314  : 	}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nLengthW$ = -8						; size = 4
_nLengthA$ = -4						; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z PROC NEAR		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 442  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 443  : 		if (psz == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  0000d	75 0b		 jne	 SHORT $L193619

; 444  : 		{
; 445  : 			m_psz = NULL;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 446  : 			return;

  00018	eb 70		 jmp	 SHORT $L208176
$L193619:

; 447  : 		}
; 448  : 		int nLengthW = lstrlenW( psz )+1;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001d	51		 push	 ecx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00024	83 c0 01	 add	 eax, 1
  00027	89 45 f8	 mov	 DWORD PTR _nLengthW$[ebp], eax

; 449  : 		int nLengthA = nLengthW*2;

  0002a	8b 55 f8	 mov	 edx, DWORD PTR _nLengthW$[ebp]
  0002d	d1 e2		 shl	 edx, 1
  0002f	89 55 fc	 mov	 DWORD PTR _nLengthA$[ebp], edx

; 450  : 
; 451  : 		if( nLengthA > t_nBufferLength )

  00032	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _nLengthA$[ebp], 128 ; 00000080H
  00039	7e 24		 jle	 SHORT $L193622

; 452  : 		{
; 453  : 			m_psz = static_cast< LPSTR >( malloc( nLengthA*sizeof( char ) ) );

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _nLengthA$[ebp]
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00045	83 c4 04	 add	 esp, 4
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 454  : 			if (m_psz == NULL)

  0004d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00050	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00053	75 0a		 jne	 SHORT $L193622

; 455  : 			{
; 456  : 				AtlThrow( E_OUTOFMEMORY );

  00055	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0005a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L193622:

; 457  : 			}
; 458  : 		}
; 459  : 
; 460  : 		if (::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ) == 0)

  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	8b 45 fc	 mov	 eax, DWORD PTR _nLengthA$[ebp]
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	52		 push	 edx
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _nLengthW$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  00074	51		 push	 ecx
  00075	6a 00		 push	 0
  00077	8b 55 0c	 mov	 edx, DWORD PTR _nCodePage$[ebp]
  0007a	52		 push	 edx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00081	85 c0		 test	 eax, eax
  00083	75 05		 jne	 SHORT $L208176

; 461  : 		{
; 462  : 			AtlThrowLastWin32();

  00085	e8 00 00 00 00	 call	 ?AtlThrowLastWin32@ATL@@YGXXZ ; ATL::AtlThrowLastWin32
$L208176:

; 463  : 		}
; 464  : 	}

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ENDP		; ATL::CW2AEX<128>::Init
_TEXT	ENDS
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_dwError$ = -4						; size = 4
?AtlThrowLastWin32@ATL@@YGXXZ PROC NEAR			; ATL::AtlThrowLastWin32, COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 81   : 	DWORD dwError = ::GetLastError();

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0000c	89 45 fc	 mov	 DWORD PTR _dwError$[ebp], eax

; 82   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

  0000f	83 7d fc 00	 cmp	 DWORD PTR _dwError$[ebp], 0
  00013	7f 08		 jg	 SHORT $L208179
  00015	8b 45 fc	 mov	 eax, DWORD PTR _dwError$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001b	eb 18		 jmp	 SHORT $L208180
$L208179:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _dwError$[ebp]
  00020	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00026	81 c9 00 00 07
	00		 or	 ecx, 458752		; 00070000H
  0002c	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  00032	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
$L208180:
  00035	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L208178:

; 83   : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 365  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 366  : 			return (this + 1);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8

; 367  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00009	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

  00018	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0001c	75 0a		 jne	 SHORT $L194985

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

  0001e	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00023	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L194985:

; 297  : 		}
; 298  : 		m_p = p;

  00028	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0002e	89 11		 mov	 DWORD PTR [ecx], edx
$L208184:

; 299  : 	}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T208192 DD	0ffffffffH
	DD	FLAT:$L208187
$T208190 DD	019930520H
	DD	01H
	DD	FLAT:$T208192
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0003c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0003f	52		 push	 edx
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L208187:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T208190
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
CRT$XCU	SEGMENT
_$S6	DD	FLAT:_$E5
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\appconfig\config\configsettingdef.h
CRT$XCU	ENDS
;	COMDAT _$E5
text$yc	SEGMENT
_$E5	PROC NEAR					; COMDAT

; 25   : 	CONF_SETTING_SKIN_IDX,				TYPE_CONFIG_STR,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_SETTING_SKIN_IDX
  00008	a3 00 00 00 00	 mov	 DWORD PTR _CONF_SETTING, eax
  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_STR
  00013	89 0d 04 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+4, ecx

; 26   : 	CONF_SETTING_CONFIG_MAIN_PAGE,		TYPE_CONFIG_STR,

  00019	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_SETTING_CONFIG_MAIN_PAGE
  0001f	89 15 08 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+8, edx
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_STR
  0002a	a3 0c 00 00 00	 mov	 DWORD PTR _CONF_SETTING+12, eax

; 27   : 	CONF_SETTING_CONFIG_PROBLEM_REPORT,	TYPE_CONFIG_STR,

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_SETTING_CONFIG_PROBLEM_REPORT
  00035	89 0d 10 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+16, ecx
  0003b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_STR
  00041	89 15 14 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+20, edx

; 28   : 	CONF_SETTING_CONFIG_HOME_PAGE,		TYPE_CONFIG_STR,

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_SETTING_CONFIG_HOME_PAGE
  0004c	a3 18 00 00 00	 mov	 DWORD PTR _CONF_SETTING+24, eax
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_STR
  00057	89 0d 1c 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+28, ecx

; 29   : 	CONF_SETTING_CONFIG_IFASKEXIT,		TYPE_CONFIG_BOOL,

  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_SETTING_CONFIG_IFASKEXIT
  00063	89 15 20 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+32, edx
  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_BOOL
  0006e	a3 24 00 00 00	 mov	 DWORD PTR _CONF_SETTING+36, eax

; 30   : 	CONF_SETTING_CONFIG_EXITCHOICE,		TYPE_CONFIG_BOOL,

  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_SETTING_CONFIG_EXITCHOICE
  00079	89 0d 28 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+40, ecx
  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_BOOL
  00085	89 15 2c 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+44, edx

; 31   : 	CONF_SETTING_LOGIN_USER_NAME,		TYPE_CONFIG_STR,

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_SETTING_LOGIN_USER_NAME
  00090	a3 30 00 00 00	 mov	 DWORD PTR _CONF_SETTING+48, eax
  00095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_STR
  0009b	89 0d 34 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+52, ecx

; 32   : 	CONF_SETTING_LOGIN_PASSWORD,		TYPE_CONFIG_STR,

  000a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_SETTING_LOGIN_PASSWORD
  000a7	89 15 38 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+56, edx
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_STR
  000b2	a3 3c 00 00 00	 mov	 DWORD PTR _CONF_SETTING+60, eax

; 33   : 	CONF_SETTING_NETID,					TYPE_CONFIG_STR,

  000b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_SETTING_NETID
  000bd	89 0d 40 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+64, ecx
  000c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_STR
  000c9	89 15 44 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+68, edx

; 34   : 	CONF_SETTING_COLOR,					TYPE_CONFIG_INT,

  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_SETTING_COLOR
  000d4	a3 48 00 00 00	 mov	 DWORD PTR _CONF_SETTING+72, eax
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_INT
  000df	89 0d 4c 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+76, ecx

; 35   : 	CONF_SETTING_LIGHT,					TYPE_CONFIG_INT,

  000e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_SETTING_LIGHT
  000eb	89 15 50 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+80, edx
  000f1	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_INT
  000f6	a3 54 00 00 00	 mov	 DWORD PTR _CONF_SETTING+84, eax

; 36   : 	CONF_SETTING_COLOR_BTN_INDEX,		TYPE_CONFIG_INT,

  000fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_SETTING_COLOR_BTN_INDEX
  00101	89 0d 58 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+88, ecx
  00107	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_INT
  0010d	89 15 5c 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+92, edx

; 37   : 	CONF_SETTING_COLOR_USER,			TYPE_CONFIG_INT,

  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_SETTING_COLOR_USER
  00118	a3 60 00 00 00	 mov	 DWORD PTR _CONF_SETTING+96, eax
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_INT
  00123	89 0d 64 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+100, ecx

; 38   : 	CONF_SETTING_FIRST_TIME_CHANGESKIN, TYPE_CONFIG_BOOL

  00129	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_SETTING_FIRST_TIME_CHANGESKIN
  0012f	89 15 68 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+104, edx

; 39   : };

  00135	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_BOOL
  0013a	a3 6c 00 00 00	 mov	 DWORD PTR _CONF_SETTING+108, eax
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
_$E5	ENDP
text$yc	ENDS
_BSS	SEGMENT
_CONF_SETTING DD 01cH DUP (?)
_BSS	ENDS
END
