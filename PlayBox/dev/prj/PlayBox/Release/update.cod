; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\update.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??1CAtlStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAtlStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringW@?$ChTraitsOS@_W@ATL@@KGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExW@?$ChTraitsOS@_W@ATL@@KGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiW@?$ChTraitsOS@_W@ATL@@KGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerW@?$ChTraitsOS@_W@ATL@@KGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperW@?$ChTraitsOS@_W@ATL@@KGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strchr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strrchr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strrev@?$ChTraitsOS@_W@ATL@@SAPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strstr@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strspn@?$ChTraitsOS@_W@ATL@@SAHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strcspn@?$ChTraitsOS@_W@ATL@@SAHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strpbrk@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsOS@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E5
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E7
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlAlignUp@H@ATL@@YGHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUIAtlStringMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CAtlStringMgr@ATL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCAtlStringMgr@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CAtlStringMgr@ATL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?haveInCheckPopUpUpdate@?1??checkPopUpUpdate@@YAXPAPAUHWND__@@@Z@4_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?haveIn@?1??checkUpdate@@YAXPBD@Z@4_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CNilStringData@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CAtlStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_strthunks@ATL@@3U_AtlStringThunks@1@A		; ATL::_strthunks
PUBLIC	?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWThunk
PUBLIC	?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z	; ATL::CompareStringWThunk
PUBLIC	?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWThunk
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
PUBLIC	?lstrcmpiWThunk@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWThunk
PUBLIC	?CharLowerWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWThunk
PUBLIC	?CharUpperWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWThunk
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	?g_hCheckUpdate@@3PAXA				; g_hCheckUpdate
_BSS	SEGMENT
?g_hCheckUpdate@@3PAXA DD 01H DUP (?)			; g_hCheckUpdate
_BSS	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitATL@_WV?$ChTraitsCRT@_W@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,ATL::StrTraitATL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
CONST	ENDS
CONST	SEGMENT
$SG199221 DB	'int', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_INT DD FLAT:$SG199221
_DATA	ENDS
CONST	SEGMENT
$SG199223 DB	'str', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_STR DD FLAT:$SG199223
_DATA	ENDS
CONST	SEGMENT
$SG199225 DB	'double', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_DOUBLE DD FLAT:$SG199225
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG199227 DB	'bool', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_BOOL DD FLAT:$SG199227
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG199229 DB	'sepint', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_INT_HASSEP DD FLAT:$SG199229
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG199231 DB	'sepstr', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_STR_HASSEP DD FLAT:$SG199231
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG199233 DB	'sepdouble', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_DOUBLE_HASSEP DD FLAT:$SG199233
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG199235 DB	'sepbool', 00H
CONST	ENDS
_DATA	SEGMENT
_TYPE_CONFIG_BOOL_HASSEP DD FLAT:$SG199235
_DATA	ENDS
CONST	SEGMENT
$SG199237 DB	'App', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_MODULE_NAME DD FLAT:$SG199237
_DATA	ENDS
CONST	SEGMENT
$SG199239 DB	'SwfPath', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_SWF_PATH DD FLAT:$SG199239
_DATA	ENDS
CONST	SEGMENT
$SG199241 DB	'MainWndHold', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_MAINWND_HOLD DD FLAT:$SG199241
_DATA	ENDS
CONST	SEGMENT
$SG199243 DB	'RunCount', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_RUN_COUNT DD FLAT:$SG199243
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG199245 DB	'PlayedGame', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_PLAYED_GAME DD FLAT:$SG199245
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG199247 DB	'playedPcGame', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_PLAYED_PC_GAME DD FLAT:$SG199247
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG199249 DB	'PlayedIconSize', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_PLAYED_ICON_SIZE DD FLAT:$SG199249
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG199251 DB	'PictureSavePath', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_APP_PIC_SAVE_PATH DD FLAT:$SG199251
_DATA	ENDS
CONST	SEGMENT
$SG199258 DB	'Setting', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_MODULE_NAME DD FLAT:$SG199258
_DATA	ENDS
CONST	SEGMENT
$SG199260 DB	'skin', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_SKIN_IDX DD FLAT:$SG199260
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG199262 DB	'MainPage', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_CONFIG_MAIN_PAGE DD FLAT:$SG199262
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG199264 DB	'ProblemReport', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_CONFIG_PROBLEM_REPORT DD FLAT:$SG199264
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG199266 DB	'HomePage', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_CONFIG_HOME_PAGE DD FLAT:$SG199266
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG199268 DB	'askexit', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_CONFIG_IFASKEXIT DD FLAT:$SG199268
_DATA	ENDS
CONST	SEGMENT
$SG199270 DB	'exitchoice', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_CONFIG_EXITCHOICE DD FLAT:$SG199270
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG199272 DB	'UN', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_LOGIN_USER_NAME DD FLAT:$SG199272
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG199274 DB	'PW', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_LOGIN_PASSWORD DD FLAT:$SG199274
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG199276 DB	'NetID', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_NETID DD FLAT:$SG199276
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG199278 DB	'ChangeColorValue', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_COLOR DD FLAT:$SG199278
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG199280 DB	'changeColorLight', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_LIGHT DD FLAT:$SG199280
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG199282 DB	'ColorIndex', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_COLOR_BTN_INDEX DD FLAT:$SG199282
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG199284 DB	'ColorUser', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_COLOR_USER DD FLAT:$SG199284
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG199286 DB	'FirstTimeChangeSkin', 00H
CONST	ENDS
_DATA	SEGMENT
_CONF_SETTING_FIRST_TIME_CHANGESKIN DD FLAT:$SG199286
_DATA	ENDS
CONST	SEGMENT
$SG199469 DB	'checkPopUpUpdate==IN', 00H
	ORG $+3
$SG199470 DB	'PlayBoxDlg', 00H
	ORG $+1
$SG199471 DB	'main.txt', 00H
	ORG $+3
$SG199478 DB	'checkPopUpUpdate==OUT', 00H
	ORG $+2
$SG199479 DB	'PlayBoxDlg', 00H
	ORG $+1
$SG199480 DB	'main.txt', 00H
	ORG $+3
$SG199486 DB	'IN==', 00H
	ORG $+3
$SG199487 DB	'runPopUpUpdate', 00H
	ORG $+1
$SG199488 DB	'update.txt', 00H
	ORG $+1
$SG199495 DB	'OUT0==', 00H
	ORG $+1
$SG199496 DB	'runPopUpUpdate', 00H
	ORG $+1
$SG199497 DB	'update.txt', 00H
	ORG $+1
$SG199507 DB	'INSTALL_DATE', 00H
	ORG $+3
$SG199512 DB	'OUT1==', 00H
	ORG $+1
$SG199513 DB	'runPopUpUpdate', 00H
	ORG $+1
$SG199514 DB	'update.txt', 00H
	ORG $+1
$SG199519 DB	'UPTIP_DATE', 00H
	ORG $+1
$SG199523 DB	'OUT2==', 00H
	ORG $+1
$SG199524 DB	'runPopUpUpdate', 00H
	ORG $+1
$SG199525 DB	'update.txt', 00H
	ORG $+1
$SG199529 DB	'PLAYBOX', 00H
$SG199530 DB	'PLAYBOX', 00H
$SG199534 DB	'OUT3==', 00H
	ORG $+1
$SG199535 DB	'runPopUpUpdate', 00H
	ORG $+1
$SG199536 DB	'update.txt', 00H
	ORG $+1
$SG199542 DB	'NEW_LYRIC', 00H
	ORG $+2
$SG199546 DB	'MB_NEW_LYRIC', 00H
	ORG $+3
$SG199555 DB	'_SILENT', 00H
$SG199558 DB	'OUT4==', 00H
	ORG $+1
$SG199559 DB	'runPopUpUpdate', 00H
	ORG $+1
$SG199560 DB	'update.txt', 00H
	ORG $+1
$SG199563 DB	'_FORCE', 00H
	ORG $+1
$SG199570 DB	'UPTIP_DATE', 00H
	ORG $+1
$SG199575 DB	'PLAYERCMD', 00H
	ORG $+2
$SG199577 DB	'%s\update', 00H
	ORG $+2
$SG199580 DB	'SendMessage to Close Player %s.', 00H
$SG199581 DB	'runPopUpUpdate', 00H
	ORG $+1
$SG199582 DB	'update.txt', 00H
	ORG $+1
$SG199584 DB	'PLAYBOX', 00H
$SG199589 DB	'OUT5==', 00H
	ORG $+1
$SG199590 DB	'runPopUpUpdate', 00H
	ORG $+1
$SG199591 DB	'update.txt', 00H
	ORG $+1
$SG199594 DB	'OUT6==', 00H
	ORG $+1
$SG199595 DB	'runPopUpUpdate', 00H
	ORG $+1
$SG199596 DB	'update.txt', 00H
	ORG $+1
$SG199606 DB	'IN==', 00H
	ORG $+3
$SG199607 DB	'realUpdate', 00H
	ORG $+1
$SG199608 DB	'update.txt', 00H
	ORG $+1
$SG199613 DB	'%s', 00H
	ORG $+1
$SG199615 DB	'%s\LhUpdate.dll', 00H
$SG199620 DB	'BeginUpdate2', 00H
	ORG $+3
$SG199624 DB	'Call BeginUpdate2.', 00H
	ORG $+1
$SG199625 DB	'realUpdate', 00H
	ORG $+1
$SG199626 DB	'update.txt', 00H
	ORG $+1
$SG199629 DB	'OUT==', 00H
	ORG $+2
$SG199630 DB	'realUpdate', 00H
	ORG $+1
$SG199631 DB	'update.txt', 00H
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT
?_strthunks@ATL@@3U_AtlStringThunks@1@A DD FLAT:?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ; ATL::_strthunks
	DD	FLAT:?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
	DD	FLAT:?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
	DD	FLAT:?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG98734 DB	'YPLAYBOX', 00H
CONST	ENDS
_DATA	SEGMENT
_g_szSoftName DD FLAT:$SG98734
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG98736 DB	'SOFTWARE\YPLAYBOX', 00H
CONST	ENDS
_DATA	SEGMENT
_STR_REG_SOFT DD FLAT:$SG98736
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG98742 DB	'SOFTWARE\YPLAYBOX\UPDATE', 00H
CONST	ENDS
_DATA	SEGMENT
_STR_REG_UPDATE DD FLAT:$SG98742
_DATA	ENDS
PUBLIC	?checkUpdate@@YAXPBD@Z				; checkUpdate
PUBLIC	?realUpdate@@YAXPAX@Z				; realUpdate
EXTRN	__imp___beginthread:NEAR
;	COMDAT ?haveIn@?1??checkUpdate@@YAXPBD@Z@4_NA
; File d:\boxgit\playbox\playbox\dev\prj\playbox\update.cpp
_BSS	SEGMENT
?haveIn@?1??checkUpdate@@YAXPBD@Z@4_NA DB 01H DUP (?)	; `checkUpdate'::`2'::haveIn
; Function compile flags: /Odt
_BSS	ENDS
_TEXT	SEGMENT
_player$ = 8						; size = 4
?checkUpdate@@YAXPBD@Z PROC NEAR			; checkUpdate

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	static bool haveIn = false;//checkUpdate只允许进入一次
; 26   : 	if(!haveIn)

  00003	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?haveIn@?1??checkUpdate@@YAXPBD@Z@4_NA
  0000a	85 c0		 test	 eax, eax
  0000c	75 20		 jne	 SHORT $L199453

; 27   : 	{
; 28   : 		haveIn = true;

  0000e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?haveIn@?1??checkUpdate@@YAXPBD@Z@4_NA, 1

; 29   : 		g_hCheckUpdate = (HANDLE)_beginthread(realUpdate, 0, (void*)(player));

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00018	51		 push	 ecx
  00019	6a 00		 push	 0
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?realUpdate@@YAXPAX@Z ; realUpdate
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___beginthread
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	a3 00 00 00 00	 mov	 DWORD PTR ?g_hCheckUpdate@@3PAXA, eax ; g_hCheckUpdate
$L199453:

; 30   : 	}
; 31   : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?checkUpdate@@YAXPBD@Z ENDP				; checkUpdate
_TEXT	ENDS
PUBLIC	?stopCheckUpdate@@YAXXZ				; stopCheckUpdate
EXTRN	__imp__TerminateThread@8:NEAR
EXTRN	__imp__GetExitCodeThread@8:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_dwThreadid$ = -4					; size = 4
?stopCheckUpdate@@YAXXZ PROC NEAR			; stopCheckUpdate

; 34   : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	51		 push	 ecx

; 35   : 	DWORD dwThreadid = 0;

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwThreadid$[ebp], 0

; 36   : 	if( g_hCheckUpdate && GetExitCodeThread(g_hCheckUpdate,&dwThreadid) && dwThreadid == STILL_ACTIVE)

  0003b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_hCheckUpdate@@3PAXA, 0 ; g_hCheckUpdate
  00042	74 52		 je	 SHORT $L199460
  00044	8d 45 fc	 lea	 eax, DWORD PTR _dwThreadid$[ebp]
  00047	50		 push	 eax
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hCheckUpdate@@3PAXA ; g_hCheckUpdate
  0004e	51		 push	 ecx
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeThread@8
  00055	85 c0		 test	 eax, eax
  00057	74 3d		 je	 SHORT $L199460
  00059	81 7d fc 03 01
	00 00		 cmp	 DWORD PTR _dwThreadid$[ebp], 259 ; 00000103H
  00060	75 34		 jne	 SHORT $L199460

; 37   : 	{
; 38   : 		TerminateThread(g_hCheckUpdate,1);

  00062	6a 01		 push	 1
  00064	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hCheckUpdate@@3PAXA ; g_hCheckUpdate
  0006a	52		 push	 edx
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 39   : 		WaitForSingleObject(g_hCheckUpdate,INFINITE);

  00071	6a ff		 push	 -1
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hCheckUpdate@@3PAXA ; g_hCheckUpdate
  00078	50		 push	 eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 40   : 		CloseHandle(g_hCheckUpdate);

  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hCheckUpdate@@3PAXA ; g_hCheckUpdate
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 41   : 		g_hCheckUpdate = NULL;

  0008c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_hCheckUpdate@@3PAXA, 0 ; g_hCheckUpdate
$L199460:

; 42   : 	}
; 43   : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?stopCheckUpdate@@YAXXZ ENDP				; stopCheckUpdate
_TEXT	ENDS
PUBLIC	?checkPopUpUpdate@@YAXPAPAUHWND__@@@Z		; checkPopUpUpdate
PUBLIC	?runPopUpUpdate@@YAXPAX@Z			; runPopUpUpdate
EXTRN	__imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
;	COMDAT ?haveInCheckPopUpUpdate@?1??checkPopUpUpdate@@YAXPAPAUHWND__@@@Z@4_NA
_BSS	SEGMENT
?haveInCheckPopUpUpdate@?1??checkPopUpUpdate@@YAXPAPAUHWND__@@@Z@4_NA DB 01H DUP (?) ; `checkPopUpUpdate'::`2'::haveInCheckPopUpUpdate
_BSS	ENDS
xdata$x	SEGMENT
$T200173 DD	0ffffffffH
	DD	FLAT:$L200163
	DD	00H
	DD	FLAT:$L200164
	DD	0ffffffffH
	DD	FLAT:$L200165
	DD	02H
	DD	FLAT:$L200166
$T200170 DD	019930520H
	DD	04H
	DD	FLAT:$T200173
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T200162 = -124						; size = 28
$T200161 = -96						; size = 28
$T200160 = -68						; size = 28
$T200159 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_phWnd$ = 8						; size = 4
?checkPopUpUpdate@@YAXPAPAUHWND__@@@Z PROC NEAR		; checkPopUpUpdate

; 48   : {

  000a0	55		 push	 ebp
  000a1	8b ec		 mov	 ebp, esp
  000a3	6a ff		 push	 -1
  000a5	68 00 00 00 00	 push	 __ehhandler$?checkPopUpUpdate@@YAXPAPAUHWND__@@@Z
  000aa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  000b0	50		 push	 eax
  000b1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  000b8	83 ec 70	 sub	 esp, 112		; 00000070H

; 49   : 	YL_Log( STR_LOG_FILE ,LOG_NOTICE,"PlayBoxDlg","checkPopUpUpdate==IN" );

  000bb	68 00 00 00 00	 push	 OFFSET FLAT:$SG199470
  000c0	8d 4d d8	 lea	 ecx, DWORD PTR $T200159[ebp]
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  000c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d0	68 00 00 00 00	 push	 OFFSET FLAT:$SG199471
  000d5	8d 4d bc	 lea	 ecx, DWORD PTR $T200160[ebp]
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  000de	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000e2	68 00 00 00 00	 push	 OFFSET FLAT:$SG199469
  000e7	8d 45 d8	 lea	 eax, DWORD PTR $T200159[ebp]
  000ea	50		 push	 eax
  000eb	6a 01		 push	 1
  000ed	8d 4d bc	 lea	 ecx, DWORD PTR $T200160[ebp]
  000f0	51		 push	 ecx
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  000f7	83 c4 10	 add	 esp, 16			; 00000010H
  000fa	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000fe	8d 4d bc	 lea	 ecx, DWORD PTR $T200160[ebp]
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00107	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0010e	8d 4d d8	 lea	 ecx, DWORD PTR $T200159[ebp]
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 50   : 	static bool haveInCheckPopUpUpdate = false;//checkPopUpUpdate只允许进入一次
; 51   : 	if(!haveInCheckPopUpUpdate)

  00117	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?haveInCheckPopUpUpdate@?1??checkPopUpUpdate@@YAXPAPAUHWND__@@@Z@4_NA
  0011e	85 d2		 test	 edx, edx
  00120	75 1b		 jne	 SHORT $L199474

; 52   : 	{
; 53   : 		haveInCheckPopUpUpdate = true;	

  00122	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?haveInCheckPopUpUpdate@?1??checkPopUpUpdate@@YAXPAPAUHWND__@@@Z@4_NA, 1

; 54   : 		_beginthread(runPopUpUpdate, 0, (void*)phWnd);

  00129	8b 45 08	 mov	 eax, DWORD PTR _phWnd$[ebp]
  0012c	50		 push	 eax
  0012d	6a 00		 push	 0
  0012f	68 00 00 00 00	 push	 OFFSET FLAT:?runPopUpUpdate@@YAXPAX@Z ; runPopUpUpdate
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___beginthread
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L199474:

; 55   : 	}
; 56   : 	YL_Log( STR_LOG_FILE ,LOG_NOTICE,"PlayBoxDlg","checkPopUpUpdate==OUT" );

  0013d	68 00 00 00 00	 push	 OFFSET FLAT:$SG199479
  00142	8d 4d a0	 lea	 ecx, DWORD PTR $T200161[ebp]
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0014b	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00152	68 00 00 00 00	 push	 OFFSET FLAT:$SG199480
  00157	8d 4d 84	 lea	 ecx, DWORD PTR $T200162[ebp]
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00160	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00164	68 00 00 00 00	 push	 OFFSET FLAT:$SG199478
  00169	8d 4d a0	 lea	 ecx, DWORD PTR $T200161[ebp]
  0016c	51		 push	 ecx
  0016d	6a 01		 push	 1
  0016f	8d 55 84	 lea	 edx, DWORD PTR $T200162[ebp]
  00172	52		 push	 edx
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00179	83 c4 10	 add	 esp, 16			; 00000010H
  0017c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00180	8d 4d 84	 lea	 ecx, DWORD PTR $T200162[ebp]
  00183	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00189	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00190	8d 4d a0	 lea	 ecx, DWORD PTR $T200161[ebp]
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 57   : }

  00199	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0019c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200163:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T200159[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200164:
  00009	8d 4d bc	 lea	 ecx, DWORD PTR $T200160[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200165:
  00012	8d 4d a0	 lea	 ecx, DWORD PTR $T200161[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200166:
  0001b	8d 4d 84	 lea	 ecx, DWORD PTR $T200162[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?checkPopUpUpdate@@YAXPAPAUHWND__@@@Z:
  00024	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200170
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?checkPopUpUpdate@@YAXPAPAUHWND__@@@Z ENDP		; checkPopUpUpdate
EXTRN	?GetUpdateTipsDelay@CLhcImg@@SAHXZ:NEAR		; CLhcImg::GetUpdateTipsDelay
EXTRN	?win32Showexec@@YAPAXPBD0_N@Z:NEAR		; win32Showexec
EXTRN	__imp__time:NEAR
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
EXTRN	?DoModal@CDialog@@UAEHXZ:NEAR			; CDialog::DoModal
EXTRN	__imp__PostMessageA@16:NEAR
EXTRN	?GetConfigIntValue@AfxUserConfig@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAH@Z:NEAR ; AfxUserConfig::GetConfigIntValue
EXTRN	?WriteString@YL_EncFileReg@@SA_NPAUHKEY__@@PBD11@Z:NEAR ; YL_EncFileReg::WriteString
EXTRN	?ReadString@YL_EncFileReg@@SA_NPAUHKEY__@@PBD1QADI@Z:NEAR ; YL_EncFileReg::ReadString
EXTRN	?WriteDWORD@YL_EncFileReg@@SA_NPAUHKEY__@@PBD1ABI@Z:NEAR ; YL_EncFileReg::WriteDWORD
EXTRN	?ReadDWORD@YL_EncFileReg@@SA_NPAUHKEY__@@PBD1AAI@Z:NEAR ; YL_EncFileReg::ReadDWORD
EXTRN	__imp___snprintf:NEAR
EXTRN	__imp__GetModuleFileNameA@12:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__GetCommandLineA@0:NEAR
EXTRN	__imp__Sleep@4:NEAR
EXTRN	_memset:NEAR
EXTRN	_strcpy:NEAR
EXTRN	??0CUpdateTipDlg@@QAE@PAVCWnd@@@Z:NEAR		; CUpdateTipDlg::CUpdateTipDlg
EXTRN	??1CUpdateTipDlg@@UAE@XZ:NEAR			; CUpdateTipDlg::~CUpdateTipDlg
EXTRN	_strlen:NEAR
EXTRN	?SetForceUpdate@CUpdateTipDlg@@QAEXH@Z:NEAR	; CUpdateTipDlg::SetForceUpdate
EXTRN	__imp__exit:NEAR
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:NEAR
EXTRN	__imp__strstr:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__imp__strupr:NEAR
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
EXTRN	?AfxGetUserConfig@@YAPAVAfxUserConfig@@XZ:NEAR	; AfxGetUserConfig
EXTRN	?GetHomePath@CLhcImg@@SA_NQADH@Z:NEAR		; CLhcImg::GetHomePath
xdata$x	SEGMENT
$T200226 DD	0ffffffffH
	DD	FLAT:$L200198
	DD	00H
	DD	FLAT:$L200199
	DD	0ffffffffH
	DD	FLAT:$L200200
	DD	02H
	DD	FLAT:$L200201
	DD	0ffffffffH
	DD	FLAT:$L200202
	DD	04H
	DD	FLAT:$L200203
	DD	0ffffffffH
	DD	FLAT:$L200204
	DD	06H
	DD	FLAT:$L200205
	DD	0ffffffffH
	DD	FLAT:$L200206
	DD	08H
	DD	FLAT:$L200207
	DD	0ffffffffH
	DD	FLAT:$L200208
	DD	0aH
	DD	FLAT:$L200209
	DD	0bH
	DD	FLAT:$L200210
	DD	0aH
	DD	FLAT:$L200211
	DD	0dH
	DD	FLAT:$L200212
	DD	0aH
	DD	FLAT:$L200213
	DD	0fH
	DD	FLAT:$L200214
	DD	010H
	DD	FLAT:$L200215
	DD	0fH
	DD	FLAT:$L200216
	DD	012H
	DD	FLAT:$L200217
	DD	0aH
	DD	FLAT:$L200218
	DD	014H
	DD	FLAT:$L200219
$T200221 DD	019930520H
	DD	016H
	DD	FLAT:$T200226
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T200197 = -2204					; size = 28
$T200196 = -2176					; size = 28
$T200195 = -2148					; size = 28
$T200194 = -2120					; size = 28
$T200193 = -2092					; size = 28
$T200192 = -2064					; size = 28
$T200191 = -2036					; size = 28
$T200190 = -2008					; size = 28
$T200189 = -1980					; size = 28
$T200188 = -1952					; size = 28
$T200187 = -1924					; size = 28
$T200186 = -1896					; size = 28
$T200185 = -1868					; size = 28
$T200184 = -1840					; size = 28
$T200183 = -1812					; size = 28
$T200182 = -1784					; size = 28
$T200181 = -1756					; size = 28
$T200180 = -1728					; size = 28
$T200179 = -1700					; size = 28
$T200178 = -1672					; size = 28
_uppath$199576 = -1644					; size = 260
_dir$199549 = -1380					; size = 260
_forceUpdate$199561 = -1112				; size = 4
_dlg$199566 = -1108					; size = 376
_setupexe$199551 = -732					; size = 128
_hMain$199565 = -600					; size = 4
_delay$199508 = -596					; size = 4
_playerName$ = -592					; size = 28
_dwDate$ = -564						; size = 4
_nListen$ = -560					; size = 4
_pszNewVer$ = -556					; size = 128
_timer$ = -424						; size = 4
_cfname$ = -420						; size = 260
_pszMbNewVer$ = -156					; size = 128
__$ArrayPad$ = -24					; size = 4
_dwInstDate$ = -20					; size = 4
_dwCurDate$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pparam$ = 8						; size = 4
?runPopUpUpdate@@YAXPAX@Z PROC NEAR			; runPopUpUpdate

; 63   : {

  001b0	55		 push	 ebp
  001b1	8b ec		 mov	 ebp, esp
  001b3	6a ff		 push	 -1
  001b5	68 00 00 00 00	 push	 __ehhandler$?runPopUpUpdate@@YAXPAX@Z
  001ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  001c0	50		 push	 eax
  001c1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  001c8	81 ec 90 08 00
	00		 sub	 esp, 2192		; 00000890H
  001ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  001d3	89 45 e8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 64   : 	YL_Log(UPDATE_LOG, LOG_NOTICE, "runPopUpUpdate", "IN==");

  001d6	68 00 00 00 00	 push	 OFFSET FLAT:$SG199487
  001db	8d 8d 78 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200178[ebp]
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  001e7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  001ee	68 00 00 00 00	 push	 OFFSET FLAT:$SG199488
  001f3	8d 8d 5c f9 ff
	ff		 lea	 ecx, DWORD PTR $T200179[ebp]
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  001ff	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00203	68 00 00 00 00	 push	 OFFSET FLAT:$SG199486
  00208	8d 85 78 f9 ff
	ff		 lea	 eax, DWORD PTR $T200178[ebp]
  0020e	50		 push	 eax
  0020f	6a 01		 push	 1
  00211	8d 8d 5c f9 ff
	ff		 lea	 ecx, DWORD PTR $T200179[ebp]
  00217	51		 push	 ecx
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  0021e	83 c4 10	 add	 esp, 16			; 00000010H
  00221	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00225	8d 8d 5c f9 ff
	ff		 lea	 ecx, DWORD PTR $T200179[ebp]
  0022b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00231	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00238	8d 8d 78 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200178[ebp]
  0023e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 65   : 	//检测是否应该出现升级提示
; 66   : 	//没玩够10个游戏，不进行升级
; 67   : 	int nListen = 0;

  00244	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _nListen$[ebp], 0

; 68   : 	AfxGetUserConfig()->GetConfigIntValue( CONF_APP_MODULE_NAME, CONF_APP_PLAYED_GAME, nListen );

  0024e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_APP_PLAYED_GAME
  00254	52		 push	 edx
  00255	8d 8d 40 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200180[ebp]
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00261	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00268	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_APP_MODULE_NAME
  0026d	50		 push	 eax
  0026e	8d 8d 24 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200181[ebp]
  00274	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0027a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0027e	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _nListen$[ebp]
  00284	51		 push	 ecx
  00285	8d 95 40 f9 ff
	ff		 lea	 edx, DWORD PTR $T200180[ebp]
  0028b	52		 push	 edx
  0028c	8d 85 24 f9 ff
	ff		 lea	 eax, DWORD PTR $T200181[ebp]
  00292	50		 push	 eax
  00293	e8 00 00 00 00	 call	 ?AfxGetUserConfig@@YAPAVAfxUserConfig@@XZ ; AfxGetUserConfig
  00298	8b c8		 mov	 ecx, eax
  0029a	e8 00 00 00 00	 call	 ?GetConfigIntValue@AfxUserConfig@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAH@Z ; AfxUserConfig::GetConfigIntValue
  0029f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  002a3	8d 8d 24 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200181[ebp]
  002a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  002af	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002b6	8d 8d 40 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200180[ebp]
  002bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 69   : 	if(nListen < 4)

  002c2	83 bd d0 fd ff
	ff 04		 cmp	 DWORD PTR _nListen$[ebp], 4
  002c9	7d 73		 jge	 SHORT $L199492

; 70   : 	{
; 71   : 		YL_Log(UPDATE_LOG, LOG_NOTICE, "runPopUpUpdate", "OUT0==");

  002cb	68 00 00 00 00	 push	 OFFSET FLAT:$SG199496
  002d0	8d 8d 08 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200182[ebp]
  002d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  002dc	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  002e3	68 00 00 00 00	 push	 OFFSET FLAT:$SG199497
  002e8	8d 8d ec f8 ff
	ff		 lea	 ecx, DWORD PTR $T200183[ebp]
  002ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  002f4	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  002f8	68 00 00 00 00	 push	 OFFSET FLAT:$SG199495
  002fd	8d 8d 08 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200182[ebp]
  00303	51		 push	 ecx
  00304	6a 01		 push	 1
  00306	8d 95 ec f8 ff
	ff		 lea	 edx, DWORD PTR $T200183[ebp]
  0030c	52		 push	 edx
  0030d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00313	83 c4 10	 add	 esp, 16			; 00000010H
  00316	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0031a	8d 8d ec f8 ff
	ff		 lea	 ecx, DWORD PTR $T200183[ebp]
  00320	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00326	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0032d	8d 8d 08 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200182[ebp]
  00333	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 72   : 		return;

  00339	e9 f7 06 00 00	 jmp	 $L200177
$L199492:

; 73   : 	}
; 74   : 	unsigned int dwDate = 0, dwInstDate = 0, dwCurDate = 0;

  0033e	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwDate$[ebp], 0
  00348	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwInstDate$[ebp], 0
  0034f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwCurDate$[ebp], 0

; 75   : 	time_t timer;
; 76   : 	time(&timer);

  00356	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _timer$[ebp]
  0035c	50		 push	 eax
  0035d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__time
  00363	83 c4 04	 add	 esp, 4

; 77   : 	dwCurDate = (DWORD)(timer/(60 * 60 * 24));

  00366	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR _timer$[ebp]
  0036c	99		 cdq
  0036d	b9 80 51 01 00	 mov	 ecx, 86400		; 00015180H
  00372	f7 f9		 idiv	 ecx
  00374	89 45 f0	 mov	 DWORD PTR _dwCurDate$[ebp], eax

; 78   : 	//检查安装时间
; 79   : 	if(YL_EncFileReg::ReadDWORD(HKEY_PLAYBOX_ROOT, STR_REG_UPDATE, "INSTALL_DATE", dwInstDate))

  00377	8d 55 ec	 lea	 edx, DWORD PTR _dwInstDate$[ebp]
  0037a	52		 push	 edx
  0037b	68 00 00 00 00	 push	 OFFSET FLAT:$SG199507
  00380	a1 00 00 00 00	 mov	 eax, DWORD PTR _STR_REG_UPDATE
  00385	50		 push	 eax
  00386	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0038b	e8 00 00 00 00	 call	 ?ReadDWORD@YL_EncFileReg@@SA_NPAUHKEY__@@PBD1AAI@Z ; YL_EncFileReg::ReadDWORD
  00390	83 c4 10	 add	 esp, 16			; 00000010H
  00393	0f b6 c8	 movzx	 ecx, al
  00396	85 c9		 test	 ecx, ecx
  00398	0f 84 8c 00 00
	00		 je	 $L199506

; 80   : 	{
; 81   : 		int delay = CLhcImg::GetUpdateTipsDelay();

  0039e	e8 00 00 00 00	 call	 ?GetUpdateTipsDelay@CLhcImg@@SAHXZ ; CLhcImg::GetUpdateTipsDelay
  003a3	89 85 ac fd ff
	ff		 mov	 DWORD PTR _delay$199508[ebp], eax

; 82   : 		if(dwCurDate - dwInstDate < delay)

  003a9	8b 55 f0	 mov	 edx, DWORD PTR _dwCurDate$[ebp]
  003ac	2b 55 ec	 sub	 edx, DWORD PTR _dwInstDate$[ebp]
  003af	3b 95 ac fd ff
	ff		 cmp	 edx, DWORD PTR _delay$199508[ebp]
  003b5	73 73		 jae	 SHORT $L199506

; 83   : 		{
; 84   : 			YL_Log(UPDATE_LOG, LOG_NOTICE, "runPopUpUpdate", "OUT1==");

  003b7	68 00 00 00 00	 push	 OFFSET FLAT:$SG199513
  003bc	8d 8d d0 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200184[ebp]
  003c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  003c8	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  003cf	68 00 00 00 00	 push	 OFFSET FLAT:$SG199514
  003d4	8d 8d b4 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200185[ebp]
  003da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  003e0	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  003e4	68 00 00 00 00	 push	 OFFSET FLAT:$SG199512
  003e9	8d 85 d0 f8 ff
	ff		 lea	 eax, DWORD PTR $T200184[ebp]
  003ef	50		 push	 eax
  003f0	6a 01		 push	 1
  003f2	8d 8d b4 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200185[ebp]
  003f8	51		 push	 ecx
  003f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  003ff	83 c4 10	 add	 esp, 16			; 00000010H
  00402	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00406	8d 8d b4 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200185[ebp]
  0040c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00412	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00419	8d 8d d0 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200184[ebp]
  0041f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 85   : 			return;

  00425	e9 0b 06 00 00	 jmp	 $L200177
$L199506:

; 86   : 		}
; 87   : 	}
; 88   : 	//上次执行时间
; 89   : 	if(YL_EncFileReg::ReadDWORD(HKEY_PLAYBOX_ROOT, STR_REG_UPDATE, "UPTIP_DATE", dwDate))

  0042a	8d 95 cc fd ff
	ff		 lea	 edx, DWORD PTR _dwDate$[ebp]
  00430	52		 push	 edx
  00431	68 00 00 00 00	 push	 OFFSET FLAT:$SG199519
  00436	a1 00 00 00 00	 mov	 eax, DWORD PTR _STR_REG_UPDATE
  0043b	50		 push	 eax
  0043c	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00441	e8 00 00 00 00	 call	 ?ReadDWORD@YL_EncFileReg@@SA_NPAUHKEY__@@PBD1AAI@Z ; YL_EncFileReg::ReadDWORD
  00446	83 c4 10	 add	 esp, 16			; 00000010H
  00449	0f b6 c8	 movzx	 ecx, al
  0044c	85 c9		 test	 ecx, ecx
  0044e	0f 84 81 00 00
	00		 je	 $L199518

; 90   : 	{
; 91   : 		//比较时间间隔
; 92   : 		if(dwCurDate - dwDate < 3)

  00454	8b 55 f0	 mov	 edx, DWORD PTR _dwCurDate$[ebp]
  00457	2b 95 cc fd ff
	ff		 sub	 edx, DWORD PTR _dwDate$[ebp]
  0045d	83 fa 03	 cmp	 edx, 3
  00460	73 73		 jae	 SHORT $L199518

; 93   : 		{
; 94   : 			YL_Log(UPDATE_LOG, LOG_NOTICE, "runPopUpUpdate", "OUT2==");

  00462	68 00 00 00 00	 push	 OFFSET FLAT:$SG199524
  00467	8d 8d 98 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200186[ebp]
  0046d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00473	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8
  0047a	68 00 00 00 00	 push	 OFFSET FLAT:$SG199525
  0047f	8d 8d 7c f8 ff
	ff		 lea	 ecx, DWORD PTR $T200187[ebp]
  00485	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0048b	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  0048f	68 00 00 00 00	 push	 OFFSET FLAT:$SG199523
  00494	8d 85 98 f8 ff
	ff		 lea	 eax, DWORD PTR $T200186[ebp]
  0049a	50		 push	 eax
  0049b	6a 01		 push	 1
  0049d	8d 8d 7c f8 ff
	ff		 lea	 ecx, DWORD PTR $T200187[ebp]
  004a3	51		 push	 ecx
  004a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  004aa	83 c4 10	 add	 esp, 16			; 00000010H
  004ad	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  004b1	8d 8d 7c f8 ff
	ff		 lea	 ecx, DWORD PTR $T200187[ebp]
  004b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  004bd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004c4	8d 8d 98 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200186[ebp]
  004ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 95   : 			return;

  004d0	e9 60 05 00 00	 jmp	 $L200177
$L199518:

; 96   : 		}
; 97   : 	}
; 98   : 	
; 99   : 	char cfname[MAX_PATH];
; 100  : 	GetModuleFileName(NULL, cfname, MAX_PATH);	

  004d5	68 04 01 00 00	 push	 260			; 00000104H
  004da	8d 95 5c fe ff
	ff		 lea	 edx, DWORD PTR _cfname$[ebp]
  004e0	52		 push	 edx
  004e1	6a 00		 push	 0
  004e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 101  : 	string playerName;

  004e9	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _playerName$[ebp]
  004ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  004f5	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 10 ; 0000000aH

; 102  : 	if(strstr(strupr(cfname), "PLAYBOX") != NULL)

  004fc	68 00 00 00 00	 push	 OFFSET FLAT:$SG199529
  00501	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _cfname$[ebp]
  00507	50		 push	 eax
  00508	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strupr
  0050e	83 c4 04	 add	 esp, 4
  00511	50		 push	 eax
  00512	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  00518	83 c4 08	 add	 esp, 8
  0051b	85 c0		 test	 eax, eax
  0051d	74 16		 je	 SHORT $L199528

; 103  : 	{
; 104  : 		playerName = "PLAYBOX";

  0051f	68 00 00 00 00	 push	 OFFSET FLAT:$SG199530
  00524	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _playerName$[ebp]
  0052a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 105  : 	}
; 106  : 	else

  00530	e9 80 00 00 00	 jmp	 $L199531
$L199528:

; 107  : 	{
; 108  : 		YL_Log(UPDATE_LOG, LOG_NOTICE, "runPopUpUpdate", "OUT3==");

  00535	68 00 00 00 00	 push	 OFFSET FLAT:$SG199535
  0053a	8d 8d 60 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200188[ebp]
  00540	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00546	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  0054a	68 00 00 00 00	 push	 OFFSET FLAT:$SG199536
  0054f	8d 8d 44 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200189[ebp]
  00555	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0055b	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  0055f	68 00 00 00 00	 push	 OFFSET FLAT:$SG199534
  00564	8d 8d 60 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200188[ebp]
  0056a	51		 push	 ecx
  0056b	6a 01		 push	 1
  0056d	8d 95 44 f8 ff
	ff		 lea	 edx, DWORD PTR $T200189[ebp]
  00573	52		 push	 edx
  00574	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  0057a	83 c4 10	 add	 esp, 16			; 00000010H
  0057d	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00581	8d 8d 44 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200189[ebp]
  00587	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0058d	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00591	8d 8d 60 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200188[ebp]
  00597	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 109  : 		return;

  0059d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  005a4	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _playerName$[ebp]
  005aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  005b0	e9 80 04 00 00	 jmp	 $L200177
$L199531:

; 110  : 	}
; 111  : 	//从注册表判断是否下载了新版本
; 112  : 	char pszNewVer[128], pszMbNewVer[128];
; 113  : 	memset(pszNewVer, 0, 128);

  005b5	68 80 00 00 00	 push	 128			; 00000080H
  005ba	6a 00		 push	 0
  005bc	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _pszNewVer$[ebp]
  005c2	50		 push	 eax
  005c3	e8 00 00 00 00	 call	 _memset
  005c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 114  : 	memset(pszMbNewVer, 0, 128);

  005cb	68 80 00 00 00	 push	 128			; 00000080H
  005d0	6a 00		 push	 0
  005d2	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszMbNewVer$[ebp]
  005d8	51		 push	 ecx
  005d9	e8 00 00 00 00	 call	 _memset
  005de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 115  : 	YL_EncFileReg::ReadString(HKEY_PLAYBOX_ROOT, STR_REG_SOFT, STR_NEW_LYRIC_VERSION, pszNewVer, 128);

  005e1	68 80 00 00 00	 push	 128			; 00000080H
  005e6	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _pszNewVer$[ebp]
  005ec	52		 push	 edx
  005ed	68 00 00 00 00	 push	 OFFSET FLAT:$SG199542
  005f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _STR_REG_SOFT
  005f7	50		 push	 eax
  005f8	68 02 00 00 80	 push	 -2147483646		; 80000002H
  005fd	e8 00 00 00 00	 call	 ?ReadString@YL_EncFileReg@@SA_NPAUHKEY__@@PBD1QADI@Z ; YL_EncFileReg::ReadString
  00602	83 c4 14	 add	 esp, 20			; 00000014H

; 116  : 	YL_EncFileReg::ReadString(HKEY_PLAYBOX_ROOT, STR_REG_SOFT, STR_MB_NEW_LYRIC_VER, pszMbNewVer, 128);	

  00605	68 80 00 00 00	 push	 128			; 00000080H
  0060a	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszMbNewVer$[ebp]
  00610	51		 push	 ecx
  00611	68 00 00 00 00	 push	 OFFSET FLAT:$SG199546
  00616	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _STR_REG_SOFT
  0061c	52		 push	 edx
  0061d	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00622	e8 00 00 00 00	 call	 ?ReadString@YL_EncFileReg@@SA_NPAUHKEY__@@PBD1QADI@Z ; YL_EncFileReg::ReadString
  00627	83 c4 14	 add	 esp, 20			; 00000014H

; 117  : 	if(strlen(pszNewVer) > 0 || (strlen(pszMbNewVer) > 0 ))

  0062a	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _pszNewVer$[ebp]
  00630	50		 push	 eax
  00631	e8 00 00 00 00	 call	 _strlen
  00636	83 c4 04	 add	 esp, 4
  00639	85 c0		 test	 eax, eax
  0063b	77 17		 ja	 SHORT $L199548
  0063d	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszMbNewVer$[ebp]
  00643	51		 push	 ecx
  00644	e8 00 00 00 00	 call	 _strlen
  00649	83 c4 04	 add	 esp, 4
  0064c	85 c0		 test	 eax, eax
  0064e	0f 86 66 03 00
	00		 jbe	 $L199547
$L199548:

; 118  : 	{
; 119  : 		char dir[MAX_PATH];
; 120  : 		memset(dir, 0, MAX_PATH);

  00654	68 04 01 00 00	 push	 260			; 00000104H
  00659	6a 00		 push	 0
  0065b	8d 95 9c fa ff
	ff		 lea	 edx, DWORD PTR _dir$199549[ebp]
  00661	52		 push	 edx
  00662	e8 00 00 00 00	 call	 _memset
  00667	83 c4 0c	 add	 esp, 12			; 0000000cH

; 121  : 		if(!CLhcImg::GetHomePath(dir, MAX_PATH))

  0066a	68 04 01 00 00	 push	 260			; 00000104H
  0066f	8d 85 9c fa ff
	ff		 lea	 eax, DWORD PTR _dir$199549[ebp]
  00675	50		 push	 eax
  00676	e8 00 00 00 00	 call	 ?GetHomePath@CLhcImg@@SA_NQADH@Z ; CLhcImg::GetHomePath
  0067b	83 c4 08	 add	 esp, 8
  0067e	0f b6 c8	 movzx	 ecx, al
  00681	85 c9		 test	 ecx, ecx
  00683	75 18		 jne	 SHORT $L199550

; 122  : 			return;

  00685	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0068c	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _playerName$[ebp]
  00692	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00698	e9 98 03 00 00	 jmp	 $L200177
$L199550:

; 123  : 
; 124  : 		char setupexe[128];
; 125  : 		if(strlen(pszNewVer) > 0)

  0069d	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _pszNewVer$[ebp]
  006a3	52		 push	 edx
  006a4	e8 00 00 00 00	 call	 _strlen
  006a9	83 c4 04	 add	 esp, 4
  006ac	85 c0		 test	 eax, eax
  006ae	76 18		 jbe	 SHORT $L199552

; 126  : 			strcpy(setupexe, pszNewVer);

  006b0	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _pszNewVer$[ebp]
  006b6	50		 push	 eax
  006b7	8d 8d 24 fd ff
	ff		 lea	 ecx, DWORD PTR _setupexe$199551[ebp]
  006bd	51		 push	 ecx
  006be	e8 00 00 00 00	 call	 _strcpy
  006c3	83 c4 08	 add	 esp, 8

; 127  : 		else

  006c6	eb 16		 jmp	 SHORT $L199553
$L199552:

; 128  : 			strcpy(setupexe, pszMbNewVer);

  006c8	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR _pszMbNewVer$[ebp]
  006ce	52		 push	 edx
  006cf	8d 85 24 fd ff
	ff		 lea	 eax, DWORD PTR _setupexe$199551[ebp]
  006d5	50		 push	 eax
  006d6	e8 00 00 00 00	 call	 _strcpy
  006db	83 c4 08	 add	 esp, 8
$L199553:

; 129  : 		
; 130  : 		//静默安装的升级包不处理，由bho处理
; 131  : 		if(strstr(strupr(setupexe), "_SILENT") != NULL)

  006de	68 00 00 00 00	 push	 OFFSET FLAT:$SG199555
  006e3	8d 8d 24 fd ff
	ff		 lea	 ecx, DWORD PTR _setupexe$199551[ebp]
  006e9	51		 push	 ecx
  006ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strupr
  006f0	83 c4 04	 add	 esp, 4
  006f3	50		 push	 eax
  006f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  006fa	83 c4 08	 add	 esp, 8
  006fd	85 c0		 test	 eax, eax
  006ff	0f 84 80 00 00
	00		 je	 $L199554

; 132  : 		{
; 133  : 			YL_Log(UPDATE_LOG, LOG_NOTICE, "runPopUpUpdate", "OUT4==");

  00705	68 00 00 00 00	 push	 OFFSET FLAT:$SG199559
  0070a	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200190[ebp]
  00710	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00716	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  0071a	68 00 00 00 00	 push	 OFFSET FLAT:$SG199560
  0071f	8d 8d 0c f8 ff
	ff		 lea	 ecx, DWORD PTR $T200191[ebp]
  00725	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0072b	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  0072f	68 00 00 00 00	 push	 OFFSET FLAT:$SG199558
  00734	8d 95 28 f8 ff
	ff		 lea	 edx, DWORD PTR $T200190[ebp]
  0073a	52		 push	 edx
  0073b	6a 01		 push	 1
  0073d	8d 85 0c f8 ff
	ff		 lea	 eax, DWORD PTR $T200191[ebp]
  00743	50		 push	 eax
  00744	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  0074a	83 c4 10	 add	 esp, 16			; 00000010H
  0074d	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00751	8d 8d 0c f8 ff
	ff		 lea	 ecx, DWORD PTR $T200191[ebp]
  00757	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0075d	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00761	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200190[ebp]
  00767	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 134  : 			return;

  0076d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00774	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _playerName$[ebp]
  0077a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00780	e9 b0 02 00 00	 jmp	 $L200177
$L199554:

; 135  : 		}		
; 136  : 		int forceUpdate;
; 137  : 		if(strstr(strupr(setupexe), "_FORCE") != NULL)

  00785	68 00 00 00 00	 push	 OFFSET FLAT:$SG199563
  0078a	8d 8d 24 fd ff
	ff		 lea	 ecx, DWORD PTR _setupexe$199551[ebp]
  00790	51		 push	 ecx
  00791	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strupr
  00797	83 c4 04	 add	 esp, 4
  0079a	50		 push	 eax
  0079b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  007a1	83 c4 08	 add	 esp, 8
  007a4	85 c0		 test	 eax, eax
  007a6	74 0c		 je	 SHORT $L199562

; 138  : 			forceUpdate = MB_OK;

  007a8	c7 85 a8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _forceUpdate$199561[ebp], 0

; 139  : 		else

  007b2	eb 0a		 jmp	 SHORT $L199564
$L199562:

; 140  : 			forceUpdate = MB_OKCANCEL;

  007b4	c7 85 a8 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _forceUpdate$199561[ebp], 1
$L199564:

; 141  : 
; 142  : 		HWND hMain = NULL;

  007be	c7 85 a8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _hMain$199565[ebp], 0

; 143  : 
; 144  : 		CUpdateTipDlg dlg;

  007c8	6a 00		 push	 0
  007ca	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _dlg$199566[ebp]
  007d0	e8 00 00 00 00	 call	 ??0CUpdateTipDlg@@QAE@PAVCWnd@@@Z ; CUpdateTipDlg::CUpdateTipDlg
  007d5	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH

; 145  : 		dlg.SetForceUpdate(forceUpdate);

  007d9	8b 95 a8 fb ff
	ff		 mov	 edx, DWORD PTR _forceUpdate$199561[ebp]
  007df	52		 push	 edx
  007e0	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _dlg$199566[ebp]
  007e6	e8 00 00 00 00	 call	 ?SetForceUpdate@CUpdateTipDlg@@QAEXH@Z ; CUpdateTipDlg::SetForceUpdate

; 146  : 		Sleep(6000); // wait for main window shown

  007eb	68 70 17 00 00	 push	 6000			; 00001770H
  007f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 147  : 		//记录当天执行日期
; 148  : 		YL_EncFileReg::WriteDWORD(HKEY_PLAYBOX_ROOT, STR_REG_UPDATE, "UPTIP_DATE", dwCurDate);

  007f6	8d 45 f0	 lea	 eax, DWORD PTR _dwCurDate$[ebp]
  007f9	50		 push	 eax
  007fa	68 00 00 00 00	 push	 OFFSET FLAT:$SG199570
  007ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _STR_REG_UPDATE
  00805	51		 push	 ecx
  00806	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0080b	e8 00 00 00 00	 call	 ?WriteDWORD@YL_EncFileReg@@SA_NPAUHKEY__@@PBD1ABI@Z ; YL_EncFileReg::WriteDWORD
  00810	83 c4 10	 add	 esp, 16			; 00000010H

; 149  : 		if(dlg.DoModal() == IDOK)

  00813	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _dlg$199566[ebp]
  00819	e8 00 00 00 00	 call	 ?DoModal@CDialog@@UAEHXZ ; CDialog::DoModal
  0081e	83 f8 01	 cmp	 eax, 1
  00821	0f 85 84 01 00
	00		 jne	 $L199571

; 150  : 		{
; 151  : 			//如果用户确认，运行安装程序
; 152  : 			YL_EncFileReg::WriteString( HKEY_PLAYBOX_ROOT, STR_REG_SOFT, "PLAYERCMD", GetCommandLine() );

  00827	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCommandLineA@0
  0082d	50		 push	 eax
  0082e	68 00 00 00 00	 push	 OFFSET FLAT:$SG199575
  00833	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _STR_REG_SOFT
  00839	52		 push	 edx
  0083a	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0083f	e8 00 00 00 00	 call	 ?WriteString@YL_EncFileReg@@SA_NPAUHKEY__@@PBD11@Z ; YL_EncFileReg::WriteString
  00844	83 c4 10	 add	 esp, 16			; 00000010H

; 153  : 			
; 154  : 			char uppath[MAX_PATH];
; 155  : 			memset(uppath, 0, MAX_PATH);

  00847	68 04 01 00 00	 push	 260			; 00000104H
  0084c	6a 00		 push	 0
  0084e	8d 85 94 f9 ff
	ff		 lea	 eax, DWORD PTR _uppath$199576[ebp]
  00854	50		 push	 eax
  00855	e8 00 00 00 00	 call	 _memset
  0085a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 			_snprintf(uppath, MAX_PATH-1, "%s\\update", dir);

  0085d	8d 8d 9c fa ff
	ff		 lea	 ecx, DWORD PTR _dir$199549[ebp]
  00863	51		 push	 ecx
  00864	68 00 00 00 00	 push	 OFFSET FLAT:$SG199577
  00869	68 03 01 00 00	 push	 259			; 00000103H
  0086e	8d 95 94 f9 ff
	ff		 lea	 edx, DWORD PTR _uppath$199576[ebp]
  00874	52		 push	 edx
  00875	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  0087b	83 c4 10	 add	 esp, 16			; 00000010H

; 157  : 			win32Showexec(setupexe, uppath, false);

  0087e	6a 00		 push	 0
  00880	8d 85 94 f9 ff
	ff		 lea	 eax, DWORD PTR _uppath$199576[ebp]
  00886	50		 push	 eax
  00887	8d 8d 24 fd ff
	ff		 lea	 ecx, DWORD PTR _setupexe$199551[ebp]
  0088d	51		 push	 ecx
  0088e	e8 00 00 00 00	 call	 ?win32Showexec@@YAPAXPBD0_N@Z ; win32Showexec
  00893	83 c4 0c	 add	 esp, 12			; 0000000cH

; 158  : 			//关闭游戏盒
; 159  : 			YL_Log(UPDATE_LOG, LOG_NOTICE, "runPopUpUpdate", "SendMessage to Close Player %s.", playerName.c_str());

  00896	68 00 00 00 00	 push	 OFFSET FLAT:$SG199581
  0089b	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200192[ebp]
  008a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  008a7	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  008ab	68 00 00 00 00	 push	 OFFSET FLAT:$SG199582
  008b0	8d 8d d4 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200193[ebp]
  008b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  008bc	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  008c0	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _playerName$[ebp]
  008c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  008cc	50		 push	 eax
  008cd	68 00 00 00 00	 push	 OFFSET FLAT:$SG199580
  008d2	8d 95 f0 f7 ff
	ff		 lea	 edx, DWORD PTR $T200192[ebp]
  008d8	52		 push	 edx
  008d9	6a 01		 push	 1
  008db	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR $T200193[ebp]
  008e1	50		 push	 eax
  008e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  008e8	83 c4 14	 add	 esp, 20			; 00000014H
  008eb	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  008ef	8d 8d d4 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200193[ebp]
  008f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  008fb	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  008ff	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200192[ebp]
  00905	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 160  : 			if(playerName == "PLAYBOX")

  0090b	68 00 00 00 00	 push	 OFFSET FLAT:$SG199584
  00910	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _playerName$[ebp]
  00916	51		 push	 ecx
  00917	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
  0091d	83 c4 08	 add	 esp, 8
  00920	0f b6 d0	 movzx	 edx, al
  00923	85 d2		 test	 edx, edx
  00925	74 14		 je	 SHORT $L199583

; 161  : 			{
; 162  : 				PostMessage(*((HWND*)pparam), WM_CLOSE, 0,0);

  00927	6a 00		 push	 0
  00929	6a 00		 push	 0
  0092b	6a 10		 push	 16			; 00000010H
  0092d	8b 45 08	 mov	 eax, DWORD PTR _pparam$[ebp]
  00930	8b 08		 mov	 ecx, DWORD PTR [eax]
  00932	51		 push	 ecx
  00933	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 163  : 			}
; 164  : 			else

  00939	eb 70		 jmp	 SHORT $L199571
$L199583:

; 165  : 			{
; 166  : 				YL_Log(UPDATE_LOG, LOG_NOTICE, "runPopUpUpdate", "OUT5==");

  0093b	68 00 00 00 00	 push	 OFFSET FLAT:$SG199590
  00940	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200194[ebp]
  00946	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0094c	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  00950	68 00 00 00 00	 push	 OFFSET FLAT:$SG199591
  00955	8d 8d 9c f7 ff
	ff		 lea	 ecx, DWORD PTR $T200195[ebp]
  0095b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00961	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  00965	68 00 00 00 00	 push	 OFFSET FLAT:$SG199589
  0096a	8d 95 b8 f7 ff
	ff		 lea	 edx, DWORD PTR $T200194[ebp]
  00970	52		 push	 edx
  00971	6a 01		 push	 1
  00973	8d 85 9c f7 ff
	ff		 lea	 eax, DWORD PTR $T200195[ebp]
  00979	50		 push	 eax
  0097a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00980	83 c4 10	 add	 esp, 16			; 00000010H
  00983	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  00987	8d 8d 9c f7 ff
	ff		 lea	 ecx, DWORD PTR $T200195[ebp]
  0098d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00993	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00997	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200194[ebp]
  0099d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 167  : 				exit(0);

  009a3	6a 00		 push	 0
  009a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$L199571:

; 168  : 			}
; 169  : 		}
; 170  : 	}

  009ab	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  009af	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _dlg$199566[ebp]
  009b5	e8 00 00 00 00	 call	 ??1CUpdateTipDlg@@UAE@XZ ; CUpdateTipDlg::~CUpdateTipDlg
$L199547:

; 171  : 	YL_Log(UPDATE_LOG, LOG_NOTICE, "runPopUpUpdate", "OUT6==");

  009ba	68 00 00 00 00	 push	 OFFSET FLAT:$SG199595
  009bf	8d 8d 80 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200196[ebp]
  009c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  009cb	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  009cf	68 00 00 00 00	 push	 OFFSET FLAT:$SG199596
  009d4	8d 8d 64 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200197[ebp]
  009da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  009e0	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  009e4	68 00 00 00 00	 push	 OFFSET FLAT:$SG199594
  009e9	8d 8d 80 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200196[ebp]
  009ef	51		 push	 ecx
  009f0	6a 01		 push	 1
  009f2	8d 95 64 f7 ff
	ff		 lea	 edx, DWORD PTR $T200197[ebp]
  009f8	52		 push	 edx
  009f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  009ff	83 c4 10	 add	 esp, 16			; 00000010H
  00a02	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  00a06	8d 8d 64 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200197[ebp]
  00a0c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00a12	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00a16	8d 8d 80 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200196[ebp]
  00a1c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 172  : }

  00a22	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00a29	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _playerName$[ebp]
  00a2f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200177:
  00a35	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00a38	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00a3f	8b 4d e8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a42	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a47	8b e5		 mov	 esp, ebp
  00a49	5d		 pop	 ebp
  00a4a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200198:
  0002e	8d 8d 78 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200178[ebp]
  00034	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200199:
  0003a	8d 8d 5c f9 ff
	ff		 lea	 ecx, DWORD PTR $T200179[ebp]
  00040	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200200:
  00046	8d 8d 40 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200180[ebp]
  0004c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200201:
  00052	8d 8d 24 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200181[ebp]
  00058	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200202:
  0005e	8d 8d 08 f9 ff
	ff		 lea	 ecx, DWORD PTR $T200182[ebp]
  00064	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200203:
  0006a	8d 8d ec f8 ff
	ff		 lea	 ecx, DWORD PTR $T200183[ebp]
  00070	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200204:
  00076	8d 8d d0 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200184[ebp]
  0007c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200205:
  00082	8d 8d b4 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200185[ebp]
  00088	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200206:
  0008e	8d 8d 98 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200186[ebp]
  00094	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200207:
  0009a	8d 8d 7c f8 ff
	ff		 lea	 ecx, DWORD PTR $T200187[ebp]
  000a0	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200208:
  000a6	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _playerName$[ebp]
  000ac	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200209:
  000b2	8d 8d 60 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200188[ebp]
  000b8	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200210:
  000be	8d 8d 44 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200189[ebp]
  000c4	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200211:
  000ca	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR $T200190[ebp]
  000d0	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200212:
  000d6	8d 8d 0c f8 ff
	ff		 lea	 ecx, DWORD PTR $T200191[ebp]
  000dc	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200213:
  000e2	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _dlg$199566[ebp]
  000e8	e9 00 00 00 00	 jmp	 ??1CUpdateTipDlg@@UAE@XZ ; CUpdateTipDlg::~CUpdateTipDlg
$L200214:
  000ed	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200192[ebp]
  000f3	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200215:
  000f9	8d 8d d4 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200193[ebp]
  000ff	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200216:
  00105	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200194[ebp]
  0010b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200217:
  00111	8d 8d 9c f7 ff
	ff		 lea	 ecx, DWORD PTR $T200195[ebp]
  00117	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200218:
  0011d	8d 8d 80 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200196[ebp]
  00123	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200219:
  00129	8d 8d 64 f7 ff
	ff		 lea	 ecx, DWORD PTR $T200197[ebp]
  0012f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?runPopUpUpdate@@YAXPAX@Z:
  00135	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200221
  0013a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?runPopUpUpdate@@YAXPAX@Z ENDP				; runPopUpUpdate
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -160						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

  00011	c7 85 60 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _ver$[ebp], 148 ; 00000094H

; 139  : 	::GetVersionEx( &ver );

  0001b	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _ver$[ebp]
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00028	83 bd 70 ff ff
	ff 02		 cmp	 DWORD PTR _ver$[ebp+16], 2
  0002f	75 15		 jne	 SHORT $L24173
  00031	83 bd 64 ff ff
	ff 05		 cmp	 DWORD PTR _ver$[ebp+4], 5
  00038	72 0c		 jb	 SHORT $L24173

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  0003a	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

  00044	eb 0a		 jmp	 SHORT $L24174
$L24173:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00046	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L24174:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  00050	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pfnGetThreadACP$[ebp]
  00056	51		 push	 ecx
  00057	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0005c	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pNew$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pp$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 93   : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$24161 = -24					; size = 4
_lcidThread$ = -20					; size = 4
_szACP$ = -16						; size = 7
__$ArrayPad$ = -8					; size = 4
_nACP$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0
  0001b	89 45 ec	 mov	 DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  0001e	6a 07		 push	 7
  00020	8d 45 f0	 lea	 eax, DWORD PTR _szACP$[ebp]
  00023	50		 push	 eax
  00024	68 04 10 00 00	 push	 4100			; 00001004H
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _lcidThread$[ebp]
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00033	85 c0		 test	 eax, eax
  00035	74 34		 je	 SHORT $L24160

; 111  : 	{
; 112  : 		char* pch = szACP;

  00037	8d 55 f0	 lea	 edx, DWORD PTR _szACP$[ebp]
  0003a	89 55 e8	 mov	 DWORD PTR _pch$24161[ebp], edx
$L24163:

; 113  : 		while (*pch != '\0')

  0003d	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00040	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00043	85 c9		 test	 ecx, ecx
  00045	74 24		 je	 SHORT $L24160

; 114  : 		{
; 115  : 			nACP *= 10;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  0004a	6b d2 0a	 imul	 edx, 10			; 0000000aH
  0004d	89 55 fc	 mov	 DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

  00050	8b 45 e8	 mov	 eax, DWORD PTR _pch$24161[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	8b 55 fc	 mov	 edx, DWORD PTR _nACP$[ebp]
  00059	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  0005d	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
  00060	8b 4d e8	 mov	 ecx, DWORD PTR _pch$24161[ebp]
  00063	83 c1 01	 add	 ecx, 1
  00066	89 4d e8	 mov	 DWORD PTR _pch$24161[ebp], ecx

; 117  : 		}

  00069	eb d2		 jmp	 SHORT $L24163
$L24160:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  0006b	83 7d fc 00	 cmp	 DWORD PTR _nACP$[ebp], 0
  0006f	75 09		 jne	 SHORT $L24165

; 121  : 		nACP = ::GetACP();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  00077	89 45 fc	 mov	 DWORD PTR _nACP$[ebp], eax
$L24165:

; 122  : 
; 123  : 	return nACP;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _nACP$[ebp]

; 124  : }

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  : 	return( CP_THREAD_ACP );

  00003	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
EXTRN	__imp__FreeLibrary@4:NEAR
EXTRN	__imp__GetProcAddress@8:NEAR
EXTRN	__imp__LoadLibraryA@4:NEAR
EXTRN	?g_hSharedWnd@@3PAUHWND__@@A:DWORD		; g_hSharedWnd
xdata$x	SEGMENT
$T200257 DD	0ffffffffH
	DD	FLAT:$L200247
	DD	00H
	DD	FLAT:$L200248
	DD	0ffffffffH
	DD	FLAT:$L200249
	DD	02H
	DD	FLAT:$L200250
	DD	0ffffffffH
	DD	FLAT:$L200251
	DD	04H
	DD	FLAT:$L200252
$T200254 DD	019930520H
	DD	06H
	DD	FLAT:$T200257
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\update.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T200246 = -792						; size = 28
$T200245 = -764						; size = 28
$T200244 = -736						; size = 28
$T200243 = -708						; size = 28
$T200242 = -680						; size = 28
$T200241 = -652						; size = 28
_lpfn$199618 = -624					; size = 4
_szsysdir$ = -620					; size = 260
_szUpdate$ = -356					; size = 260
_hLib$ = -88						; size = 4
_szPlayer$ = -84					; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pparam$ = 8						; size = 4
?realUpdate@@YAXPAX@Z PROC NEAR				; realUpdate

; 178  : {

  00a50	55		 push	 ebp
  00a51	8b ec		 mov	 ebp, esp
  00a53	6a ff		 push	 -1
  00a55	68 00 00 00 00	 push	 __ehhandler$?realUpdate@@YAXPAX@Z
  00a5a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00a60	50		 push	 eax
  00a61	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00a68	81 ec 0c 03 00
	00		 sub	 esp, 780		; 0000030cH
  00a6e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00a73	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 179  : 	YL_Log(UPDATE_LOG, LOG_NOTICE, "realUpdate", "IN==");

  00a76	68 00 00 00 00	 push	 OFFSET FLAT:$SG199607
  00a7b	8d 8d 74 fd ff
	ff		 lea	 ecx, DWORD PTR $T200241[ebp]
  00a81	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00a87	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00a8e	68 00 00 00 00	 push	 OFFSET FLAT:$SG199608
  00a93	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR $T200242[ebp]
  00a99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00a9f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00aa3	68 00 00 00 00	 push	 OFFSET FLAT:$SG199606
  00aa8	8d 85 74 fd ff
	ff		 lea	 eax, DWORD PTR $T200241[ebp]
  00aae	50		 push	 eax
  00aaf	6a 01		 push	 1
  00ab1	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR $T200242[ebp]
  00ab7	51		 push	 ecx
  00ab8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00abe	83 c4 10	 add	 esp, 16			; 00000010H
  00ac1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00ac5	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR $T200242[ebp]
  00acb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00ad1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ad8	8d 8d 74 fd ff
	ff		 lea	 ecx, DWORD PTR $T200241[ebp]
  00ade	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 180  : 
; 181  : 	char szsysdir[MAX_PATH], szUpdate[MAX_PATH], szPlayer[64];
; 182  : 	memset(szsysdir, 0 , MAX_PATH);

  00ae4	68 04 01 00 00	 push	 260			; 00000104H
  00ae9	6a 00		 push	 0
  00aeb	8d 95 94 fd ff
	ff		 lea	 edx, DWORD PTR _szsysdir$[ebp]
  00af1	52		 push	 edx
  00af2	e8 00 00 00 00	 call	 _memset
  00af7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  : 	memset(szUpdate, 0, MAX_PATH);

  00afa	68 04 01 00 00	 push	 260			; 00000104H
  00aff	6a 00		 push	 0
  00b01	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _szUpdate$[ebp]
  00b07	50		 push	 eax
  00b08	e8 00 00 00 00	 call	 _memset
  00b0d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 	memset(szPlayer, 0, 64);

  00b10	6a 40		 push	 64			; 00000040H
  00b12	6a 00		 push	 0
  00b14	8d 4d ac	 lea	 ecx, DWORD PTR _szPlayer$[ebp]
  00b17	51		 push	 ecx
  00b18	e8 00 00 00 00	 call	 _memset
  00b1d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 185  : 	_snprintf(szPlayer, 64-1, "%s", (char*)pparam);

  00b20	8b 55 08	 mov	 edx, DWORD PTR _pparam$[ebp]
  00b23	52		 push	 edx
  00b24	68 00 00 00 00	 push	 OFFSET FLAT:$SG199613
  00b29	6a 3f		 push	 63			; 0000003fH
  00b2b	8d 45 ac	 lea	 eax, DWORD PTR _szPlayer$[ebp]
  00b2e	50		 push	 eax
  00b2f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  00b35	83 c4 10	 add	 esp, 16			; 00000010H

; 186  : 
; 187  : 	if(!CLhcImg::GetHomePath(szsysdir, MAX_PATH))

  00b38	68 04 01 00 00	 push	 260			; 00000104H
  00b3d	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR _szsysdir$[ebp]
  00b43	51		 push	 ecx
  00b44	e8 00 00 00 00	 call	 ?GetHomePath@CLhcImg@@SA_NQADH@Z ; CLhcImg::GetHomePath
  00b49	83 c4 08	 add	 esp, 8
  00b4c	0f b6 d0	 movzx	 edx, al
  00b4f	85 d2		 test	 edx, edx
  00b51	75 05		 jne	 SHORT $L199614

; 188  : 	{
; 189  : 		return;

  00b53	e9 5a 01 00 00	 jmp	 $L199603
$L199614:

; 190  : 	}
; 191  : 	_snprintf(szUpdate, MAX_PATH-1, "%s\\LhUpdate.dll", szsysdir);

  00b58	8d 85 94 fd ff
	ff		 lea	 eax, DWORD PTR _szsysdir$[ebp]
  00b5e	50		 push	 eax
  00b5f	68 00 00 00 00	 push	 OFFSET FLAT:$SG199615
  00b64	68 03 01 00 00	 push	 259			; 00000103H
  00b69	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR _szUpdate$[ebp]
  00b6f	51		 push	 ecx
  00b70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  00b76	83 c4 10	 add	 esp, 16			; 00000010H

; 192  : 
; 193  : 	HMODULE hLib = LoadLibrary(szUpdate);

  00b79	8d 95 9c fe ff
	ff		 lea	 edx, DWORD PTR _szUpdate$[ebp]
  00b7f	52		 push	 edx
  00b80	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  00b86	89 45 a8	 mov	 DWORD PTR _hLib$[ebp], eax

; 194  : 	if(hLib != NULL)

  00b89	83 7d a8 00	 cmp	 DWORD PTR _hLib$[ebp], 0
  00b8d	0f 84 b1 00 00
	00		 je	 $L199617

; 195  : 	{
; 196  : 		LPCREATERECOGNISE lpfn = (LPCREATERECOGNISE)GetProcAddress(hLib, "BeginUpdate2");	

  00b93	68 00 00 00 00	 push	 OFFSET FLAT:$SG199620
  00b98	8b 45 a8	 mov	 eax, DWORD PTR _hLib$[ebp]
  00b9b	50		 push	 eax
  00b9c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00ba2	89 85 90 fd ff
	ff		 mov	 DWORD PTR _lpfn$199618[ebp], eax

; 197  : 		if(lpfn != NULL)

  00ba8	83 bd 90 fd ff
	ff 00		 cmp	 DWORD PTR _lpfn$199618[ebp], 0
  00baf	0f 84 85 00 00
	00		 je	 $L199621

; 198  : 		{
; 199  : 			YL_Log(UPDATE_LOG, LOG_NOTICE, "realUpdate", "Call BeginUpdate2.");

  00bb5	68 00 00 00 00	 push	 OFFSET FLAT:$SG199625
  00bba	8d 8d 3c fd ff
	ff		 lea	 ecx, DWORD PTR $T200243[ebp]
  00bc0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00bc6	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00bcd	68 00 00 00 00	 push	 OFFSET FLAT:$SG199626
  00bd2	8d 8d 20 fd ff
	ff		 lea	 ecx, DWORD PTR $T200244[ebp]
  00bd8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00bde	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00be2	68 00 00 00 00	 push	 OFFSET FLAT:$SG199624
  00be7	8d 8d 3c fd ff
	ff		 lea	 ecx, DWORD PTR $T200243[ebp]
  00bed	51		 push	 ecx
  00bee	6a 01		 push	 1
  00bf0	8d 95 20 fd ff
	ff		 lea	 edx, DWORD PTR $T200244[ebp]
  00bf6	52		 push	 edx
  00bf7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00bfd	83 c4 10	 add	 esp, 16			; 00000010H
  00c00	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00c04	8d 8d 20 fd ff
	ff		 lea	 ecx, DWORD PTR $T200244[ebp]
  00c0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00c10	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c17	8d 8d 3c fd ff
	ff		 lea	 ecx, DWORD PTR $T200243[ebp]
  00c1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 200  : 			lpfn(g_szSoftName, szPlayer, g_hSharedWnd);

  00c23	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hSharedWnd@@3PAUHWND__@@A ; g_hSharedWnd
  00c28	50		 push	 eax
  00c29	8d 4d ac	 lea	 ecx, DWORD PTR _szPlayer$[ebp]
  00c2c	51		 push	 ecx
  00c2d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_szSoftName
  00c33	52		 push	 edx
  00c34	ff 95 90 fd ff
	ff		 call	 DWORD PTR _lpfn$199618[ebp]
$L199621:

; 201  : 		}
; 202  : 		FreeLibrary(hLib);

  00c3a	8b 45 a8	 mov	 eax, DWORD PTR _hLib$[ebp]
  00c3d	50		 push	 eax
  00c3e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
$L199617:

; 203  : 	}
; 204  : 	YL_Log(UPDATE_LOG, LOG_NOTICE, "realUpdate", "OUT==");

  00c44	68 00 00 00 00	 push	 OFFSET FLAT:$SG199630
  00c49	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR $T200245[ebp]
  00c4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00c55	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00c5c	68 00 00 00 00	 push	 OFFSET FLAT:$SG199631
  00c61	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR $T200246[ebp]
  00c67	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00c6d	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00c71	68 00 00 00 00	 push	 OFFSET FLAT:$SG199629
  00c76	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR $T200245[ebp]
  00c7c	51		 push	 ecx
  00c7d	6a 01		 push	 1
  00c7f	8d 95 e8 fc ff
	ff		 lea	 edx, DWORD PTR $T200246[ebp]
  00c85	52		 push	 edx
  00c86	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?YL_Log@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H0PBDZZ
  00c8c	83 c4 10	 add	 esp, 16			; 00000010H
  00c8f	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00c93	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR $T200246[ebp]
  00c99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00c9f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ca6	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR $T200245[ebp]
  00cac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L199603:

; 205  : }

  00cb2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00cb5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00cbc	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cbf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cc4	8b e5		 mov	 esp, ebp
  00cc6	5d		 pop	 ebp
  00cc7	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200247:
  0013f	8d 8d 74 fd ff
	ff		 lea	 ecx, DWORD PTR $T200241[ebp]
  00145	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200248:
  0014b	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR $T200242[ebp]
  00151	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200249:
  00157	8d 8d 3c fd ff
	ff		 lea	 ecx, DWORD PTR $T200243[ebp]
  0015d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200250:
  00163	8d 8d 20 fd ff
	ff		 lea	 ecx, DWORD PTR $T200244[ebp]
  00169	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200251:
  0016f	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR $T200245[ebp]
  00175	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L200252:
  0017b	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR $T200246[ebp]
  00181	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?realUpdate@@YAXPAX@Z:
  00187	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200254
  0018c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?realUpdate@@YAXPAX@Z ENDP				; realUpdate
PUBLIC	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z	; ATL::_AtlInstallStringThunk
PUBLIC	?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableW@12:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWThunk, COMDAT

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 184  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
; 185  : 		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetEnvironmentVariableW@12
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
  0000e	68 14 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 186  : 
; 187  : 	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);

  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 0c	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  00022	52		 push	 edx
  00023	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  00026	50		 push	 eax
  00027	ff 15 14 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20

; 188  : }

  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWThunk
_TEXT	ENDS
PUBLIC	?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
PUBLIC	??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
EXTRN	__imp__GetVersion@0:NEAR
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT
?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA DB 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT
??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 DD 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
; Function compile flags: /Odt
_BSS	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT
_pfn$ = -4						; size = 4
_ppThunk$ = 8						; size = 4
_pfnWin9x$ = 12						; size = 4
_pfnNT$ = 16						; size = 4
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z PROC NEAR	; ATL::_AtlInstallStringThunk, COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 116  : #pragma warning (push)
; 117  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 118  : 
; 119  : 	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
  00009	83 e0 01	 and	 eax, 1
  0000c	75 25		 jne	 SHORT $L25641
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
  00014	83 c9 01	 or	 ecx, 1
  00017	89 0d 00 00 00
	00		 mov	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, ecx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00023	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00028	f7 d8		 neg	 eax
  0002a	1b c0		 sbb	 eax, eax
  0002c	f7 d8		 neg	 eax
  0002e	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L25641:

; 120  : 	
; 121  : #pragma warning (pop)
; 122  : 
; 123  : 	void* pfn;
; 124  : 	if (s_bWin9x)

  00033	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  0003a	85 d2		 test	 edx, edx
  0003c	74 08		 je	 SHORT $L25643

; 125  : 		pfn = pfnWin9x;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _pfnWin9x$[ebp]
  00041	89 45 fc	 mov	 DWORD PTR _pfn$[ebp], eax

; 126  : 	else

  00044	eb 06		 jmp	 SHORT $L25644
$L25643:

; 127  : 	{
; 128  : #ifdef _CSTRING_ALWAYS_THUNK
; 129  : 		pfn = pfnWin9x;
; 130  : 		(void)pfnNT;
; 131  : #else
; 132  : 		pfn = pfnNT;

  00046	8b 4d 10	 mov	 ecx, DWORD PTR _pfnNT$[ebp]
  00049	89 4d fc	 mov	 DWORD PTR _pfn$[ebp], ecx
$L25644:

; 133  : #endif
; 134  : 	}
; 135  : 	InterlockedExchangePointer(ppThunk, pfn);

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _pfn$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 08	 mov	 eax, DWORD PTR _ppThunk$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 136  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ENDP	; ATL::_AtlInstallStringThunk
_TEXT	ENDS
PUBLIC	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
PUBLIC	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
PUBLIC	??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z		; ATL::CW2AEX<128>::CW2AEX<128>
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
PUBLIC	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CW2AEX<128>::operator char *
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
EXTRN	__imp__MultiByteToWideChar@24:NEAR
EXTRN	__imp__GetEnvironmentVariableA@12:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200273 DD	0ffffffffH
	DD	FLAT:$L200267
	DD	00H
	DD	FLAT:$L200268
$T200270 DD	019930520H
	DD	02H
	DD	FLAT:$T200273
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
$T200266 = -312						; size = 4
$T200265 = -308						; size = 4
$T200264 = -304						; size = 4
_pszBufferA$ = -300					; size = 132
_nSizeW$ = -160						; size = 4
_pszNameA$ = -156					; size = 132
__$ArrayPad$ = -20					; size = 4
_nSizeA$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWFake, COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 160  : 	ULONG nSizeA;
; 161  : 	ULONG nSizeW;
; 162  : 	CTempBuffer<char> pszBufferA;

  00026	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 163  : 	CW2A pszNameA(pszName);

  00038	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  0003b	50		 push	 eax
  0003c	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ; ATL::CW2AEX<128>::CW2AEX<128>
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 164  : 
; 165  : 	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00055	e8 00 00 00 00	 call	 ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ; ATL::CW2AEX<128>::operator char *
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12
  00061	89 45 f0	 mov	 DWORD PTR _nSizeA$[ebp], eax

; 166  : 	if (nSizeA == 0)

  00064	83 7d f0 00	 cmp	 DWORD PTR _nSizeA$[ebp], 0
  00068	75 36		 jne	 SHORT $L25746

; 167  : 		return 0;

  0006a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T200264[ebp], 0
  00074	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00078	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  0007e	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  00083	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00090	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  00095	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T200264[ebp]
  0009b	e9 ee 00 00 00	 jmp	 $L25687
$L25746:

; 168  : 
; 169  : 	pszBufferA.Allocate(nSizeA*2);

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _nSizeA$[ebp]
  000a3	d1 e1		 shl	 ecx, 1
  000a5	51		 push	 ecx
  000a6	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000ac	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 170  : 	::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA);

  000b1	8b 55 f0	 mov	 edx, DWORD PTR _nSizeA$[ebp]
  000b4	52		 push	 edx
  000b5	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000bb	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000c0	50		 push	 eax
  000c1	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  000c7	e8 00 00 00 00	 call	 ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ; ATL::CW2AEX<128>::operator char *
  000cc	50		 push	 eax
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12

; 171  : 
; 172  : 	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);

  000d3	6a 00		 push	 0
  000d5	6a 00		 push	 0
  000d7	6a ff		 push	 -1
  000d9	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  000df	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  000ec	50		 push	 eax
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  000f3	89 85 60 ff ff
	ff		 mov	 DWORD PTR _nSizeW$[ebp], eax

; 173  : 	if (nSize == 0)

  000f9	83 7d 10 00	 cmp	 DWORD PTR _nSize$[ebp], 0
  000fd	75 35		 jne	 SHORT $L25748

; 174  : 		return nSizeW;

  000ff	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nSizeW$[ebp]
  00105	89 85 cc fe ff
	ff		 mov	 DWORD PTR $T200265[ebp], eax
  0010b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0010f	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00115	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00121	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00127	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  0012c	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T200265[ebp]
  00132	eb 5a		 jmp	 SHORT $L25687
$L25748:

; 175  : 	ATLASSERT(nSize >= nSizeW);
; 176  : 	::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW);

  00134	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _nSizeW$[ebp]
  0013a	51		 push	 ecx
  0013b	8b 55 0c	 mov	 edx, DWORD PTR _pszBuffer$[ebp]
  0013e	52		 push	 edx
  0013f	6a ff		 push	 -1
  00141	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00147	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  0014c	50		 push	 eax
  0014d	6a 00		 push	 0
  0014f	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00154	50		 push	 eax
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 177  : 
; 178  : 	return nSizeW;

  0015b	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nSizeW$[ebp]
  00161	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T200266[ebp], eax
  00167	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0016b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00171	e8 00 00 00 00	 call	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
  00176	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0017d	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00183	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  00188	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T200266[ebp]
$L25687:

; 179  : }

  0018e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00191	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00198	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200267:
  00000	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
$L200268:
  0000b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200270
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 158  : 	return( g_pfnGetThreadACP() );

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 159  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringW@24:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWThunk, COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 217  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CompareStringW@24
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ; ATL::CompareStringWFake
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A ; ATL::_strthunks
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : 
; 219  : 	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);

  0001b	8b 4d 1c	 mov	 ecx, DWORD PTR _nLength2$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 18	 mov	 edx, DWORD PTR _pszString2$[ebp]
  00022	52		 push	 edx
  00023	8b 45 14	 mov	 eax, DWORD PTR _nLength1$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR _pszString1$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR _lcid$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A

; 220  : }

  00039	5d		 pop	 ebp
  0003a	c2 18 00	 ret	 24			; 00000018H
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWThunk
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
PUBLIC	?AtlW2AHelper@@YGPADPADPB_WHI@Z			; AtlW2AHelper
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
EXTRN	__imp__lstrlenW@4:NEAR
EXTRN	__imp__CompareStringA@24:NEAR
EXTRN	__alloca_probe:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200296 DD	0ffffffffH
	DD	FLAT:$L200291
$T200293 DD	019930520H
	DD	01H
	DD	FLAT:$T200296
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
tv147 = -68						; size = 4
tv142 = -64						; size = 4
tv149 = -60						; size = 4
tv89 = -56						; size = 4
tv84 = -52						; size = 4
tv91 = -48						; size = 4
$T200290 = -44						; size = 4
_pszAString1$ = -40					; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__convert_ex$ = -32					; size = 4
__acp_ex$ = -28						; size = 4
_pszAString2$ = -24					; size = 4
__lpw_ex$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWFake, COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 38	 sub	 esp, 56			; 00000038H

; 193  : 	USES_CONVERSION_EX;

  0001b	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00020	89 45 e4	 mov	 DWORD PTR __acp_ex$[ebp], eax
  00023	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 194  : 	
; 195  : 	LPCSTR pszAString1 = NULL;

  00032	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pszAString1$[ebp], 0

; 196  : 	if(pszString1 != NULL)

  00039	83 7d 10 00	 cmp	 DWORD PTR _pszString1$[ebp], 0
  0003d	0f 84 98 00 00
	00		 je	 $L25772

; 197  : 	{
; 198  : 		pszAString1 = W2A_EX(pszString1,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00043	8b 45 10	 mov	 eax, DWORD PTR _pszString1$[ebp]
  00046	89 45 f0	 mov	 DWORD PTR __lpw_ex$[ebp], eax
  00049	83 7d f0 00	 cmp	 DWORD PTR __lpw_ex$[ebp], 0
  0004d	75 09		 jne	 SHORT $L200284
  0004f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
  00056	eb 6d		 jmp	 SHORT $L200285
$L200284:
  00058	8b 4d f0	 mov	 ecx, DWORD PTR __lpw_ex$[ebp]
  0005b	51		 push	 ecx
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00062	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00066	89 55 e0	 mov	 DWORD PTR __convert_ex$[ebp], edx
  00069	81 7d e0 00 04
	00 00		 cmp	 DWORD PTR __convert_ex$[ebp], 1024 ; 00000400H
  00070	7f 2c		 jg	 SHORT $L200282
  00072	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0007b	83 c4 04	 add	 esp, 4
  0007e	0f b6 c8	 movzx	 ecx, al
  00081	85 c9		 test	 ecx, ecx
  00083	74 19		 je	 SHORT $L200282
  00085	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00088	83 c0 03	 add	 eax, 3
  0008b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008e	e8 00 00 00 00	 call	 __alloca_probe
  00093	89 65 cc	 mov	 DWORD PTR tv84[ebp], esp
  00096	8b 55 cc	 mov	 edx, DWORD PTR tv84[ebp]
  00099	89 55 c8	 mov	 DWORD PTR tv89[ebp], edx
  0009c	eb 0f		 jmp	 SHORT $L200283
$L200282:
  0009e	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  000a1	50		 push	 eax
  000a2	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000a5	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  000aa	89 45 c8	 mov	 DWORD PTR tv89[ebp], eax
$L200283:
  000ad	8b 4d e4	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 e0	 mov	 edx, DWORD PTR __convert_ex$[ebp]
  000b4	52		 push	 edx
  000b5	8b 45 f0	 mov	 eax, DWORD PTR __lpw_ex$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d c8	 mov	 ecx, DWORD PTR tv89[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  000c2	89 45 d0	 mov	 DWORD PTR tv91[ebp], eax
$L200285:
  000c5	8b 55 d0	 mov	 edx, DWORD PTR tv91[ebp]
  000c8	89 55 d8	 mov	 DWORD PTR _pszAString1$[ebp], edx

; 199  : 		if(pszAString1 == NULL)

  000cb	83 7d d8 00	 cmp	 DWORD PTR _pszAString1$[ebp], 0
  000cf	75 0a		 jne	 SHORT $L25772

; 200  : 			AtlThrow(E_OUTOFMEMORY);

  000d1	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  000d6	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L25772:

; 201  : 	}
; 202  : 
; 203  : 	LPCSTR pszAString2 = NULL;

  000db	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pszAString2$[ebp], 0

; 204  : 	if(pszString2 != NULL)

  000e2	83 7d 18 00	 cmp	 DWORD PTR _pszString2$[ebp], 0
  000e6	0f 84 98 00 00
	00		 je	 $L25778

; 205  : 	{
; 206  : 		pszAString2 = W2A_EX(pszString2,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  000ec	8b 45 18	 mov	 eax, DWORD PTR _pszString2$[ebp]
  000ef	89 45 f0	 mov	 DWORD PTR __lpw_ex$[ebp], eax
  000f2	83 7d f0 00	 cmp	 DWORD PTR __lpw_ex$[ebp], 0
  000f6	75 09		 jne	 SHORT $L200288
  000f8	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv149[ebp], 0
  000ff	eb 6d		 jmp	 SHORT $L200289
$L200288:
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __lpw_ex$[ebp]
  00104	51		 push	 ecx
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0010b	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  0010f	89 55 e0	 mov	 DWORD PTR __convert_ex$[ebp], edx
  00112	81 7d e0 00 04
	00 00		 cmp	 DWORD PTR __convert_ex$[ebp], 1024 ; 00000400H
  00119	7f 2c		 jg	 SHORT $L200286
  0011b	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  00124	83 c4 04	 add	 esp, 4
  00127	0f b6 c8	 movzx	 ecx, al
  0012a	85 c9		 test	 ecx, ecx
  0012c	74 19		 je	 SHORT $L200286
  0012e	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  00131	83 c0 03	 add	 eax, 3
  00134	83 e0 fc	 and	 eax, -4			; fffffffcH
  00137	e8 00 00 00 00	 call	 __alloca_probe
  0013c	89 65 c0	 mov	 DWORD PTR tv142[ebp], esp
  0013f	8b 55 c0	 mov	 edx, DWORD PTR tv142[ebp]
  00142	89 55 bc	 mov	 DWORD PTR tv147[ebp], edx
  00145	eb 0f		 jmp	 SHORT $L200287
$L200286:
  00147	8b 45 e0	 mov	 eax, DWORD PTR __convert_ex$[ebp]
  0014a	50		 push	 eax
  0014b	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  0014e	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  00153	89 45 bc	 mov	 DWORD PTR tv147[ebp], eax
$L200287:
  00156	8b 4d e4	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  00159	51		 push	 ecx
  0015a	8b 55 e0	 mov	 edx, DWORD PTR __convert_ex$[ebp]
  0015d	52		 push	 edx
  0015e	8b 45 f0	 mov	 eax, DWORD PTR __lpw_ex$[ebp]
  00161	50		 push	 eax
  00162	8b 4d bc	 mov	 ecx, DWORD PTR tv147[ebp]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0016b	89 45 c4	 mov	 DWORD PTR tv149[ebp], eax
$L200289:
  0016e	8b 55 c4	 mov	 edx, DWORD PTR tv149[ebp]
  00171	89 55 e8	 mov	 DWORD PTR _pszAString2$[ebp], edx

; 207  : 		if(pszAString2 == NULL)

  00174	83 7d e8 00	 cmp	 DWORD PTR _pszAString2$[ebp], 0
  00178	75 0a		 jne	 SHORT $L25778

; 208  : 			AtlThrow(E_OUTOFMEMORY);

  0017a	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0017f	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L25778:

; 209  : 	}
; 210  : 
; 211  : 	return ::CompareStringA(lcid, dwFlags, pszAString1, nLength1, pszAString2, nLength2);

  00184	8b 45 1c	 mov	 eax, DWORD PTR _nLength2$[ebp]
  00187	50		 push	 eax
  00188	8b 4d e8	 mov	 ecx, DWORD PTR _pszAString2$[ebp]
  0018b	51		 push	 ecx
  0018c	8b 55 14	 mov	 edx, DWORD PTR _nLength1$[ebp]
  0018f	52		 push	 edx
  00190	8b 45 d8	 mov	 eax, DWORD PTR _pszAString1$[ebp]
  00193	50		 push	 eax
  00194	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00197	51		 push	 ecx
  00198	8b 55 08	 mov	 edx, DWORD PTR _lcid$[ebp]
  0019b	52		 push	 edx
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CompareStringA@24
  001a2	89 45 d4	 mov	 DWORD PTR $T200290[ebp], eax
  001a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001ac	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  001af	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  001b4	8b 45 d4	 mov	 eax, DWORD PTR $T200290[ebp]
$L200281:

; 212  : }

  001b7	8d 65 bc	 lea	 esp, DWORD PTR [ebp-68]
  001ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200291:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200293
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWFake
EXTRN	__imp___resetstkoflw:NEAR
EXTRN	__except_handler3:NEAR
;	COMDAT CONST
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
CONST	SEGMENT
$T200307 DD	0ffffffffH
	DD	FLAT:$L200302
	DD	FLAT:$L200303
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
tv65 = -40						; size = 4
$T200306 = -36						; size = 4
_p$24118 = -32						; size = 4
_bStackAvailable$ = -25					; size = 1
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 OFFSET FLAT:$T200307
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:__except_handler3
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00015	50		 push	 eax
  00016	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001d	83 c4 e8	 add	 esp, -24		; ffffffe8H
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 332  :     bool bStackAvailable = true;

  00026	c6 45 e7 01	 mov	 BYTE PTR _bStackAvailable$[ebp], 1

; 333  : 
; 334  :     __try

  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 335  :     {
; 336  :         PVOID p = _alloca(Size + _ATL_STACK_MARGIN);

  00031	8b 45 08	 mov	 eax, DWORD PTR _Size$[ebp]
  00034	05 03 20 00 00	 add	 eax, 8195		; 00002003H
  00039	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003c	e8 00 00 00 00	 call	 __alloca_probe
  00041	89 65 d8	 mov	 DWORD PTR tv65[ebp], esp
  00044	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00047	8b 45 d8	 mov	 eax, DWORD PTR tv65[ebp]
  0004a	89 45 e0	 mov	 DWORD PTR _p$24118[ebp], eax
  0004d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00054	eb 2c		 jmp	 SHORT $L200305
$L200302:
$L200311:

; 337  :         (p);
; 338  :     }
; 339  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 340  :                    EXCEPTION_EXECUTE_HANDLER :
; 341  :                    EXCEPTION_CONTINUE_SEARCH)

  00056	8b 4d ec	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+4]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8b 02		 mov	 eax, DWORD PTR [edx]
  0005d	89 45 dc	 mov	 DWORD PTR $T200306[ebp], eax
  00060	8b 45 dc	 mov	 eax, DWORD PTR $T200306[ebp]
  00063	2d fd 00 00 c0	 sub	 eax, -1073741571	; c00000fdH
  00068	f7 d8		 neg	 eax
  0006a	1b c0		 sbb	 eax, eax
  0006c	40		 inc	 eax
$L200304:
$L200310:
  0006d	c3		 ret	 0
$L200303:
  0006e	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 342  :     {
; 343  :         bStackAvailable = false;

  00071	c6 45 e7 00	 mov	 BYTE PTR _bStackAvailable$[ebp], 0

; 344  :         _resetstkoflw();

  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___resetstkoflw
  0007b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$L200305:

; 345  :     }
; 346  :     return bStackAvailable;

  00082	8a 45 e7	 mov	 al, BYTE PTR _bStackAvailable$[ebp]
$L200301:

; 347  : }

  00085	8d 65 cc	 lea	 esp, DWORD PTR [ebp-52]
  00088	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
EXTRN	__imp__WideCharToMultiByte@32:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPB_WHI@Z PROC NEAR		; AtlW2AHelper, COMDAT

; 573  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 574  : 	ATLASSERT(lpw != NULL);
; 575  : 	ATLASSERT(lpa != NULL);
; 576  : 	if (lpa == NULL || lpw == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpa$[ebp], 0
  00008	74 06		 je	 SHORT $L24319
  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpw$[ebp], 0
  0000e	75 04		 jne	 SHORT $L24318
$L24319:

; 577  : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 34		 jmp	 SHORT $L24315
$L24318:

; 578  : 	// verify that no illegal character present
; 579  : 	// since lpa was allocated based on the size of lpw
; 580  : 	// don't worry about the number of chars
; 581  : 	lpa[0] = '\0';

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpa$[ebp]
  00017	c6 00 00	 mov	 BYTE PTR [eax], 0

; 582  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR _nChars$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _lpa$[ebp]
  00025	52		 push	 edx
  00026	6a ff		 push	 -1
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lpw$[ebp]
  0002b	50		 push	 eax
  0002c	6a 00		 push	 0
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _acp$[ebp]
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00038	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 583  : 	if(ret == 0)

  0003b	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0003f	75 04		 jne	 SHORT $L24321

; 584  : 	{
; 585  : 		ATLASSERT(FALSE);
; 586  : 		return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	eb 03		 jmp	 SHORT $L24315
$L24321:

; 587  : 	}
; 588  : 	return lpa;

  00045	8b 45 08	 mov	 eax, DWORD PTR _lpa$[ebp]
$L24315:

; 589  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 10 00	 ret	 16			; 00000010H
?AtlW2AHelper@@YGPADPADPB_WHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00003	81 7d 08 0e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
  0000a	75 05		 jne	 SHORT $L24681

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000c	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L24681:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00011	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L200317:

; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );
; 74   : #endif
; 75   : };

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExW@20:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWThunk, COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 241  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetStringTypeExW@20
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ; ATL::GetStringTypeExWFake
  0000e	68 04 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  : 
; 243  : 	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);

  0001b	8b 4d 18	 mov	 ecx, DWORD PTR _pwCharType$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 14	 mov	 edx, DWORD PTR _nLength$[ebp]
  00022	52		 push	 edx
  00023	8b 45 10	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _dwInfoType$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _lcid$[ebp]
  0002e	52		 push	 edx
  0002f	ff 15 04 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4

; 244  : }

  00035	5d		 pop	 ebp
  00036	c2 14 00	 ret	 20			; 00000014H
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z ENDP	; ATL::GetStringTypeExWThunk
_TEXT	ENDS
EXTRN	__imp__GetStringTypeExA@20:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T200329 DD	0ffffffffH
	DD	FLAT:$L200324
$T200326 DD	019930520H
	DD	01H
	DD	FLAT:$T200329
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
$T200323 = -164						; size = 4
_nLengthA$ = -160					; size = 4
_pszA$ = -156						; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWFake, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 225  : 	int nLengthA;
; 226  : 	CTempBuffer<char> pszA;

  00026	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 227  : 
; 228  : 	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	8b 45 14	 mov	 eax, DWORD PTR _nLength$[ebp]
  00043	50		 push	 eax
  00044	8b 4d 10	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  00047	51		 push	 ecx
  00048	6a 00		 push	 0
  0004a	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00056	89 85 60 ff ff
	ff		 mov	 DWORD PTR _nLengthA$[ebp], eax

; 229  : 	pszA.Allocate(nLengthA);

  0005c	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _nLengthA$[ebp]
  00062	52		 push	 edx
  00063	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  00069	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 230  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _nLengthA$[ebp]
  00078	50		 push	 eax
  00079	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  0007f	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  00084	50		 push	 eax
  00085	8b 4d 14	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 10	 mov	 edx, DWORD PTR _pszSrc$[ebp]
  0008c	52		 push	 edx
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 231  : 
; 232  : 	if (nLength == -1)

  0009b	83 7d 14 ff	 cmp	 DWORD PTR _nLength$[ebp], -1
  0009f	75 0a		 jne	 SHORT $L25804

; 233  : 		nLengthA = -1;

  000a1	c7 85 60 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _nLengthA$[ebp], -1
$L25804:

; 234  : 
; 235  : 	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);

  000ab	8b 45 18	 mov	 eax, DWORD PTR _pwCharType$[ebp]
  000ae	50		 push	 eax
  000af	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _nLengthA$[ebp]
  000b5	51		 push	 ecx
  000b6	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  000bc	e8 00 00 00 00	 call	 ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
  000c1	50		 push	 eax
  000c2	8b 55 0c	 mov	 edx, DWORD PTR _dwInfoType$[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 08	 mov	 eax, DWORD PTR _lcid$[ebp]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStringTypeExA@20
  000d0	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T200323[ebp], eax
  000d6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000dd	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  000e3	e8 00 00 00 00	 call	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
  000e8	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T200323[ebp]

; 236  : }

  000ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L200324:
  00000	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200326
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ENDP		; ATL::GetStringTypeExWFake
PUBLIC	?lstrcmpiWFake@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiW@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWThunk, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 255  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__lstrcmpiW@8
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?lstrcmpiWFake@ATL@@YGHPB_W0@Z ; ATL::lstrcmpiWFake
  0000e	68 08 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 256  : 
; 257  : 	return _strthunks.pfnlstrcmpiW(psz1, psz2);

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _psz2$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _psz1$[ebp]
  00022	52		 push	 edx
  00023	ff 15 08 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8

; 258  : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWThunk
_TEXT	ENDS
EXTRN	__imp__lstrcmpiA@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv94 = -28						; size = 4
tv76 = -24						; size = 4
tv79 = -20						; size = 4
__acp$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWFake@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWFake, COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 248  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f4	 mov	 DWORD PTR __acp$[ebp], eax

; 249  : 
; 250  : 	return ::lstrcmpiA(W2A(psz1), W2A(psz2));

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _psz2$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L200336
  0001a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L200337
$L200336:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e8	 mov	 DWORD PTR tv76[ebp], esp
  00045	8b 45 f4	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e8	 mov	 eax, DWORD PTR tv76[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
$L200337:
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _psz1$[ebp]
  00060	89 4d f8	 mov	 DWORD PTR __lpw$[ebp], ecx
  00063	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00067	75 09		 jne	 SHORT $L200338
  00069	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00070	eb 3a		 jmp	 SHORT $L200339
$L200338:
  00072	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00075	52		 push	 edx
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0007c	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00080	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00083	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008c	e8 00 00 00 00	 call	 __alloca_probe
  00091	89 65 e0	 mov	 DWORD PTR tv91[ebp], esp
  00094	8b 4d f4	 mov	 ecx, DWORD PTR __acp$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 fc	 mov	 edx, DWORD PTR __convert$[ebp]
  0009b	52		 push	 edx
  0009c	8b 45 f8	 mov	 eax, DWORD PTR __lpw$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d e0	 mov	 ecx, DWORD PTR tv91[ebp]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  000a9	89 45 e4	 mov	 DWORD PTR tv94[ebp], eax
$L200339:
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000af	52		 push	 edx
  000b0	8b 45 e4	 mov	 eax, DWORD PTR tv94[ebp]
  000b3	50		 push	 eax
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8

; 251  : }

  000ba	8d 65 e0	 lea	 esp, DWORD PTR [ebp-32]
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
?lstrcmpiWFake@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWFake
_TEXT	ENDS
PUBLIC	?CharLowerWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWFake
EXTRN	__imp__CharLowerW@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWThunk, COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 274  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharLowerW@4
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CharLowerWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharLowerWFake
  0000e	68 0c 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  : 
; 276  : 	return _strthunks.pfnCharLowerW(psz);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 15 0c 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12

; 277  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWThunk
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z		; AtlA2WHelper
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	__imp__CharLowerA@4:NEAR
EXTRN	__imp__wcscpy:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
__lpa$ = -20						; size = 4
__acp$ = -16						; size = 4
_pszA$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWFake, COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 262  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f0	 mov	 DWORD PTR __acp$[ebp], eax

; 263  : 	LPSTR pszA;
; 264  : 
; 265  : 	pszA = W2A(psz);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L200344
  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L200345
$L200344:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e4	 mov	 DWORD PTR tv75[ebp], esp
  00045	8b 45 f0	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$L200345:
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00060	89 4d f4	 mov	 DWORD PTR _pszA$[ebp], ecx

; 266  : 	::CharLowerA(pszA);

  00063	8b 55 f4	 mov	 edx, DWORD PTR _pszA$[ebp]
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharLowerA@4

; 267  : 	wcscpy(psz, A2W(pszA));

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _pszA$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR __lpa$[ebp], eax
  00073	83 7d ec 00	 cmp	 DWORD PTR __lpa$[ebp], 0
  00077	75 09		 jne	 SHORT $L200346
  00079	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00080	eb 3b		 jmp	 SHORT $L200347
$L200346:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00092	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00095	d1 e0		 shl	 eax, 1
  00097	83 c0 03	 add	 eax, 3
  0009a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0009d	e8 00 00 00 00	 call	 __alloca_probe
  000a2	89 65 dc	 mov	 DWORD PTR tv90[ebp], esp
  000a5	8b 55 f0	 mov	 edx, DWORD PTR __acp$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  000ba	89 45 e0	 mov	 DWORD PTR tv94[ebp], eax
$L200347:
  000bd	8b 45 e0	 mov	 eax, DWORD PTR tv94[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  000c4	51		 push	 ecx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000cb	83 c4 08	 add	 esp, 8

; 268  : 
; 269  : 	return psz;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]

; 270  : }

  000d1	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z PROC NEAR		; AtlA2WHelper, COMDAT

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 555  : 	ATLASSERT(lpa != NULL);
; 556  : 	ATLASSERT(lpw != NULL);
; 557  : 	if (lpw == NULL || lpa == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpw$[ebp], 0
  00008	74 06		 je	 SHORT $L24306
  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpa$[ebp], 0
  0000e	75 04		 jne	 SHORT $L24305
$L24306:

; 558  : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 32		 jmp	 SHORT $L24302
$L24305:

; 559  : 	// verify that no illegal character present
; 560  : 	// since lpw was allocated based on the size of lpa
; 561  : 	// don't worry about the number of chars
; 562  : 	lpw[0] = '\0';

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
  00017	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 563  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _nChars$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 08	 mov	 edx, DWORD PTR _lpw$[ebp]
  00023	52		 push	 edx
  00024	6a ff		 push	 -1
  00026	8b 45 0c	 mov	 eax, DWORD PTR _lpa$[ebp]
  00029	50		 push	 eax
  0002a	6a 00		 push	 0
  0002c	8b 4d 14	 mov	 ecx, DWORD PTR _acp$[ebp]
  0002f	51		 push	 ecx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00036	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 564  : 	if(ret == 0)

  00039	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0003d	75 04		 jne	 SHORT $L24308

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);
; 567  : 		return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	eb 03		 jmp	 SHORT $L24302
$L24308:

; 568  : 	}		
; 569  : 	return lpw;

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpw$[ebp]
$L24302:

; 570  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?CharUpperWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWFake
EXTRN	__imp__CharUpperW@4:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWThunk, COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharUpperW@4
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET FLAT:?CharUpperWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharUpperWFake
  0000e	68 10 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
  00013	e8 00 00 00 00	 call	 ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 294  : 
; 295  : 	return _strthunks.pfnCharUpperW(psz);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 15 10 00 00
	00		 call	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16

; 296  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWThunk
_TEXT	ENDS
EXTRN	__imp__CharUpperA@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
__lpa$ = -20						; size = 4
__acp$ = -16						; size = 4
_pszA$ = -12						; size = 4
__lpw$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWFake, COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 281  : 	USES_CONVERSION;

  00006	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  0000b	89 45 f0	 mov	 DWORD PTR __acp$[ebp], eax

; 282  : 	LPSTR pszA;
; 283  : 
; 284  : 	pszA = W2A(psz);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __lpw$[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR __lpw$[ebp], 0
  00018	75 09		 jne	 SHORT $L200354
  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00021	eb 3a		 jmp	 SHORT $L200355
$L200354:
  00023	8b 4d f8	 mov	 ecx, DWORD PTR __lpw$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0002d	8d 54 00 02	 lea	 edx, DWORD PTR [eax+eax+2]
  00031	89 55 fc	 mov	 DWORD PTR __convert$[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00037	83 c0 03	 add	 eax, 3
  0003a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003d	e8 00 00 00 00	 call	 __alloca_probe
  00042	89 65 e4	 mov	 DWORD PTR tv75[ebp], esp
  00045	8b 45 f0	 mov	 eax, DWORD PTR __acp$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR __convert$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 f8	 mov	 edx, DWORD PTR __lpw$[ebp]
  00050	52		 push	 edx
  00051	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0005a	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$L200355:
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00060	89 4d f4	 mov	 DWORD PTR _pszA$[ebp], ecx

; 285  : 	::CharUpperA(pszA);

  00063	8b 55 f4	 mov	 edx, DWORD PTR _pszA$[ebp]
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharUpperA@4

; 286  : 	wcscpy(psz, A2W(pszA));

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _pszA$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR __lpa$[ebp], eax
  00073	83 7d ec 00	 cmp	 DWORD PTR __lpa$[ebp], 0
  00077	75 09		 jne	 SHORT $L200356
  00079	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00080	eb 3b		 jmp	 SHORT $L200357
$L200356:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR __convert$[ebp], eax
  00092	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  00095	d1 e0		 shl	 eax, 1
  00097	83 c0 03	 add	 eax, 3
  0009a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0009d	e8 00 00 00 00	 call	 __alloca_probe
  000a2	89 65 dc	 mov	 DWORD PTR tv90[ebp], esp
  000a5	8b 55 f0	 mov	 edx, DWORD PTR __acp$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 fc	 mov	 eax, DWORD PTR __convert$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __lpa$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper
  000ba	89 45 e0	 mov	 DWORD PTR tv94[ebp], eax
$L200357:
  000bd	8b 45 e0	 mov	 eax, DWORD PTR tv94[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  000c4	51		 push	 ecx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000cb	83 c4 08	 add	 esp, 8

; 287  : 
; 288  : 	return psz;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]

; 289  : }

  000d1	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWFake
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 373  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
; Function compile flags: /Odt
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = -4						; size = 4
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 375  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));

  00009	8b 45 08	 mov	 eax, DWORD PTR _nRequestedSize$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 377  : 		if (p == NULL)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0001f	75 04		 jne	 SHORT $L191833

; 378  : 			return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	eb 1a		 jmp	 SHORT $L191820
$L191833:

; 379  : 		
; 380  : 		// Add buffer to the list
; 381  : 		p->m_pNext = m_pHead;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00028	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	89 01		 mov	 DWORD PTR [ecx], eax

; 382  : 		m_pHead = p;

  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00035	89 11		 mov	 DWORD PTR [ecx], edx

; 383  : 		
; 384  : 		return p->GetData();

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
$L191820:

; 385  : 	}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
EXTRN	__imp__malloc:NEAR
; Function compile flags: /Odt
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC NEAR		; ATL::CCRTAllocator::Allocate, COMDAT

; 30   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 		return malloc(nBytes);

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0000d	83 c4 04	 add	 esp, 4

; 32   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
; Function compile flags: /Odt
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$191839 = -4						; size = 4
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 387  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$L191837:

; 388  : 		// Walk the list and free the buffers
; 389  : 		while (m_pHead != NULL)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 22		 je	 SHORT $L191835

; 390  : 		{
; 391  : 			CAtlSafeAllocBufferNode* p = m_pHead;

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 fc	 mov	 DWORD PTR _p$191839[ebp], edx

; 392  : 			m_pHead = m_pHead->m_pNext;

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	89 02		 mov	 DWORD PTR [edx], eax

; 393  : 			Allocator::Free(p);

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _p$191839[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  0002e	83 c4 04	 add	 esp, 4

; 394  : 		}

  00031	eb d6		 jmp	 SHORT $L191837
$L191835:

; 395  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
EXTRN	__imp__free:NEAR
; Function compile flags: /Odt
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC NEAR		; ATL::CCRTAllocator::Free, COMDAT

; 35   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   : 		free(p);

  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000d	83 c4 04	 add	 esp, 4

; 37   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 217  : 	}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	39 01		 cmp	 DWORD PTR [ecx], eax
  00012	74 08		 je	 SHORT $L191843

; 227  : 		{
; 228  : 			FreeHeap();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L191843:

; 229  : 		}
; 230  : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 233  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 235  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z		; ATL::CW2AEX<128>::Init
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z PROC NEAR		; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 419  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	89 01		 mov	 DWORD PTR [ecx], eax

; 420  : 		Init( psz, _AtlGetConversionACP() );

  00012	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00017	50		 push	 eax
  00018	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  0001b	52		 push	 edx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init

; 421  : 	}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC NEAR			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 428  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 429  : 		if( m_psz != m_szBuffer )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	39 01		 cmp	 DWORD PTR [ecx], eax
  00012	74 0f		 je	 SHORT $L191854

; 430  : 		{
; 431  : 			free( m_psz );

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 02		 mov	 eax, DWORD PTR [edx]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00020	83 c4 04	 add	 esp, 4
$L191854:

; 432  : 		}
; 433  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC NEAR		; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 436  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 437  : 		return( m_psz );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 438  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );
; 278  : 		if( nBytes > t_nFixedBytes )

  00007	81 7d 08 80 00
	00 00		 cmp	 DWORD PTR _nBytes$[ebp], 128 ; 00000080H
  0000e	76 0e		 jbe	 SHORT $L193612

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

  00010	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

  0001c	eb 0b		 jmp	 SHORT $L193613
$L193612:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 04	 add	 ecx, 4
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	89 0a		 mov	 DWORD PTR [edx], ecx
$L193613:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]

; 288  : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  00012	83 c4 04	 add	 esp, 4

; 314  : 	}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nLengthW$ = -8						; size = 4
_nLengthA$ = -4						; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z PROC NEAR		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 442  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 443  : 		if (psz == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  0000d	75 0b		 jne	 SHORT $L193619

; 444  : 		{
; 445  : 			m_psz = NULL;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 446  : 			return;

  00018	eb 70		 jmp	 SHORT $L200387
$L193619:

; 447  : 		}
; 448  : 		int nLengthW = lstrlenW( psz )+1;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001d	51		 push	 ecx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00024	83 c0 01	 add	 eax, 1
  00027	89 45 f8	 mov	 DWORD PTR _nLengthW$[ebp], eax

; 449  : 		int nLengthA = nLengthW*2;

  0002a	8b 55 f8	 mov	 edx, DWORD PTR _nLengthW$[ebp]
  0002d	d1 e2		 shl	 edx, 1
  0002f	89 55 fc	 mov	 DWORD PTR _nLengthA$[ebp], edx

; 450  : 
; 451  : 		if( nLengthA > t_nBufferLength )

  00032	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _nLengthA$[ebp], 128 ; 00000080H
  00039	7e 24		 jle	 SHORT $L193622

; 452  : 		{
; 453  : 			m_psz = static_cast< LPSTR >( malloc( nLengthA*sizeof( char ) ) );

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _nLengthA$[ebp]
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00045	83 c4 04	 add	 esp, 4
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 454  : 			if (m_psz == NULL)

  0004d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00050	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00053	75 0a		 jne	 SHORT $L193622

; 455  : 			{
; 456  : 				AtlThrow( E_OUTOFMEMORY );

  00055	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0005a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L193622:

; 457  : 			}
; 458  : 		}
; 459  : 
; 460  : 		if (::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ) == 0)

  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	8b 45 fc	 mov	 eax, DWORD PTR _nLengthA$[ebp]
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	52		 push	 edx
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _nLengthW$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  00074	51		 push	 ecx
  00075	6a 00		 push	 0
  00077	8b 55 0c	 mov	 edx, DWORD PTR _nCodePage$[ebp]
  0007a	52		 push	 edx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00081	85 c0		 test	 eax, eax
  00083	75 05		 jne	 SHORT $L200387

; 461  : 		{
; 462  : 			AtlThrowLastWin32();

  00085	e8 00 00 00 00	 call	 ?AtlThrowLastWin32@ATL@@YGXXZ ; ATL::AtlThrowLastWin32
$L200387:

; 463  : 		}
; 464  : 	}

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ENDP		; ATL::CW2AEX<128>::Init
_TEXT	ENDS
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_dwError$ = -4						; size = 4
?AtlThrowLastWin32@ATL@@YGXXZ PROC NEAR			; ATL::AtlThrowLastWin32, COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 81   : 	DWORD dwError = ::GetLastError();

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0000c	89 45 fc	 mov	 DWORD PTR _dwError$[ebp], eax

; 82   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

  0000f	83 7d fc 00	 cmp	 DWORD PTR _dwError$[ebp], 0
  00013	7f 08		 jg	 SHORT $L200390
  00015	8b 45 fc	 mov	 eax, DWORD PTR _dwError$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001b	eb 18		 jmp	 SHORT $L200391
$L200390:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _dwError$[ebp]
  00020	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00026	81 c9 00 00 07
	00		 or	 ecx, 458752		; 00070000H
  0002c	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  00032	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
$L200391:
  00035	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L200389:

; 83   : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 365  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 366  : 			return (this + 1);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8

; 367  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00009	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

  00018	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0001c	75 0a		 jne	 SHORT $L194985

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

  0001e	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00023	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L194985:

; 297  : 		}
; 298  : 		m_p = p;

  00028	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0002e	89 11		 mov	 DWORD PTR [ecx], edx
$L200395:

; 299  : 	}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
CRT$XCU	SEGMENT
_$S6	DD	FLAT:_$E5
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\appconfig\config\configappdef.h
CRT$XCU	ENDS
;	COMDAT _$E5
text$yc	SEGMENT
_$E5	PROC NEAR					; COMDAT

; 19   : 	CONF_APP_SWF_PATH,			TYPE_CONFIG_STR,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_APP_SWF_PATH
  00008	a3 00 00 00 00	 mov	 DWORD PTR _CONF_APP, eax
  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_STR
  00013	89 0d 04 00 00
	00		 mov	 DWORD PTR _CONF_APP+4, ecx

; 20   : 	CONF_APP_MAINWND_HOLD,		TYPE_CONFIG_BOOL,

  00019	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_APP_MAINWND_HOLD
  0001f	89 15 08 00 00
	00		 mov	 DWORD PTR _CONF_APP+8, edx
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_BOOL
  0002a	a3 0c 00 00 00	 mov	 DWORD PTR _CONF_APP+12, eax

; 21   : 	CONF_APP_RUN_COUNT,			TYPE_CONFIG_INT,

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_APP_RUN_COUNT
  00035	89 0d 10 00 00
	00		 mov	 DWORD PTR _CONF_APP+16, ecx
  0003b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_INT
  00041	89 15 14 00 00
	00		 mov	 DWORD PTR _CONF_APP+20, edx

; 22   : 	CONF_APP_PLAYED_GAME,		TYPE_CONFIG_INT,

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_APP_PLAYED_GAME
  0004c	a3 18 00 00 00	 mov	 DWORD PTR _CONF_APP+24, eax
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_INT
  00057	89 0d 1c 00 00
	00		 mov	 DWORD PTR _CONF_APP+28, ecx

; 23   : 	CONF_APP_PLAYED_PC_GAME,	TYPE_CONFIG_INT,

  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_APP_PLAYED_PC_GAME
  00063	89 15 20 00 00
	00		 mov	 DWORD PTR _CONF_APP+32, edx
  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_INT
  0006e	a3 24 00 00 00	 mov	 DWORD PTR _CONF_APP+36, eax

; 24   : 	CONF_APP_PLAYED_ICON_SIZE,	TYPE_CONFIG_INT, //玩过的游戏panel显示icon的大小0,1,2

  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_APP_PLAYED_ICON_SIZE
  00079	89 0d 28 00 00
	00		 mov	 DWORD PTR _CONF_APP+40, ecx
  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_INT
  00085	89 15 2c 00 00
	00		 mov	 DWORD PTR _CONF_APP+44, edx

; 25   : 	CONF_APP_PIC_SAVE_PATH,		TYPE_CONFIG_STR

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_APP_PIC_SAVE_PATH
  00090	a3 30 00 00 00	 mov	 DWORD PTR _CONF_APP+48, eax

; 26   : };

  00095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_STR
  0009b	89 0d 34 00 00
	00		 mov	 DWORD PTR _CONF_APP+52, ecx
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
_$E5	ENDP
text$yc	ENDS
CRT$XCU	SEGMENT
_$S8	DD	FLAT:_$E7
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\appconfig\config\configsettingdef.h
CRT$XCU	ENDS
;	COMDAT _$E7
text$yc	SEGMENT
_$E7	PROC NEAR					; COMDAT

; 25   : 	CONF_SETTING_SKIN_IDX,				TYPE_CONFIG_STR,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_SETTING_SKIN_IDX
  00008	a3 00 00 00 00	 mov	 DWORD PTR _CONF_SETTING, eax
  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_STR
  00013	89 0d 04 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+4, ecx

; 26   : 	CONF_SETTING_CONFIG_MAIN_PAGE,		TYPE_CONFIG_STR,

  00019	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_SETTING_CONFIG_MAIN_PAGE
  0001f	89 15 08 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+8, edx
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_STR
  0002a	a3 0c 00 00 00	 mov	 DWORD PTR _CONF_SETTING+12, eax

; 27   : 	CONF_SETTING_CONFIG_PROBLEM_REPORT,	TYPE_CONFIG_STR,

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_SETTING_CONFIG_PROBLEM_REPORT
  00035	89 0d 10 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+16, ecx
  0003b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_STR
  00041	89 15 14 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+20, edx

; 28   : 	CONF_SETTING_CONFIG_HOME_PAGE,		TYPE_CONFIG_STR,

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_SETTING_CONFIG_HOME_PAGE
  0004c	a3 18 00 00 00	 mov	 DWORD PTR _CONF_SETTING+24, eax
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_STR
  00057	89 0d 1c 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+28, ecx

; 29   : 	CONF_SETTING_CONFIG_IFASKEXIT,		TYPE_CONFIG_BOOL,

  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_SETTING_CONFIG_IFASKEXIT
  00063	89 15 20 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+32, edx
  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_BOOL
  0006e	a3 24 00 00 00	 mov	 DWORD PTR _CONF_SETTING+36, eax

; 30   : 	CONF_SETTING_CONFIG_EXITCHOICE,		TYPE_CONFIG_BOOL,

  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_SETTING_CONFIG_EXITCHOICE
  00079	89 0d 28 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+40, ecx
  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_BOOL
  00085	89 15 2c 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+44, edx

; 31   : 	CONF_SETTING_LOGIN_USER_NAME,		TYPE_CONFIG_STR,

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_SETTING_LOGIN_USER_NAME
  00090	a3 30 00 00 00	 mov	 DWORD PTR _CONF_SETTING+48, eax
  00095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_STR
  0009b	89 0d 34 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+52, ecx

; 32   : 	CONF_SETTING_LOGIN_PASSWORD,		TYPE_CONFIG_STR,

  000a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_SETTING_LOGIN_PASSWORD
  000a7	89 15 38 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+56, edx
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_STR
  000b2	a3 3c 00 00 00	 mov	 DWORD PTR _CONF_SETTING+60, eax

; 33   : 	CONF_SETTING_NETID,					TYPE_CONFIG_STR,

  000b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_SETTING_NETID
  000bd	89 0d 40 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+64, ecx
  000c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_STR
  000c9	89 15 44 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+68, edx

; 34   : 	CONF_SETTING_COLOR,					TYPE_CONFIG_INT,

  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_SETTING_COLOR
  000d4	a3 48 00 00 00	 mov	 DWORD PTR _CONF_SETTING+72, eax
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_INT
  000df	89 0d 4c 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+76, ecx

; 35   : 	CONF_SETTING_LIGHT,					TYPE_CONFIG_INT,

  000e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_SETTING_LIGHT
  000eb	89 15 50 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+80, edx
  000f1	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_INT
  000f6	a3 54 00 00 00	 mov	 DWORD PTR _CONF_SETTING+84, eax

; 36   : 	CONF_SETTING_COLOR_BTN_INDEX,		TYPE_CONFIG_INT,

  000fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CONF_SETTING_COLOR_BTN_INDEX
  00101	89 0d 58 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+88, ecx
  00107	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TYPE_CONFIG_INT
  0010d	89 15 5c 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+92, edx

; 37   : 	CONF_SETTING_COLOR_USER,			TYPE_CONFIG_INT,

  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR _CONF_SETTING_COLOR_USER
  00118	a3 60 00 00 00	 mov	 DWORD PTR _CONF_SETTING+96, eax
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TYPE_CONFIG_INT
  00123	89 0d 64 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+100, ecx

; 38   : 	CONF_SETTING_FIRST_TIME_CHANGESKIN, TYPE_CONFIG_BOOL

  00129	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CONF_SETTING_FIRST_TIME_CHANGESKIN
  0012f	89 15 68 00 00
	00		 mov	 DWORD PTR _CONF_SETTING+104, edx

; 39   : };

  00135	a1 00 00 00 00	 mov	 eax, DWORD PTR _TYPE_CONFIG_BOOL
  0013a	a3 6c 00 00 00	 mov	 DWORD PTR _CONF_SETTING+108, eax
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
_$E7	ENDP
text$yc	ENDS
_BSS	SEGMENT
_CONF_APP DD	0eH DUP (?)
_CONF_SETTING DD 01cH DUP (?)
_BSS	ENDS
END
