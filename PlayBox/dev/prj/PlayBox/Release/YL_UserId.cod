; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\boxgit\PlayBox\CommonLib\common\YL_UserId.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@HHDGIIFB@0123456789abcdefABCDEF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@_W@std@@YAD_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@_WDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0IPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@D@std@@YADDABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVdomain_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVrange_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@codecvt_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@_WDH@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4underflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4overflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVunderflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4domain_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_exception@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4invalid_argument@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$codecvt@_WDH@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4range_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_exception@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$codecvt@_WDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R2invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVinvalid_argument@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVoverflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
CONST	SEGMENT
$SG55235 DB	'YPLAYBOX', 00H
CONST	ENDS
_DATA	SEGMENT
_g_szSoftName DD FLAT:$SG55235
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG55237 DB	'SOFTWARE\YPLAYBOX', 00H
CONST	ENDS
_DATA	SEGMENT
_STR_REG_SOFT DD FLAT:$SG55237
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG55239 DB	'S', 00H, 'O', 00H, 'F', 00H, 'T', 00H, 'W', 00H, 'A', 00H
	DB	'R', 00H, 'E', 00H, '\', 00H, 'Y', 00H, 'P', 00H, 'L', 00H, 'A'
	DB	00H, 'Y', 00H, 'B', 00H, 'O', 00H, 'X', 00H, 00H, 00H
CONST	ENDS
_DATA	SEGMENT
_STR_WCHAR_REG_SOFT DD FLAT:$SG55239
_DATA	ENDS
CONST	SEGMENT
$SG55241 DB	'SOFTWARE\YPLAYBOX\LOGMSG', 00H
CONST	ENDS
_DATA	SEGMENT
_STR_REG_SOFT_MSG DD FLAT:$SG55241
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG55243 DB	'SOFTWARE\YPLAYBOX\UPDATE', 00H
CONST	ENDS
_DATA	SEGMENT
_STR_REG_UPDATE DD FLAT:$SG55243
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG55245 DB	'SOFTWARE\YPLAYBOX\BHO', 00H
CONST	ENDS
_DATA	SEGMENT
_STR_REG_BHO DD	FLAT:$SG55245
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG55247 DB	'path', 00H
CONST	ENDS
_DATA	SEGMENT
_STR_SOFT_HOME_KEY DD FLAT:$SG55247
_DATA	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
CONST	SEGMENT
	ORG $+3
$SG64498 DB	'userfile', 00H
	ORG $+3
$SG64499 DB	'Config', 00H
	ORG $+1
$SG64509 DB	'\', 00H
	ORG $+2
$SG64519 DB	'r', 00H
	ORG $+2
$SG64524 DB	'%s', 00H
	ORG $+1
$SG64536 DB	'w', 00H
	ORG $+2
$SG64537 DB	'%s', 0dH, 00H
$SG64538 DB	'%s', 0dH, 00H
$SG64548 DB	'r', 00H
	ORG $+2
$SG64556 DB	'%s', 00H
	ORG $+1
$SG64569 DB	'w', 00H
	ORG $+2
$SG64570 DB	'%s', 0dH, 00H
$SG64571 DB	'%s', 0dH, 00H
CONST	ENDS
PUBLIC	?GetUserFileName@YL_UserId@@SA_NQADH@Z		; YL_UserId::GetUserFileName
EXTRN	__imp__GetPrivateProfileStringA@24:NEAR
EXTRN	_memset:NEAR
EXTRN	_strlen:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	?GetConfigPath@CLhcImg@@SA_NQADH@Z:NEAR		; CLhcImg::GetConfigPath
; Function compile flags: /Odt
; File d:\boxgit\playbox\commonlib\common\yl_userid.cpp
_TEXT	SEGMENT
_path$ = -272						; size = 260
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szFileName$ = 8					; size = 4
_namelen$ = 12						; size = 4
?GetUserFileName@YL_UserId@@SA_NQADH@Z PROC NEAR	; YL_UserId::GetUserFileName

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 11   : 	char path[MAX_PATH];
; 12   : 	memset(szFileName, 0, namelen);

  00011	8b 45 0c	 mov	 eax, DWORD PTR _namelen$[ebp]
  00014	50		 push	 eax
  00015	6a 00		 push	 0
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _szFileName$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _memset
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13   : 	if(!CLhcImg::GetConfigPath(path, MAX_PATH))

  00023	68 04 01 00 00	 push	 260			; 00000104H
  00028	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ?GetConfigPath@CLhcImg@@SA_NQADH@Z ; CLhcImg::GetConfigPath
  00034	83 c4 08	 add	 esp, 8
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	75 04		 jne	 SHORT $L64496

; 14   : 		return false;

  0003e	32 c0		 xor	 al, al
  00040	eb 49		 jmp	 SHORT $L64494
$L64496:

; 15   : 
; 16   : 	if(GetPrivateProfileString("Config", "userfile", NULL, szFileName, namelen, path) == 0)

  00042	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00048	51		 push	 ecx
  00049	8b 55 0c	 mov	 edx, DWORD PTR _namelen$[ebp]
  0004c	52		 push	 edx
  0004d	8b 45 08	 mov	 eax, DWORD PTR _szFileName$[ebp]
  00050	50		 push	 eax
  00051	6a 00		 push	 0
  00053	68 00 00 00 00	 push	 OFFSET FLAT:$SG64498
  00058	68 00 00 00 00	 push	 OFFSET FLAT:$SG64499
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24
  00063	85 c0		 test	 eax, eax
  00065	75 04		 jne	 SHORT $L64497

; 17   : 	{
; 18   : 		//g7kk.dat
; 19   : 		return false;

  00067	32 c0		 xor	 al, al
  00069	eb 20		 jmp	 SHORT $L64494
$L64497:

; 20   : 	}
; 21   : 
; 22   : 	if(strlen(szFileName) <= 0)

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _szFileName$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _strlen
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	77 04		 ja	 SHORT $L64500

; 23   : 		return false;

  0007b	32 c0		 xor	 al, al
  0007d	eb 0c		 jmp	 SHORT $L64494
$L64500:

; 24   : 	szFileName[namelen-1] = '\0';

  0007f	8b 55 08	 mov	 edx, DWORD PTR _szFileName$[ebp]
  00082	03 55 0c	 add	 edx, DWORD PTR _namelen$[ebp]
  00085	c6 42 ff 00	 mov	 BYTE PTR [edx-1], 0

; 25   : 	return true;

  00089	b0 01		 mov	 al, 1
$L64494:

; 26   : }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?GetUserFileName@YL_UserId@@SA_NQADH@Z ENDP		; YL_UserId::GetUserFileName
_TEXT	ENDS
PUBLIC	?GetUserFilePath@YL_UserId@@SA_NQADH@Z		; YL_UserId::GetUserFilePath
EXTRN	_strcpy:NEAR
EXTRN	_strcat:NEAR
EXTRN	__imp__GetSystemDirectoryA@8:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_szUserFileName$ = -536					; size = 260
_szSystemPath$ = -272					; size = 260
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szFilePath$ = 8					; size = 4
_pathlen$ = 12						; size = 4
?GetUserFilePath@YL_UserId@@SA_NQADH@Z PROC NEAR	; YL_UserId::GetUserFilePath

; 29   : {

  000a0	55		 push	 ebp
  000a1	8b ec		 mov	 ebp, esp
  000a3	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000ae	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 30   : 	CHAR szSystemPath[MAX_PATH], szUserFileName[MAX_PATH];
; 31   : 	memset(szFilePath, 0, pathlen);

  000b1	8b 45 0c	 mov	 eax, DWORD PTR _pathlen$[ebp]
  000b4	50		 push	 eax
  000b5	6a 00		 push	 0
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _szFilePath$[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _memset
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32   : 	memset(szSystemPath, 0, MAX_PATH);

  000c3	68 04 01 00 00	 push	 260			; 00000104H
  000c8	6a 00		 push	 0
  000ca	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _szSystemPath$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 _memset
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33   : 	memset(szUserFileName, 0, MAX_PATH);

  000d9	68 04 01 00 00	 push	 260			; 00000104H
  000de	6a 00		 push	 0
  000e0	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _szUserFileName$[ebp]
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _memset
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 34   : 	if( GetSystemDirectory(szSystemPath, MAX_PATH) == 0 )

  000ef	68 04 01 00 00	 push	 260			; 00000104H
  000f4	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _szSystemPath$[ebp]
  000fa	51		 push	 ecx
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemDirectoryA@8
  00101	85 c0		 test	 eax, eax
  00103	75 04		 jne	 SHORT $L64507

; 35   : 	{				
; 36   : 		return false;

  00105	32 c0		 xor	 al, al
  00107	eb 58		 jmp	 SHORT $L64504
$L64507:

; 37   : 	}
; 38   : 
; 39   : 	if(!GetUserFileName(szUserFileName, MAX_PATH))

  00109	68 04 01 00 00	 push	 260			; 00000104H
  0010e	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _szUserFileName$[ebp]
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 ?GetUserFileName@YL_UserId@@SA_NQADH@Z ; YL_UserId::GetUserFileName
  0011a	83 c4 08	 add	 esp, 8
  0011d	0f b6 c0	 movzx	 eax, al
  00120	85 c0		 test	 eax, eax
  00122	75 04		 jne	 SHORT $L64508

; 40   : 	{
; 41   : 		return false;

  00124	32 c0		 xor	 al, al
  00126	eb 39		 jmp	 SHORT $L64504
$L64508:

; 42   : 	}
; 43   : 
; 44   : 	strcpy(szFilePath, szSystemPath);

  00128	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _szSystemPath$[ebp]
  0012e	51		 push	 ecx
  0012f	8b 55 08	 mov	 edx, DWORD PTR _szFilePath$[ebp]
  00132	52		 push	 edx
  00133	e8 00 00 00 00	 call	 _strcpy
  00138	83 c4 08	 add	 esp, 8

; 45   : 	strcat(szFilePath, "\\");

  0013b	68 00 00 00 00	 push	 OFFSET FLAT:$SG64509
  00140	8b 45 08	 mov	 eax, DWORD PTR _szFilePath$[ebp]
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 _strcat
  00149	83 c4 08	 add	 esp, 8

; 46   : 	strcat(szFilePath, szUserFileName);

  0014c	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _szUserFileName$[ebp]
  00152	51		 push	 ecx
  00153	8b 55 08	 mov	 edx, DWORD PTR _szFilePath$[ebp]
  00156	52		 push	 edx
  00157	e8 00 00 00 00	 call	 _strcat
  0015c	83 c4 08	 add	 esp, 8

; 47   : 	return true;

  0015f	b0 01		 mov	 al, 1
$L64504:

; 48   : }

  00161	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00164	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
?GetUserFilePath@YL_UserId@@SA_NQADH@Z ENDP		; YL_UserId::GetUserFilePath
_TEXT	ENDS
PUBLIC	?GetUserID@YL_UserId@@SA_NQADH@Z		; YL_UserId::GetUserID
EXTRN	__imp__fclose:NEAR
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
EXTRN	__imp__fgets:NEAR
EXTRN	__imp__fopen:NEAR
EXTRN	__imp_?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z:NEAR
EXTRN	__imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z:NEAR
EXTRN	__imp___snprintf:NEAR
EXTRN	__imp__atoi:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T68492	DD	0ffffffffH
	DD	FLAT:$L68483
	DD	00H
	DD	FLAT:$L68484
$T68488	DD	019930520H
	DD	02H
	DD	FLAT:$T68492
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T68482 = -614						; size = 1
$T68481 = -613						; size = 1
_szTemp$ = -612						; size = 260
_file$ = -344						; size = 4
_temp$ = -340						; size = 28
_index$ = -312						; size = 4
_szDesFilePath$ = -308					; size = 260
_id$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_szID$ = 8						; size = 4
_idlen$ = 12						; size = 4
?GetUserID@YL_UserId@@SA_NQADH@Z PROC NEAR		; YL_UserId::GetUserID

; 51   : {

  00170	55		 push	 ebp
  00171	8b ec		 mov	 ebp, esp
  00173	6a ff		 push	 -1
  00175	68 00 00 00 00	 push	 __ehhandler$?GetUserID@YL_UserId@@SA_NQADH@Z
  0017a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00180	50		 push	 eax
  00181	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00188	81 ec 5c 02 00
	00		 sub	 esp, 604		; 0000025cH
  0018e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00193	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 52   : 	memset(szID, 0, idlen);

  00196	8b 45 0c	 mov	 eax, DWORD PTR _idlen$[ebp]
  00199	50		 push	 eax
  0019a	6a 00		 push	 0
  0019c	8b 4d 08	 mov	 ecx, DWORD PTR _szID$[ebp]
  0019f	51		 push	 ecx
  001a0	e8 00 00 00 00	 call	 _memset
  001a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 53   : 	CHAR szTemp[MAX_PATH], szDesFilePath[MAX_PATH];
; 54   : 	if(!GetUserFilePath(szDesFilePath, MAX_PATH)) //g7kk.dat

  001a8	68 04 01 00 00	 push	 260			; 00000104H
  001ad	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR _szDesFilePath$[ebp]
  001b3	52		 push	 edx
  001b4	e8 00 00 00 00	 call	 ?GetUserFilePath@YL_UserId@@SA_NQADH@Z ; YL_UserId::GetUserFilePath
  001b9	83 c4 08	 add	 esp, 8
  001bc	0f b6 c0	 movzx	 eax, al
  001bf	85 c0		 test	 eax, eax
  001c1	75 07		 jne	 SHORT $L64516

; 55   : 	{
; 56   : 		return false;

  001c3	32 c0		 xor	 al, al
  001c5	e9 66 01 00 00	 jmp	 $L64513
$L64516:

; 57   : 	}
; 58   : 
; 59   : 	FILE* file;
; 60   : 	if( (file = fopen( szDesFilePath, "r")) == NULL )

  001ca	68 00 00 00 00	 push	 OFFSET FLAT:$SG64519
  001cf	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _szDesFilePath$[ebp]
  001d5	51		 push	 ecx
  001d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  001dc	83 c4 08	 add	 esp, 8
  001df	89 85 a8 fe ff
	ff		 mov	 DWORD PTR _file$[ebp], eax
  001e5	83 bd a8 fe ff
	ff 00		 cmp	 DWORD PTR _file$[ebp], 0
  001ec	75 07		 jne	 SHORT $L64518

; 61   : 	{		
; 62   : 		return false;

  001ee	32 c0		 xor	 al, al
  001f0	e9 3b 01 00 00	 jmp	 $L64513
$L64518:

; 63   : 	}
; 64   : 
; 65   : 	memset(szTemp, 0, MAX_PATH);

  001f5	68 04 01 00 00	 push	 260			; 00000104H
  001fa	6a 00		 push	 0
  001fc	8d 95 9c fd ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00202	52		 push	 edx
  00203	e8 00 00 00 00	 call	 _memset
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH

; 66   : 	fgets( szTemp, MAX_PATH, file );

  0020b	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  00211	50		 push	 eax
  00212	68 04 01 00 00	 push	 260			; 00000104H
  00217	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0021d	51		 push	 ecx
  0021e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgets
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH

; 67   : 	fclose( file );

  00227	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _file$[ebp]
  0022d	52		 push	 edx
  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00234	83 c4 04	 add	 esp, 4

; 68   : 	string temp(szTemp);

  00237	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0023d	50		 push	 eax
  0023e	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0024a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 69   : 	string::size_type index = temp.find_first_of('\r');

  00251	6a 00		 push	 0
  00253	6a 0d		 push	 13			; 0000000dH
  00255	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z
  00261	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _index$[ebp], eax

; 70   : 	string id = temp.substr(0, index);

  00267	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _index$[ebp]
  0026d	51		 push	 ecx
  0026e	6a 00		 push	 0
  00270	8d 55 d4	 lea	 edx, DWORD PTR _id$[ebp]
  00273	52		 push	 edx
  00274	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  0027a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  00280	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 71   : 	_snprintf(szID, idlen-1, "%s", id.c_str());

  00284	8d 4d d4	 lea	 ecx, DWORD PTR _id$[ebp]
  00287	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0028d	50		 push	 eax
  0028e	68 00 00 00 00	 push	 OFFSET FLAT:$SG64524
  00293	8b 45 0c	 mov	 eax, DWORD PTR _idlen$[ebp]
  00296	83 e8 01	 sub	 eax, 1
  00299	50		 push	 eax
  0029a	8b 4d 08	 mov	 ecx, DWORD PTR _szID$[ebp]
  0029d	51		 push	 ecx
  0029e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  002a4	83 c4 10	 add	 esp, 16			; 00000010H

; 72   : 	szID[idlen-1] = '\0';

  002a7	8b 55 08	 mov	 edx, DWORD PTR _szID$[ebp]
  002aa	03 55 0c	 add	 edx, DWORD PTR _idlen$[ebp]
  002ad	c6 42 ff 00	 mov	 BYTE PTR [edx-1], 0

; 73   : 
; 74   : 	if( atoi( szID ) <= 0 )

  002b1	8b 45 08	 mov	 eax, DWORD PTR _szID$[ebp]
  002b4	50		 push	 eax
  002b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  002bb	83 c4 04	 add	 esp, 4
  002be	85 c0		 test	 eax, eax
  002c0	7f 41		 jg	 SHORT $L64525

; 75   : 	{
; 76   : 		memset(szID, 0, idlen);

  002c2	8b 4d 0c	 mov	 ecx, DWORD PTR _idlen$[ebp]
  002c5	51		 push	 ecx
  002c6	6a 00		 push	 0
  002c8	8b 55 08	 mov	 edx, DWORD PTR _szID$[ebp]
  002cb	52		 push	 edx
  002cc	e8 00 00 00 00	 call	 _memset
  002d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 77   : 		return false;

  002d4	c6 85 9b fd ff
	ff 00		 mov	 BYTE PTR $T68481[ebp], 0
  002db	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002df	8d 4d d4	 lea	 ecx, DWORD PTR _id$[ebp]
  002e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  002e8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002ef	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  002f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  002fb	8a 85 9b fd ff
	ff		 mov	 al, BYTE PTR $T68481[ebp]
  00301	eb 2d		 jmp	 SHORT $L64513
$L64525:

; 78   : 	}
; 79   : 
; 80   : 	return true;

  00303	c6 85 9a fd ff
	ff 01		 mov	 BYTE PTR $T68482[ebp], 1
  0030a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0030e	8d 4d d4	 lea	 ecx, DWORD PTR _id$[ebp]
  00311	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00317	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0031e	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00324	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0032a	8a 85 9a fd ff
	ff		 mov	 al, BYTE PTR $T68482[ebp]
$L64513:

; 81   : }

  00330	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00333	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0033a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00342	8b e5		 mov	 esp, ebp
  00344	5d		 pop	 ebp
  00345	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L68483:
  00000	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68484:
  0000c	8d 4d d4	 lea	 ecx, DWORD PTR _id$[ebp]
  0000f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetUserID@YL_UserId@@SA_NQADH@Z:
  00015	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68488
  0001a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetUserID@YL_UserId@@SA_NQADH@Z ENDP			; YL_UserId::GetUserID
PUBLIC	?SetUserID@YL_UserId@@SA_NPBD@Z			; YL_UserId::SetUserID
PUBLIC	?GetInstallSRC@YL_UserId@@SA_NQADH@Z		; YL_UserId::GetInstallSRC
EXTRN	__imp__fprintf:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_szSRC$ = -408						; size = 128
_file$ = -276						; size = 4
_szUserFilePath$ = -272					; size = 260
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szID$ = 8						; size = 4
?SetUserID@YL_UserId@@SA_NPBD@Z PROC NEAR		; YL_UserId::SetUserID

; 84   : {

  00350	55		 push	 ebp
  00351	8b ec		 mov	 ebp, esp
  00353	81 ec 98 01 00
	00		 sub	 esp, 408		; 00000198H
  00359	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0035e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 85   : 	char szUserFilePath[MAX_PATH], szSRC[SRC_LENGTH];
; 86   : 	if(!GetUserFilePath(szUserFilePath, MAX_PATH))

  00361	68 04 01 00 00	 push	 260			; 00000104H
  00366	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szUserFilePath$[ebp]
  0036c	50		 push	 eax
  0036d	e8 00 00 00 00	 call	 ?GetUserFilePath@YL_UserId@@SA_NQADH@Z ; YL_UserId::GetUserFilePath
  00372	83 c4 08	 add	 esp, 8
  00375	0f b6 c8	 movzx	 ecx, al
  00378	85 c9		 test	 ecx, ecx
  0037a	75 07		 jne	 SHORT $L64533

; 87   : 	{
; 88   : 		return false;

  0037c	32 c0		 xor	 al, al
  0037e	e9 83 00 00 00	 jmp	 $L64530
$L64533:

; 89   : 	}
; 90   : 	GetInstallSRC(szSRC, SRC_LENGTH);

  00383	68 80 00 00 00	 push	 128			; 00000080H
  00388	8d 95 68 fe ff
	ff		 lea	 edx, DWORD PTR _szSRC$[ebp]
  0038e	52		 push	 edx
  0038f	e8 00 00 00 00	 call	 ?GetInstallSRC@YL_UserId@@SA_NQADH@Z ; YL_UserId::GetInstallSRC
  00394	83 c4 08	 add	 esp, 8

; 91   : 
; 92   : 	FILE *file;
; 93   : 	if( (file = fopen( szUserFilePath, "w")) == NULL )

  00397	68 00 00 00 00	 push	 OFFSET FLAT:$SG64536
  0039c	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szUserFilePath$[ebp]
  003a2	50		 push	 eax
  003a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  003a9	83 c4 08	 add	 esp, 8
  003ac	89 85 ec fe ff
	ff		 mov	 DWORD PTR _file$[ebp], eax
  003b2	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _file$[ebp], 0
  003b9	75 04		 jne	 SHORT $L64535

; 94   : 	{
; 95   : 		return false;

  003bb	32 c0		 xor	 al, al
  003bd	eb 47		 jmp	 SHORT $L64530
$L64535:

; 96   : 	}	
; 97   : 	fprintf(file, "%s\r", szID);

  003bf	8b 4d 08	 mov	 ecx, DWORD PTR _szID$[ebp]
  003c2	51		 push	 ecx
  003c3	68 00 00 00 00	 push	 OFFSET FLAT:$SG64537
  003c8	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _file$[ebp]
  003ce	52		 push	 edx
  003cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  003d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 98   : 	fprintf(file, "%s\r", szSRC);

  003d8	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _szSRC$[ebp]
  003de	50		 push	 eax
  003df	68 00 00 00 00	 push	 OFFSET FLAT:$SG64538
  003e4	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _file$[ebp]
  003ea	51		 push	 ecx
  003eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  003f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 99   : 	fclose( file );

  003f4	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _file$[ebp]
  003fa	52		 push	 edx
  003fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00401	83 c4 04	 add	 esp, 4

; 100  : 	return true;

  00404	b0 01		 mov	 al, 1
$L64530:

; 101  : }

  00406	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00409	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040e	8b e5		 mov	 esp, ebp
  00410	5d		 pop	 ebp
  00411	c3		 ret	 0
?SetUserID@YL_UserId@@SA_NPBD@Z ENDP			; YL_UserId::SetUserID
_TEXT	ENDS
EXTRN	__imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z:NEAR
EXTRN	__imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
xdata$x	SEGMENT
$T68507	DD	0ffffffffH
	DD	FLAT:$L68501
	DD	00H
	DD	FLAT:$L68502
$T68504	DD	019930520H
	DD	02H
	DD	FLAT:$T68507
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
_TEXT	SEGMENT
$T68500 = -618						; size = 1
$T68499 = -617						; size = 1
_src$ = -616						; size = 28
_szTemp$ = -588						; size = 260
_file$ = -320						; size = 4
_temp$ = -316						; size = 28
_index$ = -288						; size = 4
_szDesFilePath$ = -284					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_szSRC$ = 8						; size = 4
_srclen$ = 12						; size = 4
?GetInstallSRC@YL_UserId@@SA_NQADH@Z PROC NEAR		; YL_UserId::GetInstallSRC

; 104  : {

  00420	55		 push	 ebp
  00421	8b ec		 mov	 ebp, esp
  00423	6a ff		 push	 -1
  00425	68 00 00 00 00	 push	 __ehhandler$?GetInstallSRC@YL_UserId@@SA_NQADH@Z
  0042a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00430	50		 push	 eax
  00431	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00438	81 ec 60 02 00
	00		 sub	 esp, 608		; 00000260H
  0043e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00443	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 105  : 	memset(szSRC, 0, srclen);

  00446	8b 45 0c	 mov	 eax, DWORD PTR _srclen$[ebp]
  00449	50		 push	 eax
  0044a	6a 00		 push	 0
  0044c	8b 4d 08	 mov	 ecx, DWORD PTR _szSRC$[ebp]
  0044f	51		 push	 ecx
  00450	e8 00 00 00 00	 call	 _memset
  00455	83 c4 0c	 add	 esp, 12			; 0000000cH

; 106  : 	CHAR szTemp[MAX_PATH], szDesFilePath[MAX_PATH];
; 107  : 	if(!GetUserFilePath(szDesFilePath, MAX_PATH))

  00458	68 04 01 00 00	 push	 260			; 00000104H
  0045d	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _szDesFilePath$[ebp]
  00463	52		 push	 edx
  00464	e8 00 00 00 00	 call	 ?GetUserFilePath@YL_UserId@@SA_NQADH@Z ; YL_UserId::GetUserFilePath
  00469	83 c4 08	 add	 esp, 8
  0046c	0f b6 c0	 movzx	 eax, al
  0046f	85 c0		 test	 eax, eax
  00471	75 07		 jne	 SHORT $L64545

; 108  : 	{
; 109  : 		return false;

  00473	32 c0		 xor	 al, al
  00475	e9 de 01 00 00	 jmp	 $L64542
$L64545:

; 110  : 	}
; 111  : 
; 112  : 	FILE* file;
; 113  : 	if( (file = fopen( szDesFilePath,"r")) == NULL )

  0047a	68 00 00 00 00	 push	 OFFSET FLAT:$SG64548
  0047f	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _szDesFilePath$[ebp]
  00485	51		 push	 ecx
  00486	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0048c	83 c4 08	 add	 esp, 8
  0048f	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _file$[ebp], eax
  00495	83 bd c0 fe ff
	ff 00		 cmp	 DWORD PTR _file$[ebp], 0
  0049c	75 07		 jne	 SHORT $L64547

; 114  : 	{		
; 115  : 		return false;

  0049e	32 c0		 xor	 al, al
  004a0	e9 b3 01 00 00	 jmp	 $L64542
$L64547:

; 116  : 	}
; 117  : 	// ID, 
; 118  : 	memset(szTemp, 0, MAX_PATH);

  004a5	68 04 01 00 00	 push	 260			; 00000104H
  004aa	6a 00		 push	 0
  004ac	8d 95 b4 fd ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  004b2	52		 push	 edx
  004b3	e8 00 00 00 00	 call	 _memset
  004b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 119  : 	fgets( szTemp, MAX_PATH, file );

  004bb	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  004c1	50		 push	 eax
  004c2	68 04 01 00 00	 push	 260			; 00000104H
  004c7	8d 8d b4 fd ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  004cd	51		 push	 ecx
  004ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgets
  004d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 120  : 	fclose( file );

  004d7	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _file$[ebp]
  004dd	52		 push	 edx
  004de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  004e4	83 c4 04	 add	 esp, 4

; 121  : 
; 122  : 	string temp(szTemp);

  004e7	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  004ed	50		 push	 eax
  004ee	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  004f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  004fa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 123  : 	string::size_type index = temp.find_first_of('\r');

  00501	6a 00		 push	 0
  00503	6a 0d		 push	 13			; 0000000dH
  00505	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  0050b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z
  00511	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _index$[ebp], eax

; 124  : 	string src = temp.substr(index+1, temp.length()-index-1);

  00517	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  0051d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00523	2b 85 e0 fe ff
	ff		 sub	 eax, DWORD PTR _index$[ebp]
  00529	83 e8 01	 sub	 eax, 1
  0052c	50		 push	 eax
  0052d	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _index$[ebp]
  00533	83 c1 01	 add	 ecx, 1
  00536	51		 push	 ecx
  00537	8d 95 98 fd ff
	ff		 lea	 edx, DWORD PTR _src$[ebp]
  0053d	52		 push	 edx
  0053e	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00544	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
  0054a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 125  : 	if(src.length() <= 0 || (src.length() == 1 && src[0] == '\r'))

  0054e	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _src$[ebp]
  00554	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  0055a	85 c0		 test	 eax, eax
  0055c	76 27		 jbe	 SHORT $L64554
  0055e	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _src$[ebp]
  00564	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  0056a	83 f8 01	 cmp	 eax, 1
  0056d	75 4b		 jne	 SHORT $L64553
  0056f	6a 00		 push	 0
  00571	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _src$[ebp]
  00577	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
  0057d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00580	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00583	75 35		 jne	 SHORT $L64553
$L64554:

; 126  : 		return false;

  00585	c6 85 97 fd ff
	ff 00		 mov	 BYTE PTR $T68499[ebp], 0
  0058c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00590	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _src$[ebp]
  00596	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0059c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  005a3	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  005a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  005af	8a 85 97 fd ff
	ff		 mov	 al, BYTE PTR $T68499[ebp]
  005b5	e9 9e 00 00 00	 jmp	 $L64542
$L64553:

; 127  : 	
; 128  : 	_snprintf(szSRC, srclen-1, "%s", src.c_str());

  005ba	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _src$[ebp]
  005c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  005c6	50		 push	 eax
  005c7	68 00 00 00 00	 push	 OFFSET FLAT:$SG64556
  005cc	8b 4d 0c	 mov	 ecx, DWORD PTR _srclen$[ebp]
  005cf	83 e9 01	 sub	 ecx, 1
  005d2	51		 push	 ecx
  005d3	8b 55 08	 mov	 edx, DWORD PTR _szSRC$[ebp]
  005d6	52		 push	 edx
  005d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  005dd	83 c4 10	 add	 esp, 16			; 00000010H

; 129  : 	szSRC[srclen-1] = '\0';

  005e0	8b 45 08	 mov	 eax, DWORD PTR _szSRC$[ebp]
  005e3	03 45 0c	 add	 eax, DWORD PTR _srclen$[ebp]
  005e6	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0

; 130  : 	if(src.length() < (unsigned)srclen)

  005ea	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _src$[ebp]
  005f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  005f6	3b 45 0c	 cmp	 eax, DWORD PTR _srclen$[ebp]
  005f9	73 2d		 jae	 SHORT $L64558

; 131  : 	{
; 132  : 		if(szSRC[src.length()-1] == '\r')

  005fb	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _src$[ebp]
  00601	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00607	8b 4d 08	 mov	 ecx, DWORD PTR _szSRC$[ebp]
  0060a	0f be 54 01 ff	 movsx	 edx, BYTE PTR [ecx+eax-1]
  0060f	83 fa 0d	 cmp	 edx, 13			; 0000000dH
  00612	75 14		 jne	 SHORT $L64558

; 133  : 			szSRC[src.length()-1] = '\0';

  00614	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _src$[ebp]
  0061a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00620	8b 4d 08	 mov	 ecx, DWORD PTR _szSRC$[ebp]
  00623	c6 44 01 ff 00	 mov	 BYTE PTR [ecx+eax-1], 0
$L64558:

; 134  : 	}
; 135  : 
; 136  : 	return true;

  00628	c6 85 96 fd ff
	ff 01		 mov	 BYTE PTR $T68500[ebp], 1
  0062f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00633	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _src$[ebp]
  00639	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0063f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00646	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  0064c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00652	8a 85 96 fd ff
	ff		 mov	 al, BYTE PTR $T68500[ebp]
$L64542:

; 137  : }

  00658	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0065b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00662	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00665	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0066a	8b e5		 mov	 esp, ebp
  0066c	5d		 pop	 ebp
  0066d	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L68501:
  0001f	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00025	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68502:
  0002b	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR _src$[ebp]
  00031	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetInstallSRC@YL_UserId@@SA_NQADH@Z:
  00037	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68504
  0003c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetInstallSRC@YL_UserId@@SA_NQADH@Z ENDP		; YL_UserId::GetInstallSRC
PUBLIC	?SetInstallSRC@YL_UserId@@SA_NPBD@Z		; YL_UserId::SetInstallSRC
; Function compile flags: /Odt
_TEXT	SEGMENT
_file$ = -340						; size = 4
_szUserFilePath$ = -336					; size = 260
_szID$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szSRC$ = 8						; size = 4
?SetInstallSRC@YL_UserId@@SA_NPBD@Z PROC NEAR		; YL_UserId::SetInstallSRC

; 140  : {

  00670	55		 push	 ebp
  00671	8b ec		 mov	 ebp, esp
  00673	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00679	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0067e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 141  : 	char szUserFilePath[MAX_PATH], szID[INT_LENGTH];
; 142  : 	if(!GetUserFilePath(szUserFilePath, MAX_PATH))

  00681	68 04 01 00 00	 push	 260			; 00000104H
  00686	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szUserFilePath$[ebp]
  0068c	50		 push	 eax
  0068d	e8 00 00 00 00	 call	 ?GetUserFilePath@YL_UserId@@SA_NQADH@Z ; YL_UserId::GetUserFilePath
  00692	83 c4 08	 add	 esp, 8
  00695	0f b6 c8	 movzx	 ecx, al
  00698	85 c9		 test	 ecx, ecx
  0069a	75 04		 jne	 SHORT $L64566

; 143  : 	{
; 144  : 		return false;

  0069c	32 c0		 xor	 al, al
  0069e	eb 7a		 jmp	 SHORT $L64563
$L64566:

; 145  : 	}
; 146  : 	GetUserID(szID, INT_LENGTH);

  006a0	6a 40		 push	 64			; 00000040H
  006a2	8d 55 b8	 lea	 edx, DWORD PTR _szID$[ebp]
  006a5	52		 push	 edx
  006a6	e8 00 00 00 00	 call	 ?GetUserID@YL_UserId@@SA_NQADH@Z ; YL_UserId::GetUserID
  006ab	83 c4 08	 add	 esp, 8

; 147  : 
; 148  : 	FILE *file;
; 149  : 	if( (file = fopen( szUserFilePath, "w" )) == NULL )

  006ae	68 00 00 00 00	 push	 OFFSET FLAT:$SG64569
  006b3	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szUserFilePath$[ebp]
  006b9	50		 push	 eax
  006ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  006c0	83 c4 08	 add	 esp, 8
  006c3	89 85 ac fe ff
	ff		 mov	 DWORD PTR _file$[ebp], eax
  006c9	83 bd ac fe ff
	ff 00		 cmp	 DWORD PTR _file$[ebp], 0
  006d0	75 04		 jne	 SHORT $L64568

; 150  : 	{
; 151  : 		return false;

  006d2	32 c0		 xor	 al, al
  006d4	eb 44		 jmp	 SHORT $L64563
$L64568:

; 152  : 	}
; 153  : 	fprintf( file, "%s\r", szID );

  006d6	8d 4d b8	 lea	 ecx, DWORD PTR _szID$[ebp]
  006d9	51		 push	 ecx
  006da	68 00 00 00 00	 push	 OFFSET FLAT:$SG64570
  006df	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _file$[ebp]
  006e5	52		 push	 edx
  006e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  006ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 154  : 	fprintf( file, "%s\r", szSRC);

  006ef	8b 45 08	 mov	 eax, DWORD PTR _szSRC$[ebp]
  006f2	50		 push	 eax
  006f3	68 00 00 00 00	 push	 OFFSET FLAT:$SG64571
  006f8	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR _file$[ebp]
  006fe	51		 push	 ecx
  006ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00705	83 c4 0c	 add	 esp, 12			; 0000000cH

; 155  : 	fclose( file );

  00708	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _file$[ebp]
  0070e	52		 push	 edx
  0070f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00715	83 c4 04	 add	 esp, 4

; 156  : 	return true;

  00718	b0 01		 mov	 al, 1
$L64563:

; 157  : }

  0071a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0071d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00722	8b e5		 mov	 esp, ebp
  00724	5d		 pop	 ebp
  00725	c3		 ret	 0
?SetInstallSRC@YL_UserId@@SA_NPBD@Z ENDP		; YL_UserId::SetInstallSRC
_TEXT	ENDS
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T68520	DD	0ffffffffH
	DD	FLAT:$L68514
	DD	00H
	DD	FLAT:$L68513
$T68518	DD	019930520H
	DD	02H
	DD	FLAT:$T68520
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68515 = -44						; size = 4
$T68512 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68515[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68512[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68515[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68515[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68512[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68513:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68512[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68514:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68515[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68516
  00015	83 65 d4 fe	 and	 DWORD PTR $T68515[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68516:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68518
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68533	DD	0ffffffffH
	DD	FLAT:$L68527
	DD	00H
	DD	FLAT:$L68526
$T68531	DD	019930520H
	DD	02H
	DD	FLAT:$T68533
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68528 = -44						; size = 4
$T68525 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68528[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68525[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68528[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68528[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68525[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68526:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68525[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68527:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68528[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68529
  00015	83 65 d4 fe	 and	 DWORD PTR $T68528[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68529:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68531
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68546	DD	0ffffffffH
	DD	FLAT:$L68540
	DD	00H
	DD	FLAT:$L68539
$T68544	DD	019930520H
	DD	02H
	DD	FLAT:$T68546
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T68541 = -44						; size = 4
$T68538 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 1
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68541[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00022	8a 45 0c	 mov	 al, BYTE PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	6a 01		 push	 1
  00028	8d 4d d8	 lea	 ecx, DWORD PTR $T68538[ebp]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
  00031	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  00034	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00037	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  0003a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00041	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00044	52		 push	 edx
  00045	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00058	8b 45 d4	 mov	 eax, DWORD PTR $T68541[ebp]
  0005b	83 c8 01	 or	 eax, 1
  0005e	89 45 d4	 mov	 DWORD PTR $T68541[ebp], eax
  00061	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00065	8d 4d d8	 lea	 ecx, DWORD PTR $T68538[ebp]
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68539:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68538[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68540:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68541[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68542
  00015	83 65 d4 fe	 and	 DWORD PTR $T68541[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68542:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68544
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68559	DD	0ffffffffH
	DD	FLAT:$L68553
	DD	00H
	DD	FLAT:$L68552
$T68557	DD	019930520H
	DD	02H
	DD	FLAT:$T68559
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68554 = -44						; size = 4
$T68551 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68554[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68551[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68554[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68554[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68551[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68552:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68551[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68553:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68554[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68555
  00015	83 65 d4 fe	 and	 DWORD PTR $T68554[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68555:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68557
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68572	DD	0ffffffffH
	DD	FLAT:$L68566
	DD	00H
	DD	FLAT:$L68565
$T68570	DD	019930520H
	DD	02H
	DD	FLAT:$T68572
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68567 = -44						; size = 4
$T68564 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68567[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68564[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8a 55 10	 mov	 dl, BYTE PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68567[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68567[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68564[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68565:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68564[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68566:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68567[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68568
  00015	83 65 d4 fe	 and	 DWORD PTR $T68567[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L68568:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68570
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68585	DD	0ffffffffH
	DD	FLAT:$L68579
	DD	00H
	DD	FLAT:$L68578
$T68583	DD	019930520H
	DD	02H
	DD	FLAT:$T68585
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68580 = -44						; size = 4
$T68577 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68580[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68577[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68580[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68580[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68577[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68578:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68577[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68579:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68580[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68581
  00015	83 65 d4 fe	 and	 DWORD PTR $T68580[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68581:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68583
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68598	DD	0ffffffffH
	DD	FLAT:$L68592
	DD	00H
	DD	FLAT:$L68591
$T68596	DD	019930520H
	DD	02H
	DD	FLAT:$T68598
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68593 = -44						; size = 4
$T68590 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68593[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68590[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68593[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68593[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68590[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68591:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68590[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68592:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68593[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68594
  00015	83 65 d4 fe	 and	 DWORD PTR $T68593[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68594:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68596
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68611	DD	0ffffffffH
	DD	FLAT:$L68605
	DD	00H
	DD	FLAT:$L68604
$T68609	DD	019930520H
	DD	02H
	DD	FLAT:$T68611
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T68606 = -44						; size = 4
$T68603 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 2
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68606[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00022	66 8b 45 0c	 mov	 ax, WORD PTR __Left$[ebp]
  00026	50		 push	 eax
  00027	6a 01		 push	 1
  00029	8d 4d d8	 lea	 ecx, DWORD PTR $T68603[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
  00032	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  00035	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00038	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  0003b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00042	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00045	52		 push	 edx
  00046	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00059	8b 45 d4	 mov	 eax, DWORD PTR $T68606[ebp]
  0005c	83 c8 01	 or	 eax, 1
  0005f	89 45 d4	 mov	 DWORD PTR $T68606[ebp], eax
  00062	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00066	8d 4d d8	 lea	 ecx, DWORD PTR $T68603[ebp]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68604:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68603[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68605:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68606[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68607
  00015	83 65 d4 fe	 and	 DWORD PTR $T68606[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68607:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68609
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68624	DD	0ffffffffH
	DD	FLAT:$L68618
	DD	00H
	DD	FLAT:$L68617
$T68622	DD	019930520H
	DD	02H
	DD	FLAT:$T68624
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68619 = -44						; size = 4
$T68616 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68619[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68616[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00042	52		 push	 edx
  00043	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T68619[ebp]
  00059	83 c8 01	 or	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR $T68619[ebp], eax
  0005f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T68616[ebp]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68617:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68616[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68618:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68619[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68620
  00015	83 65 d4 fe	 and	 DWORD PTR $T68619[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68620:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68622
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68637	DD	0ffffffffH
	DD	FLAT:$L68631
	DD	00H
	DD	FLAT:$L68630
$T68635	DD	019930520H
	DD	02H
	DD	FLAT:$T68637
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T68632 = -44						; size = 4
$T68629 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 2
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T68632[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	50		 push	 eax
  00026	8d 4d d8	 lea	 ecx, DWORD PTR $T68629[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0002f	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  00035	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003f	66 8b 55 10	 mov	 dx, WORD PTR __Right$[ebp]
  00043	52		 push	 edx
  00044	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00057	8b 45 d4	 mov	 eax, DWORD PTR $T68632[ebp]
  0005a	83 c8 01	 or	 eax, 1
  0005d	89 45 d4	 mov	 DWORD PTR $T68632[ebp], eax
  00060	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00064	8d 4d d8	 lea	 ecx, DWORD PTR $T68629[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68630:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T68629[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68631:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T68632[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L68633
  00015	83 65 d4 fe	 and	 DWORD PTR $T68632[ebp], -2 ; fffffffeH
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L68633:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68635
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?is@?$ctype@D@std@@QBE_NFD@Z:NEAR
EXTRN	__imp_?to_char_type@?$char_traits@D@std@@SADABH@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@D@std@@SAHXZ:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_??1locale@std@@QAE@XZ:NEAR
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB:DWORD
EXTRN	__imp_?width@ios_base@std@@QBEHXZ:NEAR
EXTRN	__imp_?width@ios_base@std@@QAEHH@Z:NEAR
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:NEAR
EXTRN	__imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68654	DD	0ffffffffH
	DD	FLAT:$L68649
	DD	00H
	DD	FLAT:$L68650
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68656	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68648
$T68655	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T68656
$T68652	DD	019930520H
	DD	04H
	DD	FLAT:$T68654
	DD	01H
	DD	FLAT:$T68655
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv205 = -112						; size = 1
tv204 = -111						; size = 1
tv203 = -110						; size = 1
tv202 = -109						; size = 1
tv201 = -108						; size = 4
tv200 = -104						; size = 4
tv199 = -100						; size = 4
tv198 = -96						; size = 4
tv197 = -92						; size = 4
tv196 = -88						; size = 4
tv135 = -84						; size = 4
tv195 = -80						; size = 4
tv194 = -76						; size = 4
tv193 = -72						; size = 4
tv192 = -68						; size = 4
tv189 = -64						; size = 4
tv65 = -60						; size = 4
$T68646 = -56						; size = 4
$T68645 = -52						; size = 4
$T68642 = -48						; size = 4
__Meta$67261 = -44					; size = 4
__Size$67258 = -40					; size = 4
__Ctype_fac$67255 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 dc 01 00
	00		 je	 $L68647

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00055	8d 55 d0	 lea	 edx, DWORD PTR $T68642[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00061	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00064	8b ca		 mov	 ecx, edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0006c	89 45 c4	 mov	 DWORD PTR tv65[ebp], eax
  0006f	8b 45 c4	 mov	 eax, DWORD PTR tv65[ebp]
  00072	89 45 c0	 mov	 DWORD PTR tv189[ebp], eax
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00079	8b 4d c0	 mov	 ecx, DWORD PTR tv189[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 dc	 mov	 DWORD PTR __Ctype_fac$67255[ebp], eax
  00088	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0008c	8d 4d d0	 lea	 ecx, DWORD PTR $T68642[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	50		 push	 eax
  0009e	6a 00		 push	 0
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000a9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000be	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  000c1	83 7d bc 00	 cmp	 DWORD PTR tv192[ebp], 0
  000c5	7e 46		 jle	 SHORT $L68643
  000c7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000d2	8b ca		 mov	 ecx, edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000da	89 45 b8	 mov	 DWORD PTR tv193[ebp], eax
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  000e6	89 45 b4	 mov	 DWORD PTR tv194[ebp], eax
  000e9	8b 45 b8	 mov	 eax, DWORD PTR tv193[ebp]
  000ec	3b 45 b4	 cmp	 eax, DWORD PTR tv194[ebp]
  000ef	73 1c		 jae	 SHORT $L68643
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f9	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00102	89 45 b0	 mov	 DWORD PTR tv195[ebp], eax
  00105	8b 45 b0	 mov	 eax, DWORD PTR tv195[ebp]
  00108	89 45 ac	 mov	 DWORD PTR tv135[ebp], eax
  0010b	eb 12		 jmp	 SHORT $L68644
$L68643:
  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00116	89 45 a8	 mov	 DWORD PTR tv196[ebp], eax
  00119	8b 4d a8	 mov	 ecx, DWORD PTR tv196[ebp]
  0011c	89 4d ac	 mov	 DWORD PTR tv135[ebp], ecx
$L68644:
  0011f	8b 55 ac	 mov	 edx, DWORD PTR tv135[ebp]
  00122	89 55 d8	 mov	 DWORD PTR __Size$67258[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00125	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0012d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00130	8b ca		 mov	 ecx, edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00138	89 45 a4	 mov	 DWORD PTR tv197[ebp], eax
  0013b	8b 4d a4	 mov	 ecx, DWORD PTR tv197[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00144	89 45 a0	 mov	 DWORD PTR tv198[ebp], eax
  00147	8b 45 a0	 mov	 eax, DWORD PTR tv198[ebp]
  0014a	89 45 d4	 mov	 DWORD PTR __Meta$67261[ebp], eax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  0014d	eb 2f		 jmp	 SHORT $L67262
$L67263:
  0014f	8b 4d d8	 mov	 ecx, DWORD PTR __Size$67258[ebp]
  00152	83 e9 01	 sub	 ecx, 1
  00155	89 4d d8	 mov	 DWORD PTR __Size$67258[ebp], ecx
  00158	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0015b	8b 02		 mov	 eax, DWORD PTR [edx]
  0015d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00160	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00169	89 45 9c	 mov	 DWORD PTR tv199[ebp], eax
  0016c	8b 4d 9c	 mov	 ecx, DWORD PTR tv199[ebp]
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00175	89 45 98	 mov	 DWORD PTR tv200[ebp], eax
  00178	8b 4d 98	 mov	 ecx, DWORD PTR tv200[ebp]
  0017b	89 4d d4	 mov	 DWORD PTR __Meta$67261[ebp], ecx
$L67262:
  0017e	83 7d d8 00	 cmp	 DWORD PTR __Size$67258[ebp], 0
  00182	0f 86 8a 00 00
	00		 jbe	 $L67264

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0018e	89 45 94	 mov	 DWORD PTR tv201[ebp], eax
  00191	8b 55 94	 mov	 edx, DWORD PTR tv201[ebp]
  00194	89 55 cc	 mov	 DWORD PTR $T68645[ebp], edx
  00197	8d 45 d4	 lea	 eax, DWORD PTR __Meta$67261[ebp]
  0019a	50		 push	 eax
  0019b	8d 4d cc	 lea	 ecx, DWORD PTR $T68645[ebp]
  0019e	51		 push	 ecx
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  001a5	83 c4 08	 add	 esp, 8
  001a8	88 45 93	 mov	 BYTE PTR tv202[ebp], al
  001ab	0f b6 55 93	 movzx	 edx, BYTE PTR tv202[ebp]
  001af	85 d2		 test	 edx, edx
  001b1	74 0b		 je	 SHORT $L67266

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  001b3	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001b6	83 c8 01	 or	 eax, 1
  001b9	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  001bc	eb 54		 jmp	 SHORT $L67264
$L67266:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  001be	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$67261[ebp]
  001c1	51		 push	 ecx
  001c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  001c8	83 c4 04	 add	 esp, 4
  001cb	88 45 92	 mov	 BYTE PTR tv203[ebp], al
  001ce	8a 55 92	 mov	 dl, BYTE PTR tv203[ebp]
  001d1	52		 push	 edx
  001d2	6a 48		 push	 72			; 00000048H
  001d4	8b 4d dc	 mov	 ecx, DWORD PTR __Ctype_fac$67255[ebp]
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@D@std@@QBE_NFD@Z
  001dd	88 45 91	 mov	 BYTE PTR tv204[ebp], al
  001e0	0f b6 45 91	 movzx	 eax, BYTE PTR tv204[ebp]
  001e4	85 c0		 test	 eax, eax
  001e6	74 02		 je	 SHORT $L67268

; 454  : 				break;	// whitespace, quit

  001e8	eb 28		 jmp	 SHORT $L67264
$L67268:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  001ea	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$67261[ebp]
  001ed	51		 push	 ecx
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  001f4	83 c4 04	 add	 esp, 4
  001f7	88 45 90	 mov	 BYTE PTR tv205[ebp], al
  001fa	8a 55 90	 mov	 dl, BYTE PTR tv205[ebp]
  001fd	52		 push	 edx
  001fe	6a 01		 push	 1
  00200	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z

; 458  : 				_Changed = true;

  00209	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  0020d	e9 3d ff ff ff	 jmp	 $L67263
$L67264:
  00212	eb 1d		 jmp	 SHORT $L68647
$L68648:

; 460  : 		_CATCH_IO_(_Istr)

  00214	6a 01		 push	 1
  00216	6a 04		 push	 4
  00218	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0021b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00220	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00223	8b ca		 mov	 ecx, edx
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0022b	b8 00 00 00 00	 mov	 eax, $L68647
  00230	c3		 ret	 0
$L68647:
  00231	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  00238	6a 00		 push	 0
  0023a	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0023d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023f	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00242	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00245	8b ca		 mov	 ecx, edx
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z

; 464  : 	if (!_Changed)

  0024d	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  00251	85 c0		 test	 eax, eax
  00253	75 09		 jne	 SHORT $L67270

; 465  : 		_State |= ios_base::failbit;

  00255	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00258	83 c9 02	 or	 ecx, 2
  0025b	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L67270:

; 466  : 	_Istr.setstate(_State);

  0025e	6a 00		 push	 0
  00260	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00263	52		 push	 edx
  00264	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00267	8b 08		 mov	 ecx, DWORD PTR [eax]
  00269	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0026c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0026f	8b ca		 mov	 ecx, edx
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 467  : 	return (_Istr);

  00277	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0027a	89 45 c8	 mov	 DWORD PTR $T68646[ebp], eax
  0027d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00284	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00287	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0028c	8b 45 c8	 mov	 eax, DWORD PTR $T68646[ebp]

; 468  : 	}

  0028f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00292	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00299	5f		 pop	 edi
  0029a	5e		 pop	 esi
  0029b	5b		 pop	 ebx
  0029c	8b e5		 mov	 esp, ebp
  0029e	5d		 pop	 ebp
  0029f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68649:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
$L68650:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T68642[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68652
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T68668	DD	0ffffffffH
	DD	FLAT:$L68664
$T68666	DD	019930520H
	DD	01H
	DD	FLAT:$T68668
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0002f	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68664:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68666
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L65772

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L65772:

; 61   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L66674

; 54   : 				_Myistr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L66674:

; 55   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@@
PUBLIC	__CTA2?AVbad_cast@@
PUBLIC	??_R0?AVbad_cast@@@8				; bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
EXTRN	__CxxThrowException@8:NEAR
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:NEAR
EXTRN	__imp_?_Incref@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Register@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z:NEAR
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??0bad_cast@@QAE@ABV0@@Z:NEAR			; bad_cast::bad_cast
EXTRN	??1bad_cast@@UAE@XZ:NEAR			; bad_cast::~bad_cast
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:NEAR
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_??0bad_cast@@QAE@PBD@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68686	DD	0ffffffffH
	DD	FLAT:$L68682
$T68684	DD	019930520H
	DD	01H
	DD	FLAT:$T68686
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT
__TI2?AVbad_cast@@ DD 00H
	DD	FLAT:??1bad_cast@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@@@8 DD FLAT:??_7type_info@@6B@		; bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T68681 = -48						; size = 4
$T68679 = -44						; size = 12
__Pfmod$67184 = -32					; size = 4
__Psave$ = -28						; size = 4
__Lock$ = -24						; size = 4
__Id$ = -20						; size = 4
__Pf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<char> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 24	 sub	 esp, 36			; 00000024H

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	6a 00		 push	 0
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  00032	89 45 e4	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00041	89 45 ec	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00044	8b 4d ec	 mov	 ecx, DWORD PTR __Id$[ebp]
  00047	51		 push	 ecx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00051	89 45 f0	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00054	83 7d f0 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00058	74 02		 je	 SHORT $L67167

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  0005a	eb 62		 jmp	 SHORT $L67168
$L67167:
  0005c	83 7d e4 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  00060	74 08		 je	 SHORT $L67169

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00062	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  00065	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00068	eb 54		 jmp	 SHORT $L67168
$L67169:
  0006a	8d 45 e4	 lea	 eax, DWORD PTR __Psave$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
  00074	83 c4 04	 add	 esp, 4
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	75 1c		 jne	 SHORT $L67172

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  00081	8d 4d d4	 lea	 ecx, DWORD PTR $T68679[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  0008f	8d 4d d4	 lea	 ecx, DWORD PTR $T68679[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 __CxxThrowException@8
$L67172:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  00098	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  0009b	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Psave$[ebp]
  000a1	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000a6	8b 4d e4	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000a9	89 4d e0	 mov	 DWORD PTR __Pfmod$67184[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ac	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$67184[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$67184[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L67168:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000be	8b 55 f0	 mov	 edx, DWORD PTR __Pf$[ebp]
  000c1	89 55 d0	 mov	 DWORD PTR $T68681[ebp], edx
  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d4	8b 45 d0	 mov	 eax, DWORD PTR $T68681[ebp]
$L68678:

; 347  : 	}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68682:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68684
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00003	6a 0a		 push	 10			; 0000000aH
  00005	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0000d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00010	8b ca		 mov	 ecx, edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00018	50		 push	 eax
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z:NEAR
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68702	DD	0ffffffffH
	DD	FLAT:$L68698
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68704	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68697
$T68703	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T68704
$T68700	DD	019930520H
	DD	03H
	DD	FLAT:$T68702
	DD	01H
	DD	FLAT:$T68703
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
tv175 = -89						; size = 1
tv174 = -88						; size = 4
tv173 = -84						; size = 4
tv172 = -80						; size = 4
tv171 = -74						; size = 1
tv170 = -73						; size = 1
tv169 = -72						; size = 4
tv168 = -68						; size = 4
tv167 = -64						; size = 4
tv166 = -60						; size = 4
tv165 = -56						; size = 4
tv65 = -52						; size = 4
$T68695 = -48						; size = 4
$T68694 = -44						; size = 4
__Meta$67281 = -40					; size = 4
__Metadelim$67280 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 66 01 00
	00		 je	 $L68696

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  0006d	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z
  00077	83 c4 04	 add	 esp, 4
  0007a	89 45 cc	 mov	 DWORD PTR tv65[ebp], eax
  0007d	8b 55 cc	 mov	 edx, DWORD PTR tv65[ebp]
  00080	89 55 dc	 mov	 DWORD PTR __Metadelim$67280[ebp], edx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00083	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0008b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0008e	8b ca		 mov	 ecx, edx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00096	89 45 c8	 mov	 DWORD PTR tv165[ebp], eax
  00099	8b 4d c8	 mov	 ecx, DWORD PTR tv165[ebp]
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000a2	89 45 c4	 mov	 DWORD PTR tv166[ebp], eax
  000a5	8b 45 c4	 mov	 eax, DWORD PTR tv166[ebp]
  000a8	89 45 d8	 mov	 DWORD PTR __Meta$67281[ebp], eax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000ab	eb 26		 jmp	 SHORT $L67282
$L67283:
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000be	89 45 c0	 mov	 DWORD PTR tv167[ebp], eax
  000c1	8b 4d c0	 mov	 ecx, DWORD PTR tv167[ebp]
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000ca	89 45 bc	 mov	 DWORD PTR tv168[ebp], eax
  000cd	8b 45 bc	 mov	 eax, DWORD PTR tv168[ebp]
  000d0	89 45 d8	 mov	 DWORD PTR __Meta$67281[ebp], eax
$L67282:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  000d9	89 45 b8	 mov	 DWORD PTR tv169[ebp], eax
  000dc	8b 4d b8	 mov	 ecx, DWORD PTR tv169[ebp]
  000df	89 4d d4	 mov	 DWORD PTR $T68694[ebp], ecx
  000e2	8d 55 d8	 lea	 edx, DWORD PTR __Meta$67281[ebp]
  000e5	52		 push	 edx
  000e6	8d 45 d4	 lea	 eax, DWORD PTR $T68694[ebp]
  000e9	50		 push	 eax
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  000f0	83 c4 08	 add	 esp, 8
  000f3	88 45 b7	 mov	 BYTE PTR tv170[ebp], al
  000f6	0f b6 4d b7	 movzx	 ecx, BYTE PTR tv170[ebp]
  000fa	85 c9		 test	 ecx, ecx
  000fc	74 0e		 je	 SHORT $L67286

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  000fe	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00101	83 ca 01	 or	 edx, 1
  00104	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  00107	e9 92 00 00 00	 jmp	 $L67284
$L67286:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  0010c	8d 45 dc	 lea	 eax, DWORD PTR __Metadelim$67280[ebp]
  0010f	50		 push	 eax
  00110	8d 4d d8	 lea	 ecx, DWORD PTR __Meta$67281[ebp]
  00113	51		 push	 ecx
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  0011a	83 c4 08	 add	 esp, 8
  0011d	88 45 b6	 mov	 BYTE PTR tv171[ebp], al
  00120	0f b6 55 b6	 movzx	 edx, BYTE PTR tv171[ebp]
  00124	85 d2		 test	 edx, edx
  00126	74 25		 je	 SHORT $L67288

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00128	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  0012c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00134	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00137	8b ca		 mov	 ecx, edx
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0013f	89 45 b0	 mov	 DWORD PTR tv172[ebp], eax
  00142	8b 4d b0	 mov	 ecx, DWORD PTR tv172[ebp]
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ

; 501  : 				break;

  0014b	eb 51		 jmp	 SHORT $L67284
$L67288:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  0014d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00156	89 45 ac	 mov	 DWORD PTR tv173[ebp], eax
  00159	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00162	89 45 a8	 mov	 DWORD PTR tv174[ebp], eax
  00165	8b 45 ac	 mov	 eax, DWORD PTR tv173[ebp]
  00168	3b 45 a8	 cmp	 eax, DWORD PTR tv174[ebp]
  0016b	77 0b		 ja	 SHORT $L67290

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  0016d	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00170	83 c9 02	 or	 ecx, 2
  00173	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  00176	eb 26		 jmp	 SHORT $L67284
$L67290:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  00178	8d 55 d8	 lea	 edx, DWORD PTR __Meta$67281[ebp]
  0017b	52		 push	 edx
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  00182	83 c4 04	 add	 esp, 4
  00185	88 45 a7	 mov	 BYTE PTR tv175[ebp], al
  00188	8a 45 a7	 mov	 al, BYTE PTR tv175[ebp]
  0018b	50		 push	 eax
  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z

; 511  : 				_Changed = true;

  00195	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  00199	e9 0f ff ff ff	 jmp	 $L67283
$L67284:
  0019e	eb 1b		 jmp	 SHORT $L68696
$L68697:

; 513  : 		_CATCH_IO_(_Istr)

  001a0	6a 01		 push	 1
  001a2	6a 04		 push	 4
  001a4	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a9	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001ac	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001b5	b8 00 00 00 00	 mov	 eax, $L68696
  001ba	c3		 ret	 0
$L68696:
  001bb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  001c2	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $L67292

; 517  : 		_State |= ios_base::failbit;

  001ca	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001cd	83 c9 02	 or	 ecx, 2
  001d0	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L67292:

; 518  : 	_Istr.setstate(_State);

  001d3	6a 00		 push	 0
  001d5	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001d8	52		 push	 edx
  001d9	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001de	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001e1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001e4	8b ca		 mov	 ecx, edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 519  : 	return (_Istr);

  001ec	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001ef	89 45 d0	 mov	 DWORD PTR $T68695[ebp], eax
  001f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001f9	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  001fc	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00201	8b 45 d0	 mov	 eax, DWORD PTR $T68695[ebp]

; 520  : 	}

  00204	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00207	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	5b		 pop	 ebx
  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68698:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68700
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z:NEAR
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:NEAR
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:NEAR
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68724	DD	0ffffffffH
	DD	FLAT:$L68720
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68726	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68719
$T68725	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T68726
$T68722	DD	019930520H
	DD	03H
	DD	FLAT:$T68724
	DD	01H
	DD	FLAT:$T68725
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv221 = -129						; size = 1
tv220 = -128						; size = 4
tv219 = -124						; size = 4
tv218 = -120						; size = 4
tv217 = -114						; size = 1
tv216 = -113						; size = 1
tv215 = -112						; size = 4
tv214 = -108						; size = 4
tv213 = -104						; size = 4
tv212 = -100						; size = 4
tv211 = -93						; size = 1
tv210 = -92						; size = 4
tv209 = -88						; size = 4
tv208 = -84						; size = 4
tv207 = -77						; size = 1
tv83 = -76						; size = 4
tv81 = -72						; size = 4
$T68717 = -68						; size = 4
$T68716 = -64						; size = 4
$T68715 = -60						; size = 4
$T68714 = -56						; size = 4
$T68713 = -52						; size = 4
$T68712 = -48						; size = 4
$T68711 = -44						; size = 4
__Count$67315 = -40					; size = 4
__Size$ = -36						; size = 4
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 74	 sub	 esp, 116		; 00000074H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00032	89 45 dc	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0003d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00040	8b ca		 mov	 ecx, edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00048	85 c0		 test	 eax, eax
  0004a	7e 33		 jle	 SHORT $L68709
  0004c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00054	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00057	8b ca		 mov	 ecx, edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0005f	3b 45 dc	 cmp	 eax, DWORD PTR __Size$[ebp]
  00062	76 1b		 jbe	 SHORT $L68709
  00064	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00077	2b 45 dc	 sub	 eax, DWORD PTR __Size$[ebp]
  0007a	89 45 b8	 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 07		 jmp	 SHORT $L68710
$L68709:
  0007f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L68710:
  00086	8b 45 b8	 mov	 eax, DWORD PTR tv81[ebp]
  00089	89 45 e8	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008f	51		 push	 ecx
  00090	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00093	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  0009f	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000a2	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000a7	0f b6 d0	 movzx	 edx, al
  000aa	85 d2		 test	 edx, edx
  000ac	75 0e		 jne	 SHORT $L67304

; 550  : 		_State |= ios_base::badbit;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000b1	83 c8 04	 or	 eax, 4
  000b4	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000b7	e9 22 02 00 00	 jmp	 $L68718
$L67304:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  000d1	89 45 b4	 mov	 DWORD PTR tv83[ebp], eax
  000d4	8b 45 b4	 mov	 eax, DWORD PTR tv83[ebp]
  000d7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000dc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000df	0f 84 8a 00 00
	00		 je	 $L67307

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000e5	eb 09		 jmp	 SHORT $L67308
$L67309:
  000e7	8b 4d e8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  000ea	83 e9 01	 sub	 ecx, 1
  000ed	89 4d e8	 mov	 DWORD PTR __Pad$[ebp], ecx
$L67308:
  000f0	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  000f4	76 79		 jbe	 SHORT $L67307

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  000f6	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000f9	8b 02		 mov	 eax, DWORD PTR [edx]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000fe	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  00107	88 45 b3	 mov	 BYTE PTR tv207[ebp], al
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0010d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00112	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0011b	89 45 ac	 mov	 DWORD PTR tv208[ebp], eax
  0011e	8a 45 b3	 mov	 al, BYTE PTR tv207[ebp]
  00121	50		 push	 eax
  00122	8b 4d ac	 mov	 ecx, DWORD PTR tv208[ebp]
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0012b	89 45 a8	 mov	 DWORD PTR tv209[ebp], eax
  0012e	8b 4d a8	 mov	 ecx, DWORD PTR tv209[ebp]
  00131	89 4d d4	 mov	 DWORD PTR $T68711[ebp], ecx
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0013a	89 45 a4	 mov	 DWORD PTR tv210[ebp], eax
  0013d	8b 55 a4	 mov	 edx, DWORD PTR tv210[ebp]
  00140	89 55 d0	 mov	 DWORD PTR $T68712[ebp], edx
  00143	8d 45 d4	 lea	 eax, DWORD PTR $T68711[ebp]
  00146	50		 push	 eax
  00147	8d 4d d0	 lea	 ecx, DWORD PTR $T68712[ebp]
  0014a	51		 push	 ecx
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00151	83 c4 08	 add	 esp, 8
  00154	88 45 a3	 mov	 BYTE PTR tv211[ebp], al
  00157	0f b6 55 a3	 movzx	 edx, BYTE PTR tv211[ebp]
  0015b	85 d2		 test	 edx, edx
  0015d	74 0b		 je	 SHORT $L67313

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  0015f	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00162	83 c8 04	 or	 eax, 4
  00165	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  00168	eb 05		 jmp	 SHORT $L67307
$L67313:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  0016a	e9 78 ff ff ff	 jmp	 $L67309
$L67307:
  0016f	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00173	0f 85 91 00 00
	00		 jne	 $L67314

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00179	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Count$67315[ebp], 0
  00180	eb 09		 jmp	 SHORT $L67316
$L67317:
  00182	8b 4d d8	 mov	 ecx, DWORD PTR __Count$67315[ebp]
  00185	83 c1 01	 add	 ecx, 1
  00188	89 4d d8	 mov	 DWORD PTR __Count$67315[ebp], ecx
$L67316:
  0018b	8b 55 d8	 mov	 edx, DWORD PTR __Count$67315[ebp]
  0018e	3b 55 dc	 cmp	 edx, DWORD PTR __Size$[ebp]
  00191	73 77		 jae	 SHORT $L67314

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  00193	8b 45 d8	 mov	 eax, DWORD PTR __Count$67315[ebp]
  00196	50		 push	 eax
  00197	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
  001a0	89 45 9c	 mov	 DWORD PTR tv212[ebp], eax
  001a3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001ab	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001b4	89 45 98	 mov	 DWORD PTR tv213[ebp], eax
  001b7	8b 45 9c	 mov	 eax, DWORD PTR tv212[ebp]
  001ba	8a 08		 mov	 cl, BYTE PTR [eax]
  001bc	51		 push	 ecx
  001bd	8b 4d 98	 mov	 ecx, DWORD PTR tv213[ebp]
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  001c6	89 45 94	 mov	 DWORD PTR tv214[ebp], eax
  001c9	8b 55 94	 mov	 edx, DWORD PTR tv214[ebp]
  001cc	89 55 cc	 mov	 DWORD PTR $T68713[ebp], edx
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  001d5	89 45 90	 mov	 DWORD PTR tv215[ebp], eax
  001d8	8b 45 90	 mov	 eax, DWORD PTR tv215[ebp]
  001db	89 45 c8	 mov	 DWORD PTR $T68714[ebp], eax
  001de	8d 4d cc	 lea	 ecx, DWORD PTR $T68713[ebp]
  001e1	51		 push	 ecx
  001e2	8d 55 c8	 lea	 edx, DWORD PTR $T68714[ebp]
  001e5	52		 push	 edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  001ec	83 c4 08	 add	 esp, 8
  001ef	88 45 8f	 mov	 BYTE PTR tv216[ebp], al
  001f2	0f b6 45 8f	 movzx	 eax, BYTE PTR tv216[ebp]
  001f6	85 c0		 test	 eax, eax
  001f8	74 0b		 je	 SHORT $L67321

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  001fa	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001fd	83 c9 04	 or	 ecx, 4
  00200	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  00203	eb 05		 jmp	 SHORT $L67314
$L67321:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00205	e9 78 ff ff ff	 jmp	 $L67317
$L67314:
  0020a	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  0020e	0f 85 98 00 00
	00		 jne	 $L67322

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00214	eb 09		 jmp	 SHORT $L67323
$L67324:
  00216	8b 55 e8	 mov	 edx, DWORD PTR __Pad$[ebp]
  00219	83 ea 01	 sub	 edx, 1
  0021c	89 55 e8	 mov	 DWORD PTR __Pad$[ebp], edx
$L67323:
  0021f	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00223	0f 86 83 00 00
	00		 jbe	 $L67322

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  00229	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0022c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00231	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00234	8b ca		 mov	 ecx, edx
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0023c	88 45 8e	 mov	 BYTE PTR tv217[ebp], al
  0023f	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00242	8b 08		 mov	 ecx, DWORD PTR [eax]
  00244	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00247	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0024a	8b ca		 mov	 ecx, edx
  0024c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00252	89 45 88	 mov	 DWORD PTR tv218[ebp], eax
  00255	8a 45 8e	 mov	 al, BYTE PTR tv217[ebp]
  00258	50		 push	 eax
  00259	8b 4d 88	 mov	 ecx, DWORD PTR tv218[ebp]
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00262	89 45 84	 mov	 DWORD PTR tv219[ebp], eax
  00265	8b 4d 84	 mov	 ecx, DWORD PTR tv219[ebp]
  00268	89 4d c4	 mov	 DWORD PTR $T68715[ebp], ecx
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  00271	89 45 80	 mov	 DWORD PTR tv220[ebp], eax
  00274	8b 55 80	 mov	 edx, DWORD PTR tv220[ebp]
  00277	89 55 c0	 mov	 DWORD PTR $T68716[ebp], edx
  0027a	8d 45 c4	 lea	 eax, DWORD PTR $T68715[ebp]
  0027d	50		 push	 eax
  0027e	8d 4d c0	 lea	 ecx, DWORD PTR $T68716[ebp]
  00281	51		 push	 ecx
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00288	83 c4 08	 add	 esp, 8
  0028b	88 85 7f ff ff
	ff		 mov	 BYTE PTR tv221[ebp], al
  00291	0f b6 95 7f ff
	ff ff		 movzx	 edx, BYTE PTR tv221[ebp]
  00298	85 d2		 test	 edx, edx
  0029a	74 0b		 je	 SHORT $L67328

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  0029c	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0029f	83 c8 04	 or	 eax, 4
  002a2	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  002a5	eb 05		 jmp	 SHORT $L67322
$L67328:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  002a7	e9 6a ff ff ff	 jmp	 $L67324
$L67322:
  002ac	6a 00		 push	 0
  002ae	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  002b3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002b6	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  002bf	eb 1d		 jmp	 SHORT $L68718
$L68719:

; 581  : 		_CATCH_IO_(_Ostr)

  002c1	6a 01		 push	 1
  002c3	6a 04		 push	 4
  002c5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ca	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002cd	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002d0	8b ca		 mov	 ecx, edx
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  002d8	b8 00 00 00 00	 mov	 eax, $L68718
  002dd	c3		 ret	 0
$L68718:
  002de	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  002e5	6a 00		 push	 0
  002e7	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002ea	50		 push	 eax
  002eb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002f3	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 585  : 	return (_Ostr);

  002fc	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002ff	89 45 bc	 mov	 DWORD PTR $T68717[ebp], eax
  00302	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00309	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0030c	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00311	8b 45 bc	 mov	 eax, DWORD PTR $T68717[ebp]

; 586  : 	}

  00314	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00317	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0031e	5f		 pop	 edi
  0031f	5e		 pop	 esi
  00320	5b		 pop	 ebx
  00321	8b e5		 mov	 esp, ebp
  00323	5d		 pop	 ebp
  00324	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68720:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68722
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T68735	DD	0ffffffffH
	DD	FLAT:$L68731
$T68733	DD	019930520H
	DD	01H
	DD	FLAT:$T68735
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00037	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	74 30		 je	 SHORT $L66683
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  00058	85 c0		 test	 eax, eax
  0005a	74 1b		 je	 SHORT $L66683

; 90   : 				_Ostr.tie()->flush();

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b ca		 mov	 ecx, edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0006f	8b c8		 mov	 ecx, eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$L66683:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00077	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00082	8b ca		 mov	 ecx, edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68731:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68733
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:NEAR
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68744	DD	0ffffffffH
	DD	FLAT:$L68740
$T68742	DD	019930520H
	DD	01H
	DD	FLAT:$T68744
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0b		 jne	 SHORT $L66685

; 99   : 				this->_Myostr._Osfx();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$L66685:

; 100  : 			}

  0003b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68740:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68742
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L66920

; 70   : 				_Myostr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L66920:

; 71   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L66923

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$L66923:

; 77   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@_W@std@@SAGXZ:NEAR
EXTRN	__imp_?is@?$ctype@_W@std@@QBE_NF_W@Z:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB:DWORD
EXTRN	__imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z:NEAR
EXTRN	__imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T68767	DD	0ffffffffH
	DD	FLAT:$L68762
	DD	00H
	DD	FLAT:$L68763
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68769	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68761
$T68768	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T68769
$T68765	DD	019930520H
	DD	04H
	DD	FLAT:$T68767
	DD	01H
	DD	FLAT:$T68768
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv205 = -112						; size = 2
tv204 = -109						; size = 1
tv203 = -108						; size = 2
tv202 = -105						; size = 1
tv201 = -104						; size = 2
tv200 = -102						; size = 2
tv199 = -100						; size = 4
tv198 = -94						; size = 2
tv197 = -92						; size = 4
tv196 = -88						; size = 4
tv135 = -84						; size = 4
tv195 = -80						; size = 4
tv194 = -76						; size = 4
tv193 = -72						; size = 4
tv192 = -68						; size = 4
tv189 = -64						; size = 4
tv65 = -60						; size = 4
$T68759 = -56						; size = 4
$T68758 = -50						; size = 2
$T68755 = -48						; size = 4
__Meta$67345 = -44					; size = 2
__Size$67342 = -40					; size = 4
__Ctype_fac$67339 = -36					; size = 4
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 e9 01 00
	00		 je	 $L68760

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00055	8d 55 d0	 lea	 edx, DWORD PTR $T68755[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00061	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00064	8b ca		 mov	 ecx, edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0006c	89 45 c4	 mov	 DWORD PTR tv65[ebp], eax
  0006f	8b 45 c4	 mov	 eax, DWORD PTR tv65[ebp]
  00072	89 45 c0	 mov	 DWORD PTR tv189[ebp], eax
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00079	8b 4d c0	 mov	 ecx, DWORD PTR tv189[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 dc	 mov	 DWORD PTR __Ctype_fac$67339[ebp], eax
  00088	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0008c	8d 4d d0	 lea	 ecx, DWORD PTR $T68755[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	50		 push	 eax
  0009e	6a 00		 push	 0
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000a9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000be	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  000c1	83 7d bc 00	 cmp	 DWORD PTR tv192[ebp], 0
  000c5	7e 46		 jle	 SHORT $L68756
  000c7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000d2	8b ca		 mov	 ecx, edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000da	89 45 b8	 mov	 DWORD PTR tv193[ebp], eax
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  000e6	89 45 b4	 mov	 DWORD PTR tv194[ebp], eax
  000e9	8b 45 b8	 mov	 eax, DWORD PTR tv193[ebp]
  000ec	3b 45 b4	 cmp	 eax, DWORD PTR tv194[ebp]
  000ef	73 1c		 jae	 SHORT $L68756
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000f9	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00102	89 45 b0	 mov	 DWORD PTR tv195[ebp], eax
  00105	8b 45 b0	 mov	 eax, DWORD PTR tv195[ebp]
  00108	89 45 ac	 mov	 DWORD PTR tv135[ebp], eax
  0010b	eb 12		 jmp	 SHORT $L68757
$L68756:
  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00116	89 45 a8	 mov	 DWORD PTR tv196[ebp], eax
  00119	8b 4d a8	 mov	 ecx, DWORD PTR tv196[ebp]
  0011c	89 4d ac	 mov	 DWORD PTR tv135[ebp], ecx
$L68757:
  0011f	8b 55 ac	 mov	 edx, DWORD PTR tv135[ebp]
  00122	89 55 d8	 mov	 DWORD PTR __Size$67342[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00125	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0012d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00130	8b ca		 mov	 ecx, edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00138	89 45 a4	 mov	 DWORD PTR tv197[ebp], eax
  0013b	8b 4d a4	 mov	 ecx, DWORD PTR tv197[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  00144	66 89 45 a2	 mov	 WORD PTR tv198[ebp], ax
  00148	66 8b 45 a2	 mov	 ax, WORD PTR tv198[ebp]
  0014c	66 89 45 d4	 mov	 WORD PTR __Meta$67345[ebp], ax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  00150	eb 32		 jmp	 SHORT $L67346
$L67347:
  00152	8b 4d d8	 mov	 ecx, DWORD PTR __Size$67342[ebp]
  00155	83 e9 01	 sub	 ecx, 1
  00158	89 4d d8	 mov	 DWORD PTR __Size$67342[ebp], ecx
  0015b	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0015e	8b 02		 mov	 eax, DWORD PTR [edx]
  00160	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00163	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0016c	89 45 9c	 mov	 DWORD PTR tv199[ebp], eax
  0016f	8b 4d 9c	 mov	 ecx, DWORD PTR tv199[ebp]
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  00178	66 89 45 9a	 mov	 WORD PTR tv200[ebp], ax
  0017c	66 8b 4d 9a	 mov	 cx, WORD PTR tv200[ebp]
  00180	66 89 4d d4	 mov	 WORD PTR __Meta$67345[ebp], cx
$L67346:
  00184	83 7d d8 00	 cmp	 DWORD PTR __Size$67342[ebp], 0
  00188	0f 86 91 00 00
	00		 jbe	 $L67348

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00194	66 89 45 98	 mov	 WORD PTR tv201[ebp], ax
  00198	66 8b 55 98	 mov	 dx, WORD PTR tv201[ebp]
  0019c	66 89 55 ce	 mov	 WORD PTR $T68758[ebp], dx
  001a0	8d 45 d4	 lea	 eax, DWORD PTR __Meta$67345[ebp]
  001a3	50		 push	 eax
  001a4	8d 4d ce	 lea	 ecx, DWORD PTR $T68758[ebp]
  001a7	51		 push	 ecx
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  001ae	83 c4 08	 add	 esp, 8
  001b1	88 45 97	 mov	 BYTE PTR tv202[ebp], al
  001b4	0f b6 55 97	 movzx	 edx, BYTE PTR tv202[ebp]
  001b8	85 d2		 test	 edx, edx
  001ba	74 0b		 je	 SHORT $L67350

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  001bc	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001bf	83 c8 01	 or	 eax, 1
  001c2	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  001c5	eb 58		 jmp	 SHORT $L67348
$L67350:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  001c7	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$67345[ebp]
  001ca	51		 push	 ecx
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  001d1	83 c4 04	 add	 esp, 4
  001d4	66 89 45 94	 mov	 WORD PTR tv203[ebp], ax
  001d8	66 8b 55 94	 mov	 dx, WORD PTR tv203[ebp]
  001dc	52		 push	 edx
  001dd	6a 48		 push	 72			; 00000048H
  001df	8b 4d dc	 mov	 ecx, DWORD PTR __Ctype_fac$67339[ebp]
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z
  001e8	88 45 93	 mov	 BYTE PTR tv204[ebp], al
  001eb	0f b6 45 93	 movzx	 eax, BYTE PTR tv204[ebp]
  001ef	85 c0		 test	 eax, eax
  001f1	74 02		 je	 SHORT $L67352

; 454  : 				break;	// whitespace, quit

  001f3	eb 2a		 jmp	 SHORT $L67348
$L67352:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  001f5	8d 4d d4	 lea	 ecx, DWORD PTR __Meta$67345[ebp]
  001f8	51		 push	 ecx
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  001ff	83 c4 04	 add	 esp, 4
  00202	66 89 45 90	 mov	 WORD PTR tv205[ebp], ax
  00206	66 8b 55 90	 mov	 dx, WORD PTR tv205[ebp]
  0020a	52		 push	 edx
  0020b	6a 01		 push	 1
  0020d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z

; 458  : 				_Changed = true;

  00216	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  0021a	e9 33 ff ff ff	 jmp	 $L67347
$L67348:
  0021f	eb 1d		 jmp	 SHORT $L68760
$L68761:

; 460  : 		_CATCH_IO_(_Istr)

  00221	6a 01		 push	 1
  00223	6a 04		 push	 4
  00225	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00228	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0022d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00230	8b ca		 mov	 ecx, edx
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  00238	b8 00 00 00 00	 mov	 eax, $L68760
  0023d	c3		 ret	 0
$L68760:
  0023e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  00245	6a 00		 push	 0
  00247	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0024a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024c	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0024f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00252	8b ca		 mov	 ecx, edx
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z

; 464  : 	if (!_Changed)

  0025a	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  0025e	85 c0		 test	 eax, eax
  00260	75 09		 jne	 SHORT $L67354

; 465  : 		_State |= ios_base::failbit;

  00262	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00265	83 c9 02	 or	 ecx, 2
  00268	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L67354:

; 466  : 	_Istr.setstate(_State);

  0026b	6a 00		 push	 0
  0026d	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00270	52		 push	 edx
  00271	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00274	8b 08		 mov	 ecx, DWORD PTR [eax]
  00276	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00279	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0027c	8b ca		 mov	 ecx, edx
  0027e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 467  : 	return (_Istr);

  00284	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00287	89 45 c8	 mov	 DWORD PTR $T68759[ebp], eax
  0028a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00291	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00294	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00299	8b 45 c8	 mov	 eax, DWORD PTR $T68759[ebp]

; 468  : 	}

  0029c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0029f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002a6	5f		 pop	 edi
  002a7	5e		 pop	 esi
  002a8	5b		 pop	 ebx
  002a9	8b e5		 mov	 esp, ebp
  002ab	5d		 pop	 ebp
  002ac	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68762:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
$L68763:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T68755[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68765
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T68781	DD	0ffffffffH
	DD	FLAT:$L68777
$T68779	DD	019930520H
	DD	01H
	DD	FLAT:$T68781
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0002f	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68777:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68779
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L65779

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L65779:

; 61   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L66677

; 54   : 				_Myistr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L66677:

; 55   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
EXTRN	__imp_?id@?$ctype@_W@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68798	DD	0ffffffffH
	DD	FLAT:$L68794
$T68796	DD	019930520H
	DD	01H
	DD	FLAT:$T68798
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T68793 = -48						; size = 4
$T68792 = -44						; size = 12
__Pfmod$67212 = -32					; size = 4
__Psave$ = -28						; size = 4
__Lock$ = -24						; size = 4
__Id$ = -20						; size = 4
__Pf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 24	 sub	 esp, 36			; 00000024H

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	6a 00		 push	 0
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  00032	89 45 e4	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@_W@std@@2V0locale@2@A
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00041	89 45 ec	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00044	8b 4d ec	 mov	 ecx, DWORD PTR __Id$[ebp]
  00047	51		 push	 ecx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00051	89 45 f0	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00054	83 7d f0 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00058	74 02		 je	 SHORT $L67203

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  0005a	eb 62		 jmp	 SHORT $L67204
$L67203:
  0005c	83 7d e4 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  00060	74 08		 je	 SHORT $L67205

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00062	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  00065	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00068	eb 54		 jmp	 SHORT $L67204
$L67205:
  0006a	8d 45 e4	 lea	 eax, DWORD PTR __Psave$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z
  00074	83 c4 04	 add	 esp, 4
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	75 1c		 jne	 SHORT $L67208

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  00081	8d 4d d4	 lea	 ecx, DWORD PTR $T68792[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  0008f	8d 4d d4	 lea	 ecx, DWORD PTR $T68792[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 __CxxThrowException@8
$L67208:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  00098	8b 55 e4	 mov	 edx, DWORD PTR __Psave$[ebp]
  0009b	89 55 f0	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Psave$[ebp]
  000a1	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000a6	8b 4d e4	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000a9	89 4d e0	 mov	 DWORD PTR __Pfmod$67212[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ac	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$67212[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR __Pfmod$67212[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L67204:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000be	8b 55 f0	 mov	 edx, DWORD PTR __Pf$[ebp]
  000c1	89 55 d0	 mov	 DWORD PTR $T68793[ebp], edx
  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000d4	8b 45 d0	 mov	 eax, DWORD PTR $T68793[ebp]
$L68791:

; 347  : 	}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68794:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68796
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:NEAR
; Function compile flags: /Odt
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00003	6a 0a		 push	 10			; 0000000aH
  00005	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0000d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00010	8b ca		 mov	 ecx, edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  00018	50		 push	 eax
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
EXTRN	__imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z:NEAR
EXTRN	__imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68814	DD	0ffffffffH
	DD	FLAT:$L68810
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68816	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68809
$T68815	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T68816
$T68812	DD	019930520H
	DD	03H
	DD	FLAT:$T68814
	DD	01H
	DD	FLAT:$T68815
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT
tv175 = -86						; size = 2
tv174 = -84						; size = 4
tv173 = -80						; size = 4
tv172 = -76						; size = 4
tv171 = -70						; size = 1
tv170 = -69						; size = 1
tv169 = -68						; size = 2
tv168 = -66						; size = 2
tv167 = -64						; size = 4
tv166 = -58						; size = 2
tv165 = -56						; size = 4
tv65 = -50						; size = 2
$T68807 = -48						; size = 4
$T68806 = -42						; size = 2
__Meta$67365 = -40					; size = 2
__Metadelim$67364 = -36					; size = 2
__Changed$ = -29					; size = 1
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 2
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 48	 sub	 esp, 72			; 00000048H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00029	c6 45 e3 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00032	50		 push	 eax
  00033	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00036	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00042	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 74 01 00
	00		 je	 $L68808

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  0006d	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z
  00077	83 c4 04	 add	 esp, 4
  0007a	66 89 45 ce	 mov	 WORD PTR tv65[ebp], ax
  0007e	66 8b 55 ce	 mov	 dx, WORD PTR tv65[ebp]
  00082	66 89 55 dc	 mov	 WORD PTR __Metadelim$67364[ebp], dx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00086	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0008e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00091	8b ca		 mov	 ecx, edx
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00099	89 45 c8	 mov	 DWORD PTR tv165[ebp], eax
  0009c	8b 4d c8	 mov	 ecx, DWORD PTR tv165[ebp]
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000a5	66 89 45 c6	 mov	 WORD PTR tv166[ebp], ax
  000a9	66 8b 45 c6	 mov	 ax, WORD PTR tv166[ebp]
  000ad	66 89 45 d8	 mov	 WORD PTR __Meta$67365[ebp], ax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000b1	eb 29		 jmp	 SHORT $L67366
$L67367:
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000bb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  000c4	89 45 c0	 mov	 DWORD PTR tv167[ebp], eax
  000c7	8b 4d c0	 mov	 ecx, DWORD PTR tv167[ebp]
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000d0	66 89 45 be	 mov	 WORD PTR tv168[ebp], ax
  000d4	66 8b 45 be	 mov	 ax, WORD PTR tv168[ebp]
  000d8	66 89 45 d8	 mov	 WORD PTR __Meta$67365[ebp], ax
$L67366:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  000e2	66 89 45 bc	 mov	 WORD PTR tv169[ebp], ax
  000e6	66 8b 4d bc	 mov	 cx, WORD PTR tv169[ebp]
  000ea	66 89 4d d6	 mov	 WORD PTR $T68806[ebp], cx
  000ee	8d 55 d8	 lea	 edx, DWORD PTR __Meta$67365[ebp]
  000f1	52		 push	 edx
  000f2	8d 45 d6	 lea	 eax, DWORD PTR $T68806[ebp]
  000f5	50		 push	 eax
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  000fc	83 c4 08	 add	 esp, 8
  000ff	88 45 bb	 mov	 BYTE PTR tv170[ebp], al
  00102	0f b6 4d bb	 movzx	 ecx, BYTE PTR tv170[ebp]
  00106	85 c9		 test	 ecx, ecx
  00108	74 0e		 je	 SHORT $L67370

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  0010a	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  0010d	83 ca 01	 or	 edx, 1
  00110	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  00113	e9 94 00 00 00	 jmp	 $L67368
$L67370:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  00118	8d 45 dc	 lea	 eax, DWORD PTR __Metadelim$67364[ebp]
  0011b	50		 push	 eax
  0011c	8d 4d d8	 lea	 ecx, DWORD PTR __Meta$67365[ebp]
  0011f	51		 push	 ecx
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  00126	83 c4 08	 add	 esp, 8
  00129	88 45 ba	 mov	 BYTE PTR tv171[ebp], al
  0012c	0f b6 55 ba	 movzx	 edx, BYTE PTR tv171[ebp]
  00130	85 d2		 test	 edx, edx
  00132	74 25		 je	 SHORT $L67372

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00134	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  00138	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0013b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00140	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00143	8b ca		 mov	 ecx, edx
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0014b	89 45 b4	 mov	 DWORD PTR tv172[ebp], eax
  0014e	8b 4d b4	 mov	 ecx, DWORD PTR tv172[ebp]
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ

; 501  : 				break;

  00157	eb 53		 jmp	 SHORT $L67368
$L67372:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  00159	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00162	89 45 b0	 mov	 DWORD PTR tv173[ebp], eax
  00165	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  0016e	89 45 ac	 mov	 DWORD PTR tv174[ebp], eax
  00171	8b 45 b0	 mov	 eax, DWORD PTR tv173[ebp]
  00174	3b 45 ac	 cmp	 eax, DWORD PTR tv174[ebp]
  00177	77 0b		 ja	 SHORT $L67374

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  00179	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  0017c	83 c9 02	 or	 ecx, 2
  0017f	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  00182	eb 28		 jmp	 SHORT $L67368
$L67374:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  00184	8d 55 d8	 lea	 edx, DWORD PTR __Meta$67365[ebp]
  00187	52		 push	 edx
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  0018e	83 c4 04	 add	 esp, 4
  00191	66 89 45 aa	 mov	 WORD PTR tv175[ebp], ax
  00195	66 8b 45 aa	 mov	 ax, WORD PTR tv175[ebp]
  00199	50		 push	 eax
  0019a	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z

; 511  : 				_Changed = true;

  001a3	c6 45 e3 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  001a7	e9 07 ff ff ff	 jmp	 $L67367
$L67368:
  001ac	eb 1b		 jmp	 SHORT $L68808
$L68809:

; 513  : 		_CATCH_IO_(_Istr)

  001ae	6a 01		 push	 1
  001b0	6a 04		 push	 4
  001b2	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b7	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001ba	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  001c3	b8 00 00 00 00	 mov	 eax, $L68808
  001c8	c3		 ret	 0
$L68808:
  001c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  001d0	0f b6 45 e3	 movzx	 eax, BYTE PTR __Changed$[ebp]
  001d4	85 c0		 test	 eax, eax
  001d6	75 09		 jne	 SHORT $L67376

; 517  : 		_State |= ios_base::failbit;

  001d8	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001db	83 c9 02	 or	 ecx, 2
  001de	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L67376:

; 518  : 	_Istr.setstate(_State);

  001e1	6a 00		 push	 0
  001e3	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001e6	52		 push	 edx
  001e7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ec	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001ef	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001f2	8b ca		 mov	 ecx, edx
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 519  : 	return (_Istr);

  001fa	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001fd	89 45 d0	 mov	 DWORD PTR $T68807[ebp], eax
  00200	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00207	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0020a	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0020f	8b 45 d0	 mov	 eax, DWORD PTR $T68807[ebp]

; 520  : 	}

  00212	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00215	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0021c	5f		 pop	 edi
  0021d	5e		 pop	 esi
  0021e	5b		 pop	 ebx
  0021f	8b e5		 mov	 esp, ebp
  00221	5d		 pop	 ebp
  00222	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68810:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
__ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68812
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z:NEAR
EXTRN	__imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z:NEAR
EXTRN	__imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68836	DD	0ffffffffH
	DD	FLAT:$L68832
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68838	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68831
$T68837	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T68838
$T68834	DD	019930520H
	DD	03H
	DD	FLAT:$T68836
	DD	01H
	DD	FLAT:$T68837
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv221 = -105						; size = 1
tv220 = -104						; size = 2
tv219 = -102						; size = 2
tv218 = -100						; size = 4
tv217 = -96						; size = 2
tv216 = -93						; size = 1
tv215 = -92						; size = 2
tv214 = -90						; size = 2
tv213 = -88						; size = 4
tv212 = -84						; size = 4
tv211 = -77						; size = 1
tv210 = -76						; size = 2
tv209 = -74						; size = 2
tv208 = -72						; size = 4
tv207 = -66						; size = 2
tv83 = -64						; size = 4
tv81 = -60						; size = 4
$T68829 = -56						; size = 4
$T68828 = -52						; size = 2
$T68827 = -50						; size = 2
$T68826 = -48						; size = 2
$T68825 = -46						; size = 2
$T68824 = -44						; size = 2
$T68823 = -42						; size = 2
__Count$67399 = -40					; size = 4
__Size$ = -36						; size = 4
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00032	89 45 dc	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0003d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00040	8b ca		 mov	 ecx, edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00048	85 c0		 test	 eax, eax
  0004a	7e 33		 jle	 SHORT $L68821
  0004c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00054	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00057	8b ca		 mov	 ecx, edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0005f	3b 45 dc	 cmp	 eax, DWORD PTR __Size$[ebp]
  00062	76 1b		 jbe	 SHORT $L68821
  00064	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00077	2b 45 dc	 sub	 eax, DWORD PTR __Size$[ebp]
  0007a	89 45 c4	 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 07		 jmp	 SHORT $L68822
$L68821:
  0007f	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L68822:
  00086	8b 45 c4	 mov	 eax, DWORD PTR tv81[ebp]
  00089	89 45 e8	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008f	51		 push	 ecx
  00090	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00093	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  0009f	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000a2	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  000a7	0f b6 d0	 movzx	 edx, al
  000aa	85 d2		 test	 edx, edx
  000ac	75 0e		 jne	 SHORT $L67388

; 550  : 		_State |= ios_base::badbit;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000b1	83 c8 04	 or	 eax, 4
  000b4	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000b7	e9 37 02 00 00	 jmp	 $L68830
$L67388:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  000d1	89 45 c0	 mov	 DWORD PTR tv83[ebp], eax
  000d4	8b 45 c0	 mov	 eax, DWORD PTR tv83[ebp]
  000d7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000dc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000df	0f 84 96 00 00
	00		 je	 $L67391

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000e5	eb 09		 jmp	 SHORT $L67392
$L67393:
  000e7	8b 4d e8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  000ea	83 e9 01	 sub	 ecx, 1
  000ed	89 4d e8	 mov	 DWORD PTR __Pad$[ebp], ecx
$L67392:
  000f0	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  000f4	0f 86 81 00 00
	00		 jbe	 $L67391

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  000fa	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00102	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  0010b	66 89 45 be	 mov	 WORD PTR tv207[ebp], ax
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00117	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00120	89 45 b8	 mov	 DWORD PTR tv208[ebp], eax
  00123	66 8b 45 be	 mov	 ax, WORD PTR tv207[ebp]
  00127	50		 push	 eax
  00128	8b 4d b8	 mov	 ecx, DWORD PTR tv208[ebp]
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00131	66 89 45 b6	 mov	 WORD PTR tv209[ebp], ax
  00135	66 8b 4d b6	 mov	 cx, WORD PTR tv209[ebp]
  00139	66 89 4d d6	 mov	 WORD PTR $T68823[ebp], cx
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00143	66 89 45 b4	 mov	 WORD PTR tv210[ebp], ax
  00147	66 8b 55 b4	 mov	 dx, WORD PTR tv210[ebp]
  0014b	66 89 55 d4	 mov	 WORD PTR $T68824[ebp], dx
  0014f	8d 45 d6	 lea	 eax, DWORD PTR $T68823[ebp]
  00152	50		 push	 eax
  00153	8d 4d d4	 lea	 ecx, DWORD PTR $T68824[ebp]
  00156	51		 push	 ecx
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  0015d	83 c4 08	 add	 esp, 8
  00160	88 45 b3	 mov	 BYTE PTR tv211[ebp], al
  00163	0f b6 55 b3	 movzx	 edx, BYTE PTR tv211[ebp]
  00167	85 d2		 test	 edx, edx
  00169	74 0b		 je	 SHORT $L67397

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  0016b	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0016e	83 c8 04	 or	 eax, 4
  00171	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  00174	eb 05		 jmp	 SHORT $L67391
$L67397:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  00176	e9 6c ff ff ff	 jmp	 $L67393
$L67391:
  0017b	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  0017f	0f 85 98 00 00
	00		 jne	 $L67398

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00185	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Count$67399[ebp], 0
  0018c	eb 09		 jmp	 SHORT $L67400
$L67401:
  0018e	8b 4d d8	 mov	 ecx, DWORD PTR __Count$67399[ebp]
  00191	83 c1 01	 add	 ecx, 1
  00194	89 4d d8	 mov	 DWORD PTR __Count$67399[ebp], ecx
$L67400:
  00197	8b 55 d8	 mov	 edx, DWORD PTR __Count$67399[ebp]
  0019a	3b 55 dc	 cmp	 edx, DWORD PTR __Size$[ebp]
  0019d	73 7e		 jae	 SHORT $L67398

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  0019f	8b 45 d8	 mov	 eax, DWORD PTR __Count$67399[ebp]
  001a2	50		 push	 eax
  001a3	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z
  001ac	89 45 ac	 mov	 DWORD PTR tv212[ebp], eax
  001af	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b4	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001b7	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  001c0	89 45 a8	 mov	 DWORD PTR tv213[ebp], eax
  001c3	8b 45 ac	 mov	 eax, DWORD PTR tv212[ebp]
  001c6	66 8b 08	 mov	 cx, WORD PTR [eax]
  001c9	51		 push	 ecx
  001ca	8b 4d a8	 mov	 ecx, DWORD PTR tv213[ebp]
  001cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  001d3	66 89 45 a6	 mov	 WORD PTR tv214[ebp], ax
  001d7	66 8b 55 a6	 mov	 dx, WORD PTR tv214[ebp]
  001db	66 89 55 d2	 mov	 WORD PTR $T68825[ebp], dx
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  001e5	66 89 45 a4	 mov	 WORD PTR tv215[ebp], ax
  001e9	66 8b 45 a4	 mov	 ax, WORD PTR tv215[ebp]
  001ed	66 89 45 d0	 mov	 WORD PTR $T68826[ebp], ax
  001f1	8d 4d d2	 lea	 ecx, DWORD PTR $T68825[ebp]
  001f4	51		 push	 ecx
  001f5	8d 55 d0	 lea	 edx, DWORD PTR $T68826[ebp]
  001f8	52		 push	 edx
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  001ff	83 c4 08	 add	 esp, 8
  00202	88 45 a3	 mov	 BYTE PTR tv216[ebp], al
  00205	0f b6 45 a3	 movzx	 eax, BYTE PTR tv216[ebp]
  00209	85 c0		 test	 eax, eax
  0020b	74 0b		 je	 SHORT $L67405

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  0020d	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00210	83 c9 04	 or	 ecx, 4
  00213	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  00216	eb 05		 jmp	 SHORT $L67398
$L67405:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00218	e9 71 ff ff ff	 jmp	 $L67401
$L67398:
  0021d	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00221	0f 85 9a 00 00
	00		 jne	 $L67406

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00227	eb 09		 jmp	 SHORT $L67407
$L67408:
  00229	8b 55 e8	 mov	 edx, DWORD PTR __Pad$[ebp]
  0022c	83 ea 01	 sub	 edx, 1
  0022f	89 55 e8	 mov	 DWORD PTR __Pad$[ebp], edx
$L67407:
  00232	83 7d e8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00236	0f 86 85 00 00
	00		 jbe	 $L67406

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  0023c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0023f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00241	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00244	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00247	8b ca		 mov	 ecx, edx
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  0024f	66 89 45 a0	 mov	 WORD PTR tv217[ebp], ax
  00253	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00256	8b 08		 mov	 ecx, DWORD PTR [eax]
  00258	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0025b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0025e	8b ca		 mov	 ecx, edx
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00266	89 45 9c	 mov	 DWORD PTR tv218[ebp], eax
  00269	66 8b 45 a0	 mov	 ax, WORD PTR tv217[ebp]
  0026d	50		 push	 eax
  0026e	8b 4d 9c	 mov	 ecx, DWORD PTR tv218[ebp]
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00277	66 89 45 9a	 mov	 WORD PTR tv219[ebp], ax
  0027b	66 8b 4d 9a	 mov	 cx, WORD PTR tv219[ebp]
  0027f	66 89 4d ce	 mov	 WORD PTR $T68827[ebp], cx
  00283	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00289	66 89 45 98	 mov	 WORD PTR tv220[ebp], ax
  0028d	66 8b 55 98	 mov	 dx, WORD PTR tv220[ebp]
  00291	66 89 55 cc	 mov	 WORD PTR $T68828[ebp], dx
  00295	8d 45 ce	 lea	 eax, DWORD PTR $T68827[ebp]
  00298	50		 push	 eax
  00299	8d 4d cc	 lea	 ecx, DWORD PTR $T68828[ebp]
  0029c	51		 push	 ecx
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  002a3	83 c4 08	 add	 esp, 8
  002a6	88 45 97	 mov	 BYTE PTR tv221[ebp], al
  002a9	0f b6 55 97	 movzx	 edx, BYTE PTR tv221[ebp]
  002ad	85 d2		 test	 edx, edx
  002af	74 0b		 je	 SHORT $L67412

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  002b1	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002b4	83 c8 04	 or	 eax, 4
  002b7	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  002ba	eb 05		 jmp	 SHORT $L67406
$L67412:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  002bc	e9 68 ff ff ff	 jmp	 $L67408
$L67406:
  002c1	6a 00		 push	 0
  002c3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002cb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  002d4	eb 1d		 jmp	 SHORT $L68830
$L68831:

; 581  : 		_CATCH_IO_(_Ostr)

  002d6	6a 01		 push	 1
  002d8	6a 04		 push	 4
  002da	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002df	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002e2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002e5	8b ca		 mov	 ecx, edx
  002e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  002ed	b8 00 00 00 00	 mov	 eax, $L68830
  002f2	c3		 ret	 0
$L68830:
  002f3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  002fa	6a 00		 push	 0
  002fc	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  002ff	50		 push	 eax
  00300	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00303	8b 11		 mov	 edx, DWORD PTR [ecx]
  00305	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00308	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 585  : 	return (_Ostr);

  00311	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00314	89 45 c8	 mov	 DWORD PTR $T68829[ebp], eax
  00317	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0031e	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00321	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00326	8b 45 c8	 mov	 eax, DWORD PTR $T68829[ebp]

; 586  : 	}

  00329	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0032c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00333	5f		 pop	 edi
  00334	5e		 pop	 esi
  00335	5b		 pop	 ebx
  00336	8b e5		 mov	 esp, ebp
  00338	5d		 pop	 ebp
  00339	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68832:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68834
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T68847	DD	0ffffffffH
	DD	FLAT:$L68843
$T68845	DD	019930520H
	DD	01H
	DD	FLAT:$T68847
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00037	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	74 30		 je	 SHORT $L66691
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  00058	85 c0		 test	 eax, eax
  0005a	74 1b		 je	 SHORT $L66691

; 90   : 				_Ostr.tie()->flush();

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b ca		 mov	 ecx, edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  0006f	8b c8		 mov	 ecx, eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
$L66691:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00077	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00082	8b ca		 mov	 ecx, edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68843:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68845
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
EXTRN	__imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T68856	DD	0ffffffffH
	DD	FLAT:$L68852
$T68854	DD	019930520H
	DD	01H
	DD	FLAT:$T68856
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0b		 jne	 SHORT $L66693

; 99   : 				this->_Myostr._Osfx();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L66693:

; 100  : 			}

  0003b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68852:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68854
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Odt
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	85 c0		 test	 eax, eax
  00028	74 1d		 je	 SHORT $L66926

; 70   : 				_Myostr.rdbuf()->_Lock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0003f	8b c8		 mov	 ecx, eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L66926:

; 71   : 			}

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L66929

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00035	8b c8		 mov	 ecx, eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L66929:

; 77   : 			}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
END
