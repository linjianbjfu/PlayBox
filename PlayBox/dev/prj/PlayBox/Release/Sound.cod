; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\util\Sound.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??_GCSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CSound@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CSound@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSound@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCSound@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CSound@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_self@CSound@@2PAV1@A				; CSound::m_self
_BSS	SEGMENT
?m_self@CSound@@2PAV1@A DD 01H DUP (?)			; CSound::m_self
_BSS	ENDS
PUBLIC	??0CSound@@QAE@XZ				; CSound::CSound
PUBLIC	?GetInstance@CSound@@SAPAV1@XZ			; CSound::GetInstance
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T200636 DD	0ffffffffH
	DD	FLAT:$L200629
$T200633 DD	019930520H
	DD	01H
	DD	FLAT:$T200636
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\util\sound.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv72 = -24						; size = 4
$T200626 = -20						; size = 4
$T200625 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?GetInstance@CSound@@SAPAV1@XZ PROC NEAR		; CSound::GetInstance

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetInstance@CSound@@SAPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 15   : 	if( m_self == NULL )

  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_self@CSound@@2PAV1@A, 0 ; CSound::m_self
  00022	75 47		 jne	 SHORT $L200097

; 16   : 	{
; 17   : 		m_self = new CSound();

  00024	68 9c 00 00 00	 push	 156			; 0000009cH
  00029	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 ec	 mov	 DWORD PTR $T200626[ebp], eax
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003b	83 7d ec 00	 cmp	 DWORD PTR $T200626[ebp], 0
  0003f	74 0d		 je	 SHORT $L200627
  00041	8b 4d ec	 mov	 ecx, DWORD PTR $T200626[ebp]
  00044	e8 00 00 00 00	 call	 ??0CSound@@QAE@XZ	; CSound::CSound
  00049	89 45 e8	 mov	 DWORD PTR tv72[ebp], eax
  0004c	eb 07		 jmp	 SHORT $L200628
$L200627:
  0004e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L200628:
  00055	8b 45 e8	 mov	 eax, DWORD PTR tv72[ebp]
  00058	89 45 f0	 mov	 DWORD PTR $T200625[ebp], eax
  0005b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00062	8b 4d f0	 mov	 ecx, DWORD PTR $T200625[ebp]
  00065	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_self@CSound@@2PAV1@A, ecx ; CSound::m_self
$L200097:

; 18   : 	}
; 19   : 	return m_self;

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_self@CSound@@2PAV1@A ; CSound::m_self

; 20   : }

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L200629:
  00000	8b 45 ec	 mov	 eax, DWORD PTR $T200626[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?GetInstance@CSound@@SAPAV1@XZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T200633
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetInstance@CSound@@SAPAV1@XZ ENDP			; CSound::GetInstance
PUBLIC	?DelInstance@CSound@@SAXXZ			; CSound::DelInstance
; Function compile flags: /Odt
_TEXT	SEGMENT
tv71 = -12						; size = 4
$T200640 = -8						; size = 4
$T200639 = -4						; size = 4
?DelInstance@CSound@@SAXXZ PROC NEAR			; CSound::DelInstance

; 23   : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 24   : 	if( m_self != NULL )

  00086	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_self@CSound@@2PAV1@A, 0 ; CSound::m_self
  0008d	74 2c		 je	 SHORT $L200104

; 25   : 	{
; 26   : 		delete m_self;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_self@CSound@@2PAV1@A ; CSound::m_self
  00094	89 45 f8	 mov	 DWORD PTR $T200640[ebp], eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR $T200640[ebp]
  0009a	89 4d fc	 mov	 DWORD PTR $T200639[ebp], ecx
  0009d	83 7d fc 00	 cmp	 DWORD PTR $T200639[ebp], 0
  000a1	74 11		 je	 SHORT $L200641
  000a3	6a 01		 push	 1
  000a5	8b 55 fc	 mov	 edx, DWORD PTR $T200639[ebp]
  000a8	8b 02		 mov	 eax, DWORD PTR [edx]
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR $T200639[ebp]
  000ad	ff 10		 call	 DWORD PTR [eax]
  000af	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  000b2	eb 07		 jmp	 SHORT $L200104
$L200641:
  000b4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L200104:

; 27   : 	}
; 28   : 	m_self = NULL;

  000bb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_self@CSound@@2PAV1@A, 0 ; CSound::m_self

; 29   : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
?DelInstance@CSound@@SAXXZ ENDP				; CSound::DelInstance
_TEXT	ENDS
PUBLIC	??_7CSound@@6B@					; CSound::`vftable'
PUBLIC	??_GCSound@@UAEPAXI@Z				; CSound::`scalar deleting destructor'
PUBLIC	??_R4CSound@@6B@				; CSound::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSound@@@8				; CSound `RTTI Type Descriptor'
PUBLIC	??_R3CSound@@8					; CSound::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSound@@8					; CSound::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CSound@@8				; CSound::`RTTI Base Class Descriptor at (0,-1,0,0)'
EXTRN	??_ECSound@@UAEPAXI@Z:NEAR			; CSound::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_7CSound@@6B@
CONST	SEGMENT
??_7CSound@@6B@ DD FLAT:??_R4CSound@@6B@		; CSound::`vftable'
	DD	FLAT:??_ECSound@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CSound@@6B@
rdata$r	SEGMENT
??_R4CSound@@6B@ DD 00H					; CSound::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSound@@@8
	DD	FLAT:??_R3CSound@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSound@@@8
_DATA	SEGMENT
??_R0?AVCSound@@@8 DD FLAT:??_7type_info@@6B@		; CSound `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSound@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CSound@@8
rdata$r	SEGMENT
??_R3CSound@@8 DD 00H					; CSound::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CSound@@8
rdata$r	ENDS
;	COMDAT ??_R2CSound@@8
rdata$r	SEGMENT
??_R2CSound@@8 DD FLAT:??_R1A@?0A@A@CSound@@8		; CSound::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CSound@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CSound@@8 DD FLAT:??_R0?AVCSound@@@8	; CSound::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt
rdata$r	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CSound@@QAE@XZ PROC NEAR				; CSound::CSound
; _this$ = ecx

; 36   : {

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	51		 push	 ecx
  000d4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSound@@6B@

; 37   : 	m_device=1;

  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 38   : }

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
??0CSound@@QAE@XZ ENDP					; CSound::CSound
_TEXT	ENDS
PUBLIC	??1CSound@@UAE@XZ				; CSound::~CSound
; Function compile flags: /Odt
;	COMDAT ??_GCSound@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCSound@@UAEPAXI@Z PROC NEAR				; CSound::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CSound@@UAE@XZ	; CSound::~CSound
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $L200113
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L200113:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GCSound@@UAEPAXI@Z ENDP				; CSound::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CSound@@UAE@XZ PROC NEAR				; CSound::~CSound
; _this$ = ecx

; 41   : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp
  00103	51		 push	 ecx
  00104	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00107	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSound@@6B@

; 42   : 
; 43   : }

  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
??1CSound@@UAE@XZ ENDP					; CSound::~CSound
_TEXT	ENDS
PUBLIC	?GetDevice@CSound@@AAE_NHAAPAUHMIXER__@@@Z	; CSound::GetDevice
EXTRN	__imp__mixerOpen@20:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_dev$ = 8						; size = 4
_hmixer$ = 12						; size = 4
?GetDevice@CSound@@AAE_NHAAPAUHMIXER__@@@Z PROC NEAR	; CSound::GetDevice
; _this$ = ecx

; 47   : {

  00120	55		 push	 ebp
  00121	8b ec		 mov	 ebp, esp
  00123	83 ec 08	 sub	 esp, 8
  00126	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 48   : 	switch(dev)   

  00129	8b 45 08	 mov	 eax, DWORD PTR _dev$[ebp]
  0012c	89 45 f8	 mov	 DWORD PTR tv64[ebp], eax
  0012f	8b 4d f8	 mov	 ecx, DWORD PTR tv64[ebp]
  00132	83 e9 01	 sub	 ecx, 1
  00135	89 4d f8	 mov	 DWORD PTR tv64[ebp], ecx
  00138	83 7d f8 05	 cmp	 DWORD PTR tv64[ebp], 5
  0013c	77 46		 ja	 SHORT $L200131
  0013e	8b 55 f8	 mov	 edx, DWORD PTR tv64[ebp]
  00141	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L200648[edx*4]
$L200126:

; 49   : 	{   
; 50   : 	case 1:  //WAVE
; 51   : 		m_device=MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT;

  00148	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0014b	c7 40 04 08 10
	00 00		 mov	 DWORD PTR [eax+4], 4104	; 00001008H

; 52   : 		break;

  00152	eb 3a		 jmp	 SHORT $L200123
$L200127:

; 53   : 	case 2:  //MIDI
; 54   : 		m_device=MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER;

  00154	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00157	c7 41 04 04 10
	00 00		 mov	 DWORD PTR [ecx+4], 4100	; 00001004H

; 55   : 		break;

  0015e	eb 2e		 jmp	 SHORT $L200123
$L200128:

; 56   : 	case 3:  //LINE IN / cd音量
; 57   : 	case 4:
; 58   : 		m_device=MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC;

  00160	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00163	c7 42 04 05 10
	00 00		 mov	 DWORD PTR [edx+4], 4101	; 00001005H

; 59   : 		break;

  0016a	eb 22		 jmp	 SHORT $L200123
$L200129:

; 60   : 	case 5:  //麦克风音量
; 61   : 		m_device=MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE;

  0016c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0016f	c7 40 04 03 10
	00 00		 mov	 DWORD PTR [eax+4], 4099	; 00001003H

; 62   : 		break;

  00176	eb 16		 jmp	 SHORT $L200123
$L200130:

; 63   : 	case 6:  //PC   扬声器音量
; 64   : 		m_device=MIXERLINE_COMPONENTTYPE_SRC_LINE;

  00178	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0017b	c7 41 04 02 10
	00 00		 mov	 DWORD PTR [ecx+4], 4098	; 00001002H

; 65   : 		break;  

  00182	eb 0a		 jmp	 SHORT $L200123
$L200131:

; 66   : 	default:   //主音量
; 67   : 		m_device=MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;

  00184	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00187	c7 42 04 04 00
	00 00		 mov	 DWORD PTR [edx+4], 4
$L200123:

; 68   : 	}
; 69   : 	if(mixerOpen(&hmixer,0,0,0,0))

  0018e	6a 00		 push	 0
  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	6a 00		 push	 0
  00196	8b 45 0c	 mov	 eax, DWORD PTR _hmixer$[ebp]
  00199	50		 push	 eax
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mixerOpen@20
  001a0	85 c0		 test	 eax, eax
  001a2	74 04		 je	 SHORT $L200132

; 70   : 		return FALSE;

  001a4	32 c0		 xor	 al, al
  001a6	eb 02		 jmp	 SHORT $L200121
$L200132:

; 71   : 
; 72   : 	return TRUE;

  001a8	b0 01		 mov	 al, 1
$L200121:

; 73   : }

  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c2 08 00	 ret	 8
$L200648:
  001b0	00 00 00 00	 DD	 $L200126
  001b4	00 00 00 00	 DD	 $L200127
  001b8	00 00 00 00	 DD	 $L200128
  001bc	00 00 00 00	 DD	 $L200128
  001c0	00 00 00 00	 DD	 $L200129
  001c4	00 00 00 00	 DD	 $L200130
?GetDevice@CSound@@AAE_NHAAPAUHMIXER__@@@Z ENDP		; CSound::GetDevice
_TEXT	ENDS
PUBLIC	?GetVolumeControl@CSound@@QAE_NPAUHMIXER__@@JJPAUtagMIXERCONTROLA@@@Z ; CSound::GetVolumeControl
EXTRN	__imp__mixerGetLineControlsA@12:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__mixerGetLineInfoA@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -204						; size = 4
_mxlc$ = -200						; size = 24
_mxl$ = -176						; size = 168
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_hmixer$ = 8						; size = 4
_componentType$ = 12					; size = 4
_ctrlType$ = 16						; size = 4
_mxc$ = 20						; size = 4
?GetVolumeControl@CSound@@QAE_NPAUHMIXER__@@JJPAUtagMIXERCONTROLA@@@Z PROC NEAR ; CSound::GetVolumeControl
; _this$ = ecx

; 78   : {   

  001d0	55		 push	 ebp
  001d1	8b ec		 mov	 ebp, esp
  001d3	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  001d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  001de	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  001e1	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 79   : 	MIXERLINECONTROLS mxlc;   
; 80   : 	MIXERLINE mxl;   
; 81   : 	mxl.cbStruct = sizeof(mxl);   

  001e7	c7 85 50 ff ff
	ff a8 00 00 00	 mov	 DWORD PTR _mxl$[ebp], 168 ; 000000a8H

; 82   : 	mxl.dwComponentType = componentType;   

  001f1	8b 45 0c	 mov	 eax, DWORD PTR _componentType$[ebp]
  001f4	89 85 68 ff ff
	ff		 mov	 DWORD PTR _mxl$[ebp+24], eax

; 83   : 	if(!mixerGetLineInfo((HMIXEROBJ)hmixer,&mxl,MIXER_GETLINEINFOF_COMPONENTTYPE))   

  001fa	6a 03		 push	 3
  001fc	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _mxl$[ebp]
  00202	51		 push	 ecx
  00203	8b 55 08	 mov	 edx, DWORD PTR _hmixer$[ebp]
  00206	52		 push	 edx
  00207	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mixerGetLineInfoA@12
  0020d	85 c0		 test	 eax, eax
  0020f	75 5b		 jne	 SHORT $L200143

; 84   : 	{   
; 85   : 		mxlc.cbStruct = sizeof(mxlc);   

  00211	c7 85 38 ff ff
	ff 18 00 00 00	 mov	 DWORD PTR _mxlc$[ebp], 24 ; 00000018H

; 86   : 		mxlc.dwLineID = mxl.dwLineID;   

  0021b	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _mxl$[ebp+12]
  00221	89 85 3c ff ff
	ff		 mov	 DWORD PTR _mxlc$[ebp+4], eax

; 87   : 		mxlc.dwControlType = ctrlType;   

  00227	8b 4d 10	 mov	 ecx, DWORD PTR _ctrlType$[ebp]
  0022a	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _mxlc$[ebp+8], ecx

; 88   : 		mxlc.cControls = 1;   

  00230	c7 85 44 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _mxlc$[ebp+12], 1

; 89   : 		mxlc.cbmxctrl = sizeof(MIXERCONTROL);   

  0023a	c7 85 48 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _mxlc$[ebp+16], 148 ; 00000094H

; 90   : 		mxlc.pamxctrl = mxc;   

  00244	8b 55 14	 mov	 edx, DWORD PTR _mxc$[ebp]
  00247	89 95 4c ff ff
	ff		 mov	 DWORD PTR _mxlc$[ebp+20], edx

; 91   : 		if(mixerGetLineControls((HMIXEROBJ)hmixer,&mxlc,MIXER_GETLINECONTROLSF_ONEBYTYPE))   

  0024d	6a 02		 push	 2
  0024f	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _mxlc$[ebp]
  00255	50		 push	 eax
  00256	8b 4d 08	 mov	 ecx, DWORD PTR _hmixer$[ebp]
  00259	51		 push	 ecx
  0025a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mixerGetLineControlsA@12
  00260	85 c0		 test	 eax, eax
  00262	74 04		 je	 SHORT $L200146

; 92   : 			return FALSE;   

  00264	32 c0		 xor	 al, al
  00266	eb 06		 jmp	 SHORT $L200139
$L200146:

; 93   : 		else   
; 94   : 			return TRUE;   

  00268	b0 01		 mov	 al, 1
  0026a	eb 02		 jmp	 SHORT $L200139
$L200143:

; 95   : 	}   
; 96   : 	return FALSE;   

  0026c	32 c0		 xor	 al, al
$L200139:

; 97   : }  

  0026e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00271	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00276	8b e5		 mov	 esp, ebp
  00278	5d		 pop	 ebp
  00279	c2 10 00	 ret	 16			; 00000010H
?GetVolumeControl@CSound@@QAE_NPAUHMIXER__@@JJPAUtagMIXERCONTROLA@@@Z ENDP ; CSound::GetVolumeControl
_TEXT	ENDS
PUBLIC	?GetMuteValue@CSound@@QAEJPAUHMIXER__@@PAUtagMIXERCONTROLA@@@Z ; CSound::GetMuteValue
EXTRN	__imp__mixerGetControlDetailsA@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -32						; size = 4
_mxcdMute$ = -28					; size = 4
_mxcd$ = -24						; size = 24
_hmixer$ = 8						; size = 4
_mxc$ = 12						; size = 4
?GetMuteValue@CSound@@QAEJPAUHMIXER__@@PAUtagMIXERCONTROLA@@@Z PROC NEAR ; CSound::GetMuteValue
; _this$ = ecx

; 100  : {   

  00280	55		 push	 ebp
  00281	8b ec		 mov	 ebp, esp
  00283	83 ec 20	 sub	 esp, 32			; 00000020H
  00286	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 101  : 	MIXERCONTROLDETAILS   mxcd;   
; 102  : 	MIXERCONTROLDETAILS_BOOLEAN   mxcdMute;   
; 103  : 	mxcd.hwndOwner = 0;   

  00289	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+12], 0

; 104  : 	mxcd.cbStruct = sizeof(mxcd);   

  00290	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp], 24 ; 00000018H

; 105  : 	mxcd.dwControlID = mxc->dwControlID;   

  00297	8b 45 0c	 mov	 eax, DWORD PTR _mxc$[ebp]
  0029a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0029d	89 4d ec	 mov	 DWORD PTR _mxcd$[ebp+4], ecx

; 106  : 	mxcd.cbDetails = sizeof(mxcdMute);   

  002a0	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+16], 4

; 107  : 	mxcd.paDetails = &mxcdMute;   

  002a7	8d 55 e4	 lea	 edx, DWORD PTR _mxcdMute$[ebp]
  002aa	89 55 fc	 mov	 DWORD PTR _mxcd$[ebp+20], edx

; 108  : 	mxcd.cChannels = 1;   

  002ad	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+8], 1

; 109  : 	mxcd.cMultipleItems = 0;   

  002b4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+12], 0

; 110  : 	if(mixerGetControlDetails((HMIXEROBJ)hmixer,&mxcd,
; 111  : 		MIXER_OBJECTF_HMIXER|MIXER_GETCONTROLDETAILSF_VALUE))

  002bb	68 00 00 00 80	 push	 -2147483648		; 80000000H
  002c0	8d 45 e8	 lea	 eax, DWORD PTR _mxcd$[ebp]
  002c3	50		 push	 eax
  002c4	8b 4d 08	 mov	 ecx, DWORD PTR _hmixer$[ebp]
  002c7	51		 push	 ecx
  002c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mixerGetControlDetailsA@12
  002ce	85 c0		 test	 eax, eax
  002d0	74 05		 je	 SHORT $L200156

; 112  : 		return -1;   

  002d2	83 c8 ff	 or	 eax, -1
  002d5	eb 03		 jmp	 SHORT $L200152
$L200156:

; 113  : 	return mxcdMute.fValue;   

  002d7	8b 45 e4	 mov	 eax, DWORD PTR _mxcdMute$[ebp]
$L200152:

; 114  : }  

  002da	8b e5		 mov	 esp, ebp
  002dc	5d		 pop	 ebp
  002dd	c2 08 00	 ret	 8
?GetMuteValue@CSound@@QAEJPAUHMIXER__@@PAUtagMIXERCONTROLA@@@Z ENDP ; CSound::GetMuteValue
_TEXT	ENDS
PUBLIC	?SetMuteValue@CSound@@QAE_NPAUHMIXER__@@PAUtagMIXERCONTROLA@@_N@Z ; CSound::SetMuteValue
EXTRN	__imp__mixerSetControlDetails@12:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -32						; size = 4
_mxcdMute$ = -28					; size = 4
_mxcd$ = -24						; size = 24
_hmixer$ = 8						; size = 4
_mxc$ = 12						; size = 4
_mute$ = 16						; size = 1
?SetMuteValue@CSound@@QAE_NPAUHMIXER__@@PAUtagMIXERCONTROLA@@_N@Z PROC NEAR ; CSound::SetMuteValue
; _this$ = ecx

; 117  : {   

  002e0	55		 push	 ebp
  002e1	8b ec		 mov	 ebp, esp
  002e3	83 ec 20	 sub	 esp, 32			; 00000020H
  002e6	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	MIXERCONTROLDETAILS mxcd;
; 119  : 	MIXERCONTROLDETAILS_BOOLEAN mxcdMute;
; 120  : 	mxcdMute.fValue=mute;   

  002e9	0f b6 45 10	 movzx	 eax, BYTE PTR _mute$[ebp]
  002ed	89 45 e4	 mov	 DWORD PTR _mxcdMute$[ebp], eax

; 121  : 	mxcd.hwndOwner = 0;

  002f0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+12], 0

; 122  : 	mxcd.dwControlID = mxc->dwControlID;   

  002f7	8b 4d 0c	 mov	 ecx, DWORD PTR _mxc$[ebp]
  002fa	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002fd	89 55 ec	 mov	 DWORD PTR _mxcd$[ebp+4], edx

; 123  : 	mxcd.cbStruct = sizeof(mxcd);   

  00300	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp], 24 ; 00000018H

; 124  : 	mxcd.cbDetails = sizeof(mxcdMute);   

  00307	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+16], 4

; 125  : 	mxcd.paDetails = &mxcdMute;   

  0030e	8d 45 e4	 lea	 eax, DWORD PTR _mxcdMute$[ebp]
  00311	89 45 fc	 mov	 DWORD PTR _mxcd$[ebp+20], eax

; 126  : 	mxcd.cChannels = 1;   

  00314	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+8], 1

; 127  : 	mxcd.cMultipleItems = 0;   

  0031b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+12], 0

; 128  : 	if(mixerSetControlDetails((HMIXEROBJ)hmixer,&mxcd,
; 129  : 		MIXER_OBJECTF_HMIXER|MIXER_SETCONTROLDETAILSF_VALUE))

  00322	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00327	8d 4d e8	 lea	 ecx, DWORD PTR _mxcd$[ebp]
  0032a	51		 push	 ecx
  0032b	8b 55 08	 mov	 edx, DWORD PTR _hmixer$[ebp]
  0032e	52		 push	 edx
  0032f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mixerSetControlDetails@12
  00335	85 c0		 test	 eax, eax
  00337	74 04		 je	 SHORT $L200166

; 130  : 		return   FALSE; 

  00339	32 c0		 xor	 al, al
  0033b	eb 02		 jmp	 SHORT $L200162
$L200166:

; 131  : 
; 132  : 	return   TRUE;   

  0033d	b0 01		 mov	 al, 1
$L200162:

; 133  : }

  0033f	8b e5		 mov	 esp, ebp
  00341	5d		 pop	 ebp
  00342	c2 0c 00	 ret	 12			; 0000000cH
?SetMuteValue@CSound@@QAE_NPAUHMIXER__@@PAUtagMIXERCONTROLA@@_N@Z ENDP ; CSound::SetMuteValue
_TEXT	ENDS
PUBLIC	?GetVolumeValue@CSound@@QAEIPAUHMIXER__@@PAUtagMIXERCONTROLA@@@Z ; CSound::GetVolumeValue
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -32						; size = 4
_mxcd$ = -28						; size = 24
_vol$ = -4						; size = 4
_hmixer$ = 8						; size = 4
_mxc$ = 12						; size = 4
?GetVolumeValue@CSound@@QAEIPAUHMIXER__@@PAUtagMIXERCONTROLA@@@Z PROC NEAR ; CSound::GetVolumeValue
; _this$ = ecx

; 136  : {   

  00350	55		 push	 ebp
  00351	8b ec		 mov	 ebp, esp
  00353	83 ec 20	 sub	 esp, 32			; 00000020H
  00356	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 	MIXERCONTROLDETAILS   mxcd;
; 138  : 	MIXERCONTROLDETAILS_UNSIGNED   vol;   vol.dwValue=0;   

  00359	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vol$[ebp], 0

; 139  : 	mxcd.hwndOwner = 0;   

  00360	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+12], 0

; 140  : 	mxcd.cbStruct = sizeof(mxcd);   

  00367	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp], 24 ; 00000018H

; 141  : 	mxcd.dwControlID = mxc->dwControlID;   

  0036e	8b 45 0c	 mov	 eax, DWORD PTR _mxc$[ebp]
  00371	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00374	89 4d e8	 mov	 DWORD PTR _mxcd$[ebp+4], ecx

; 142  : 	mxcd.cbDetails = sizeof(vol);   

  00377	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+16], 4

; 143  : 	mxcd.paDetails = &vol;   

  0037e	8d 55 fc	 lea	 edx, DWORD PTR _vol$[ebp]
  00381	89 55 f8	 mov	 DWORD PTR _mxcd$[ebp+20], edx

; 144  : 	mxcd.cChannels = 1;   

  00384	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+8], 1

; 145  : 	if(mixerGetControlDetails((HMIXEROBJ)hmixer,&mxcd,MIXER_OBJECTF_HMIXER|MIXER_GETCONTROLDETAILSF_VALUE))  

  0038b	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00390	8d 45 e4	 lea	 eax, DWORD PTR _mxcd$[ebp]
  00393	50		 push	 eax
  00394	8b 4d 08	 mov	 ecx, DWORD PTR _hmixer$[ebp]
  00397	51		 push	 ecx
  00398	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mixerGetControlDetailsA@12
  0039e	85 c0		 test	 eax, eax
  003a0	74 05		 je	 SHORT $L200175

; 146  : 		return   -1;   

  003a2	83 c8 ff	 or	 eax, -1
  003a5	eb 03		 jmp	 SHORT $L200171
$L200175:

; 147  : 	return   vol.dwValue;   

  003a7	8b 45 fc	 mov	 eax, DWORD PTR _vol$[ebp]
$L200171:

; 148  : }

  003aa	8b e5		 mov	 esp, ebp
  003ac	5d		 pop	 ebp
  003ad	c2 08 00	 ret	 8
?GetVolumeValue@CSound@@QAEIPAUHMIXER__@@PAUtagMIXERCONTROLA@@@Z ENDP ; CSound::GetVolumeValue
_TEXT	ENDS
PUBLIC	?SetVolumeValue@CSound@@QAE_NPAUHMIXER__@@PAUtagMIXERCONTROLA@@J@Z ; CSound::SetVolumeValue
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -32						; size = 4
_mxcd$ = -28						; size = 24
_vol$ = -4						; size = 4
_hmixer$ = 8						; size = 4
_mxc$ = 12						; size = 4
_volume$ = 16						; size = 4
?SetVolumeValue@CSound@@QAE_NPAUHMIXER__@@PAUtagMIXERCONTROLA@@J@Z PROC NEAR ; CSound::SetVolumeValue
; _this$ = ecx

; 151  : {   

  003b0	55		 push	 ebp
  003b1	8b ec		 mov	 ebp, esp
  003b3	83 ec 20	 sub	 esp, 32			; 00000020H
  003b6	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 	MIXERCONTROLDETAILS   mxcd;
; 153  : 	MIXERCONTROLDETAILS_UNSIGNED vol;
; 154  : 	vol.dwValue = volume;

  003b9	8b 45 10	 mov	 eax, DWORD PTR _volume$[ebp]
  003bc	89 45 fc	 mov	 DWORD PTR _vol$[ebp], eax

; 155  : 	mxcd.hwndOwner = 0;

  003bf	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+12], 0

; 156  : 	mxcd.dwControlID = mxc->dwControlID;

  003c6	8b 4d 0c	 mov	 ecx, DWORD PTR _mxc$[ebp]
  003c9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003cc	89 55 e8	 mov	 DWORD PTR _mxcd$[ebp+4], edx

; 157  : 	mxcd.cbStruct = sizeof(mxcd);

  003cf	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp], 24 ; 00000018H

; 158  : 	mxcd.cbDetails = sizeof(vol);

  003d6	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+16], 4

; 159  : 	mxcd.paDetails = &vol;

  003dd	8d 45 fc	 lea	 eax, DWORD PTR _vol$[ebp]
  003e0	89 45 f8	 mov	 DWORD PTR _mxcd$[ebp+20], eax

; 160  : 	mxcd.cChannels = 1;

  003e3	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _mxcd$[ebp+8], 1

; 161  : 	if(mixerSetControlDetails((HMIXEROBJ)hmixer,&mxcd,
; 162  : 		MIXER_OBJECTF_HMIXER|MIXER_SETCONTROLDETAILSF_VALUE))   

  003ea	68 00 00 00 80	 push	 -2147483648		; 80000000H
  003ef	8d 4d e4	 lea	 ecx, DWORD PTR _mxcd$[ebp]
  003f2	51		 push	 ecx
  003f3	8b 55 08	 mov	 edx, DWORD PTR _hmixer$[ebp]
  003f6	52		 push	 edx
  003f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mixerSetControlDetails@12
  003fd	85 c0		 test	 eax, eax
  003ff	74 04		 je	 SHORT $L200185

; 163  : 		return FALSE; 

  00401	32 c0		 xor	 al, al
  00403	eb 02		 jmp	 SHORT $L200181
$L200185:

; 164  : 
; 165  : 	return TRUE;   

  00405	b0 01		 mov	 al, 1
$L200181:

; 166  : }

  00407	8b e5		 mov	 esp, ebp
  00409	5d		 pop	 ebp
  0040a	c2 0c 00	 ret	 12			; 0000000cH
?SetVolumeValue@CSound@@QAE_NPAUHMIXER__@@PAUtagMIXERCONTROLA@@J@Z ENDP ; CSound::SetVolumeValue
_TEXT	ENDS
PUBLIC	?GetVolume@CSound@@QAEII@Z			; CSound::GetVolume
EXTRN	__imp__mixerClose@4:NEAR
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_rt$ = -8						; size = 4
_hmixer$ = -4						; size = 4
_dev$ = 8						; size = 4
?GetVolume@CSound@@QAEII@Z PROC NEAR			; CSound::GetVolume
; _this$ = ecx

; 170  : {

  00410	55		 push	 ebp
  00411	8b ec		 mov	 ebp, esp
  00413	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00416	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 	unsigned rt=0;

  00419	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _rt$[ebp], 0

; 172  : 	HMIXER   hmixer;   
; 173  : 	if(!GetDevice(dev,hmixer))

  00420	8d 45 fc	 lea	 eax, DWORD PTR _hmixer$[ebp]
  00423	50		 push	 eax
  00424	8b 4d 08	 mov	 ecx, DWORD PTR _dev$[ebp]
  00427	51		 push	 ecx
  00428	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0042b	e8 00 00 00 00	 call	 ?GetDevice@CSound@@AAE_NHAAPAUHMIXER__@@@Z ; CSound::GetDevice
  00430	0f b6 d0	 movzx	 edx, al
  00433	85 d2		 test	 edx, edx
  00435	75 04		 jne	 SHORT $L200192

; 174  : 		return 0;

  00437	33 c0		 xor	 eax, eax
  00439	eb 58		 jmp	 SHORT $L200189
$L200192:

; 175  : 	if(!GetVolumeControl(hmixer,m_device,MIXERCONTROL_CONTROLTYPE_VOLUME,&m_volCtrl))

  0043b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0043e	83 c0 08	 add	 eax, 8
  00441	50		 push	 eax
  00442	68 01 00 03 50	 push	 1342373889		; 50030001H
  00447	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0044a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0044d	52		 push	 edx
  0044e	8b 45 fc	 mov	 eax, DWORD PTR _hmixer$[ebp]
  00451	50		 push	 eax
  00452	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00455	e8 00 00 00 00	 call	 ?GetVolumeControl@CSound@@QAE_NPAUHMIXER__@@JJPAUtagMIXERCONTROLA@@@Z ; CSound::GetVolumeControl
  0045a	0f b6 c8	 movzx	 ecx, al
  0045d	85 c9		 test	 ecx, ecx
  0045f	75 04		 jne	 SHORT $L200193

; 176  : 		return 0;

  00461	33 c0		 xor	 eax, eax
  00463	eb 2e		 jmp	 SHORT $L200189
$L200193:

; 177  : 	rt=GetVolumeValue(hmixer,&m_volCtrl)*100/m_volCtrl.Bounds.lMaximum;

  00465	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00468	83 c2 08	 add	 edx, 8
  0046b	52		 push	 edx
  0046c	8b 45 fc	 mov	 eax, DWORD PTR _hmixer$[ebp]
  0046f	50		 push	 eax
  00470	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00473	e8 00 00 00 00	 call	 ?GetVolumeValue@CSound@@QAEIPAUHMIXER__@@PAUtagMIXERCONTROLA@@@Z ; CSound::GetVolumeValue
  00478	6b c0 64	 imul	 eax, 100		; 00000064H
  0047b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0047e	33 d2		 xor	 edx, edx
  00480	f7 71 70	 div	 DWORD PTR [ecx+112]
  00483	89 45 f8	 mov	 DWORD PTR _rt$[ebp], eax

; 178  : 	mixerClose(hmixer);

  00486	8b 55 fc	 mov	 edx, DWORD PTR _hmixer$[ebp]
  00489	52		 push	 edx
  0048a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mixerClose@4

; 179  : 	return   rt;    

  00490	8b 45 f8	 mov	 eax, DWORD PTR _rt$[ebp]
$L200189:

; 180  : }

  00493	8b e5		 mov	 esp, ebp
  00495	5d		 pop	 ebp
  00496	c2 04 00	 ret	 4
?GetVolume@CSound@@QAEII@Z ENDP				; CSound::GetVolume
_TEXT	ENDS
PUBLIC	?SetVolume@CSound@@QAE_NJJ@Z			; CSound::SetVolume
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_hmixer$ = -8						; size = 4
_rc$ = -1						; size = 1
_dev$ = 8						; size = 4
_vol$ = 12						; size = 4
?SetVolume@CSound@@QAE_NJJ@Z PROC NEAR			; CSound::SetVolume
; _this$ = ecx

; 184  : {   

  004a0	55		 push	 ebp
  004a1	8b ec		 mov	 ebp, esp
  004a3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  004a6	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 185  : 	bool rc=FALSE;

  004a9	c6 45 ff 00	 mov	 BYTE PTR _rc$[ebp], 0

; 186  : 	HMIXER hmixer;   
; 187  : 	if(!GetDevice(dev,hmixer))

  004ad	8d 45 f8	 lea	 eax, DWORD PTR _hmixer$[ebp]
  004b0	50		 push	 eax
  004b1	8b 4d 08	 mov	 ecx, DWORD PTR _dev$[ebp]
  004b4	51		 push	 ecx
  004b5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  004b8	e8 00 00 00 00	 call	 ?GetDevice@CSound@@AAE_NHAAPAUHMIXER__@@@Z ; CSound::GetDevice
  004bd	0f b6 d0	 movzx	 edx, al
  004c0	85 d2		 test	 edx, edx
  004c2	75 04		 jne	 SHORT $L200201

; 188  : 		return FALSE;    

  004c4	32 c0		 xor	 al, al
  004c6	eb 6a		 jmp	 SHORT $L200198
$L200201:

; 189  : 	if(GetVolumeControl(hmixer,m_device,MIXERCONTROL_CONTROLTYPE_VOLUME,&m_volCtrl))   

  004c8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  004cb	83 c0 08	 add	 eax, 8
  004ce	50		 push	 eax
  004cf	68 01 00 03 50	 push	 1342373889		; 50030001H
  004d4	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  004d7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  004da	52		 push	 edx
  004db	8b 45 f8	 mov	 eax, DWORD PTR _hmixer$[ebp]
  004de	50		 push	 eax
  004df	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  004e2	e8 00 00 00 00	 call	 ?GetVolumeControl@CSound@@QAE_NPAUHMIXER__@@JJPAUtagMIXERCONTROLA@@@Z ; CSound::GetVolumeControl
  004e7	0f b6 c8	 movzx	 ecx, al
  004ea	85 c9		 test	 ecx, ecx
  004ec	74 37		 je	 SHORT $L200202

; 190  : 	{   
; 191  : 		vol=vol*m_volCtrl.Bounds.lMaximum/100;   

  004ee	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  004f1	8b 45 0c	 mov	 eax, DWORD PTR _vol$[ebp]
  004f4	0f af 42 70	 imul	 eax, DWORD PTR [edx+112]
  004f8	99		 cdq
  004f9	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  004fe	f7 f9		 idiv	 ecx
  00500	89 45 0c	 mov	 DWORD PTR _vol$[ebp], eax

; 192  : 		if(SetVolumeValue(hmixer,&m_volCtrl,vol))   

  00503	8b 55 0c	 mov	 edx, DWORD PTR _vol$[ebp]
  00506	52		 push	 edx
  00507	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0050a	83 c0 08	 add	 eax, 8
  0050d	50		 push	 eax
  0050e	8b 4d f8	 mov	 ecx, DWORD PTR _hmixer$[ebp]
  00511	51		 push	 ecx
  00512	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00515	e8 00 00 00 00	 call	 ?SetVolumeValue@CSound@@QAE_NPAUHMIXER__@@PAUtagMIXERCONTROLA@@J@Z ; CSound::SetVolumeValue
  0051a	0f b6 d0	 movzx	 edx, al
  0051d	85 d2		 test	 edx, edx
  0051f	74 04		 je	 SHORT $L200202

; 193  : 			rc=TRUE;   

  00521	c6 45 ff 01	 mov	 BYTE PTR _rc$[ebp], 1
$L200202:

; 194  : 	}   
; 195  : 	mixerClose(hmixer);

  00525	8b 45 f8	 mov	 eax, DWORD PTR _hmixer$[ebp]
  00528	50		 push	 eax
  00529	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mixerClose@4

; 196  : 	return rc;   

  0052f	8a 45 ff	 mov	 al, BYTE PTR _rc$[ebp]
$L200198:

; 197  : }

  00532	8b e5		 mov	 esp, ebp
  00534	5d		 pop	 ebp
  00535	c2 08 00	 ret	 8
?SetVolume@CSound@@QAE_NJJ@Z ENDP			; CSound::SetVolume
_TEXT	ENDS
PUBLIC	?SetMute@CSound@@QAE_NJ_N@Z			; CSound::SetMute
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_hmixer$ = -8						; size = 4
_rc$ = -1						; size = 1
_dev$ = 8						; size = 4
_sound$ = 12						; size = 1
?SetMute@CSound@@QAE_NJ_N@Z PROC NEAR			; CSound::SetMute
; _this$ = ecx

; 201  : {

  00540	55		 push	 ebp
  00541	8b ec		 mov	 ebp, esp
  00543	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00546	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 	bool rc=FALSE; 

  00549	c6 45 ff 00	 mov	 BYTE PTR _rc$[ebp], 0

; 203  : 	HMIXER hmixer;   
; 204  : 	if(!GetDevice(dev,hmixer))

  0054d	8d 45 f8	 lea	 eax, DWORD PTR _hmixer$[ebp]
  00550	50		 push	 eax
  00551	8b 4d 08	 mov	 ecx, DWORD PTR _dev$[ebp]
  00554	51		 push	 ecx
  00555	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00558	e8 00 00 00 00	 call	 ?GetDevice@CSound@@AAE_NHAAPAUHMIXER__@@@Z ; CSound::GetDevice
  0055d	0f b6 d0	 movzx	 edx, al
  00560	85 d2		 test	 edx, edx
  00562	75 04		 jne	 SHORT $L200211

; 205  : 		return FALSE;

  00564	32 c0		 xor	 al, al
  00566	eb 55		 jmp	 SHORT $L200208
$L200211:

; 206  : 	if(GetVolumeControl(hmixer,m_device,MIXERCONTROL_CONTROLTYPE_MUTE,&m_volCtrl))

  00568	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0056b	83 c0 08	 add	 eax, 8
  0056e	50		 push	 eax
  0056f	68 02 00 01 20	 push	 536936450		; 20010002H
  00574	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00577	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0057a	52		 push	 edx
  0057b	8b 45 f8	 mov	 eax, DWORD PTR _hmixer$[ebp]
  0057e	50		 push	 eax
  0057f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00582	e8 00 00 00 00	 call	 ?GetVolumeControl@CSound@@QAE_NPAUHMIXER__@@JJPAUtagMIXERCONTROLA@@@Z ; CSound::GetVolumeControl
  00587	0f b6 c8	 movzx	 ecx, al
  0058a	85 c9		 test	 ecx, ecx
  0058c	74 22		 je	 SHORT $L200212

; 207  : 		if(SetMuteValue(hmixer,&m_volCtrl,sound))   

  0058e	8a 55 0c	 mov	 dl, BYTE PTR _sound$[ebp]
  00591	52		 push	 edx
  00592	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00595	83 c0 08	 add	 eax, 8
  00598	50		 push	 eax
  00599	8b 4d f8	 mov	 ecx, DWORD PTR _hmixer$[ebp]
  0059c	51		 push	 ecx
  0059d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  005a0	e8 00 00 00 00	 call	 ?SetMuteValue@CSound@@QAE_NPAUHMIXER__@@PAUtagMIXERCONTROLA@@_N@Z ; CSound::SetMuteValue
  005a5	0f b6 d0	 movzx	 edx, al
  005a8	85 d2		 test	 edx, edx
  005aa	74 04		 je	 SHORT $L200212

; 208  : 			rc=TRUE;   

  005ac	c6 45 ff 01	 mov	 BYTE PTR _rc$[ebp], 1
$L200212:

; 209  : 	mixerClose(hmixer);   

  005b0	8b 45 f8	 mov	 eax, DWORD PTR _hmixer$[ebp]
  005b3	50		 push	 eax
  005b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mixerClose@4

; 210  : 	return rc;   

  005ba	8a 45 ff	 mov	 al, BYTE PTR _rc$[ebp]
$L200208:

; 211  : }

  005bd	8b e5		 mov	 esp, ebp
  005bf	5d		 pop	 ebp
  005c0	c2 08 00	 ret	 8
?SetMute@CSound@@QAE_NJ_N@Z ENDP			; CSound::SetMute
_TEXT	ENDS
PUBLIC	?GetMute@CSound@@QAE_NJ@Z			; CSound::GetMute
; Function compile flags: /Odt
_TEXT	SEGMENT
_this$ = -12						; size = 4
_hmixer$ = -8						; size = 4
_rc$ = -4						; size = 4
_dev$ = 8						; size = 4
?GetMute@CSound@@QAE_NJ@Z PROC NEAR			; CSound::GetMute
; _this$ = ecx

; 215  : { 

  005d0	55		 push	 ebp
  005d1	8b ec		 mov	 ebp, esp
  005d3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  005d6	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 216  : 	long rc=0;  

  005d9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _rc$[ebp], 0

; 217  : 	HMIXER hmixer;   
; 218  : 	if(!GetDevice(dev,hmixer))

  005e0	8d 45 f8	 lea	 eax, DWORD PTR _hmixer$[ebp]
  005e3	50		 push	 eax
  005e4	8b 4d 08	 mov	 ecx, DWORD PTR _dev$[ebp]
  005e7	51		 push	 ecx
  005e8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  005eb	e8 00 00 00 00	 call	 ?GetDevice@CSound@@AAE_NHAAPAUHMIXER__@@@Z ; CSound::GetDevice
  005f0	0f b6 d0	 movzx	 edx, al
  005f3	85 d2		 test	 edx, edx
  005f5	75 04		 jne	 SHORT $L200220

; 219  : 		return false; 

  005f7	32 c0		 xor	 al, al
  005f9	eb 52		 jmp	 SHORT $L200217
$L200220:

; 220  : 	if(GetVolumeControl(hmixer,m_device,MIXERCONTROL_CONTROLTYPE_MUTE,&m_volCtrl))   

  005fb	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  005fe	83 c0 08	 add	 eax, 8
  00601	50		 push	 eax
  00602	68 02 00 01 20	 push	 536936450		; 20010002H
  00607	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0060a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0060d	52		 push	 edx
  0060e	8b 45 f8	 mov	 eax, DWORD PTR _hmixer$[ebp]
  00611	50		 push	 eax
  00612	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00615	e8 00 00 00 00	 call	 ?GetVolumeControl@CSound@@QAE_NPAUHMIXER__@@JJPAUtagMIXERCONTROLA@@@Z ; CSound::GetVolumeControl
  0061a	0f b6 c8	 movzx	 ecx, al
  0061d	85 c9		 test	 ecx, ecx
  0061f	74 16		 je	 SHORT $L200221

; 221  : 		rc=GetMuteValue(hmixer,&m_volCtrl);

  00621	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00624	83 c2 08	 add	 edx, 8
  00627	52		 push	 edx
  00628	8b 45 f8	 mov	 eax, DWORD PTR _hmixer$[ebp]
  0062b	50		 push	 eax
  0062c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0062f	e8 00 00 00 00	 call	 ?GetMuteValue@CSound@@QAEJPAUHMIXER__@@PAUtagMIXERCONTROLA@@@Z ; CSound::GetMuteValue
  00634	89 45 fc	 mov	 DWORD PTR _rc$[ebp], eax
$L200221:

; 222  : 	mixerClose(hmixer);

  00637	8b 4d f8	 mov	 ecx, DWORD PTR _hmixer$[ebp]
  0063a	51		 push	 ecx
  0063b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mixerClose@4

; 223  : 	if(rc)

  00641	83 7d fc 00	 cmp	 DWORD PTR _rc$[ebp], 0
  00645	74 04		 je	 SHORT $L200222

; 224  : 		return true;

  00647	b0 01		 mov	 al, 1
  00649	eb 02		 jmp	 SHORT $L200217
$L200222:

; 225  : 
; 226  : 	return false;

  0064b	32 c0		 xor	 al, al
$L200217:

; 227  : }

  0064d	8b e5		 mov	 esp, ebp
  0064f	5d		 pop	 ebp
  00650	c2 04 00	 ret	 4
?GetMute@CSound@@QAE_NJ@Z ENDP				; CSound::GetMute
_TEXT	ENDS
END
