; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\boxgit\PlayBox\CommonLib\common\YL_Encrypter.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG1194	DB	'KoOtOiTvINGwd', 00H
	ORG $+2
$SG1196	DB	'_Y8g2E6n0E1i7L5t2IoOoNk', 00H
$SG1208	DB	'_Y8g2E6n0E1i7L5t2IoOoNk', 00H
$SG1210	DB	'KoOtOiTvINGwd', 00H
CONST	ENDS
PUBLIC	?XOR@@YAXPAD0HH@Z				; XOR
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
;	COMDAT rtc$IMZ
; File d:\boxgit\playbox\commonlib\common\yl_encrypter.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
_TEXT	SEGMENT
_i$1155 = -4						; size = 4
_data$ = 8						; size = 4
_key$ = 12						; size = 4
_datalen$ = 16						; size = 4
_keylen$ = 20						; size = 4
?XOR@@YAXPAD0HH@Z PROC NEAR				; XOR

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 21   : 	for (int i=0; i<datalen; i++)

  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1155[ebp], 0
  00012	eb 09		 jmp	 SHORT $L1156
$L1157:
  00014	8b 45 fc	 mov	 eax, DWORD PTR _i$1155[ebp]
  00017	83 c0 01	 add	 eax, 1
  0001a	89 45 fc	 mov	 DWORD PTR _i$1155[ebp], eax
$L1156:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _i$1155[ebp]
  00020	3b 4d 10	 cmp	 ecx, DWORD PTR _datalen$[ebp]
  00023	7d 23		 jge	 SHORT $L1154

; 22   : 		*(data+i) ^= *(key+i%keylen);

  00025	8b 45 fc	 mov	 eax, DWORD PTR _i$1155[ebp]
  00028	99		 cdq
  00029	f7 7d 14	 idiv	 DWORD PTR _keylen$[ebp]
  0002c	8b 45 0c	 mov	 eax, DWORD PTR _key$[ebp]
  0002f	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00033	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00036	03 55 fc	 add	 edx, DWORD PTR _i$1155[ebp]
  00039	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0003c	33 c1		 xor	 eax, ecx
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00041	03 4d fc	 add	 ecx, DWORD PTR _i$1155[ebp]
  00044	88 01		 mov	 BYTE PTR [ecx], al
  00046	eb cc		 jmp	 SHORT $L1157
$L1154:

; 23   : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?XOR@@YAXPAD0HH@Z ENDP					; XOR
_TEXT	ENDS
PUBLIC	?MOVE@@YAXPADHH@Z				; MOVE
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	_memcpy:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	_abs:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T1318 = -20						; size = 4
$T1317 = -16						; size = 4
_ptr$ = -12						; size = 4
_tmp$ = -8						; size = 4
_realpos$ = -4						; size = 4
_data$ = 8						; size = 4
_datalen$ = 12						; size = 4
_pos$ = 16						; size = 4
?MOVE@@YAXPADHH@Z PROC NEAR				; MOVE

; 26   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	83 ec 14	 sub	 esp, 20			; 00000014H
  00056	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0005b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0005e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00061	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00064	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00067	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 27   : 	if (pos == 0 || pos%datalen == 0)

  0006a	83 7d 10 00	 cmp	 DWORD PTR _pos$[ebp], 0
  0006e	74 0b		 je	 SHORT $L1165
  00070	8b 45 10	 mov	 eax, DWORD PTR _pos$[ebp]
  00073	99		 cdq
  00074	f7 7d 0c	 idiv	 DWORD PTR _datalen$[ebp]
  00077	85 d2		 test	 edx, edx
  00079	75 05		 jne	 SHORT $L1164
$L1165:

; 28   : 		return;

  0007b	e9 11 01 00 00	 jmp	 $L1163
$L1164:

; 29   : 
; 30   : 	int realpos = abs(pos);

  00080	8b 45 10	 mov	 eax, DWORD PTR _pos$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _abs
  00089	83 c4 04	 add	 esp, 4
  0008c	89 45 fc	 mov	 DWORD PTR _realpos$[ebp], eax
$L1168:

; 31   : 	while (realpos > datalen)

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _realpos$[ebp]
  00092	3b 4d 0c	 cmp	 ecx, DWORD PTR _datalen$[ebp]
  00095	7e 0b		 jle	 SHORT $L1169

; 32   : 		realpos -= datalen;

  00097	8b 55 fc	 mov	 edx, DWORD PTR _realpos$[ebp]
  0009a	2b 55 0c	 sub	 edx, DWORD PTR _datalen$[ebp]
  0009d	89 55 fc	 mov	 DWORD PTR _realpos$[ebp], edx
  000a0	eb ed		 jmp	 SHORT $L1168
$L1169:

; 33   : 	
; 34   : 	char* tmp = new char[realpos];

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _realpos$[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ab	83 c4 04	 add	 esp, 4
  000ae	89 45 f0	 mov	 DWORD PTR $T1317[ebp], eax
  000b1	8b 4d f0	 mov	 ecx, DWORD PTR $T1317[ebp]
  000b4	89 4d f8	 mov	 DWORD PTR _tmp$[ebp], ecx

; 35   : 	char* ptr;
; 36   : 	if (pos > 0)

  000b7	83 7d 10 00	 cmp	 DWORD PTR _pos$[ebp], 0
  000bb	7e 66		 jle	 SHORT $L1174

; 37   : 	{
; 38   : 		memcpy( tmp, data+datalen-realpos, realpos );

  000bd	8b 55 fc	 mov	 edx, DWORD PTR _realpos$[ebp]
  000c0	52		 push	 edx
  000c1	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000c4	03 45 0c	 add	 eax, DWORD PTR _datalen$[ebp]
  000c7	2b 45 fc	 sub	 eax, DWORD PTR _realpos$[ebp]
  000ca	50		 push	 eax
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 39   : 		ptr = data+datalen-1;

  000d7	8b 55 0c	 mov	 edx, DWORD PTR _datalen$[ebp]
  000da	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000dd	8d 4c 10 ff	 lea	 ecx, DWORD PTR [eax+edx-1]
  000e1	89 4d f4	 mov	 DWORD PTR _ptr$[ebp], ecx

; 40   : 		for (; ptr>data+realpos-1; ptr--)

  000e4	eb 09		 jmp	 SHORT $L1175
$L1176:
  000e6	8b 55 f4	 mov	 edx, DWORD PTR _ptr$[ebp]
  000e9	83 ea 01	 sub	 edx, 1
  000ec	89 55 f4	 mov	 DWORD PTR _ptr$[ebp], edx
$L1175:
  000ef	8b 45 fc	 mov	 eax, DWORD PTR _realpos$[ebp]
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000f5	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  000f9	39 55 f4	 cmp	 DWORD PTR _ptr$[ebp], edx
  000fc	76 0f		 jbe	 SHORT $L1177

; 41   : 			*ptr = *(ptr-realpos);

  000fe	8b 45 f4	 mov	 eax, DWORD PTR _ptr$[ebp]
  00101	2b 45 fc	 sub	 eax, DWORD PTR _realpos$[ebp]
  00104	8b 4d f4	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00107	8a 10		 mov	 dl, BYTE PTR [eax]
  00109	88 11		 mov	 BYTE PTR [ecx], dl
  0010b	eb d9		 jmp	 SHORT $L1176
$L1177:

; 42   : 		memcpy( data, tmp, realpos );

  0010d	8b 45 fc	 mov	 eax, DWORD PTR _realpos$[ebp]
  00110	50		 push	 eax
  00111	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  00114	51		 push	 ecx
  00115	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00118	52		 push	 edx
  00119	e8 00 00 00 00	 call	 _memcpy
  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 43   : 	}
; 44   : 	else

  00121	eb 5c		 jmp	 SHORT $L1178
$L1174:

; 45   : 	{
; 46   : 		memcpy( tmp, data, realpos );

  00123	8b 45 fc	 mov	 eax, DWORD PTR _realpos$[ebp]
  00126	50		 push	 eax
  00127	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0012a	51		 push	 ecx
  0012b	8b 55 f8	 mov	 edx, DWORD PTR _tmp$[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 _memcpy
  00134	83 c4 0c	 add	 esp, 12			; 0000000cH

; 47   : 		ptr = data;

  00137	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0013a	89 45 f4	 mov	 DWORD PTR _ptr$[ebp], eax

; 48   : 		for (; ptr<data+datalen-realpos; ptr++)

  0013d	eb 09		 jmp	 SHORT $L1179
$L1180:
  0013f	8b 4d f4	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00142	83 c1 01	 add	 ecx, 1
  00145	89 4d f4	 mov	 DWORD PTR _ptr$[ebp], ecx
$L1179:
  00148	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  0014b	03 55 0c	 add	 edx, DWORD PTR _datalen$[ebp]
  0014e	2b 55 fc	 sub	 edx, DWORD PTR _realpos$[ebp]
  00151	39 55 f4	 cmp	 DWORD PTR _ptr$[ebp], edx
  00154	73 0f		 jae	 SHORT $L1181

; 49   : 			*ptr = *(ptr+realpos);

  00156	8b 45 f4	 mov	 eax, DWORD PTR _ptr$[ebp]
  00159	03 45 fc	 add	 eax, DWORD PTR _realpos$[ebp]
  0015c	8b 4d f4	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0015f	8a 10		 mov	 dl, BYTE PTR [eax]
  00161	88 11		 mov	 BYTE PTR [ecx], dl
  00163	eb da		 jmp	 SHORT $L1180
$L1181:

; 50   : 		memcpy( data + datalen - realpos, tmp, realpos );

  00165	8b 45 fc	 mov	 eax, DWORD PTR _realpos$[ebp]
  00168	50		 push	 eax
  00169	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  0016c	51		 push	 ecx
  0016d	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00170	03 55 0c	 add	 edx, DWORD PTR _datalen$[ebp]
  00173	2b 55 fc	 sub	 edx, DWORD PTR _realpos$[ebp]
  00176	52		 push	 edx
  00177	e8 00 00 00 00	 call	 _memcpy
  0017c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1178:

; 51   : 	}
; 52   : 	delete []tmp;

  0017f	8b 45 f8	 mov	 eax, DWORD PTR _tmp$[ebp]
  00182	89 45 ec	 mov	 DWORD PTR $T1318[ebp], eax
  00185	8b 4d ec	 mov	 ecx, DWORD PTR $T1318[ebp]
  00188	51		 push	 ecx
  00189	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0018e	83 c4 04	 add	 esp, 4
$L1163:

; 53   : }

  00191	83 c4 14	 add	 esp, 20			; 00000014H
  00194	3b ec		 cmp	 ebp, esp
  00196	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c3		 ret	 0
?MOVE@@YAXPADHH@Z ENDP					; MOVE
_TEXT	ENDS
PUBLIC	?Encrypt@YL_Encrypter@@SAXPADHH@Z		; YL_Encrypter::Encrypt
EXTRN	___security_cookie:DWORD
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv64 = -64						; size = 4
_key2$1195 = -56					; size = 23
_key1$1193 = -24					; size = 13
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_memptr$ = 8						; size = 4
_memlen$ = 12						; size = 4
_algorithmType$ = 16					; size = 4
?Encrypt@YL_Encrypter@@SAXPADHH@Z PROC NEAR		; YL_Encrypter::Encrypt

; 56   : {

  001a0	55		 push	 ebp
  001a1	8b ec		 mov	 ebp, esp
  001a3	83 ec 40	 sub	 esp, 64			; 00000040H
  001a6	57		 push	 edi
  001a7	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  001aa	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001af	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  001b4	f3 ab		 rep stosd
  001b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  001bb	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 57   : 	switch (algorithmType)

  001be	8b 45 10	 mov	 eax, DWORD PTR _algorithmType$[ebp]
  001c1	89 45 c0	 mov	 DWORD PTR tv64[ebp], eax
  001c4	83 7d c0 00	 cmp	 DWORD PTR tv64[ebp], 0
  001c8	74 02		 je	 SHORT $L1192
  001ca	eb 79		 jmp	 SHORT $L1187
$L1192:

; 58   : 	{
; 59   : 	case 0:						//取前16个字节与后面的部分分别异或
; 60   : 		{
; 61   : 			char key1[XOR_KEY1_LEN];
; 62   : 			memcpy(key1,KT_ECRP_KEY1,XOR_KEY1_LEN);

  001cc	6a 0d		 push	 13			; 0000000dH
  001ce	68 00 00 00 00	 push	 OFFSET FLAT:$SG1194
  001d3	8d 4d e8	 lea	 ecx, DWORD PTR _key1$1193[ebp]
  001d6	51		 push	 ecx
  001d7	e8 00 00 00 00	 call	 _memcpy
  001dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 63   : 			MOVE( memptr, memlen,MOVE_POS1);		

  001df	68 85 00 00 00	 push	 133			; 00000085H
  001e4	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  001e7	52		 push	 edx
  001e8	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 ?MOVE@@YAXPADHH@Z	; MOVE
  001f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 64   : 			XOR( memptr, key1, memlen, XOR_KEY1_LEN );

  001f4	6a 0d		 push	 13			; 0000000dH
  001f6	8b 4d 0c	 mov	 ecx, DWORD PTR _memlen$[ebp]
  001f9	51		 push	 ecx
  001fa	8d 55 e8	 lea	 edx, DWORD PTR _key1$1193[ebp]
  001fd	52		 push	 edx
  001fe	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  00201	50		 push	 eax
  00202	e8 00 00 00 00	 call	 ?XOR@@YAXPAD0HH@Z	; XOR
  00207	83 c4 10	 add	 esp, 16			; 00000010H

; 65   : 			char key2[XOR_KEY2_LEN];
; 66   : 			memcpy(key2,KT_ECRP_KEY2,XOR_KEY2_LEN);

  0020a	6a 17		 push	 23			; 00000017H
  0020c	68 00 00 00 00	 push	 OFFSET FLAT:$SG1196
  00211	8d 4d c8	 lea	 ecx, DWORD PTR _key2$1195[ebp]
  00214	51		 push	 ecx
  00215	e8 00 00 00 00	 call	 _memcpy
  0021a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 67   : 			MOVE( memptr, memlen,-MOVE_POS2);

  0021d	6a b9		 push	 -71			; ffffffb9H
  0021f	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  00222	52		 push	 edx
  00223	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  00226	50		 push	 eax
  00227	e8 00 00 00 00	 call	 ?MOVE@@YAXPADHH@Z	; MOVE
  0022c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 68   : 			XOR( memptr, key2, memlen, XOR_KEY2_LEN );

  0022f	6a 17		 push	 23			; 00000017H
  00231	8b 4d 0c	 mov	 ecx, DWORD PTR _memlen$[ebp]
  00234	51		 push	 ecx
  00235	8d 55 c8	 lea	 edx, DWORD PTR _key2$1195[ebp]
  00238	52		 push	 edx
  00239	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  0023c	50		 push	 eax
  0023d	e8 00 00 00 00	 call	 ?XOR@@YAXPAD0HH@Z	; XOR
  00242	83 c4 10	 add	 esp, 16			; 00000010H
$L1187:

; 69   : 			break;
; 70   : 		}
; 71   : 	}
; 72   : }

  00245	52		 push	 edx
  00246	8b cd		 mov	 ecx, ebp
  00248	50		 push	 eax
  00249	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L1327
  0024f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00254	58		 pop	 eax
  00255	5a		 pop	 edx
  00256	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00259	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025e	5f		 pop	 edi
  0025f	83 c4 40	 add	 esp, 64			; 00000040H
  00262	3b ec		 cmp	 ebp, esp
  00264	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00269	8b e5		 mov	 esp, ebp
  0026b	5d		 pop	 ebp
  0026c	c3		 ret	 0
$L1327:
  0026d	02 00 00 00	 DD	 2
  00271	00 00 00 00	 DD	 $L1326
$L1326:
  00275	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00279	0d 00 00 00	 DD	 13			; 0000000dH
  0027d	00 00 00 00	 DD	 $L1322
  00281	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00285	17 00 00 00	 DD	 23			; 00000017H
  00289	00 00 00 00	 DD	 $L1323
$L1323:
  0028d	6b		 DB	 107			; 0000006bH
  0028e	65		 DB	 101			; 00000065H
  0028f	79		 DB	 121			; 00000079H
  00290	32		 DB	 50			; 00000032H
  00291	00		 DB	 0
$L1322:
  00292	6b		 DB	 107			; 0000006bH
  00293	65		 DB	 101			; 00000065H
  00294	79		 DB	 121			; 00000079H
  00295	31		 DB	 49			; 00000031H
  00296	00		 DB	 0
?Encrypt@YL_Encrypter@@SAXPADHH@Z ENDP			; YL_Encrypter::Encrypt
_TEXT	ENDS
PUBLIC	?Decrypt@YL_Encrypter@@SAXPADHH@Z		; YL_Encrypter::Decrypt
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv64 = -64						; size = 4
_key1$1209 = -56					; size = 13
_key2$1207 = -32					; size = 23
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_memptr$ = 8						; size = 4
_memlen$ = 12						; size = 4
_algorithmType$ = 16					; size = 4
?Decrypt@YL_Encrypter@@SAXPADHH@Z PROC NEAR		; YL_Encrypter::Decrypt

; 75   : {

  002a0	55		 push	 ebp
  002a1	8b ec		 mov	 ebp, esp
  002a3	83 ec 40	 sub	 esp, 64			; 00000040H
  002a6	57		 push	 edi
  002a7	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  002aa	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  002af	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  002b4	f3 ab		 rep stosd
  002b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  002bb	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 76   : 	switch (algorithmType)

  002be	8b 45 10	 mov	 eax, DWORD PTR _algorithmType$[ebp]
  002c1	89 45 c0	 mov	 DWORD PTR tv64[ebp], eax
  002c4	83 7d c0 00	 cmp	 DWORD PTR tv64[ebp], 0
  002c8	74 02		 je	 SHORT $L1206
  002ca	eb 79		 jmp	 SHORT $L1201
$L1206:

; 77   : 	{
; 78   : 	case 0:						//取前16个字节与后面的部分分别异或
; 79   : 		{
; 80   : 			char key2[XOR_KEY2_LEN];
; 81   : 			memcpy(key2,KT_ECRP_KEY2,XOR_KEY2_LEN);	

  002cc	6a 17		 push	 23			; 00000017H
  002ce	68 00 00 00 00	 push	 OFFSET FLAT:$SG1208
  002d3	8d 4d e0	 lea	 ecx, DWORD PTR _key2$1207[ebp]
  002d6	51		 push	 ecx
  002d7	e8 00 00 00 00	 call	 _memcpy
  002dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 82   : 			XOR( memptr, key2, memlen, XOR_KEY2_LEN );

  002df	6a 17		 push	 23			; 00000017H
  002e1	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  002e4	52		 push	 edx
  002e5	8d 45 e0	 lea	 eax, DWORD PTR _key2$1207[ebp]
  002e8	50		 push	 eax
  002e9	8b 4d 08	 mov	 ecx, DWORD PTR _memptr$[ebp]
  002ec	51		 push	 ecx
  002ed	e8 00 00 00 00	 call	 ?XOR@@YAXPAD0HH@Z	; XOR
  002f2	83 c4 10	 add	 esp, 16			; 00000010H

; 83   : 			MOVE( memptr, memlen,MOVE_POS2);	

  002f5	6a 47		 push	 71			; 00000047H
  002f7	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  002fa	52		 push	 edx
  002fb	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  002fe	50		 push	 eax
  002ff	e8 00 00 00 00	 call	 ?MOVE@@YAXPADHH@Z	; MOVE
  00304	83 c4 0c	 add	 esp, 12			; 0000000cH

; 84   : 
; 85   : 			char key1[XOR_KEY1_LEN];
; 86   : 			memcpy(key1,KT_ECRP_KEY1,XOR_KEY1_LEN);

  00307	6a 0d		 push	 13			; 0000000dH
  00309	68 00 00 00 00	 push	 OFFSET FLAT:$SG1210
  0030e	8d 4d c8	 lea	 ecx, DWORD PTR _key1$1209[ebp]
  00311	51		 push	 ecx
  00312	e8 00 00 00 00	 call	 _memcpy
  00317	83 c4 0c	 add	 esp, 12			; 0000000cH

; 87   : 			XOR( memptr, key1, memlen, XOR_KEY1_LEN );

  0031a	6a 0d		 push	 13			; 0000000dH
  0031c	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  0031f	52		 push	 edx
  00320	8d 45 c8	 lea	 eax, DWORD PTR _key1$1209[ebp]
  00323	50		 push	 eax
  00324	8b 4d 08	 mov	 ecx, DWORD PTR _memptr$[ebp]
  00327	51		 push	 ecx
  00328	e8 00 00 00 00	 call	 ?XOR@@YAXPAD0HH@Z	; XOR
  0032d	83 c4 10	 add	 esp, 16			; 00000010H

; 88   : 			MOVE( memptr, memlen,-MOVE_POS1);	

  00330	68 7b ff ff ff	 push	 -133			; ffffff7bH
  00335	8b 55 0c	 mov	 edx, DWORD PTR _memlen$[ebp]
  00338	52		 push	 edx
  00339	8b 45 08	 mov	 eax, DWORD PTR _memptr$[ebp]
  0033c	50		 push	 eax
  0033d	e8 00 00 00 00	 call	 ?MOVE@@YAXPADHH@Z	; MOVE
  00342	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1201:

; 89   : 
; 90   : 			break;
; 91   : 		}
; 92   : 	}
; 93   : }

  00345	52		 push	 edx
  00346	8b cd		 mov	 ecx, ebp
  00348	50		 push	 eax
  00349	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L1336
  0034f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00354	58		 pop	 eax
  00355	5a		 pop	 edx
  00356	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00359	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035e	5f		 pop	 edi
  0035f	83 c4 40	 add	 esp, 64			; 00000040H
  00362	3b ec		 cmp	 ebp, esp
  00364	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00369	8b e5		 mov	 esp, ebp
  0036b	5d		 pop	 ebp
  0036c	c3		 ret	 0
$L1336:
  0036d	02 00 00 00	 DD	 2
  00371	00 00 00 00	 DD	 $L1335
$L1335:
  00375	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00379	17 00 00 00	 DD	 23			; 00000017H
  0037d	00 00 00 00	 DD	 $L1332
  00381	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00385	0d 00 00 00	 DD	 13			; 0000000dH
  00389	00 00 00 00	 DD	 $L1333
$L1333:
  0038d	6b		 DB	 107			; 0000006bH
  0038e	65		 DB	 101			; 00000065H
  0038f	79		 DB	 121			; 00000079H
  00390	31		 DB	 49			; 00000031H
  00391	00		 DB	 0
$L1332:
  00392	6b		 DB	 107			; 0000006bH
  00393	65		 DB	 101			; 00000065H
  00394	79		 DB	 121			; 00000079H
  00395	32		 DB	 50			; 00000032H
  00396	00		 DB	 0
?Decrypt@YL_Encrypter@@SAXPADHH@Z ENDP			; YL_Encrypter::Decrypt
_TEXT	ENDS
END
