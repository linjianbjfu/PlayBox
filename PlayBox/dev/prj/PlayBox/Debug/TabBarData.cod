; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\module\TabMan\TabBarData.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??1IData@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppStart@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataAppExit@IData@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIData@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@OneLocalGame@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTabBarData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCTabBarData@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ITabBarData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ITabBarData@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CTabBarData@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GITabBarData@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GTAB_ITEM@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3ITabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CTabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ITabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CTabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ITabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTabBarData@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVIData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVITabBarData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCTabBarData@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4ITabBarData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CTabBarData@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EN@CBMLGOH@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FG@LDNDNCJM@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVITabBarObserver@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7ITabBarData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CTabBarData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?m_pTabBarData@CTabBarData@@2PAV1@A		; CTabBarData::m_pTabBarData
_BSS	SEGMENT
?m_pTabBarData@CTabBarData@@2PAV1@A DD 01H DUP (?)	; CTabBarData::m_pTabBarData
_BSS	ENDS
CONST	SEGMENT
_ID_MESSAGE_TABBAR DD 0bH
_ID_DATA_PANELCHANGE DD 05H
CONST	ENDS
PUBLIC	?GetInstance@CTabBarData@@SAPAVIData@@XZ	; CTabBarData::GetInstance
PUBLIC	??0CTabBarData@@QAE@XZ				; CTabBarData::CTabBarData
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__except_list:DWORD
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT rtc$IMZ
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabbardata.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
xdata$x	SEGMENT
$T190448 DD	0ffffffffH
	DD	FLAT:$L190440
$T190444 DD	019930520H
	DD	01H
	DD	FLAT:$T190448
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv72 = -24						; size = 4
$T190431 = -20						; size = 4
$T190430 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?GetInstance@CTabBarData@@SAPAVIData@@XZ PROC NEAR	; CTabBarData::GetInstance

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetInstance@CTabBarData@@SAPAVIData@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  00022	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00029	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH

; 10   : 	if(m_pTabBarData == NULL)

  00030	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A, 0 ; CTabBarData::m_pTabBarData
  00037	75 44		 jne	 SHORT $L188360

; 11   : 		m_pTabBarData = new CTabBarData();

  00039	6a 18		 push	 24			; 00000018H
  0003b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00040	83 c4 04	 add	 esp, 4
  00043	89 45 ec	 mov	 DWORD PTR $T190431[ebp], eax
  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004d	83 7d ec 00	 cmp	 DWORD PTR $T190431[ebp], 0
  00051	74 0d		 je	 SHORT $L190432
  00053	8b 4d ec	 mov	 ecx, DWORD PTR $T190431[ebp]
  00056	e8 00 00 00 00	 call	 ??0CTabBarData@@QAE@XZ
  0005b	89 45 e8	 mov	 DWORD PTR tv72[ebp], eax
  0005e	eb 07		 jmp	 SHORT $L190433
$L190432:
  00060	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L190433:
  00067	8b 45 e8	 mov	 eax, DWORD PTR tv72[ebp]
  0006a	89 45 f0	 mov	 DWORD PTR $T190430[ebp], eax
  0006d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00074	8b 4d f0	 mov	 ecx, DWORD PTR $T190430[ebp]
  00077	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A, ecx ; CTabBarData::m_pTabBarData
$L188360:

; 12   : 	return m_pTabBarData;

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A ; CTabBarData::m_pTabBarData

; 13   : }

  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0008c	83 c4 18	 add	 esp, 24			; 00000018H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L190440:
  00000	8b 45 ec	 mov	 eax, DWORD PTR $T190431[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?GetInstance@CTabBarData@@SAPAVIData@@XZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190444
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetInstance@CTabBarData@@SAPAVIData@@XZ ENDP		; CTabBarData::GetInstance
PUBLIC	??_R4CTabBarData@@6B@				; CTabBarData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTabBarData@@@8				; CTabBarData `RTTI Type Descriptor'
PUBLIC	??_R3CTabBarData@@8				; CTabBarData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTabBarData@@8				; CTabBarData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CTabBarData@@8			; CTabBarData::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@ITabBarData@@8			; ITabBarData::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVITabBarData@@@8				; ITabBarData `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@IData@@8				; IData::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVIData@@@8				; IData `RTTI Type Descriptor'
PUBLIC	??0ITabBarData@@QAE@XZ				; ITabBarData::ITabBarData
PUBLIC	??1ITabBarData@@UAE@XZ				; ITabBarData::~ITabBarData
PUBLIC	??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >
PUBLIC	?DataAppStart@CTabBarData@@UAEXXZ		; CTabBarData::DataAppStart
PUBLIC	?DataAppExit@CTabBarData@@UAEXXZ		; CTabBarData::DataAppExit
PUBLIC	?ITabBar_ChangeTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z ; CTabBarData::ITabBar_ChangeTab
PUBLIC	?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z ; CTabBarData::ITabBar_DeleteTab
PUBLIC	?ITabBar_GetCurPos@CTabBarData@@UAEHXZ		; CTabBarData::ITabBar_GetCurPos
PUBLIC	?ITabBar_GetCurItem@CTabBarData@@UAE_NAAUTAB_ITEM@@@Z ; CTabBarData::ITabBar_GetCurItem
PUBLIC	?ITabBar_GetTabBarData@CTabBarData@@UAEXAAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@Z ; CTabBarData::ITabBar_GetTabBarData
PUBLIC	??_7CTabBarData@@6B@				; CTabBarData::`vftable'
PUBLIC	??_GCTabBarData@@UAEPAXI@Z			; CTabBarData::`scalar deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECTabBarData@@UAEPAXI@Z:NEAR			; CTabBarData::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190456 DD	0ffffffffH
	DD	FLAT:$L190451
$T190454 DD	019930520H
	DD	01H
	DD	FLAT:$T190456
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CTabBarData@@6B@
CONST	SEGMENT
??_7CTabBarData@@6B@ DD FLAT:??_R4CTabBarData@@6B@	; CTabBarData::`vftable'
	DD	FLAT:??_ECTabBarData@@UAEPAXI@Z
	DD	FLAT:?DataAppStart@CTabBarData@@UAEXXZ
	DD	FLAT:?DataAppExit@CTabBarData@@UAEXXZ
	DD	FLAT:?ITabBar_ChangeTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBar_GetCurPos@CTabBarData@@UAEHXZ
	DD	FLAT:?ITabBar_GetCurItem@CTabBarData@@UAE_NAAUTAB_ITEM@@@Z
	DD	FLAT:?ITabBar_GetTabBarData@CTabBarData@@UAEXAAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@Z
CONST	ENDS
;	COMDAT ??_R4CTabBarData@@6B@
rdata$r	SEGMENT
??_R4CTabBarData@@6B@ DD 00H				; CTabBarData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTabBarData@@@8
	DD	FLAT:??_R3CTabBarData@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTabBarData@@@8
_DATA	SEGMENT
??_R0?AVCTabBarData@@@8 DD FLAT:??_7type_info@@6B@	; CTabBarData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTabBarData@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CTabBarData@@8
rdata$r	SEGMENT
??_R3CTabBarData@@8 DD 00H				; CTabBarData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CTabBarData@@8
rdata$r	ENDS
;	COMDAT ??_R2CTabBarData@@8
rdata$r	SEGMENT
??_R2CTabBarData@@8 DD FLAT:??_R1A@?0A@A@CTabBarData@@8	; CTabBarData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@ITabBarData@@8
	DD	FLAT:??_R1A@?0A@A@IData@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTabBarData@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CTabBarData@@8 DD FLAT:??_R0?AVCTabBarData@@@8 ; CTabBarData::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ITabBarData@@8
rdata$r	SEGMENT
??_R1A@?0A@A@ITabBarData@@8 DD FLAT:??_R0?AVITabBarData@@@8 ; ITabBarData::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVITabBarData@@@8
_DATA	SEGMENT
??_R0?AVITabBarData@@@8 DD FLAT:??_7type_info@@6B@	; ITabBarData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVITabBarData@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@IData@@8
rdata$r	SEGMENT
??_R1A@?0A@A@IData@@8 DD FLAT:??_R0?AVIData@@@8		; IData::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVIData@@@8
_DATA	SEGMENT
??_R0?AVIData@@@8 DD FLAT:??_7type_info@@6B@		; IData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIData@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ??0CTabBarData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CTabBarData@@QAE@XZ PROC NEAR			; CTabBarData::CTabBarData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTabBarData@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00020	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0ITabBarData@@QAE@XZ
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTabBarData@@6B@
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	83 c1 08	 add	 ecx, 8
  00041	e8 00 00 00 00	 call	 ??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >
  00046	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005a	83 c4 10	 add	 esp, 16			; 00000010H
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190451:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ITabBarData@@UAE@XZ
__ehhandler$??0CTabBarData@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190454
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CTabBarData@@QAE@XZ ENDP				; CTabBarData::CTabBarData
PUBLIC	??1CTabBarData@@UAE@XZ				; CTabBarData::~CTabBarData
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GCTabBarData@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTabBarData@@UAEPAXI@Z PROC NEAR			; CTabBarData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1CTabBarData@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0c		 je	 SHORT $L188370
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4
$L188370:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??_GCTabBarData@@UAEPAXI@Z ENDP				; CTabBarData::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_R4ITabBarData@@6B@				; ITabBarData::`RTTI Complete Object Locator'
PUBLIC	??_R3ITabBarData@@8				; ITabBarData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITabBarData@@8				; ITabBarData::`RTTI Base Class Array'
PUBLIC	?DataAppStart@IData@@UAEXXZ			; IData::DataAppStart
PUBLIC	?DataAppExit@IData@@UAEXXZ			; IData::DataAppExit
PUBLIC	??0IData@@QAE@XZ				; IData::IData
PUBLIC	??_7ITabBarData@@6B@				; ITabBarData::`vftable'
PUBLIC	??_GITabBarData@@UAEPAXI@Z			; ITabBarData::`scalar deleting destructor'
EXTRN	__purecall:NEAR
EXTRN	??_EITabBarData@@UAEPAXI@Z:NEAR			; ITabBarData::`vector deleting destructor'
;	COMDAT ??_7ITabBarData@@6B@
CONST	SEGMENT
??_7ITabBarData@@6B@ DD FLAT:??_R4ITabBarData@@6B@	; ITabBarData::`vftable'
	DD	FLAT:??_EITabBarData@@UAEPAXI@Z
	DD	FLAT:?DataAppStart@IData@@UAEXXZ
	DD	FLAT:?DataAppExit@IData@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4ITabBarData@@6B@
rdata$r	SEGMENT
??_R4ITabBarData@@6B@ DD 00H				; ITabBarData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVITabBarData@@@8
	DD	FLAT:??_R3ITabBarData@@8
rdata$r	ENDS
;	COMDAT ??_R3ITabBarData@@8
rdata$r	SEGMENT
??_R3ITabBarData@@8 DD 00H				; ITabBarData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITabBarData@@8
rdata$r	ENDS
;	COMDAT ??_R2ITabBarData@@8
rdata$r	SEGMENT
??_R2ITabBarData@@8 DD FLAT:??_R1A@?0A@A@ITabBarData@@8	; ITabBarData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@IData@@8
; Function compile flags: /Odt /RTCsu
rdata$r	ENDS
;	COMDAT ??0ITabBarData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ITabBarData@@QAE@XZ PROC NEAR			; ITabBarData::ITabBarData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0IData@@QAE@XZ
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ITabBarData@@6B@
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??0ITabBarData@@QAE@XZ ENDP				; ITabBarData::ITabBarData
; Function compile flags: /Odt /RTCsu
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\datainterface\idata.h
_TEXT	ENDS
;	COMDAT ?DataAppStart@IData@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DataAppStart@IData@@UAEXXZ PROC NEAR			; IData::DataAppStart, COMDAT
; _this$ = ecx

; 15   : 	virtual void	DataAppStart(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?DataAppStart@IData@@UAEXXZ ENDP			; IData::DataAppStart
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?DataAppExit@IData@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DataAppExit@IData@@UAEXXZ PROC NEAR			; IData::DataAppExit, COMDAT
; _this$ = ecx

; 18   : 	virtual void	DataAppExit(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?DataAppExit@IData@@UAEXXZ ENDP				; IData::DataAppExit
_TEXT	ENDS
PUBLIC	??1IData@@MAE@XZ				; IData::~IData
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1ITabBarData@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ITabBarData@@UAE@XZ PROC NEAR			; ITabBarData::~ITabBarData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1IData@@MAE@XZ	; IData::~IData
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1ITabBarData@@UAE@XZ ENDP				; ITabBarData::~ITabBarData
_TEXT	ENDS
PUBLIC	??_R4IData@@6B@					; IData::`RTTI Complete Object Locator'
PUBLIC	??_R3IData@@8					; IData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IData@@8					; IData::`RTTI Base Class Array'
PUBLIC	??_7IData@@6B@					; IData::`vftable'
PUBLIC	??_GIData@@MAEPAXI@Z				; IData::`scalar deleting destructor'
EXTRN	??_EIData@@MAEPAXI@Z:NEAR			; IData::`vector deleting destructor'
;	COMDAT ??_7IData@@6B@
CONST	SEGMENT
??_7IData@@6B@ DD FLAT:??_R4IData@@6B@			; IData::`vftable'
	DD	FLAT:??_EIData@@MAEPAXI@Z
	DD	FLAT:?DataAppStart@IData@@UAEXXZ
	DD	FLAT:?DataAppExit@IData@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4IData@@6B@
rdata$r	SEGMENT
??_R4IData@@6B@ DD 00H					; IData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIData@@@8
	DD	FLAT:??_R3IData@@8
rdata$r	ENDS
;	COMDAT ??_R3IData@@8
rdata$r	SEGMENT
??_R3IData@@8 DD 00H					; IData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IData@@8
rdata$r	ENDS
;	COMDAT ??_R2IData@@8
rdata$r	SEGMENT
??_R2IData@@8 DD FLAT:??_R1A@?0A@A@IData@@8		; IData::`RTTI Base Class Array'
; Function compile flags: /Odt /RTCsu
rdata$r	ENDS
;	COMDAT ??1IData@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1IData@@MAE@XZ PROC NEAR				; IData::~IData, COMDAT
; _this$ = ecx

; 10   : 	virtual ~IData(){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IData@@6B@
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1IData@@MAE@XZ ENDP					; IData::~IData
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_GIData@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIData@@MAEPAXI@Z PROC NEAR				; IData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1IData@@MAE@XZ	; IData::~IData
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0c		 je	 SHORT $L187041
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4
$L187041:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??_GIData@@MAEPAXI@Z ENDP				; IData::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190473 DD	0ffffffffH
	DD	FLAT:$L190468
$T190471 DD	019930520H
	DD	01H
	DD	FLAT:$T190473
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1CTabBarData@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CTabBarData@@UAE@XZ PROC NEAR			; CTabBarData::~CTabBarData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CTabBarData@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00020	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	83 c1 08	 add	 ecx, 8
  00030	e8 00 00 00 00	 call	 ??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >
  00035	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ??1ITabBarData@@UAE@XZ
  00044	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190468:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ITabBarData@@UAE@XZ
__ehhandler$??1CTabBarData@@UAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190471
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CTabBarData@@UAE@XZ ENDP				; CTabBarData::~CTabBarData
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GITabBarData@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GITabBarData@@UAEPAXI@Z PROC NEAR			; ITabBarData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1ITabBarData@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0c		 je	 SHORT $L188380
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4
$L188380:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??_GITabBarData@@UAEPAXI@Z ENDP				; ITabBarData::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0IData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IData@@QAE@XZ PROC NEAR				; IData::IData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7IData@@6B@
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0IData@@QAE@XZ ENDP					; IData::IData
_TEXT	ENDS
PUBLIC	?DelInstance@CTabBarData@@SAXXZ			; CTabBarData::DelInstance
; Function compile flags: /Odt /RTCsu
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\module\tabman\tabbardata.cpp
_TEXT	SEGMENT
tv71 = -12						; size = 4
$T190480 = -8						; size = 4
$T190479 = -4						; size = 4
?DelInstance@CTabBarData@@SAXXZ PROC NEAR		; CTabBarData::DelInstance

; 16   : {

  000a0	55		 push	 ebp
  000a1	8b ec		 mov	 ebp, esp
  000a3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000a6	56		 push	 esi
  000a7	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  000ae	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  000b5	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 17   : 	if(m_pTabBarData != NULL)

  000bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A, 0 ; CTabBarData::m_pTabBarData
  000c3	74 35		 je	 SHORT $L188385

; 18   : 		delete m_pTabBarData;

  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A ; CTabBarData::m_pTabBarData
  000ca	89 45 f8	 mov	 DWORD PTR $T190480[ebp], eax
  000cd	8b 4d f8	 mov	 ecx, DWORD PTR $T190480[ebp]
  000d0	89 4d fc	 mov	 DWORD PTR $T190479[ebp], ecx
  000d3	83 7d fc 00	 cmp	 DWORD PTR $T190479[ebp], 0
  000d7	74 1a		 je	 SHORT $L190481
  000d9	8b f4		 mov	 esi, esp
  000db	6a 01		 push	 1
  000dd	8b 55 fc	 mov	 edx, DWORD PTR $T190479[ebp]
  000e0	8b 02		 mov	 eax, DWORD PTR [edx]
  000e2	8b 4d fc	 mov	 ecx, DWORD PTR $T190479[ebp]
  000e5	ff 10		 call	 DWORD PTR [eax]
  000e7	3b f4		 cmp	 esi, esp
  000e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ee	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  000f1	eb 07		 jmp	 SHORT $L188385
$L190481:
  000f3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L188385:

; 19   : 	m_pTabBarData = NULL;

  000fa	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_pTabBarData@CTabBarData@@2PAV1@A, 0 ; CTabBarData::m_pTabBarData

; 20   : }

  00104	5e		 pop	 esi
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
  00108	3b ec		 cmp	 ebp, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
?DelInstance@CTabBarData@@SAXXZ ENDP			; CTabBarData::DelInstance
; Function compile flags: /Odt /RTCsu
_this$ = -4						; size = 4
?DataAppStart@CTabBarData@@UAEXXZ PROC NEAR		; CTabBarData::DataAppStart
; _this$ = ecx

; 23   : {

  00120	55		 push	 ebp
  00121	8b ec		 mov	 ebp, esp
  00123	51		 push	 ecx
  00124	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0012b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 	//tab
; 25   : }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
?DataAppStart@CTabBarData@@UAEXXZ ENDP			; CTabBarData::DataAppStart
; Function compile flags: /Odt /RTCsu
_this$ = -4						; size = 4
?DataAppExit@CTabBarData@@UAEXXZ PROC NEAR		; CTabBarData::DataAppExit
; _this$ = ecx

; 28   : {

  00140	55		 push	 ebp
  00141	8b ec		 mov	 ebp, esp
  00143	51		 push	 ecx
  00144	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0014b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	//tab
; 30   : }

  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
?DataAppExit@CTabBarData@@UAEXXZ ENDP			; CTabBarData::DataAppExit
_TEXT	ENDS
PUBLIC	??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
PUBLIC	?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
PUBLIC	??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
PUBLIC	??_R0?AVIMessageObserver@@@8			; IMessageObserver `RTTI Type Descriptor'
PUBLIC	??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
PUBLIC	??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
PUBLIC	??_R0?AVITabBarObserver@@@8			; ITabBarObserver `RTTI Type Descriptor'
PUBLIC	?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ; CTabBarData::NotifyCreateTab
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	?AfxGetMessageManager@@YAPAVIMessageManager@@XZ:NEAR ; AfxGetMessageManager
EXTRN	___RTDynamicCast:NEAR
xdata$x	SEGMENT
$T190497 DD	0ffffffffH
	DD	FLAT:$L190488
$T190490 DD	019930520H
	DD	01H
	DD	FLAT:$T190497
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0?AVITabBarObserver@@@8
_DATA	SEGMENT
??_R0?AVITabBarObserver@@@8 DD FLAT:??_7type_info@@6B@	; ITabBarObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVITabBarObserver@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVIMessageObserver@@@8
_DATA	SEGMENT
??_R0?AVIMessageObserver@@@8 DD FLAT:??_7type_info@@6B@	; IMessageObserver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIMessageObserver@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVIMessageObserver@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
_TEXT	SEGMENT
tv69 = -64						; size = 4
$T190487 = -60						; size = 4
$T190486 = -56						; size = 4
_pOb$188899 = -52					; size = 4
_itOb$188892 = -44					; size = 4
_listOb$ = -32						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_item$ = 8						; size = 4
?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::NotifyCreateTab
; _this$ = ecx

; 33   : {

  00160	55		 push	 ebp
  00161	8b ec		 mov	 ebp, esp
  00163	6a ff		 push	 -1
  00165	68 00 00 00 00	 push	 __ehhandler$?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z
  0016a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00170	50		 push	 eax
  00171	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00178	83 ec 34	 sub	 esp, 52			; 00000034H
  0017b	56		 push	 esi
  0017c	57		 push	 edi
  0017d	51		 push	 ecx
  0017e	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  00181	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00186	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0018b	f3 ab		 rep stosd
  0018d	59		 pop	 ecx
  0018e	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 34   : 	list<IMessageObserver*> listOb;

  00191	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00194	e8 00 00 00 00	 call	 ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
  00199	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 35   : 	AfxGetMessageManager()->QueryObservers( ID_MESSAGE_TABBAR,listOb);

  001a0	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  001a5	89 45 c0	 mov	 DWORD PTR tv69[ebp], eax
  001a8	8b f4		 mov	 esi, esp
  001aa	8d 45 e0	 lea	 eax, DWORD PTR _listOb$[ebp]
  001ad	50		 push	 eax
  001ae	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  001b3	8b 4d c0	 mov	 ecx, DWORD PTR tv69[ebp]
  001b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b8	8b 4d c0	 mov	 ecx, DWORD PTR tv69[ebp]
  001bb	ff 52 0c	 call	 DWORD PTR [edx+12]
  001be	3b f4		 cmp	 esi, esp
  001c0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 36   : 
; 37   : 	for( list<IMessageObserver*>::iterator itOb = listOb.begin();itOb != listOb.end();itOb++ )

  001c5	8d 45 d4	 lea	 eax, DWORD PTR _itOb$188892[ebp]
  001c8	50		 push	 eax
  001c9	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  001cc	e8 00 00 00 00	 call	 ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
  001d1	eb 0e		 jmp	 SHORT $L188896
$L188897:
  001d3	6a 00		 push	 0
  001d5	8d 4d c8	 lea	 ecx, DWORD PTR $T190486[ebp]
  001d8	51		 push	 ecx
  001d9	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188892[ebp]
  001dc	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
$L188896:
  001e1	8d 55 c4	 lea	 edx, DWORD PTR $T190487[ebp]
  001e4	52		 push	 edx
  001e5	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  001e8	e8 00 00 00 00	 call	 ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
  001ed	50		 push	 eax
  001ee	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188892[ebp]
  001f1	e8 00 00 00 00	 call	 ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
  001f6	0f b6 c0	 movzx	 eax, al
  001f9	85 c0		 test	 eax, eax
  001fb	74 3e		 je	 SHORT $L188898

; 38   : 	{
; 39   : 		ITabBarObserver* pOb = dynamic_cast<ITabBarObserver*>(*itOb);

  001fd	6a 00		 push	 0
  001ff	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVITabBarObserver@@@8
  00204	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIMessageObserver@@@8
  00209	6a 00		 push	 0
  0020b	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188892[ebp]
  0020e	e8 00 00 00 00	 call	 ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
  00213	8b 08		 mov	 ecx, DWORD PTR [eax]
  00215	51		 push	 ecx
  00216	e8 00 00 00 00	 call	 ___RTDynamicCast
  0021b	83 c4 14	 add	 esp, 20			; 00000014H
  0021e	89 45 cc	 mov	 DWORD PTR _pOb$188899[ebp], eax

; 40   : 		pOb->ITabBarOb_CreateNewTab(item);

  00221	8b f4		 mov	 esi, esp
  00223	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00226	52		 push	 edx
  00227	8b 45 cc	 mov	 eax, DWORD PTR _pOb$188899[ebp]
  0022a	8b 10		 mov	 edx, DWORD PTR [eax]
  0022c	8b 4d cc	 mov	 ecx, DWORD PTR _pOb$188899[ebp]
  0022f	ff 52 04	 call	 DWORD PTR [edx+4]
  00232	3b f4		 cmp	 esi, esp
  00234	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 41   : 	}

  00239	eb 98		 jmp	 SHORT $L188897
$L188898:

; 42   : }

  0023b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00242	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00245	e8 00 00 00 00	 call	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
  0024a	52		 push	 edx
  0024b	8b cd		 mov	 ecx, ebp
  0024d	50		 push	 eax
  0024e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190495
  00254	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00259	58		 pop	 eax
  0025a	5a		 pop	 edx
  0025b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0025e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00265	5f		 pop	 edi
  00266	5e		 pop	 esi
  00267	83 c4 40	 add	 esp, 64			; 00000040H
  0026a	3b ec		 cmp	 ebp, esp
  0026c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00271	8b e5		 mov	 esp, ebp
  00273	5d		 pop	 ebp
  00274	c2 04 00	 ret	 4
$L190495:
  00277	02 00 00 00	 DD	 2
  0027b	00 00 00 00	 DD	 $L190494
$L190494:
  0027f	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00283	0c 00 00 00	 DD	 12			; 0000000cH
  00287	00 00 00 00	 DD	 $L190491
  0028b	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0028f	04 00 00 00	 DD	 4
  00293	00 00 00 00	 DD	 $L190492
$L190492:
  00297	69		 DB	 105			; 00000069H
  00298	74		 DB	 116			; 00000074H
  00299	4f		 DB	 79			; 0000004fH
  0029a	62		 DB	 98			; 00000062H
  0029b	00		 DB	 0
$L190491:
  0029c	6c		 DB	 108			; 0000006cH
  0029d	69		 DB	 105			; 00000069H
  0029e	73		 DB	 115			; 00000073H
  0029f	74		 DB	 116			; 00000074H
  002a0	4f		 DB	 79			; 0000004fH
  002a1	62		 DB	 98			; 00000062H
  002a2	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L190488:
  00015	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00018	e9 00 00 00 00	 jmp	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
__ehhandler$?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z:
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190490
  00022	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ENDP	; CTabBarData::NotifyCreateTab
PUBLIC	?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ; CTabBarData::NotifyOpenExistTab
xdata$x	SEGMENT
$T190509 DD	0ffffffffH
	DD	FLAT:$L190501
$T190503 DD	019930520H
	DD	01H
	DD	FLAT:$T190509
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv69 = -64						; size = 4
$T190500 = -60						; size = 4
$T190499 = -56						; size = 4
_pOb$188916 = -52					; size = 4
_itOb$188909 = -44					; size = 4
_listOb$ = -32						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_item$ = 8						; size = 4
?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::NotifyOpenExistTab
; _this$ = ecx

; 45   : {

  002b0	55		 push	 ebp
  002b1	8b ec		 mov	 ebp, esp
  002b3	6a ff		 push	 -1
  002b5	68 00 00 00 00	 push	 __ehhandler$?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z
  002ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  002c0	50		 push	 eax
  002c1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  002c8	83 ec 34	 sub	 esp, 52			; 00000034H
  002cb	56		 push	 esi
  002cc	57		 push	 edi
  002cd	51		 push	 ecx
  002ce	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  002d1	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  002d6	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  002db	f3 ab		 rep stosd
  002dd	59		 pop	 ecx
  002de	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 46   : 	list<IMessageObserver*> listOb;

  002e1	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  002e4	e8 00 00 00 00	 call	 ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
  002e9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 47   : 	AfxGetMessageManager()->QueryObservers( ID_MESSAGE_TABBAR,listOb);

  002f0	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  002f5	89 45 c0	 mov	 DWORD PTR tv69[ebp], eax
  002f8	8b f4		 mov	 esi, esp
  002fa	8d 45 e0	 lea	 eax, DWORD PTR _listOb$[ebp]
  002fd	50		 push	 eax
  002fe	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  00303	8b 4d c0	 mov	 ecx, DWORD PTR tv69[ebp]
  00306	8b 11		 mov	 edx, DWORD PTR [ecx]
  00308	8b 4d c0	 mov	 ecx, DWORD PTR tv69[ebp]
  0030b	ff 52 0c	 call	 DWORD PTR [edx+12]
  0030e	3b f4		 cmp	 esi, esp
  00310	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 48   : 
; 49   : 	for( list<IMessageObserver*>::iterator itOb = listOb.begin();itOb != listOb.end();itOb++ )

  00315	8d 45 d4	 lea	 eax, DWORD PTR _itOb$188909[ebp]
  00318	50		 push	 eax
  00319	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0031c	e8 00 00 00 00	 call	 ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
  00321	eb 0e		 jmp	 SHORT $L188913
$L188914:
  00323	6a 00		 push	 0
  00325	8d 4d c8	 lea	 ecx, DWORD PTR $T190499[ebp]
  00328	51		 push	 ecx
  00329	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188909[ebp]
  0032c	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
$L188913:
  00331	8d 55 c4	 lea	 edx, DWORD PTR $T190500[ebp]
  00334	52		 push	 edx
  00335	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00338	e8 00 00 00 00	 call	 ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
  0033d	50		 push	 eax
  0033e	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188909[ebp]
  00341	e8 00 00 00 00	 call	 ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
  00346	0f b6 c0	 movzx	 eax, al
  00349	85 c0		 test	 eax, eax
  0034b	74 3e		 je	 SHORT $L188915

; 50   : 	{
; 51   : 		ITabBarObserver* pOb = dynamic_cast<ITabBarObserver*>(*itOb);

  0034d	6a 00		 push	 0
  0034f	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVITabBarObserver@@@8
  00354	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIMessageObserver@@@8
  00359	6a 00		 push	 0
  0035b	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188909[ebp]
  0035e	e8 00 00 00 00	 call	 ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
  00363	8b 08		 mov	 ecx, DWORD PTR [eax]
  00365	51		 push	 ecx
  00366	e8 00 00 00 00	 call	 ___RTDynamicCast
  0036b	83 c4 14	 add	 esp, 20			; 00000014H
  0036e	89 45 cc	 mov	 DWORD PTR _pOb$188916[ebp], eax

; 52   : 		pOb->ITabBarOb_OpenExistTab(item);

  00371	8b f4		 mov	 esi, esp
  00373	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00376	52		 push	 edx
  00377	8b 45 cc	 mov	 eax, DWORD PTR _pOb$188916[ebp]
  0037a	8b 10		 mov	 edx, DWORD PTR [eax]
  0037c	8b 4d cc	 mov	 ecx, DWORD PTR _pOb$188916[ebp]
  0037f	ff 52 08	 call	 DWORD PTR [edx+8]
  00382	3b f4		 cmp	 esi, esp
  00384	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 53   : 	}

  00389	eb 98		 jmp	 SHORT $L188914
$L188915:

; 54   : }

  0038b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00392	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00395	e8 00 00 00 00	 call	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
  0039a	52		 push	 edx
  0039b	8b cd		 mov	 ecx, ebp
  0039d	50		 push	 eax
  0039e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190508
  003a4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003a9	58		 pop	 eax
  003aa	5a		 pop	 edx
  003ab	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003ae	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  003b5	5f		 pop	 edi
  003b6	5e		 pop	 esi
  003b7	83 c4 40	 add	 esp, 64			; 00000040H
  003ba	3b ec		 cmp	 ebp, esp
  003bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c1	8b e5		 mov	 esp, ebp
  003c3	5d		 pop	 ebp
  003c4	c2 04 00	 ret	 4
$L190508:
  003c7	02 00 00 00	 DD	 2
  003cb	00 00 00 00	 DD	 $L190507
$L190507:
  003cf	e0 ff ff ff	 DD	 -32			; ffffffe0H
  003d3	0c 00 00 00	 DD	 12			; 0000000cH
  003d7	00 00 00 00	 DD	 $L190504
  003db	d4 ff ff ff	 DD	 -44			; ffffffd4H
  003df	04 00 00 00	 DD	 4
  003e3	00 00 00 00	 DD	 $L190505
$L190505:
  003e7	69		 DB	 105			; 00000069H
  003e8	74		 DB	 116			; 00000074H
  003e9	4f		 DB	 79			; 0000004fH
  003ea	62		 DB	 98			; 00000062H
  003eb	00		 DB	 0
$L190504:
  003ec	6c		 DB	 108			; 0000006cH
  003ed	69		 DB	 105			; 00000069H
  003ee	73		 DB	 115			; 00000073H
  003ef	74		 DB	 116			; 00000074H
  003f0	4f		 DB	 79			; 0000004fH
  003f1	62		 DB	 98			; 00000062H
  003f2	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L190501:
  00027	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
__ehhandler$?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z:
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190503
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ENDP ; CTabBarData::NotifyOpenExistTab
PUBLIC	?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z	; CTabBarData::NotifyDelTab
xdata$x	SEGMENT
$T190521 DD	0ffffffffH
	DD	FLAT:$L190513
$T190515 DD	019930520H
	DD	01H
	DD	FLAT:$T190521
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv69 = -64						; size = 4
$T190512 = -60						; size = 4
$T190511 = -56						; size = 4
_pOb$188932 = -52					; size = 4
_itOb$188925 = -44					; size = 4
_listOb$ = -32						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_item$ = 8						; size = 4
?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::NotifyDelTab
; _this$ = ecx

; 57   : {

  00400	55		 push	 ebp
  00401	8b ec		 mov	 ebp, esp
  00403	6a ff		 push	 -1
  00405	68 00 00 00 00	 push	 __ehhandler$?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z
  0040a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00410	50		 push	 eax
  00411	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00418	83 ec 34	 sub	 esp, 52			; 00000034H
  0041b	56		 push	 esi
  0041c	57		 push	 edi
  0041d	51		 push	 ecx
  0041e	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  00421	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00426	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0042b	f3 ab		 rep stosd
  0042d	59		 pop	 ecx
  0042e	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 	list<IMessageObserver*> listOb;

  00431	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00434	e8 00 00 00 00	 call	 ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
  00439	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 59   : 	AfxGetMessageManager()->QueryObservers( ID_MESSAGE_TABBAR,listOb);

  00440	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  00445	89 45 c0	 mov	 DWORD PTR tv69[ebp], eax
  00448	8b f4		 mov	 esi, esp
  0044a	8d 45 e0	 lea	 eax, DWORD PTR _listOb$[ebp]
  0044d	50		 push	 eax
  0044e	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  00453	8b 4d c0	 mov	 ecx, DWORD PTR tv69[ebp]
  00456	8b 11		 mov	 edx, DWORD PTR [ecx]
  00458	8b 4d c0	 mov	 ecx, DWORD PTR tv69[ebp]
  0045b	ff 52 0c	 call	 DWORD PTR [edx+12]
  0045e	3b f4		 cmp	 esi, esp
  00460	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 60   : 
; 61   : 	for( list<IMessageObserver*>::iterator itOb = listOb.begin();itOb != listOb.end();itOb++ )

  00465	8d 45 d4	 lea	 eax, DWORD PTR _itOb$188925[ebp]
  00468	50		 push	 eax
  00469	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0046c	e8 00 00 00 00	 call	 ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
  00471	eb 0e		 jmp	 SHORT $L188929
$L188930:
  00473	6a 00		 push	 0
  00475	8d 4d c8	 lea	 ecx, DWORD PTR $T190511[ebp]
  00478	51		 push	 ecx
  00479	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188925[ebp]
  0047c	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
$L188929:
  00481	8d 55 c4	 lea	 edx, DWORD PTR $T190512[ebp]
  00484	52		 push	 edx
  00485	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00488	e8 00 00 00 00	 call	 ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
  0048d	50		 push	 eax
  0048e	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188925[ebp]
  00491	e8 00 00 00 00	 call	 ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
  00496	0f b6 c0	 movzx	 eax, al
  00499	85 c0		 test	 eax, eax
  0049b	74 3e		 je	 SHORT $L188931

; 62   : 	{
; 63   : 		ITabBarObserver* pOb = dynamic_cast<ITabBarObserver*>(*itOb);

  0049d	6a 00		 push	 0
  0049f	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVITabBarObserver@@@8
  004a4	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIMessageObserver@@@8
  004a9	6a 00		 push	 0
  004ab	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188925[ebp]
  004ae	e8 00 00 00 00	 call	 ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
  004b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  004b5	51		 push	 ecx
  004b6	e8 00 00 00 00	 call	 ___RTDynamicCast
  004bb	83 c4 14	 add	 esp, 20			; 00000014H
  004be	89 45 cc	 mov	 DWORD PTR _pOb$188932[ebp], eax

; 64   : 		pOb->ITabBarOb_DelTab(item);

  004c1	8b f4		 mov	 esi, esp
  004c3	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  004c6	52		 push	 edx
  004c7	8b 45 cc	 mov	 eax, DWORD PTR _pOb$188932[ebp]
  004ca	8b 10		 mov	 edx, DWORD PTR [eax]
  004cc	8b 4d cc	 mov	 ecx, DWORD PTR _pOb$188932[ebp]
  004cf	ff 52 0c	 call	 DWORD PTR [edx+12]
  004d2	3b f4		 cmp	 esi, esp
  004d4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 65   : 	}

  004d9	eb 98		 jmp	 SHORT $L188930
$L188931:

; 66   : }

  004db	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004e2	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  004e5	e8 00 00 00 00	 call	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
  004ea	52		 push	 edx
  004eb	8b cd		 mov	 ecx, ebp
  004ed	50		 push	 eax
  004ee	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190520
  004f4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004f9	58		 pop	 eax
  004fa	5a		 pop	 edx
  004fb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004fe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00505	5f		 pop	 edi
  00506	5e		 pop	 esi
  00507	83 c4 40	 add	 esp, 64			; 00000040H
  0050a	3b ec		 cmp	 ebp, esp
  0050c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00511	8b e5		 mov	 esp, ebp
  00513	5d		 pop	 ebp
  00514	c2 04 00	 ret	 4
$L190520:
  00517	02 00 00 00	 DD	 2
  0051b	00 00 00 00	 DD	 $L190519
$L190519:
  0051f	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00523	0c 00 00 00	 DD	 12			; 0000000cH
  00527	00 00 00 00	 DD	 $L190516
  0052b	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0052f	04 00 00 00	 DD	 4
  00533	00 00 00 00	 DD	 $L190517
$L190517:
  00537	69		 DB	 105			; 00000069H
  00538	74		 DB	 116			; 00000074H
  00539	4f		 DB	 79			; 0000004fH
  0053a	62		 DB	 98			; 00000062H
  0053b	00		 DB	 0
$L190516:
  0053c	6c		 DB	 108			; 0000006cH
  0053d	69		 DB	 105			; 00000069H
  0053e	73		 DB	 115			; 00000073H
  0053f	74		 DB	 116			; 00000074H
  00540	4f		 DB	 79			; 0000004fH
  00541	62		 DB	 98			; 00000062H
  00542	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L190513:
  00039	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0003c	e9 00 00 00 00	 jmp	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
__ehhandler$?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z:
  00041	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190515
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ENDP	; CTabBarData::NotifyDelTab
PUBLIC	?NotifyOpenTabError@CTabBarData@@AAEXH@Z	; CTabBarData::NotifyOpenTabError
xdata$x	SEGMENT
$T190533 DD	0ffffffffH
	DD	FLAT:$L190525
$T190527 DD	019930520H
	DD	01H
	DD	FLAT:$T190533
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv69 = -64						; size = 4
$T190524 = -60						; size = 4
$T190523 = -56						; size = 4
_pOb$188948 = -52					; size = 4
_itOb$188941 = -44					; size = 4
_listOb$ = -32						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_iErrorCode$ = 8					; size = 4
?NotifyOpenTabError@CTabBarData@@AAEXH@Z PROC NEAR	; CTabBarData::NotifyOpenTabError
; _this$ = ecx

; 69   : {

  00550	55		 push	 ebp
  00551	8b ec		 mov	 ebp, esp
  00553	6a ff		 push	 -1
  00555	68 00 00 00 00	 push	 __ehhandler$?NotifyOpenTabError@CTabBarData@@AAEXH@Z
  0055a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00560	50		 push	 eax
  00561	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00568	83 ec 34	 sub	 esp, 52			; 00000034H
  0056b	56		 push	 esi
  0056c	57		 push	 edi
  0056d	51		 push	 ecx
  0056e	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  00571	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00576	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0057b	f3 ab		 rep stosd
  0057d	59		 pop	 ecx
  0057e	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 70   : 	list<IMessageObserver*> listOb;

  00581	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00584	e8 00 00 00 00	 call	 ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
  00589	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 71   : 	AfxGetMessageManager()->QueryObservers( ID_MESSAGE_TABBAR,listOb);

  00590	e8 00 00 00 00	 call	 ?AfxGetMessageManager@@YAPAVIMessageManager@@XZ ; AfxGetMessageManager
  00595	89 45 c0	 mov	 DWORD PTR tv69[ebp], eax
  00598	8b f4		 mov	 esi, esp
  0059a	8d 45 e0	 lea	 eax, DWORD PTR _listOb$[ebp]
  0059d	50		 push	 eax
  0059e	68 00 00 00 00	 push	 OFFSET FLAT:_ID_MESSAGE_TABBAR
  005a3	8b 4d c0	 mov	 ecx, DWORD PTR tv69[ebp]
  005a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  005a8	8b 4d c0	 mov	 ecx, DWORD PTR tv69[ebp]
  005ab	ff 52 0c	 call	 DWORD PTR [edx+12]
  005ae	3b f4		 cmp	 esi, esp
  005b0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 72   : 
; 73   : 	for( list<IMessageObserver*>::iterator itOb = listOb.begin();itOb != listOb.end();itOb++ )

  005b5	8d 45 d4	 lea	 eax, DWORD PTR _itOb$188941[ebp]
  005b8	50		 push	 eax
  005b9	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  005bc	e8 00 00 00 00	 call	 ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
  005c1	eb 0e		 jmp	 SHORT $L188945
$L188946:
  005c3	6a 00		 push	 0
  005c5	8d 4d c8	 lea	 ecx, DWORD PTR $T190523[ebp]
  005c8	51		 push	 ecx
  005c9	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188941[ebp]
  005cc	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
$L188945:
  005d1	8d 55 c4	 lea	 edx, DWORD PTR $T190524[ebp]
  005d4	52		 push	 edx
  005d5	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  005d8	e8 00 00 00 00	 call	 ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
  005dd	50		 push	 eax
  005de	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188941[ebp]
  005e1	e8 00 00 00 00	 call	 ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
  005e6	0f b6 c0	 movzx	 eax, al
  005e9	85 c0		 test	 eax, eax
  005eb	74 3e		 je	 SHORT $L188947

; 74   : 	{
; 75   : 		ITabBarObserver* pOb = dynamic_cast<ITabBarObserver*>(*itOb);

  005ed	6a 00		 push	 0
  005ef	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVITabBarObserver@@@8
  005f4	68 00 00 00 00	 push	 OFFSET FLAT:??_R0?AVIMessageObserver@@@8
  005f9	6a 00		 push	 0
  005fb	8d 4d d4	 lea	 ecx, DWORD PTR _itOb$188941[ebp]
  005fe	e8 00 00 00 00	 call	 ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
  00603	8b 08		 mov	 ecx, DWORD PTR [eax]
  00605	51		 push	 ecx
  00606	e8 00 00 00 00	 call	 ___RTDynamicCast
  0060b	83 c4 14	 add	 esp, 20			; 00000014H
  0060e	89 45 cc	 mov	 DWORD PTR _pOb$188948[ebp], eax

; 76   : 		pOb->ITabBarOb_OpenTabError(iErrorCode);

  00611	8b f4		 mov	 esi, esp
  00613	8b 55 08	 mov	 edx, DWORD PTR _iErrorCode$[ebp]
  00616	52		 push	 edx
  00617	8b 45 cc	 mov	 eax, DWORD PTR _pOb$188948[ebp]
  0061a	8b 10		 mov	 edx, DWORD PTR [eax]
  0061c	8b 4d cc	 mov	 ecx, DWORD PTR _pOb$188948[ebp]
  0061f	ff 52 10	 call	 DWORD PTR [edx+16]
  00622	3b f4		 cmp	 esi, esp
  00624	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 77   : 	}

  00629	eb 98		 jmp	 SHORT $L188946
$L188947:

; 78   : }

  0062b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00632	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  00635	e8 00 00 00 00	 call	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
  0063a	52		 push	 edx
  0063b	8b cd		 mov	 ecx, ebp
  0063d	50		 push	 eax
  0063e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190532
  00644	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00649	58		 pop	 eax
  0064a	5a		 pop	 edx
  0064b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0064e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00655	5f		 pop	 edi
  00656	5e		 pop	 esi
  00657	83 c4 40	 add	 esp, 64			; 00000040H
  0065a	3b ec		 cmp	 ebp, esp
  0065c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00661	8b e5		 mov	 esp, ebp
  00663	5d		 pop	 ebp
  00664	c2 04 00	 ret	 4
$L190532:
  00667	02 00 00 00	 DD	 2
  0066b	00 00 00 00	 DD	 $L190531
$L190531:
  0066f	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00673	0c 00 00 00	 DD	 12			; 0000000cH
  00677	00 00 00 00	 DD	 $L190528
  0067b	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0067f	04 00 00 00	 DD	 4
  00683	00 00 00 00	 DD	 $L190529
$L190529:
  00687	69		 DB	 105			; 00000069H
  00688	74		 DB	 116			; 00000074H
  00689	4f		 DB	 79			; 0000004fH
  0068a	62		 DB	 98			; 00000062H
  0068b	00		 DB	 0
$L190528:
  0068c	6c		 DB	 108			; 0000006cH
  0068d	69		 DB	 105			; 00000069H
  0068e	73		 DB	 115			; 00000073H
  0068f	74		 DB	 116			; 00000074H
  00690	4f		 DB	 79			; 0000004fH
  00691	62		 DB	 98			; 00000062H
  00692	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L190525:
  0004b	8d 4d e0	 lea	 ecx, DWORD PTR _listOb$[ebp]
  0004e	e9 00 00 00 00	 jmp	 ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
__ehhandler$?NotifyOpenTabError@CTabBarData@@AAEXH@Z:
  00053	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190527
  00058	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NotifyOpenTabError@CTabBarData@@AAEXH@Z ENDP		; CTabBarData::NotifyOpenTabError
PUBLIC	??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
PUBLIC	??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
PUBLIC	??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
PUBLIC	??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator-
PUBLIC	?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
PUBLIC	?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
PUBLIC	?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
PUBLIC	?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::push_back
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z:NEAR
EXTRN	?AfxGetDataManager2@@YAPAVIDataManager@@XZ:NEAR	; AfxGetDataManager2
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv86 = -48						; size = 4
tv80 = -44						; size = 4
tv72 = -40						; size = 4
tv66 = -36						; size = 4
$T190538 = -32						; size = 4
$T190537 = -28						; size = 4
$T190536 = -24						; size = 4
$T190535 = -20						; size = 4
_it$ = -12						; size = 4
_this$ = -4						; size = 4
_item$ = 8						; size = 4
?ITabBar_ChangeTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::ITabBar_ChangeTab
; _this$ = ecx

; 84   : {

  006a0	55		 push	 ebp
  006a1	8b ec		 mov	 ebp, esp
  006a3	83 ec 30	 sub	 esp, 48			; 00000030H
  006a6	56		 push	 esi
  006a7	57		 push	 edi
  006a8	51		 push	 ecx
  006a9	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  006ac	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  006b1	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  006b6	f3 ab		 rep stosd
  006b8	59		 pop	 ecx
  006b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 85   : 	//
; 86   : 	if( GLOBAL_PANELCHANGEDATA->IPanelChange_IsFullScreen() )

  006bc	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  006c1	89 45 dc	 mov	 DWORD PTR tv66[ebp], eax
  006c4	8b f4		 mov	 esi, esp
  006c6	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_PANELCHANGE
  006cb	8b 45 dc	 mov	 eax, DWORD PTR tv66[ebp]
  006ce	8b 10		 mov	 edx, DWORD PTR [eax]
  006d0	8b 4d dc	 mov	 ecx, DWORD PTR tv66[ebp]
  006d3	ff 52 0c	 call	 DWORD PTR [edx+12]
  006d6	3b f4		 cmp	 esi, esp
  006d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006dd	89 45 d8	 mov	 DWORD PTR tv72[ebp], eax
  006e0	8b 45 d8	 mov	 eax, DWORD PTR tv72[ebp]
  006e3	8b 10		 mov	 edx, DWORD PTR [eax]
  006e5	8b f4		 mov	 esi, esp
  006e7	8b 4d d8	 mov	 ecx, DWORD PTR tv72[ebp]
  006ea	ff 52 14	 call	 DWORD PTR [edx+20]
  006ed	3b f4		 cmp	 esi, esp
  006ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006f4	0f b6 c0	 movzx	 eax, al
  006f7	85 c0		 test	 eax, eax
  006f9	74 38		 je	 SHORT $L188955

; 87   : 	{
; 88   : 		GLOBAL_PANELCHANGEDATA->IPanelChange_ExitFullScreen();

  006fb	e8 00 00 00 00	 call	 ?AfxGetDataManager2@@YAPAVIDataManager@@XZ ; AfxGetDataManager2
  00700	89 45 d4	 mov	 DWORD PTR tv80[ebp], eax
  00703	8b f4		 mov	 esi, esp
  00705	68 00 00 00 00	 push	 OFFSET FLAT:_ID_DATA_PANELCHANGE
  0070a	8b 4d d4	 mov	 ecx, DWORD PTR tv80[ebp]
  0070d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0070f	8b 4d d4	 mov	 ecx, DWORD PTR tv80[ebp]
  00712	ff 52 0c	 call	 DWORD PTR [edx+12]
  00715	3b f4		 cmp	 esi, esp
  00717	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0071c	89 45 d0	 mov	 DWORD PTR tv86[ebp], eax
  0071f	8b 45 d0	 mov	 eax, DWORD PTR tv86[ebp]
  00722	8b 10		 mov	 edx, DWORD PTR [eax]
  00724	8b f4		 mov	 esi, esp
  00726	8b 4d d0	 mov	 ecx, DWORD PTR tv86[ebp]
  00729	ff 52 10	 call	 DWORD PTR [edx+16]
  0072c	3b f4		 cmp	 esi, esp
  0072e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L188955:

; 89   : 	}
; 90   : 	//////////////////////
; 91   : 	vector<TAB_ITEM>::iterator it = m_vecItem.begin();

  00733	8d 45 f4	 lea	 eax, DWORD PTR _it$[ebp]
  00736	50		 push	 eax
  00737	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0073a	83 c1 08	 add	 ecx, 8
  0073d	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin

; 92   : 	for( ; it != m_vecItem.end(); it++ )

  00742	eb 0e		 jmp	 SHORT $L189078
$L189079:
  00744	6a 00		 push	 0
  00746	8d 4d ec	 lea	 ecx, DWORD PTR $T190535[ebp]
  00749	51		 push	 ecx
  0074a	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  0074d	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
$L189078:
  00752	8d 55 e8	 lea	 edx, DWORD PTR $T190536[ebp]
  00755	52		 push	 edx
  00756	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00759	83 c1 08	 add	 ecx, 8
  0075c	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  00761	50		 push	 eax
  00762	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  00765	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
  0076a	0f b6 c0	 movzx	 eax, al
  0076d	85 c0		 test	 eax, eax
  0076f	74 3d		 je	 SHORT $L189080

; 93   : 	{
; 94   : 		if( it->eumType == item.eumType
; 95   : 			&& it->strName == item.strName )

  00771	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  00774	e8 00 00 00 00	 call	 ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
  00779	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0077c	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0077f	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00782	75 28		 jne	 SHORT $L189081
  00784	8b f4		 mov	 esi, esp
  00786	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00789	50		 push	 eax
  0078a	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  0078d	e8 00 00 00 00	 call	 ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
  00792	50		 push	 eax
  00793	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
  00799	83 c4 08	 add	 esp, 8
  0079c	3b f4		 cmp	 esi, esp
  0079e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  007a3	0f b6 c8	 movzx	 ecx, al
  007a6	85 c9		 test	 ecx, ecx
  007a8	74 02		 je	 SHORT $L189081

; 96   : 		{
; 97   : 			break;

  007aa	eb 02		 jmp	 SHORT $L189080
$L189081:

; 98   : 		}
; 99   : 	}

  007ac	eb 96		 jmp	 SHORT $L189079
$L189080:

; 100  : 	if( it != m_vecItem.end() )

  007ae	8d 55 e4	 lea	 edx, DWORD PTR $T190537[ebp]
  007b1	52		 push	 edx
  007b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007b5	83 c1 08	 add	 ecx, 8
  007b8	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  007bd	50		 push	 eax
  007be	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  007c1	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
  007c6	0f b6 c0	 movzx	 eax, al
  007c9	85 c0		 test	 eax, eax
  007cb	74 2c		 je	 SHORT $L189083

; 101  : 	{
; 102  : 		m_iPos = int(it - m_vecItem.begin());

  007cd	8d 4d e0	 lea	 ecx, DWORD PTR $T190538[ebp]
  007d0	51		 push	 ecx
  007d1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007d4	83 c1 08	 add	 ecx, 8
  007d7	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
  007dc	50		 push	 eax
  007dd	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  007e0	e8 00 00 00 00	 call	 ??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator-
  007e5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  007e8	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 103  : 		NotifyOpenExistTab(item);

  007eb	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  007ee	50		 push	 eax
  007ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007f2	e8 00 00 00 00	 call	 ?NotifyOpenExistTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ; CTabBarData::NotifyOpenExistTab

; 104  : 	}else

  007f7	eb 4b		 jmp	 SHORT $L188953
$L189083:

; 105  : 	{
; 106  : 		if( m_vecItem.size() >= MAX_TAB_COUNT )

  007f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007fc	83 c1 08	 add	 ecx, 8
  007ff	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  00804	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00807	72 0c		 jb	 SHORT $L189086

; 107  : 		{
; 108  : 			//tabclosetooltips
; 109  : 			NotifyOpenTabError( 1 );

  00809	6a 01		 push	 1
  0080b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0080e	e8 00 00 00 00	 call	 ?NotifyOpenTabError@CTabBarData@@AAEXH@Z ; CTabBarData::NotifyOpenTabError

; 110  : 		}else

  00813	eb 2f		 jmp	 SHORT $L188953
$L189086:

; 111  : 		{
; 112  : 			m_vecItem.push_back(item);

  00815	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00818	51		 push	 ecx
  00819	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0081c	83 c1 08	 add	 ecx, 8
  0081f	e8 00 00 00 00	 call	 ?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::push_back

; 113  : 			m_iPos = int(m_vecItem.size()-1);

  00824	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00827	83 c1 08	 add	 ecx, 8
  0082a	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  0082f	83 e8 01	 sub	 eax, 1
  00832	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00835	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 114  : 			NotifyCreateTab(item);

  00838	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0083b	50		 push	 eax
  0083c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0083f	e8 00 00 00 00	 call	 ?NotifyCreateTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ; CTabBarData::NotifyCreateTab
$L188953:

; 115  : 		}
; 116  : 	}
; 117  : }

  00844	52		 push	 edx
  00845	8b cd		 mov	 ecx, ebp
  00847	50		 push	 eax
  00848	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190541
  0084e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00853	58		 pop	 eax
  00854	5a		 pop	 edx
  00855	5f		 pop	 edi
  00856	5e		 pop	 esi
  00857	83 c4 30	 add	 esp, 48			; 00000030H
  0085a	3b ec		 cmp	 ebp, esp
  0085c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00861	8b e5		 mov	 esp, ebp
  00863	5d		 pop	 ebp
  00864	c2 04 00	 ret	 4
$L190541:
  00867	01 00 00 00	 DD	 1
  0086b	00 00 00 00	 DD	 $L190540
$L190540:
  0086f	f4 ff ff ff	 DD	 -12			; fffffff4H
  00873	04 00 00 00	 DD	 4
  00877	00 00 00 00	 DD	 $L190539
$L190539:
  0087b	69		 DB	 105			; 00000069H
  0087c	74		 DB	 116			; 00000074H
  0087d	00		 DB	 0
?ITabBar_ChangeTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z ENDP ; CTabBarData::ITabBar_ChangeTab
_TEXT	ENDS
PUBLIC	??0TAB_ITEM@@QAE@XZ				; TAB_ITEM::TAB_ITEM
PUBLIC	??1TAB_ITEM@@QAE@XZ				; TAB_ITEM::~TAB_ITEM
PUBLIC	?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::erase
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
xdata$x	SEGMENT
$T190559 DD	0ffffffffH
	DD	FLAT:$L190548
$T190550 DD	019930520H
	DD	01H
	DD	FLAT:$T190559
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T190547 = -116						; size = 4
$T190546 = -112						; size = 4
$T190545 = -108						; size = 4
$T190544 = -104						; size = 4
_it$ = -96						; size = 4
_itemexisted$ = -84					; size = 60
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_item$ = 8						; size = 4
?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::ITabBar_DeleteTab
; _this$ = ecx

; 120  : {

  00880	55		 push	 ebp
  00881	8b ec		 mov	 ebp, esp
  00883	6a ff		 push	 -1
  00885	68 00 00 00 00	 push	 __ehhandler$?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z
  0088a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00890	50		 push	 eax
  00891	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00898	83 ec 68	 sub	 esp, 104		; 00000068H
  0089b	56		 push	 esi
  0089c	57		 push	 edi
  0089d	51		 push	 ecx
  0089e	8d 7d 8c	 lea	 edi, DWORD PTR [ebp-116]
  008a1	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  008a6	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  008ab	f3 ab		 rep stosd
  008ad	59		 pop	 ecx
  008ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  008b3	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  008b6	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 	TAB_ITEM itemexisted;

  008b9	8d 4d ac	 lea	 ecx, DWORD PTR _itemexisted$[ebp]
  008bc	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@XZ
  008c1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 122  : 	vector<TAB_ITEM>::iterator it = m_vecItem.begin();

  008c8	8d 45 a0	 lea	 eax, DWORD PTR _it$[ebp]
  008cb	50		 push	 eax
  008cc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  008cf	83 c1 08	 add	 ecx, 8
  008d2	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin

; 123  : 	for( ; it != m_vecItem.end(); it++ )

  008d7	eb 0e		 jmp	 SHORT $L189098
$L189099:
  008d9	6a 00		 push	 0
  008db	8d 4d 98	 lea	 ecx, DWORD PTR $T190544[ebp]
  008de	51		 push	 ecx
  008df	8d 4d a0	 lea	 ecx, DWORD PTR _it$[ebp]
  008e2	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
$L189098:
  008e7	8d 55 94	 lea	 edx, DWORD PTR $T190545[ebp]
  008ea	52		 push	 edx
  008eb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  008ee	83 c1 08	 add	 ecx, 8
  008f1	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  008f6	50		 push	 eax
  008f7	8d 4d a0	 lea	 ecx, DWORD PTR _it$[ebp]
  008fa	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
  008ff	0f b6 c0	 movzx	 eax, al
  00902	85 c0		 test	 eax, eax
  00904	74 3d		 je	 SHORT $L189100

; 124  : 	{
; 125  : 		if( it->eumType == item.eumType
; 126  : 			&& it->strName == item.strName )

  00906	8d 4d a0	 lea	 ecx, DWORD PTR _it$[ebp]
  00909	e8 00 00 00 00	 call	 ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
  0090e	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00911	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00914	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00917	75 28		 jne	 SHORT $L189101
  00919	8b f4		 mov	 esi, esp
  0091b	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0091e	50		 push	 eax
  0091f	8d 4d a0	 lea	 ecx, DWORD PTR _it$[ebp]
  00922	e8 00 00 00 00	 call	 ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
  00927	50		 push	 eax
  00928	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
  0092e	83 c4 08	 add	 esp, 8
  00931	3b f4		 cmp	 esi, esp
  00933	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00938	0f b6 c8	 movzx	 ecx, al
  0093b	85 c9		 test	 ecx, ecx
  0093d	74 02		 je	 SHORT $L189101

; 127  : 		{
; 128  : 			break;

  0093f	eb 02		 jmp	 SHORT $L189100
$L189101:

; 129  : 		}
; 130  : 	}

  00941	eb 96		 jmp	 SHORT $L189099
$L189100:

; 131  : 	if( it != m_vecItem.end() )

  00943	8d 55 90	 lea	 edx, DWORD PTR $T190546[ebp]
  00946	52		 push	 edx
  00947	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0094a	83 c1 08	 add	 ecx, 8
  0094d	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  00952	50		 push	 eax
  00953	8d 4d a0	 lea	 ecx, DWORD PTR _it$[ebp]
  00956	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
  0095b	0f b6 c0	 movzx	 eax, al
  0095e	85 c0		 test	 eax, eax
  00960	74 41		 je	 SHORT $L189103

; 132  : 	{
; 133  : 		m_vecItem.erase( it );

  00962	8b 4d a0	 mov	 ecx, DWORD PTR _it$[ebp]
  00965	51		 push	 ecx
  00966	8d 55 8c	 lea	 edx, DWORD PTR $T190547[ebp]
  00969	52		 push	 edx
  0096a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0096d	83 c1 08	 add	 ecx, 8
  00970	e8 00 00 00 00	 call	 ?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::erase

; 134  : 
; 135  : 		m_iPos--;

  00975	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00978	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0097b	83 e9 01	 sub	 ecx, 1
  0097e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00981	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 136  : 		if( m_iPos < 0 )

  00984	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00987	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0098b	7d 0a		 jge	 SHORT $L189105

; 137  : 		{
; 138  : 			m_iPos = 0;

  0098d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00990	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$L189105:

; 139  : 		}
; 140  : 		NotifyDelTab(item);

  00997	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  0099a	52		 push	 edx
  0099b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0099e	e8 00 00 00 00	 call	 ?NotifyDelTab@CTabBarData@@AAEXAAUTAB_ITEM@@@Z ; CTabBarData::NotifyDelTab
$L189103:

; 141  : 	}
; 142  : }

  009a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  009aa	8d 4d ac	 lea	 ecx, DWORD PTR _itemexisted$[ebp]
  009ad	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
  009b2	52		 push	 edx
  009b3	8b cd		 mov	 ecx, ebp
  009b5	50		 push	 eax
  009b6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190557
  009bc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  009c1	58		 pop	 eax
  009c2	5a		 pop	 edx
  009c3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  009c6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  009cd	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009d5	5f		 pop	 edi
  009d6	5e		 pop	 esi
  009d7	83 c4 74	 add	 esp, 116		; 00000074H
  009da	3b ec		 cmp	 ebp, esp
  009dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  009e1	8b e5		 mov	 esp, ebp
  009e3	5d		 pop	 ebp
  009e4	c2 04 00	 ret	 4
$L190557:
  009e7	02 00 00 00	 DD	 2
  009eb	00 00 00 00	 DD	 $L190556
$L190556:
  009ef	ac ff ff ff	 DD	 -84			; ffffffacH
  009f3	3c 00 00 00	 DD	 60			; 0000003cH
  009f7	00 00 00 00	 DD	 $L190551
  009fb	a0 ff ff ff	 DD	 -96			; ffffffa0H
  009ff	04 00 00 00	 DD	 4
  00a03	00 00 00 00	 DD	 $L190552
$L190552:
  00a07	69		 DB	 105			; 00000069H
  00a08	74		 DB	 116			; 00000074H
  00a09	00		 DB	 0
$L190551:
  00a0a	69		 DB	 105			; 00000069H
  00a0b	74		 DB	 116			; 00000074H
  00a0c	65		 DB	 101			; 00000065H
  00a0d	6d		 DB	 109			; 0000006dH
  00a0e	65		 DB	 101			; 00000065H
  00a0f	78		 DB	 120			; 00000078H
  00a10	69		 DB	 105			; 00000069H
  00a11	73		 DB	 115			; 00000073H
  00a12	74		 DB	 116			; 00000074H
  00a13	65		 DB	 101			; 00000065H
  00a14	64		 DB	 100			; 00000064H
  00a15	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L190548:
  0005d	8d 4d ac	 lea	 ecx, DWORD PTR _itemexisted$[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1TAB_ITEM@@QAE@XZ
__ehhandler$?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z:
  00065	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190550
  0006a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ITabBar_DeleteTab@CTabBarData@@UAEXAAUTAB_ITEM@@@Z ENDP ; CTabBarData::ITabBar_DeleteTab
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190566 DD	0ffffffffH
	DD	FLAT:$L190561
$T190564 DD	019930520H
	DD	01H
	DD	FLAT:$T190566
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0TAB_ITEM@@QAE@XZ PROC NEAR				; TAB_ITEM::TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0TAB_ITEM@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b f4		 mov	 esi, esp
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002f	3b f4		 cmp	 esi, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	83 c1 20	 add	 ecx, 32			; 00000020H
  00043	8b f4		 mov	 esi, esp
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00059	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00066	5e		 pop	 esi
  00067	83 c4 10	 add	 esp, 16			; 00000010H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190561:
  00000	8b f4		 mov	 esi, esp
  00002	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??0TAB_ITEM@@QAE@XZ:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190564
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0TAB_ITEM@@QAE@XZ ENDP				; TAB_ITEM::TAB_ITEM
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190575 DD	0ffffffffH
	DD	FLAT:$L190570
$T190573 DD	019930520H
	DD	01H
	DD	FLAT:$T190575
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1TAB_ITEM@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TAB_ITEM@@QAE@XZ PROC NEAR				; TAB_ITEM::~TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1TAB_ITEM@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 20	 add	 ecx, 32			; 00000020H
  00031	8b f4		 mov	 esi, esp
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00047	8b f4		 mov	 esi, esp
  00049	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00063	5e		 pop	 esi
  00064	83 c4 10	 add	 esp, 16			; 00000010H
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190570:
  00000	8b f4		 mov	 esi, esp
  00002	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??1TAB_ITEM@@QAE@XZ:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190573
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1TAB_ITEM@@QAE@XZ ENDP				; TAB_ITEM::~TAB_ITEM
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ITabBar_GetCurPos@CTabBarData@@UAEHXZ PROC NEAR	; CTabBarData::ITabBar_GetCurPos
; _this$ = ecx

; 145  : {

  00a20	55		 push	 ebp
  00a21	8b ec		 mov	 ebp, esp
  00a23	51		 push	 ecx
  00a24	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00a2b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : 	return m_iPos;

  00a2e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a31	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 147  : } 

  00a34	8b e5		 mov	 esp, ebp
  00a36	5d		 pop	 ebp
  00a37	c3		 ret	 0
?ITabBar_GetCurPos@CTabBarData@@UAEHXZ ENDP		; CTabBarData::ITabBar_GetCurPos
_TEXT	ENDS
PUBLIC	??4TAB_ITEM@@QAEAAU0@ABU0@@Z			; TAB_ITEM::operator=
PUBLIC	??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_TabItem$ = 8						; size = 4
?ITabBar_GetCurItem@CTabBarData@@UAE_NAAUTAB_ITEM@@@Z PROC NEAR ; CTabBarData::ITabBar_GetCurItem
; _this$ = ecx

; 150  : {

  00a40	55		 push	 ebp
  00a41	8b ec		 mov	 ebp, esp
  00a43	51		 push	 ecx
  00a44	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00a4b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 151  : 	if( m_iPos >= 0 && m_iPos < m_vecItem.size() )

  00a4e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a51	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00a55	7c 32		 jl	 SHORT $L189117
  00a57	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a5a	83 c1 08	 add	 ecx, 8
  00a5d	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  00a62	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a65	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  00a68	73 1f		 jae	 SHORT $L189117

; 152  : 	{
; 153  : 		TabItem = m_vecItem[m_iPos];

  00a6a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a6d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00a70	50		 push	 eax
  00a71	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a74	83 c1 08	 add	 ecx, 8
  00a77	e8 00 00 00 00	 call	 ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
  00a7c	50		 push	 eax
  00a7d	8b 4d 08	 mov	 ecx, DWORD PTR _TabItem$[ebp]
  00a80	e8 00 00 00 00	 call	 ??4TAB_ITEM@@QAEAAU0@ABU0@@Z

; 154  : 		return true;

  00a85	b0 01		 mov	 al, 1
  00a87	eb 02		 jmp	 SHORT $L189116
$L189117:

; 155  : 	}else
; 156  : 	{
; 157  : 		return false;

  00a89	32 c0		 xor	 al, al
$L189116:

; 158  : 	}	
; 159  : }

  00a8b	83 c4 04	 add	 esp, 4
  00a8e	3b ec		 cmp	 ebp, esp
  00a90	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a95	8b e5		 mov	 esp, ebp
  00a97	5d		 pop	 ebp
  00a98	c2 04 00	 ret	 4
?ITabBar_GetCurItem@CTabBarData@@UAE_NAAUTAB_ITEM@@@Z ENDP ; CTabBarData::ITabBar_GetCurItem
_TEXT	ENDS
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4TAB_ITEM@@QAEAAU0@ABU0@@Z PROC NEAR			; TAB_ITEM::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	8b f4		 mov	 esi, esp
  00011	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0001e	3b f4		 cmp	 esi, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0002b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0002e	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00031	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00034	83 c1 20	 add	 ecx, 32			; 00000020H
  00037	8b f4		 mov	 esi, esp
  00039	51		 push	 ecx
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 20	 add	 ecx, 32			; 00000020H
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00046	3b f4		 cmp	 esi, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	5e		 pop	 esi
  00051	83 c4 04	 add	 esp, 4
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
??4TAB_ITEM@@QAEAAU0@ABU0@@Z ENDP			; TAB_ITEM::operator=
_TEXT	ENDS
PUBLIC	??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z ; std::back_inserter<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
PUBLIC	??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z ; std::copy<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
PUBLIC	?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T190585 = -20						; size = 4
$T190584 = -16						; size = 4
$T190583 = -12						; size = 4
$T190582 = -8						; size = 4
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
?ITabBar_GetTabBarData@CTabBarData@@UAEXAAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@Z PROC NEAR ; CTabBarData::ITabBar_GetTabBarData
; _this$ = ecx

; 162  : {

  00aa0	55		 push	 ebp
  00aa1	8b ec		 mov	 ebp, esp
  00aa3	83 ec 14	 sub	 esp, 20			; 00000014H
  00aa6	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00aab	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00aae	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00ab1	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00ab4	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00ab7	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00aba	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 163  : 	vec.clear();

  00abd	8b 4d 08	 mov	 ecx, DWORD PTR _vec$[ebp]
  00ac0	e8 00 00 00 00	 call	 ?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear

; 164  : 	copy(m_vecItem.begin(), m_vecItem.end(), back_inserter(vec));

  00ac5	8b 45 08	 mov	 eax, DWORD PTR _vec$[ebp]
  00ac8	50		 push	 eax
  00ac9	8d 4d f8	 lea	 ecx, DWORD PTR $T190582[ebp]
  00acc	51		 push	 ecx
  00acd	e8 00 00 00 00	 call	 ??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z ; std::back_inserter<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
  00ad2	83 c4 08	 add	 esp, 8
  00ad5	8b 10		 mov	 edx, DWORD PTR [eax]
  00ad7	52		 push	 edx
  00ad8	8d 45 f4	 lea	 eax, DWORD PTR $T190583[ebp]
  00adb	50		 push	 eax
  00adc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00adf	83 c1 08	 add	 ecx, 8
  00ae2	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  00ae7	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ae9	51		 push	 ecx
  00aea	8d 55 f0	 lea	 edx, DWORD PTR $T190584[ebp]
  00aed	52		 push	 edx
  00aee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00af1	83 c1 08	 add	 ecx, 8
  00af4	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
  00af9	8b 00		 mov	 eax, DWORD PTR [eax]
  00afb	50		 push	 eax
  00afc	8d 4d ec	 lea	 ecx, DWORD PTR $T190585[ebp]
  00aff	51		 push	 ecx
  00b00	e8 00 00 00 00	 call	 ??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z ; std::copy<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
  00b05	83 c4 10	 add	 esp, 16			; 00000010H

; 165  : }

  00b08	83 c4 14	 add	 esp, 20			; 00000014H
  00b0b	3b ec		 cmp	 ebp, esp
  00b0d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b12	8b e5		 mov	 esp, ebp
  00b14	5d		 pop	 ebp
  00b15	c2 04 00	 ret	 4
?ITabBar_GetTabBarData@CTabBarData@@UAEXAAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@Z ENDP ; CTabBarData::ITabBar_GetTabBarData
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >
PUBLIC	??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ		; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
PUBLIC	?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	51		 push	 ecx
  00018	8b cc		 mov	 ecx, esp
  0001a	e8 00 00 00 00	 call	 ??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ ; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >

; 300  : 		_Buy(0);

  00027	6a 00		 push	 0
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy

; 301  : 		}

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 c4 08	 add	 esp, 8
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::vector<TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy

; 389  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::~vector<TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
;	COMDAT ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00018	e8 00 00 00 00	 call	 ??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00014	51		 push	 ecx
  00015	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00018	e8 00 00 00 00	 call	 ??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001e	75 09		 jne	 SHORT $L190592
  00020	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00027	eb 17		 jmp	 SHORT $L190593
$L190592:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00032	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00035	99		 cdq
  00036	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0003b	f7 f9		 idiv	 ecx
  0003d	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L190593:
  00040	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*
PUBLIC	??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+
; Function compile flags: /Odt /RTCsu
;	COMDAT ??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z
_TEXT	SEGMENT
$T190596 = -12						; size = 4
$T190595 = -8						; size = 4
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[], COMDAT
; _this$ = ecx

; 554  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		return (*(begin() + _Pos));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00021	50		 push	 eax
  00022	8d 4d f4	 lea	 ecx, DWORD PTR $T190596[ebp]
  00025	51		 push	 ecx
  00026	8d 55 f8	 lea	 edx, DWORD PTR $T190595[ebp]
  00029	52		 push	 edx
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*

; 556  : 		}

  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??A?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAUTAB_ITEM@@I@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::operator[]
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::capacity
PUBLIC	?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::insert
PUBLIC	?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill
; Function compile flags: /Odt /RTCsu
;	COMDAT ?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z
_TEXT	SEGMENT
$T190599 = -12						; size = 4
$T190598 = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  00027	8b f0		 mov	 esi, eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::capacity
  00031	3b f0		 cmp	 esi, eax
  00033	73 1d		 jae	 SHORT $L189249

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00035	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00038	50		 push	 eax
  00039	6a 01		 push	 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00041	52		 push	 edx
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  00050	eb 1f		 jmp	 SHORT $L189248
$L189249:

; 583  : 			insert(end(), _Val);

  00052	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00055	52		 push	 edx
  00056	8d 45 f8	 lea	 eax, DWORD PTR $T190598[ebp]
  00059	50		 push	 eax
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?end@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::end
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	51		 push	 ecx
  00065	8d 55 f4	 lea	 edx, DWORD PTR $T190599[ebp]
  00068	52		 push	 edx
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::insert
$L189248:

; 584  : 		}

  00071	5e		 pop	 esi
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::push_back
_TEXT	ENDS
PUBLIC	??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ; std::copy<TAB_ITEM *,TAB_ITEM *>
PUBLIC	?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::erase, COMDAT
; _this$ = ecx

; 723  : 		{	// erase element at where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 724  : 		copy(_ITER_BASE(_Where) + 1, _Mylast, _ITER_BASE(_Where));

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00018	52		 push	 edx
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0001c	83 c0 3c	 add	 eax, 60			; 0000003cH
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ; std::copy<TAB_ITEM *,TAB_ITEM *>
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  : 		_Destroy(_Mylast - 1, _Mylast);

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002e	52		 push	 edx
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00035	83 e9 3c	 sub	 ecx, 60			; 0000003cH
  00038	51		 push	 ecx
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy

; 726  : 		--_Mylast;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00047	83 e8 3c	 sub	 eax, 60			; 0000003cH
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 727  : 		return (_Where);

  00050	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00053	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00056	89 02		 mov	 DWORD PTR [edx], eax
  00058	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 728  : 		}

  0005b	83 c4 04	 add	 esp, 4
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
?erase@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::erase
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy

; 745  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?clear@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::clear
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
PUBLIC	??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	51		 push	 ecx
  00018	8b cc		 mov	 ecx, esp
  0001a	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00035	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 281  : 		}

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 c4 08	 add	 esp, 8
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
??0?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::list<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 364  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 365  : 		_Tidy();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy

; 366  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::~list<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
PUBLIC	??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
;	COMDAT ?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin, COMDAT
; _this$ = ecx

; 376  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 377  : 		return (iterator(_Nextnode(_Myhead)));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 10		 mov	 edx, DWORD PTR [eax]
  0001f	52		 push	 edx
  00020	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00023	e8 00 00 00 00	 call	 ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 378  : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?begin@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::begin
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end, COMDAT
; _this$ = ecx

; 386  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 387  : 		return (iterator(_Myhead));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00018	e8 00 00 00 00	 call	 ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 388  : 		}

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?end@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::end
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 239  : 			{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 240  : 			return ((reference)**(const_iterator *)this);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*

; 241  : 			}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??Diterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEAAPAVIMessageObserver@@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 255  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			iterator _Tmp = *this;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	89 4d f4	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 257  : 			++*this;

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++

; 258  : 			return (_Tmp);

  0002a	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Tmp$[ebp]
  00030	89 02		 mov	 DWORD PTR [edx], eax
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 259  : 			}

  00035	52		 push	 edx
  00036	8b cd		 mov	 ecx, ebp
  00038	50		 push	 eax
  00039	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190611
  0003f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00044	58		 pop	 eax
  00045	5a		 pop	 edx
  00046	83 c4 10	 add	 esp, 16			; 00000010H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$L190611:
  00056	01 00 00 00	 DD	 1
  0005a	00 00 00 00	 DD	 $L190610
$L190610:
  0005e	f4 ff ff ff	 DD	 -12			; fffffff4H
  00062	04 00 00 00	 DD	 4
  00066	00 00 00 00	 DD	 $L190609
$L190609:
  0006a	5f		 DB	 95			; 0000005fH
  0006b	54		 DB	 84			; 00000054H
  0006c	6d		 DB	 109			; 0000006dH
  0006d	70		 DB	 112			; 00000070H
  0006e	00		 DB	 0
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
; Function compile flags: /Odt /RTCsu
;	COMDAT ??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 201  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 			return (!(*this == _Right));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	f7 d8		 neg	 eax
  0001f	1b c0		 sbb	 eax, eax
  00021	40		 inc	 eax

; 203  : 			}

  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??9const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator!=
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->, COMDAT
; _this$ = ecx

; 224  : 			{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 225  : 			return (&**this);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*

; 226  : 			}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??Citerator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEPAUTAB_ITEM@@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 236  : 			iterator _Tmp = *this;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	89 4d f4	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 237  : 			++*this;

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++

; 238  : 			return (_Tmp);

  0002a	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Tmp$[ebp]
  00030	89 02		 mov	 DWORD PTR [edx], eax
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 239  : 			}

  00035	52		 push	 edx
  00036	8b cd		 mov	 ecx, ebp
  00038	50		 push	 eax
  00039	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190617
  0003f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00044	58		 pop	 eax
  00045	5a		 pop	 edx
  00046	83 c4 10	 add	 esp, 16			; 00000010H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$L190617:
  00056	01 00 00 00	 DD	 1
  0005a	00 00 00 00	 DD	 $L190616
$L190616:
  0005e	f4 ff ff ff	 DD	 -12			; fffffff4H
  00062	04 00 00 00	 DD	 4
  00066	00 00 00 00	 DD	 $L190615
$L190615:
  0006a	5f		 DB	 95			; 0000005fH
  0006b	54		 DB	 84			; 00000054H
  0006c	6d		 DB	 109			; 0000006dH
  0006d	70		 DB	 112			; 00000070H
  0006e	00		 DB	 0
??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator-
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
$T190619 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	89 4d f8	 mov	 DWORD PTR $T190619[ebp], ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00022	52		 push	 edx
  00023	8d 4d f8	 lea	 ecx, DWORD PTR $T190619[ebp]
  00026	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator-

; 280  : 			}

  0002b	83 c4 08	 add	 esp, 8
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator==
; Function compile flags: /Odt /RTCsu
;	COMDAT ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 159  : 			{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : 			return (!(*this == _Right));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator==
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	f7 d8		 neg	 eax
  0001f	1b c0		 sbb	 eax, eax
  00021	40		 inc	 eax

; 161  : 			}

  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001e	75 09		 jne	 SHORT $L190622
  00020	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00027	eb 17		 jmp	 SHORT $L190623
$L190622:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00032	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00035	99		 cdq
  00036	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0003b	f7 f9		 idiv	 ecx
  0003d	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L190623:
  00040	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::capacity
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Insert_n
; Function compile flags: /Odt /RTCsu
;	COMDAT ?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
$T190628 = -16						; size = 4
$T190625 = -12						; size = 4
__Off$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  00025	85 c0		 test	 eax, eax
  00027	75 09		 jne	 SHORT $L190626
  00029	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00030	eb 18		 jmp	 SHORT $L190627
$L190626:
  00032	8d 45 f4	 lea	 eax, DWORD PTR $T190625[ebp]
  00035	50		 push	 eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
  0003e	50		 push	 eax
  0003f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00042	e8 00 00 00 00	 call	 ??Giterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator-
  00047	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$L190627:
  0004a	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  0004d	89 4d f8	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00050	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	52		 push	 edx
  00054	6a 01		 push	 1
  00056	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00062	8b 4d f8	 mov	 ecx, DWORD PTR __Off$[ebp]
  00065	51		 push	 ecx
  00066	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00069	52		 push	 edx
  0006a	8d 45 f0	 lea	 eax, DWORD PTR $T190628[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?begin@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::begin
  00076	8b c8		 mov	 ecx, eax
  00078	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+
  0007d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE?AViterator@12@V312@ABUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::allocate
PUBLIC	?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
PUBLIC	?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  0002c	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00030	75 04		 jne	 SHORT $L189345

; 773  : 			return (false);

  00032	32 c0		 xor	 al, al
  00034	eb 49		 jmp	 SHORT $L189344
$L189345:

; 774  : 		else if (max_size() < _Capacity)

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
  0003e	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00041	73 0a		 jae	 SHORT $L189347

; 775  : 			_Xlen();	// result too long

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen

; 776  : 		else

  0004b	eb 30		 jmp	 SHORT $L189346
$L189347:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::allocate
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  0005f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00068	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  0006b	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0006e	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L189346:

; 781  : 			}
; 782  : 		return (true);

  0007d	b0 01		 mov	 al, 1
$L189344:

; 783  : 		}

  0007f	83 c4 04	 add	 esp, 4
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
?_Buy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::deallocate
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00015	74 3c		 je	 SHORT $L189360

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001d	52		 push	 edx
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00024	51		 push	 ecx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00036	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00039	8b c1		 mov	 eax, ecx
  0003b	99		 cdq
  0003c	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00041	f7 f9		 idiv	 ecx
  00043	50		 push	 eax
  00044	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00047	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::deallocate
$L189360:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0005d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00060	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  00071	83 c4 04	 add	 esp, 4
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?_Tidy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Uninitialized_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Uninitialized_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  00026	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00029	6b c0 3c	 imul	 eax, 60			; 0000003cH
  0002c	03 45 08	 add	 eax, DWORD PTR __Ptr$[ebp]

; 880  : 		}

  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z PROC NEAR ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z ; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>

; 22   : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_Vector_val@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAE@V?$allocator@UTAB_ITEM@@@1@@Z ENDP ; std::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >::_Vector_val<TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ PROC NEAR	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$allocator@UTAB_ITEM@@@std@@QAE@XZ ENDP		; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode, COMDAT

; 107  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 109  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
PUBLIC	?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190646 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T190648 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L190639
$T190647 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T190648
$T190641 DD	019930520H
	DD	02H
	DD	FLAT:$T190646
	DD	01H
	DD	FLAT:$T190647
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
_TEXT	SEGMENT
tv93 = -44						; size = 4
tv92 = -40						; size = 4
__Linkcnt$ = -36					; size = 4
__Pnode$ = -28						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode, COMDAT
; _this$ = ecx

; 898  : 		{	// allocate a head node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  00027	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0002a	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0002d	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00030	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00033	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00036	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00039	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  0003f	6a 01		 push	 1
  00041	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
  00049	89 45 e4	 mov	 DWORD PTR __Pnode$[ebp], eax

; 900  : 		int _Linkcnt = 0;

  0004c	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR __Linkcnt$[ebp], 0

; 901  : 
; 902  : 		_TRY_BEGIN

  00053	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

  0005a	8b 45 e4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00063	83 c4 04	 add	 esp, 4
  00066	89 45 d8	 mov	 DWORD PTR tv92[ebp], eax
  00069	8d 4d e4	 lea	 ecx, DWORD PTR __Pnode$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 d8	 mov	 edx, DWORD PTR tv92[ebp]
  00070	52		 push	 edx
  00071	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 01	 add	 ecx, 1
  00077	e8 00 00 00 00	 call	 ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct

; 904  : 		++_Linkcnt;

  0007c	8b 45 dc	 mov	 eax, DWORD PTR __Linkcnt$[ebp]
  0007f	83 c0 01	 add	 eax, 1
  00082	89 45 dc	 mov	 DWORD PTR __Linkcnt$[ebp], eax

; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

  00085	8b 4d e4	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  0008e	83 c4 04	 add	 esp, 4
  00091	89 45 d4	 mov	 DWORD PTR tv93[ebp], eax
  00094	8d 55 e4	 lea	 edx, DWORD PTR __Pnode$[ebp]
  00097	52		 push	 edx
  00098	8b 45 d4	 mov	 eax, DWORD PTR tv93[ebp]
  0009b	50		 push	 eax
  0009c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	83 c1 01	 add	 ecx, 1
  000a2	e8 00 00 00 00	 call	 ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
  000a7	eb 35		 jmp	 SHORT $L190638
$L190639:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)

  000a9	83 7d dc 00	 cmp	 DWORD PTR __Linkcnt$[ebp], 0
  000ad	7e 18		 jle	 SHORT $L189396

; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));

  000af	8b 4d e4	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  000b8	83 c4 04	 add	 esp, 4
  000bb	50		 push	 eax
  000bc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	83 c1 01	 add	 ecx, 1
  000c2	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
$L189396:

; 909  : 		this->_Alnod.deallocate(_Pnode, 1);

  000c7	6a 01		 push	 1
  000c9	8b 55 e4	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000cc	52		 push	 edx
  000cd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 910  : 		_RERAISE;

  000d5	6a 00		 push	 0
  000d7	6a 00		 push	 0
  000d9	e8 00 00 00 00	 call	 __CxxThrowException@8
$L190638:

; 911  : 		_CATCH_END

  000de	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 912  : 		return (_Pnode);

  000e5	8b 45 e4	 mov	 eax, DWORD PTR __Pnode$[ebp]
$L190636:

; 913  : 		}

  000e8	52		 push	 edx
  000e9	8b cd		 mov	 ecx, ebp
  000eb	50		 push	 eax
  000ec	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190645
  000f2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000f7	58		 pop	 eax
  000f8	5a		 pop	 edx
  000f9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	83 c4 2c	 add	 esp, 44			; 0000002cH
  00109	3b ec		 cmp	 ebp, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
$L190645:
  00114	01 00 00 00	 DD	 1
  00118	00 00 00 00	 DD	 $L190644
$L190644:
  0011c	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00120	04 00 00 00	 DD	 4
  00124	00 00 00 00	 DD	 $L190642
$L190642:
  00128	5f		 DB	 95			; 0000005fH
  00129	50		 DB	 80			; 00000050H
  0012a	6e		 DB	 110			; 0000006eH
  0012b	6f		 DB	 111			; 0000006fH
  0012c	64		 DB	 100			; 00000064H
  0012d	65		 DB	 101			; 00000065H
  0012e	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190641
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Buynode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Buynode
PUBLIC	?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy, COMDAT
; _this$ = ecx

; 929  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 930  : 		clear();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	83 c1 01	 add	 ecx, 1
  0002c	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy

; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));

  00031	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  0003d	83 c4 04	 add	 esp, 4
  00040	50		 push	 eax
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	83 c1 01	 add	 ecx, 1
  00047	e8 00 00 00 00	 call	 ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy

; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

  0004c	6a 01		 push	 1
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00054	52		 push	 edx
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 934  : 		_Myhead = 0;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 935  : 		}

  00067	83 c4 04	 add	 esp, 4
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAEXXZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
PUBLIC	??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 82   : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	51		 push	 ecx
  00018	8b cc		 mov	 ecx, esp
  0001a	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR __Al$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	83 c1 02	 add	 ecx, 2
  00035	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>

; 83   : 		}

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$_List_val@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_val<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ PROC NEAR ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$allocator@PAVIMessageObserver@@@std@@QAE@XZ ENDP	; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator

; 236  : 			}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 249  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 250  : 			++(*(const_iterator *)this);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++

; 251  : 			return (*this);

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 252  : 			}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??Eiterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 160  : 			{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 			return (_Myval(_Ptr));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
  00019	83 c4 04	 add	 esp, 4

; 162  : 			}

  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??Dconst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBEABQAVIMessageObserver@@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 196  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 			return (_Ptr == _Right._Ptr);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	2b 01		 sub	 eax, DWORD PTR [ecx]
  00018	f7 d8		 neg	 eax
  0001a	1b c0		 sbb	 eax, eax
  0001c	40		 inc	 eax

; 198  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??8const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator

; 216  : 			}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*

; 221  : 			}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 			++this->_Myptr;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			return (*this);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 232  : 			}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	89 4d f4	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00022	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00025	52		 push	 edx
  00026	8d 4d f4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00029	e8 00 00 00 00	 call	 ??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax
  00035	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00038	52		 push	 edx
  00039	8b cd		 mov	 ecx, ebp
  0003b	50		 push	 eax
  0003c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190665
  00042	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00047	58		 pop	 eax
  00048	5a		 pop	 edx
  00049	83 c4 10	 add	 esp, 16			; 00000010H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
$L190665:
  00059	01 00 00 00	 DD	 1
  0005d	00 00 00 00	 DD	 $L190664
$L190664:
  00061	f4 ff ff ff	 DD	 -12			; fffffff4H
  00065	04 00 00 00	 DD	 4
  00069	00 00 00 00	 DD	 $L190663
$L190663:
  0006d	5f		 DB	 95			; 0000005fH
  0006e	54		 DB	 84			; 00000054H
  0006f	6d		 DB	 109			; 0000006dH
  00070	70		 DB	 112			; 00000070H
  00071	00		 DB	 0
??Hiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	2b 01		 sub	 eax, DWORD PTR [ecx]
  00018	99		 cdq
  00019	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0001e	f7 f9		 idiv	 ecx

; 144  : 			}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator-
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 152  : 			{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	2b 01		 sub	 eax, DWORD PTR [ecx]
  00018	f7 d8		 neg	 eax
  0001a	1b c0		 sbb	 eax, eax
  0001c	40		 inc	 eax

; 156  : 			}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??8const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ	; std::allocator<TAB_ITEM>::max_size
; Function compile flags: /Odt /RTCsu
;	COMDAT ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ ; std::allocator<TAB_ITEM>::max_size

; 522  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>
PUBLIC	??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z ; std::fill<TAB_ITEM *,TAB_ITEM>
PUBLIC	??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ; std::copy_backward<TAB_ITEM *,TAB_ITEM *>
PUBLIC	??0TAB_ITEM@@QAE@ABU0@@Z			; TAB_ITEM::TAB_ITEM
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190685 DD	0ffffffffH
	DD	FLAT:$L190677
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T190687 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L190674
$T190688 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L190676
$T190686 DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T190687
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T190688
$T190679 DD	019930520H
	DD	05H
	DD	FLAT:$T190685
	DD	02H
	DD	FLAT:$T190686
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z
_TEXT	SEGMENT
tv244 = -120						; size = 4
tv65 = -116						; size = 4
tv89 = -112						; size = 4
__Oldend$189505 = -108					; size = 4
__Ptr$189485 = -104					; size = 4
__Newvec$189484 = -100					; size = 4
__Capacity$ = -96					; size = 4
__Tmp$ = -88						; size = 60
_this$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 68	 sub	 esp, 104		; 00000068H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	51		 push	 ecx
  00020	8d 7d 88	 lea	 edi, DWORD PTR [ebp-120]
  00023	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	59		 pop	 ecx
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00038	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0003b	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0003e	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00041	50		 push	 eax
  00042	8d 4d a8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00045	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@ABU0@@Z
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 811  : 		size_type _Capacity = capacity();

  00051	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?capacity@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::capacity
  00059	89 45 a0	 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  0005c	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00060	75 05		 jne	 SHORT $L189478

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00062	e9 cf 02 00 00	 jmp	 $L189479
$L189478:
  00067	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  0006f	8b f0		 mov	 esi, eax
  00071	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
  00079	2b c6		 sub	 eax, esi
  0007b	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0007e	73 0d		 jae	 SHORT $L189480

; 816  : 			_Xlen();	// result too long

  00080	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  00088	e9 a9 02 00 00	 jmp	 $L189479
$L189480:
  0008d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  00095	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00098	39 45 a0	 cmp	 DWORD PTR __Capacity$[ebp], eax
  0009b	0f 83 68 01 00
	00		 jae	 $L189482

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  000a1	8b 75 a0	 mov	 esi, DWORD PTR __Capacity$[ebp]
  000a4	d1 ee		 shr	 esi, 1
  000a6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?max_size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::max_size
  000ae	2b c6		 sub	 eax, esi
  000b0	3b 45 a0	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  000b3	73 09		 jae	 SHORT $L190671
  000b5	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  000bc	eb 0b		 jmp	 SHORT $L190672
$L190671:
  000be	8b 4d a0	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  000c1	d1 e9		 shr	 ecx, 1
  000c3	03 4d a0	 add	 ecx, DWORD PTR __Capacity$[ebp]
  000c6	89 4d 90	 mov	 DWORD PTR tv89[ebp], ecx
$L190672:
  000c9	8b 55 90	 mov	 edx, DWORD PTR tv89[ebp]
  000cc	89 55 a0	 mov	 DWORD PTR __Capacity$[ebp], edx

; 821  : 			if (_Capacity < size() + _Count)

  000cf	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  000d7	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000da	39 45 a0	 cmp	 DWORD PTR __Capacity$[ebp], eax
  000dd	73 0e		 jae	 SHORT $L189483

; 822  : 				_Capacity = size() + _Count;

  000df	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  000e7	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000ea	89 45 a0	 mov	 DWORD PTR __Capacity$[ebp], eax
$L189483:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000ed	8b 45 a0	 mov	 eax, DWORD PTR __Capacity$[ebp]
  000f0	50		 push	 eax
  000f1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	e8 00 00 00 00	 call	 ?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::allocate
  000f9	89 45 9c	 mov	 DWORD PTR __Newvec$189484[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  000fc	8b 4d 9c	 mov	 ecx, DWORD PTR __Newvec$189484[ebp]
  000ff	89 4d 98	 mov	 DWORD PTR __Ptr$189485[ebp], ecx

; 825  : 
; 826  : 			_TRY_BEGIN

  00102	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  00106	8b 55 9c	 mov	 edx, DWORD PTR __Newvec$189484[ebp]
  00109	52		 push	 edx
  0010a	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0010d	50		 push	 eax
  0010e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00111	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00114	52		 push	 edx
  00115	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>
  0011d	89 45 8c	 mov	 DWORD PTR tv65[ebp], eax
  00120	8b 45 8c	 mov	 eax, DWORD PTR tv65[ebp]
  00123	89 45 98	 mov	 DWORD PTR __Ptr$189485[ebp], eax

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00126	8d 4d a8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00129	51		 push	 ecx
  0012a	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0012d	52		 push	 edx
  0012e	8b 45 98	 mov	 eax, DWORD PTR __Ptr$189485[ebp]
  00131	50		 push	 eax
  00132	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00135	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill
  0013a	89 45 88	 mov	 DWORD PTR tv244[ebp], eax
  0013d	8b 4d 88	 mov	 ecx, DWORD PTR tv244[ebp]
  00140	89 4d 98	 mov	 DWORD PTR __Ptr$189485[ebp], ecx

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00143	8b 55 98	 mov	 edx, DWORD PTR __Ptr$189485[ebp]
  00146	52		 push	 edx
  00147	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0014a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0014d	51		 push	 ecx
  0014e	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00151	52		 push	 edx
  00152	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00155	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>
  0015a	eb 29		 jmp	 SHORT $L190673
$L190674:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  0015c	8b 45 98	 mov	 eax, DWORD PTR __Ptr$189485[ebp]
  0015f	50		 push	 eax
  00160	8b 4d 9c	 mov	 ecx, DWORD PTR __Newvec$189484[ebp]
  00163	51		 push	 ecx
  00164	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  0016c	8b 55 a0	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0016f	52		 push	 edx
  00170	8b 45 9c	 mov	 eax, DWORD PTR __Newvec$189484[ebp]
  00173	50		 push	 eax
  00174	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00177	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::deallocate

; 834  : 			_RERAISE;

  0017c	6a 00		 push	 0
  0017e	6a 00		 push	 0
  00180	e8 00 00 00 00	 call	 __CxxThrowException@8
$L190673:

; 835  : 			_CATCH_END

  00185	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 836  : 
; 837  : 			_Count += size();

  0018c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	e8 00 00 00 00	 call	 ?size@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEIXZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::size
  00194	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00197	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  0019a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0019d	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  001a1	74 3a		 je	 SHORT $L189492

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  001a3	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  001a6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001a9	50		 push	 eax
  001aa	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ad	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001b0	52		 push	 edx
  001b1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b4	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  001b9	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001bc	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001bf	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001c2	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  001c5	99		 cdq
  001c6	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  001cb	f7 f9		 idiv	 ecx
  001cd	50		 push	 eax
  001ce	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  001d1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001d4	50		 push	 eax
  001d5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d8	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ; std::allocator<TAB_ITEM>::deallocate
$L189492:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001dd	8b 4d a0	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  001e0	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  001e3	03 4d 9c	 add	 ecx, DWORD PTR __Newvec$189484[ebp]
  001e6	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  001e9	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 844  : 			_Mylast = _Newvec + _Count;

  001ec	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001ef	6b c0 3c	 imul	 eax, 60			; 0000003cH
  001f2	03 45 9c	 add	 eax, DWORD PTR __Newvec$189484[ebp]
  001f5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f8	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

  001fb	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  001fe	8b 45 9c	 mov	 eax, DWORD PTR __Newvec$189484[ebp]
  00201	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  00204	e9 2d 01 00 00	 jmp	 $L189479
$L189482:
  00209	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0020c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0020f	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  00212	99		 cdq
  00213	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00218	f7 f9		 idiv	 ecx
  0021a	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0021d	0f 83 af 00 00
	00		 jae	 $L189495

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00223	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00226	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00229	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  0022c	52		 push	 edx
  0022d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00230	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00233	51		 push	 ecx
  00234	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00237	52		 push	 edx
  00238	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>

; 851  : 
; 852  : 			_TRY_BEGIN

  00240	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  00244	8d 45 a8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00247	50		 push	 eax
  00248	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0024b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0024e	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  00251	99		 cdq
  00252	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00257	f7 f9		 idiv	 ecx
  00259	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0025c	2b d0		 sub	 edx, eax
  0025e	52		 push	 edx
  0025f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00262	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00265	51		 push	 ecx
  00266	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00269	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU3@IABU3@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ufill
  0026e	eb 28		 jmp	 SHORT $L190675
$L190676:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  00270	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00273	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00276	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00279	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0027c	52		 push	 edx
  0027d	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00280	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00283	03 4d 08	 add	 ecx, DWORD PTR __Where$[ebp]
  00286	51		 push	 ecx
  00287	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0028a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXPAUTAB_ITEM@@0@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Destroy

; 857  : 			_RERAISE;

  0028f	6a 00		 push	 0
  00291	6a 00		 push	 0
  00293	e8 00 00 00 00	 call	 __CxxThrowException@8
$L190675:

; 858  : 			_CATCH_END

  00298	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 859  : 
; 860  : 			_Mylast += _Count;

  0029f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  002a2	6b d2 3c	 imul	 edx, 60			; 0000003cH
  002a5	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  002a8	03 50 08	 add	 edx, DWORD PTR [eax+8]
  002ab	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002ae	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  002b1	8d 55 a8	 lea	 edx, DWORD PTR __Tmp$[ebp]
  002b4	52		 push	 edx
  002b5	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002b8	6b c0 3c	 imul	 eax, 60			; 0000003cH
  002bb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002be	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002c1	2b d0		 sub	 edx, eax
  002c3	52		 push	 edx
  002c4	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  002c7	50		 push	 eax
  002c8	e8 00 00 00 00	 call	 ??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z ; std::fill<TAB_ITEM *,TAB_ITEM>
  002cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002d0	eb 64		 jmp	 SHORT $L189479
$L189495:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  002d2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002d8	89 55 94	 mov	 DWORD PTR __Oldend$189505[ebp], edx

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002db	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  002de	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002e1	51		 push	 ecx
  002e2	8b 55 94	 mov	 edx, DWORD PTR __Oldend$189505[ebp]
  002e5	52		 push	 edx
  002e6	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002e9	6b c0 3c	 imul	 eax, 60			; 0000003cH
  002ec	8b 4d 94	 mov	 ecx, DWORD PTR __Oldend$189505[ebp]
  002ef	2b c8		 sub	 ecx, eax
  002f1	51		 push	 ecx
  002f2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002f5	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>
  002fa	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  002fd	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  00300	8b 45 94	 mov	 eax, DWORD PTR __Oldend$189505[ebp]
  00303	50		 push	 eax
  00304	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00307	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  0030a	8b 55 94	 mov	 edx, DWORD PTR __Oldend$189505[ebp]
  0030d	2b d1		 sub	 edx, ecx
  0030f	52		 push	 edx
  00310	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00313	50		 push	 eax
  00314	e8 00 00 00 00	 call	 ??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ; std::copy_backward<TAB_ITEM *,TAB_ITEM *>
  00319	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  0031c	8d 4d a8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0031f	51		 push	 ecx
  00320	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00323	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00326	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  00329	52		 push	 edx
  0032a	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0032d	50		 push	 eax
  0032e	e8 00 00 00 00	 call	 ??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z ; std::fill<TAB_ITEM *,TAB_ITEM>
  00333	83 c4 0c	 add	 esp, 12			; 0000000cH
$L189479:

; 873  : 			}
; 874  : 		}

  00336	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0033d	8d 4d a8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00340	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
$L190670:
  00345	52		 push	 edx
  00346	8b cd		 mov	 ecx, ebp
  00348	50		 push	 eax
  00349	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190684
  0034f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00354	58		 pop	 eax
  00355	5a		 pop	 edx
  00356	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00359	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00360	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00363	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00368	5f		 pop	 edi
  00369	5e		 pop	 esi
  0036a	5b		 pop	 ebx
  0036b	83 c4 78	 add	 esp, 120		; 00000078H
  0036e	3b ec		 cmp	 ebp, esp
  00370	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00375	8b e5		 mov	 esp, ebp
  00377	5d		 pop	 ebp
  00378	c2 0c 00	 ret	 12			; 0000000cH
$L190684:
  0037b	01 00 00 00	 DD	 1
  0037f	00 00 00 00	 DD	 $L190683
$L190683:
  00383	a8 ff ff ff	 DD	 -88			; ffffffa8H
  00387	3c 00 00 00	 DD	 60			; 0000003cH
  0038b	00 00 00 00	 DD	 $L190680
$L190680:
  0038f	5f		 DB	 95			; 0000005fH
  00390	54		 DB	 84			; 00000054H
  00391	6d		 DB	 109			; 0000006dH
  00392	70		 DB	 112			; 00000070H
  00393	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190677:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TAB_ITEM@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190679
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEXViterator@12@IABUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190698 DD	0ffffffffH
	DD	FLAT:$L190694
$T190696 DD	019930520H
	DD	01H
	DD	FLAT:$T190698
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
	ORG $-30
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T190693 = -84						; size = 28
$T190692 = -56						; size = 40
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	51		 push	 ecx
  0001e	8d 7d ac	 lea	 edi, DWORD PTR [ebp-84]
  00021	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  00031	8b f4		 mov	 esi, esp
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00038	8d 4d ac	 lea	 ecx, DWORD PTR $T190693[ebp]
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	8d 45 ac	 lea	 eax, DWORD PTR $T190693[ebp]
  00052	50		 push	 eax
  00053	8d 4d c8	 lea	 ecx, DWORD PTR $T190692[ebp]
  00056	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00060	8d 4d c8	 lea	 ecx, DWORD PTR $T190692[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L190691:

; 885  : 		}

  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	83 c4 54	 add	 esp, 84			; 00000054H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190694:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d ac	 lea	 ecx, DWORD PTR $T190693[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190696
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IBEXXZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Xlen
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z PROC NEAR	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??0?$allocator@UTAB_ITEM@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<TAB_ITEM>::allocator<TAB_ITEM>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z PROC NEAR ; std::allocator<TAB_ITEM>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4

; 133  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@I@Z ENDP ; std::allocator<TAB_ITEM>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z ; std::_Allocate<TAB_ITEM>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z PROC NEAR ; std::allocator<TAB_ITEM>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  0000e	6a 00		 push	 0
  00010	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z ; std::_Allocate<TAB_ITEM>
  00019	83 c4 08	 add	 esp, 8

; 138  : 		}

  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@UTAB_ITEM@@@std@@QAEPAUTAB_ITEM@@I@Z ENDP ; std::allocator<TAB_ITEM>::allocate
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode, COMDAT

; 112  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 114  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval, COMDAT

; 117  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 119  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAVIMessageObserver@@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Myval
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Pnode$ = -12						; size = 4
__Pnext$ = -8						; size = 4
_this$ = -4						; size = 4
?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear, COMDAT
; _this$ = ecx

; 610  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b 10		 mov	 edx, DWORD PTR [eax]
  0002f	89 55 f4	 mov	 DWORD PTR __Pnode$[ebp], edx

; 613  : 		_Nextnode(_Myhead) = _Myhead;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00047	89 08		 mov	 DWORD PTR [eax], ecx

; 614  : 		_Prevnode(_Myhead) = _Myhead;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?_Prevnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Prevnode
  00055	83 c4 04	 add	 esp, 4
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005e	89 10		 mov	 DWORD PTR [eax], edx

; 615  : 		_Mysize = 0;

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

  0006a	eb 06		 jmp	 SHORT $L189542
$L189543:
  0006c	8b 4d f8	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  0006f	89 4d f4	 mov	 DWORD PTR __Pnode$[ebp], ecx
$L189542:
  00072	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00075	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00078	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0007b	74 2d		 je	 SHORT $L189539

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00086	83 c4 04	 add	 esp, 4
  00089	8b 10		 mov	 edx, DWORD PTR [eax]
  0008b	89 55 f8	 mov	 DWORD PTR __Pnext$[ebp], edx

; 620  : 			this->_Alnod.destroy(_Pnode);

  0008e	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00091	50		 push	 eax
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy

; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

  0009a	6a 01		 push	 1
  0009c	8b 4d f4	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0009f	51		 push	 ecx
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate

; 622  : 			}

  000a8	eb c2		 jmp	 SHORT $L189543
$L189539:

; 623  : 		}

  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ad	3b ec		 cmp	 ebp, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
?clear@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEXXZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::clear
_TEXT	ENDS
PUBLIC	??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
PUBLIC	??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 64   : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	51		 push	 ecx
  00018	8b cc		 mov	 ecx, esp
  0001a	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR __Al$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	83 c1 01	 add	 ecx, 1
  00035	e8 00 00 00 00	 call	 ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>

; 65   : 		}

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$_List_ptr@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_ptr<IMessageObserver *,std::allocator<IMessageObserver *> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??0?$allocator@PAVIMessageObserver@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<IMessageObserver *>::allocator<IMessageObserver *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4

; 133  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  0000e	6a 00		 push	 0
  00010	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
  00019	83 c4 08	 add	 esp, 8

; 138  : 		}

  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
  0001b	83 c4 08	 add	 esp, 8

; 148  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
  00017	83 c4 04	 add	 esp, 4

; 153  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::destroy
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 157  : 			}

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??0const_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 170  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 			_Ptr = _Nextnode(_Ptr);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ?_Nextnode@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@PAU342@@Z ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::_Nextnode
  00019	83 c4 04	 add	 esp, 4
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 02		 mov	 DWORD PTR [edx], eax

; 172  : 			return (*this);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 173  : 			}

  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??Econst_iterator@?$list@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<IMessageObserver *,std::allocator<IMessageObserver *> >::const_iterator::operator++
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00011	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	03 01		 add	 eax, DWORD PTR [ecx]
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	89 02		 mov	 DWORD PTR [edx], eax

; 257  : 			return (*this);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??Yiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator+=
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??0const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAE@PAUTAB_ITEM@@@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??Dconst_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEABUTAB_ITEM@@XZ ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator*
_TEXT	ENDS
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190725 DD	0ffffffffH
	DD	FLAT:$L190720
$T190723 DD	019930520H
	DD	01H
	DD	FLAT:$T190725
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0TAB_ITEM@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0TAB_ITEM@@QAE@ABU0@@Z PROC NEAR			; TAB_ITEM::TAB_ITEM, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0TAB_ITEM@@QAE@ABU0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b f4		 mov	 esi, esp
  00026	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00047	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0004a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00050	83 c1 20	 add	 ecx, 32			; 00000020H
  00053	8b f4		 mov	 esi, esp
  00055	51		 push	 ecx
  00056	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	83 c1 20	 add	 ecx, 32			; 00000020H
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00070	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007d	5e		 pop	 esi
  0007e	83 c4 10	 add	 esp, 16			; 00000010H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190720:
  00000	8b f4		 mov	 esi, esp
  00002	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??0TAB_ITEM@@QAE@ABU0@@Z:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190723
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0TAB_ITEM@@QAE@ABU0@@Z ENDP				; TAB_ITEM::TAB_ITEM
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt /RTCsu
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ PROC NEAR	; std::allocator<TAB_ITEM>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0001e	c7 45 f8 44 44
	44 04		 mov	 DWORD PTR __Count$[ebp], 71582788 ; 04444444H

; 158  : 		return (0 < _Count ? _Count : 1);

  00025	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00029	76 08		 jbe	 SHORT $L190731
  0002b	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00031	eb 07		 jmp	 SHORT $L190732
$L190731:
  00033	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L190732:
  0003a	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$allocator@UTAB_ITEM@@@std@@QBEIXZ ENDP	; std::allocator<TAB_ITEM>::max_size
_TEXT	ENDS
PUBLIC	??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >, COMDAT
; _this$ = ecx

; 44   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>

; 45   : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@IAE@V?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
  00017	83 c4 04	 add	 esp, 4

; 153  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
;	COMDAT ??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Cont$ = 12						; size = 4
??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z PROC NEAR ; std::back_inserter<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >, COMDAT

; 55   : 	{	// return a back_insert_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   : 	return (std::back_insert_iterator<_Container>(_Cont));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Cont$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 57   : 	}

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$back_inserter@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@@Z ENDP ; std::back_inserter<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z ; std::_Ptr_cat<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
PUBLIC	??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T190737 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z PROC NEAR ; std::copy<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >, COMDAT

; 1039 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  0000b	8d 45 14	 lea	 eax, DWORD PTR __Dest$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z ; std::_Ptr_cat<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T190737[ebp], al
  0001e	8a 55 ff	 mov	 dl, BYTE PTR $T190737[ebp]
  00021	52		 push	 edx
  00022	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
  00037	83 c4 14	 add	 esp, 20			; 00000014H
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1041 : 	}

  0003d	83 c4 04	 add	 esp, 4
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$copy@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@@Z ENDP ; std::copy<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
PUBLIC	??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<TAB_ITEM *,TAB_ITEM *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z
_TEXT	SEGMENT
$T190739 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z PROC NEAR ; std::copy<TAB_ITEM *,TAB_ITEM *>, COMDAT

; 1039 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  0000b	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T190739[ebp], al
  0001e	8a 55 ff	 mov	 dl, BYTE PTR $T190739[ebp]
  00021	52		 push	 edx
  00022	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<TAB_ITEM *,TAB_ITEM *>
  00033	83 c4 10	 add	 esp, 16			; 00000010H

; 1041 : 	}

  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$copy@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ENDP ; std::copy<TAB_ITEM *,TAB_ITEM *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT
$T190741 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z PROC NEAR ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000b	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T190741[ebp], al
  0001e	8a 55 ff	 mov	 dl, BYTE PTR $T190741[ebp]
  00021	52		 push	 edx
  00022	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
  00033	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@@Z ENDP ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT
$T190743 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  0000b	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T190743[ebp], al
  0001e	8a 55 ff	 mov	 dl, BYTE PTR $T190743[ebp]
  00021	52		 push	 edx
  00022	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
  00037	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??$_Uninitialized_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@@Z ENDP ; std::_Uninitialized_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Uninitialized_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z PROC NEAR ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z ; std::_Uninitialized_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAUTAB_ITEM@@@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@IAEPAUTAB_ITEM@@PAU2@00@Z ENDP ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::_Ucopy<TAB_ITEM *>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z PROC NEAR ; std::fill<TAB_ITEM *,TAB_ITEM>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1135 : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L189809
$L189810:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 3c	 add	 eax, 60			; 0000003cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L189809:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L189808

; 1136 : 		*_First = _Val;

  00016	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001d	e8 00 00 00 00	 call	 ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
  00022	eb e1		 jmp	 SHORT $L189810
$L189808:

; 1137 : 	}

  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$fill@PAUTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@0ABU1@@Z ENDP ; std::fill<TAB_ITEM *,TAB_ITEM>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<TAB_ITEM *,TAB_ITEM *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z
_TEXT	SEGMENT
$T190747 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z PROC NEAR ; std::copy_backward<TAB_ITEM *,TAB_ITEM *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  0000b	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T190747[ebp], al
  0001e	8a 55 ff	 mov	 dl, BYTE PTR $T190747[ebp]
  00021	52		 push	 edx
  00022	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<TAB_ITEM *,TAB_ITEM *>
  00033	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$copy_backward@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00@Z ENDP ; std::copy_backward<TAB_ITEM *,TAB_ITEM *>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z PROC NEAR ; std::_Allocate<TAB_ITEM>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Allocate@UTAB_ITEM@@@std@@YAPAUTAB_ITEM@@IPAU1@@Z ENDP ; std::_Allocate<TAB_ITEM>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$?0PAVIMessageObserver@@@?$allocator@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *><IMessageObserver *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
$T190752 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00014	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00017	50		 push	 eax
  00018	6a 04		 push	 4
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001f	83 c4 08	 add	 esp, 8
  00022	89 45 fc	 mov	 DWORD PTR $T190752[ebp], eax
  00025	83 7d fc 00	 cmp	 DWORD PTR $T190752[ebp], 0
  00029	74 12		 je	 SHORT $L190753
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR $T190752[ebp]
  0002e	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00031	8b 02		 mov	 eax, DWORD PTR [edx]
  00033	89 01		 mov	 DWORD PTR [ecx], eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR $T190752[ebp]
  00038	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0003b	eb 07		 jmp	 SHORT $L189838
$L190753:
  0003d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L189838:

; 43   : 	}

  00044	83 c4 08	 add	 esp, 8
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
??$_Construct@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *,std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@PAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$?0PAVIMessageObserver@@@?$allocator@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVIMessageObserver@@@1@@Z ENDP ; std::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>::allocator<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node><IMessageObserver *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVIMessageObserver@@V?$allocator@PAVIMessageObserver@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<IMessageObserver *,std::allocator<IMessageObserver *> >::_Node>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
_TEXT	ENDS
;	COMDAT ??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Cont$ = 8						; size = 4
??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z PROC NEAR ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >, COMDAT
; _this$ = ecx

; 23   : 		{	// construct with container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Cont$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 24   : 		}

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??0?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAE@AAV?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@1@@Z ENDP ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z PROC NEAR ; std::_Ptr_cat<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  0001b	8a 45 fb	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  0001e	52		 push	 edx
  0001f	8b cd		 mov	 ecx, ebp
  00021	50		 push	 eax
  00022	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190763
  00028	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0002d	58		 pop	 eax
  0002e	5a		 pop	 edx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$L190763:
  00033	01 00 00 00	 DD	 1
  00037	00 00 00 00	 DD	 $L190762
$L190762:
  0003b	fb ff ff ff	 DD	 -5			; fffffffbH
  0003f	01 00 00 00	 DD	 1
  00043	00 00 00 00	 DD	 $L190761
$L190761:
  00047	5f		 DB	 95			; 0000005fH
  00048	43		 DB	 67			; 00000043H
  00049	61		 DB	 97			; 00000061H
  0004a	74		 DB	 116			; 00000074H
  0004b	00		 DB	 0
??$_Ptr_cat@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@AAV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@@Z ENDP ; std::_Ptr_cat<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
_TEXT	ENDS
PUBLIC	??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator=
PUBLIC	??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator*
PUBLIC	??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator++
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >, COMDAT

; 1020 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1021 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	eb 10		 jmp	 SHORT $L189852
$L189853:
  00005	8d 4d 14	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00008	e8 00 00 00 00	 call	 ??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator++
  0000d	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEAAV012@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator++
$L189852:
  00015	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00018	50		 push	 eax
  00019	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0001c	e8 00 00 00 00	 call	 ??9const_iterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBE_NABV012@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::const_iterator::operator!=
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 1a		 je	 SHORT $L189854

; 1022 : 		*_Dest = *_First;

  00028	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0002b	e8 00 00 00 00	 call	 ??Diterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QBEAAUTAB_ITEM@@XZ ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator::operator*
  00030	50		 push	 eax
  00031	8d 4d 14	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00034	e8 00 00 00 00	 call	 ??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator*
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 ??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator=
  00040	eb c3		 jmp	 SHORT $L189853
$L189854:

; 1023 : 	return (_Dest);

  00042	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00045	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
  00048	89 02		 mov	 DWORD PTR [edx], eax
  0004a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1024 : 	}

  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??$_Copy_opt@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@V?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@3@@std@@YA?AV?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@0@Viterator@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@0@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::iterator,std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > > >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z PROC NEAR ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  0001b	8a 45 fb	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  0001e	52		 push	 edx
  0001f	8b cd		 mov	 ecx, ebp
  00021	50		 push	 eax
  00022	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L190768
  00028	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0002d	58		 pop	 eax
  0002e	5a		 pop	 edx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$L190768:
  00033	01 00 00 00	 DD	 1
  00037	00 00 00 00	 DD	 $L190767
$L190767:
  0003b	fb ff ff ff	 DD	 -5			; fffffffbH
  0003f	01 00 00 00	 DD	 1
  00043	00 00 00 00	 DD	 $L190766
$L190766:
  00047	5f		 DB	 95			; 0000005fH
  00048	43		 DB	 67			; 00000043H
  00049	61		 DB	 97			; 00000061H
  0004a	74		 DB	 116			; 00000074H
  0004b	00		 DB	 0
??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ENDP ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<TAB_ITEM *,TAB_ITEM *>, COMDAT

; 1020 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1021 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	eb 12		 jmp	 SHORT $L189858
$L189859:
  00005	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00008	83 c0 3c	 add	 eax, 60			; 0000003cH
  0000b	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00014	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$L189858:
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	3b 55 0c	 cmp	 edx, DWORD PTR __Last$[ebp]
  0001d	74 0e		 je	 SHORT $L189860

; 1022 : 		*_Dest = *_First;

  0001f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00026	e8 00 00 00 00	 call	 ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
  0002b	eb d8		 jmp	 SHORT $L189859
$L189860:

; 1023 : 	return (_Dest);

  0002d	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1024 : 	}

  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Copy_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<TAB_ITEM *,TAB_ITEM *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ; std::allocator<TAB_ITEM>::destroy
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L189862
$L189863:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 3c	 add	 eax, 60			; 0000003cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L189862:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L189861

; 226  : 		_Al.destroy(_First);

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001d	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ; std::allocator<TAB_ITEM>::destroy
  00022	eb e1		 jmp	 SHORT $L189863
$L189861:

; 227  : 	}

  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Destroy_range@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@0AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<TAB_ITEM,std::allocator<TAB_ITEM> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z ; std::allocator<TAB_ITEM>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T190777 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T190779 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L190773
$T190778 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T190779
$T190775 DD	019930520H
	DD	02H
	DD	FLAT:$T190777
	DD	01H
	DD	FLAT:$T190778
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >, COMDAT

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00024	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 208  : 	_FwdIt _Next = _First;

  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 209  : 
; 210  : 	_TRY_BEGIN

  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  00034	eb 12		 jmp	 SHORT $L189868
$L189869:
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00039	83 e9 01	 sub	 ecx, 1
  0003c	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	83 c2 3c	 add	 edx, 60			; 0000003cH
  00045	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L189868:
  00048	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0004c	76 12		 jbe	 SHORT $L189870

; 212  : 		_Al.construct(_First, _Val);

  0004e	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00055	51		 push	 ecx
  00056	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00059	e8 00 00 00 00	 call	 ?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z ; std::allocator<TAB_ITEM>::construct
  0005e	eb d6		 jmp	 SHORT $L189869
$L189870:
  00060	eb 2a		 jmp	 SHORT $L190772
$L190773:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

  00062	eb 09		 jmp	 SHORT $L189871
$L189872:
  00064	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00067	83 c2 3c	 add	 edx, 60			; 0000003cH
  0006a	89 55 ec	 mov	 DWORD PTR __Next$[ebp], edx
$L189871:
  0006d	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00070	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  00073	74 0e		 je	 SHORT $L189873

; 215  : 		_Al.destroy(_Next);

  00075	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00078	51		 push	 ecx
  00079	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0007c	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ; std::allocator<TAB_ITEM>::destroy
  00081	eb e1		 jmp	 SHORT $L189872
$L189873:

; 216  : 	_RERAISE;

  00083	6a 00		 push	 0
  00085	6a 00		 push	 0
  00087	e8 00 00 00 00	 call	 __CxxThrowException@8
$L190772:

; 217  : 	_CATCH_END

  0008c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$L190771:

; 218  : 	}

  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	83 c4 14	 add	 esp, 20			; 00000014H
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190775
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAUTAB_ITEM@@IU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAXPAUTAB_ITEM@@IABU1@AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<TAB_ITEM *,unsigned int,TAB_ITEM,std::allocator<TAB_ITEM> >
PUBLIC	??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z
_TEXT	SEGMENT
$T190783 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  0000b	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTAB_ITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTAB_ITEM@@0@Z ; std::_Ptr_cat<TAB_ITEM *,TAB_ITEM *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T190783[ebp], al
  0001e	8a 55 ff	 mov	 dl, BYTE PTR $T190783[ebp]
  00021	52		 push	 edx
  00022	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
  00037	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??$_Uninitialized_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@@Z ENDP ; std::_Uninitialized_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<TAB_ITEM *,TAB_ITEM *>, COMDAT

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L189916:

; 1049 : 	while (_First != _Last)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00009	74 20		 je	 SHORT $L189917

; 1050 : 		*--_Dest = *--_Last;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	83 e9 3c	 sub	 ecx, 60			; 0000003cH
  00011	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  00014	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00017	83 ea 3c	 sub	 edx, 60			; 0000003cH
  0001a	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0001d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00024	e8 00 00 00 00	 call	 ??4TAB_ITEM@@QAEAAU0@ABU0@@Z
  00029	eb d8		 jmp	 SHORT $L189916
$L189917:

; 1051 : 	return (_Dest);

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1052 : 	}

  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Copy_backward_opt@PAUTAB_ITEM@@PAU1@@std@@YAPAUTAB_ITEM@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<TAB_ITEM *,TAB_ITEM *>
_TEXT	ENDS
PUBLIC	??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z ; std::_Construct<TAB_ITEM,TAB_ITEM>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z PROC NEAR ; std::allocator<TAB_ITEM>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z ; std::_Construct<TAB_ITEM,TAB_ITEM>
  0001b	83 c4 08	 add	 esp, 8

; 148  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z ENDP ; std::allocator<TAB_ITEM>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z	; std::_Destroy<TAB_ITEM>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z PROC NEAR ; std::allocator<TAB_ITEM>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z ; std::_Destroy<TAB_ITEM>
  00017	83 c4 04	 add	 esp, 4

; 153  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ENDP ; std::allocator<TAB_ITEM>::destroy
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iterator
_TEXT	ENDS
;	COMDAT ??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z PROC NEAR ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator=, COMDAT
; _this$ = ecx

; 28   : 		{	// push value into container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 		container->push_back(_Val);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00017	e8 00 00 00 00	 call	 ?push_back@?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@QAEXABUTAB_ITEM@@@Z ; std::vector<TAB_ITEM,std::allocator<TAB_ITEM> >::push_back

; 30   : 		return (*this);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 31   : 		}

  0001f	83 c4 04	 add	 esp, 4
  00022	3b ec		 cmp	 ebp, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??4?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@ABUTAB_ITEM@@@Z ENDP ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator=
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ PROC NEAR ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator*, COMDAT
; _this$ = ecx

; 34   : 		{	// pretend to return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 		return (*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 36   : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??D?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator*
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ PROC NEAR ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator++, COMDAT
; _this$ = ecx

; 39   : 		{	// pretend to preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 		return (*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 41   : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??E?$back_insert_iterator@V?$vector@UTAB_ITEM@@V?$allocator@UTAB_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::back_insert_iterator<std::vector<TAB_ITEM,std::allocator<TAB_ITEM> > >::operator++
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T190796 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T190798 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L190792
$T190797 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T190798
$T190794 DD	019930520H
	DD	02H
	DD	FLAT:$T190796
	DD	01H
	DD	FLAT:$T190797
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00024	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 78   : 	_FwdIt _Next = _Dest;

  00027	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002a	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 79   : 
; 80   : 	_TRY_BEGIN

  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  00034	eb 12		 jmp	 SHORT $L189941
$L189942:
  00036	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00039	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0003c	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	83 c2 3c	 add	 edx, 60			; 0000003cH
  00045	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L189941:
  00048	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0004b	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0004e	74 12		 je	 SHORT $L189943

; 82   : 		_Al.construct(_Dest, *_First);

  00050	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00053	51		 push	 ecx
  00054	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00057	52		 push	 edx
  00058	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0005b	e8 00 00 00 00	 call	 ?construct@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@ABU3@@Z ; std::allocator<TAB_ITEM>::construct
  00060	eb d4		 jmp	 SHORT $L189942
$L189943:
  00062	eb 2a		 jmp	 SHORT $L190791
$L190792:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  00064	eb 09		 jmp	 SHORT $L189944
$L189945:
  00066	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00069	83 c0 3c	 add	 eax, 60			; 0000003cH
  0006c	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$L189944:
  0006f	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00072	3b 4d 10	 cmp	 ecx, DWORD PTR __Dest$[ebp]
  00075	74 0e		 je	 SHORT $L189946

; 85   : 		_Al.destroy(_Next);

  00077	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  0007a	52		 push	 edx
  0007b	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0007e	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTAB_ITEM@@@std@@QAEXPAUTAB_ITEM@@@Z ; std::allocator<TAB_ITEM>::destroy
  00083	eb e1		 jmp	 SHORT $L189945
$L189946:

; 86   : 	_RERAISE;

  00085	6a 00		 push	 0
  00087	6a 00		 push	 0
  00089	e8 00 00 00 00	 call	 __CxxThrowException@8
$L190791:

; 87   : 	_CATCH_END

  0008e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 88   : 	return (_Dest);

  00095	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$L190790:

; 89   : 	}

  00098	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	83 c4 14	 add	 esp, 20			; 00000014H
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190794
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAUTAB_ITEM@@PAU1@V?$allocator@UTAB_ITEM@@@std@@@std@@YAPAUTAB_ITEM@@PAU1@00AAV?$allocator@UTAB_ITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<TAB_ITEM *,TAB_ITEM *,std::allocator<TAB_ITEM> >
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T190810 DD	0ffffffffH
	DD	FLAT:$L190806
$T190808 DD	019930520H
	DD	01H
	DD	FLAT:$T190810
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -24						; size = 4
$T190803 = -20						; size = 4
$T190802 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z PROC NEAR ; std::_Construct<TAB_ITEM,TAB_ITEM>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  00022	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00029	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00030	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00033	50		 push	 eax
  00034	6a 3c		 push	 60			; 0000003cH
  00036	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0003b	83 c4 08	 add	 esp, 8
  0003e	89 45 ec	 mov	 DWORD PTR $T190803[ebp], eax
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	83 7d ec 00	 cmp	 DWORD PTR $T190803[ebp], 0
  0004c	74 11		 je	 SHORT $L190804
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00051	51		 push	 ecx
  00052	8b 4d ec	 mov	 ecx, DWORD PTR $T190803[ebp]
  00055	e8 00 00 00 00	 call	 ??0TAB_ITEM@@QAE@ABU0@@Z
  0005a	89 45 e8	 mov	 DWORD PTR tv74[ebp], eax
  0005d	eb 07		 jmp	 SHORT $L190805
$L190804:
  0005f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L190805:
  00066	8b 55 e8	 mov	 edx, DWORD PTR tv74[ebp]
  00069	89 55 f0	 mov	 DWORD PTR $T190802[ebp], edx
  0006c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 43   : 	}

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007d	83 c4 18	 add	 esp, 24			; 00000018H
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190806:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ec	 mov	 ecx, DWORD PTR $T190803[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190808
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Construct@UTAB_ITEM@@U1@@std@@YAXPAUTAB_ITEM@@ABU1@@Z ENDP ; std::_Construct<TAB_ITEM,TAB_ITEM>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_GTAB_ITEM@@QAEPAXI@Z				; TAB_ITEM::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z PROC NEAR ; std::_Destroy<TAB_ITEM>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00003	6a 00		 push	 0
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??_GTAB_ITEM@@QAEPAXI@Z

; 50   : 	}

  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$_Destroy@UTAB_ITEM@@@std@@YAXPAUTAB_ITEM@@@Z ENDP	; std::_Destroy<TAB_ITEM>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_GTAB_ITEM@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTAB_ITEM@@QAEPAXI@Z PROC NEAR			; TAB_ITEM::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1TAB_ITEM@@QAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0c		 je	 SHORT $L189958
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4
$L189958:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??_GTAB_ITEM@@QAEPAXI@Z ENDP				; TAB_ITEM::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00015	8b f4		 mov	 esi, esp
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0001d	3b f4		 cmp	 esi, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 28   : 		}

  00024	5e		 pop	 esi
  00025	83 c4 04	 add	 esp, 4
  00028	3b ec		 cmp	 ebp, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190825 DD	0ffffffffH
	DD	FLAT:$L190820
$T190823 DD	019930520H
	DD	01H
	DD	FLAT:$T190825
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt /RTCsu
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b f4		 mov	 esi, esp
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  0002f	3b f4		 cmp	 esi, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00046	8b f4		 mov	 esi, esp
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  0004b	51		 push	 ecx
  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 20   : 		}

  0005f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00073	5e		 pop	 esi
  00074	83 c4 10	 add	 esp, 16			; 00000010H
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190820:
  00000	8b f4		 mov	 esi, esp
  00002	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190823
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0c		 je	 SHORT $L91647
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4
$L91647:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190835 DD	0ffffffffH
	DD	FLAT:$L190830
$T190833 DD	019930520H
	DD	01H
	DD	FLAT:$T190835
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003a	8b f4		 mov	 esi, esp
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00050	8b f4		 mov	 esi, esp
  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006c	5e		 pop	 esi
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190830:
  00000	8b f4		 mov	 esi, esp
  00002	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??1logic_error@std@@UAE@XZ:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190833
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0001f	83 c4 04	 add	 esp, 4
  00022	3b ec		 cmp	 ebp, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0c		 je	 SHORT $L91713
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4
$L91713:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190847 DD	0ffffffffH
	DD	FLAT:$L190842
$T190845 DD	019930520H
	DD	01H
	DD	FLAT:$T190847
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b f4		 mov	 esi, esp
  00026	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  0004a	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0004d	83 c2 0c	 add	 edx, 12			; 0000000cH
  00050	8b f4		 mov	 esi, esp
  00052	52		 push	 edx
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007a	5e		 pop	 esi
  0007b	83 c4 10	 add	 esp, 16			; 00000010H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190842:
  00000	8b f4		 mov	 esi, esp
  00002	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190845
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
END
