; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\boxgit\PlayBox\CommonLib\common\YL_Base64.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?YL_Base64Encode@@YAHPADPBDH@Z			; YL_Base64Encode
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
;	COMDAT rtc$IMZ
; File d:\boxgit\playbox\commonlib\common\yl_base64.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA
_DATA	SEGMENT
?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA DB 041H	; `YL_Base64Encode'::`2'::tbl
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02bH
	DB	02fH
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
_TEXT	SEGMENT
_to$ = -16						; size = 4
_p$ = -12						; size = 4
_s$ = -8						; size = 4
_i$ = -4						; size = 4
_b64store$ = 8						; size = 4
_str$ = 12						; size = 4
_length$ = 16						; size = 4
?YL_Base64Encode@@YAHPADPBDH@Z PROC NEAR		; YL_Base64Encode

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 8    :   /* Conversion table.  */
; 9    :   static char tbl[64] = {
; 10   :     'A','B','C','D','E','F','G','H',
; 11   :     'I','J','K','L','M','N','O','P',
; 12   :     'Q','R','S','T','U','V','W','X',
; 13   :     'Y','Z','a','b','c','d','e','f',
; 14   :     'g','h','i','j','k','l','m','n',
; 15   :     'o','p','q','r','s','t','u','v',
; 16   :     'w','x','y','z','0','1','2','3',
; 17   :     '4','5','6','7','8','9','+','/'
; 18   :   };
; 19   :   int i;
; 20   :   const unsigned char *s = (const unsigned char *) str;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  0001a	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 21   :   char *p = b64store;

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _b64store$[ebp]
  00020	89 4d f4	 mov	 DWORD PTR _p$[ebp], ecx

; 22   : 
; 23   :   ///* Transform the 3x8 bits to 4x6 bits, as required by base64.  */
; 24   :   //for (i = 0; i < length; i += 3)
; 25   :   //  {
; 26   :   //    *p++ = tbl[s[0] >> 2];
; 27   :   //    *p++ = tbl[((s[0] & 3) << 4) + (s[1] >> 4)];
; 28   :   //    *p++ = tbl[((s[1] & 0xf) << 2) + (s[2] >> 6)];
; 29   :   //    *p++ = tbl[s[2] & 0x3f];
; 30   :   //    s += 3;
; 31   :   //  }
; 32   : 
; 33   :   ///* Pad the result if necessary...  */
; 34   :   //if (i == length + 1)
; 35   :   //  *(p - 1) = '=';
; 36   :   //else if (i == length + 2)
; 37   :   //  *(p - 1) = *(p - 2) = '=';
; 38   : 
; 39   :   int to = length - length % 3;

  00023	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  00026	99		 cdq
  00027	b9 03 00 00 00	 mov	 ecx, 3
  0002c	f7 f9		 idiv	 ecx
  0002e	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  00031	2b c2		 sub	 eax, edx
  00033	89 45 f0	 mov	 DWORD PTR _to$[ebp], eax

; 40   :   /* Transform the 3x8 bits to 4x6 bits, as required by base64.  */
; 41   :   for (i = 0; i < to; i += 3)

  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003d	eb 09		 jmp	 SHORT $L939
$L940:
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00042	83 c1 03	 add	 ecx, 3
  00045	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L939:
  00048	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0004b	3b 55 f0	 cmp	 edx, DWORD PTR _to$[ebp]
  0004e	0f 8d 9d 00 00
	00		 jge	 $L941

; 42   :   {
; 43   : 	  *p++ = tbl[s[0] >> 2];

  00054	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00057	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0005a	c1 f9 02	 sar	 ecx, 2
  0005d	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00060	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[ecx]
  00066	88 02		 mov	 BYTE PTR [edx], al
  00068	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  0006b	83 c1 01	 add	 ecx, 1
  0006e	89 4d f4	 mov	 DWORD PTR _p$[ebp], ecx

; 44   : 	  *p++ = tbl[((s[0] & 3) << 4) + (s[1] >> 4)];

  00071	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00074	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00077	83 e0 03	 and	 eax, 3
  0007a	c1 e0 04	 shl	 eax, 4
  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00080	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00084	c1 fa 04	 sar	 edx, 4
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  0008a	8a 94 10 00 00
	00 00		 mov	 dl, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[eax+edx]
  00091	88 11		 mov	 BYTE PTR [ecx], dl
  00093	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00096	83 c0 01	 add	 eax, 1
  00099	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 45   : 	  *p++ = tbl[((s[1] & 0xf) << 2) + (s[2] >> 6)];

  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0009f	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  000a3	83 e2 0f	 and	 edx, 15			; 0000000fH
  000a6	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000a9	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  000ad	c1 f9 06	 sar	 ecx, 6
  000b0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  000b3	8a 8c 91 00 00
	00 00		 mov	 cl, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[ecx+edx*4]
  000ba	88 08		 mov	 BYTE PTR [eax], cl
  000bc	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  000bf	83 c2 01	 add	 edx, 1
  000c2	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx

; 46   : 	  *p++ = tbl[s[2] & 0x3f];

  000c5	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000c8	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  000cc	83 e1 3f	 and	 ecx, 63			; 0000003fH
  000cf	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  000d2	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[ecx]
  000d8	88 02		 mov	 BYTE PTR [edx], al
  000da	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d f4	 mov	 DWORD PTR _p$[ebp], ecx

; 47   : 	  s += 3;

  000e3	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  000e6	83 c2 03	 add	 edx, 3
  000e9	89 55 f8	 mov	 DWORD PTR _s$[ebp], edx

; 48   :   }

  000ec	e9 4e ff ff ff	 jmp	 $L940
$L941:

; 49   : 
; 50   :   if (length - to == 1)

  000f1	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  000f4	2b 45 f0	 sub	 eax, DWORD PTR _to$[ebp]
  000f7	83 f8 01	 cmp	 eax, 1
  000fa	75 60		 jne	 SHORT $L942

; 51   :   { //! one char.
; 52   : 	  *p++ = tbl[s[0] >> 2];

  000fc	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000ff	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00102	c1 fa 02	 sar	 edx, 2
  00105	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00108	8a 8a 00 00 00
	00		 mov	 cl, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[edx]
  0010e	88 08		 mov	 BYTE PTR [eax], cl
  00110	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00113	83 c2 01	 add	 edx, 1
  00116	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx

; 53   : 	  *p++ = tbl[((s[0] & 3) << 4)];

  00119	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0011c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0011f	83 e1 03	 and	 ecx, 3
  00122	c1 e1 04	 shl	 ecx, 4
  00125	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00128	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[ecx]
  0012e	88 02		 mov	 BYTE PTR [edx], al
  00130	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  00133	83 c1 01	 add	 ecx, 1
  00136	89 4d f4	 mov	 DWORD PTR _p$[ebp], ecx

; 54   : 	  *p++ = '=';

  00139	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0013c	c6 02 3d	 mov	 BYTE PTR [edx], 61	; 0000003dH
  0013f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00142	83 c0 01	 add	 eax, 1
  00145	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 55   : 	  *p++ = '=';

  00148	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  0014b	c6 01 3d	 mov	 BYTE PTR [ecx], 61	; 0000003dH
  0014e	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00151	83 c2 01	 add	 edx, 1
  00154	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx

; 56   :   }
; 57   :   else if (length - to == 2)

  00157	e9 81 00 00 00	 jmp	 $L943
$L942:
  0015c	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  0015f	2b 45 f0	 sub	 eax, DWORD PTR _to$[ebp]
  00162	83 f8 02	 cmp	 eax, 2
  00165	75 76		 jne	 SHORT $L943

; 58   :   {
; 59   : 	  *p++ = tbl[s[0] >> 2];

  00167	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0016a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0016d	c1 fa 02	 sar	 edx, 2
  00170	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00173	8a 8a 00 00 00
	00		 mov	 cl, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[edx]
  00179	88 08		 mov	 BYTE PTR [eax], cl
  0017b	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0017e	83 c2 01	 add	 edx, 1
  00181	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx

; 60   : 	  *p++ = tbl[((s[0] & 3) << 4) + (s[1] >> 4)];

  00184	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00187	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0018a	83 e1 03	 and	 ecx, 3
  0018d	c1 e1 04	 shl	 ecx, 4
  00190	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00193	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00197	c1 f8 04	 sar	 eax, 4
  0019a	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0019d	8a 84 01 00 00
	00 00		 mov	 al, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[ecx+eax]
  001a4	88 02		 mov	 BYTE PTR [edx], al
  001a6	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  001a9	83 c1 01	 add	 ecx, 1
  001ac	89 4d f4	 mov	 DWORD PTR _p$[ebp], ecx

; 61   : 	  *p++ = tbl[((s[1] & 0xf) << 2)];

  001af	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001b2	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  001b6	83 e0 0f	 and	 eax, 15			; 0000000fH
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  001bc	8a 14 85 00 00
	00 00		 mov	 dl, BYTE PTR ?tbl@?1??YL_Base64Encode@@YAHPADPBDH@Z@4PADA[eax*4]
  001c3	88 11		 mov	 BYTE PTR [ecx], dl
  001c5	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001c8	83 c0 01	 add	 eax, 1
  001cb	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 62   : 	  *p++ = '=';

  001ce	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  001d1	c6 01 3d	 mov	 BYTE PTR [ecx], 61	; 0000003dH
  001d4	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  001d7	83 c2 01	 add	 edx, 1
  001da	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
$L943:

; 63   :   }
; 64   : 
; 65   :   /* ...and zero-terminate it.  */
; 66   :   *p = '\0';

  001dd	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 67   : 
; 68   :   return (int)(p - b64store);

  001e3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e6	2b 45 08	 sub	 eax, DWORD PTR _b64store$[ebp]

; 69   : }

  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c3		 ret	 0
?YL_Base64Encode@@YAHPADPBDH@Z ENDP			; YL_Base64Encode
_TEXT	ENDS
PUBLIC	?YL_Base64Decode@@YAHPADPBD@Z			; YL_Base64Decode
;	COMDAT ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA
_DATA	SEGMENT
?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA DW 0ffffH ; `YL_Base64Decode'::`2'::base64_char_to_value
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	03eH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	03fH
	DW	034H
	DW	035H
	DW	036H
	DW	037H
	DW	038H
	DW	039H
	DW	03aH
	DW	03bH
	DW	03cH
	DW	03dH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	00H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	0fH
	DW	010H
	DW	011H
	DW	012H
	DW	013H
	DW	014H
	DW	015H
	DW	016H
	DW	017H
	DW	018H
	DW	019H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	01aH
	DW	01bH
	DW	01cH
	DW	01dH
	DW	01eH
	DW	01fH
	DW	020H
	DW	021H
	DW	022H
	DW	023H
	DW	024H
	DW	025H
	DW	026H
	DW	027H
	DW	028H
	DW	029H
	DW	02aH
	DW	02bH
	DW	02cH
	DW	02dH
	DW	02eH
	DW	02fH
	DW	030H
	DW	031H
	DW	032H
	DW	033H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
_TEXT	SEGMENT
_value$958 = -16					; size = 4
_c$957 = -9						; size = 1
_q$ = -8						; size = 4
_p$ = -4						; size = 4
_to$ = 8						; size = 4
_base64$ = 12						; size = 4
?YL_Base64Decode@@YAHPADPBD@Z PROC NEAR			; YL_Base64Decode

; 83   : {

  001f0	55		 push	 ebp
  001f1	8b ec		 mov	 ebp, esp
  001f3	83 ec 10	 sub	 esp, 16			; 00000010H
  001f6	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  001fb	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  001fe	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00201	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00204	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 84   :   /* Table of base64 values for first 128 characters.  Note that this
; 85   :      assumes ASCII (but so does Wget in other places).  */
; 86   :   static short base64_char_to_value[128] =
; 87   :     {
; 88   :       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,	/*   0-  9 */
; 89   :       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,	/*  10- 19 */
; 90   :       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,	/*  20- 29 */
; 91   :       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,	/*  30- 39 */
; 92   :       -1,  -1,  -1,  62,  -1,  -1,  -1,  63,  52,  53,	/*  40- 49 */
; 93   :       54,  55,  56,  57,  58,  59,  60,  61,  -1,  -1,	/*  50- 59 */
; 94   :       -1,  -1,  -1,  -1,  -1,  0,   1,   2,   3,   4,	/*  60- 69 */
; 95   :       5,   6,   7,   8,   9,   10,  11,  12,  13,  14,	/*  70- 79 */
; 96   :       15,  16,  17,  18,  19,  20,  21,  22,  23,  24,	/*  80- 89 */
; 97   :       25,  -1,  -1,  -1,  -1,  -1,  -1,  26,  27,  28,	/*  90- 99 */
; 98   :       29,  30,  31,  32,  33,  34,  35,  36,  37,  38,	/* 100-109 */
; 99   :       39,  40,  41,  42,  43,  44,  45,  46,  47,  48,	/* 110-119 */
; 100  :       49,  50,  51,  -1,  -1,  -1,  -1,  -1		/* 120-127 */
; 101  :     };
; 102  : 
; 103  :   const char *p = base64;

  00207	8b 45 0c	 mov	 eax, DWORD PTR _base64$[ebp]
  0020a	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 104  :   char *q = to;

  0020d	8b 4d 08	 mov	 ecx, DWORD PTR _to$[ebp]
  00210	89 4d f8	 mov	 DWORD PTR _q$[ebp], ecx
$L955:

; 105  : 
; 106  :   while (1)

  00213	ba 01 00 00 00	 mov	 edx, 1
  00218	85 d2		 test	 edx, edx
  0021a	0f 84 67 02 00
	00		 je	 $L956
$L959:

; 107  :     {
; 108  :       unsigned char c;
; 109  :       unsigned long value;
; 110  : 
; 111  :       /* Process first byte of a quadruplet.  */
; 112  :       NEXT_BASE64_CHAR (c, p);

  00220	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00223	8a 08		 mov	 cl, BYTE PTR [eax]
  00225	88 4d f7	 mov	 BYTE PTR _c$957[ebp], cl
  00228	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0022b	83 c2 01	 add	 edx, 1
  0022e	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx
  00231	0f b6 45 f7	 movzx	 eax, BYTE PTR _c$957[ebp]
  00235	85 c0		 test	 eax, eax
  00237	74 25		 je	 SHORT $L961
  00239	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  0023d	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00243	75 10		 jne	 SHORT $L964
  00245	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  00249	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[edx*2]
  00251	85 c0		 test	 eax, eax
  00253	7d 09		 jge	 SHORT $L961
$L964:
  00255	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  00259	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  0025c	75 c2		 jne	 SHORT $L959
$L961:

; 113  :       if (!c)

  0025e	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  00262	85 d2		 test	 edx, edx
  00264	75 05		 jne	 SHORT $L965

; 114  : 	break;

  00266	e9 1c 02 00 00	 jmp	 $L956
$L965:

; 115  :       if (c == '=')

  0026b	0f b6 45 f7	 movzx	 eax, BYTE PTR _c$957[ebp]
  0026f	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  00272	75 08		 jne	 SHORT $L966

; 116  : 	return -1;		/* illegal '=' while decoding base64 */

  00274	83 c8 ff	 or	 eax, -1
  00277	e9 11 02 00 00	 jmp	 $L949
$L966:

; 117  :       value = base64_char_to_value[c] << 18;

  0027c	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  00280	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[ecx*2]
  00288	c1 e2 12	 shl	 edx, 18			; 00000012H
  0028b	89 55 f0	 mov	 DWORD PTR _value$958[ebp], edx
$L967:

; 118  : 
; 119  :       /* Process scond byte of a quadruplet.  */
; 120  :       NEXT_BASE64_CHAR (c, p);

  0028e	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00291	8a 08		 mov	 cl, BYTE PTR [eax]
  00293	88 4d f7	 mov	 BYTE PTR _c$957[ebp], cl
  00296	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00299	83 c2 01	 add	 edx, 1
  0029c	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx
  0029f	0f b6 45 f7	 movzx	 eax, BYTE PTR _c$957[ebp]
  002a3	85 c0		 test	 eax, eax
  002a5	74 25		 je	 SHORT $L969
  002a7	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  002ab	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  002b1	75 10		 jne	 SHORT $L972
  002b3	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  002b7	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[edx*2]
  002bf	85 c0		 test	 eax, eax
  002c1	7d 09		 jge	 SHORT $L969
$L972:
  002c3	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  002c7	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  002ca	75 c2		 jne	 SHORT $L967
$L969:

; 121  :       if (!c)

  002cc	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  002d0	85 d2		 test	 edx, edx
  002d2	75 08		 jne	 SHORT $L973

; 122  : 	return -1;		/* premature EOF while decoding base64 */

  002d4	83 c8 ff	 or	 eax, -1
  002d7	e9 b1 01 00 00	 jmp	 $L949
$L973:

; 123  :       if (c == '=')

  002dc	0f b6 45 f7	 movzx	 eax, BYTE PTR _c$957[ebp]
  002e0	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  002e3	75 08		 jne	 SHORT $L974

; 124  : 	return -1;		/* illegal `=' while decoding base64 */

  002e5	83 c8 ff	 or	 eax, -1
  002e8	e9 a0 01 00 00	 jmp	 $L949
$L974:

; 125  :       value |= base64_char_to_value[c] << 12;

  002ed	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  002f1	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[ecx*2]
  002f9	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  002fc	0b 55 f0	 or	 edx, DWORD PTR _value$958[ebp]
  002ff	89 55 f0	 mov	 DWORD PTR _value$958[ebp], edx

; 126  :       *q++ = (char)(value >> 16);

  00302	8b 45 f0	 mov	 eax, DWORD PTR _value$958[ebp]
  00305	c1 e8 10	 shr	 eax, 16			; 00000010H
  00308	8b 4d f8	 mov	 ecx, DWORD PTR _q$[ebp]
  0030b	88 01		 mov	 BYTE PTR [ecx], al
  0030d	8b 55 f8	 mov	 edx, DWORD PTR _q$[ebp]
  00310	83 c2 01	 add	 edx, 1
  00313	89 55 f8	 mov	 DWORD PTR _q$[ebp], edx
$L976:

; 127  : 
; 128  :       /* Process third byte of a quadruplet.  */
; 129  :       NEXT_BASE64_CHAR (c, p);

  00316	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00319	8a 08		 mov	 cl, BYTE PTR [eax]
  0031b	88 4d f7	 mov	 BYTE PTR _c$957[ebp], cl
  0031e	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00321	83 c2 01	 add	 edx, 1
  00324	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx
  00327	0f b6 45 f7	 movzx	 eax, BYTE PTR _c$957[ebp]
  0032b	85 c0		 test	 eax, eax
  0032d	74 25		 je	 SHORT $L978
  0032f	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  00333	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00339	75 10		 jne	 SHORT $L981
  0033b	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  0033f	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[edx*2]
  00347	85 c0		 test	 eax, eax
  00349	7d 09		 jge	 SHORT $L978
$L981:
  0034b	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  0034f	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  00352	75 c2		 jne	 SHORT $L976
$L978:

; 130  :       if (!c)

  00354	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  00358	85 d2		 test	 edx, edx
  0035a	75 08		 jne	 SHORT $L982

; 131  : 	return -1;		/* premature EOF while decoding base64 */

  0035c	83 c8 ff	 or	 eax, -1
  0035f	e9 29 01 00 00	 jmp	 $L949
$L982:

; 132  : 
; 133  :       if (c == '=')

  00364	0f b6 45 f7	 movzx	 eax, BYTE PTR _c$957[ebp]
  00368	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  0036b	75 64		 jne	 SHORT $L983
$L984:

; 134  : 	{
; 135  : 	  NEXT_BASE64_CHAR (c, p);

  0036d	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00370	8a 11		 mov	 dl, BYTE PTR [ecx]
  00372	88 55 f7	 mov	 BYTE PTR _c$957[ebp], dl
  00375	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00378	83 c0 01	 add	 eax, 1
  0037b	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
  0037e	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  00382	85 c9		 test	 ecx, ecx
  00384	74 25		 je	 SHORT $L986
  00386	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  0038a	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00390	75 10		 jne	 SHORT $L989
  00392	0f b6 45 f7	 movzx	 eax, BYTE PTR _c$957[ebp]
  00396	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[eax*2]
  0039e	85 c9		 test	 ecx, ecx
  003a0	7d 09		 jge	 SHORT $L986
$L989:
  003a2	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  003a6	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  003a9	75 c2		 jne	 SHORT $L984
$L986:

; 136  : 	  if (!c)

  003ab	0f b6 45 f7	 movzx	 eax, BYTE PTR _c$957[ebp]
  003af	85 c0		 test	 eax, eax
  003b1	75 08		 jne	 SHORT $L990

; 137  : 	    return -1;		/* premature EOF while decoding base64 */

  003b3	83 c8 ff	 or	 eax, -1
  003b6	e9 d2 00 00 00	 jmp	 $L949
$L990:

; 138  : 	  if (c != '=')

  003bb	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  003bf	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  003c2	74 08		 je	 SHORT $L991

; 139  : 	    return -1;		/* padding `=' expected but not found */

  003c4	83 c8 ff	 or	 eax, -1
  003c7	e9 c1 00 00 00	 jmp	 $L949
$L991:

; 140  : 	  continue;

  003cc	e9 42 fe ff ff	 jmp	 $L955
$L983:

; 141  : 	}
; 142  : 
; 143  :       value |= base64_char_to_value[c] << 6;

  003d1	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  003d5	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[edx*2]
  003dd	c1 e0 06	 shl	 eax, 6
  003e0	0b 45 f0	 or	 eax, DWORD PTR _value$958[ebp]
  003e3	89 45 f0	 mov	 DWORD PTR _value$958[ebp], eax

; 144  :       *q++ = (char)(0xff & value >> 8);

  003e6	8b 4d f0	 mov	 ecx, DWORD PTR _value$958[ebp]
  003e9	c1 e9 08	 shr	 ecx, 8
  003ec	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003f2	8b 55 f8	 mov	 edx, DWORD PTR _q$[ebp]
  003f5	88 0a		 mov	 BYTE PTR [edx], cl
  003f7	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  003fa	83 c0 01	 add	 eax, 1
  003fd	89 45 f8	 mov	 DWORD PTR _q$[ebp], eax
$L993:

; 145  : 
; 146  :       /* Process fourth byte of a quadruplet.  */
; 147  :       NEXT_BASE64_CHAR (c, p);

  00400	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00403	8a 11		 mov	 dl, BYTE PTR [ecx]
  00405	88 55 f7	 mov	 BYTE PTR _c$957[ebp], dl
  00408	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0040b	83 c0 01	 add	 eax, 1
  0040e	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
  00411	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  00415	85 c9		 test	 ecx, ecx
  00417	74 25		 je	 SHORT $L995
  00419	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  0041d	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00423	75 10		 jne	 SHORT $L998
  00425	0f b6 45 f7	 movzx	 eax, BYTE PTR _c$957[ebp]
  00429	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[eax*2]
  00431	85 c9		 test	 ecx, ecx
  00433	7d 09		 jge	 SHORT $L995
$L998:
  00435	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  00439	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  0043c	75 c2		 jne	 SHORT $L993
$L995:

; 148  :       if (!c)

  0043e	0f b6 45 f7	 movzx	 eax, BYTE PTR _c$957[ebp]
  00442	85 c0		 test	 eax, eax
  00444	75 05		 jne	 SHORT $L999

; 149  : 	return -1;		/* premature EOF while decoding base64 */

  00446	83 c8 ff	 or	 eax, -1
  00449	eb 42		 jmp	 SHORT $L949
$L999:

; 150  :       if (c == '=')

  0044b	0f b6 4d f7	 movzx	 ecx, BYTE PTR _c$957[ebp]
  0044f	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  00452	75 05		 jne	 SHORT $L1000

; 151  : 	continue;

  00454	e9 ba fd ff ff	 jmp	 $L955
$L1000:

; 152  : 
; 153  :       value |= base64_char_to_value[c];

  00459	0f b6 55 f7	 movzx	 edx, BYTE PTR _c$957[ebp]
  0045d	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?base64_char_to_value@?1??YL_Base64Decode@@YAHPADPBD@Z@4PAFA[edx*2]
  00465	0b 45 f0	 or	 eax, DWORD PTR _value$958[ebp]
  00468	89 45 f0	 mov	 DWORD PTR _value$958[ebp], eax

; 154  :       *q++ = (char)(0xff & value);

  0046b	8b 4d f0	 mov	 ecx, DWORD PTR _value$958[ebp]
  0046e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00474	8b 55 f8	 mov	 edx, DWORD PTR _q$[ebp]
  00477	88 0a		 mov	 BYTE PTR [edx], cl
  00479	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  0047c	83 c0 01	 add	 eax, 1
  0047f	89 45 f8	 mov	 DWORD PTR _q$[ebp], eax

; 155  :     }

  00482	e9 8c fd ff ff	 jmp	 $L955
$L956:

; 156  : 
; 157  :   return (int)(q - to);

  00487	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  0048a	2b 45 08	 sub	 eax, DWORD PTR _to$[ebp]
$L949:

; 158  : }

  0048d	8b e5		 mov	 esp, ebp
  0048f	5d		 pop	 ebp
  00490	c3		 ret	 0
?YL_Base64Decode@@YAHPADPBD@Z ENDP			; YL_Base64Decode
_TEXT	ENDS
PUBLIC	?YL_Base64Encode@@YAHPADPBDH1@Z			; YL_Base64Encode
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	_memcpy:NEAR
EXTRN	_strlen:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T1060 = -28						; size = 4
$T1059 = -24						; size = 4
_ret$ = -20						; size = 4
_j$1018 = -16						; size = 4
_i$1014 = -12						; size = 4
___len$ = -8						; size = 4
___tmp$ = -4						; size = 4
_b64store$ = 8						; size = 4
_str$ = 12						; size = 4
_length$ = 16						; size = 4
_xor_string$ = 20					; size = 4
?YL_Base64Encode@@YAHPADPBDH1@Z PROC NEAR		; YL_Base64Encode

; 161  : {

  004a0	55		 push	 ebp
  004a1	8b ec		 mov	 ebp, esp
  004a3	83 ec 1c	 sub	 esp, 28			; 0000001cH
  004a6	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  004ab	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  004ae	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  004b1	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  004b4	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  004b7	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  004ba	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  004bd	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 162  : 	char *__tmp = new char[length];

  004c0	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  004c3	50		 push	 eax
  004c4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  004c9	83 c4 04	 add	 esp, 4
  004cc	89 45 e8	 mov	 DWORD PTR $T1059[ebp], eax
  004cf	8b 4d e8	 mov	 ecx, DWORD PTR $T1059[ebp]
  004d2	89 4d fc	 mov	 DWORD PTR ___tmp$[ebp], ecx

; 163  : 	memcpy(__tmp, str, length);

  004d5	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp]
  004d8	52		 push	 edx
  004d9	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  004dc	50		 push	 eax
  004dd	8b 4d fc	 mov	 ecx, DWORD PTR ___tmp$[ebp]
  004e0	51		 push	 ecx
  004e1	e8 00 00 00 00	 call	 _memcpy
  004e6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 164  : 
; 165  : 	int __len = (int)strlen(xor_string);

  004e9	8b 55 14	 mov	 edx, DWORD PTR _xor_string$[ebp]
  004ec	52		 push	 edx
  004ed	e8 00 00 00 00	 call	 _strlen
  004f2	83 c4 04	 add	 esp, 4
  004f5	89 45 f8	 mov	 DWORD PTR ___len$[ebp], eax

; 166  : 
; 167  : 	for (int i = 0; i < length; )

  004f8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1014[ebp], 0
$L1016:
  004ff	8b 45 f4	 mov	 eax, DWORD PTR _i$1014[ebp]
  00502	3b 45 10	 cmp	 eax, DWORD PTR _length$[ebp]
  00505	7d 4b		 jge	 SHORT $L1017

; 168  : 	{
; 169  : 		for (int j = 0; j < __len && i < length; j++)

  00507	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _j$1018[ebp], 0
  0050e	eb 09		 jmp	 SHORT $L1019
$L1020:
  00510	8b 4d f0	 mov	 ecx, DWORD PTR _j$1018[ebp]
  00513	83 c1 01	 add	 ecx, 1
  00516	89 4d f0	 mov	 DWORD PTR _j$1018[ebp], ecx
$L1019:
  00519	8b 55 f0	 mov	 edx, DWORD PTR _j$1018[ebp]
  0051c	3b 55 f8	 cmp	 edx, DWORD PTR ___len$[ebp]
  0051f	7d 2f		 jge	 SHORT $L1021
  00521	8b 45 f4	 mov	 eax, DWORD PTR _i$1014[ebp]
  00524	3b 45 10	 cmp	 eax, DWORD PTR _length$[ebp]
  00527	7d 27		 jge	 SHORT $L1021

; 170  : 		{
; 171  : 			__tmp[i++] ^= xor_string[j];

  00529	8b 4d 14	 mov	 ecx, DWORD PTR _xor_string$[ebp]
  0052c	03 4d f0	 add	 ecx, DWORD PTR _j$1018[ebp]
  0052f	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00532	8b 45 fc	 mov	 eax, DWORD PTR ___tmp$[ebp]
  00535	03 45 f4	 add	 eax, DWORD PTR _i$1014[ebp]
  00538	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0053b	33 ca		 xor	 ecx, edx
  0053d	8b 55 fc	 mov	 edx, DWORD PTR ___tmp$[ebp]
  00540	03 55 f4	 add	 edx, DWORD PTR _i$1014[ebp]
  00543	88 0a		 mov	 BYTE PTR [edx], cl
  00545	8b 45 f4	 mov	 eax, DWORD PTR _i$1014[ebp]
  00548	83 c0 01	 add	 eax, 1
  0054b	89 45 f4	 mov	 DWORD PTR _i$1014[ebp], eax

; 172  : 		}

  0054e	eb c0		 jmp	 SHORT $L1020
$L1021:

; 173  : 	}

  00550	eb ad		 jmp	 SHORT $L1016
$L1017:

; 174  : 
; 175  : 	int ret = YL_Base64Encode(b64store, __tmp, length);

  00552	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp]
  00555	51		 push	 ecx
  00556	8b 55 fc	 mov	 edx, DWORD PTR ___tmp$[ebp]
  00559	52		 push	 edx
  0055a	8b 45 08	 mov	 eax, DWORD PTR _b64store$[ebp]
  0055d	50		 push	 eax
  0055e	e8 00 00 00 00	 call	 ?YL_Base64Encode@@YAHPADPBDH@Z ; YL_Base64Encode
  00563	83 c4 0c	 add	 esp, 12			; 0000000cH
  00566	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 176  : 	delete []__tmp;

  00569	8b 4d fc	 mov	 ecx, DWORD PTR ___tmp$[ebp]
  0056c	89 4d e4	 mov	 DWORD PTR $T1060[ebp], ecx
  0056f	8b 55 e4	 mov	 edx, DWORD PTR $T1060[ebp]
  00572	52		 push	 edx
  00573	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00578	83 c4 04	 add	 esp, 4

; 177  : 
; 178  : 	return ret;

  0057b	8b 45 ec	 mov	 eax, DWORD PTR _ret$[ebp]

; 179  : }

  0057e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00581	3b ec		 cmp	 ebp, esp
  00583	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00588	8b e5		 mov	 esp, ebp
  0058a	5d		 pop	 ebp
  0058b	c3		 ret	 0
?YL_Base64Encode@@YAHPADPBDH1@Z ENDP			; YL_Base64Encode
_TEXT	ENDS
PUBLIC	?YL_Base64Decode@@YAHPADPBD1@Z			; YL_Base64Decode
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_j$1037 = -16						; size = 4
_i$1033 = -12						; size = 4
___len$ = -8						; size = 4
_ret$ = -4						; size = 4
_to$ = 8						; size = 4
_base64$ = 12						; size = 4
_xor_string$ = 16					; size = 4
?YL_Base64Decode@@YAHPADPBD1@Z PROC NEAR		; YL_Base64Decode

; 182  : {

  00590	55		 push	 ebp
  00591	8b ec		 mov	 ebp, esp
  00593	83 ec 10	 sub	 esp, 16			; 00000010H
  00596	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0059b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0059e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  005a1	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  005a4	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 183  : 	int ret = YL_Base64Decode(to, base64);

  005a7	8b 45 0c	 mov	 eax, DWORD PTR _base64$[ebp]
  005aa	50		 push	 eax
  005ab	8b 4d 08	 mov	 ecx, DWORD PTR _to$[ebp]
  005ae	51		 push	 ecx
  005af	e8 00 00 00 00	 call	 ?YL_Base64Decode@@YAHPADPBD@Z ; YL_Base64Decode
  005b4	83 c4 08	 add	 esp, 8
  005b7	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 184  : 	if (ret == -1)

  005ba	83 7d fc ff	 cmp	 DWORD PTR _ret$[ebp], -1
  005be	75 05		 jne	 SHORT $L1030

; 185  : 		return -1;

  005c0	83 c8 ff	 or	 eax, -1
  005c3	eb 6c		 jmp	 SHORT $L1028
$L1030:

; 186  : 
; 187  : 	int __len = (int)strlen(xor_string);

  005c5	8b 55 10	 mov	 edx, DWORD PTR _xor_string$[ebp]
  005c8	52		 push	 edx
  005c9	e8 00 00 00 00	 call	 _strlen
  005ce	83 c4 04	 add	 esp, 4
  005d1	89 45 f8	 mov	 DWORD PTR ___len$[ebp], eax

; 188  : 
; 189  : 	for (int i = 0; i < ret; )

  005d4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1033[ebp], 0
$L1035:
  005db	8b 45 f4	 mov	 eax, DWORD PTR _i$1033[ebp]
  005de	3b 45 fc	 cmp	 eax, DWORD PTR _ret$[ebp]
  005e1	7d 4b		 jge	 SHORT $L1036

; 190  : 	{
; 191  : 		for (int j = 0; j < __len && i < ret; j++)

  005e3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _j$1037[ebp], 0
  005ea	eb 09		 jmp	 SHORT $L1038
$L1039:
  005ec	8b 4d f0	 mov	 ecx, DWORD PTR _j$1037[ebp]
  005ef	83 c1 01	 add	 ecx, 1
  005f2	89 4d f0	 mov	 DWORD PTR _j$1037[ebp], ecx
$L1038:
  005f5	8b 55 f0	 mov	 edx, DWORD PTR _j$1037[ebp]
  005f8	3b 55 f8	 cmp	 edx, DWORD PTR ___len$[ebp]
  005fb	7d 2f		 jge	 SHORT $L1040
  005fd	8b 45 f4	 mov	 eax, DWORD PTR _i$1033[ebp]
  00600	3b 45 fc	 cmp	 eax, DWORD PTR _ret$[ebp]
  00603	7d 27		 jge	 SHORT $L1040

; 192  : 		{
; 193  : 			to[i++] ^= xor_string[j];

  00605	8b 4d 10	 mov	 ecx, DWORD PTR _xor_string$[ebp]
  00608	03 4d f0	 add	 ecx, DWORD PTR _j$1037[ebp]
  0060b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0060e	8b 45 08	 mov	 eax, DWORD PTR _to$[ebp]
  00611	03 45 f4	 add	 eax, DWORD PTR _i$1033[ebp]
  00614	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00617	33 ca		 xor	 ecx, edx
  00619	8b 55 08	 mov	 edx, DWORD PTR _to$[ebp]
  0061c	03 55 f4	 add	 edx, DWORD PTR _i$1033[ebp]
  0061f	88 0a		 mov	 BYTE PTR [edx], cl
  00621	8b 45 f4	 mov	 eax, DWORD PTR _i$1033[ebp]
  00624	83 c0 01	 add	 eax, 1
  00627	89 45 f4	 mov	 DWORD PTR _i$1033[ebp], eax

; 194  : 		}

  0062a	eb c0		 jmp	 SHORT $L1039
$L1040:

; 195  : 	}

  0062c	eb ad		 jmp	 SHORT $L1035
$L1036:

; 196  : 
; 197  : 	return ret;

  0062e	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$L1028:

; 198  : }

  00631	83 c4 10	 add	 esp, 16			; 00000010H
  00634	3b ec		 cmp	 ebp, esp
  00636	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0063b	8b e5		 mov	 esp, ebp
  0063d	5d		 pop	 ebp
  0063e	c3		 ret	 0
?YL_Base64Decode@@YAHPADPBD1@Z ENDP			; YL_Base64Decode
_TEXT	ENDS
END
