; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\Gui\Bitmap\cdib.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT _$E5
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??_GCDib@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CDib@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CDib@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CDib@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCDib@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CDib@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_C@_0EN@CBMLGOH@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FG@LDNDNCJM@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA5PAVCUserException@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCObject@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCException@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCSimpleException@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCUserException@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0PAX@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0PAVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0PAVCSimpleException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0PAVCUserException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI5PAVCUserException@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0PAVCException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FJ@DMHPDOJC@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FI@NHHJANPC@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CDib@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?classCDib@CDib@@2UCRuntimeClass@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _CLSID_AVIFile
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _CLSID_AVISimpleUnMarshal
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IID_IAVIEditStream
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IID_IGetFrame
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IID_IAVIStreaming
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IID_IAVIStream
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IID_IAVIFile
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?classCDib@CDib@@2UCRuntimeClass@@A		; CDib::classCDib
PUBLIC	?CreateObject@CDib@@SGPAVCObject@@XZ		; CDib::CreateObject
PUBLIC	_IID_IAVIFile
PUBLIC	_IID_IAVIStream
PUBLIC	_IID_IAVIStreaming
PUBLIC	_IID_IGetFrame
PUBLIC	_IID_IAVIEditStream
PUBLIC	_CLSID_AVISimpleUnMarshal
PUBLIC	_CLSID_AVIFile
EXTRN	?GetThisClass@CObject@@SGPAUCRuntimeClass@@XZ:NEAR ; CObject::GetThisClass
_BSS	SEGMENT
_g_count DD	01H DUP (?)
_BSS	ENDS
;	COMDAT _IID_IAVIFile
CONST	SEGMENT
_IID_IAVIFile DD 020020H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _IID_IAVIStream
CONST	SEGMENT
_IID_IAVIStream DD 020021H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _IID_IAVIStreaming
CONST	SEGMENT
_IID_IAVIStreaming DD 020022H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _IID_IGetFrame
CONST	SEGMENT
_IID_IGetFrame DD 020023H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _IID_IAVIEditStream
CONST	SEGMENT
_IID_IAVIEditStream DD 020024H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _CLSID_AVISimpleUnMarshal
CONST	SEGMENT
_CLSID_AVISimpleUnMarshal DD 020009H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _CLSID_AVIFile
CONST	SEGMENT
_CLSID_AVIFile DD 020000H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
_DATA	SEGMENT
_THIS_FILE DB	'.\src\Gui\Bitmap\cdib.cpp', 00H
_DATA	ENDS
CONST	SEGMENT
$SG192311 DB	'CDib', 00H
CONST	ENDS
;	COMDAT ?classCDib@CDib@@2UCRuntimeClass@@A
_DATA	SEGMENT
?classCDib@CDib@@2UCRuntimeClass@@A DD FLAT:$SG192311	; CDib::classCDib
	DD	038H
	DD	00H
	DD	FLAT:?CreateObject@CDib@@SGPAVCObject@@XZ
	DD	FLAT:?GetThisClass@CObject@@SGPAUCRuntimeClass@@XZ
	DD	00H
	DD	FLAT:?_init_CDib@@3UAFX_CLASSINIT@@A
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG192429 DB	'Invalid bitmap file', 00H
$SG192465 DB	'Invalid bitmap file', 00H
$SG192488 DB	'Invalid bitmap file', 00H
$SG192541 DB	'AttachMemory error', 00H
	ORG $+1
$SG192626 DB	'.\src\Gui\Bitmap\cdib.cpp', 00H
	ORG $+2
$SG192627 DB	'CDib::MakePalette -- m_nColorTableEntries = %d', 0aH, 00H
$SG192662 DB	'.\src\Gui\Bitmap\cdib.cpp', 00H
	ORG $+2
$SG192663 DB	'Compress: original palette size = %d', 0aH, 00H
	ORG $+2
$SG192687 DB	'Unable to compress this DIB', 00H
$SG192690 DB	'Driver can''t do compression', 00H
$SG192706 DB	'.\src\Gui\Bitmap\cdib.cpp', 00H
	ORG $+2
$SG192707 DB	'dib successfully created - height = %d', 0aH, 00H
$SG192709 DB	'.\src\Gui\Bitmap\cdib.cpp', 00H
	ORG $+2
$SG192710 DB	'Compress: new palette size = %d', 0aH, 00H
	ORG $+3
$SG192757 DB	'Read error', 00H
	ORG $+1
$SG192803 DB	'ReadSection error', 00H
	ORG $+2
$SG192822 DB	'write error', 00H
$SG192831 DB	'.\src\Gui\Bitmap\cdib.cpp', 00H
	ORG $+2
$SG192832 DB	'CDib::Serialize -- pos = %d', 0aH, 00H
	ORG $+3
$SG192835 DB	'.\src\Gui\Bitmap\cdib.cpp', 00H
	ORG $+2
$SG192836 DB	'CDib::Serialize -- pos = %d', 0aH, 00H
	ORG $+3
$SG192863 DB	'.\src\Gui\Bitmap\cdib.cpp', 00H
	ORG $+2
$SG192864 DB	'Not a valid Windows bitmap -- probably an OS/2 bitmap', 0aH
	DB	00H
CONST	ENDS
PUBLIC	??0CDib@@IAE@XZ					; CDib::CDib
EXTRN	??2CObject@@SGPAXIPBDH@Z:NEAR			; CObject::operator new
EXTRN	??3CObject@@SGXPAXPBDH@Z:NEAR			; CObject::operator delete
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__except_list:DWORD
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT rtc$IMZ
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\bitmap\cdib.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
xdata$x	SEGMENT
$T193416 DD	0ffffffffH
	DD	FLAT:$L193408
$T193412 DD	019930520H
	DD	01H
	DD	FLAT:$T193416
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T193399 = -20						; size = 4
$T193398 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?CreateObject@CDib@@SGPAVCObject@@XZ PROC NEAR		; CDib::CreateObject

; 13   : IMPLEMENT_SERIAL(CDib, CObject, 0);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateObject@CDib@@SGPAVCObject@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  00022	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00029	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00030	6a 0d		 push	 13			; 0000000dH
  00032	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00037	6a 38		 push	 56			; 00000038H
  00039	e8 00 00 00 00	 call	 ??2CObject@@SGPAXIPBDH@Z ; CObject::operator new
  0003e	89 45 ec	 mov	 DWORD PTR $T193399[ebp], eax
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	83 7d ec 00	 cmp	 DWORD PTR $T193399[ebp], 0
  0004c	74 0d		 je	 SHORT $L193400
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR $T193399[ebp]
  00051	e8 00 00 00 00	 call	 ??0CDib@@IAE@XZ		; CDib::CDib
  00056	89 45 e8	 mov	 DWORD PTR tv75[ebp], eax
  00059	eb 07		 jmp	 SHORT $L193401
$L193400:
  0005b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$L193401:
  00062	8b 45 e8	 mov	 eax, DWORD PTR tv75[ebp]
  00065	89 45 f0	 mov	 DWORD PTR $T193398[ebp], eax
  00068	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006f	8b 45 f0	 mov	 eax, DWORD PTR $T193398[ebp]
  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007c	83 c4 18	 add	 esp, 24			; 00000018H
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L193408:
  00000	6a 0d		 push	 13			; 0000000dH
  00002	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00007	8b 45 ec	 mov	 eax, DWORD PTR $T193399[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAXPBDH@Z ; CObject::operator delete
  00010	c3		 ret	 0
__ehhandler$?CreateObject@CDib@@SGPAVCObject@@XZ:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193412
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreateObject@CDib@@SGPAVCObject@@XZ ENDP		; CDib::CreateObject
PUBLIC	?GetThisClass@CDib@@SGPAUCRuntimeClass@@XZ	; CDib::GetThisClass
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
?GetThisClass@CDib@@SGPAUCRuntimeClass@@XZ PROC NEAR	; CDib::GetThisClass

; 13   : IMPLEMENT_SERIAL(CDib, CObject, 0);

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp
  00093	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?classCDib@CDib@@2UCRuntimeClass@@A ; CDib::classCDib
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?GetThisClass@CDib@@SGPAUCRuntimeClass@@XZ ENDP		; CDib::GetThisClass
_TEXT	ENDS
PUBLIC	?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ	; CDib::GetRuntimeClass
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ PROC NEAR ; CDib::GetRuntimeClass
; _this$ = ecx

; 13   : IMPLEMENT_SERIAL(CDib, CObject, 0);

  000a0	55		 push	 ebp
  000a1	8b ec		 mov	 ebp, esp
  000a3	51		 push	 ecx
  000a4	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  000ab	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  000ae	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?classCDib@CDib@@2UCRuntimeClass@@A ; CDib::classCDib
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ ENDP	; CDib::GetRuntimeClass
_TEXT	ENDS
PUBLIC	??5@YGAAVCArchive@@AAV0@AAPAVCDib@@@Z		; operator>>
EXTRN	?ReadObject@CArchive@@QAEPAVCObject@@PBUCRuntimeClass@@@Z:NEAR ; CArchive::ReadObject
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pOb$ = 12						; size = 4
??5@YGAAVCArchive@@AAV0@AAPAVCDib@@@Z PROC NEAR		; operator>>

; 13   : IMPLEMENT_SERIAL(CDib, CObject, 0);

  000c0	55		 push	 ebp
  000c1	8b ec		 mov	 ebp, esp
  000c3	e8 00 00 00 00	 call	 ?GetThisClass@CDib@@SGPAUCRuntimeClass@@XZ ; CDib::GetThisClass
  000c8	50		 push	 eax
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  000cc	e8 00 00 00 00	 call	 ?ReadObject@CArchive@@QAEPAVCObject@@PBUCRuntimeClass@@@Z ; CArchive::ReadObject
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _pOb$[ebp]
  000d4	89 01		 mov	 DWORD PTR [ecx], eax
  000d6	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  000d9	3b ec		 cmp	 ebp, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e0	5d		 pop	 ebp
  000e1	c2 08 00	 ret	 8
??5@YGAAVCArchive@@AAV0@AAPAVCDib@@@Z ENDP		; operator>>
_TEXT	ENDS
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	?Empty@CDib@@QAEXXZ				; CDib::Empty
PUBLIC	?Serialize@CDib@@MAEXAAVCArchive@@@Z		; CDib::Serialize
PUBLIC	??_7CDib@@6B@					; CDib::`vftable'
PUBLIC	??_GCDib@@MAEPAXI@Z				; CDib::`scalar deleting destructor'
PUBLIC	??_R4CDib@@6B@					; CDib::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDib@@@8				; CDib `RTTI Type Descriptor'
PUBLIC	??_R3CDib@@8					; CDib::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDib@@8					; CDib::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CDib@@8				; CDib::`RTTI Base Class Descriptor at (0,-1,0,0)'
EXTRN	??_ECDib@@MAEPAXI@Z:NEAR			; CDib::`vector deleting destructor'
EXTRN	??1CObject@@UAE@XZ:NEAR				; CObject::~CObject
EXTRN	??0CObject@@IAE@XZ:NEAR				; CObject::CObject
EXTRN	?AssertValid@CObject@@UBEXXZ:NEAR		; CObject::AssertValid
EXTRN	?Dump@CObject@@UBEXAAVCDumpContext@@@Z:NEAR	; CObject::Dump
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
xdata$x	SEGMENT
$T193426 DD	0ffffffffH
	DD	FLAT:$L193422
$T193424 DD	019930520H
	DD	01H
	DD	FLAT:$T193426
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CDib@@6B@
CONST	SEGMENT
??_7CDib@@6B@ DD FLAT:??_R4CDib@@6B@			; CDib::`vftable'
	DD	FLAT:?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECDib@@MAEPAXI@Z
	DD	FLAT:?Serialize@CDib@@MAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CDib@@6B@
rdata$r	SEGMENT
??_R4CDib@@6B@ DD 00H					; CDib::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDib@@@8
	DD	FLAT:??_R3CDib@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDib@@@8
_DATA	SEGMENT
??_R0?AVCDib@@@8 DD FLAT:??_7type_info@@6B@		; CDib `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDib@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CDib@@8
rdata$r	SEGMENT
??_R3CDib@@8 DD	00H					; CDib::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CDib@@8
rdata$r	ENDS
;	COMDAT ??_R2CDib@@8
rdata$r	SEGMENT
??_R2CDib@@8 DD	FLAT:??_R1A@?0A@A@CDib@@8		; CDib::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDib@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CDib@@8 DD FLAT:??_R0?AVCDib@@@8		; CDib::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CDib@@IAE@XZ PROC NEAR				; CDib::CDib
; _this$ = ecx

; 18   : {

  000f0	55		 push	 ebp
  000f1	8b ec		 mov	 ebp, esp
  000f3	6a ff		 push	 -1
  000f5	68 00 00 00 00	 push	 __ehhandler$??0CDib@@IAE@XZ
  000fa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00100	50		 push	 eax
  00101	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00108	51		 push	 ecx
  00109	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00110	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00113	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00116	e8 00 00 00 00	 call	 ??0CObject@@IAE@XZ	; CObject::CObject
  0011b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00122	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00125	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDib@@6B@

; 19   : 	m_hFile = NULL;

  0012b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 20   : 	m_hBitmap = NULL;

  00135	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00138	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 21   : 	m_hPalette = NULL;

  0013f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00142	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 22   : 	m_nBmihAlloc = m_nImageAlloc = noAlloc;

  00149	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  00153	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00156	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 23   : 	m_lpvFile = NULL;

  0015d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00160	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 24   : 	Empty();

  00167	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 25   : }

  0016f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00176	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00179	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00183	83 c4 10	 add	 esp, 16			; 00000010H
  00186	3b ec		 cmp	 ebp, esp
  00188	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L193422:
  0001b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1CObject@@UAE@XZ	; CObject::~CObject
__ehhandler$??0CDib@@IAE@XZ:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193424
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CDib@@IAE@XZ ENDP					; CDib::CDib
PUBLIC	??1CDib@@MAE@XZ					; CDib::~CDib
EXTRN	??3CObject@@SGXPAX@Z:NEAR			; CObject::operator delete
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GCDib@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCDib@@MAEPAXI@Z PROC NEAR				; CDib::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1CDib@@MAE@XZ		; CDib::~CDib
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 09		 je	 SHORT $L192335
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L192335:
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??_GCDib@@MAEPAXI@Z ENDP				; CDib::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CDib@@IAE@VCSize@@H@Z			; CDib::CDib
PUBLIC	?ComputePaletteSize@CDib@@AAEXH@Z		; CDib::ComputePaletteSize
PUBLIC	?ComputeMetrics@CDib@@AAEXXZ			; CDib::ComputeMetrics
EXTRN	??_U@YAPAXIPBDH@Z:NEAR				; operator new[]
EXTRN	_memset:NEAR
xdata$x	SEGMENT
$T193434 DD	0ffffffffH
	DD	FLAT:$L193430
$T193432 DD	019930520H
	DD	01H
	DD	FLAT:$T193434
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T193429 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_size$ = 8						; size = 8
_nBitCount$ = 16					; size = 4
??0CDib@@IAE@VCSize@@H@Z PROC NEAR			; CDib::CDib
; _this$ = ecx

; 28   : {

  001a0	55		 push	 ebp
  001a1	8b ec		 mov	 ebp, esp
  001a3	6a ff		 push	 -1
  001a5	68 00 00 00 00	 push	 __ehhandler$??0CDib@@IAE@VCSize@@H@Z
  001aa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  001b0	50		 push	 eax
  001b1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  001b8	83 ec 08	 sub	 esp, 8
  001bb	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  001c2	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  001c9	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  001cc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001cf	e8 00 00 00 00	 call	 ??0CObject@@IAE@XZ	; CObject::CObject
  001d4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  001db	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001de	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDib@@6B@

; 29   : 	m_hFile = NULL;

  001e4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e7	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 30   : 	m_hBitmap = NULL;

  001ee	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001f1	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 31   : 	m_hPalette = NULL;

  001f8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001fb	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 32   : 	m_nBmihAlloc = m_nImageAlloc = noAlloc;

  00202	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00205	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  0020c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0020f	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 33   : 	Empty();

  00216	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00219	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 34   : 	ComputePaletteSize(nBitCount);

  0021e	8b 45 10	 mov	 eax, DWORD PTR _nBitCount$[ebp]
  00221	50		 push	 eax
  00222	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00225	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 35   : 	m_lpBMIH = (LPBITMAPINFOHEADER) new 
; 36   : 		char[sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * m_nColorTableEntries];

  0022a	6a 23		 push	 35			; 00000023H
  0022c	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00231	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00237	8d 04 95 28 00
	00 00		 lea	 eax, DWORD PTR [edx*4+40]
  0023e	50		 push	 eax
  0023f	e8 00 00 00 00	 call	 ??_U@YAPAXIPBDH@Z	; operator new[]
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH
  00247	89 45 ec	 mov	 DWORD PTR $T193429[ebp], eax
  0024a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0024d	8b 55 ec	 mov	 edx, DWORD PTR $T193429[ebp]
  00250	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 37   : 	m_nBmihAlloc = crtAlloc;

  00253	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00256	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 38   : 	m_lpBMIH->biSize = sizeof(BITMAPINFOHEADER);

  0025d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00260	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00263	c7 02 28 00 00
	00		 mov	 DWORD PTR [edx], 40	; 00000028H

; 39   : 	m_lpBMIH->biWidth = size.cx;

  00269	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0026c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0026f	8b 55 08	 mov	 edx, DWORD PTR _size$[ebp]
  00272	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 40   : 	m_lpBMIH->biHeight = size.cy;

  00275	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00278	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0027b	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp+4]
  0027e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 41   : 	m_lpBMIH->biPlanes = 1;

  00281	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00284	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00287	66 c7 41 0c 01
	00		 mov	 WORD PTR [ecx+12], 1

; 42   : 	m_lpBMIH->biBitCount = nBitCount;

  0028d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00290	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00293	66 8b 4d 10	 mov	 cx, WORD PTR _nBitCount$[ebp]
  00297	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 43   : 	m_lpBMIH->biCompression = BI_RGB;

  0029b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0029e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002a1	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 44   : 	m_lpBMIH->biSizeImage = 0;

  002a8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002ae	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 45   : 	m_lpBMIH->biXPelsPerMeter = 0;

  002b5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002b8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002bb	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 46   : 	m_lpBMIH->biYPelsPerMeter = 0;

  002c2	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  002c5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002c8	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 47   : 	m_lpBMIH->biClrUsed = m_nColorTableEntries;

  002cf	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002d2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002d5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002d8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002db	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 48   : 	m_lpBMIH->biClrImportant = m_nColorTableEntries;

  002de	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  002e1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002e4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002e7	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  002ea	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 49   : 	ComputeMetrics();

  002ed	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002f0	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 50   : 	memset(m_lpvColorTable, 0, sizeof(RGBQUAD) * m_nColorTableEntries);

  002f5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002f8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002fb	c1 e1 02	 shl	 ecx, 2
  002fe	51		 push	 ecx
  002ff	6a 00		 push	 0
  00301	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00304	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00307	50		 push	 eax
  00308	e8 00 00 00 00	 call	 _memset
  0030d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 	m_lpImage = NULL;  // no data yet

  00310	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00313	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 52   : }

  0031a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00321	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00324	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00327	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0032e	83 c4 14	 add	 esp, 20			; 00000014H
  00331	3b ec		 cmp	 ebp, esp
  00333	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00338	8b e5		 mov	 esp, ebp
  0033a	5d		 pop	 ebp
  0033b	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L193430:
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e9 00 00 00 00	 jmp	 ??1CObject@@UAE@XZ	; CObject::~CObject
__ehhandler$??0CDib@@IAE@VCSize@@H@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193432
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CDib@@IAE@VCSize@@H@Z ENDP				; CDib::CDib
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
xdata$x	SEGMENT
$T193441 DD	0ffffffffH
	DD	FLAT:$L193437
$T193439 DD	019930520H
	DD	01H
	DD	FLAT:$T193441
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T193436 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CDib@@MAE@XZ PROC NEAR				; CDib::~CDib
; _this$ = ecx

; 55   : {

  00340	55		 push	 ebp
  00341	8b ec		 mov	 ebp, esp
  00343	6a ff		 push	 -1
  00345	68 00 00 00 00	 push	 __ehhandler$??1CDib@@MAE@XZ
  0034a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00350	50		 push	 eax
  00351	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00358	83 ec 08	 sub	 esp, 8
  0035b	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00362	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00369	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0036c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0036f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDib@@6B@
  00375	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 56   : 	delete m_lpvFile ;

  0037c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0037f	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00382	89 55 ec	 mov	 DWORD PTR $T193436[ebp], edx
  00385	8b 45 ec	 mov	 eax, DWORD PTR $T193436[ebp]
  00388	50		 push	 eax
  00389	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0038e	83 c4 04	 add	 esp, 4

; 57   : 	g_count --;

  00391	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_count
  00397	83 e9 01	 sub	 ecx, 1
  0039a	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_count, ecx

; 58   : 	//TRACE("m_lpvFile Destroy: %d\n", g_count);
; 59   : 	m_lpvFile = NULL;

  003a0	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  003a3	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 60   : 
; 61   : 	Empty();

  003aa	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  003ad	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 62   : }

  003b2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003b9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  003bc	e8 00 00 00 00	 call	 ??1CObject@@UAE@XZ	; CObject::~CObject
  003c1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003c4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  003cb	83 c4 14	 add	 esp, 20			; 00000014H
  003ce	3b ec		 cmp	 ebp, esp
  003d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003d5	8b e5		 mov	 esp, ebp
  003d7	5d		 pop	 ebp
  003d8	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L193437:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e9 00 00 00 00	 jmp	 ??1CObject@@UAE@XZ	; CObject::~CObject
__ehhandler$??1CDib@@MAE@XZ:
  00047	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193439
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CDib@@MAE@XZ ENDP					; CDib::~CDib
PUBLIC	?GetDimensions@CDib@@QAE?AVCSize@@XZ		; CDib::GetDimensions
EXTRN	??0CSize@@QAE@HH@Z:NEAR				; CSize::CSize
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetDimensions@CDib@@QAE?AVCSize@@XZ PROC NEAR		; CDib::GetDimensions
; _this$ = ecx

; 65   : {	

  003e0	55		 push	 ebp
  003e1	8b ec		 mov	 ebp, esp
  003e3	51		 push	 ecx
  003e4	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  003eb	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   : 	if(m_lpBMIH == NULL) return CSize(0, 0);

  003ee	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003f1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  003f5	75 11		 jne	 SHORT $L192356
  003f7	6a 00		 push	 0
  003f9	6a 00		 push	 0
  003fb	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  003fe	e8 00 00 00 00	 call	 ??0CSize@@QAE@HH@Z	; CSize::CSize
  00403	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00406	eb 1f		 jmp	 SHORT $L192355
$L192356:

; 67   : 	return CSize((int) m_lpBMIH->biWidth, (int) m_lpBMIH->biHeight);

  00408	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0040b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0040e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00411	50		 push	 eax
  00412	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00415	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00418	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0041b	50		 push	 eax
  0041c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0041f	e8 00 00 00 00	 call	 ??0CSize@@QAE@HH@Z	; CSize::CSize
  00424	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L192355:

; 68   : }

  00427	83 c4 04	 add	 esp, 4
  0042a	3b ec		 cmp	 ebp, esp
  0042c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00431	8b e5		 mov	 esp, ebp
  00433	5d		 pop	 ebp
  00434	c2 04 00	 ret	 4
?GetDimensions@CDib@@QAE?AVCSize@@XZ ENDP		; CDib::GetDimensions
_TEXT	ENDS
PUBLIC	?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z ; CDib::CcutBitmap
EXTRN	??0CMemFile@@QAE@I@Z:NEAR			; CMemFile::CMemFile
EXTRN	__imp__GlobalAlloc@8:NEAR
EXTRN	__imp__GlobalLock@4:NEAR
EXTRN	__imp__GlobalUnlock@4:NEAR
EXTRN	__imp__GlobalFree@4:NEAR
EXTRN	??0CRect@@QAE@XZ:NEAR				; CRect::CRect
EXTRN	?Width@CRect@@QBEHXZ:NEAR			; CRect::Width
EXTRN	?Height@CRect@@QBEHXZ:NEAR			; CRect::Height
EXTRN	??2@YAPAXIPBDH@Z:NEAR				; operator new
EXTRN	_memcpy:NEAR
EXTRN	?SeekToBegin@CFile@@QAEXXZ:NEAR			; CFile::SeekToBegin
xdata$x	SEGMENT
$T193464 DD	0ffffffffH
	DD	FLAT:$L193456
$T193458 DD	019930520H
	DD	01H
	DD	FLAT:$T193464
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv165 = -104						; size = 4
tv144 = -100						; size = 4
tv88 = -96						; size = 4
tv78 = -92						; size = 4
$T193455 = -88						; size = 4
$T193448 = -84						; size = 4
$T193445 = -80						; size = 4
$T193444 = -76						; size = 4
_y$192397 = -72						; size = 4
_addBitB$ = -68						; size = 4
_lpPic$ = -64						; size = 4
_hTmpBuf$ = -60						; size = 4
_addBitS$ = -56						; size = 4
_rect$ = -52						; size = 4
_nWidth$ = -48						; size = 4
_nHeight$ = -44						; size = 4
_nLineBytes$ = -40					; size = 4
_lpbmpInfo$ = -36					; size = 4
_lpFhdr$ = -32						; size = 4
_len$ = -28						; size = 4
_ret$ = -24						; size = 4
_pFile$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lpImage$ = 8						; size = 4
_pCutRect$ = 12						; size = 4
_ppFile$ = 16						; size = 4
?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z PROC NEAR ; CDib::CcutBitmap
; _this$ = ecx

; 70   : {

  00440	55		 push	 ebp
  00441	8b ec		 mov	 ebp, esp
  00443	6a ff		 push	 -1
  00445	68 00 00 00 00	 push	 __ehhandler$?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z
  0044a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00450	50		 push	 eax
  00451	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00458	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0045b	56		 push	 esi
  0045c	57		 push	 edi
  0045d	51		 push	 ecx
  0045e	8d 7d 98	 lea	 edi, DWORD PTR [ebp-104]
  00461	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00466	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0046b	f3 ab		 rep stosd
  0046d	59		 pop	 ecx
  0046e	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 71   : 	if( pCutRect == NULL ) return FALSE;

  00471	83 7d 0c 00	 cmp	 DWORD PTR _pCutRect$[ebp], 0
  00475	75 07		 jne	 SHORT $L192367
  00477	33 c0		 xor	 eax, eax
  00479	e9 8c 03 00 00	 jmp	 $L192366
$L192367:

; 72   : 	if( lpImage == NULL ) return FALSE;

  0047e	83 7d 08 00	 cmp	 DWORD PTR _lpImage$[ebp], 0
  00482	75 07		 jne	 SHORT $L192368
  00484	33 c0		 xor	 eax, eax
  00486	e9 7f 03 00 00	 jmp	 $L192366
$L192368:

; 73   : 
; 74   : 	CMemFile * pFile ;
; 75   : 	* ppFile =   new CMemFile;

  0048b	6a 4b		 push	 75			; 0000004bH
  0048d	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00492	6a 28		 push	 40			; 00000028H
  00494	e8 00 00 00 00	 call	 ??2CObject@@SGPAXIPBDH@Z ; CObject::operator new
  00499	89 45 b0	 mov	 DWORD PTR $T193445[ebp], eax
  0049c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  004a3	83 7d b0 00	 cmp	 DWORD PTR $T193445[ebp], 0
  004a7	74 12		 je	 SHORT $L193446
  004a9	68 00 04 00 00	 push	 1024			; 00000400H
  004ae	8b 4d b0	 mov	 ecx, DWORD PTR $T193445[ebp]
  004b1	e8 00 00 00 00	 call	 ??0CMemFile@@QAE@I@Z	; CMemFile::CMemFile
  004b6	89 45 a4	 mov	 DWORD PTR tv78[ebp], eax
  004b9	eb 07		 jmp	 SHORT $L193447
$L193446:
  004bb	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$L193447:
  004c2	8b 45 a4	 mov	 eax, DWORD PTR tv78[ebp]
  004c5	89 45 b4	 mov	 DWORD PTR $T193444[ebp], eax
  004c8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004cf	8b 4d 10	 mov	 ecx, DWORD PTR _ppFile$[ebp]
  004d2	8b 55 b4	 mov	 edx, DWORD PTR $T193444[ebp]
  004d5	89 11		 mov	 DWORD PTR [ecx], edx

; 76   : 	pFile = *ppFile;

  004d7	8b 45 10	 mov	 eax, DWORD PTR _ppFile$[ebp]
  004da	8b 08		 mov	 ecx, DWORD PTR [eax]
  004dc	89 4d ec	 mov	 DWORD PTR _pFile$[ebp], ecx

; 77   : 	BOOL ret=FALSE;

  004df	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 78   : 
; 79   : 	//分析位图信息,
; 80   : 	int len=sizeof(BITMAPFILEHEADER);

  004e6	c7 45 e4 0e 00
	00 00		 mov	 DWORD PTR _len$[ebp], 14 ; 0000000eH

; 81   : 	LPBITMAPFILEHEADER lpFhdr=(LPBITMAPFILEHEADER)lpImage;//文件头信息

  004ed	8b 55 08	 mov	 edx, DWORD PTR _lpImage$[ebp]
  004f0	89 55 e0	 mov	 DWORD PTR _lpFhdr$[ebp], edx

; 82   : 	LPBITMAPINFOHEADER lpbmpInfo = (LPBITMAPINFOHEADER)(lpImage+sizeof(BITMAPFILEHEADER));//位图头信息

  004f3	8b 45 08	 mov	 eax, DWORD PTR _lpImage$[ebp]
  004f6	83 c0 0e	 add	 eax, 14			; 0000000eH
  004f9	89 45 dc	 mov	 DWORD PTR _lpbmpInfo$[ebp], eax

; 83   : 
; 84   : 
; 85   : 	int nLineBytes=0,nHeight=0,nWidth=0;

  004fc	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _nLineBytes$[ebp], 0
  00503	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _nHeight$[ebp], 0
  0050a	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _nWidth$[ebp], 0

; 86   : 	nHeight = lpbmpInfo->biHeight;//源图像高

  00511	8b 4d dc	 mov	 ecx, DWORD PTR _lpbmpInfo$[ebp]
  00514	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00517	89 55 d4	 mov	 DWORD PTR _nHeight$[ebp], edx

; 87   : 	nWidth = lpbmpInfo->biWidth; //源图像宽

  0051a	8b 45 dc	 mov	 eax, DWORD PTR _lpbmpInfo$[ebp]
  0051d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00520	89 4d d0	 mov	 DWORD PTR _nWidth$[ebp], ecx

; 88   : 	
; 89   : 	CRect* rect = new CRect;

  00523	6a 59		 push	 89			; 00000059H
  00525	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  0052a	6a 10		 push	 16			; 00000010H
  0052c	e8 00 00 00 00	 call	 ??2@YAPAXIPBDH@Z	; operator new
  00531	83 c4 0c	 add	 esp, 12			; 0000000cH
  00534	89 45 ac	 mov	 DWORD PTR $T193448[ebp], eax
  00537	83 7d ac 00	 cmp	 DWORD PTR $T193448[ebp], 0
  0053b	74 0d		 je	 SHORT $L193449
  0053d	8b 4d ac	 mov	 ecx, DWORD PTR $T193448[ebp]
  00540	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect
  00545	89 45 a0	 mov	 DWORD PTR tv88[ebp], eax
  00548	eb 07		 jmp	 SHORT $L193450
$L193449:
  0054a	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
$L193450:
  00551	8b 55 a0	 mov	 edx, DWORD PTR tv88[ebp]
  00554	89 55 cc	 mov	 DWORD PTR _rect$[ebp], edx

; 90   : 	
; 91   : 	if( pCutRect->rect)

  00557	8b 45 0c	 mov	 eax, DWORD PTR _pCutRect$[ebp]
  0055a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0055d	74 0a		 je	 SHORT $L192390

; 92   : 	{
; 93   : 		rect = pCutRect->rect;

  0055f	8b 4d 0c	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  00562	8b 11		 mov	 edx, DWORD PTR [ecx]
  00564	89 55 cc	 mov	 DWORD PTR _rect$[ebp], edx

; 94   : 	}
; 95   : 	else

  00567	eb 45		 jmp	 SHORT $L192391
$L192390:

; 96   : 	{
; 97   : 		rect->left =  pCutRect->index * nWidth/pCutRect->count;

  00569	8b 45 0c	 mov	 eax, DWORD PTR _pCutRect$[ebp]
  0056c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0056f	0f af 45 d0	 imul	 eax, DWORD PTR _nWidth$[ebp]
  00573	8b 4d 0c	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  00576	33 d2		 xor	 edx, edx
  00578	f7 71 04	 div	 DWORD PTR [ecx+4]
  0057b	8b 55 cc	 mov	 edx, DWORD PTR _rect$[ebp]
  0057e	89 02		 mov	 DWORD PTR [edx], eax

; 98   : 		rect->right =  (pCutRect->index+1) * nWidth/pCutRect->count;

  00580	8b 45 0c	 mov	 eax, DWORD PTR _pCutRect$[ebp]
  00583	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00586	83 c0 01	 add	 eax, 1
  00589	0f af 45 d0	 imul	 eax, DWORD PTR _nWidth$[ebp]
  0058d	8b 4d 0c	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  00590	33 d2		 xor	 edx, edx
  00592	f7 71 04	 div	 DWORD PTR [ecx+4]
  00595	8b 55 cc	 mov	 edx, DWORD PTR _rect$[ebp]
  00598	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 99   : 		rect->top = 0;

  0059b	8b 45 cc	 mov	 eax, DWORD PTR _rect$[ebp]
  0059e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 100  : 		rect->bottom = nHeight;

  005a5	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  005a8	8b 55 d4	 mov	 edx, DWORD PTR _nHeight$[ebp]
  005ab	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L192391:

; 101  : 	}
; 102  : 
; 103  : 
; 104  : 	
; 105  : 	int addBitS = rect->Width()*3%4 ==0? 0:4-rect->Width()*3%4;

  005ae	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  005b1	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  005b6	6b c0 03	 imul	 eax, 3
  005b9	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  005be	79 05		 jns	 SHORT $L193460
  005c0	48		 dec	 eax
  005c1	83 c8 fc	 or	 eax, -4			; fffffffcH
  005c4	40		 inc	 eax
$L193460:
  005c5	85 c0		 test	 eax, eax
  005c7	75 09		 jne	 SHORT $L193451
  005c9	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv144[ebp], 0
  005d0	eb 21		 jmp	 SHORT $L193452
$L193451:
  005d2	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  005d5	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  005da	6b c0 03	 imul	 eax, 3
  005dd	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  005e2	79 05		 jns	 SHORT $L193461
  005e4	48		 dec	 eax
  005e5	83 c8 fc	 or	 eax, -4			; fffffffcH
  005e8	40		 inc	 eax
$L193461:
  005e9	b9 04 00 00 00	 mov	 ecx, 4
  005ee	2b c8		 sub	 ecx, eax
  005f0	89 4d 9c	 mov	 DWORD PTR tv144[ebp], ecx
$L193452:
  005f3	8b 55 9c	 mov	 edx, DWORD PTR tv144[ebp]
  005f6	89 55 c8	 mov	 DWORD PTR _addBitS$[ebp], edx

; 106  : 	HGLOBAL hTmpBuf = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,(rect->Width()+addBitS)*rect->Height()*3);

  005f9	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  005fc	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00601	8b f0		 mov	 esi, eax
  00603	03 75 c8	 add	 esi, DWORD PTR _addBitS$[ebp]
  00606	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  00609	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0060e	0f af f0	 imul	 esi, eax
  00611	6b f6 03	 imul	 esi, 3
  00614	8b fc		 mov	 edi, esp
  00616	56		 push	 esi
  00617	6a 42		 push	 66			; 00000042H
  00619	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  0061f	3b fc		 cmp	 edi, esp
  00621	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00626	89 45 c4	 mov	 DWORD PTR _hTmpBuf$[ebp], eax

; 107  : 	LPSTR lpPic = (LPSTR)GlobalLock(hTmpBuf);

  00629	8b f4		 mov	 esi, esp
  0062b	8b 45 c4	 mov	 eax, DWORD PTR _hTmpBuf$[ebp]
  0062e	50		 push	 eax
  0062f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  00635	3b f4		 cmp	 esi, esp
  00637	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0063c	89 45 c0	 mov	 DWORD PTR _lpPic$[ebp], eax

; 108  : 
; 109  : 	
; 110  : 	int addBitB = lpbmpInfo->biWidth * 3%4 == 0 ? 0 : 4-lpbmpInfo->biWidth * 3%4;

  0063f	8b 4d dc	 mov	 ecx, DWORD PTR _lpbmpInfo$[ebp]
  00642	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00645	6b d2 03	 imul	 edx, 3
  00648	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  0064e	79 05		 jns	 SHORT $L193462
  00650	4a		 dec	 edx
  00651	83 ca fc	 or	 edx, -4			; fffffffcH
  00654	42		 inc	 edx
$L193462:
  00655	85 d2		 test	 edx, edx
  00657	75 09		 jne	 SHORT $L193453
  00659	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv165[ebp], 0
  00660	eb 20		 jmp	 SHORT $L193454
$L193453:
  00662	8b 45 dc	 mov	 eax, DWORD PTR _lpbmpInfo$[ebp]
  00665	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00668	6b c9 03	 imul	 ecx, 3
  0066b	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00671	79 05		 jns	 SHORT $L193463
  00673	49		 dec	 ecx
  00674	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00677	41		 inc	 ecx
$L193463:
  00678	ba 04 00 00 00	 mov	 edx, 4
  0067d	2b d1		 sub	 edx, ecx
  0067f	89 55 98	 mov	 DWORD PTR tv165[ebp], edx
$L193454:
  00682	8b 45 98	 mov	 eax, DWORD PTR tv165[ebp]
  00685	89 45 bc	 mov	 DWORD PTR _addBitB$[ebp], eax

; 111  : 
; 112  : 	// 拷贝原始图像到新分配的图像存储区
; 113  : 	for(int y=rect->top;y< rect->bottom; y++)

  00688	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  0068b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0068e	89 55 b8	 mov	 DWORD PTR _y$192397[ebp], edx
  00691	eb 09		 jmp	 SHORT $L192398
$L192399:
  00693	8b 45 b8	 mov	 eax, DWORD PTR _y$192397[ebp]
  00696	83 c0 01	 add	 eax, 1
  00699	89 45 b8	 mov	 DWORD PTR _y$192397[ebp], eax
$L192398:
  0069c	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  0069f	8b 55 b8	 mov	 edx, DWORD PTR _y$192397[ebp]
  006a2	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  006a5	7d 75		 jge	 SHORT $L192400

; 114  : 	{
; 115  : 		
; 116  : 		memcpy(lpPic,lpImage+lpFhdr->bfOffBits+y* (lpbmpInfo->biWidth * 3+addBitB)+rect->left*3, rect->Width()*3 );

  006a7	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  006aa	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  006af	6b c0 03	 imul	 eax, 3
  006b2	50		 push	 eax
  006b3	8b 45 e0	 mov	 eax, DWORD PTR _lpFhdr$[ebp]
  006b6	8b 4d 08	 mov	 ecx, DWORD PTR _lpImage$[ebp]
  006b9	03 48 0a	 add	 ecx, DWORD PTR [eax+10]
  006bc	8b 55 dc	 mov	 edx, DWORD PTR _lpbmpInfo$[ebp]
  006bf	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  006c2	6b c0 03	 imul	 eax, 3
  006c5	03 45 bc	 add	 eax, DWORD PTR _addBitB$[ebp]
  006c8	0f af 45 b8	 imul	 eax, DWORD PTR _y$192397[ebp]
  006cc	03 c8		 add	 ecx, eax
  006ce	8b 55 cc	 mov	 edx, DWORD PTR _rect$[ebp]
  006d1	8b 02		 mov	 eax, DWORD PTR [edx]
  006d3	6b c0 03	 imul	 eax, 3
  006d6	03 c8		 add	 ecx, eax
  006d8	51		 push	 ecx
  006d9	8b 4d c0	 mov	 ecx, DWORD PTR _lpPic$[ebp]
  006dc	51		 push	 ecx
  006dd	e8 00 00 00 00	 call	 _memcpy
  006e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 117  : 		lpPic+= rect->Width()*3;

  006e5	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  006e8	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  006ed	6b c0 03	 imul	 eax, 3
  006f0	03 45 c0	 add	 eax, DWORD PTR _lpPic$[ebp]
  006f3	89 45 c0	 mov	 DWORD PTR _lpPic$[ebp], eax

; 118  : 		if(addBitS != 0 )

  006f6	83 7d c8 00	 cmp	 DWORD PTR _addBitS$[ebp], 0
  006fa	74 1b		 je	 SHORT $L192401

; 119  : 		{
; 120  : 			ZeroMemory(lpPic,addBitS);

  006fc	8b 55 c8	 mov	 edx, DWORD PTR _addBitS$[ebp]
  006ff	52		 push	 edx
  00700	6a 00		 push	 0
  00702	8b 45 c0	 mov	 eax, DWORD PTR _lpPic$[ebp]
  00705	50		 push	 eax
  00706	e8 00 00 00 00	 call	 _memset
  0070b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 121  : 			lpPic+= addBitS;

  0070e	8b 4d c0	 mov	 ecx, DWORD PTR _lpPic$[ebp]
  00711	03 4d c8	 add	 ecx, DWORD PTR _addBitS$[ebp]
  00714	89 4d c0	 mov	 DWORD PTR _lpPic$[ebp], ecx
$L192401:

; 122  : 		}
; 123  : 	}

  00717	e9 77 ff ff ff	 jmp	 $L192399
$L192400:

; 124  : 
; 125  : 	//将指针移回开始位置
; 126  : 	lpPic=lpPic-(rect->Width()*3+addBitS)*rect->Height();

  0071c	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  0071f	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00724	8b f0		 mov	 esi, eax
  00726	6b f6 03	 imul	 esi, 3
  00729	03 75 c8	 add	 esi, DWORD PTR _addBitS$[ebp]
  0072c	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  0072f	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00734	0f af f0	 imul	 esi, eax
  00737	8b 55 c0	 mov	 edx, DWORD PTR _lpPic$[ebp]
  0073a	2b d6		 sub	 edx, esi
  0073c	89 55 c0	 mov	 DWORD PTR _lpPic$[ebp], edx

; 127  : 
; 128  : 	//存储位图
; 129  : 	//除了高度，宽度，不改变原始图像的其它信息
; 130  : 	lpbmpInfo->biWidth=rect->Width();

  0073f	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  00742	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00747	8b 4d dc	 mov	 ecx, DWORD PTR _lpbmpInfo$[ebp]
  0074a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 131  : 	lpbmpInfo->biHeight=rect->Height();

  0074d	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  00750	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00755	8b 55 dc	 mov	 edx, DWORD PTR _lpbmpInfo$[ebp]
  00758	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 132  : 
; 133  : 	pFile->Write(lpFhdr,len);//写文件头

  0075b	8b f4		 mov	 esi, esp
  0075d	8b 45 e4	 mov	 eax, DWORD PTR _len$[ebp]
  00760	50		 push	 eax
  00761	8b 4d e0	 mov	 ecx, DWORD PTR _lpFhdr$[ebp]
  00764	51		 push	 ecx
  00765	8b 55 ec	 mov	 edx, DWORD PTR _pFile$[ebp]
  00768	8b 02		 mov	 eax, DWORD PTR [edx]
  0076a	8b 4d ec	 mov	 ecx, DWORD PTR _pFile$[ebp]
  0076d	ff 50 40	 call	 DWORD PTR [eax+64]
  00770	3b f4		 cmp	 esi, esp
  00772	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 134  : 	pFile->Write( lpbmpInfo,sizeof(BITMAPINFOHEADER));//写位图信息

  00777	8b f4		 mov	 esi, esp
  00779	6a 28		 push	 40			; 00000028H
  0077b	8b 4d dc	 mov	 ecx, DWORD PTR _lpbmpInfo$[ebp]
  0077e	51		 push	 ecx
  0077f	8b 55 ec	 mov	 edx, DWORD PTR _pFile$[ebp]
  00782	8b 02		 mov	 eax, DWORD PTR [edx]
  00784	8b 4d ec	 mov	 ecx, DWORD PTR _pFile$[ebp]
  00787	ff 50 40	 call	 DWORD PTR [eax+64]
  0078a	3b f4		 cmp	 esi, esp
  0078c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 135  : 	pFile->Write( lpPic,(rect->Width()*3+addBitS)*rect->Height() );//写拷贝过来的图像像素

  00791	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  00794	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00799	8b f0		 mov	 esi, eax
  0079b	6b f6 03	 imul	 esi, 3
  0079e	03 75 c8	 add	 esi, DWORD PTR _addBitS$[ebp]
  007a1	8b 4d cc	 mov	 ecx, DWORD PTR _rect$[ebp]
  007a4	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  007a9	0f af f0	 imul	 esi, eax
  007ac	8b fc		 mov	 edi, esp
  007ae	56		 push	 esi
  007af	8b 4d c0	 mov	 ecx, DWORD PTR _lpPic$[ebp]
  007b2	51		 push	 ecx
  007b3	8b 55 ec	 mov	 edx, DWORD PTR _pFile$[ebp]
  007b6	8b 02		 mov	 eax, DWORD PTR [edx]
  007b8	8b 4d ec	 mov	 ecx, DWORD PTR _pFile$[ebp]
  007bb	ff 50 40	 call	 DWORD PTR [eax+64]
  007be	3b fc		 cmp	 edi, esp
  007c0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 136  : 	
; 137  : 	pFile->SeekToBegin();

  007c5	8b 4d ec	 mov	 ecx, DWORD PTR _pFile$[ebp]
  007c8	e8 00 00 00 00	 call	 ?SeekToBegin@CFile@@QAEXXZ ; CFile::SeekToBegin

; 138  : 
; 139  : 	GlobalUnlock (hTmpBuf);//释放

  007cd	8b f4		 mov	 esi, esp
  007cf	8b 4d c4	 mov	 ecx, DWORD PTR _hTmpBuf$[ebp]
  007d2	51		 push	 ecx
  007d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  007d9	3b f4		 cmp	 esi, esp
  007db	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 140  : 	GlobalFree (hTmpBuf);

  007e0	8b f4		 mov	 esi, esp
  007e2	8b 55 c4	 mov	 edx, DWORD PTR _hTmpBuf$[ebp]
  007e5	52		 push	 edx
  007e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  007ec	3b f4		 cmp	 esi, esp
  007ee	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 141  : 
; 142  : 
; 143  : 	delete rect;

  007f3	8b 45 cc	 mov	 eax, DWORD PTR _rect$[ebp]
  007f6	89 45 a8	 mov	 DWORD PTR $T193455[ebp], eax
  007f9	8b 4d a8	 mov	 ecx, DWORD PTR $T193455[ebp]
  007fc	51		 push	 ecx
  007fd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00802	83 c4 04	 add	 esp, 4

; 144  : 	return TRUE;

  00805	b8 01 00 00 00	 mov	 eax, 1
$L192366:

; 145  : }

  0080a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0080d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00814	5f		 pop	 edi
  00815	5e		 pop	 esi
  00816	83 c4 68	 add	 esp, 104		; 00000068H
  00819	3b ec		 cmp	 ebp, esp
  0081b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00820	8b e5		 mov	 esp, ebp
  00822	5d		 pop	 ebp
  00823	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L193456:
  00051	6a 4b		 push	 75			; 0000004bH
  00053	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00058	8b 45 b0	 mov	 eax, DWORD PTR $T193445[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ??3CObject@@SGXPAXPBDH@Z ; CObject::operator delete
  00061	c3		 ret	 0
__ehhandler$?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z:
  00062	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193458
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z ENDP ; CDib::CcutBitmap
PUBLIC	?AttachMemory@CDib@@QAEHPAXH0@Z			; CDib::AttachMemory
PUBLIC	?AttachMapFile2@CDib@@IAEHPAXIPAUCutRect@1@H@Z	; CDib::AttachMapFile2
PUBLIC	?DetachMapFile@CDib@@AAEXXZ			; CDib::DetachMapFile
EXTRN	?AfxMessageBox@@YGHPBDII@Z:NEAR			; AfxMessageBox
EXTRN	@_RTC_CheckStackVars@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv145 = -56						; size = 4
$T193469 = -52						; size = 4
$T193468 = -48						; size = 4
$T193467 = -44						; size = 4
$T193466 = -40						; size = 4
_nLenght$192422 = -36					; size = 4
_nLenght$ = -32						; size = 4
_memFile$ = -24						; size = 4
_retLen$ = -16						; size = 4
_lpImage$ = -12						; size = 4
_hImageBuf$ = -8					; size = 4
_this$ = -4						; size = 4
_pVoid$ = 8						; size = 4
_size$ = 12						; size = 4
_pCutRect$ = 16						; size = 4
_bShare$ = 20						; size = 4
?AttachMapFile2@CDib@@IAEHPAXIPAUCutRect@1@H@Z PROC NEAR ; CDib::AttachMapFile2
; _this$ = ecx

; 147  : {

  00830	55		 push	 ebp
  00831	8b ec		 mov	 ebp, esp
  00833	83 ec 38	 sub	 esp, 56			; 00000038H
  00836	56		 push	 esi
  00837	57		 push	 edi
  00838	51		 push	 ecx
  00839	8d 7d c8	 lea	 edi, DWORD PTR [ebp-56]
  0083c	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00841	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00846	f3 ab		 rep stosd
  00848	59		 pop	 ecx
  00849	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 148  : 	if(size<=0) return FALSE;

  0084c	83 7d 0c 00	 cmp	 DWORD PTR _size$[ebp], 0
  00850	77 07		 ja	 SHORT $L192411
  00852	33 c0		 xor	 eax, eax
  00854	e9 d5 01 00 00	 jmp	 $L192410
$L192411:

; 149  : 
; 150  : 	HGLOBAL hImageBuf = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,size);

  00859	8b f4		 mov	 esi, esp
  0085b	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0085e	50		 push	 eax
  0085f	6a 42		 push	 66			; 00000042H
  00861	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00867	3b f4		 cmp	 esi, esp
  00869	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0086e	89 45 f8	 mov	 DWORD PTR _hImageBuf$[ebp], eax

; 151  : 	if(!hImageBuf)

  00871	83 7d f8 00	 cmp	 DWORD PTR _hImageBuf$[ebp], 0
  00875	75 07		 jne	 SHORT $L192413

; 152  : 	{
; 153  : 		//分配失败则返回
; 154  : 		return FALSE;

  00877	33 c0		 xor	 eax, eax
  00879	e9 b0 01 00 00	 jmp	 $L192410
$L192413:

; 155  : 	}
; 156  : 
; 157  : 	LPSTR lpImage = (LPSTR)GlobalLock(hImageBuf);

  0087e	8b f4		 mov	 esi, esp
  00880	8b 4d f8	 mov	 ecx, DWORD PTR _hImageBuf$[ebp]
  00883	51		 push	 ecx
  00884	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  0088a	3b f4		 cmp	 esi, esp
  0088c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00891	89 45 f4	 mov	 DWORD PTR _lpImage$[ebp], eax

; 158  : 
; 159  : 	//将图像读入内存
; 160  : 	DWORD retLen=0;

  00894	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _retLen$[ebp], 0

; 161  : //	retLen=f.Read(lpImage,dwBitsSize);
; 162  : 	memcpy(lpImage, pVoid, size );

  0089b	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  0089e	52		 push	 edx
  0089f	8b 45 08	 mov	 eax, DWORD PTR _pVoid$[ebp]
  008a2	50		 push	 eax
  008a3	8b 4d f4	 mov	 ecx, DWORD PTR _lpImage$[ebp]
  008a6	51		 push	 ecx
  008a7	e8 00 00 00 00	 call	 _memcpy
  008ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  : 	
; 164  : 
; 165  : 	CMemFile* memFile = NULL;

  008af	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _memFile$[ebp], 0

; 166  : 	CcutBitmap(lpImage,pCutRect,&memFile);

  008b6	8d 55 e8	 lea	 edx, DWORD PTR _memFile$[ebp]
  008b9	52		 push	 edx
  008ba	8b 45 10	 mov	 eax, DWORD PTR _pCutRect$[ebp]
  008bd	50		 push	 eax
  008be	8b 4d f4	 mov	 ecx, DWORD PTR _lpImage$[ebp]
  008c1	51		 push	 ecx
  008c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008c5	e8 00 00 00 00	 call	 ?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z ; CDib::CcutBitmap

; 167  : 
; 168  : 
; 169  : 	GlobalUnlock (hImageBuf);//释放

  008ca	8b f4		 mov	 esi, esp
  008cc	8b 55 f8	 mov	 edx, DWORD PTR _hImageBuf$[ebp]
  008cf	52		 push	 edx
  008d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  008d6	3b f4		 cmp	 esi, esp
  008d8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 170  : 	GlobalFree (hImageBuf);

  008dd	8b f4		 mov	 esi, esp
  008df	8b 45 f8	 mov	 eax, DWORD PTR _hImageBuf$[ebp]
  008e2	50		 push	 eax
  008e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  008e9	3b f4		 cmp	 esi, esp
  008eb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 171  : 
; 172  : 	if(m_lpvFile != NULL)

  008f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008f3	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  008f7	74 2e		 je	 SHORT $L192418

; 173  : 	{
; 174  : 		delete m_lpvFile;

  008f9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  008fc	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  008ff	89 45 d8	 mov	 DWORD PTR $T193466[ebp], eax
  00902	8b 4d d8	 mov	 ecx, DWORD PTR $T193466[ebp]
  00905	51		 push	 ecx
  00906	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0090b	83 c4 04	 add	 esp, 4

; 175  : 		g_count --;

  0090e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_count
  00914	83 ea 01	 sub	 edx, 1
  00917	89 15 00 00 00
	00		 mov	 DWORD PTR _g_count, edx

; 176  : 		//	TRACE("m_lpvFile Destroy: %d\n", g_count);
; 177  : 		m_lpvFile = NULL;

  0091d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00920	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
$L192418:

; 178  : 	}
; 179  : 
; 180  : 	UINT nLenght = 0;

  00927	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _nLenght$[ebp], 0

; 181  : 	if( memFile )

  0092e	83 7d e8 00	 cmp	 DWORD PTR _memFile$[ebp], 0
  00932	0f 84 f4 00 00
	00		 je	 $L192421

; 182  : 	{
; 183  : 		UINT nLenght = memFile->GetLength();

  00938	8b 4d e8	 mov	 ecx, DWORD PTR _memFile$[ebp]
  0093b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0093d	8b f4		 mov	 esi, esp
  0093f	8b 4d e8	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00942	ff 52 38	 call	 DWORD PTR [edx+56]
  00945	3b f4		 cmp	 esi, esp
  00947	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0094c	89 45 dc	 mov	 DWORD PTR _nLenght$192422[ebp], eax

; 184  : 	m_lpvFile = new unsigned char [nLenght];

  0094f	68 b8 00 00 00	 push	 184			; 000000b8H
  00954	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00959	8b 45 dc	 mov	 eax, DWORD PTR _nLenght$192422[ebp]
  0095c	50		 push	 eax
  0095d	e8 00 00 00 00	 call	 ??_U@YAPAXIPBDH@Z	; operator new[]
  00962	83 c4 0c	 add	 esp, 12			; 0000000cH
  00965	89 45 d4	 mov	 DWORD PTR $T193467[ebp], eax
  00968	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0096b	8b 55 d4	 mov	 edx, DWORD PTR $T193467[ebp]
  0096e	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 185  : 	g_count ++;

  00971	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_count
  00976	83 c0 01	 add	 eax, 1
  00979	a3 00 00 00 00	 mov	 DWORD PTR _g_count, eax

; 186  : 
; 187  : 	memFile->Read(m_lpvFile, nLenght);

  0097e	8b f4		 mov	 esi, esp
  00980	8b 4d dc	 mov	 ecx, DWORD PTR _nLenght$192422[ebp]
  00983	51		 push	 ecx
  00984	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00987	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0098a	50		 push	 eax
  0098b	8b 4d e8	 mov	 ecx, DWORD PTR _memFile$[ebp]
  0098e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00990	8b 4d e8	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00993	ff 52 3c	 call	 DWORD PTR [edx+60]
  00996	3b f4		 cmp	 esi, esp
  00998	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 188  : 
; 189  : 	memFile->Close();

  0099d	8b 45 e8	 mov	 eax, DWORD PTR _memFile$[ebp]
  009a0	8b 10		 mov	 edx, DWORD PTR [eax]
  009a2	8b f4		 mov	 esi, esp
  009a4	8b 4d e8	 mov	 ecx, DWORD PTR _memFile$[ebp]
  009a7	ff 52 54	 call	 DWORD PTR [edx+84]
  009aa	3b f4		 cmp	 esi, esp
  009ac	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 190  : 
; 191  : 	delete memFile;

  009b1	8b 45 e8	 mov	 eax, DWORD PTR _memFile$[ebp]
  009b4	89 45 cc	 mov	 DWORD PTR $T193469[ebp], eax
  009b7	8b 4d cc	 mov	 ecx, DWORD PTR $T193469[ebp]
  009ba	89 4d d0	 mov	 DWORD PTR $T193468[ebp], ecx
  009bd	83 7d d0 00	 cmp	 DWORD PTR $T193468[ebp], 0
  009c1	74 1b		 je	 SHORT $L193470
  009c3	8b f4		 mov	 esi, esp
  009c5	6a 01		 push	 1
  009c7	8b 55 d0	 mov	 edx, DWORD PTR $T193468[ebp]
  009ca	8b 02		 mov	 eax, DWORD PTR [edx]
  009cc	8b 4d d0	 mov	 ecx, DWORD PTR $T193468[ebp]
  009cf	ff 50 04	 call	 DWORD PTR [eax+4]
  009d2	3b f4		 cmp	 esi, esp
  009d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  009d9	89 45 c8	 mov	 DWORD PTR tv145[ebp], eax
  009dc	eb 07		 jmp	 SHORT $L193471
$L193470:
  009de	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv145[ebp], 0
$L193471:

; 192  : 
; 193  : 	if(((LPBITMAPFILEHEADER) m_lpvFile)->bfType != 0x4d42) {

  009e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009e8	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  009eb	0f b7 02	 movzx	 eax, WORD PTR [edx]
  009ee	3d 42 4d 00 00	 cmp	 eax, 19778		; 00004d42H
  009f3	74 1a		 je	 SHORT $L192428

; 194  : 		AfxMessageBox("Invalid bitmap file");

  009f5	6a 00		 push	 0
  009f7	6a 00		 push	 0
  009f9	68 00 00 00 00	 push	 OFFSET FLAT:$SG192429
  009fe	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 195  : 		DetachMapFile();

  00a03	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a06	e8 00 00 00 00	 call	 ?DetachMapFile@CDib@@AAEXXZ ; CDib::DetachMapFile

; 196  : 		return FALSE;

  00a0b	33 c0		 xor	 eax, eax
  00a0d	eb 1f		 jmp	 SHORT $L192410
$L192428:

; 197  : 	}
; 198  : 	AttachMemory((LPBYTE) m_lpvFile + sizeof(BITMAPFILEHEADER));

  00a0f	6a 00		 push	 0
  00a11	6a 00		 push	 0
  00a13	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a16	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00a19	83 c2 0e	 add	 edx, 14			; 0000000eH
  00a1c	52		 push	 edx
  00a1d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a20	e8 00 00 00 00	 call	 ?AttachMemory@CDib@@QAEHPAXH0@Z ; CDib::AttachMemory

; 199  : 	//	m_lpvFile = lpvFile;
; 200  : 	//	m_hFile = hFile;
; 201  : 	//
; 202  : 	//*(m_lpImage+100) = 5;
; 203  : 	return TRUE;

  00a25	b8 01 00 00 00	 mov	 eax, 1
  00a2a	eb 02		 jmp	 SHORT $L192410
$L192421:

; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		return FALSE;

  00a2c	33 c0		 xor	 eax, eax
$L192410:

; 208  : 	}
; 209  : }

  00a2e	52		 push	 edx
  00a2f	8b cd		 mov	 ecx, ebp
  00a31	50		 push	 eax
  00a32	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L193474
  00a38	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00a3d	58		 pop	 eax
  00a3e	5a		 pop	 edx
  00a3f	5f		 pop	 edi
  00a40	5e		 pop	 esi
  00a41	83 c4 38	 add	 esp, 56			; 00000038H
  00a44	3b ec		 cmp	 ebp, esp
  00a46	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a4b	8b e5		 mov	 esp, ebp
  00a4d	5d		 pop	 ebp
  00a4e	c2 10 00	 ret	 16			; 00000010H
$L193474:
  00a51	01 00 00 00	 DD	 1
  00a55	00 00 00 00	 DD	 $L193473
$L193473:
  00a59	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00a5d	04 00 00 00	 DD	 4
  00a61	00 00 00 00	 DD	 $L193472
$L193472:
  00a65	6d		 DB	 109			; 0000006dH
  00a66	65		 DB	 101			; 00000065H
  00a67	6d		 DB	 109			; 0000006dH
  00a68	46		 DB	 70			; 00000046H
  00a69	69		 DB	 105			; 00000069H
  00a6a	6c		 DB	 108			; 0000006cH
  00a6b	65		 DB	 101			; 00000065H
  00a6c	00		 DB	 0
?AttachMapFile2@CDib@@IAEHPAXIPAUCutRect@1@H@Z ENDP	; CDib::AttachMapFile2
_TEXT	ENDS
PUBLIC	?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z	; CDib::AttachMapFile2
EXTRN	__imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z:NEAR
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:NEAR
EXTRN	??0CFile@@QAE@XZ:NEAR				; CFile::CFile
EXTRN	?Open@CFile@@UAEHPBDIPAVCFileException@@@Z:NEAR	; CFile::Open
EXTRN	?GetLength@CFile@@UBE_KXZ:NEAR			; CFile::GetLength
EXTRN	?Read@CFile@@UAEIPAXI@Z:NEAR			; CFile::Read
EXTRN	?Close@CFile@@UAEXXZ:NEAR			; CFile::Close
EXTRN	??1CFile@@UAE@XZ:NEAR				; CFile::~CFile
xdata$x	SEGMENT
$T193499 DD	0ffffffffH
	DD	FLAT:$L193489
	DD	00H
	DD	FLAT:$L193490
$T193492 DD	019930520H
	DD	02H
	DD	FLAT:$T193499
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv170 = -132						; size = 4
$T193488 = -128						; size = 4
$T193487 = -124						; size = 4
$T193486 = -120						; size = 4
$T193483 = -116						; size = 4
$T193482 = -112						; size = 4
$T193481 = -108						; size = 4
$T193480 = -104						; size = 4
$T193479 = -100						; size = 4
$T193478 = -96						; size = 4
$T193477 = -92						; size = 4
_nLenght$192458 = -88					; size = 4
_nLenght$ = -84						; size = 4
_memFile$ = -76						; size = 4
_str$ = -64						; size = 4
_retLen$ = -56						; size = 4
_lpImage$ = -52						; size = 4
_hImageBuf$ = -48					; size = 4
_dwBitsSize$ = -44					; size = 4
_f$ = -36						; size = 16
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_strPathname$ = 8					; size = 4
_pCutRect$ = 12						; size = 4
_bShare$ = 16						; size = 4
?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z PROC NEAR	; CDib::AttachMapFile2
; _this$ = ecx

; 211  : {

  00a70	55		 push	 ebp
  00a71	8b ec		 mov	 ebp, esp
  00a73	6a ff		 push	 -1
  00a75	68 00 00 00 00	 push	 __ehhandler$?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z
  00a7a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00a80	50		 push	 eax
  00a81	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00a88	83 ec 78	 sub	 esp, 120		; 00000078H
  00a8b	56		 push	 esi
  00a8c	57		 push	 edi
  00a8d	51		 push	 ecx
  00a8e	8d bd 7c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-132]
  00a94	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  00a99	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00a9e	f3 ab		 rep stosd
  00aa0	59		 pop	 ecx
  00aa1	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 212  : 	CFile f ;

  00aa4	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00aa7	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile
  00aac	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 213  : 
; 214  : 	if(!f.Open(strPathname, CFile::modeRead))

  00ab3	6a 00		 push	 0
  00ab5	6a 00		 push	 0
  00ab7	8b 45 08	 mov	 eax, DWORD PTR _strPathname$[ebp]
  00aba	50		 push	 eax
  00abb	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00abe	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  00ac3	85 c0		 test	 eax, eax
  00ac5	75 1e		 jne	 SHORT $L192440

; 215  : 		return false;

  00ac7	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T193477[ebp], 0
  00ace	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ad5	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00ad8	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00add	8b 45 a4	 mov	 eax, DWORD PTR $T193477[ebp]
  00ae0	e9 22 03 00 00	 jmp	 $L192438
$L192440:

; 216  : 
; 217  : 
; 218  : 	DWORD dwBitsSize=f.GetLength();//文件长度

  00ae5	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00ae8	e8 00 00 00 00	 call	 ?GetLength@CFile@@UBE_KXZ ; CFile::GetLength
  00aed	89 45 d4	 mov	 DWORD PTR _dwBitsSize$[ebp], eax

; 219  : 
; 220  : 	HGLOBAL hImageBuf = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,dwBitsSize);

  00af0	8b f4		 mov	 esi, esp
  00af2	8b 4d d4	 mov	 ecx, DWORD PTR _dwBitsSize$[ebp]
  00af5	51		 push	 ecx
  00af6	6a 42		 push	 66			; 00000042H
  00af8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00afe	3b f4		 cmp	 esi, esp
  00b00	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b05	89 45 d0	 mov	 DWORD PTR _hImageBuf$[ebp], eax

; 221  : 	if(!hImageBuf)

  00b08	83 7d d0 00	 cmp	 DWORD PTR _hImageBuf$[ebp], 0
  00b0c	75 26		 jne	 SHORT $L192444

; 222  : 	{
; 223  : 		//分配失败则返回
; 224  : 		f.Close();

  00b0e	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00b11	e8 00 00 00 00	 call	 ?Close@CFile@@UAEXXZ	; CFile::Close

; 225  : 		return FALSE;

  00b16	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T193478[ebp], 0
  00b1d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b24	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00b27	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00b2c	8b 45 a0	 mov	 eax, DWORD PTR $T193478[ebp]
  00b2f	e9 d3 02 00 00	 jmp	 $L192438
$L192444:

; 226  : 	}
; 227  : 
; 228  : 	LPSTR lpImage = (LPSTR)GlobalLock(hImageBuf);

  00b34	8b f4		 mov	 esi, esp
  00b36	8b 55 d0	 mov	 edx, DWORD PTR _hImageBuf$[ebp]
  00b39	52		 push	 edx
  00b3a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  00b40	3b f4		 cmp	 esi, esp
  00b42	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b47	89 45 cc	 mov	 DWORD PTR _lpImage$[ebp], eax

; 229  : 
; 230  : 	//将图像读入内存
; 231  : 	DWORD retLen=0;

  00b4a	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _retLen$[ebp], 0

; 232  : 	retLen=f.Read(lpImage,dwBitsSize);

  00b51	8b 45 d4	 mov	 eax, DWORD PTR _dwBitsSize$[ebp]
  00b54	50		 push	 eax
  00b55	8b 4d cc	 mov	 ecx, DWORD PTR _lpImage$[ebp]
  00b58	51		 push	 ecx
  00b59	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00b5c	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  00b61	89 45 c8	 mov	 DWORD PTR _retLen$[ebp], eax

; 233  : 	if(retLen<dwBitsSize)

  00b64	8b 55 c8	 mov	 edx, DWORD PTR _retLen$[ebp]
  00b67	3b 55 d4	 cmp	 edx, DWORD PTR _dwBitsSize$[ebp]
  00b6a	73 52		 jae	 SHORT $L192449

; 234  : 	{
; 235  : 		if(hImageBuf!=NULL)

  00b6c	83 7d d0 00	 cmp	 DWORD PTR _hImageBuf$[ebp], 0
  00b70	74 26		 je	 SHORT $L192450

; 236  : 		{
; 237  : 			GlobalUnlock (hImageBuf);

  00b72	8b f4		 mov	 esi, esp
  00b74	8b 45 d0	 mov	 eax, DWORD PTR _hImageBuf$[ebp]
  00b77	50		 push	 eax
  00b78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  00b7e	3b f4		 cmp	 esi, esp
  00b80	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 238  : 			GlobalFree (hImageBuf);

  00b85	8b f4		 mov	 esi, esp
  00b87	8b 4d d0	 mov	 ecx, DWORD PTR _hImageBuf$[ebp]
  00b8a	51		 push	 ecx
  00b8b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  00b91	3b f4		 cmp	 esi, esp
  00b93	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L192450:

; 239  : 		}
; 240  : 		f.Close();

  00b98	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00b9b	e8 00 00 00 00	 call	 ?Close@CFile@@UAEXXZ	; CFile::Close

; 241  : 		return FALSE;

  00ba0	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T193479[ebp], 0
  00ba7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00bae	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00bb1	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00bb6	8b 45 9c	 mov	 eax, DWORD PTR $T193479[ebp]
  00bb9	e9 49 02 00 00	 jmp	 $L192438
$L192449:

; 242  : 	}
; 243  : 
; 244  : 
; 245  : 	CString str;

  00bbe	8b f4		 mov	 esi, esp
  00bc0	8d 4d c0	 lea	 ecx, DWORD PTR _str$[ebp]
  00bc3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00bc9	3b f4		 cmp	 esi, esp
  00bcb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00bd0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 246  : 	str =strPathname;

  00bd4	8b f4		 mov	 esi, esp
  00bd6	8b 55 08	 mov	 edx, DWORD PTR _strPathname$[ebp]
  00bd9	52		 push	 edx
  00bda	8d 4d c0	 lea	 ecx, DWORD PTR _str$[ebp]
  00bdd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
  00be3	3b f4		 cmp	 esi, esp
  00be5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 247  : 
; 248  : 	CMemFile* memFile = NULL;

  00bea	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _memFile$[ebp], 0

; 249  : 	CcutBitmap(lpImage, pCutRect,&memFile);

  00bf1	8d 45 b4	 lea	 eax, DWORD PTR _memFile$[ebp]
  00bf4	50		 push	 eax
  00bf5	8b 4d 0c	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  00bf8	51		 push	 ecx
  00bf9	8b 55 cc	 mov	 edx, DWORD PTR _lpImage$[ebp]
  00bfc	52		 push	 edx
  00bfd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00c00	e8 00 00 00 00	 call	 ?CcutBitmap@CDib@@IAEHPADPAUCutRect@1@PAPAVCMemFile@@@Z ; CDib::CcutBitmap

; 250  : 	str.ReleaseBuffer();

  00c05	8b f4		 mov	 esi, esp
  00c07	6a ff		 push	 -1
  00c09	8d 4d c0	 lea	 ecx, DWORD PTR _str$[ebp]
  00c0c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z
  00c12	3b f4		 cmp	 esi, esp
  00c14	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 251  : 
; 252  : 	GlobalUnlock (hImageBuf);//释放

  00c19	8b f4		 mov	 esi, esp
  00c1b	8b 45 d0	 mov	 eax, DWORD PTR _hImageBuf$[ebp]
  00c1e	50		 push	 eax
  00c1f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  00c25	3b f4		 cmp	 esi, esp
  00c27	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 253  : 	GlobalFree (hImageBuf);

  00c2c	8b f4		 mov	 esi, esp
  00c2e	8b 4d d0	 mov	 ecx, DWORD PTR _hImageBuf$[ebp]
  00c31	51		 push	 ecx
  00c32	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  00c38	3b f4		 cmp	 esi, esp
  00c3a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 254  : 
; 255  : 	if(m_lpvFile != NULL)

  00c3f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00c42	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00c46	74 2c		 je	 SHORT $L192454

; 256  : 	{
; 257  : 		delete m_lpvFile;

  00c48	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00c4b	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00c4e	89 4d 98	 mov	 DWORD PTR $T193480[ebp], ecx
  00c51	8b 55 98	 mov	 edx, DWORD PTR $T193480[ebp]
  00c54	52		 push	 edx
  00c55	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c5a	83 c4 04	 add	 esp, 4

; 258  : 		g_count --;

  00c5d	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_count
  00c62	83 e8 01	 sub	 eax, 1
  00c65	a3 00 00 00 00	 mov	 DWORD PTR _g_count, eax

; 259  : 		//	TRACE("m_lpvFile Destroy: %d\n", g_count);
; 260  : 		m_lpvFile = NULL;

  00c6a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00c6d	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
$L192454:

; 261  : 	}
; 262  : 
; 263  : 	UINT nLenght = 0;

  00c74	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _nLenght$[ebp], 0

; 264  : 	if( memFile )

  00c7b	83 7d b4 00	 cmp	 DWORD PTR _memFile$[ebp], 0
  00c7f	0f 84 53 01 00
	00		 je	 $L192457

; 265  : 	{
; 266  : 		UINT nLenght = memFile->GetLength();

  00c85	8b 55 b4	 mov	 edx, DWORD PTR _memFile$[ebp]
  00c88	8b 02		 mov	 eax, DWORD PTR [edx]
  00c8a	8b f4		 mov	 esi, esp
  00c8c	8b 4d b4	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00c8f	ff 50 38	 call	 DWORD PTR [eax+56]
  00c92	3b f4		 cmp	 esi, esp
  00c94	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00c99	89 45 a8	 mov	 DWORD PTR _nLenght$192458[ebp], eax

; 267  : 	m_lpvFile = new unsigned char [nLenght];

  00c9c	68 0b 01 00 00	 push	 267			; 0000010bH
  00ca1	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00ca6	8b 4d a8	 mov	 ecx, DWORD PTR _nLenght$192458[ebp]
  00ca9	51		 push	 ecx
  00caa	e8 00 00 00 00	 call	 ??_U@YAPAXIPBDH@Z	; operator new[]
  00caf	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cb2	89 45 94	 mov	 DWORD PTR $T193481[ebp], eax
  00cb5	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00cb8	8b 45 94	 mov	 eax, DWORD PTR $T193481[ebp]
  00cbb	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 268  : 	g_count ++;

  00cbe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_count
  00cc4	83 c1 01	 add	 ecx, 1
  00cc7	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_count, ecx

; 269  : 
; 270  : 	memFile->Read(m_lpvFile, nLenght);

  00ccd	8b f4		 mov	 esi, esp
  00ccf	8b 55 a8	 mov	 edx, DWORD PTR _nLenght$192458[ebp]
  00cd2	52		 push	 edx
  00cd3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00cd6	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00cd9	51		 push	 ecx
  00cda	8b 55 b4	 mov	 edx, DWORD PTR _memFile$[ebp]
  00cdd	8b 02		 mov	 eax, DWORD PTR [edx]
  00cdf	8b 4d b4	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00ce2	ff 50 3c	 call	 DWORD PTR [eax+60]
  00ce5	3b f4		 cmp	 esi, esp
  00ce7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 271  : 
; 272  : 	memFile->Close();

  00cec	8b 4d b4	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00cef	8b 11		 mov	 edx, DWORD PTR [ecx]
  00cf1	8b f4		 mov	 esi, esp
  00cf3	8b 4d b4	 mov	 ecx, DWORD PTR _memFile$[ebp]
  00cf6	ff 52 54	 call	 DWORD PTR [edx+84]
  00cf9	3b f4		 cmp	 esi, esp
  00cfb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 273  : 
; 274  : 	delete memFile;

  00d00	8b 45 b4	 mov	 eax, DWORD PTR _memFile$[ebp]
  00d03	89 45 8c	 mov	 DWORD PTR $T193483[ebp], eax
  00d06	8b 4d 8c	 mov	 ecx, DWORD PTR $T193483[ebp]
  00d09	89 4d 90	 mov	 DWORD PTR $T193482[ebp], ecx
  00d0c	83 7d 90 00	 cmp	 DWORD PTR $T193482[ebp], 0
  00d10	74 1e		 je	 SHORT $L193484
  00d12	8b f4		 mov	 esi, esp
  00d14	6a 01		 push	 1
  00d16	8b 55 90	 mov	 edx, DWORD PTR $T193482[ebp]
  00d19	8b 02		 mov	 eax, DWORD PTR [edx]
  00d1b	8b 4d 90	 mov	 ecx, DWORD PTR $T193482[ebp]
  00d1e	ff 50 04	 call	 DWORD PTR [eax+4]
  00d21	3b f4		 cmp	 esi, esp
  00d23	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d28	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv170[ebp], eax
  00d2e	eb 0a		 jmp	 SHORT $L193485
$L193484:
  00d30	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv170[ebp], 0
$L193485:

; 275  : 
; 276  : 	if(((LPBITMAPFILEHEADER) m_lpvFile)->bfType != 0x4d42) {

  00d3a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00d3d	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00d40	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00d43	3d 42 4d 00 00	 cmp	 eax, 19778		; 00004d42H
  00d48	74 47		 je	 SHORT $L192464

; 277  : 		AfxMessageBox("Invalid bitmap file");

  00d4a	6a 00		 push	 0
  00d4c	6a 00		 push	 0
  00d4e	68 00 00 00 00	 push	 OFFSET FLAT:$SG192465
  00d53	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 278  : 		DetachMapFile();

  00d58	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00d5b	e8 00 00 00 00	 call	 ?DetachMapFile@CDib@@AAEXXZ ; CDib::DetachMapFile

; 279  : 		return FALSE;

  00d60	c7 45 88 00 00
	00 00		 mov	 DWORD PTR $T193486[ebp], 0
  00d67	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00d6b	8b f4		 mov	 esi, esp
  00d6d	8d 4d c0	 lea	 ecx, DWORD PTR _str$[ebp]
  00d70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00d76	3b f4		 cmp	 esi, esp
  00d78	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d7d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d84	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00d87	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00d8c	8b 45 88	 mov	 eax, DWORD PTR $T193486[ebp]
  00d8f	eb 76		 jmp	 SHORT $L192438
$L192464:

; 280  : 	}
; 281  : 	AttachMemory((LPBYTE) m_lpvFile + sizeof(BITMAPFILEHEADER));

  00d91	6a 00		 push	 0
  00d93	6a 00		 push	 0
  00d95	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00d98	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00d9b	83 c2 0e	 add	 edx, 14			; 0000000eH
  00d9e	52		 push	 edx
  00d9f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00da2	e8 00 00 00 00	 call	 ?AttachMemory@CDib@@QAEHPAXH0@Z ; CDib::AttachMemory

; 282  : 	//	m_lpvFile = lpvFile;
; 283  : 	//	m_hFile = hFile;
; 284  : 	//
; 285  : 	//*(m_lpImage+100) = 5;
; 286  : 	return TRUE;

  00da7	c7 45 84 01 00
	00 00		 mov	 DWORD PTR $T193487[ebp], 1
  00dae	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00db2	8b f4		 mov	 esi, esp
  00db4	8d 4d c0	 lea	 ecx, DWORD PTR _str$[ebp]
  00db7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00dbd	3b f4		 cmp	 esi, esp
  00dbf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00dc4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00dcb	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00dce	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00dd3	8b 45 84	 mov	 eax, DWORD PTR $T193487[ebp]
  00dd6	eb 2f		 jmp	 SHORT $L192438
$L192457:

; 287  : 	}
; 288  : 	else
; 289  : 	{
; 290  : 		return FALSE;

  00dd8	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T193488[ebp], 0
  00ddf	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00de3	8b f4		 mov	 esi, esp
  00de5	8d 4d c0	 lea	 ecx, DWORD PTR _str$[ebp]
  00de8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00dee	3b f4		 cmp	 esi, esp
  00df0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00df5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00dfc	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00dff	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00e04	8b 45 80	 mov	 eax, DWORD PTR $T193488[ebp]
$L192438:

; 291  : 	}
; 292  : }

  00e07	52		 push	 edx
  00e08	8b cd		 mov	 ecx, ebp
  00e0a	50		 push	 eax
  00e0b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L193498
  00e11	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00e16	58		 pop	 eax
  00e17	5a		 pop	 edx
  00e18	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00e1b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00e22	5f		 pop	 edi
  00e23	5e		 pop	 esi
  00e24	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  00e2a	3b ec		 cmp	 ebp, esp
  00e2c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00e31	8b e5		 mov	 esp, ebp
  00e33	5d		 pop	 ebp
  00e34	c2 0c 00	 ret	 12			; 0000000cH
$L193498:
  00e37	03 00 00 00	 DD	 3
  00e3b	00 00 00 00	 DD	 $L193497
$L193497:
  00e3f	dc ff ff ff	 DD	 -36			; ffffffdcH
  00e43	10 00 00 00	 DD	 16			; 00000010H
  00e47	00 00 00 00	 DD	 $L193493
  00e4b	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00e4f	04 00 00 00	 DD	 4
  00e53	00 00 00 00	 DD	 $L193494
  00e57	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00e5b	04 00 00 00	 DD	 4
  00e5f	00 00 00 00	 DD	 $L193495
$L193495:
  00e63	6d		 DB	 109			; 0000006dH
  00e64	65		 DB	 101			; 00000065H
  00e65	6d		 DB	 109			; 0000006dH
  00e66	46		 DB	 70			; 00000046H
  00e67	69		 DB	 105			; 00000069H
  00e68	6c		 DB	 108			; 0000006cH
  00e69	65		 DB	 101			; 00000065H
  00e6a	00		 DB	 0
$L193494:
  00e6b	73		 DB	 115			; 00000073H
  00e6c	74		 DB	 116			; 00000074H
  00e6d	72		 DB	 114			; 00000072H
  00e6e	00		 DB	 0
$L193493:
  00e6f	66		 DB	 102			; 00000066H
  00e70	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L193489:
  0006c	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  0006f	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
$L193490:
  00074	8b f4		 mov	 esi, esp
  00076	8d 4d c0	 lea	 ecx, DWORD PTR _str$[ebp]
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0007f	3b f4		 cmp	 esi, esp
  00081	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z:
  00086	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193492
  0008b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z ENDP	; CDib::AttachMapFile2
PUBLIC	?AttachMapFile@CDib@@IAEHPBDH@Z			; CDib::AttachMapFile
xdata$x	SEGMENT
$T193513 DD	0ffffffffH
	DD	FLAT:$L193506
$T193508 DD	019930520H
	DD	01H
	DD	FLAT:$T193513
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T193505 = -64						; size = 4
$T193504 = -60						; size = 4
$T193503 = -56						; size = 4
$T193502 = -52						; size = 4
$T193501 = -48						; size = 4
_len$ = -44						; size = 4
_f$ = -36						; size = 16
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_strPathname$ = 8					; size = 4
_bShare$ = 12						; size = 4
?AttachMapFile@CDib@@IAEHPBDH@Z PROC NEAR		; CDib::AttachMapFile
; _this$ = ecx

; 294  : {

  00e80	55		 push	 ebp
  00e81	8b ec		 mov	 ebp, esp
  00e83	6a ff		 push	 -1
  00e85	68 00 00 00 00	 push	 __ehhandler$?AttachMapFile@CDib@@IAEHPBDH@Z
  00e8a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00e90	50		 push	 eax
  00e91	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00e98	83 ec 34	 sub	 esp, 52			; 00000034H
  00e9b	57		 push	 edi
  00e9c	51		 push	 ecx
  00e9d	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  00ea0	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00ea5	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00eaa	f3 ab		 rep stosd
  00eac	59		 pop	 ecx
  00ead	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 295  : 	//// if we open the same file twice, Windows treats it as 2 separate files
; 296  : 	//// doesn't work with rare BMP files where # palette entries > biClrUsed
; 297  : 	////HANDLE hFile = ::CreateFile(strPathname, GENERIC_WRITE | GENERIC_READ,
; 298  : 	////	bShare ? FILE_SHARE_READ : 0,
; 299  : 	////	NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
; 300  : 	//HANDLE hFile = ::CreateFile(strPathname, GENERIC_READ|GENERIC_WRITE,
; 301  : 	//	FILE_SHARE_WRITE|FILE_SHARE_READ,	NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
; 302  : 	//ASSERT(hFile != INVALID_HANDLE_VALUE);
; 303  : 	//DWORD dwFileSize = ::GetFileSize(hFile, NULL);
; 304  : 	////HANDLE hMap = ::CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
; 305  : 	//HANDLE hMap = ::CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
; 306  : 	//
; 307  : 	//DWORD dwErr = ::GetLastError();
; 308  : 	//if(hMap == NULL) {
; 309  : 	//	AfxMessageBox("Empty bitmap file");
; 310  : 	//	AfxMessageBox(CString(strPathname));
; 311  : 	//	return FALSE;
; 312  : 	//}
; 313  : 	////LPVOID lpvFile = ::MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0); // map whole file
; 314  : 	//LPVOID lpvFile = ::MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0); // map whole file
; 315  : 	CFile f ;

  00eb0	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00eb3	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile
  00eb8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 316  : 
; 317  : 	if(!f.Open(strPathname, CFile::modeRead))

  00ebf	6a 00		 push	 0
  00ec1	6a 00		 push	 0
  00ec3	8b 45 08	 mov	 eax, DWORD PTR _strPathname$[ebp]
  00ec6	50		 push	 eax
  00ec7	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00eca	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  00ecf	85 c0		 test	 eax, eax
  00ed1	75 1e		 jne	 SHORT $L192478

; 318  : 		return false;

  00ed3	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T193501[ebp], 0
  00eda	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ee1	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00ee4	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00ee9	8b 45 d0	 mov	 eax, DWORD PTR $T193501[ebp]
  00eec	e9 ff 00 00 00	 jmp	 $L192476
$L192478:

; 319  : 
; 320  : 	int len = (int)f.GetLength(); 

  00ef1	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00ef4	e8 00 00 00 00	 call	 ?GetLength@CFile@@UBE_KXZ ; CFile::GetLength
  00ef9	89 45 d4	 mov	 DWORD PTR _len$[ebp], eax

; 321  : 
; 322  : 	if(m_lpvFile != NULL)

  00efc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00eff	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  00f03	74 2e		 je	 SHORT $L192482

; 323  : 	{
; 324  : 		delete m_lpvFile;

  00f05	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00f08	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00f0b	89 45 cc	 mov	 DWORD PTR $T193502[ebp], eax
  00f0e	8b 4d cc	 mov	 ecx, DWORD PTR $T193502[ebp]
  00f11	51		 push	 ecx
  00f12	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00f17	83 c4 04	 add	 esp, 4

; 325  : 		g_count --;

  00f1a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_count
  00f20	83 ea 01	 sub	 edx, 1
  00f23	89 15 00 00 00
	00		 mov	 DWORD PTR _g_count, edx

; 326  : 	//	TRACE("m_lpvFile Destroy: %d\n", g_count);
; 327  : 		m_lpvFile = NULL;

  00f29	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00f2c	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
$L192482:

; 328  : 	}
; 329  : 	m_lpvFile = new unsigned char [len];

  00f33	68 49 01 00 00	 push	 329			; 00000149H
  00f38	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00f3d	8b 4d d4	 mov	 ecx, DWORD PTR _len$[ebp]
  00f40	51		 push	 ecx
  00f41	e8 00 00 00 00	 call	 ??_U@YAPAXIPBDH@Z	; operator new[]
  00f46	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f49	89 45 c8	 mov	 DWORD PTR $T193503[ebp], eax
  00f4c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00f4f	8b 45 c8	 mov	 eax, DWORD PTR $T193503[ebp]
  00f52	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 330  : 	g_count ++;

  00f55	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_count
  00f5b	83 c1 01	 add	 ecx, 1
  00f5e	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_count, ecx

; 331  : 	//TRACE("m_lpvFile Allocate: %d\n", g_count);
; 332  : 	f.Read(m_lpvFile, len);

  00f64	8b 55 d4	 mov	 edx, DWORD PTR _len$[ebp]
  00f67	52		 push	 edx
  00f68	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00f6b	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00f6e	51		 push	 ecx
  00f6f	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00f72	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read

; 333  : 
; 334  : 	f.Close();

  00f77	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00f7a	e8 00 00 00 00	 call	 ?Close@CFile@@UAEXXZ	; CFile::Close

; 335  : 
; 336  : 	if(((LPBITMAPFILEHEADER) m_lpvFile)->bfType != 0x4d42) {

  00f7f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00f82	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00f85	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00f88	81 f9 42 4d 00
	00		 cmp	 ecx, 19778		; 00004d42H
  00f8e	74 31		 je	 SHORT $L192487

; 337  : 		AfxMessageBox("Invalid bitmap file");

  00f90	6a 00		 push	 0
  00f92	6a 00		 push	 0
  00f94	68 00 00 00 00	 push	 OFFSET FLAT:$SG192488
  00f99	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 338  : 		DetachMapFile();

  00f9e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00fa1	e8 00 00 00 00	 call	 ?DetachMapFile@CDib@@AAEXXZ ; CDib::DetachMapFile

; 339  : 		return FALSE;

  00fa6	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T193504[ebp], 0
  00fad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00fb4	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00fb7	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00fbc	8b 45 c4	 mov	 eax, DWORD PTR $T193504[ebp]
  00fbf	eb 2f		 jmp	 SHORT $L192476
$L192487:

; 340  : 	}
; 341  : 	AttachMemory((LPBYTE) m_lpvFile + sizeof(BITMAPFILEHEADER));

  00fc1	6a 00		 push	 0
  00fc3	6a 00		 push	 0
  00fc5	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00fc8	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00fcb	83 c0 0e	 add	 eax, 14			; 0000000eH
  00fce	50		 push	 eax
  00fcf	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00fd2	e8 00 00 00 00	 call	 ?AttachMemory@CDib@@QAEHPAXH0@Z ; CDib::AttachMemory

; 342  : //	m_lpvFile = lpvFile;
; 343  : //	m_hFile = hFile;
; 344  : //
; 345  : 	//*(m_lpImage+100) = 5;
; 346  : 	return TRUE;

  00fd7	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR $T193505[ebp], 1
  00fde	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00fe5	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00fe8	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00fed	8b 45 c0	 mov	 eax, DWORD PTR $T193505[ebp]
$L192476:

; 347  : }

  00ff0	52		 push	 edx
  00ff1	8b cd		 mov	 ecx, ebp
  00ff3	50		 push	 eax
  00ff4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L193512
  00ffa	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00fff	58		 pop	 eax
  01000	5a		 pop	 edx
  01001	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01004	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0100b	5f		 pop	 edi
  0100c	83 c4 40	 add	 esp, 64			; 00000040H
  0100f	3b ec		 cmp	 ebp, esp
  01011	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01016	8b e5		 mov	 esp, ebp
  01018	5d		 pop	 ebp
  01019	c2 08 00	 ret	 8
$L193512:
  0101c	01 00 00 00	 DD	 1
  01020	00 00 00 00	 DD	 $L193511
$L193511:
  01024	dc ff ff ff	 DD	 -36			; ffffffdcH
  01028	10 00 00 00	 DD	 16			; 00000010H
  0102c	00 00 00 00	 DD	 $L193509
$L193509:
  01030	66		 DB	 102			; 00000066H
  01031	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L193506:
  00090	8d 4d dc	 lea	 ecx, DWORD PTR _f$[ebp]
  00093	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
__ehhandler$?AttachMapFile@CDib@@IAEHPBDH@Z:
  00098	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193508
  0009d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AttachMapFile@CDib@@IAEHPBDH@Z ENDP			; CDib::AttachMapFile
PUBLIC	?CopyToMapFile@CDib@@IAEHPBD@Z			; CDib::CopyToMapFile
PUBLIC	?MakePalette@CDib@@IAEHXZ			; CDib::MakePalette
EXTRN	__imp__CreateFileA@28:NEAR
EXTRN	__imp__MapViewOfFile@20:NEAR
EXTRN	?AfxAssertFailedLine@@YGHPBDH@Z:NEAR		; AfxAssertFailedLine
EXTRN	__imp__CreateFileMappingA@24:NEAR
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_dwSizeImage$ = -60					; size = 4
_lpBMIH$ = -56						; size = 4
_lpbCurrent$ = -52					; size = 4
_lpvFile$ = -48						; size = 4
_dwErr$ = -44						; size = 4
_hMap$ = -40						; size = 4
_nSize$ = -36						; size = 4
_hFile$ = -32						; size = 4
_bmfh$ = -24						; size = 14
_this$ = -4						; size = 4
_strPathname$ = 8					; size = 4
?CopyToMapFile@CDib@@IAEHPBD@Z PROC NEAR		; CDib::CopyToMapFile
; _this$ = ecx

; 350  : {

  01040	55		 push	 ebp
  01041	8b ec		 mov	 ebp, esp
  01043	83 ec 3c	 sub	 esp, 60			; 0000003cH
  01046	56		 push	 esi
  01047	57		 push	 edi
  01048	51		 push	 ecx
  01049	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  0104c	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  01051	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  01056	f3 ab		 rep stosd
  01058	59		 pop	 ecx
  01059	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 351  : 	// copies DIB to a new file, releases prior pointers
; 352  : 	// if you previously used CreateSection, the HBITMAP will be NULL (and unusable)
; 353  : 	BITMAPFILEHEADER bmfh;
; 354  : 	bmfh.bfType = 0x4d42;  // 'BM'

  0105c	66 c7 45 e8 42
	4d		 mov	 WORD PTR _bmfh$[ebp], 19778 ; 00004d42H

; 355  : 	bmfh.bfSize = m_dwSizeImage + sizeof(BITMAPINFOHEADER) +
; 356  : 			sizeof(RGBQUAD) * m_nColorTableEntries + sizeof(BITMAPFILEHEADER);

  01062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01065	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  01068	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0106b	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0106e	8d 4c 81 36	 lea	 ecx, DWORD PTR [ecx+eax*4+54]
  01072	89 4d ea	 mov	 DWORD PTR _bmfh$[ebp+2], ecx

; 357  : 	// meaning of bfSize open to interpretation
; 358  : 	bmfh.bfReserved1 = bmfh.bfReserved2 = 0;

  01075	66 c7 45 f0 00
	00		 mov	 WORD PTR _bmfh$[ebp+8], 0
  0107b	66 8b 55 f0	 mov	 dx, WORD PTR _bmfh$[ebp+8]
  0107f	66 89 55 ee	 mov	 WORD PTR _bmfh$[ebp+6], dx

; 359  : 	bmfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) +
; 360  : 			sizeof(RGBQUAD) * m_nColorTableEntries;	

  01083	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01086	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01089	8d 14 8d 36 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+54]
  01090	89 55 f2	 mov	 DWORD PTR _bmfh$[ebp+10], edx

; 361  : 	HANDLE hFile = ::CreateFile(strPathname, GENERIC_WRITE | GENERIC_READ, 0, NULL,
; 362  : 		CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  01093	8b f4		 mov	 esi, esp
  01095	6a 00		 push	 0
  01097	68 80 00 00 00	 push	 128			; 00000080H
  0109c	6a 02		 push	 2
  0109e	6a 00		 push	 0
  010a0	6a 00		 push	 0
  010a2	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  010a7	8b 45 08	 mov	 eax, DWORD PTR _strPathname$[ebp]
  010aa	50		 push	 eax
  010ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  010b1	3b f4		 cmp	 esi, esp
  010b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  010b8	89 45 e0	 mov	 DWORD PTR _hFile$[ebp], eax

; 363  : 	ASSERT(hFile != INVALID_HANDLE_VALUE);

  010bb	83 7d e0 ff	 cmp	 DWORD PTR _hFile$[ebp], -1
  010bf	75 14		 jne	 SHORT $L193515
  010c1	68 6b 01 00 00	 push	 363			; 0000016bH
  010c6	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  010cb	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  010d0	85 c0		 test	 eax, eax
  010d2	74 01		 je	 SHORT $L193515
  010d4	cc		 int	 3
$L193515:

; 364  : 	int nSize =  sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) +
; 365  : 				sizeof(RGBQUAD) * m_nColorTableEntries +  m_dwSizeImage;

  010d5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  010d8	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  010db	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010de	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  010e1	8d 44 82 36	 lea	 eax, DWORD PTR [edx+eax*4+54]
  010e5	89 45 dc	 mov	 DWORD PTR _nSize$[ebp], eax

; 366  : 	HANDLE hMap = ::CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, nSize, NULL);

  010e8	8b f4		 mov	 esi, esp
  010ea	6a 00		 push	 0
  010ec	8b 4d dc	 mov	 ecx, DWORD PTR _nSize$[ebp]
  010ef	51		 push	 ecx
  010f0	6a 00		 push	 0
  010f2	6a 04		 push	 4
  010f4	6a 00		 push	 0
  010f6	8b 55 e0	 mov	 edx, DWORD PTR _hFile$[ebp]
  010f9	52		 push	 edx
  010fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileMappingA@24
  01100	3b f4		 cmp	 esi, esp
  01102	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01107	89 45 d8	 mov	 DWORD PTR _hMap$[ebp], eax

; 367  : 	DWORD dwErr = ::GetLastError();

  0110a	8b f4		 mov	 esi, esp
  0110c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  01112	3b f4		 cmp	 esi, esp
  01114	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01119	89 45 d4	 mov	 DWORD PTR _dwErr$[ebp], eax

; 368  : 	ASSERT(hMap != NULL);

  0111c	83 7d d8 00	 cmp	 DWORD PTR _hMap$[ebp], 0
  01120	75 14		 jne	 SHORT $L193516
  01122	68 70 01 00 00	 push	 368			; 00000170H
  01127	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  0112c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  01131	85 c0		 test	 eax, eax
  01133	74 01		 je	 SHORT $L193516
  01135	cc		 int	 3
$L193516:

; 369  : 	LPVOID lpvFile = ::MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0); // map whole file

  01136	8b f4		 mov	 esi, esp
  01138	6a 00		 push	 0
  0113a	6a 00		 push	 0
  0113c	6a 00		 push	 0
  0113e	6a 02		 push	 2
  01140	8b 4d d8	 mov	 ecx, DWORD PTR _hMap$[ebp]
  01143	51		 push	 ecx
  01144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapViewOfFile@20
  0114a	3b f4		 cmp	 esi, esp
  0114c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01151	89 45 d0	 mov	 DWORD PTR _lpvFile$[ebp], eax

; 370  : 	ASSERT(lpvFile != NULL);

  01154	83 7d d0 00	 cmp	 DWORD PTR _lpvFile$[ebp], 0
  01158	75 14		 jne	 SHORT $L193517
  0115a	68 72 01 00 00	 push	 370			; 00000172H
  0115f	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  01164	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  01169	85 c0		 test	 eax, eax
  0116b	74 01		 je	 SHORT $L193517
  0116d	cc		 int	 3
$L193517:

; 371  : 	LPBYTE lpbCurrent = (LPBYTE) lpvFile;

  0116e	8b 45 d0	 mov	 eax, DWORD PTR _lpvFile$[ebp]
  01171	89 45 cc	 mov	 DWORD PTR _lpbCurrent$[ebp], eax

; 372  : 	memcpy(lpbCurrent, &bmfh, sizeof(BITMAPFILEHEADER)); // file header

  01174	6a 0e		 push	 14			; 0000000eH
  01176	8d 4d e8	 lea	 ecx, DWORD PTR _bmfh$[ebp]
  01179	51		 push	 ecx
  0117a	8b 55 cc	 mov	 edx, DWORD PTR _lpbCurrent$[ebp]
  0117d	52		 push	 edx
  0117e	e8 00 00 00 00	 call	 _memcpy
  01183	83 c4 0c	 add	 esp, 12			; 0000000cH

; 373  : 	lpbCurrent += sizeof(BITMAPFILEHEADER);

  01186	8b 45 cc	 mov	 eax, DWORD PTR _lpbCurrent$[ebp]
  01189	83 c0 0e	 add	 eax, 14			; 0000000eH
  0118c	89 45 cc	 mov	 DWORD PTR _lpbCurrent$[ebp], eax

; 374  : 	LPBITMAPINFOHEADER lpBMIH = (LPBITMAPINFOHEADER) lpbCurrent;

  0118f	8b 4d cc	 mov	 ecx, DWORD PTR _lpbCurrent$[ebp]
  01192	89 4d c8	 mov	 DWORD PTR _lpBMIH$[ebp], ecx

; 375  : 	memcpy(lpbCurrent, m_lpBMIH,
; 376  : 		sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * m_nColorTableEntries); // info

  01195	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01198	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0119b	8d 0c 85 28 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+40]
  011a2	51		 push	 ecx
  011a3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  011a6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  011a9	50		 push	 eax
  011aa	8b 4d cc	 mov	 ecx, DWORD PTR _lpbCurrent$[ebp]
  011ad	51		 push	 ecx
  011ae	e8 00 00 00 00	 call	 _memcpy
  011b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 377  : 	lpbCurrent += sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * m_nColorTableEntries;

  011b6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  011b9	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  011bc	8b 4d cc	 mov	 ecx, DWORD PTR _lpbCurrent$[ebp]
  011bf	8d 54 81 28	 lea	 edx, DWORD PTR [ecx+eax*4+40]
  011c3	89 55 cc	 mov	 DWORD PTR _lpbCurrent$[ebp], edx

; 378  : 	memcpy(lpbCurrent, m_lpImage, m_dwSizeImage); // bit image

  011c6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011c9	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  011cc	51		 push	 ecx
  011cd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  011d0	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  011d3	50		 push	 eax
  011d4	8b 4d cc	 mov	 ecx, DWORD PTR _lpbCurrent$[ebp]
  011d7	51		 push	 ecx
  011d8	e8 00 00 00 00	 call	 _memcpy
  011dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 379  : 	DWORD dwSizeImage = m_dwSizeImage;

  011e0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  011e3	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  011e6	89 45 c4	 mov	 DWORD PTR _dwSizeImage$[ebp], eax

; 380  : 	Empty();

  011e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011ec	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 381  : 	m_dwSizeImage = dwSizeImage;

  011f1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011f4	8b 55 c4	 mov	 edx, DWORD PTR _dwSizeImage$[ebp]
  011f7	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 382  : 	m_nBmihAlloc = m_nImageAlloc = noAlloc;

  011fa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011fd	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  01204	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01207	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 383  : 	m_lpBMIH = lpBMIH;

  0120e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01211	8b 45 c8	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  01214	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 384  : 	m_lpImage = lpbCurrent;

  01217	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0121a	8b 55 cc	 mov	 edx, DWORD PTR _lpbCurrent$[ebp]
  0121d	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 385  : 	m_hFile = hFile;

  01220	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01223	8b 4d e0	 mov	 ecx, DWORD PTR _hFile$[ebp]
  01226	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 386  : 	m_hMap = hMap;

  01229	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0122c	8b 45 d8	 mov	 eax, DWORD PTR _hMap$[ebp]
  0122f	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 387  : 	m_lpvFile = lpvFile;

  01232	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01235	8b 55 d0	 mov	 edx, DWORD PTR _lpvFile$[ebp]
  01238	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 388  : 	ComputePaletteSize(m_lpBMIH->biBitCount);

  0123b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0123e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01241	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  01245	52		 push	 edx
  01246	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01249	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 389  : 	ComputeMetrics();

  0124e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01251	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 390  : 	MakePalette();

  01256	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01259	e8 00 00 00 00	 call	 ?MakePalette@CDib@@IAEHXZ ; CDib::MakePalette

; 391  : 	return TRUE;

  0125e	b8 01 00 00 00	 mov	 eax, 1

; 392  : }

  01263	52		 push	 edx
  01264	8b cd		 mov	 ecx, ebp
  01266	50		 push	 eax
  01267	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L193520
  0126d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  01272	58		 pop	 eax
  01273	5a		 pop	 edx
  01274	5f		 pop	 edi
  01275	5e		 pop	 esi
  01276	83 c4 3c	 add	 esp, 60			; 0000003cH
  01279	3b ec		 cmp	 ebp, esp
  0127b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01280	8b e5		 mov	 esp, ebp
  01282	5d		 pop	 ebp
  01283	c2 04 00	 ret	 4
$L193520:
  01286	01 00 00 00	 DD	 1
  0128a	00 00 00 00	 DD	 $L193519
$L193519:
  0128e	e8 ff ff ff	 DD	 -24			; ffffffe8H
  01292	0e 00 00 00	 DD	 14			; 0000000eH
  01296	00 00 00 00	 DD	 $L193518
$L193518:
  0129a	62		 DB	 98			; 00000062H
  0129b	6d		 DB	 109			; 0000006dH
  0129c	66		 DB	 102			; 00000066H
  0129d	68		 DB	 104			; 00000068H
  0129e	00		 DB	 0
?CopyToMapFile@CDib@@IAEHPBD@Z ENDP			; CDib::CopyToMapFile
_TEXT	ENDS
PUBLIC	??_R0PAVCException@@@8				; CException * `RTTI Type Descriptor'
EXTRN	?Delete@CException@@QAEXXZ:NEAR			; CException::Delete
xdata$x	SEGMENT
$T193533 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T193535 DD	00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0ffffffe4H
	DD	FLAT:$L193524
$T193534 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T193535
$T193528 DD	019930520H
	DD	02H
	DD	FLAT:$T193533
	DD	01H
	DD	FLAT:$T193534
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0PAVCException@@@8
_DATA	SEGMENT
??_R0PAVCException@@@8 DD FLAT:??_7type_info@@6B@	; CException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCException@@', 00H
	ORG $-25
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.PAVCException@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
_TEXT	SEGMENT
$T193522 = -36						; size = 4
_pe$192540 = -28					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_lpvMem$ = 8						; size = 4
_bMustDelete$ = 12					; size = 4
_hGlobal$ = 16						; size = 4
?AttachMemory@CDib@@QAEHPAXH0@Z PROC NEAR		; CDib::AttachMemory
; _this$ = ecx

; 395  : {

  012a0	55		 push	 ebp
  012a1	8b ec		 mov	 ebp, esp
  012a3	6a ff		 push	 -1
  012a5	68 00 00 00 00	 push	 __ehhandler$?AttachMemory@CDib@@QAEHPAXH0@Z
  012aa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  012b0	50		 push	 eax
  012b1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  012b8	51		 push	 ecx
  012b9	83 ec 14	 sub	 esp, 20			; 00000014H
  012bc	53		 push	 ebx
  012bd	56		 push	 esi
  012be	57		 push	 edi
  012bf	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  012c4	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  012c7	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  012ca	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  012cd	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  012d0	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  012d3	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  012d6	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 	// assumes contiguous BITMAPINFOHEADER, color table, image
; 397  : 	// color table could be zero length
; 398  : 	Empty();

  012d9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  012dc	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 399  : 	m_hGlobal = hGlobal;

  012e1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  012e4	8b 4d 10	 mov	 ecx, DWORD PTR _hGlobal$[ebp]
  012e7	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 400  : 	if(bMustDelete == FALSE) {

  012ea	83 7d 0c 00	 cmp	 DWORD PTR _bMustDelete$[ebp], 0
  012ee	75 0c		 jne	 SHORT $L192534

; 401  : 		m_nBmihAlloc = noAlloc;

  012f0	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  012f3	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 402  : 	}
; 403  : 	else {

  012fa	eb 10		 jmp	 SHORT $L192535
$L192534:

; 404  : 		m_nBmihAlloc = ((hGlobal == NULL) ? crtAlloc : heapAlloc);

  012fc	33 c0		 xor	 eax, eax
  012fe	83 7d 10 00	 cmp	 DWORD PTR _hGlobal$[ebp], 0
  01302	0f 95 c0	 setne	 al
  01305	40		 inc	 eax
  01306	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01309	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$L192535:

; 405  : 	}
; 406  : 	try {

  0130c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 407  : 		m_lpBMIH = (LPBITMAPINFOHEADER) lpvMem;

  01313	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  01316	8b 45 08	 mov	 eax, DWORD PTR _lpvMem$[ebp]
  01319	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 408  : 		ComputeMetrics();

  0131c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0131f	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 409  : 		ComputePaletteSize(m_lpBMIH->biBitCount);

  01324	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01327	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0132a	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  0132e	50		 push	 eax
  0132f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01332	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 410  : 		m_lpImage = (LPBYTE) m_lpvColorTable + sizeof(RGBQUAD) * m_nColorTableEntries;

  01337	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0133a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0133d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01340	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01343	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  01346	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01349	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0134c	eb 23		 jmp	 SHORT $L193523
$L193524:

; 411  : 		//MakePalette();
; 412  : 	}
; 413  : 	catch(CException* pe) {
; 414  : 		AfxMessageBox("AttachMemory error");

  0134e	6a 00		 push	 0
  01350	6a 00		 push	 0
  01352	68 00 00 00 00	 push	 OFFSET FLAT:$SG192541
  01357	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 415  : 		pe->Delete();

  0135c	8b 4d e4	 mov	 ecx, DWORD PTR _pe$192540[ebp]
  0135f	e8 00 00 00 00	 call	 ?Delete@CException@@QAEXXZ ; CException::Delete

; 416  : 		return FALSE;

  01364	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T193522[ebp], 0
  0136b	b8 00 00 00 00	 mov	 eax, $L193526
  01370	c3		 ret	 0
$L193523:

; 417  : 	}

  01371	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 418  : 	return TRUE;

  01378	eb 05		 jmp	 SHORT $L193525
$L193526:

; 416  : 		return FALSE;

  0137a	8b 45 dc	 mov	 eax, DWORD PTR $T193522[ebp]
  0137d	eb 05		 jmp	 SHORT $L192533
$L193525:

; 418  : 	return TRUE;

  0137f	b8 01 00 00 00	 mov	 eax, 1
$L192533:

; 419  : }

  01384	52		 push	 edx
  01385	8b cd		 mov	 ecx, ebp
  01387	50		 push	 eax
  01388	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L193532
  0138e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  01393	58		 pop	 eax
  01394	5a		 pop	 edx
  01395	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  01398	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0139f	5f		 pop	 edi
  013a0	5e		 pop	 esi
  013a1	5b		 pop	 ebx
  013a2	83 c4 24	 add	 esp, 36			; 00000024H
  013a5	3b ec		 cmp	 ebp, esp
  013a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  013ac	8b e5		 mov	 esp, ebp
  013ae	5d		 pop	 ebp
  013af	c2 0c 00	 ret	 12			; 0000000cH
$L193532:
  013b2	01 00 00 00	 DD	 1
  013b6	00 00 00 00	 DD	 $L193531
$L193531:
  013ba	e4 ff ff ff	 DD	 -28			; ffffffe4H
  013be	04 00 00 00	 DD	 4
  013c2	00 00 00 00	 DD	 $L193529
$L193529:
  013c6	70		 DB	 112			; 00000070H
  013c7	65		 DB	 101			; 00000065H
  013c8	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$?AttachMemory@CDib@@QAEHPAXH0@Z:
  000a2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193528
  000a7	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AttachMemory@CDib@@QAEHPAXH0@Z ENDP			; CDib::AttachMemory
PUBLIC	?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z	; CDib::CreateBitmap
PUBLIC	?DrawTransParent@CDib@@IAEIPAVCDC@@VCRect@@1K@Z	; CDib::DrawTransParent
EXTRN	__imp__SelectObject@8:NEAR
EXTRN	__imp__CreateCompatibleDC@4:NEAR
EXTRN	__imp__TransparentBlt@44:NEAR
EXTRN	__imp__DeleteDC@4:NEAR
EXTRN	?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ:NEAR		; CDC::GetSafeHdc
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hdcCompatible$192552 = -8				; size = 4
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
_rcSrc$ = 12						; size = 16
_rcDst$ = 28						; size = 16
_color$ = 44						; size = 4
?DrawTransParent@CDib@@IAEIPAVCDC@@VCRect@@1K@Z PROC NEAR ; CDib::DrawTransParent
; _this$ = ecx

; 422  : {

  013d0	55		 push	 ebp
  013d1	8b ec		 mov	 ebp, esp
  013d3	83 ec 08	 sub	 esp, 8
  013d6	56		 push	 esi
  013d7	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  013de	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  013e5	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 423  : 	if(this->m_hBitmap == NULL)

  013e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013eb	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  013ef	75 0c		 jne	 SHORT $L192550

; 424  : 		this->CreateBitmap(pDC);

  013f1	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  013f4	51		 push	 ecx
  013f5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013f8	e8 00 00 00 00	 call	 ?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ; CDib::CreateBitmap
$L192550:

; 425  : 	
; 426  : 	if(true)

  013fd	ba 01 00 00 00	 mov	 edx, 1
  01402	85 d2		 test	 edx, edx
  01404	0f 84 9f 00 00
	00		 je	 $L192549

; 427  : 	{
; 428  : 		HDC  hdcCompatible = CreateCompatibleDC(pDC->GetSafeHdc()); 

  0140a	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0140d	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01412	8b f4		 mov	 esi, esp
  01414	50		 push	 eax
  01415	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  0141b	3b f4		 cmp	 esi, esp
  0141d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01422	89 45 f8	 mov	 DWORD PTR _hdcCompatible$192552[ebp], eax

; 429  : 		SelectObject(hdcCompatible, m_hBitmap);

  01425	8b f4		 mov	 esi, esp
  01427	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0142a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0142d	51		 push	 ecx
  0142e	8b 55 f8	 mov	 edx, DWORD PTR _hdcCompatible$192552[ebp]
  01431	52		 push	 edx
  01432	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01438	3b f4		 cmp	 esi, esp
  0143a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 430  : 
; 431  : 		::TransparentBlt(pDC->m_hDC, rcDst.left, rcDst.top, rcDst.Width(), rcDst.Height(),hdcCompatible,
; 432  : 			rcSrc.left, rcSrc.top, rcSrc.Width(), rcSrc.Height(), color);

  0143f	8b f4		 mov	 esi, esp
  01441	8b 45 2c	 mov	 eax, DWORD PTR _color$[ebp]
  01444	50		 push	 eax
  01445	8d 4d 0c	 lea	 ecx, DWORD PTR _rcSrc$[ebp]
  01448	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0144d	50		 push	 eax
  0144e	8d 4d 0c	 lea	 ecx, DWORD PTR _rcSrc$[ebp]
  01451	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  01456	50		 push	 eax
  01457	8b 4d 10	 mov	 ecx, DWORD PTR _rcSrc$[ebp+4]
  0145a	51		 push	 ecx
  0145b	8b 55 0c	 mov	 edx, DWORD PTR _rcSrc$[ebp]
  0145e	52		 push	 edx
  0145f	8b 45 f8	 mov	 eax, DWORD PTR _hdcCompatible$192552[ebp]
  01462	50		 push	 eax
  01463	8d 4d 1c	 lea	 ecx, DWORD PTR _rcDst$[ebp]
  01466	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0146b	50		 push	 eax
  0146c	8d 4d 1c	 lea	 ecx, DWORD PTR _rcDst$[ebp]
  0146f	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  01474	50		 push	 eax
  01475	8b 4d 20	 mov	 ecx, DWORD PTR _rcDst$[ebp+4]
  01478	51		 push	 ecx
  01479	8b 55 1c	 mov	 edx, DWORD PTR _rcDst$[ebp]
  0147c	52		 push	 edx
  0147d	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  01480	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01483	51		 push	 ecx
  01484	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TransparentBlt@44
  0148a	3b f4		 cmp	 esi, esp
  0148c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 433  : 		DeleteDC(hdcCompatible);

  01491	8b f4		 mov	 esi, esp
  01493	8b 55 f8	 mov	 edx, DWORD PTR _hdcCompatible$192552[ebp]
  01496	52		 push	 edx
  01497	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  0149d	3b f4		 cmp	 esi, esp
  0149f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 434  : 		return true;

  014a4	b8 01 00 00 00	 mov	 eax, 1
$L192549:

; 435  : 	}
; 436  : 	/*else
; 437  : 	{
; 438  : 		if(rcSrc.Width() == rcDst.Width() && rcSrc.Height() == rcDst.Height())
; 439  : 		{
; 440  : 			::BitBlt(pDC->m_hDC, rcDst.left, rcDst.top, rcDst.Width(), rcDst.Height() , m_hBitmap, rcSrc.left, rcSrc.top, SRCCOPY);
; 441  : 		}
; 442  : 		else
; 443  : 		{
; 444  : 			::StretchBlt(pDC->m_hDC, rcDst.left, rcDst.top, rcDst.Width(), rcDst.Height() , m_hBitmap, rcSrc.left, rcSrc.top,rcSrc.Width(), rcSrc.Height(), SRCCOPY);
; 445  : 		}
; 446  : 	}*/
; 447  : }

  014a9	5e		 pop	 esi
  014aa	83 c4 08	 add	 esp, 8
  014ad	3b ec		 cmp	 ebp, esp
  014af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  014b4	8b e5		 mov	 esp, ebp
  014b6	5d		 pop	 ebp
  014b7	c2 28 00	 ret	 40			; 00000028H
?DrawTransParent@CDib@@IAEIPAVCDC@@VCRect@@1K@Z ENDP	; CDib::DrawTransParent
_TEXT	ENDS
PUBLIC	?UsePalette@CDib@@IAEIPAVCDC@@H@Z		; CDib::UsePalette
EXTRN	__imp__RealizePalette@4:NEAR
EXTRN	__imp__SelectPalette@12:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hdc$ = -8						; size = 4
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
_bBackground$ = 12					; size = 4
?UsePalette@CDib@@IAEIPAVCDC@@H@Z PROC NEAR		; CDib::UsePalette
; _this$ = ecx

; 450  : {

  014c0	55		 push	 ebp
  014c1	8b ec		 mov	 ebp, esp
  014c3	83 ec 08	 sub	 esp, 8
  014c6	56		 push	 esi
  014c7	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  014ce	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  014d5	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 451  : 	if(m_hPalette == NULL) return 0;

  014d8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  014db	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  014df	75 04		 jne	 SHORT $L192558
  014e1	33 c0		 xor	 eax, eax
  014e3	eb 3c		 jmp	 SHORT $L192557
$L192558:

; 452  : 	HDC hdc = pDC->GetSafeHdc();

  014e5	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  014e8	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  014ed	89 45 f8	 mov	 DWORD PTR _hdc$[ebp], eax

; 453  : 	::SelectPalette(hdc, m_hPalette, bBackground);

  014f0	8b f4		 mov	 esi, esp
  014f2	8b 4d 0c	 mov	 ecx, DWORD PTR _bBackground$[ebp]
  014f5	51		 push	 ecx
  014f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  014f9	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  014fc	50		 push	 eax
  014fd	8b 4d f8	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01500	51		 push	 ecx
  01501	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  01507	3b f4		 cmp	 esi, esp
  01509	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 454  : 	return ::RealizePalette(hdc);

  0150e	8b f4		 mov	 esi, esp
  01510	8b 55 f8	 mov	 edx, DWORD PTR _hdc$[ebp]
  01513	52		 push	 edx
  01514	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RealizePalette@4
  0151a	3b f4		 cmp	 esi, esp
  0151c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L192557:

; 455  : }

  01521	5e		 pop	 esi
  01522	83 c4 08	 add	 esp, 8
  01525	3b ec		 cmp	 ebp, esp
  01527	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0152c	8b e5		 mov	 esp, ebp
  0152e	5d		 pop	 ebp
  0152f	c2 08 00	 ret	 8
?UsePalette@CDib@@IAEIPAVCDC@@H@Z ENDP			; CDib::UsePalette
_TEXT	ENDS
PUBLIC	?Draw@CDib@@IAEHPAVCDC@@VCPoint@@VCSize@@HKW4DrawMode@1@@Z ; CDib::Draw
EXTRN	__imp__StretchDIBits@52:NEAR
EXTRN	__imp__CreateCompatibleBitmap@12:NEAR
EXTRN	__imp__DeleteObject@4:NEAR
EXTRN	?SetStretchBltMode@CDC@@QAEHH@Z:NEAR		; CDC::SetStretchBltMode
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv319 = -80						; size = 4
tv308 = -76						; size = 4
tv297 = -72						; size = 4
tv233 = -68						; size = 4
tv227 = -64						; size = 4
_j$192605 = -60						; size = 4
_i$192601 = -56						; size = 4
_cy$192600 = -52					; size = 4
_cx$192599 = -48					; size = 4
_old$192595 = -44					; size = 4
_hbmScreen$192594 = -40					; size = 4
_hdcCompatible$192593 = -36				; size = 4
_old$192587 = -32					; size = 4
_hbmScreen$192586 = -28					; size = 4
_hdcCompatible$192585 = -24				; size = 4
_old$192579 = -20					; size = 4
_hbmScreen$192578 = -16					; size = 4
_hdcCompatible$192577 = -12				; size = 4
_hOldPalette$ = -8					; size = 4
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
_origin$ = 12						; size = 8
_size$ = 20						; size = 8
_IsBKTransparent$ = 28					; size = 4
_mask$ = 32						; size = 4
_mode$ = 36						; size = 4
?Draw@CDib@@IAEHPAVCDC@@VCPoint@@VCSize@@HKW4DrawMode@1@@Z PROC NEAR ; CDib::Draw
; _this$ = ecx

; 458  : {

  01540	55		 push	 ebp
  01541	8b ec		 mov	 ebp, esp
  01543	83 ec 50	 sub	 esp, 80			; 00000050H
  01546	56		 push	 esi
  01547	57		 push	 edi
  01548	51		 push	 ecx
  01549	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0154c	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  01551	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  01556	f3 ab		 rep stosd
  01558	59		 pop	 ecx
  01559	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 459  : 	if(m_lpBMIH == NULL) return FALSE;

  0155c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0155f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  01563	75 07		 jne	 SHORT $L192569
  01565	33 c0		 xor	 eax, eax
  01567	e9 b0 05 00 00	 jmp	 $L192568
$L192569:

; 460  : 	HPALETTE hOldPalette = NULL;

  0156c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hOldPalette$[ebp], 0

; 461  : 	if(m_hPalette != NULL) {

  01573	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01576	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  0157a	74 24		 je	 SHORT $L192571

; 462  : 		hOldPalette = ::SelectPalette(pDC->GetSafeHdc(), m_hPalette, TRUE);

  0157c	8b f4		 mov	 esi, esp
  0157e	6a 01		 push	 1
  01580	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01583	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  01586	50		 push	 eax
  01587	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0158a	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0158f	50		 push	 eax
  01590	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  01596	3b f4		 cmp	 esi, esp
  01598	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0159d	89 45 f8	 mov	 DWORD PTR _hOldPalette$[ebp], eax
$L192571:

; 463  : 	}
; 464  : 	pDC->SetStretchBltMode(COLORONCOLOR);

  015a0	6a 03		 push	 3
  015a2	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  015a5	e8 00 00 00 00	 call	 ?SetStretchBltMode@CDC@@QAEHH@Z ; CDC::SetStretchBltMode

; 465  : 
; 466  : 	if(!IsBKTransparent)

  015aa	83 7d 1c 00	 cmp	 DWORD PTR _IsBKTransparent$[ebp], 0
  015ae	75 5a		 jne	 SHORT $L192572

; 467  : 	{	
; 468  : 		::StretchDIBits(pDC->GetSafeHdc(), origin.x, origin.y, size.cx, size.cy,
; 469  : 			0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 470  : 			m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  015b0	8b f4		 mov	 esi, esp
  015b2	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  015b7	6a 00		 push	 0
  015b9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  015bc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  015bf	52		 push	 edx
  015c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015c3	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  015c6	51		 push	 ecx
  015c7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  015ca	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  015cd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  015d0	51		 push	 ecx
  015d1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  015d4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  015d7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  015da	51		 push	 ecx
  015db	6a 00		 push	 0
  015dd	6a 00		 push	 0
  015df	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  015e2	52		 push	 edx
  015e3	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  015e6	50		 push	 eax
  015e7	8b 4d 10	 mov	 ecx, DWORD PTR _origin$[ebp+4]
  015ea	51		 push	 ecx
  015eb	8b 55 0c	 mov	 edx, DWORD PTR _origin$[ebp]
  015ee	52		 push	 edx
  015ef	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  015f2	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  015f7	50		 push	 eax
  015f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52
  015fe	3b f4		 cmp	 esi, esp
  01600	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 471  : 	}
; 472  : 	else

  01605	e9 e9 04 00 00	 jmp	 $L192575
$L192572:

; 473  : 	{
; 474  : 		if(mode == STRETCH)

  0160a	83 7d 24 01	 cmp	 DWORD PTR _mode$[ebp], 1
  0160e	0f 85 22 01 00
	00		 jne	 $L192576

; 475  : 		{
; 476  : 			HDC  hdcCompatible = CreateCompatibleDC(pDC->GetSafeHdc()); 

  01614	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01617	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0161c	8b f4		 mov	 esi, esp
  0161e	50		 push	 eax
  0161f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  01625	3b f4		 cmp	 esi, esp
  01627	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0162c	89 45 f4	 mov	 DWORD PTR _hdcCompatible$192577[ebp], eax

; 477  : 			HBITMAP  hbmScreen = CreateCompatibleBitmap(pDC->GetSafeHdc(), 
; 478  : 							size.cx, size.cy);

  0162f	8b f4		 mov	 esi, esp
  01631	8b 45 18	 mov	 eax, DWORD PTR _size$[ebp+4]
  01634	50		 push	 eax
  01635	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  01638	51		 push	 ecx
  01639	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0163c	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01641	50		 push	 eax
  01642	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  01648	3b f4		 cmp	 esi, esp
  0164a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0164f	89 45 f0	 mov	 DWORD PTR _hbmScreen$192578[ebp], eax

; 479  : 			HBITMAP old = (HBITMAP)SelectObject(hdcCompatible, hbmScreen);

  01652	8b f4		 mov	 esi, esp
  01654	8b 55 f0	 mov	 edx, DWORD PTR _hbmScreen$192578[ebp]
  01657	52		 push	 edx
  01658	8b 45 f4	 mov	 eax, DWORD PTR _hdcCompatible$192577[ebp]
  0165b	50		 push	 eax
  0165c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01662	3b f4		 cmp	 esi, esp
  01664	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01669	89 45 ec	 mov	 DWORD PTR _old$192579[ebp], eax

; 480  : 
; 481  : 			::StretchDIBits(hdcCompatible, 0, 0, size.cx, size.cy,
; 482  : 				0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 483  : 				m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  0166c	8b f4		 mov	 esi, esp
  0166e	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01673	6a 00		 push	 0
  01675	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01678	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0167b	52		 push	 edx
  0167c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0167f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01682	51		 push	 ecx
  01683	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01686	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01689	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0168c	51		 push	 ecx
  0168d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01690	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01693	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01696	51		 push	 ecx
  01697	6a 00		 push	 0
  01699	6a 00		 push	 0
  0169b	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  0169e	52		 push	 edx
  0169f	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  016a2	50		 push	 eax
  016a3	6a 00		 push	 0
  016a5	6a 00		 push	 0
  016a7	8b 4d f4	 mov	 ecx, DWORD PTR _hdcCompatible$192577[ebp]
  016aa	51		 push	 ecx
  016ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52
  016b1	3b f4		 cmp	 esi, esp
  016b3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 484  : 			TransparentBlt(pDC->GetSafeHdc(),origin.x, origin.y, size.cx, size.cy,hdcCompatible,0,0,size.cx, size.cy,mask);

  016b8	8b f4		 mov	 esi, esp
  016ba	8b 55 20	 mov	 edx, DWORD PTR _mask$[ebp]
  016bd	52		 push	 edx
  016be	8b 45 18	 mov	 eax, DWORD PTR _size$[ebp+4]
  016c1	50		 push	 eax
  016c2	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  016c5	51		 push	 ecx
  016c6	6a 00		 push	 0
  016c8	6a 00		 push	 0
  016ca	8b 55 f4	 mov	 edx, DWORD PTR _hdcCompatible$192577[ebp]
  016cd	52		 push	 edx
  016ce	8b 45 18	 mov	 eax, DWORD PTR _size$[ebp+4]
  016d1	50		 push	 eax
  016d2	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  016d5	51		 push	 ecx
  016d6	8b 55 10	 mov	 edx, DWORD PTR _origin$[ebp+4]
  016d9	52		 push	 edx
  016da	8b 45 0c	 mov	 eax, DWORD PTR _origin$[ebp]
  016dd	50		 push	 eax
  016de	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  016e1	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  016e6	50		 push	 eax
  016e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TransparentBlt@44
  016ed	3b f4		 cmp	 esi, esp
  016ef	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 485  : 			SelectObject(hdcCompatible, old);

  016f4	8b f4		 mov	 esi, esp
  016f6	8b 4d ec	 mov	 ecx, DWORD PTR _old$192579[ebp]
  016f9	51		 push	 ecx
  016fa	8b 55 f4	 mov	 edx, DWORD PTR _hdcCompatible$192577[ebp]
  016fd	52		 push	 edx
  016fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01704	3b f4		 cmp	 esi, esp
  01706	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 486  : 			DeleteObject(hbmScreen);

  0170b	8b f4		 mov	 esi, esp
  0170d	8b 45 f0	 mov	 eax, DWORD PTR _hbmScreen$192578[ebp]
  01710	50		 push	 eax
  01711	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  01717	3b f4		 cmp	 esi, esp
  01719	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 487  : 			DeleteDC(hdcCompatible);

  0171e	8b f4		 mov	 esi, esp
  01720	8b 4d f4	 mov	 ecx, DWORD PTR _hdcCompatible$192577[ebp]
  01723	51		 push	 ecx
  01724	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  0172a	3b f4		 cmp	 esi, esp
  0172c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 488  : 		}
; 489  : 		else if(mode == NORMAL)

  01731	e9 bd 03 00 00	 jmp	 $L192575
$L192576:
  01736	83 7d 24 00	 cmp	 DWORD PTR _mode$[ebp], 0
  0173a	0f 85 8a 01 00
	00		 jne	 $L192584

; 490  : 		{
; 491  : 			HDC  hdcCompatible = CreateCompatibleDC(pDC->GetSafeHdc()); 

  01740	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01743	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01748	8b f4		 mov	 esi, esp
  0174a	50		 push	 eax
  0174b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  01751	3b f4		 cmp	 esi, esp
  01753	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01758	89 45 e8	 mov	 DWORD PTR _hdcCompatible$192585[ebp], eax

; 492  : 			HBITMAP  hbmScreen = CreateCompatibleBitmap(pDC->GetSafeHdc(), 
; 493  : 							m_lpBMIH->biWidth, m_lpBMIH->biHeight);

  0175b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0175e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01761	8b f4		 mov	 esi, esp
  01763	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01766	51		 push	 ecx
  01767	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0176a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0176d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01770	51		 push	 ecx
  01771	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01774	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01779	50		 push	 eax
  0177a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  01780	3b f4		 cmp	 esi, esp
  01782	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01787	89 45 e4	 mov	 DWORD PTR _hbmScreen$192586[ebp], eax

; 494  : 			HBITMAP old = (HBITMAP)SelectObject(hdcCompatible, hbmScreen);

  0178a	8b f4		 mov	 esi, esp
  0178c	8b 55 e4	 mov	 edx, DWORD PTR _hbmScreen$192586[ebp]
  0178f	52		 push	 edx
  01790	8b 45 e8	 mov	 eax, DWORD PTR _hdcCompatible$192585[ebp]
  01793	50		 push	 eax
  01794	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  0179a	3b f4		 cmp	 esi, esp
  0179c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  017a1	89 45 e0	 mov	 DWORD PTR _old$192587[ebp], eax

; 495  : 
; 496  : 			::StretchDIBits(hdcCompatible, 0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 497  : 				0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 498  : 				m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  017a4	8b f4		 mov	 esi, esp
  017a6	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  017ab	6a 00		 push	 0
  017ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  017b0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  017b3	52		 push	 edx
  017b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  017b7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  017ba	51		 push	 ecx
  017bb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  017be	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  017c1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  017c4	51		 push	 ecx
  017c5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  017c8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  017cb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  017ce	51		 push	 ecx
  017cf	6a 00		 push	 0
  017d1	6a 00		 push	 0
  017d3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  017d6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  017d9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  017dc	51		 push	 ecx
  017dd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  017e0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  017e3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  017e6	51		 push	 ecx
  017e7	6a 00		 push	 0
  017e9	6a 00		 push	 0
  017eb	8b 55 e8	 mov	 edx, DWORD PTR _hdcCompatible$192585[ebp]
  017ee	52		 push	 edx
  017ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52
  017f5	3b f4		 cmp	 esi, esp
  017f7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 499  : 
; 500  : 			size.cx = (size.cx > m_lpBMIH->biWidth)? m_lpBMIH->biWidth : size.cx;

  017fc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  017ff	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01802	8b 55 14	 mov	 edx, DWORD PTR _size$[ebp]
  01805	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  01808	7e 0e		 jle	 SHORT $L193539
  0180a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0180d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01810	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01813	89 55 c0	 mov	 DWORD PTR tv227[ebp], edx
  01816	eb 06		 jmp	 SHORT $L193540
$L193539:
  01818	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  0181b	89 45 c0	 mov	 DWORD PTR tv227[ebp], eax
$L193540:
  0181e	8b 4d c0	 mov	 ecx, DWORD PTR tv227[ebp]
  01821	89 4d 14	 mov	 DWORD PTR _size$[ebp], ecx

; 501  : 			size.cy = (size.cy > m_lpBMIH->biHeight)? m_lpBMIH->biHeight : size.cy;

  01824	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01827	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0182a	8b 4d 18	 mov	 ecx, DWORD PTR _size$[ebp+4]
  0182d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  01830	7e 0e		 jle	 SHORT $L193541
  01832	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01835	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01838	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0183b	89 4d bc	 mov	 DWORD PTR tv233[ebp], ecx
  0183e	eb 06		 jmp	 SHORT $L193542
$L193541:
  01840	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  01843	89 55 bc	 mov	 DWORD PTR tv233[ebp], edx
$L193542:
  01846	8b 45 bc	 mov	 eax, DWORD PTR tv233[ebp]
  01849	89 45 18	 mov	 DWORD PTR _size$[ebp+4], eax

; 502  : 
; 503  : 			TransparentBlt(pDC->GetSafeHdc(),origin.x, origin.y, size.cx, size.cy,hdcCompatible,0,0,size.cx, size.cy,mask);

  0184c	8b f4		 mov	 esi, esp
  0184e	8b 4d 20	 mov	 ecx, DWORD PTR _mask$[ebp]
  01851	51		 push	 ecx
  01852	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  01855	52		 push	 edx
  01856	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  01859	50		 push	 eax
  0185a	6a 00		 push	 0
  0185c	6a 00		 push	 0
  0185e	8b 4d e8	 mov	 ecx, DWORD PTR _hdcCompatible$192585[ebp]
  01861	51		 push	 ecx
  01862	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  01865	52		 push	 edx
  01866	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  01869	50		 push	 eax
  0186a	8b 4d 10	 mov	 ecx, DWORD PTR _origin$[ebp+4]
  0186d	51		 push	 ecx
  0186e	8b 55 0c	 mov	 edx, DWORD PTR _origin$[ebp]
  01871	52		 push	 edx
  01872	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01875	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0187a	50		 push	 eax
  0187b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TransparentBlt@44
  01881	3b f4		 cmp	 esi, esp
  01883	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 504  : 			SelectObject(hdcCompatible, old);

  01888	8b f4		 mov	 esi, esp
  0188a	8b 45 e0	 mov	 eax, DWORD PTR _old$192587[ebp]
  0188d	50		 push	 eax
  0188e	8b 4d e8	 mov	 ecx, DWORD PTR _hdcCompatible$192585[ebp]
  01891	51		 push	 ecx
  01892	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01898	3b f4		 cmp	 esi, esp
  0189a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 505  : 			DeleteObject(hbmScreen);

  0189f	8b f4		 mov	 esi, esp
  018a1	8b 55 e4	 mov	 edx, DWORD PTR _hbmScreen$192586[ebp]
  018a4	52		 push	 edx
  018a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  018ab	3b f4		 cmp	 esi, esp
  018ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 506  : 			DeleteDC(hdcCompatible);

  018b2	8b f4		 mov	 esi, esp
  018b4	8b 45 e8	 mov	 eax, DWORD PTR _hdcCompatible$192585[ebp]
  018b7	50		 push	 eax
  018b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  018be	3b f4		 cmp	 esi, esp
  018c0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 507  : 		}
; 508  : 		else if(mode == TILE)

  018c5	e9 29 02 00 00	 jmp	 $L192575
$L192584:
  018ca	83 7d 24 02	 cmp	 DWORD PTR _mode$[ebp], 2
  018ce	0f 85 1f 02 00
	00		 jne	 $L192575

; 509  : 		{
; 510  : 			HDC  hdcCompatible = CreateCompatibleDC(pDC->GetSafeHdc()); 

  018d4	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  018d7	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  018dc	8b f4		 mov	 esi, esp
  018de	50		 push	 eax
  018df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  018e5	3b f4		 cmp	 esi, esp
  018e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  018ec	89 45 dc	 mov	 DWORD PTR _hdcCompatible$192593[ebp], eax

; 511  : 			HBITMAP  hbmScreen = CreateCompatibleBitmap(pDC->GetSafeHdc(), 
; 512  : 				m_lpBMIH->biWidth, m_lpBMIH->biHeight);

  018ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  018f2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  018f5	8b f4		 mov	 esi, esp
  018f7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  018fa	50		 push	 eax
  018fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  018fe	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01901	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01904	50		 push	 eax
  01905	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01908	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0190d	50		 push	 eax
  0190e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  01914	3b f4		 cmp	 esi, esp
  01916	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0191b	89 45 d8	 mov	 DWORD PTR _hbmScreen$192594[ebp], eax

; 513  : 			HBITMAP old = (HBITMAP)SelectObject(hdcCompatible, hbmScreen);

  0191e	8b f4		 mov	 esi, esp
  01920	8b 4d d8	 mov	 ecx, DWORD PTR _hbmScreen$192594[ebp]
  01923	51		 push	 ecx
  01924	8b 55 dc	 mov	 edx, DWORD PTR _hdcCompatible$192593[ebp]
  01927	52		 push	 edx
  01928	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  0192e	3b f4		 cmp	 esi, esp
  01930	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01935	89 45 d4	 mov	 DWORD PTR _old$192595[ebp], eax

; 514  : 
; 515  : 			::StretchDIBits(hdcCompatible, 0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 516  : 				0, 0, m_lpBMIH->biWidth, m_lpBMIH->biHeight,
; 517  : 				m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  01938	8b f4		 mov	 esi, esp
  0193a	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  0193f	6a 00		 push	 0
  01941	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01944	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01947	51		 push	 ecx
  01948	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0194b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0194e	50		 push	 eax
  0194f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01952	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01955	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01958	50		 push	 eax
  01959	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0195c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0195f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01962	50		 push	 eax
  01963	6a 00		 push	 0
  01965	6a 00		 push	 0
  01967	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0196a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0196d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01970	50		 push	 eax
  01971	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01974	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01977	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0197a	50		 push	 eax
  0197b	6a 00		 push	 0
  0197d	6a 00		 push	 0
  0197f	8b 4d dc	 mov	 ecx, DWORD PTR _hdcCompatible$192593[ebp]
  01982	51		 push	 ecx
  01983	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52
  01989	3b f4		 cmp	 esi, esp
  0198b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 518  : 
; 519  : 			size.cy = (size.cy > m_lpBMIH->biHeight)? m_lpBMIH->biHeight : size.cy;

  01990	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01993	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01996	8b 4d 18	 mov	 ecx, DWORD PTR _size$[ebp+4]
  01999	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0199c	7e 0e		 jle	 SHORT $L193543
  0199e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  019a1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  019a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  019a7	89 4d b8	 mov	 DWORD PTR tv297[ebp], ecx
  019aa	eb 06		 jmp	 SHORT $L193544
$L193543:
  019ac	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  019af	89 55 b8	 mov	 DWORD PTR tv297[ebp], edx
$L193544:
  019b2	8b 45 b8	 mov	 eax, DWORD PTR tv297[ebp]
  019b5	89 45 18	 mov	 DWORD PTR _size$[ebp+4], eax

; 520  : 
; 521  : 			int cx = size.cx;

  019b8	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  019bb	89 4d d0	 mov	 DWORD PTR _cx$192599[ebp], ecx

; 522  : 			int cy = size.cy;

  019be	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  019c1	89 55 cc	 mov	 DWORD PTR _cy$192600[ebp], edx

; 523  : 			for(int i = 0 ; i<size.cx; i+= m_lpBMIH->biWidth)

  019c4	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$192601[ebp], 0
  019cb	eb 0f		 jmp	 SHORT $L192602
$L192603:
  019cd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  019d0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  019d3	8b 55 c8	 mov	 edx, DWORD PTR _i$192601[ebp]
  019d6	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  019d9	89 55 c8	 mov	 DWORD PTR _i$192601[ebp], edx
$L192602:
  019dc	8b 45 c8	 mov	 eax, DWORD PTR _i$192601[ebp]
  019df	3b 45 14	 cmp	 eax, DWORD PTR _size$[ebp]
  019e2	0f 8d ce 00 00
	00		 jge	 $L192604

; 524  : 			{
; 525  : 				cx = size.cx - i;

  019e8	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  019eb	2b 4d c8	 sub	 ecx, DWORD PTR _i$192601[ebp]
  019ee	89 4d d0	 mov	 DWORD PTR _cx$192599[ebp], ecx

; 526  : 				cx = (cx > m_lpBMIH->biWidth) ? m_lpBMIH->biWidth : cx;

  019f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  019f4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  019f7	8b 4d d0	 mov	 ecx, DWORD PTR _cx$192599[ebp]
  019fa	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  019fd	7e 0e		 jle	 SHORT $L193545
  019ff	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01a02	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01a05	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01a08	89 4d b4	 mov	 DWORD PTR tv308[ebp], ecx
  01a0b	eb 06		 jmp	 SHORT $L193546
$L193545:
  01a0d	8b 55 d0	 mov	 edx, DWORD PTR _cx$192599[ebp]
  01a10	89 55 b4	 mov	 DWORD PTR tv308[ebp], edx
$L193546:
  01a13	8b 45 b4	 mov	 eax, DWORD PTR tv308[ebp]
  01a16	89 45 d0	 mov	 DWORD PTR _cx$192599[ebp], eax

; 527  : 				for(int j = 0; j<size.cy; j+= m_lpBMIH->biHeight)

  01a19	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _j$192605[ebp], 0
  01a20	eb 0f		 jmp	 SHORT $L192606
$L192607:
  01a22	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a25	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01a28	8b 45 c4	 mov	 eax, DWORD PTR _j$192605[ebp]
  01a2b	03 42 08	 add	 eax, DWORD PTR [edx+8]
  01a2e	89 45 c4	 mov	 DWORD PTR _j$192605[ebp], eax
$L192606:
  01a31	8b 4d c4	 mov	 ecx, DWORD PTR _j$192605[ebp]
  01a34	3b 4d 18	 cmp	 ecx, DWORD PTR _size$[ebp+4]
  01a37	7d 78		 jge	 SHORT $L192608

; 528  : 				{
; 529  : 					cy = size.cy - j;

  01a39	8b 55 18	 mov	 edx, DWORD PTR _size$[ebp+4]
  01a3c	2b 55 c4	 sub	 edx, DWORD PTR _j$192605[ebp]
  01a3f	89 55 cc	 mov	 DWORD PTR _cy$192600[ebp], edx

; 530  : 					cy = (cy > m_lpBMIH->biHeight)? m_lpBMIH->biHeight : cy;

  01a42	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a45	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01a48	8b 55 cc	 mov	 edx, DWORD PTR _cy$192600[ebp]
  01a4b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  01a4e	7e 0e		 jle	 SHORT $L193547
  01a50	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a53	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01a56	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01a59	89 55 b0	 mov	 DWORD PTR tv319[ebp], edx
  01a5c	eb 06		 jmp	 SHORT $L193548
$L193547:
  01a5e	8b 45 cc	 mov	 eax, DWORD PTR _cy$192600[ebp]
  01a61	89 45 b0	 mov	 DWORD PTR tv319[ebp], eax
$L193548:
  01a64	8b 4d b0	 mov	 ecx, DWORD PTR tv319[ebp]
  01a67	89 4d cc	 mov	 DWORD PTR _cy$192600[ebp], ecx

; 531  : 					TransparentBlt(pDC->GetSafeHdc(),origin.x + i, origin.y + j, 
; 532  : 						cx, cy,hdcCompatible,0,0,cx, cy,mask);

  01a6a	8b f4		 mov	 esi, esp
  01a6c	8b 55 20	 mov	 edx, DWORD PTR _mask$[ebp]
  01a6f	52		 push	 edx
  01a70	8b 45 cc	 mov	 eax, DWORD PTR _cy$192600[ebp]
  01a73	50		 push	 eax
  01a74	8b 4d d0	 mov	 ecx, DWORD PTR _cx$192599[ebp]
  01a77	51		 push	 ecx
  01a78	6a 00		 push	 0
  01a7a	6a 00		 push	 0
  01a7c	8b 55 dc	 mov	 edx, DWORD PTR _hdcCompatible$192593[ebp]
  01a7f	52		 push	 edx
  01a80	8b 45 cc	 mov	 eax, DWORD PTR _cy$192600[ebp]
  01a83	50		 push	 eax
  01a84	8b 4d d0	 mov	 ecx, DWORD PTR _cx$192599[ebp]
  01a87	51		 push	 ecx
  01a88	8b 55 10	 mov	 edx, DWORD PTR _origin$[ebp+4]
  01a8b	03 55 c4	 add	 edx, DWORD PTR _j$192605[ebp]
  01a8e	52		 push	 edx
  01a8f	8b 45 0c	 mov	 eax, DWORD PTR _origin$[ebp]
  01a92	03 45 c8	 add	 eax, DWORD PTR _i$192601[ebp]
  01a95	50		 push	 eax
  01a96	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01a99	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01a9e	50		 push	 eax
  01a9f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TransparentBlt@44
  01aa5	3b f4		 cmp	 esi, esp
  01aa7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 533  : 				}

  01aac	e9 71 ff ff ff	 jmp	 $L192607
$L192608:

; 534  : 			}

  01ab1	e9 17 ff ff ff	 jmp	 $L192603
$L192604:

; 535  : 			SelectObject(hdcCompatible, old);

  01ab6	8b f4		 mov	 esi, esp
  01ab8	8b 4d d4	 mov	 ecx, DWORD PTR _old$192595[ebp]
  01abb	51		 push	 ecx
  01abc	8b 55 dc	 mov	 edx, DWORD PTR _hdcCompatible$192593[ebp]
  01abf	52		 push	 edx
  01ac0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01ac6	3b f4		 cmp	 esi, esp
  01ac8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 536  : 			DeleteObject(hbmScreen);

  01acd	8b f4		 mov	 esi, esp
  01acf	8b 45 d8	 mov	 eax, DWORD PTR _hbmScreen$192594[ebp]
  01ad2	50		 push	 eax
  01ad3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  01ad9	3b f4		 cmp	 esi, esp
  01adb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 537  : 			DeleteDC(hdcCompatible);

  01ae0	8b f4		 mov	 esi, esp
  01ae2	8b 4d dc	 mov	 ecx, DWORD PTR _hdcCompatible$192593[ebp]
  01ae5	51		 push	 ecx
  01ae6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  01aec	3b f4		 cmp	 esi, esp
  01aee	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L192575:

; 538  : 		}
; 539  : 	}
; 540  : 	if (hOldPalette != NULL)

  01af3	83 7d f8 00	 cmp	 DWORD PTR _hOldPalette$[ebp], 0
  01af7	74 1e		 je	 SHORT $L192609

; 541  : 	{
; 542  : 		::SelectPalette(pDC->GetSafeHdc(), hOldPalette, TRUE);

  01af9	8b f4		 mov	 esi, esp
  01afb	6a 01		 push	 1
  01afd	8b 55 f8	 mov	 edx, DWORD PTR _hOldPalette$[ebp]
  01b00	52		 push	 edx
  01b01	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01b04	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01b09	50		 push	 eax
  01b0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  01b10	3b f4		 cmp	 esi, esp
  01b12	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L192609:

; 543  : 	}
; 544  : 	
; 545  : 	return TRUE;

  01b17	b8 01 00 00 00	 mov	 eax, 1
$L192568:

; 546  : }

  01b1c	5f		 pop	 edi
  01b1d	5e		 pop	 esi
  01b1e	83 c4 50	 add	 esp, 80			; 00000050H
  01b21	3b ec		 cmp	 ebp, esp
  01b23	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01b28	8b e5		 mov	 esp, ebp
  01b2a	5d		 pop	 ebp
  01b2b	c2 20 00	 ret	 32			; 00000020H
?Draw@CDib@@IAEHPAVCDC@@VCPoint@@VCSize@@HKW4DrawMode@1@@Z ENDP ; CDib::Draw
_TEXT	ENDS
PUBLIC	?CreateSection@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ; CDib::CreateSection
EXTRN	__imp__CreateDIBSection@24:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?CreateSection@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z PROC NEAR ; CDib::CreateSection
; _this$ = ecx

; 549  : {

  01b30	55		 push	 ebp
  01b31	8b ec		 mov	 ebp, esp
  01b33	51		 push	 ecx
  01b34	56		 push	 esi
  01b35	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  01b3c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 550  : 	if(m_lpBMIH == NULL) return NULL;

  01b3f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01b42	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  01b46	75 07		 jne	 SHORT $L192614
  01b48	33 c0		 xor	 eax, eax
  01b4a	e9 81 00 00 00	 jmp	 $L192613
$L192614:

; 551  : 	if(m_lpImage != NULL) return NULL; // can only do this if image doesn't exist

  01b4f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b52	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  01b56	74 04		 je	 SHORT $L192615
  01b58	33 c0		 xor	 eax, eax
  01b5a	eb 74		 jmp	 SHORT $L192613
$L192615:

; 552  : 	if(m_hBitmap != NULL)

  01b5c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01b5f	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  01b63	74 16		 je	 SHORT $L192616

; 553  : 		::DeleteObject(m_hBitmap);

  01b65	8b f4		 mov	 esi, esp
  01b67	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01b6a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01b6d	51		 push	 ecx
  01b6e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  01b74	3b f4		 cmp	 esi, esp
  01b76	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L192616:

; 554  : 	m_hBitmap = ::CreateDIBSection(pDC->GetSafeHdc(), (LPBITMAPINFO) m_lpBMIH,
; 555  : 		DIB_RGB_COLORS,	(LPVOID*) &m_lpImage, NULL, 0);

  01b7b	8b f4		 mov	 esi, esp
  01b7d	6a 00		 push	 0
  01b7f	6a 00		 push	 0
  01b81	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01b84	83 c2 10	 add	 edx, 16			; 00000010H
  01b87	52		 push	 edx
  01b88	6a 00		 push	 0
  01b8a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01b8d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01b90	51		 push	 ecx
  01b91	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01b94	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01b99	50		 push	 eax
  01b9a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBSection@24
  01ba0	3b f4		 cmp	 esi, esp
  01ba2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01ba7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01baa	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 556  : 	ASSERT(m_lpImage != NULL);

  01bad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01bb0	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  01bb4	75 14		 jne	 SHORT $L193550
  01bb6	68 2c 02 00 00	 push	 556			; 0000022cH
  01bbb	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  01bc0	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  01bc5	85 c0		 test	 eax, eax
  01bc7	74 01		 je	 SHORT $L193550
  01bc9	cc		 int	 3
$L193550:

; 557  : 	return m_hBitmap;

  01bca	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01bcd	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
$L192613:

; 558  : }

  01bd0	5e		 pop	 esi
  01bd1	83 c4 04	 add	 esp, 4
  01bd4	3b ec		 cmp	 ebp, esp
  01bd6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01bdb	8b e5		 mov	 esp, ebp
  01bdd	5d		 pop	 ebp
  01bde	c2 04 00	 ret	 4
?CreateSection@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ENDP	; CDib::CreateSection
_TEXT	ENDS
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ		; ATL::CTraceFileAndLineInfo::operator()
EXTRN	__imp__CreatePalette@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T193554 = -32						; size = 4
$T193553 = -28						; size = 4
$T193552 = -24						; size = 8
_i$192636 = -16						; size = 4
_pDibQuad$ = -12					; size = 4
_pLogPal$ = -8						; size = 4
_this$ = -4						; size = 4
?MakePalette@CDib@@IAEHXZ PROC NEAR			; CDib::MakePalette
; _this$ = ecx

; 561  : {

  01bf0	55		 push	 ebp
  01bf1	8b ec		 mov	 ebp, esp
  01bf3	83 ec 20	 sub	 esp, 32			; 00000020H
  01bf6	56		 push	 esi
  01bf7	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  01bfc	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  01bff	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  01c02	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  01c05	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  01c08	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  01c0b	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  01c0e	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  01c11	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  01c14	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 562  : 	// makes a logical palette (m_hPalette) from the DIB's color table
; 563  : 	// this palette will be selected and realized prior to drawing the DIB
; 564  : 	if(m_nColorTableEntries == 0) return FALSE;

  01c17	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01c1a	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  01c1e	75 07		 jne	 SHORT $L192623
  01c20	33 c0		 xor	 eax, eax
  01c22	e9 20 01 00 00	 jmp	 $L192622
$L192623:

; 565  : 	if(m_hPalette != NULL) ::DeleteObject(m_hPalette);

  01c27	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c2a	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  01c2e	74 16		 je	 SHORT $L192624
  01c30	8b f4		 mov	 esi, esp
  01c32	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01c35	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  01c38	50		 push	 eax
  01c39	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  01c3f	3b f4		 cmp	 esi, esp
  01c41	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L192624:

; 566  : 	TRACE("CDib::MakePalette -- m_nColorTableEntries = %d\n", m_nColorTableEntries);

  01c46	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c49	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  01c4c	52		 push	 edx
  01c4d	68 00 00 00 00	 push	 OFFSET FLAT:$SG192627
  01c52	68 36 02 00 00	 push	 566			; 00000236H
  01c57	68 00 00 00 00	 push	 OFFSET FLAT:$SG192626
  01c5c	8d 4d e8	 lea	 ecx, DWORD PTR $T193552[ebp]
  01c5f	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  01c64	50		 push	 eax
  01c65	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  01c6a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 567  : 	LPLOGPALETTE pLogPal = (LPLOGPALETTE) new char[2 * sizeof(WORD) +
; 568  : 		m_nColorTableEntries * sizeof(PALETTEENTRY)];

  01c6d	68 37 02 00 00	 push	 567			; 00000237H
  01c72	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  01c77	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01c7a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01c7d	8d 14 8d 04 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+4]
  01c84	52		 push	 edx
  01c85	e8 00 00 00 00	 call	 ??_U@YAPAXIPBDH@Z	; operator new[]
  01c8a	83 c4 0c	 add	 esp, 12			; 0000000cH
  01c8d	89 45 e4	 mov	 DWORD PTR $T193553[ebp], eax
  01c90	8b 45 e4	 mov	 eax, DWORD PTR $T193553[ebp]
  01c93	89 45 f8	 mov	 DWORD PTR _pLogPal$[ebp], eax

; 569  : 	pLogPal->palVersion = 0x300;

  01c96	8b 4d f8	 mov	 ecx, DWORD PTR _pLogPal$[ebp]
  01c99	66 c7 01 00 03	 mov	 WORD PTR [ecx], 768	; 00000300H

; 570  : 	pLogPal->palNumEntries = m_nColorTableEntries;

  01c9e	8b 55 f8	 mov	 edx, DWORD PTR _pLogPal$[ebp]
  01ca1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ca4	66 8b 48 24	 mov	 cx, WORD PTR [eax+36]
  01ca8	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 571  : 	LPRGBQUAD pDibQuad = (LPRGBQUAD) m_lpvColorTable;

  01cac	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01caf	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01cb2	89 45 f4	 mov	 DWORD PTR _pDibQuad$[ebp], eax

; 572  : 	for(int i = 0; i < m_nColorTableEntries; i++) {

  01cb5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$192636[ebp], 0
  01cbc	eb 09		 jmp	 SHORT $L192637
$L192638:
  01cbe	8b 4d f0	 mov	 ecx, DWORD PTR _i$192636[ebp]
  01cc1	83 c1 01	 add	 ecx, 1
  01cc4	89 4d f0	 mov	 DWORD PTR _i$192636[ebp], ecx
$L192637:
  01cc7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01cca	8b 45 f0	 mov	 eax, DWORD PTR _i$192636[ebp]
  01ccd	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  01cd0	7d 45		 jge	 SHORT $L192639

; 573  : 		pLogPal->palPalEntry[i].peRed = pDibQuad->rgbRed;

  01cd2	8b 4d f0	 mov	 ecx, DWORD PTR _i$192636[ebp]
  01cd5	8b 55 f8	 mov	 edx, DWORD PTR _pLogPal$[ebp]
  01cd8	8b 45 f4	 mov	 eax, DWORD PTR _pDibQuad$[ebp]
  01cdb	8a 40 02	 mov	 al, BYTE PTR [eax+2]
  01cde	88 44 8a 04	 mov	 BYTE PTR [edx+ecx*4+4], al

; 574  : 		pLogPal->palPalEntry[i].peGreen = pDibQuad->rgbGreen;

  01ce2	8b 4d f0	 mov	 ecx, DWORD PTR _i$192636[ebp]
  01ce5	8b 55 f8	 mov	 edx, DWORD PTR _pLogPal$[ebp]
  01ce8	8b 45 f4	 mov	 eax, DWORD PTR _pDibQuad$[ebp]
  01ceb	8a 40 01	 mov	 al, BYTE PTR [eax+1]
  01cee	88 44 8a 05	 mov	 BYTE PTR [edx+ecx*4+5], al

; 575  : 		pLogPal->palPalEntry[i].peBlue = pDibQuad->rgbBlue;

  01cf2	8b 4d f0	 mov	 ecx, DWORD PTR _i$192636[ebp]
  01cf5	8b 55 f8	 mov	 edx, DWORD PTR _pLogPal$[ebp]
  01cf8	8b 45 f4	 mov	 eax, DWORD PTR _pDibQuad$[ebp]
  01cfb	8a 00		 mov	 al, BYTE PTR [eax]
  01cfd	88 44 8a 06	 mov	 BYTE PTR [edx+ecx*4+6], al

; 576  : 		pLogPal->palPalEntry[i].peFlags = 0;

  01d01	8b 4d f0	 mov	 ecx, DWORD PTR _i$192636[ebp]
  01d04	8b 55 f8	 mov	 edx, DWORD PTR _pLogPal$[ebp]
  01d07	c6 44 8a 07 00	 mov	 BYTE PTR [edx+ecx*4+7], 0

; 577  : 		pDibQuad++;

  01d0c	8b 45 f4	 mov	 eax, DWORD PTR _pDibQuad$[ebp]
  01d0f	83 c0 04	 add	 eax, 4
  01d12	89 45 f4	 mov	 DWORD PTR _pDibQuad$[ebp], eax

; 578  : 	}

  01d15	eb a7		 jmp	 SHORT $L192638
$L192639:

; 579  : 	m_hPalette = ::CreatePalette(pLogPal);

  01d17	8b f4		 mov	 esi, esp
  01d19	8b 4d f8	 mov	 ecx, DWORD PTR _pLogPal$[ebp]
  01d1c	51		 push	 ecx
  01d1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreatePalette@4
  01d23	3b f4		 cmp	 esi, esp
  01d25	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01d2a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01d2d	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 580  : 	delete pLogPal;

  01d30	8b 45 f8	 mov	 eax, DWORD PTR _pLogPal$[ebp]
  01d33	89 45 e0	 mov	 DWORD PTR $T193554[ebp], eax
  01d36	8b 4d e0	 mov	 ecx, DWORD PTR $T193554[ebp]
  01d39	51		 push	 ecx
  01d3a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01d3f	83 c4 04	 add	 esp, 4

; 581  : 	return TRUE;

  01d42	b8 01 00 00 00	 mov	 eax, 1
$L192622:

; 582  : }	

  01d47	5e		 pop	 esi
  01d48	83 c4 20	 add	 esp, 32			; 00000020H
  01d4b	3b ec		 cmp	 ebp, esp
  01d4d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01d52	8b e5		 mov	 esp, ebp
  01d54	5d		 pop	 ebp
  01d55	c3		 ret	 0
?MakePalette@CDib@@IAEHXZ ENDP				; CDib::MakePalette
_TEXT	ENDS
PUBLIC	?SetSystemPalette@CDib@@IAEHPAVCDC@@@Z		; CDib::SetSystemPalette
EXTRN	__imp__CreateHalftonePalette@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?SetSystemPalette@CDib@@IAEHPAVCDC@@@Z PROC NEAR	; CDib::SetSystemPalette
; _this$ = ecx

; 585  : {

  01d60	55		 push	 ebp
  01d61	8b ec		 mov	 ebp, esp
  01d63	51		 push	 ecx
  01d64	56		 push	 esi
  01d65	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  01d6c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 	// if the DIB doesn't have a color table, we can use the system's halftone palette
; 587  : 	if(m_nColorTableEntries != 0) return FALSE;

  01d6f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d72	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  01d76	74 04		 je	 SHORT $L192645
  01d78	33 c0		 xor	 eax, eax
  01d7a	eb 23		 jmp	 SHORT $L192644
$L192645:

; 588  : 	m_hPalette = ::CreateHalftonePalette(pDC->GetSafeHdc());

  01d7c	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01d7f	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01d84	8b f4		 mov	 esi, esp
  01d86	50		 push	 eax
  01d87	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateHalftonePalette@4
  01d8d	3b f4		 cmp	 esi, esp
  01d8f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01d94	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d97	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 589  : 	return TRUE;

  01d9a	b8 01 00 00 00	 mov	 eax, 1
$L192644:

; 590  : }

  01d9f	5e		 pop	 esi
  01da0	83 c4 04	 add	 esp, 4
  01da3	3b ec		 cmp	 ebp, esp
  01da5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01daa	8b e5		 mov	 esp, ebp
  01dac	5d		 pop	 ebp
  01dad	c2 04 00	 ret	 4
?SetSystemPalette@CDib@@IAEHPAVCDC@@@Z ENDP		; CDib::SetSystemPalette
_TEXT	ENDS
EXTRN	__imp__CreateDIBitmap@24:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hBitmap$ = -8						; size = 4
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z PROC NEAR ; CDib::CreateBitmap
; _this$ = ecx

; 593  : {

  01db0	55		 push	 ebp
  01db1	8b ec		 mov	 ebp, esp
  01db3	83 ec 08	 sub	 esp, 8
  01db6	56		 push	 esi
  01db7	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  01dbe	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  01dc5	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 594  :     if (m_dwSizeImage == 0) return NULL;

  01dc8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01dcb	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  01dcf	75 04		 jne	 SHORT $L192650
  01dd1	33 c0		 xor	 eax, eax
  01dd3	eb 5a		 jmp	 SHORT $L192649
$L192650:

; 595  :     HBITMAP hBitmap = ::CreateDIBitmap(pDC->GetSafeHdc(), m_lpBMIH,
; 596  :             CBM_INIT, m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS);

  01dd5	8b f4		 mov	 esi, esp
  01dd7	6a 00		 push	 0
  01dd9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ddc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01ddf	52		 push	 edx
  01de0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01de3	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01de6	51		 push	 ecx
  01de7	6a 04		 push	 4
  01de9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01dec	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01def	50		 push	 eax
  01df0	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01df3	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01df8	50		 push	 eax
  01df9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBitmap@24
  01dff	3b f4		 cmp	 esi, esp
  01e01	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01e06	89 45 f8	 mov	 DWORD PTR _hBitmap$[ebp], eax

; 597  :     ASSERT(hBitmap != NULL);

  01e09	83 7d f8 00	 cmp	 DWORD PTR _hBitmap$[ebp], 0
  01e0d	75 14		 jne	 SHORT $L193557
  01e0f	68 55 02 00 00	 push	 597			; 00000255H
  01e14	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  01e19	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  01e1e	85 c0		 test	 eax, eax
  01e20	74 01		 je	 SHORT $L193557
  01e22	cc		 int	 3
$L193557:

; 598  : 	this->m_hBitmap = hBitmap;

  01e23	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01e26	8b 45 f8	 mov	 eax, DWORD PTR _hBitmap$[ebp]
  01e29	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 599  :     return hBitmap;

  01e2c	8b 45 f8	 mov	 eax, DWORD PTR _hBitmap$[ebp]
$L192649:

; 600  : }

  01e2f	5e		 pop	 esi
  01e30	83 c4 08	 add	 esp, 8
  01e33	3b ec		 cmp	 ebp, esp
  01e35	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01e3a	8b e5		 mov	 esp, ebp
  01e3c	5d		 pop	 ebp
  01e3d	c2 04 00	 ret	 4
?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ENDP	; CDib::CreateBitmap
_TEXT	ENDS
PUBLIC	?Compress@CDib@@IAEHPAVCDC@@H@Z			; CDib::Compress
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	__imp__GetDIBits@28:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv139 = -76						; size = 4
$T193567 = -72						; size = 8
$T193566 = -64						; size = 8
$T193564 = -56						; size = 4
$T193563 = -52						; size = 4
$T193562 = -48						; size = 4
$T193560 = -44						; size = 4
$T193559 = -40						; size = 8
_lpImage$ = -32						; size = 4
_dwBytes$192694 = -28					; size = 4
_lpBMIH$ = -24						; size = 4
_nSize$ = -20						; size = 4
_hBitmap$ = -16						; size = 4
_hOldPalette$ = -12					; size = 4
_hdc$ = -8						; size = 4
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
_bCompress$ = 12					; size = 4
?Compress@CDib@@IAEHPAVCDC@@H@Z PROC NEAR		; CDib::Compress
; _this$ = ecx

; 603  : {

  01e40	55		 push	 ebp
  01e41	8b ec		 mov	 ebp, esp
  01e43	83 ec 4c	 sub	 esp, 76			; 0000004cH
  01e46	56		 push	 esi
  01e47	57		 push	 edi
  01e48	51		 push	 ecx
  01e49	8d 7d b4	 lea	 edi, DWORD PTR [ebp-76]
  01e4c	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H
  01e51	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  01e56	f3 ab		 rep stosd
  01e58	59		 pop	 ecx
  01e59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 604  : 	// 1. makes GDI bitmap from existing DIB
; 605  : 	// 2. makes a new DIB from GDI bitmap with compression
; 606  : 	// 3. cleans up the original DIB
; 607  : 	// 4. puts the new DIB in the object
; 608  : 	if((m_lpBMIH->biBitCount != 4) && (m_lpBMIH->biBitCount != 8)) return FALSE;

  01e5c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e5f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01e62	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  01e66	83 fa 04	 cmp	 edx, 4
  01e69	74 16		 je	 SHORT $L192659
  01e6b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e6e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01e71	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  01e75	83 fa 08	 cmp	 edx, 8
  01e78	74 07		 je	 SHORT $L192659
  01e7a	33 c0		 xor	 eax, eax
  01e7c	e9 a3 03 00 00	 jmp	 $L192658
$L192659:

; 609  : 		// compression supported only for 4 bpp and 8 bpp DIBs
; 610  : 	if(m_hBitmap) return FALSE; // can't compress a DIB Section!

  01e81	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e84	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  01e88	74 07		 je	 SHORT $L192660
  01e8a	33 c0		 xor	 eax, eax
  01e8c	e9 93 03 00 00	 jmp	 $L192658
$L192660:

; 611  : 	TRACE("Compress: original palette size = %d\n", m_nColorTableEntries); 

  01e91	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01e94	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  01e97	52		 push	 edx
  01e98	68 00 00 00 00	 push	 OFFSET FLAT:$SG192663
  01e9d	68 63 02 00 00	 push	 611			; 00000263H
  01ea2	68 00 00 00 00	 push	 OFFSET FLAT:$SG192662
  01ea7	8d 4d d8	 lea	 ecx, DWORD PTR $T193559[ebp]
  01eaa	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  01eaf	50		 push	 eax
  01eb0	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  01eb5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 612  : 	HDC hdc = pDC->GetSafeHdc();

  01eb8	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01ebb	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01ec0	89 45 f8	 mov	 DWORD PTR _hdc$[ebp], eax

; 613  : 	HPALETTE hOldPalette = ::SelectPalette(hdc, m_hPalette, FALSE);

  01ec3	8b f4		 mov	 esi, esp
  01ec5	6a 00		 push	 0
  01ec7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01eca	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01ecd	51		 push	 ecx
  01ece	8b 55 f8	 mov	 edx, DWORD PTR _hdc$[ebp]
  01ed1	52		 push	 edx
  01ed2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  01ed8	3b f4		 cmp	 esi, esp
  01eda	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01edf	89 45 f4	 mov	 DWORD PTR _hOldPalette$[ebp], eax

; 614  : 	HBITMAP hBitmap;  // temporary
; 615  : 	if((hBitmap = CreateBitmap(pDC)) == NULL) return FALSE;

  01ee2	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  01ee5	50		 push	 eax
  01ee6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ee9	e8 00 00 00 00	 call	 ?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ; CDib::CreateBitmap
  01eee	89 45 f0	 mov	 DWORD PTR _hBitmap$[ebp], eax
  01ef1	83 7d f0 00	 cmp	 DWORD PTR _hBitmap$[ebp], 0
  01ef5	75 07		 jne	 SHORT $L192667
  01ef7	33 c0		 xor	 eax, eax
  01ef9	e9 26 03 00 00	 jmp	 $L192658
$L192667:

; 616  : 	int nSize = sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * m_nColorTableEntries;

  01efe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01f01	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  01f04	8d 04 95 28 00
	00 00		 lea	 eax, DWORD PTR [edx*4+40]
  01f0b	89 45 ec	 mov	 DWORD PTR _nSize$[ebp], eax

; 617  : 	LPBITMAPINFOHEADER lpBMIH = (LPBITMAPINFOHEADER) new char[nSize];

  01f0e	68 69 02 00 00	 push	 617			; 00000269H
  01f13	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  01f18	8b 4d ec	 mov	 ecx, DWORD PTR _nSize$[ebp]
  01f1b	51		 push	 ecx
  01f1c	e8 00 00 00 00	 call	 ??_U@YAPAXIPBDH@Z	; operator new[]
  01f21	83 c4 0c	 add	 esp, 12			; 0000000cH
  01f24	89 45 d4	 mov	 DWORD PTR $T193560[ebp], eax
  01f27	8b 55 d4	 mov	 edx, DWORD PTR $T193560[ebp]
  01f2a	89 55 e8	 mov	 DWORD PTR _lpBMIH$[ebp], edx

; 618  : 	memcpy(lpBMIH, m_lpBMIH, nSize);  // new header

  01f2d	8b 45 ec	 mov	 eax, DWORD PTR _nSize$[ebp]
  01f30	50		 push	 eax
  01f31	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01f34	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01f37	52		 push	 edx
  01f38	8b 45 e8	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  01f3b	50		 push	 eax
  01f3c	e8 00 00 00 00	 call	 _memcpy
  01f41	83 c4 0c	 add	 esp, 12			; 0000000cH

; 619  : 	if(bCompress) {

  01f44	83 7d 0c 00	 cmp	 DWORD PTR _bCompress$[ebp], 0
  01f48	0f 84 36 01 00
	00		 je	 $L192675

; 620  : 		switch (lpBMIH->biBitCount) {

  01f4e	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  01f51	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  01f55	89 55 b4	 mov	 DWORD PTR tv139[ebp], edx
  01f58	83 7d b4 04	 cmp	 DWORD PTR tv139[ebp], 4
  01f5c	74 08		 je	 SHORT $L192680
  01f5e	83 7d b4 08	 cmp	 DWORD PTR tv139[ebp], 8
  01f62	74 0e		 je	 SHORT $L192681
  01f64	eb 18		 jmp	 SHORT $L192682
$L192680:

; 621  : 		case 4:
; 622  : 			lpBMIH->biCompression = BI_RLE4;

  01f66	8b 45 e8	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  01f69	c7 40 10 02 00
	00 00		 mov	 DWORD PTR [eax+16], 2

; 623  : 			break;

  01f70	eb 24		 jmp	 SHORT $L192677
$L192681:

; 624  : 		case 8:
; 625  : 			lpBMIH->biCompression = BI_RLE8;

  01f72	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  01f75	c7 41 10 01 00
	00 00		 mov	 DWORD PTR [ecx+16], 1

; 626  : 			break;

  01f7c	eb 18		 jmp	 SHORT $L192677
$L192682:

; 627  : 		default:
; 628  : 			ASSERT(FALSE);

  01f7e	33 d2		 xor	 edx, edx
  01f80	75 14		 jne	 SHORT $L192677
  01f82	68 74 02 00 00	 push	 628			; 00000274H
  01f87	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  01f8c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  01f91	85 c0		 test	 eax, eax
  01f93	74 01		 je	 SHORT $L192677
  01f95	cc		 int	 3
$L192677:

; 629  : 		}
; 630  : 		// calls GetDIBits with null data pointer to get size of compressed DIB
; 631  : 		if(!::GetDIBits(pDC->GetSafeHdc(), hBitmap, 0, (UINT) lpBMIH->biHeight,
; 632  : 						NULL, (LPBITMAPINFO) lpBMIH, DIB_RGB_COLORS)) {

  01f96	8b f4		 mov	 esi, esp
  01f98	6a 00		 push	 0
  01f9a	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  01f9d	51		 push	 ecx
  01f9e	6a 00		 push	 0
  01fa0	8b 55 e8	 mov	 edx, DWORD PTR _lpBMIH$[ebp]
  01fa3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01fa6	50		 push	 eax
  01fa7	6a 00		 push	 0
  01fa9	8b 4d f0	 mov	 ecx, DWORD PTR _hBitmap$[ebp]
  01fac	51		 push	 ecx
  01fad	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  01fb0	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  01fb5	50		 push	 eax
  01fb6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDIBits@28
  01fbc	3b f4		 cmp	 esi, esp
  01fbe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01fc3	85 c0		 test	 eax, eax
  01fc5	75 53		 jne	 SHORT $L192686

; 633  : 			AfxMessageBox("Unable to compress this DIB");

  01fc7	6a 00		 push	 0
  01fc9	6a 00		 push	 0
  01fcb	68 00 00 00 00	 push	 OFFSET FLAT:$SG192687
  01fd0	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 634  : 			// probably a problem with the color table
; 635  : 	 		::DeleteObject(hBitmap);

  01fd5	8b f4		 mov	 esi, esp
  01fd7	8b 55 f0	 mov	 edx, DWORD PTR _hBitmap$[ebp]
  01fda	52		 push	 edx
  01fdb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  01fe1	3b f4		 cmp	 esi, esp
  01fe3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 636  : 			delete [] lpBMIH;

  01fe8	8b 45 e8	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  01feb	89 45 d0	 mov	 DWORD PTR $T193562[ebp], eax
  01fee	8b 4d d0	 mov	 ecx, DWORD PTR $T193562[ebp]
  01ff1	51		 push	 ecx
  01ff2	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  01ff7	83 c4 04	 add	 esp, 4

; 637  : 			::SelectPalette(hdc, hOldPalette, FALSE);

  01ffa	8b f4		 mov	 esi, esp
  01ffc	6a 00		 push	 0
  01ffe	8b 55 f4	 mov	 edx, DWORD PTR _hOldPalette$[ebp]
  02001	52		 push	 edx
  02002	8b 45 f8	 mov	 eax, DWORD PTR _hdc$[ebp]
  02005	50		 push	 eax
  02006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  0200c	3b f4		 cmp	 esi, esp
  0200e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 638  : 			return FALSE; 

  02013	33 c0		 xor	 eax, eax
  02015	e9 0a 02 00 00	 jmp	 $L192658
$L192686:

; 639  : 		}
; 640  : 		if (lpBMIH->biSizeImage == 0) {

  0201a	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  0201d	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  02021	75 53		 jne	 SHORT $L192689

; 641  : 			AfxMessageBox("Driver can't do compression");

  02023	6a 00		 push	 0
  02025	6a 00		 push	 0
  02027	68 00 00 00 00	 push	 OFFSET FLAT:$SG192690
  0202c	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 642  : 	 		::DeleteObject(hBitmap);

  02031	8b f4		 mov	 esi, esp
  02033	8b 55 f0	 mov	 edx, DWORD PTR _hBitmap$[ebp]
  02036	52		 push	 edx
  02037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  0203d	3b f4		 cmp	 esi, esp
  0203f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 643  : 			delete [] lpBMIH;

  02044	8b 45 e8	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  02047	89 45 cc	 mov	 DWORD PTR $T193563[ebp], eax
  0204a	8b 4d cc	 mov	 ecx, DWORD PTR $T193563[ebp]
  0204d	51		 push	 ecx
  0204e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  02053	83 c4 04	 add	 esp, 4

; 644  : 			::SelectPalette(hdc, hOldPalette, FALSE);

  02056	8b f4		 mov	 esi, esp
  02058	6a 00		 push	 0
  0205a	8b 55 f4	 mov	 edx, DWORD PTR _hOldPalette$[ebp]
  0205d	52		 push	 edx
  0205e	8b 45 f8	 mov	 eax, DWORD PTR _hdc$[ebp]
  02061	50		 push	 eax
  02062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  02068	3b f4		 cmp	 esi, esp
  0206a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 645  : 			return FALSE; 

  0206f	33 c0		 xor	 eax, eax
  02071	e9 ae 01 00 00	 jmp	 $L192658
$L192689:

; 646  : 		}
; 647  : 		else {
; 648  : 			m_dwSizeImage = lpBMIH->biSizeImage;

  02076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02079	8b 55 e8	 mov	 edx, DWORD PTR _lpBMIH$[ebp]
  0207c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0207f	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 649  : 		}
; 650  : 	}
; 651  : 	else {

  02082	eb 67		 jmp	 SHORT $L192693
$L192675:

; 652  : 		lpBMIH->biCompression = BI_RGB; // decompress

  02084	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  02087	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 653  : 		// figure the image size from the bitmap width and height
; 654  : 		DWORD dwBytes = ((DWORD) lpBMIH->biWidth * lpBMIH->biBitCount) / 32;

  0208e	8b 55 e8	 mov	 edx, DWORD PTR _lpBMIH$[ebp]
  02091	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  02095	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  02098	0f af 41 04	 imul	 eax, DWORD PTR [ecx+4]
  0209c	c1 e8 05	 shr	 eax, 5
  0209f	89 45 e4	 mov	 DWORD PTR _dwBytes$192694[ebp], eax

; 655  : 		if(((DWORD) lpBMIH->biWidth * lpBMIH->biBitCount) % 32) {

  020a2	8b 55 e8	 mov	 edx, DWORD PTR _lpBMIH$[ebp]
  020a5	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  020a9	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  020ac	0f af 41 04	 imul	 eax, DWORD PTR [ecx+4]
  020b0	33 d2		 xor	 edx, edx
  020b2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  020b7	f7 f1		 div	 ecx
  020b9	85 d2		 test	 edx, edx
  020bb	74 09		 je	 SHORT $L192697

; 656  : 			dwBytes++;

  020bd	8b 55 e4	 mov	 edx, DWORD PTR _dwBytes$192694[ebp]
  020c0	83 c2 01	 add	 edx, 1
  020c3	89 55 e4	 mov	 DWORD PTR _dwBytes$192694[ebp], edx
$L192697:

; 657  : 		}
; 658  : 		dwBytes *= 4;

  020c6	8b 45 e4	 mov	 eax, DWORD PTR _dwBytes$192694[ebp]
  020c9	c1 e0 02	 shl	 eax, 2
  020cc	89 45 e4	 mov	 DWORD PTR _dwBytes$192694[ebp], eax

; 659  : 		m_dwSizeImage = dwBytes * lpBMIH->biHeight; // no compression

  020cf	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  020d2	8b 55 e4	 mov	 edx, DWORD PTR _dwBytes$192694[ebp]
  020d5	0f af 51 08	 imul	 edx, DWORD PTR [ecx+8]
  020d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  020dc	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 660  : 		lpBMIH->biSizeImage = m_dwSizeImage;

  020df	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  020e2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  020e5	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  020e8	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L192693:

; 661  : 	} 
; 662  : 	// second GetDIBits call to make DIB
; 663  : 	LPBYTE lpImage = (LPBYTE) new char[m_dwSizeImage];

  020eb	68 97 02 00 00	 push	 663			; 00000297H
  020f0	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  020f5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  020f8	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  020fb	52		 push	 edx
  020fc	e8 00 00 00 00	 call	 ??_U@YAPAXIPBDH@Z	; operator new[]
  02101	83 c4 0c	 add	 esp, 12			; 0000000cH
  02104	89 45 c8	 mov	 DWORD PTR $T193564[ebp], eax
  02107	8b 45 c8	 mov	 eax, DWORD PTR $T193564[ebp]
  0210a	89 45 e0	 mov	 DWORD PTR _lpImage$[ebp], eax

; 664  : 	VERIFY(::GetDIBits(pDC->GetSafeHdc(), hBitmap, 0, (UINT) lpBMIH->biHeight,
; 665  :     		lpImage, (LPBITMAPINFO) lpBMIH, DIB_RGB_COLORS));

  0210d	8b f4		 mov	 esi, esp
  0210f	6a 00		 push	 0
  02111	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  02114	51		 push	 ecx
  02115	8b 55 e0	 mov	 edx, DWORD PTR _lpImage$[ebp]
  02118	52		 push	 edx
  02119	8b 45 e8	 mov	 eax, DWORD PTR _lpBMIH$[ebp]
  0211c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0211f	51		 push	 ecx
  02120	6a 00		 push	 0
  02122	8b 55 f0	 mov	 edx, DWORD PTR _hBitmap$[ebp]
  02125	52		 push	 edx
  02126	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  02129	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0212e	50		 push	 eax
  0212f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDIBits@28
  02135	3b f4		 cmp	 esi, esp
  02137	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0213c	85 c0		 test	 eax, eax
  0213e	75 14		 jne	 SHORT $L193565
  02140	68 99 02 00 00	 push	 665			; 00000299H
  02145	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  0214a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0214f	85 c0		 test	 eax, eax
  02151	74 01		 je	 SHORT $L193565
  02153	cc		 int	 3
$L193565:

; 666  :     TRACE("dib successfully created - height = %d\n", lpBMIH->biHeight);

  02154	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  02157	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0215a	52		 push	 edx
  0215b	68 00 00 00 00	 push	 OFFSET FLAT:$SG192707
  02160	68 9a 02 00 00	 push	 666			; 0000029aH
  02165	68 00 00 00 00	 push	 OFFSET FLAT:$SG192706
  0216a	8d 4d c0	 lea	 ecx, DWORD PTR $T193566[ebp]
  0216d	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  02172	50		 push	 eax
  02173	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  02178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 667  : 	::DeleteObject(hBitmap);

  0217b	8b f4		 mov	 esi, esp
  0217d	8b 45 f0	 mov	 eax, DWORD PTR _hBitmap$[ebp]
  02180	50		 push	 eax
  02181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  02187	3b f4		 cmp	 esi, esp
  02189	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 668  : 	Empty();

  0218e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02191	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 669  : 	m_nBmihAlloc = m_nImageAlloc = crtAlloc;

  02196	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02199	c7 41 1c 01 00
	00 00		 mov	 DWORD PTR [ecx+28], 1
  021a0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  021a3	c7 42 18 01 00
	00 00		 mov	 DWORD PTR [edx+24], 1

; 670  : 	m_lpBMIH = lpBMIH;

  021aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  021ad	8b 4d e8	 mov	 ecx, DWORD PTR _lpBMIH$[ebp]
  021b0	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 671  : 	m_lpImage = lpImage;

  021b3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  021b6	8b 45 e0	 mov	 eax, DWORD PTR _lpImage$[ebp]
  021b9	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 672  : 	ComputeMetrics();

  021bc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  021bf	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 673  : 	ComputePaletteSize(m_lpBMIH->biBitCount);

  021c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  021c7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  021ca	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  021ce	50		 push	 eax
  021cf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  021d2	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 674  : 	MakePalette();

  021d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  021da	e8 00 00 00 00	 call	 ?MakePalette@CDib@@IAEHXZ ; CDib::MakePalette

; 675  : 	::SelectPalette(hdc, hOldPalette, FALSE);

  021df	8b f4		 mov	 esi, esp
  021e1	6a 00		 push	 0
  021e3	8b 4d f4	 mov	 ecx, DWORD PTR _hOldPalette$[ebp]
  021e6	51		 push	 ecx
  021e7	8b 55 f8	 mov	 edx, DWORD PTR _hdc$[ebp]
  021ea	52		 push	 edx
  021eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  021f1	3b f4		 cmp	 esi, esp
  021f3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 676  : 	TRACE("Compress: new palette size = %d\n", m_nColorTableEntries); 

  021f8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  021fb	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  021fe	51		 push	 ecx
  021ff	68 00 00 00 00	 push	 OFFSET FLAT:$SG192710
  02204	68 a4 02 00 00	 push	 676			; 000002a4H
  02209	68 00 00 00 00	 push	 OFFSET FLAT:$SG192709
  0220e	8d 4d b8	 lea	 ecx, DWORD PTR $T193567[ebp]
  02211	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  02216	50		 push	 eax
  02217	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  0221c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 677  : 	return TRUE;

  0221f	b8 01 00 00 00	 mov	 eax, 1
$L192658:

; 678  : }

  02224	5f		 pop	 edi
  02225	5e		 pop	 esi
  02226	83 c4 4c	 add	 esp, 76			; 0000004cH
  02229	3b ec		 cmp	 ebp, esp
  0222b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02230	8b e5		 mov	 esp, ebp
  02232	5d		 pop	 ebp
  02233	c2 08 00	 ret	 8
?Compress@CDib@@IAEHPAVCDC@@H@Z ENDP			; CDib::Compress
_TEXT	ENDS
PUBLIC	__TI5PAVCUserException@@
PUBLIC	__CTA5PAVCUserException@@
PUBLIC	??_R0PAVCUserException@@@8			; CUserException * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAVCUserException@@@84
PUBLIC	??_R0PAVCSimpleException@@@8			; CSimpleException * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAVCSimpleException@@@84
PUBLIC	__CT??_R0PAVCException@@@84
PUBLIC	??_R0PAVCObject@@@8				; CObject * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAVCObject@@@84
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAX@84
PUBLIC	?Read@CDib@@IAEHPAVCFile@@@Z			; CDib::Read
EXTRN	__CxxThrowException@8:NEAR
EXTRN	??0CUserException@@QAE@XZ:NEAR			; CUserException::CUserException
EXTRN	??3CException@@SGXPAXPBDH@Z:NEAR		; CException::operator delete
xdata$x	SEGMENT
$T193596 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L193585
	DD	00H
	DD	FLAT:$L193586
	DD	0ffffffffH
	DD	00H
$T193598 DD	00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0ffffffc4H
	DD	FLAT:$L193584
$T193597 DD	00H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T193598
$T193590 DD	019930520H
	DD	04H
	DD	FLAT:$T193596
	DD	01H
	DD	FLAT:$T193597
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __TI5PAVCUserException@@
xdata$x	SEGMENT
__TI5PAVCUserException@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA5PAVCUserException@@
xdata$x	ENDS
;	COMDAT __CTA5PAVCUserException@@
xdata$x	SEGMENT
__CTA5PAVCUserException@@ DD 05H
	DD	FLAT:__CT??_R0PAVCUserException@@@84
	DD	FLAT:__CT??_R0PAVCSimpleException@@@84
	DD	FLAT:__CT??_R0PAVCException@@@84
	DD	FLAT:__CT??_R0PAVCObject@@@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCUserException@@@84
xdata$x	SEGMENT
__CT??_R0PAVCUserException@@@84 DD 01H
	DD	FLAT:??_R0PAVCUserException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAVCUserException@@@8
_DATA	SEGMENT
??_R0PAVCUserException@@@8 DD FLAT:??_7type_info@@6B@	; CUserException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCUserException@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0PAVCSimpleException@@@84
xdata$x	SEGMENT
__CT??_R0PAVCSimpleException@@@84 DD 01H
	DD	FLAT:??_R0PAVCSimpleException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAVCSimpleException@@@8
_DATA	SEGMENT
??_R0PAVCSimpleException@@@8 DD FLAT:??_7type_info@@6B@	; CSimpleException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCSimpleException@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0PAVCException@@@84
xdata$x	SEGMENT
__CT??_R0PAVCException@@@84 DD 01H
	DD	FLAT:??_R0PAVCException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCObject@@@84
xdata$x	SEGMENT
__CT??_R0PAVCObject@@@84 DD 01H
	DD	FLAT:??_R0PAVCObject@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAVCObject@@@8
_DATA	SEGMENT
??_R0PAVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCObject@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAX@8
_DATA	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
_TEXT	SEGMENT
tv189 = -144						; size = 4
tv188 = -140						; size = 4
tv187 = -136						; size = 4
tv186 = -132						; size = 4
tv130 = -128						; size = 4
tv185 = -124						; size = 4
tv183 = -120						; size = 4
tv83 = -116						; size = 4
tv182 = -112						; size = 4
tv180 = -108						; size = 4
tv179 = -104						; size = 4
$T193582 = -100						; size = 4
$T193581 = -96						; size = 4
$T193580 = -92						; size = 4
$T193577 = -88						; size = 4
$T193576 = -84						; size = 4
$T193575 = -80						; size = 4
$T193571 = -76						; size = 4
$T193570 = -72						; size = 4
$T193569 = -68						; size = 4
_pe$192756 = -60					; size = 4
_bmfh$ = -48						; size = 14
_nSize$ = -28						; size = 4
_nCount$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_pFile$ = 8						; size = 4
?Read@CDib@@IAEHPAVCFile@@@Z PROC NEAR			; CDib::Read
; _this$ = ecx

; 681  : {

  02240	55		 push	 ebp
  02241	8b ec		 mov	 ebp, esp
  02243	6a ff		 push	 -1
  02245	68 00 00 00 00	 push	 __ehhandler$?Read@CDib@@IAEHPAVCFile@@@Z
  0224a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02250	50		 push	 eax
  02251	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02258	51		 push	 ecx
  02259	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0225f	53		 push	 ebx
  02260	56		 push	 esi
  02261	57		 push	 edi
  02262	51		 push	 ecx
  02263	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-144]
  02269	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0226e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  02273	f3 ab		 rep stosd
  02275	59		 pop	 ecx
  02276	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  02279	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 682  : 	// 1. read file header to get size of info hdr + color table
; 683  : 	// 2. read info hdr (to get image size) and color table
; 684  : 	// 3. read image
; 685  : 	// can't use bfSize in file header
; 686  : 	Empty();

  0227c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0227f	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 687  : 	int nCount, nSize;
; 688  : 	BITMAPFILEHEADER bmfh;
; 689  : 	try {

  02284	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 690  : 		nCount = pFile->Read((LPVOID) &bmfh, sizeof(BITMAPFILEHEADER));

  0228b	8b f4		 mov	 esi, esp
  0228d	6a 0e		 push	 14			; 0000000eH
  0228f	8d 45 d0	 lea	 eax, DWORD PTR _bmfh$[ebp]
  02292	50		 push	 eax
  02293	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  02296	8b 11		 mov	 edx, DWORD PTR [ecx]
  02298	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  0229b	ff 52 3c	 call	 DWORD PTR [edx+60]
  0229e	3b f4		 cmp	 esi, esp
  022a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  022a5	89 45 98	 mov	 DWORD PTR tv179[ebp], eax
  022a8	8b 45 98	 mov	 eax, DWORD PTR tv179[ebp]
  022ab	89 45 e8	 mov	 DWORD PTR _nCount$[ebp], eax

; 691  : 		if(nCount != sizeof(BITMAPFILEHEADER)) {

  022ae	83 7d e8 0e	 cmp	 DWORD PTR _nCount$[ebp], 14 ; 0000000eH
  022b2	74 5f		 je	 SHORT $L192722

; 692  : 			throw new CUserException;

  022b4	68 b4 02 00 00	 push	 692			; 000002b4H
  022b9	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  022be	68 a0 00 00 00	 push	 160			; 000000a0H
  022c3	e8 00 00 00 00	 call	 ??2CObject@@SGPAXIPBDH@Z ; CObject::operator new
  022c8	89 45 94	 mov	 DWORD PTR tv180[ebp], eax
  022cb	8b 4d 94	 mov	 ecx, DWORD PTR tv180[ebp]
  022ce	89 4d b4	 mov	 DWORD PTR $T193571[ebp], ecx
  022d1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  022d5	83 7d b4 00	 cmp	 DWORD PTR $T193571[ebp], 0
  022d9	74 13		 je	 SHORT $L193572
  022db	8b 4d b4	 mov	 ecx, DWORD PTR $T193571[ebp]
  022de	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  022e3	89 45 90	 mov	 DWORD PTR tv182[ebp], eax
  022e6	8b 55 90	 mov	 edx, DWORD PTR tv182[ebp]
  022e9	89 55 8c	 mov	 DWORD PTR tv83[ebp], edx
  022ec	eb 07		 jmp	 SHORT $L193573
$L193572:
  022ee	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$L193573:
  022f5	8b 45 8c	 mov	 eax, DWORD PTR tv83[ebp]
  022f8	89 45 b8	 mov	 DWORD PTR $T193570[ebp], eax
  022fb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  022ff	8b 4d b8	 mov	 ecx, DWORD PTR $T193570[ebp]
  02302	89 4d bc	 mov	 DWORD PTR $T193569[ebp], ecx
  02305	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  0230a	8d 55 bc	 lea	 edx, DWORD PTR $T193569[ebp]
  0230d	52		 push	 edx
  0230e	e8 00 00 00 00	 call	 __CxxThrowException@8
$L192722:

; 693  : 		}
; 694  : 		if(bmfh.bfType != 0x4d42) {

  02313	0f b7 45 d0	 movzx	 eax, WORD PTR _bmfh$[ebp]
  02317	3d 42 4d 00 00	 cmp	 eax, 19778		; 00004d42H
  0231c	74 5f		 je	 SHORT $L192741

; 695  : 			throw new CUserException;

  0231e	68 b7 02 00 00	 push	 695			; 000002b7H
  02323	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  02328	68 a0 00 00 00	 push	 160			; 000000a0H
  0232d	e8 00 00 00 00	 call	 ??2CObject@@SGPAXIPBDH@Z ; CObject::operator new
  02332	89 45 88	 mov	 DWORD PTR tv183[ebp], eax
  02335	8b 4d 88	 mov	 ecx, DWORD PTR tv183[ebp]
  02338	89 4d a8	 mov	 DWORD PTR $T193577[ebp], ecx
  0233b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0233f	83 7d a8 00	 cmp	 DWORD PTR $T193577[ebp], 0
  02343	74 13		 je	 SHORT $L193578
  02345	8b 4d a8	 mov	 ecx, DWORD PTR $T193577[ebp]
  02348	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  0234d	89 45 84	 mov	 DWORD PTR tv185[ebp], eax
  02350	8b 55 84	 mov	 edx, DWORD PTR tv185[ebp]
  02353	89 55 80	 mov	 DWORD PTR tv130[ebp], edx
  02356	eb 07		 jmp	 SHORT $L193579
$L193578:
  02358	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
$L193579:
  0235f	8b 45 80	 mov	 eax, DWORD PTR tv130[ebp]
  02362	89 45 ac	 mov	 DWORD PTR $T193576[ebp], eax
  02365	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  02369	8b 4d ac	 mov	 ecx, DWORD PTR $T193576[ebp]
  0236c	89 4d b0	 mov	 DWORD PTR $T193575[ebp], ecx
  0236f	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  02374	8d 55 b0	 lea	 edx, DWORD PTR $T193575[ebp]
  02377	52		 push	 edx
  02378	e8 00 00 00 00	 call	 __CxxThrowException@8
$L192741:

; 696  : 		}
; 697  : 		nSize = bmfh.bfOffBits - sizeof(BITMAPFILEHEADER);

  0237d	8b 45 da	 mov	 eax, DWORD PTR _bmfh$[ebp+10]
  02380	83 e8 0e	 sub	 eax, 14			; 0000000eH
  02383	89 45 e4	 mov	 DWORD PTR _nSize$[ebp], eax

; 698  : 		m_lpBMIH = (LPBITMAPINFOHEADER) new char[nSize];

  02386	68 ba 02 00 00	 push	 698			; 000002baH
  0238b	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  02390	8b 4d e4	 mov	 ecx, DWORD PTR _nSize$[ebp]
  02393	51		 push	 ecx
  02394	e8 00 00 00 00	 call	 ??_U@YAPAXIPBDH@Z	; operator new[]
  02399	83 c4 0c	 add	 esp, 12			; 0000000cH
  0239c	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv186[ebp], eax
  023a2	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv186[ebp]
  023a8	89 55 a4	 mov	 DWORD PTR $T193580[ebp], edx
  023ab	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  023ae	8b 4d a4	 mov	 ecx, DWORD PTR $T193580[ebp]
  023b1	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 699  : 		m_nBmihAlloc = m_nImageAlloc = crtAlloc;

  023b4	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  023b7	c7 42 1c 01 00
	00 00		 mov	 DWORD PTR [edx+28], 1
  023be	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  023c1	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 700  : 		nCount = pFile->Read(m_lpBMIH, nSize); // info hdr & color table

  023c8	8b f4		 mov	 esi, esp
  023ca	8b 4d e4	 mov	 ecx, DWORD PTR _nSize$[ebp]
  023cd	51		 push	 ecx
  023ce	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  023d1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  023d4	50		 push	 eax
  023d5	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  023d8	8b 11		 mov	 edx, DWORD PTR [ecx]
  023da	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  023dd	ff 52 3c	 call	 DWORD PTR [edx+60]
  023e0	3b f4		 cmp	 esi, esp
  023e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  023e7	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv187[ebp], eax
  023ed	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv187[ebp]
  023f3	89 45 e8	 mov	 DWORD PTR _nCount$[ebp], eax

; 701  : 		ComputeMetrics();

  023f6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  023f9	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 702  : 		ComputePaletteSize(m_lpBMIH->biBitCount);

  023fe	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02401	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02404	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  02408	50		 push	 eax
  02409	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0240c	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 703  : 		MakePalette();

  02411	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02414	e8 00 00 00 00	 call	 ?MakePalette@CDib@@IAEHXZ ; CDib::MakePalette

; 704  : 		m_lpImage = (LPBYTE) new char[m_dwSizeImage];

  02419	68 c0 02 00 00	 push	 704			; 000002c0H
  0241e	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  02423	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02426	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  02429	52		 push	 edx
  0242a	e8 00 00 00 00	 call	 ??_U@YAPAXIPBDH@Z	; operator new[]
  0242f	83 c4 0c	 add	 esp, 12			; 0000000cH
  02432	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv188[ebp], eax
  02438	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv188[ebp]
  0243e	89 45 a0	 mov	 DWORD PTR $T193581[ebp], eax
  02441	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02444	8b 55 a0	 mov	 edx, DWORD PTR $T193581[ebp]
  02447	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 705  : 		nCount = pFile->Read(m_lpImage, m_dwSizeImage); // image only

  0244a	8b f4		 mov	 esi, esp
  0244c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0244f	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  02452	51		 push	 ecx
  02453	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  02456	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  02459	50		 push	 eax
  0245a	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  0245d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0245f	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  02462	ff 52 3c	 call	 DWORD PTR [edx+60]
  02465	3b f4		 cmp	 esi, esp
  02467	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0246c	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv189[ebp], eax
  02472	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv189[ebp]
  02478	89 45 e8	 mov	 DWORD PTR _nCount$[ebp], eax
  0247b	eb 23		 jmp	 SHORT $L193583
$L193584:

; 706  : 	}
; 707  : 	catch(CException* pe) {
; 708  : 		AfxMessageBox("Read error");

  0247d	6a 00		 push	 0
  0247f	6a 00		 push	 0
  02481	68 00 00 00 00	 push	 OFFSET FLAT:$SG192757
  02486	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 709  : 		pe->Delete();

  0248b	8b 4d c4	 mov	 ecx, DWORD PTR _pe$192756[ebp]
  0248e	e8 00 00 00 00	 call	 ?Delete@CException@@QAEXXZ ; CException::Delete

; 710  : 		return FALSE;

  02493	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T193582[ebp], 0
  0249a	b8 00 00 00 00	 mov	 eax, $L193588
  0249f	c3		 ret	 0
$L193583:

; 711  : 	}

  024a0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 712  : 	return TRUE;

  024a7	eb 05		 jmp	 SHORT $L193587
$L193588:

; 710  : 		return FALSE;

  024a9	8b 45 9c	 mov	 eax, DWORD PTR $T193582[ebp]
  024ac	eb 05		 jmp	 SHORT $L193568
$L193587:

; 712  : 	return TRUE;

  024ae	b8 01 00 00 00	 mov	 eax, 1
$L193568:

; 713  : }

  024b3	52		 push	 edx
  024b4	8b cd		 mov	 ecx, ebp
  024b6	50		 push	 eax
  024b7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L193595
  024bd	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  024c2	58		 pop	 eax
  024c3	5a		 pop	 edx
  024c4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  024c7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  024ce	5f		 pop	 edi
  024cf	5e		 pop	 esi
  024d0	5b		 pop	 ebx
  024d1	81 c4 90 00 00
	00		 add	 esp, 144		; 00000090H
  024d7	3b ec		 cmp	 ebp, esp
  024d9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  024de	8b e5		 mov	 esp, ebp
  024e0	5d		 pop	 ebp
  024e1	c2 04 00	 ret	 4
$L193595:
  024e4	02 00 00 00	 DD	 2
  024e8	00 00 00 00	 DD	 $L193594
$L193594:
  024ec	d0 ff ff ff	 DD	 -48			; ffffffd0H
  024f0	0e 00 00 00	 DD	 14			; 0000000eH
  024f4	00 00 00 00	 DD	 $L193591
  024f8	c4 ff ff ff	 DD	 -60			; ffffffc4H
  024fc	04 00 00 00	 DD	 4
  02500	00 00 00 00	 DD	 $L193592
$L193592:
  02504	70		 DB	 112			; 00000070H
  02505	65		 DB	 101			; 00000065H
  02506	00		 DB	 0
$L193591:
  02507	62		 DB	 98			; 00000062H
  02508	6d		 DB	 109			; 0000006dH
  02509	66		 DB	 102			; 00000066H
  0250a	68		 DB	 104			; 00000068H
  0250b	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L193585:
  000ac	68 b4 02 00 00	 push	 692			; 000002b4H
  000b1	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  000b6	8b 45 b4	 mov	 eax, DWORD PTR $T193571[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ??3CException@@SGXPAXPBDH@Z ; CException::operator delete
  000bf	c3		 ret	 0
$L193586:
  000c0	68 b7 02 00 00	 push	 695			; 000002b7H
  000c5	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  000ca	8b 45 a8	 mov	 eax, DWORD PTR $T193577[ebp]
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ??3CException@@SGXPAXPBDH@Z ; CException::operator delete
  000d3	c3		 ret	 0
__ehhandler$?Read@CDib@@IAEHPAVCFile@@@Z:
  000d4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193590
  000d9	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Read@CDib@@IAEHPAVCFile@@@Z ENDP			; CDib::Read
PUBLIC	?ReadSection@CDib@@IAEHPAVCFile@@PAVCDC@@@Z	; CDib::ReadSection
xdata$x	SEGMENT
$T193632 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L193620
	DD	00H
	DD	FLAT:$L193621
	DD	00H
	DD	FLAT:$L193622
	DD	0ffffffffH
	DD	00H
$T193634 DD	00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0ffffffc4H
	DD	FLAT:$L193619
$T193633 DD	00H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T193634
$T193626 DD	019930520H
	DD	05H
	DD	FLAT:$T193632
	DD	01H
	DD	FLAT:$T193633
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv228 = -168						; size = 4
tv227 = -164						; size = 4
tv226 = -160						; size = 4
tv161 = -156						; size = 4
tv225 = -152						; size = 4
tv223 = -148						; size = 4
tv222 = -144						; size = 4
tv221 = -140						; size = 4
tv130 = -136						; size = 4
tv220 = -132						; size = 4
tv218 = -128						; size = 4
tv83 = -124						; size = 4
tv217 = -120						; size = 4
tv215 = -116						; size = 4
tv214 = -112						; size = 4
$T193617 = -108						; size = 4
$T193613 = -104						; size = 4
$T193612 = -100						; size = 4
$T193611 = -96						; size = 4
$T193610 = -92						; size = 4
$T193607 = -88						; size = 4
$T193606 = -84						; size = 4
$T193605 = -80						; size = 4
$T193602 = -76						; size = 4
$T193601 = -72						; size = 4
$T193600 = -68						; size = 4
_pe$192802 = -60					; size = 4
_bmfh$ = -48						; size = 14
_nSize$ = -28						; size = 4
_nCount$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_pFile$ = 8						; size = 4
_pDC$ = 12						; size = 4
?ReadSection@CDib@@IAEHPAVCFile@@PAVCDC@@@Z PROC NEAR	; CDib::ReadSection
; _this$ = ecx

; 716  : {

  02510	55		 push	 ebp
  02511	8b ec		 mov	 ebp, esp
  02513	6a ff		 push	 -1
  02515	68 00 00 00 00	 push	 __ehhandler$?ReadSection@CDib@@IAEHPAVCFile@@PAVCDC@@@Z
  0251a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02520	50		 push	 eax
  02521	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02528	51		 push	 ecx
  02529	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0252f	53		 push	 ebx
  02530	56		 push	 esi
  02531	57		 push	 edi
  02532	51		 push	 ecx
  02533	8d bd 58 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-168]
  02539	b9 26 00 00 00	 mov	 ecx, 38			; 00000026H
  0253e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  02543	f3 ab		 rep stosd
  02545	59		 pop	 ecx
  02546	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  02549	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 717  : 	// new function reads BMP from disk and creates a DIB section
; 718  : 	//    allows modification of bitmaps from disk
; 719  : 	// 1. read file header to get size of info hdr + color table
; 720  : 	// 2. read info hdr (to get image size) and color table
; 721  : 	// 3. create DIB section based on header parms
; 722  : 	// 4. read image into memory that CreateDibSection allocates
; 723  : 	Empty();

  0254c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0254f	e8 00 00 00 00	 call	 ?Empty@CDib@@QAEXXZ	; CDib::Empty

; 724  : 	int nCount, nSize;
; 725  : 	BITMAPFILEHEADER bmfh;
; 726  : 	try {

  02554	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 727  : 		nCount = pFile->Read((LPVOID) &bmfh, sizeof(BITMAPFILEHEADER));

  0255b	8b f4		 mov	 esi, esp
  0255d	6a 0e		 push	 14			; 0000000eH
  0255f	8d 45 d0	 lea	 eax, DWORD PTR _bmfh$[ebp]
  02562	50		 push	 eax
  02563	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  02566	8b 11		 mov	 edx, DWORD PTR [ecx]
  02568	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  0256b	ff 52 3c	 call	 DWORD PTR [edx+60]
  0256e	3b f4		 cmp	 esi, esp
  02570	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02575	89 45 90	 mov	 DWORD PTR tv214[ebp], eax
  02578	8b 45 90	 mov	 eax, DWORD PTR tv214[ebp]
  0257b	89 45 e8	 mov	 DWORD PTR _nCount$[ebp], eax

; 728  : 		if(nCount != sizeof(BITMAPFILEHEADER)) {

  0257e	83 7d e8 0e	 cmp	 DWORD PTR _nCount$[ebp], 14 ; 0000000eH
  02582	74 5f		 je	 SHORT $L192771

; 729  : 			throw new CUserException;

  02584	68 d9 02 00 00	 push	 729			; 000002d9H
  02589	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  0258e	68 a0 00 00 00	 push	 160			; 000000a0H
  02593	e8 00 00 00 00	 call	 ??2CObject@@SGPAXIPBDH@Z ; CObject::operator new
  02598	89 45 8c	 mov	 DWORD PTR tv215[ebp], eax
  0259b	8b 4d 8c	 mov	 ecx, DWORD PTR tv215[ebp]
  0259e	89 4d b4	 mov	 DWORD PTR $T193602[ebp], ecx
  025a1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  025a5	83 7d b4 00	 cmp	 DWORD PTR $T193602[ebp], 0
  025a9	74 13		 je	 SHORT $L193603
  025ab	8b 4d b4	 mov	 ecx, DWORD PTR $T193602[ebp]
  025ae	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  025b3	89 45 88	 mov	 DWORD PTR tv217[ebp], eax
  025b6	8b 55 88	 mov	 edx, DWORD PTR tv217[ebp]
  025b9	89 55 84	 mov	 DWORD PTR tv83[ebp], edx
  025bc	eb 07		 jmp	 SHORT $L193604
$L193603:
  025be	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$L193604:
  025c5	8b 45 84	 mov	 eax, DWORD PTR tv83[ebp]
  025c8	89 45 b8	 mov	 DWORD PTR $T193601[ebp], eax
  025cb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  025cf	8b 4d b8	 mov	 ecx, DWORD PTR $T193601[ebp]
  025d2	89 4d bc	 mov	 DWORD PTR $T193600[ebp], ecx
  025d5	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  025da	8d 55 bc	 lea	 edx, DWORD PTR $T193600[ebp]
  025dd	52		 push	 edx
  025de	e8 00 00 00 00	 call	 __CxxThrowException@8
$L192771:

; 730  : 		}
; 731  : 		if(bmfh.bfType != 0x4d42) {

  025e3	0f b7 45 d0	 movzx	 eax, WORD PTR _bmfh$[ebp]
  025e7	3d 42 4d 00 00	 cmp	 eax, 19778		; 00004d42H
  025ec	74 6e		 je	 SHORT $L192779

; 732  : 			throw new CUserException;

  025ee	68 dc 02 00 00	 push	 732			; 000002dcH
  025f3	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  025f8	68 a0 00 00 00	 push	 160			; 000000a0H
  025fd	e8 00 00 00 00	 call	 ??2CObject@@SGPAXIPBDH@Z ; CObject::operator new
  02602	89 45 80	 mov	 DWORD PTR tv218[ebp], eax
  02605	8b 4d 80	 mov	 ecx, DWORD PTR tv218[ebp]
  02608	89 4d a8	 mov	 DWORD PTR $T193607[ebp], ecx
  0260b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0260f	83 7d a8 00	 cmp	 DWORD PTR $T193607[ebp], 0
  02613	74 1c		 je	 SHORT $L193608
  02615	8b 4d a8	 mov	 ecx, DWORD PTR $T193607[ebp]
  02618	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  0261d	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv220[ebp], eax
  02623	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv220[ebp]
  02629	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv130[ebp], edx
  0262f	eb 0a		 jmp	 SHORT $L193609
$L193608:
  02631	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv130[ebp], 0
$L193609:
  0263b	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv130[ebp]
  02641	89 45 ac	 mov	 DWORD PTR $T193606[ebp], eax
  02644	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  02648	8b 4d ac	 mov	 ecx, DWORD PTR $T193606[ebp]
  0264b	89 4d b0	 mov	 DWORD PTR $T193605[ebp], ecx
  0264e	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  02653	8d 55 b0	 lea	 edx, DWORD PTR $T193605[ebp]
  02656	52		 push	 edx
  02657	e8 00 00 00 00	 call	 __CxxThrowException@8
$L192779:

; 733  : 		}
; 734  : 		nSize = bmfh.bfOffBits - sizeof(BITMAPFILEHEADER);

  0265c	8b 45 da	 mov	 eax, DWORD PTR _bmfh$[ebp+10]
  0265f	83 e8 0e	 sub	 eax, 14			; 0000000eH
  02662	89 45 e4	 mov	 DWORD PTR _nSize$[ebp], eax

; 735  : 		m_lpBMIH = (LPBITMAPINFOHEADER) new char[nSize];

  02665	68 df 02 00 00	 push	 735			; 000002dfH
  0266a	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  0266f	8b 4d e4	 mov	 ecx, DWORD PTR _nSize$[ebp]
  02672	51		 push	 ecx
  02673	e8 00 00 00 00	 call	 ??_U@YAPAXIPBDH@Z	; operator new[]
  02678	83 c4 0c	 add	 esp, 12			; 0000000cH
  0267b	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv221[ebp], eax
  02681	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv221[ebp]
  02687	89 55 a4	 mov	 DWORD PTR $T193610[ebp], edx
  0268a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0268d	8b 4d a4	 mov	 ecx, DWORD PTR $T193610[ebp]
  02690	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 736  : 		m_nBmihAlloc = crtAlloc;

  02693	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  02696	c7 42 18 01 00
	00 00		 mov	 DWORD PTR [edx+24], 1

; 737  : 		m_nImageAlloc = noAlloc;

  0269d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  026a0	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 738  : 		nCount = pFile->Read(m_lpBMIH, nSize); // info hdr & color table

  026a7	8b f4		 mov	 esi, esp
  026a9	8b 4d e4	 mov	 ecx, DWORD PTR _nSize$[ebp]
  026ac	51		 push	 ecx
  026ad	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  026b0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  026b3	50		 push	 eax
  026b4	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  026b7	8b 11		 mov	 edx, DWORD PTR [ecx]
  026b9	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  026bc	ff 52 3c	 call	 DWORD PTR [edx+60]
  026bf	3b f4		 cmp	 esi, esp
  026c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  026c6	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv222[ebp], eax
  026cc	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv222[ebp]
  026d2	89 45 e8	 mov	 DWORD PTR _nCount$[ebp], eax

; 739  : 		if(m_lpBMIH->biCompression != BI_RGB) {

  026d5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  026d8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  026db	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  026df	74 74		 je	 SHORT $L192791

; 740  : 			throw new CUserException;

  026e1	68 e4 02 00 00	 push	 740			; 000002e4H
  026e6	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  026eb	68 a0 00 00 00	 push	 160			; 000000a0H
  026f0	e8 00 00 00 00	 call	 ??2CObject@@SGPAXIPBDH@Z ; CObject::operator new
  026f5	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv223[ebp], eax
  026fb	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv223[ebp]
  02701	89 45 98	 mov	 DWORD PTR $T193613[ebp], eax
  02704	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  02708	83 7d 98 00	 cmp	 DWORD PTR $T193613[ebp], 0
  0270c	74 1c		 je	 SHORT $L193614
  0270e	8b 4d 98	 mov	 ecx, DWORD PTR $T193613[ebp]
  02711	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  02716	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv225[ebp], eax
  0271c	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv225[ebp]
  02722	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv161[ebp], ecx
  02728	eb 0a		 jmp	 SHORT $L193615
$L193614:
  0272a	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv161[ebp], 0
$L193615:
  02734	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv161[ebp]
  0273a	89 55 9c	 mov	 DWORD PTR $T193612[ebp], edx
  0273d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  02741	8b 45 9c	 mov	 eax, DWORD PTR $T193612[ebp]
  02744	89 45 a0	 mov	 DWORD PTR $T193611[ebp], eax
  02747	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  0274c	8d 4d a0	 lea	 ecx, DWORD PTR $T193611[ebp]
  0274f	51		 push	 ecx
  02750	e8 00 00 00 00	 call	 __CxxThrowException@8
$L192791:

; 741  : 		}
; 742  : 		ComputeMetrics();

  02755	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02758	e8 00 00 00 00	 call	 ?ComputeMetrics@CDib@@AAEXXZ ; CDib::ComputeMetrics

; 743  : 		ComputePaletteSize(m_lpBMIH->biBitCount);

  0275d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  02760	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  02763	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  02767	51		 push	 ecx
  02768	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0276b	e8 00 00 00 00	 call	 ?ComputePaletteSize@CDib@@AAEXH@Z ; CDib::ComputePaletteSize

; 744  : 		MakePalette();

  02770	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02773	e8 00 00 00 00	 call	 ?MakePalette@CDib@@IAEHXZ ; CDib::MakePalette

; 745  : 		UsePalette(pDC);

  02778	6a 00		 push	 0
  0277a	8b 55 0c	 mov	 edx, DWORD PTR _pDC$[ebp]
  0277d	52		 push	 edx
  0277e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02781	e8 00 00 00 00	 call	 ?UsePalette@CDib@@IAEIPAVCDC@@H@Z ; CDib::UsePalette

; 746  : 		m_hBitmap = ::CreateDIBSection(pDC->GetSafeHdc(), (LPBITMAPINFO) m_lpBMIH,
; 747  : 			DIB_RGB_COLORS,	(LPVOID*) &m_lpImage, NULL, 0);

  02786	8b 4d 0c	 mov	 ecx, DWORD PTR _pDC$[ebp]
  02789	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  0278e	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], eax
  02794	8b f4		 mov	 esi, esp
  02796	6a 00		 push	 0
  02798	6a 00		 push	 0
  0279a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0279d	83 c0 10	 add	 eax, 16			; 00000010H
  027a0	50		 push	 eax
  027a1	6a 00		 push	 0
  027a3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  027a6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  027a9	52		 push	 edx
  027aa	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv226[ebp]
  027b0	50		 push	 eax
  027b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBSection@24
  027b7	3b f4		 cmp	 esi, esp
  027b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  027be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  027c1	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 748  : 		ASSERT(m_lpImage != NULL);

  027c4	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  027c7	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  027cb	75 1f		 jne	 SHORT $L193616
  027cd	68 ec 02 00 00	 push	 748			; 000002ecH
  027d2	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  027d7	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  027dc	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv227[ebp], eax
  027e2	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR tv227[ebp], 0
  027e9	74 01		 je	 SHORT $L193616
  027eb	cc		 int	 3
$L193616:

; 749  : 		nCount = pFile->Read(m_lpImage, m_dwSizeImage); // image only

  027ec	8b f4		 mov	 esi, esp
  027ee	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  027f1	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  027f4	52		 push	 edx
  027f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  027f8	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  027fb	51		 push	 ecx
  027fc	8b 55 08	 mov	 edx, DWORD PTR _pFile$[ebp]
  027ff	8b 02		 mov	 eax, DWORD PTR [edx]
  02801	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  02804	ff 50 3c	 call	 DWORD PTR [eax+60]
  02807	3b f4		 cmp	 esi, esp
  02809	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0280e	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv228[ebp], eax
  02814	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv228[ebp]
  0281a	89 4d e8	 mov	 DWORD PTR _nCount$[ebp], ecx
  0281d	eb 23		 jmp	 SHORT $L193618
$L193619:

; 750  : 	}
; 751  : 	catch(CException* pe) {
; 752  : 		AfxMessageBox("ReadSection error");

  0281f	6a 00		 push	 0
  02821	6a 00		 push	 0
  02823	68 00 00 00 00	 push	 OFFSET FLAT:$SG192803
  02828	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 753  : 		pe->Delete();

  0282d	8b 4d c4	 mov	 ecx, DWORD PTR _pe$192802[ebp]
  02830	e8 00 00 00 00	 call	 ?Delete@CException@@QAEXXZ ; CException::Delete

; 754  : 		return FALSE;

  02835	c7 45 94 00 00
	00 00		 mov	 DWORD PTR $T193617[ebp], 0
  0283c	b8 00 00 00 00	 mov	 eax, $L193624
  02841	c3		 ret	 0
$L193618:

; 755  : 	}

  02842	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 756  : 	return TRUE;

  02849	eb 05		 jmp	 SHORT $L193623
$L193624:

; 754  : 		return FALSE;

  0284b	8b 45 94	 mov	 eax, DWORD PTR $T193617[ebp]
  0284e	eb 05		 jmp	 SHORT $L193599
$L193623:

; 756  : 	return TRUE;

  02850	b8 01 00 00 00	 mov	 eax, 1
$L193599:

; 757  : }

  02855	52		 push	 edx
  02856	8b cd		 mov	 ecx, ebp
  02858	50		 push	 eax
  02859	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L193631
  0285f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  02864	58		 pop	 eax
  02865	5a		 pop	 edx
  02866	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  02869	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02870	5f		 pop	 edi
  02871	5e		 pop	 esi
  02872	5b		 pop	 ebx
  02873	81 c4 a8 00 00
	00		 add	 esp, 168		; 000000a8H
  02879	3b ec		 cmp	 ebp, esp
  0287b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02880	8b e5		 mov	 esp, ebp
  02882	5d		 pop	 ebp
  02883	c2 08 00	 ret	 8
$L193631:
  02886	02 00 00 00	 DD	 2
  0288a	00 00 00 00	 DD	 $L193630
$L193630:
  0288e	d0 ff ff ff	 DD	 -48			; ffffffd0H
  02892	0e 00 00 00	 DD	 14			; 0000000eH
  02896	00 00 00 00	 DD	 $L193627
  0289a	c4 ff ff ff	 DD	 -60			; ffffffc4H
  0289e	04 00 00 00	 DD	 4
  028a2	00 00 00 00	 DD	 $L193628
$L193628:
  028a6	70		 DB	 112			; 00000070H
  028a7	65		 DB	 101			; 00000065H
  028a8	00		 DB	 0
$L193627:
  028a9	62		 DB	 98			; 00000062H
  028aa	6d		 DB	 109			; 0000006dH
  028ab	66		 DB	 102			; 00000066H
  028ac	68		 DB	 104			; 00000068H
  028ad	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L193620:
  000de	68 d9 02 00 00	 push	 729			; 000002d9H
  000e3	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  000e8	8b 45 b4	 mov	 eax, DWORD PTR $T193602[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ??3CException@@SGXPAXPBDH@Z ; CException::operator delete
  000f1	c3		 ret	 0
$L193621:
  000f2	68 dc 02 00 00	 push	 732			; 000002dcH
  000f7	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  000fc	8b 45 a8	 mov	 eax, DWORD PTR $T193607[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 ??3CException@@SGXPAXPBDH@Z ; CException::operator delete
  00105	c3		 ret	 0
$L193622:
  00106	68 e4 02 00 00	 push	 740			; 000002e4H
  0010b	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00110	8b 45 98	 mov	 eax, DWORD PTR $T193613[ebp]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ??3CException@@SGXPAXPBDH@Z ; CException::operator delete
  00119	c3		 ret	 0
__ehhandler$?ReadSection@CDib@@IAEHPAVCFile@@PAVCDC@@@Z:
  0011a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193626
  0011f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ReadSection@CDib@@IAEHPAVCFile@@PAVCDC@@@Z ENDP	; CDib::ReadSection
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltrace.h
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC NEAR	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 158  : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 45 0c	 mov	 eax, DWORD PTR _nLineNo$[ebp]
  0001c	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
PUBLIC	??BCTraceCategory@ATL@@QBEKXZ			; ATL::CTraceCategory::operator unsigned long
PUBLIC	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z		; ATL::CTrace::TraceV
EXTRN	?s_trace@CTrace@ATL@@2V12@A:QWORD		; ATL::CTrace::s_trace
EXTRN	?atlTraceGeneral@ATL@@3VCTraceCategory@1@A:DWORD ; ATL::atlTraceGeneral
; Function compile flags: /Odt /RTCsu
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ
_TEXT	SEGMENT
_ptr$ = -4						; size = 4
_this$ = 8						; size = 4
_pszFmt$ = 12						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ PROC NEAR	; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 173  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 174  : 		va_list ptr; va_start(ptr, pszFmt);

  0000b	8d 45 10	 lea	 eax, DWORD PTR _pszFmt$[ebp+4]
  0000e	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 175  : 		ATL::CTrace::s_trace.TraceV(m_pszFileName, m_nLineNo, atlTraceGeneral, 0, pszFmt, ptr);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00014	51		 push	 ecx
  00015	8b 55 0c	 mov	 edx, DWORD PTR _pszFmt$[ebp]
  00018	52		 push	 edx
  00019	6a 00		 push	 0
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?atlTraceGeneral@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceGeneral
  00020	e8 00 00 00 00	 call	 ??BCTraceCategory@ATL@@QBEKXZ ; ATL::CTraceCategory::operator unsigned long
  00025	50		 push	 eax
  00026	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	51		 push	 ecx
  0002d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET FLAT:?s_trace@CTrace@ATL@@2V12@A
  00038	e8 00 00 00 00	 call	 ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z ; ATL::CTrace::TraceV
  0003d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 176  : 		va_end(ptr);

  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ptr$[ebp], 0

; 177  : 	}

  00047	83 c4 04	 add	 esp, 4
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
EXTRN	_AtlTraceVA:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pszFileName$ = 12					; size = 4
_nLine$ = 16						; size = 4
_dwCategory$ = 20					; size = 4
_nLevel$ = 24						; size = 4
_pszFmt$ = 28						; size = 4
_args$ = 32						; size = 4
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z PROC NEAR		; ATL::CTrace::TraceV, COMDAT

; 121  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  : 		AtlTraceVA(m_dwModule, pszFileName, nLine, dwCategory, nLevel, pszFmt, args);

  00003	8b 45 20	 mov	 eax, DWORD PTR _args$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 1c	 mov	 ecx, DWORD PTR _pszFmt$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 18	 mov	 edx, DWORD PTR _nLevel$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 14	 mov	 eax, DWORD PTR _dwCategory$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR _pszFileName$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _AtlTraceVA
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH

; 123  : 	}

  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z ENDP		; ATL::CTrace::TraceV
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCTraceCategory@ATL@@QBEKXZ PROC NEAR			; ATL::CTraceCategory::operator unsigned long, COMDAT
; _this$ = ecx

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 203  : 	return( m_dwCategory );

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 204  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??BCTraceCategory@ATL@@QBEKXZ ENDP			; ATL::CTraceCategory::operator unsigned long
_TEXT	ENDS
PUBLIC	?Write@CDib@@IAEHPAVCFile@@@Z			; CDib::Write
xdata$x	SEGMENT
$T193652 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T193654 DD	00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0ffffffc8H
	DD	FLAT:$L193642
$T193653 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T193654
$T193646 DD	019930520H
	DD	02H
	DD	FLAT:$T193652
	DD	01H
	DD	FLAT:$T193653
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\bitmap\cdib.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T193640 = -64						; size = 4
_pe$192821 = -56					; size = 4
_nSizeHdr$ = -48					; size = 4
_bmfh$ = -40						; size = 14
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_pFile$ = 8						; size = 4
?Write@CDib@@IAEHPAVCFile@@@Z PROC NEAR			; CDib::Write
; _this$ = ecx

; 760  : {

  028b0	55		 push	 ebp
  028b1	8b ec		 mov	 ebp, esp
  028b3	6a ff		 push	 -1
  028b5	68 00 00 00 00	 push	 __ehhandler$?Write@CDib@@IAEHPAVCFile@@@Z
  028ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  028c0	50		 push	 eax
  028c1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  028c8	51		 push	 ecx
  028c9	83 ec 30	 sub	 esp, 48			; 00000030H
  028cc	53		 push	 ebx
  028cd	56		 push	 esi
  028ce	57		 push	 edi
  028cf	51		 push	 ecx
  028d0	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  028d3	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  028d8	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  028dd	f3 ab		 rep stosd
  028df	59		 pop	 ecx
  028e0	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  028e3	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 761  : 	BITMAPFILEHEADER bmfh;
; 762  : 	bmfh.bfType = 0x4d42;  // 'BM'

  028e6	66 c7 45 d8 42
	4d		 mov	 WORD PTR _bmfh$[ebp], 19778 ; 00004d42H

; 763  : 	int nSizeHdr = sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * m_nColorTableEntries;

  028ec	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  028ef	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  028f2	8d 14 8d 28 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+40]
  028f9	89 55 d0	 mov	 DWORD PTR _nSizeHdr$[ebp], edx

; 764  : 	bmfh.bfSize = 0;

  028fc	c7 45 da 00 00
	00 00		 mov	 DWORD PTR _bmfh$[ebp+2], 0

; 765  : //	bmfh.bfSize = sizeof(BITMAPFILEHEADER) + nSizeHdr + m_dwSizeImage;
; 766  : 	// meaning of bfSize open to interpretation (bytes, words, dwords?) -- we won't use it
; 767  : 	bmfh.bfReserved1 = bmfh.bfReserved2 = 0;

  02903	66 c7 45 e0 00
	00		 mov	 WORD PTR _bmfh$[ebp+8], 0
  02909	66 8b 45 e0	 mov	 ax, WORD PTR _bmfh$[ebp+8]
  0290d	66 89 45 de	 mov	 WORD PTR _bmfh$[ebp+6], ax

; 768  : 	bmfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) +
; 769  : 			sizeof(RGBQUAD) * m_nColorTableEntries;	

  02911	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02914	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  02917	8d 04 95 36 00
	00 00		 lea	 eax, DWORD PTR [edx*4+54]
  0291e	89 45 e2	 mov	 DWORD PTR _bmfh$[ebp+10], eax

; 770  : 	try {

  02921	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 771  : 		pFile->Write((LPVOID) &bmfh, sizeof(BITMAPFILEHEADER));

  02928	8b f4		 mov	 esi, esp
  0292a	6a 0e		 push	 14			; 0000000eH
  0292c	8d 4d d8	 lea	 ecx, DWORD PTR _bmfh$[ebp]
  0292f	51		 push	 ecx
  02930	8b 55 08	 mov	 edx, DWORD PTR _pFile$[ebp]
  02933	8b 02		 mov	 eax, DWORD PTR [edx]
  02935	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  02938	ff 50 40	 call	 DWORD PTR [eax+64]
  0293b	3b f4		 cmp	 esi, esp
  0293d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 772  : 		pFile->Write((LPVOID) m_lpBMIH,  nSizeHdr);

  02942	8b f4		 mov	 esi, esp
  02944	8b 4d d0	 mov	 ecx, DWORD PTR _nSizeHdr$[ebp]
  02947	51		 push	 ecx
  02948	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0294b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0294e	50		 push	 eax
  0294f	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  02952	8b 11		 mov	 edx, DWORD PTR [ecx]
  02954	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  02957	ff 52 40	 call	 DWORD PTR [edx+64]
  0295a	3b f4		 cmp	 esi, esp
  0295c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 773  : 		pFile->Write((LPVOID) m_lpImage, m_dwSizeImage);

  02961	8b f4		 mov	 esi, esp
  02963	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  02966	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  02969	51		 push	 ecx
  0296a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0296d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  02970	50		 push	 eax
  02971	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  02974	8b 11		 mov	 edx, DWORD PTR [ecx]
  02976	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  02979	ff 52 40	 call	 DWORD PTR [edx+64]
  0297c	3b f4		 cmp	 esi, esp
  0297e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02983	eb 23		 jmp	 SHORT $L193641
$L193642:

; 774  : 	}
; 775  : 	catch(CException* pe) {
; 776  : 		pe->Delete();

  02985	8b 4d c8	 mov	 ecx, DWORD PTR _pe$192821[ebp]
  02988	e8 00 00 00 00	 call	 ?Delete@CException@@QAEXXZ ; CException::Delete

; 777  : 		AfxMessageBox("write error");

  0298d	6a 00		 push	 0
  0298f	6a 00		 push	 0
  02991	68 00 00 00 00	 push	 OFFSET FLAT:$SG192822
  02996	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 778  : 		return FALSE;

  0299b	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T193640[ebp], 0
  029a2	b8 00 00 00 00	 mov	 eax, $L193644
  029a7	c3		 ret	 0
$L193641:

; 779  : 	}

  029a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 780  : 	return TRUE;

  029af	eb 05		 jmp	 SHORT $L193643
$L193644:

; 778  : 		return FALSE;

  029b1	8b 45 c0	 mov	 eax, DWORD PTR $T193640[ebp]
  029b4	eb 05		 jmp	 SHORT $L192808
$L193643:

; 780  : 	return TRUE;

  029b6	b8 01 00 00 00	 mov	 eax, 1
$L192808:

; 781  : }

  029bb	52		 push	 edx
  029bc	8b cd		 mov	 ecx, ebp
  029be	50		 push	 eax
  029bf	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L193651
  029c5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  029ca	58		 pop	 eax
  029cb	5a		 pop	 edx
  029cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  029cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  029d6	5f		 pop	 edi
  029d7	5e		 pop	 esi
  029d8	5b		 pop	 ebx
  029d9	83 c4 40	 add	 esp, 64			; 00000040H
  029dc	3b ec		 cmp	 ebp, esp
  029de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  029e3	8b e5		 mov	 esp, ebp
  029e5	5d		 pop	 ebp
  029e6	c2 04 00	 ret	 4
$L193651:
  029e9	02 00 00 00	 DD	 2
  029ed	00 00 00 00	 DD	 $L193650
$L193650:
  029f1	d8 ff ff ff	 DD	 -40			; ffffffd8H
  029f5	0e 00 00 00	 DD	 14			; 0000000eH
  029f9	00 00 00 00	 DD	 $L193647
  029fd	c8 ff ff ff	 DD	 -56			; ffffffc8H
  02a01	04 00 00 00	 DD	 4
  02a05	00 00 00 00	 DD	 $L193648
$L193648:
  02a09	70		 DB	 112			; 00000070H
  02a0a	65		 DB	 101			; 00000065H
  02a0b	00		 DB	 0
$L193647:
  02a0c	62		 DB	 98			; 00000062H
  02a0d	6d		 DB	 109			; 0000006dH
  02a0e	66		 DB	 102			; 00000066H
  02a0f	68		 DB	 104			; 00000068H
  02a10	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$?Write@CDib@@IAEHPAVCFile@@@Z:
  00124	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193646
  00129	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Write@CDib@@IAEHPAVCFile@@@Z ENDP			; CDib::Write
EXTRN	?IsStoring@CArchive@@QBEHXZ:NEAR		; CArchive::IsStoring
EXTRN	?GetFile@CArchive@@QBEPAVCFile@@XZ:NEAR		; CArchive::GetFile
EXTRN	?Flush@CArchive@@QAEXXZ:NEAR			; CArchive::Flush
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv83 = -32						; size = 4
tv67 = -28						; size = 4
$T193657 = -24						; size = 8
$T193656 = -16						; size = 8
_dwPos$ = -8						; size = 4
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@CDib@@MAEXAAVCArchive@@@Z PROC NEAR		; CDib::Serialize
; _this$ = ecx

; 784  : {

  02a20	55		 push	 ebp
  02a21	8b ec		 mov	 ebp, esp
  02a23	83 ec 20	 sub	 esp, 32			; 00000020H
  02a26	56		 push	 esi
  02a27	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  02a2c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  02a2f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  02a32	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  02a35	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  02a38	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  02a3b	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  02a3e	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  02a41	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  02a44	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 785  : 	DWORD dwPos;
; 786  : 	dwPos = (DWORD)ar.GetFile()->GetPosition();

  02a47	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  02a4a	e8 00 00 00 00	 call	 ?GetFile@CArchive@@QBEPAVCFile@@XZ ; CArchive::GetFile
  02a4f	89 45 e4	 mov	 DWORD PTR tv67[ebp], eax
  02a52	8b 45 e4	 mov	 eax, DWORD PTR tv67[ebp]
  02a55	8b 10		 mov	 edx, DWORD PTR [eax]
  02a57	8b f4		 mov	 esi, esp
  02a59	8b 4d e4	 mov	 ecx, DWORD PTR tv67[ebp]
  02a5c	ff 52 14	 call	 DWORD PTR [edx+20]
  02a5f	3b f4		 cmp	 esi, esp
  02a61	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02a66	89 45 f8	 mov	 DWORD PTR _dwPos$[ebp], eax

; 787  : 	TRACE("CDib::Serialize -- pos = %d\n", dwPos);

  02a69	8b 45 f8	 mov	 eax, DWORD PTR _dwPos$[ebp]
  02a6c	50		 push	 eax
  02a6d	68 00 00 00 00	 push	 OFFSET FLAT:$SG192832
  02a72	68 13 03 00 00	 push	 787			; 00000313H
  02a77	68 00 00 00 00	 push	 OFFSET FLAT:$SG192831
  02a7c	8d 4d f0	 lea	 ecx, DWORD PTR $T193656[ebp]
  02a7f	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  02a84	50		 push	 eax
  02a85	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  02a8a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 	ar.Flush();

  02a8d	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  02a90	e8 00 00 00 00	 call	 ?Flush@CArchive@@QAEXXZ	; CArchive::Flush

; 789  : 	dwPos = (DWORD)ar.GetFile()->GetPosition();

  02a95	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  02a98	e8 00 00 00 00	 call	 ?GetFile@CArchive@@QBEPAVCFile@@XZ ; CArchive::GetFile
  02a9d	89 45 e0	 mov	 DWORD PTR tv83[ebp], eax
  02aa0	8b 4d e0	 mov	 ecx, DWORD PTR tv83[ebp]
  02aa3	8b 11		 mov	 edx, DWORD PTR [ecx]
  02aa5	8b f4		 mov	 esi, esp
  02aa7	8b 4d e0	 mov	 ecx, DWORD PTR tv83[ebp]
  02aaa	ff 52 14	 call	 DWORD PTR [edx+20]
  02aad	3b f4		 cmp	 esi, esp
  02aaf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02ab4	89 45 f8	 mov	 DWORD PTR _dwPos$[ebp], eax

; 790  : 	TRACE("CDib::Serialize -- pos = %d\n", dwPos);

  02ab7	8b 45 f8	 mov	 eax, DWORD PTR _dwPos$[ebp]
  02aba	50		 push	 eax
  02abb	68 00 00 00 00	 push	 OFFSET FLAT:$SG192836
  02ac0	68 16 03 00 00	 push	 790			; 00000316H
  02ac5	68 00 00 00 00	 push	 OFFSET FLAT:$SG192835
  02aca	8d 4d e8	 lea	 ecx, DWORD PTR $T193657[ebp]
  02acd	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  02ad2	50		 push	 eax
  02ad3	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  02ad8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 791  : 	if(ar.IsStoring()) {

  02adb	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  02ade	e8 00 00 00 00	 call	 ?IsStoring@CArchive@@QBEHXZ ; CArchive::IsStoring
  02ae3	85 c0		 test	 eax, eax
  02ae5	74 13		 je	 SHORT $L192837

; 792  : 		Write(ar.GetFile());

  02ae7	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  02aea	e8 00 00 00 00	 call	 ?GetFile@CArchive@@QBEPAVCFile@@XZ ; CArchive::GetFile
  02aef	50		 push	 eax
  02af0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02af3	e8 00 00 00 00	 call	 ?Write@CDib@@IAEHPAVCFile@@@Z ; CDib::Write

; 793  : 	}
; 794  : 	else {

  02af8	eb 11		 jmp	 SHORT $L192827
$L192837:

; 795  : 		Read(ar.GetFile());

  02afa	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  02afd	e8 00 00 00 00	 call	 ?GetFile@CArchive@@QBEPAVCFile@@XZ ; CArchive::GetFile
  02b02	50		 push	 eax
  02b03	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02b06	e8 00 00 00 00	 call	 ?Read@CDib@@IAEHPAVCFile@@@Z ; CDib::Read
$L192827:

; 796  : 	}
; 797  : }

  02b0b	5e		 pop	 esi
  02b0c	83 c4 20	 add	 esp, 32			; 00000020H
  02b0f	3b ec		 cmp	 ebp, esp
  02b11	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02b16	8b e5		 mov	 esp, ebp
  02b18	5d		 pop	 ebp
  02b19	c2 04 00	 ret	 4
?Serialize@CDib@@MAEXAAVCArchive@@@Z ENDP		; CDib::Serialize
; Function compile flags: /Odt /RTCsu
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_nBitCount$ = 8						; size = 4
?ComputePaletteSize@CDib@@AAEXH@Z PROC NEAR		; CDib::ComputePaletteSize
; _this$ = ecx

; 801  : {

  02b20	55		 push	 ebp
  02b21	8b ec		 mov	 ebp, esp
  02b23	83 ec 08	 sub	 esp, 8
  02b26	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  02b2d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  02b34	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 	if((m_lpBMIH == NULL) || (m_lpBMIH->biClrUsed == 0)) {

  02b37	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02b3a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  02b3e	74 0c		 je	 SHORT $L192844
  02b40	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02b43	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02b46	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  02b4a	75 70		 jne	 SHORT $L192843
$L192844:

; 803  : 		switch(nBitCount) {

  02b4c	8b 45 08	 mov	 eax, DWORD PTR _nBitCount$[ebp]
  02b4f	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  02b52	8b 4d f8	 mov	 ecx, DWORD PTR tv69[ebp]
  02b55	83 e9 01	 sub	 ecx, 1
  02b58	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
  02b5b	83 7d f8 1f	 cmp	 DWORD PTR tv69[ebp], 31	; 0000001fH
  02b5f	77 41		 ja	 SHORT $L192853
  02b61	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  02b64	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $L193662[edx]
  02b6b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L193663[eax*4]
$L192849:

; 804  : 			case 1:
; 805  : 				m_nColorTableEntries = 2;

  02b72	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02b75	c7 41 24 02 00
	00 00		 mov	 DWORD PTR [ecx+36], 2

; 806  : 				break;

  02b7c	eb 3c		 jmp	 SHORT $L192846
$L192850:

; 807  : 			case 4:
; 808  : 				m_nColorTableEntries = 16;

  02b7e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02b81	c7 42 24 10 00
	00 00		 mov	 DWORD PTR [edx+36], 16	; 00000010H

; 809  : 				break;

  02b88	eb 30		 jmp	 SHORT $L192846
$L192851:

; 810  : 			case 8:
; 811  : 				m_nColorTableEntries = 256;

  02b8a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02b8d	c7 40 24 00 01
	00 00		 mov	 DWORD PTR [eax+36], 256	; 00000100H

; 812  : 				break;

  02b94	eb 24		 jmp	 SHORT $L192846
$L192852:

; 813  : 			case 16:
; 814  : 			case 24:
; 815  : 			case 32:
; 816  : 				m_nColorTableEntries = 0;

  02b96	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02b99	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 817  : 				break;

  02ba0	eb 18		 jmp	 SHORT $L192846
$L192853:

; 818  : 			default:
; 819  : 				ASSERT(FALSE);

  02ba2	33 d2		 xor	 edx, edx
  02ba4	75 14		 jne	 SHORT $L192846
  02ba6	68 33 03 00 00	 push	 819			; 00000333H
  02bab	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  02bb0	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  02bb5	85 c0		 test	 eax, eax
  02bb7	74 01		 je	 SHORT $L192846
  02bb9	cc		 int	 3
$L192846:

; 820  : 		}
; 821  : 	}
; 822  : 	else {

  02bba	eb 0f		 jmp	 SHORT $L192855
$L192843:

; 823  : 		m_nColorTableEntries = m_lpBMIH->biClrUsed;

  02bbc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02bbf	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02bc2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02bc5	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  02bc8	89 48 24	 mov	 DWORD PTR [eax+36], ecx
$L192855:

; 824  : 	}
; 825  : 	ASSERT((m_nColorTableEntries >= 0) && (m_nColorTableEntries <= 256)); 

  02bcb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02bce	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  02bd2	7c 0c		 jl	 SHORT $L193660
  02bd4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02bd7	81 78 24 00 01
	00 00		 cmp	 DWORD PTR [eax+36], 256	; 00000100H
  02bde	7e 14		 jle	 SHORT $L192842
$L193660:
  02be0	68 39 03 00 00	 push	 825			; 00000339H
  02be5	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  02bea	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  02bef	85 c0		 test	 eax, eax
  02bf1	74 01		 je	 SHORT $L192842
  02bf3	cc		 int	 3
$L192842:

; 826  : }

  02bf4	83 c4 08	 add	 esp, 8
  02bf7	3b ec		 cmp	 ebp, esp
  02bf9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02bfe	8b e5		 mov	 esp, ebp
  02c00	5d		 pop	 ebp
  02c01	c2 04 00	 ret	 4
$L193663:
  02c04	00 00 00 00	 DD	 $L192849
  02c08	00 00 00 00	 DD	 $L192850
  02c0c	00 00 00 00	 DD	 $L192851
  02c10	00 00 00 00	 DD	 $L192852
  02c14	00 00 00 00	 DD	 $L192853
$L193662:
  02c18	00		 DB	 0
  02c19	04		 DB	 4
  02c1a	04		 DB	 4
  02c1b	01		 DB	 1
  02c1c	04		 DB	 4
  02c1d	04		 DB	 4
  02c1e	04		 DB	 4
  02c1f	02		 DB	 2
  02c20	04		 DB	 4
  02c21	04		 DB	 4
  02c22	04		 DB	 4
  02c23	04		 DB	 4
  02c24	04		 DB	 4
  02c25	04		 DB	 4
  02c26	04		 DB	 4
  02c27	03		 DB	 3
  02c28	04		 DB	 4
  02c29	04		 DB	 4
  02c2a	04		 DB	 4
  02c2b	04		 DB	 4
  02c2c	04		 DB	 4
  02c2d	04		 DB	 4
  02c2e	04		 DB	 4
  02c2f	03		 DB	 3
  02c30	04		 DB	 4
  02c31	04		 DB	 4
  02c32	04		 DB	 4
  02c33	04		 DB	 4
  02c34	04		 DB	 4
  02c35	04		 DB	 4
  02c36	04		 DB	 4
  02c37	03		 DB	 3
?ComputePaletteSize@CDib@@AAEXH@Z ENDP			; CDib::ComputePaletteSize
_TEXT	ENDS
xdata$x	SEGMENT
$T193675 DD	0ffffffffH
	DD	FLAT:$L193671
$T193673 DD	019930520H
	DD	01H
	DD	FLAT:$T193675
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv84 = -44						; size = 4
$T193668 = -40						; size = 4
$T193667 = -36						; size = 4
$T193666 = -32						; size = 4
$T193665 = -28						; size = 8
_dwBytes$192873 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ComputeMetrics@CDib@@AAEXXZ PROC NEAR			; CDib::ComputeMetrics
; _this$ = ecx

; 829  : {

  02c40	55		 push	 ebp
  02c41	8b ec		 mov	 ebp, esp
  02c43	6a ff		 push	 -1
  02c45	68 00 00 00 00	 push	 __ehhandler$?ComputeMetrics@CDib@@AAEXXZ
  02c4a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02c50	50		 push	 eax
  02c51	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02c58	83 ec 20	 sub	 esp, 32			; 00000020H
  02c5b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  02c60	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  02c63	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  02c66	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  02c69	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  02c6c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  02c6f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  02c72	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  02c75	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  02c78	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 830  : 	if(m_lpBMIH->biSize != sizeof(BITMAPINFOHEADER)) {

  02c7b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  02c7e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02c81	83 39 28	 cmp	 DWORD PTR [ecx], 40	; 00000028H
  02c84	74 79		 je	 SHORT $L192861

; 831  : 		TRACE("Not a valid Windows bitmap -- probably an OS/2 bitmap\n");

  02c86	68 00 00 00 00	 push	 OFFSET FLAT:$SG192864
  02c8b	68 3f 03 00 00	 push	 831			; 0000033fH
  02c90	68 00 00 00 00	 push	 OFFSET FLAT:$SG192863
  02c95	8d 4d e4	 lea	 ecx, DWORD PTR $T193665[ebp]
  02c98	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  02c9d	50		 push	 eax
  02c9e	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  02ca3	83 c4 08	 add	 esp, 8

; 832  : 		throw new CUserException;

  02ca6	68 40 03 00 00	 push	 832			; 00000340H
  02cab	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  02cb0	68 a0 00 00 00	 push	 160			; 000000a0H
  02cb5	e8 00 00 00 00	 call	 ??2CObject@@SGPAXIPBDH@Z ; CObject::operator new
  02cba	89 45 d8	 mov	 DWORD PTR $T193668[ebp], eax
  02cbd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  02cc4	83 7d d8 00	 cmp	 DWORD PTR $T193668[ebp], 0
  02cc8	74 0d		 je	 SHORT $L193669
  02cca	8b 4d d8	 mov	 ecx, DWORD PTR $T193668[ebp]
  02ccd	e8 00 00 00 00	 call	 ??0CUserException@@QAE@XZ ; CUserException::CUserException
  02cd2	89 45 d4	 mov	 DWORD PTR tv84[ebp], eax
  02cd5	eb 07		 jmp	 SHORT $L193670
$L193669:
  02cd7	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$L193670:
  02cde	8b 55 d4	 mov	 edx, DWORD PTR tv84[ebp]
  02ce1	89 55 dc	 mov	 DWORD PTR $T193667[ebp], edx
  02ce4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02ceb	8b 45 dc	 mov	 eax, DWORD PTR $T193667[ebp]
  02cee	89 45 e0	 mov	 DWORD PTR $T193666[ebp], eax
  02cf1	68 00 00 00 00	 push	 OFFSET FLAT:__TI5PAVCUserException@@
  02cf6	8d 4d e0	 lea	 ecx, DWORD PTR $T193666[ebp]
  02cf9	51		 push	 ecx
  02cfa	e8 00 00 00 00	 call	 __CxxThrowException@8
$L192861:

; 833  : 	}
; 834  : 	m_dwSizeImage = m_lpBMIH->biSizeImage;

  02cff	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  02d02	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  02d05	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  02d08	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  02d0b	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 835  : 	if(m_dwSizeImage == 0) {

  02d0e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  02d11	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  02d15	75 60		 jne	 SHORT $L192872

; 836  : 		DWORD dwBytes = ((DWORD) m_lpBMIH->biWidth * m_lpBMIH->biBitCount) / 32;

  02d17	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  02d1a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02d1d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  02d20	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02d23	0f b7 41 0e	 movzx	 eax, WORD PTR [ecx+14]
  02d27	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  02d2b	c1 e8 05	 shr	 eax, 5
  02d2e	89 45 ec	 mov	 DWORD PTR _dwBytes$192873[ebp], eax

; 837  : 		if(((DWORD) m_lpBMIH->biWidth * m_lpBMIH->biBitCount) % 32) {

  02d31	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  02d34	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02d37	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  02d3a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02d3d	0f b7 41 0e	 movzx	 eax, WORD PTR [ecx+14]
  02d41	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  02d45	33 d2		 xor	 edx, edx
  02d47	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  02d4c	f7 f1		 div	 ecx
  02d4e	85 d2		 test	 edx, edx
  02d50	74 09		 je	 SHORT $L192876

; 838  : 			dwBytes++;

  02d52	8b 55 ec	 mov	 edx, DWORD PTR _dwBytes$192873[ebp]
  02d55	83 c2 01	 add	 edx, 1
  02d58	89 55 ec	 mov	 DWORD PTR _dwBytes$192873[ebp], edx
$L192876:

; 839  : 		}
; 840  : 		dwBytes *= 4;

  02d5b	8b 45 ec	 mov	 eax, DWORD PTR _dwBytes$192873[ebp]
  02d5e	c1 e0 02	 shl	 eax, 2
  02d61	89 45 ec	 mov	 DWORD PTR _dwBytes$192873[ebp], eax

; 841  : 		m_dwSizeImage = dwBytes * m_lpBMIH->biHeight; // no compression

  02d64	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  02d67	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02d6a	8b 45 ec	 mov	 eax, DWORD PTR _dwBytes$192873[ebp]
  02d6d	0f af 42 08	 imul	 eax, DWORD PTR [edx+8]
  02d71	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  02d74	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$L192872:

; 842  : 	}
; 843  : 	m_lpvColorTable = (LPBYTE) m_lpBMIH + sizeof(BITMAPINFOHEADER);

  02d77	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  02d7a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  02d7d	83 c0 28	 add	 eax, 40			; 00000028H
  02d80	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  02d83	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L193664:

; 844  : }

  02d86	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02d89	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02d90	83 c4 2c	 add	 esp, 44			; 0000002cH
  02d93	3b ec		 cmp	 ebp, esp
  02d95	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02d9a	8b e5		 mov	 esp, ebp
  02d9c	5d		 pop	 ebp
  02d9d	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L193671:
  0012e	68 40 03 00 00	 push	 832			; 00000340H
  00133	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00138	8b 45 d8	 mov	 eax, DWORD PTR $T193668[ebp]
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 ??3CException@@SGXPAXPBDH@Z ; CException::operator delete
  00141	c3		 ret	 0
__ehhandler$?ComputeMetrics@CDib@@AAEXXZ:
  00142	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T193673
  00147	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ComputeMetrics@CDib@@AAEXXZ ENDP			; CDib::ComputeMetrics
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T193678 = -12						; size = 4
$T193677 = -8						; size = 4
_this$ = -4						; size = 4
?Empty@CDib@@QAEXXZ PROC NEAR				; CDib::Empty
; _this$ = ecx

; 847  : {

  02da0	55		 push	 ebp
  02da1	8b ec		 mov	 ebp, esp
  02da3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  02da6	56		 push	 esi
  02da7	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  02dae	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  02db5	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  02dbc	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 848  : 	// this is supposed to clean up whatever is in the DIB
; 849  : 	DetachMapFile();

  02dbf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02dc2	e8 00 00 00 00	 call	 ?DetachMapFile@CDib@@AAEXXZ ; CDib::DetachMapFile

; 850  : 	if(m_nBmihAlloc == crtAlloc) {

  02dc7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02dca	83 78 18 01	 cmp	 DWORD PTR [eax+24], 1
  02dce	75 17		 jne	 SHORT $L192882

; 851  : 		delete [] m_lpBMIH;

  02dd0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02dd3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02dd6	89 55 f8	 mov	 DWORD PTR $T193677[ebp], edx
  02dd9	8b 45 f8	 mov	 eax, DWORD PTR $T193677[ebp]
  02ddc	50		 push	 eax
  02ddd	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  02de2	83 c4 04	 add	 esp, 4

; 852  : 	}
; 853  : 	else if(m_nBmihAlloc == heapAlloc) {

  02de5	eb 35		 jmp	 SHORT $L192884
$L192882:
  02de7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02dea	83 79 18 02	 cmp	 DWORD PTR [ecx+24], 2
  02dee	75 2c		 jne	 SHORT $L192884

; 854  : 		::GlobalUnlock(m_hGlobal);

  02df0	8b f4		 mov	 esi, esp
  02df2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02df5	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  02df8	50		 push	 eax
  02df9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  02dff	3b f4		 cmp	 esi, esp
  02e01	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 855  : 		::GlobalFree(m_hGlobal);

  02e06	8b f4		 mov	 esi, esp
  02e08	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02e0b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  02e0e	52		 push	 edx
  02e0f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  02e15	3b f4		 cmp	 esi, esp
  02e17	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L192884:

; 856  : 	}
; 857  : 	if(m_nImageAlloc == crtAlloc) delete [] m_lpImage;

  02e1c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02e1f	83 78 1c 01	 cmp	 DWORD PTR [eax+28], 1
  02e23	75 15		 jne	 SHORT $L192886
  02e25	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02e28	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  02e2b	89 55 f4	 mov	 DWORD PTR $T193678[ebp], edx
  02e2e	8b 45 f4	 mov	 eax, DWORD PTR $T193678[ebp]
  02e31	50		 push	 eax
  02e32	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  02e37	83 c4 04	 add	 esp, 4
$L192886:

; 858  : 	if(m_hPalette != NULL) ::DeleteObject(m_hPalette);

  02e3a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02e3d	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  02e41	74 16		 je	 SHORT $L192888
  02e43	8b f4		 mov	 esi, esp
  02e45	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02e48	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  02e4b	50		 push	 eax
  02e4c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  02e52	3b f4		 cmp	 esi, esp
  02e54	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L192888:

; 859  : 	if(m_hBitmap != NULL) ::DeleteObject(m_hBitmap);

  02e59	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02e5c	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  02e60	74 16		 je	 SHORT $L192889
  02e62	8b f4		 mov	 esi, esp
  02e64	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02e67	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  02e6a	50		 push	 eax
  02e6b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  02e71	3b f4		 cmp	 esi, esp
  02e73	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L192889:

; 860  : 	m_nBmihAlloc = m_nImageAlloc = noAlloc;

  02e78	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02e7b	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  02e82	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02e85	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 861  : 	m_hGlobal = NULL;

  02e8c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02e8f	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 862  : 	m_lpBMIH = NULL;

  02e96	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02e99	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 863  : 	//m_lpImage = NULL;
; 864  : 	m_lpvColorTable = NULL;

  02ea0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02ea3	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 865  : 	m_nColorTableEntries = 0;

  02eaa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02ead	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 866  : 	m_dwSizeImage = 0;

  02eb4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02eb7	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 867  : 	//m_lpvFile = NULL;
; 868  : 	m_hMap = NULL;

  02ebe	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02ec1	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 869  : 	m_hFile = NULL;

  02ec8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02ecb	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 870  : 	m_hBitmap = NULL;

  02ed2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02ed5	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 871  : 	m_hPalette = NULL;

  02edc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02edf	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 872  : }

  02ee6	5e		 pop	 esi
  02ee7	83 c4 0c	 add	 esp, 12			; 0000000cH
  02eea	3b ec		 cmp	 ebp, esp
  02eec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02ef1	8b e5		 mov	 esp, ebp
  02ef3	5d		 pop	 ebp
  02ef4	c3		 ret	 0
?Empty@CDib@@QAEXXZ ENDP				; CDib::Empty
; Function compile flags: /Odt /RTCsu
_this$ = -4						; size = 4
?DetachMapFile@CDib@@AAEXXZ PROC NEAR			; CDib::DetachMapFile
; _this$ = ecx

; 875  : {

  02f00	55		 push	 ebp
  02f01	8b ec		 mov	 ebp, esp
  02f03	51		 push	 ecx
  02f04	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  02f0b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 876  : 
; 877  : 	return;
; 878  : 	//if(m_hFile == NULL) return;
; 879  : 	//::UnmapViewOfFile(m_lpvFile);
; 880  : 	//::CloseHandle(m_hMap);
; 881  : 	//::CloseHandle(m_hFile);
; 882  : 	//m_hFile = NULL;
; 883  : }

  02f0e	8b e5		 mov	 esp, ebp
  02f10	5d		 pop	 ebp
  02f11	c3		 ret	 0
?DetachMapFile@CDib@@AAEXXZ ENDP			; CDib::DetachMapFile
_TEXT	ENDS
PUBLIC	??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z	; AFX_CLASSINIT::AFX_CLASSINIT
CRT$XCU	SEGMENT
_$S6	DD	FLAT:_$E5
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E5
text$yc	SEGMENT
_$E5	PROC NEAR					; COMDAT

; 13   : IMPLEMENT_SERIAL(CDib, CObject, 0);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 ?GetThisClass@CDib@@SGPAUCRuntimeClass@@XZ ; CDib::GetThisClass
  00008	50		 push	 eax
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?_init_CDib@@3UAFX_CLASSINIT@@A ; _init_CDib
  0000e	e8 00 00 00 00	 call	 ??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z ; AFX_CLASSINIT::AFX_CLASSINIT
  00013	3b ec		 cmp	 ebp, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_$E5	ENDP
text$yc	ENDS
EXTRN	?AfxClassInit@@YGXPAUCRuntimeClass@@@Z:NEAR	; AfxClassInit
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.h
;	COMDAT ??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pNewClass$ = 8						; size = 4
??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z PROC NEAR	; AFX_CLASSINIT::AFX_CLASSINIT, COMDAT
; _this$ = ecx

; 346  : 	{ AFX_CLASSINIT(CRuntimeClass* pNewClass) { AfxClassInit(pNewClass); } };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _pNewClass$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?AfxClassInit@@YGXPAUCRuntimeClass@@@Z ; AfxClassInit
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0AFX_CLASSINIT@@QAE@PAUCRuntimeClass@@@Z ENDP		; AFX_CLASSINIT::AFX_CLASSINIT
_TEXT	ENDS
PUBLIC	?_init_CDib@@3UAFX_CLASSINIT@@A			; _init_CDib
_BSS	SEGMENT
?_init_CDib@@3UAFX_CLASSINIT@@A DB 01H DUP (?)		; _init_CDib
_BSS	ENDS
END
